var v1 = Object.defineProperty;
var y1 = Object.getPrototypeOf;
var x1 = Reflect.get;
var iv = y => {
  throw TypeError(y)
};
var b1 = (y, u, v) => u in y ? v1(y, u, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: v
}) : y[u] = v;
var fi = (y, u, v) => b1(y, typeof u != "symbol" ? u + "" : u, v),
  Zf = (y, u, v) => u.has(y) || iv("Cannot " + v);
var ir = (y, u, v) => (Zf(y, u, "read from private field"), v ? v.call(y) : u.get(y)),
  xi = (y, u, v) => u.has(y) ? iv("Cannot add the same private member more than once") : u instanceof WeakSet ? u.add(y) : u.set(y, v),
  Mn = (y, u, v, b) => (Zf(y, u, "write to private field"), b ? b.call(y, v) : u.set(y, v), v),
  ni = (y, u, v) => (Zf(y, u, "access private method"), v);
var av = (y, u, v) => x1(y1(y), v, u);
import "../chunks/CRtM9yEB.js";
import {
  o as $a,
  a as w1,
  s as Oa
} from "../chunks/D8CaDjpN.js";
import {
  a8 as T1,
  bo as S1,
  bB as P1,
  bq as M1,
  bC as I1,
  aZ as C1,
  bD as A1,
  e as Ke,
  bE as nv,
  a6 as k1,
  j as m,
  i as H,
  b0 as Nu,
  A as Xr,
  b as q,
  p as ri,
  a5 as en,
  bF as Nf,
  bG as E1,
  f as he,
  w as Mi,
  av as Oo,
  a as Ct,
  d as I,
  r as P,
  s as D,
  n as vi,
  c as ii,
  t as Re,
  x as Cn,
  h as Sr,
  bH as sv,
  y as z1,
  bI as L1,
  q as Ba,
  g as _a,
  o as $i,
  u as mt,
  v as oi,
  bz as fp,
  G as jm,
  aG as D1,
  aF as ov,
  aH as R1,
  am as qm,
  bJ as po,
  a_ as Jn,
  bK as t0,
  C as F1,
  $ as B1
} from "../chunks/CYj7RoHR.js";
import {
  s as te,
  c as r0
} from "../chunks/B6QbPa6V.js";
import {
  i as Se
} from "../chunks/Cf5AFK_W.js";
import {
  h as O1
} from "../chunks/CUZkzveP.js";
import {
  d as Lr,
  a as Vr,
  s as Qt,
  g as uo,
  r as Xa,
  f as Vm,
  b as j1,
  e as Ya,
  i as rp,
  c as jo,
  h as em
} from "../chunks/CxnK3XnS.js";
import {
  a as fl,
  t as pn
} from "../chunks/Y97y7iKX.js";
import {
  g as mp,
  b as q1
} from "../chunks/DMPgVYSy.js";
import {
  p as ga
} from "../chunks/DJ4Jv8YE.js";
import {
  g as An,
  P as V1,
  b as i0
} from "../chunks/zg9v6uNP.js";
import {
  S as xn,
  u as Lt,
  t as Nt,
  a as ui,
  a3 as zs,
  V as Z1,
  a4 as N1,
  a5 as U1,
  c as G1,
  a2 as W1,
  m as H1,
  e as $1,
  a6 as X1,
  C as lv,
  a7 as Xd,
  P as Y1
} from "../chunks/C-QWu-_s.js";
import {
  A as ya,
  p as Zm,
  c as tm,
  g as Uf,
  a as K1
} from "../chunks/q3pa11yR.js";
import {
  P as za
} from "../chunks/hPxjenh9.js";
import "../chunks/Sef_6GPL.js";
import {
  e as na,
  i as Lc
} from "../chunks/D8w24C3V.js";
import {
  a as gp,
  b as vl,
  c as Nm
} from "../chunks/CRHmzY0-.js";
import {
  b as Rn
} from "../chunks/CFVLNqmB.js";
import {
  i as Um
} from "../chunks/CM9PaSbx.js";
import {
  r as Er,
  p as rr,
  s as Dc,
  u as cv
} from "../chunks/DCiGwyYv.js";
import {
  C as Ls,
  S as J1,
  U as Q1,
  a as eb
} from "../chunks/D7XmeQ9p.js";
import {
  U as tb,
  A as a0,
  D as n0,
  a as Ip,
  I as rm,
  r as rb,
  P as s0,
  b as ib
} from "../chunks/DBmBYbvw.js";
import {
  c as _p,
  b as o0,
  g as tn,
  a as Cp
} from "../chunks/BUuDGZSZ.js";
import {
  h as Ap
} from "../chunks/B7Ll4qF4.js";
import {
  L as l0
} from "../chunks/DyROykdK.js";
import {
  l as ab,
  g as nb
} from "../chunks/BWURdrR3.js";
import {
  c as Rc
} from "../chunks/Y5aeRNEB.js";
import {
  d as sb,
  p as Gm
} from "../chunks/lKGxW_5r.js";
import {
  cj as ob,
  aQ as c0,
  aq as lb,
  bN as cb,
  F as Wm,
  cl as ub,
  c9 as kp,
  cp as hb,
  aH as db,
  d as pb,
  aZ as Hm,
  c2 as $m,
  c1 as Xm,
  ad as fb,
  _ as mb,
  ac as gb,
  r as u0,
  aN as _b,
  aO as vb,
  L as yb,
  K as xb,
  aL as im,
  e as bb,
  at as wb,
  b4 as Tb,
  aa as Sb,
  o as Pb,
  M as Mb,
  ap as Ib,
  ae as Cb,
  b6 as Ab,
  bQ as kb,
  E as h0,
  ak as Eb,
  aj as zb,
  V as Lb,
  bF as Db,
  al as Rb,
  cn as Fb,
  a5 as Bb,
  a as Ob,
  T as jb,
  aU as qb,
  aW as Vb,
  b1 as Zb,
  P as Nb,
  bh as Ub,
  bo as Gb,
  cq as Wb,
  ce as Hb,
  bp as $b,
  ba as Xb,
  bc as Yb,
  ai as Kb,
  cr as Jb,
  b9 as Qb,
  ah as e2,
  bW as t2,
  h as r2,
  aD as i2,
  b$ as a2,
  bq as n2,
  bx as d0,
  bZ as s2,
  u as o2,
  a4 as l2,
  cm as c2,
  ck as u2,
  ar as h2,
  aP as d2,
  J as Ym,
  bn as p0,
  I as p2,
  bz as f2,
  by as m2,
  bk as Sc,
  bf as Pc,
  bm as g2,
  bl as _2,
  b7 as f0,
  aE as v2,
  bB as uv,
  bC as hv,
  bD as y2,
  aY as x2,
  j as dv,
  k as pv,
  bA as fv,
  l as mv,
  bd as m0,
  b3 as Ep,
  aV as b2,
  aX as w2,
  be as T2,
  D as S2,
  ca as g0,
  cf as P2,
  bw as M2,
  bH as I2,
  bI as C2,
  bj as A2,
  C as k2,
  bb as E2,
  s as z2,
  c7 as L2,
  c8 as D2,
  i as R2,
  c5 as F2,
  bY as B2,
  cs as O2,
  p as j2,
  m as q2,
  n as V2,
  b as Z2,
  O as am,
  q as N2,
  c3 as U2,
  c0 as G2,
  cc as W2,
  cd as H2,
  aC as $2,
  bE as X2,
  bM as gv,
  a7 as Y2,
  z as K2,
  cw as J2,
  b2 as Q2,
  aR as ew,
  aS as tw,
  a8 as rw,
  aT as iw,
  a6 as aw,
  Z as nw,
  v as sw,
  W as ow,
  w as lw,
  aM as cw,
  bR as uw,
  aI as hw,
  bs as dw,
  y as pw,
  R as fw,
  aw as mw,
  ch as gw,
  cg as _w,
  aB as vw,
  H as yw,
  bV as xw,
  aF as bw,
  aG as ww,
  x as Tw,
  ci as Sw,
  aJ as Pw,
  c6 as Mw,
  au as Iw,
  N as Cw,
  bU as Aw,
  af as kw,
  G as Ew,
  ao as zw,
  c4 as Lw,
  co as Dw,
  cv as Rw,
  t as _v,
  bu as Fw,
  bt as Bw,
  a_ as Ow,
  a$ as jw,
  bJ as qw,
  bG as Vw,
  bK as Zw,
  bP as Nw,
  ay as Uw,
  ax as Gw,
  av as Ww,
  a0 as Hw,
  b5 as $w,
  $ as Xw,
  bg as Yw,
  B as Kw,
  A as Jw,
  a3 as Qw,
  S as e5,
  bS as t5,
  bT as r5,
  b0 as i5,
  U as a5,
  a9 as n5,
  Y as s5,
  X as o5,
  a2 as l5,
  a1 as c5,
  f as u5,
  g as h5,
  bX as _0,
  as as d5,
  ab as p5,
  br as f5,
  c as m5,
  am as g5,
  bv as _5,
  aK as v5,
  cx as y5,
  cz as x5,
  bO as b5,
  Q as w5,
  cb as T5,
  cu as S5,
  b_ as P5,
  aA as M5,
  an as I5,
  ag as C5,
  b8 as A5,
  cy as k5,
  bi as vv,
  az as E5,
  ct as z5,
  bL as L5
} from "../chunks/DlQzzbT7.js";
import {
  f as nm,
  g as zp,
  s as D5,
  e as R5,
  l as v0,
  d as F5,
  b as B5,
  c as O5,
  z as j5,
  y as q5,
  x as V5,
  m as yv,
  a as Z5,
  p as N5,
  u as U5,
  t as xv
} from "../chunks/BO5EwNhv.js";
import {
  P as Dn,
  t as G5
} from "../chunks/Wy2m_iew.js";
import {
  L as Lp
} from "../chunks/C_8KOCN8.js";
import {
  l as W5,
  v as H5,
  a as y0,
  s as x0
} from "../chunks/DNxAlxOf.js";
import {
  p as Km,
  m as b0
} from "../chunks/BTC0_9Y1.js";
import {
  f as ml
} from "../chunks/B5XmZCie.js";
import {
  k as Ec
} from "../chunks/BZosarym.js";
import {
  A as w0
} from "../chunks/BcZvx3GI.js";
import {
  b as Jm
} from "../chunks/Ci4Ak25d.js";
import {
  u as $5
} from "../chunks/PmKA_hZj.js";
import {
  u as X5
} from "../chunks/yF3c-AM3.js";
import {
  E as sm,
  D as Qm,
  a as bv,
  W as Y5,
  b as K5,
  R as J5
} from "../chunks/ZD6Vp4g6.js";
import {
  l as eg
} from "../chunks/CkRgT60A.js";
import {
  f as Kn,
  s as ip
} from "../chunks/BmWly3c3.js";
import {
  C as tg
} from "../chunks/DzGjbc5h.js";
import {
  L as T0
} from "../chunks/C1LsjeJg.js";
import {
  t as Q5,
  r as S0,
  g as e3
} from "../chunks/DC17ucEm.js";
import {
  c as co
} from "../chunks/CRRxHBZH.js";
import {
  c as yn
} from "../chunks/_dL0S2Nq.js";
import {
  a as P0
} from "../chunks/DqaH9GUQ.js";
import {
  L as t3
} from "../chunks/DXslYFsN.js";
import {
  e as r3,
  p as i3,
  a as a3
} from "../chunks/CLqvEatA.js";
import {
  b as n3
} from "../chunks/DOOkcyPP.js";
import {
  c as M0
} from "../chunks/DAe61g9Q.js";
import {
  e as s3
} from "../chunks/CfoJd_zW.js";
import {
  a as o3
} from "../chunks/WKB77N50.js";
import {
  d as l3
} from "../chunks/B-cwZVZd.js";
import {
  r as c3
} from "../chunks/D8_tCN9s.js";
import {
  R as I0
} from "../chunks/TF0eA8Ac.js";
import {
  T as Xu,
  G as vp
} from "../chunks/Cd4mbsP_.js";
import {
  t as C0
} from "../chunks/D5lq4OQm.js";
import {
  C as u3
} from "../chunks/CGg-aUhi.js";
import {
  c as h3
} from "../chunks/BgybBRjc.js";
import {
  R as d3
} from "../chunks/Dnj6N6bn.js";
import {
  W as p3
} from "../chunks/Dz0e7R2r.js";
import {
  r as f3
} from "../chunks/KBO-xTnE.js";
(function() {
  try {
    var y = typeof window < "u" ? window : typeof global < "u" ? global : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {};
    y.SENTRY_RELEASE = {
      id: "57f41670f2805f713b0da8f3636738eb734a70e1"
    }
  } catch {}
})();
try {
  (function() {
    var y = typeof window < "u" ? window : typeof global < "u" ? global : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {},
      u = new y.Error().stack;
    u && (y._sentryDebugIds = y._sentryDebugIds || {}, y._sentryDebugIds[u] = "908a4261-1d47-4ac0-9491-ae76046791af", y._sentryDebugIdIdentifier = "sentry-dbid-908a4261-1d47-4ac0-9491-ae76046791af")
  })()
} catch {}
const m3 = [];

function g3(y, u = !1, v = !1) {
  return ap(y, new Map, "", m3, null, v)
}

function ap(y, u, v, b, k = null, z = !1) {
  if (typeof y == "object" && y !== null) {
    var T = u.get(y);
    if (T !== void 0) return T;
    if (y instanceof Map) return new Map(y);
    if (y instanceof Set) return new Set(y);
    if (T1(y)) {
      var s = Array(y.length);
      u.set(y, s), k !== null && u.set(k, s);
      for (var B = 0; B < y.length; B += 1) {
        var W = y[B];
        B in y && (s[B] = ap(W, u, v, b, null, z))
      }
      return s
    }
    if (S1(y) === P1) {
      s = {}, u.set(y, s), k !== null && u.set(k, s);
      for (var ee in y) s[ee] = ap(y[ee], u, v, b, null, z);
      return s
    }
    if (y instanceof Date) return structuredClone(y);
    if (typeof y.toJSON == "function" && !z) return ap(y.toJSON(), u, v, b, y)
  }
  if (y instanceof EventTarget) return y;
  try {
    return structuredClone(y)
  } catch {
    return y
  }
}

function _3() {
  return Symbol(M1)
}

function Ch(y, u) {
  I1(window, ["resize"], () => C1(() => u(window[y])))
}

function v3(y) {
  return function(...u) {
    var v = u[0];
    return v.preventDefault(), y == null ? void 0 : y.apply(this, u)
  }
}
const y3 = A1;
var ks, Es, oo, Sp, bs, Uu, np;
const fg = class fg extends Map {
  constructor(v) {
    super();
    xi(this, bs);
    xi(this, ks, new Map);
    xi(this, Es, Ke(0));
    xi(this, oo, Ke(0));
    xi(this, Sp, nv || -1);
    if (v) {
      for (var [b, k] of v) super.set(b, k);
      ir(this, oo).v = super.size
    }
  }
  has(v) {
    var b = ir(this, ks),
      k = b.get(v);
    if (k === void 0) {
      var z = super.get(v);
      if (z !== void 0) k = ni(this, bs, Uu).call(this, 0), b.set(v, k);
      else return m(ir(this, Es)), !1
    }
    return m(k), !0
  }
  forEach(v, b) {
    ni(this, bs, np).call(this), super.forEach(v, b)
  }
  get(v) {
    var b = ir(this, ks),
      k = b.get(v);
    if (k === void 0) {
      var z = super.get(v);
      if (z !== void 0) k = ni(this, bs, Uu).call(this, 0), b.set(v, k);
      else {
        m(ir(this, Es));
        return
      }
    }
    return m(k), super.get(v)
  }
  set(v, b) {
    var $;
    var k = ir(this, ks),
      z = k.get(v),
      T = super.get(v),
      s = super.set(v, b),
      B = ir(this, Es);
    if (z === void 0) z = ni(this, bs, Uu).call(this, 0), k.set(v, z), H(ir(this, oo), super.size), Nu(B);
    else if (T !== b) {
      Nu(z);
      var W = B.reactions === null ? null : new Set(B.reactions),
        ee = W === null || !(($ = z.reactions) != null && $.every(oe => W.has(oe)));
      ee && Nu(B)
    }
    return s
  }
  delete(v) {
    var b = ir(this, ks),
      k = b.get(v),
      z = super.delete(v);
    return k !== void 0 && (b.delete(v), H(ir(this, oo), super.size), H(k, -1), Nu(ir(this, Es))), z
  }
  clear() {
    if (super.size !== 0) {
      super.clear();
      var v = ir(this, ks);
      H(ir(this, oo), 0);
      for (var b of v.values()) H(b, -1);
      Nu(ir(this, Es)), v.clear()
    }
  }
  keys() {
    return m(ir(this, Es)), super.keys()
  }
  values() {
    return ni(this, bs, np).call(this), super.values()
  }
  entries() {
    return ni(this, bs, np).call(this), super.entries()
  } [Symbol.iterator]() {
    return this.entries()
  }
  get size() {
    return m(ir(this, oo)), super.size
  }
};
ks = new WeakMap, Es = new WeakMap, oo = new WeakMap, Sp = new WeakMap, bs = new WeakSet, Uu = function(v) {
  return nv === ir(this, Sp) ? Ke(v) : k1(v)
}, np = function() {
  m(ir(this, Es));
  var v = ir(this, ks);
  if (ir(this, oo).v !== v.size) {
    for (var b of av(fg.prototype, this, "keys").call(this))
      if (!v.has(b)) {
        var k = ni(this, bs, Uu).call(this, 0);
        v.set(b, k)
      }
  }
  for ([, k] of ir(this, ks)) m(k)
};
let yp = fg;
const ao = 2 * Math.PI * 6378137 / 2;
class kn {
  constructor(u = 256) {
    fi(this, "initialResolution");
    this.tileSize = u, this.initialResolution = 2 * ao / this.tileSize
  }
  latLonToMeters(u, v) {
    const b = v / 180 * ao,
      k = Math.log(Math.tan((90 + u) * Math.PI / 360)) / (Math.PI / 180) * ao / 180;
    return [b, k]
  }
  metersToLatLon(u, v) {
    const b = u / ao * 180;
    let k = v / ao * 180;
    return k = 180 / Math.PI * (2 * Math.atan(Math.exp(k * Math.PI / 180)) - Math.PI / 2), [k, b]
  }
  pixelsToMeters(u, v, b) {
    const k = this.resolution(b),
      z = u * k - ao,
      T = ao - v * k;
    return [z, T]
  }
  pixelsToLatLon(u, v, b) {
    const [k, z] = this.pixelsToMeters(u, v, b);
    return this.metersToLatLon(k, z)
  }
  latLonToPixels(u, v, b) {
    const [k, z] = this.latLonToMeters(u, v);
    return this.metersToPixels(k, z, b)
  }
  latLonToPixelsFloor(u, v, b) {
    const [k, z] = this.latLonToPixels(u, v, b);
    return [Math.floor(k), Math.floor(z)]
  }
  metersToPixels(u, v, b) {
    const k = this.resolution(b),
      z = (u + ao) / k,
      T = (ao - v) / k;
    return [z, T]
  }
  latLonToTile(u, v, b) {
    const [k, z] = this.latLonToMeters(u, v);
    return this.metersToTile(k, z, b)
  }
  metersToTile(u, v, b) {
    const [k, z] = this.metersToPixels(u, v, b);
    return this.pixelsToTile(k, z)
  }
  pixelsToTile(u, v) {
    const b = Math.ceil(u / this.tileSize) - 1,
      k = Math.ceil(v / this.tileSize) - 1;
    return [b, k]
  }
  pixelsToTileLocal(u, v) {
    return {
      tile: this.pixelsToTile(u, v),
      pixel: [Math.floor(u) % this.tileSize, Math.floor(v) % this.tileSize]
    }
  }
  tileBounds(u, v, b) {
    const [k, z] = this.pixelsToMeters(u * this.tileSize, v * this.tileSize, b), [T, s] = this.pixelsToMeters((u + 1) * this.tileSize, (v + 1) * this.tileSize, b);
    return {
      min: [k, z],
      max: [T, s]
    }
  }
  tileBoundsLatLon(u, v, b) {
    const k = this.tileBounds(u, v, b);
    return {
      min: this.metersToLatLon(k.min[0], k.min[1]),
      max: this.metersToLatLon(k.max[0], k.max[1])
    }
  }
  resolution(u) {
    return this.initialResolution / 2 ** u
  }
  latLonToTileAndPixel(u, v, b) {
    const [k, z] = this.latLonToMeters(u, v), [T, s] = this.metersToTile(k, z, b), [B, W] = this.metersToPixels(k, z, b);
    return {
      tile: [T, s],
      pixel: [Math.floor(B) % this.tileSize, Math.floor(W) % this.tileSize]
    }
  }
  pixelBounds(u, v, b) {
    return {
      min: this.pixelsToMeters(u, v, b),
      max: this.pixelsToMeters(u + 1, v + 1, b)
    }
  }
  pixelToBoundsLatLon(u, v, b) {
    const k = this.pixelBounds(u, v, b),
      z = .001885,
      T = (k.max[0] - k.min[0]) * z,
      s = (k.max[1] - k.min[1]) * z;
    return k.min[0] -= T, k.max[0] -= T, k.min[1] -= s, k.max[1] -= s, {
      min: this.metersToLatLon(k.min[0], k.min[1]),
      max: this.metersToLatLon(k.max[0], k.max[1])
    }
  }
  latLonToTileBoundsLatLon(u, v, b) {
    const [k, z] = this.latLonToMeters(u, v), [T, s] = this.metersToTile(k, z, b);
    return this.tileBoundsLatLon(T, s, b)
  }
  latLonToPixelBoundsLatLon(u, v, b) {
    const [k, z] = this.latLonToMeters(u, v), [T, s] = this.metersToPixels(k, z, b);
    return this.pixelToBoundsLatLon(Math.floor(T), Math.floor(s), b)
  }
  latLonToRegionAndPixel(u, v, b, k = xn.regionSize) {
    const [z, T] = this.latLonToPixelsFloor(u, v, b), s = this.tileSize * k;
    return {
      region: [Math.floor(z / s), Math.floor(T / s)],
      pixel: [z % s, T % s]
    }
  }
}

function rg(y, u = !0) {
  const {
    min: v,
    max: b
  } = y;
  return u ? [
    [v[1], b[0]],
    [b[1], b[0]],
    [b[1], v[0]],
    [v[1], v[0]]
  ] : [
    [v[0], b[1]],
    [b[0], b[1]],
    [b[0], v[1]],
    [v[0], v[1]]
  ]
}

function ig(y) {
  return [(y.min[0] + y.max[0]) / 2, (y.min[1] + y.max[1]) / 2]
}
const x3 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAAAAACoWZBhAAAAAXNSR0IArs4c6QAAACpJREFUeNpj+AsEZ86ASIa/DAwMZ84ACRDzDBigMs/AARITq1oUwxBWAADaREUdDMswKwAAAABJRU5ErkJggg==",
  wv = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAACVJREFUeNpj+A8FDEAAZwMRBAIBmIYLIgHcgkQDIs3E6SRsjgcABYFLtfTgakEAAAAASUVORK5CYII=";

function b3(y) {
  return Math.floor(Math.random() * y)
}
const om = 14.5;
async function w3() {
  const y = S3();
  if (y) return y;
  try {
    if ((await navigator.permissions.query({
        name: "geolocation"
      })).state === "granted") {
      const v = await new Promise((b, k) => navigator.geolocation.getCurrentPosition(z => b(z), z => k(z)));
      return {
        lat: v.coords.latitude,
        lng: v.coords.longitude,
        zoom: om
      }
    }
  } catch (u) {
    console.error(u)
  }
  return {
    ...T3().pos,
    zoom: om
  }
}

function T3() {
  const y = Object.entries(A0),
    u = b3(y.length),
    [v, b] = y[u];
  return {
    city: v,
    pos: b
  }
}
const A0 = {
    tokyo: {
      lat: 35.677545560719665,
      lng: 139.76394445809638
    },
    paris: {
      lat: 48.8537151734952,
      lng: 2.3484026030630787
    },
    newYork: {
      lat: 40.71283173786517,
      lng: -74.00599771376795
    },
    saoPaulo: {
      lat: -23.550584064565356,
      lng: -46.63339720713918
    },
    sydney: {
      lat: -33.86943325619071,
      lng: 151.2083447239608
    }
  },
  k0 = "location";

function no(y, u) {
  localStorage.setItem(k0, JSON.stringify({
    ...y,
    zoom: u
  }))
}

function S3() {
  const y = localStorage.getItem(k0);
  if (!y) return;
  const u = JSON.parse(y);
  return u.zoom ?? (u.zoom = om), u
}

function P3(y) {
  return y.lat >= -90 && y.lat <= 90 && y.lng >= -180 && y.lng <= 180
}
var Qu, eh;
class M3 {
  constructor() {
    xi(this, Qu, Ke(-1));
    xi(this, eh, Ke([]))
  }
  get idx() {
    return m(ir(this, Qu))
  }
  set idx(u) {
    H(ir(this, Qu), u, !0)
  }
  get entries() {
    return m(ir(this, eh))
  }
  set entries(u) {
    H(ir(this, eh), u)
  }
  hasNext() {
    return this.idx < this.entries.length - 1
  }
  goToNext(u) {
    const v = this.idx + 1,
      b = this.entries[v];
    b && (this.idx = v, u.flyTo({
      center: b.pos,
      zoom: b.zoom
    }))
  }
  hasPrev() {
    return this.idx > 0
  }
  goToPrev(u) {
    const v = this.idx - 1,
      b = this.entries[v];
    b && (this.idx = v, u.flyTo({
      center: b.pos,
      zoom: b.zoom
    }))
  }
  isEmpty() {
    return this.entries.length === 0
  }
  push(u) {
    this.idx = this.idx + 1, this.entries = [...this.entries.slice(0, this.idx), u]
  }
}
Qu = new WeakMap, eh = new WeakMap;
const I3 = new M3;

function C3(y) {
  return y && y.__esModule && Object.prototype.hasOwnProperty.call(y, "default") ? y.default : y
}
var sp = {
  exports: {}
};
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.11.0/LICENSE.txt
 */
var A3 = sp.exports,
  Tv;

function k3() {
  return Tv || (Tv = 1, (function(y, u) {
    (function(v, b) {
      y.exports = b()
    })(A3, (function() {
      var v = {},
        b = {};

      function k(T, s, B) {
        if (b[T] = B, T === "index") {
          var W = "var sharedModule = {}; (" + b.shared + ")(sharedModule); (" + b.worker + ")(sharedModule);",
            ee = {};
          return b.shared(ee), b.index(v, ee), typeof window < "u" && v.setWorkerUrl(window.URL.createObjectURL(new Blob([W], {
            type: "text/javascript"
          }))), v
        }
      }
      k("shared", ["exports"], (function(T) {
        function s(i, t, r, n) {
          return new(r || (r = Promise))((function(l, p) {
            function f(M) {
              try {
                x(n.next(M))
              } catch (C) {
                p(C)
              }
            }

            function _(M) {
              try {
                x(n.throw(M))
              } catch (C) {
                p(C)
              }
            }

            function x(M) {
              var C;
              M.done ? l(M.value) : (C = M.value, C instanceof r ? C : new r((function(L) {
                L(C)
              }))).then(f, _)
            }
            x((n = n.apply(i, t || [])).next())
          }))
        }

        function B(i, t) {
          this.x = i, this.y = t
        }

        function W(i) {
          return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i
        }
        var ee, $;
        typeof SuppressedError == "function" && SuppressedError, B.prototype = {
          clone() {
            return new B(this.x, this.y)
          },
          add(i) {
            return this.clone()._add(i)
          },
          sub(i) {
            return this.clone()._sub(i)
          },
          multByPoint(i) {
            return this.clone()._multByPoint(i)
          },
          divByPoint(i) {
            return this.clone()._divByPoint(i)
          },
          mult(i) {
            return this.clone()._mult(i)
          },
          div(i) {
            return this.clone()._div(i)
          },
          rotate(i) {
            return this.clone()._rotate(i)
          },
          rotateAround(i, t) {
            return this.clone()._rotateAround(i, t)
          },
          matMult(i) {
            return this.clone()._matMult(i)
          },
          unit() {
            return this.clone()._unit()
          },
          perp() {
            return this.clone()._perp()
          },
          round() {
            return this.clone()._round()
          },
          mag() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
          },
          equals(i) {
            return this.x === i.x && this.y === i.y
          },
          dist(i) {
            return Math.sqrt(this.distSqr(i))
          },
          distSqr(i) {
            const t = i.x - this.x,
              r = i.y - this.y;
            return t * t + r * r
          },
          angle() {
            return Math.atan2(this.y, this.x)
          },
          angleTo(i) {
            return Math.atan2(this.y - i.y, this.x - i.x)
          },
          angleWith(i) {
            return this.angleWithSep(i.x, i.y)
          },
          angleWithSep(i, t) {
            return Math.atan2(this.x * t - this.y * i, this.x * i + this.y * t)
          },
          _matMult(i) {
            const t = i[2] * this.x + i[3] * this.y;
            return this.x = i[0] * this.x + i[1] * this.y, this.y = t, this
          },
          _add(i) {
            return this.x += i.x, this.y += i.y, this
          },
          _sub(i) {
            return this.x -= i.x, this.y -= i.y, this
          },
          _mult(i) {
            return this.x *= i, this.y *= i, this
          },
          _div(i) {
            return this.x /= i, this.y /= i, this
          },
          _multByPoint(i) {
            return this.x *= i.x, this.y *= i.y, this
          },
          _divByPoint(i) {
            return this.x /= i.x, this.y /= i.y, this
          },
          _unit() {
            return this._div(this.mag()), this
          },
          _perp() {
            const i = this.y;
            return this.y = this.x, this.x = -i, this
          },
          _rotate(i) {
            const t = Math.cos(i),
              r = Math.sin(i),
              n = r * this.x + t * this.y;
            return this.x = t * this.x - r * this.y, this.y = n, this
          },
          _rotateAround(i, t) {
            const r = Math.cos(i),
              n = Math.sin(i),
              l = t.y + n * (this.x - t.x) + r * (this.y - t.y);
            return this.x = t.x + r * (this.x - t.x) - n * (this.y - t.y), this.y = l, this
          },
          _round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
          },
          constructor: B
        }, B.convert = function(i) {
          if (i instanceof B) return i;
          if (Array.isArray(i)) return new B(+i[0], +i[1]);
          if (i.x !== void 0 && i.y !== void 0) return new B(+i.x, +i.y);
          throw new Error("Expected [x, y] or {x, y} point format")
        };
        var oe = (function() {
            if ($) return ee;

            function i(t, r, n, l) {
              this.cx = 3 * t, this.bx = 3 * (n - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * r, this.by = 3 * (l - r) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = r, this.p2x = n, this.p2y = l
            }
            return $ = 1, ee = i, i.prototype = {
              sampleCurveX: function(t) {
                return ((this.ax * t + this.bx) * t + this.cx) * t
              },
              sampleCurveY: function(t) {
                return ((this.ay * t + this.by) * t + this.cy) * t
              },
              sampleCurveDerivativeX: function(t) {
                return (3 * this.ax * t + 2 * this.bx) * t + this.cx
              },
              solveCurveX: function(t, r) {
                if (r === void 0 && (r = 1e-6), t < 0) return 0;
                if (t > 1) return 1;
                for (var n = t, l = 0; l < 8; l++) {
                  var p = this.sampleCurveX(n) - t;
                  if (Math.abs(p) < r) return n;
                  var f = this.sampleCurveDerivativeX(n);
                  if (Math.abs(f) < 1e-6) break;
                  n -= p / f
                }
                var _ = 0,
                  x = 1;
                for (n = t, l = 0; l < 20 && (p = this.sampleCurveX(n), !(Math.abs(p - t) < r)); l++) t > p ? _ = n : x = n, n = .5 * (x - _) + _;
                return n
              },
              solve: function(t, r) {
                return this.sampleCurveY(this.solveCurveX(t, r))
              }
            }, ee
          })(),
          me = W(oe);
        let _e, Z;

        function Ie() {
          return _e == null && (_e = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), _e
        }

        function we() {
          if (Z == null && (Z = !1, Ie())) {
            const t = new OffscreenCanvas(5, 5).getContext("2d", {
              willReadFrequently: !0
            });
            if (t) {
              for (let n = 0; n < 25; n++) {
                const l = 4 * n;
                t.fillStyle = `rgb(${l},${l+1},${l+2})`, t.fillRect(n % 5, Math.floor(n / 5), 1, 1)
              }
              const r = t.getImageData(0, 0, 5, 5).data;
              for (let n = 0; n < 100; n++)
                if (n % 4 != 3 && r[n] !== n) {
                  Z = !0;
                  break
                }
            }
          }
          return Z || !1
        }
        var Fe = 1e-6,
          xe = typeof Float32Array < "u" ? Float32Array : Array;

        function $e() {
          var i = new xe(9);
          return xe != Float32Array && (i[1] = 0, i[2] = 0, i[3] = 0, i[5] = 0, i[6] = 0, i[7] = 0), i[0] = 1, i[4] = 1, i[8] = 1, i
        }

        function et(i) {
          return i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i
        }

        function Xe() {
          var i = new xe(3);
          return xe != Float32Array && (i[0] = 0, i[1] = 0, i[2] = 0), i
        }

        function Ae(i) {
          var t = i[0],
            r = i[1],
            n = i[2];
          return Math.sqrt(t * t + r * r + n * n)
        }

        function De(i, t, r) {
          var n = new xe(3);
          return n[0] = i, n[1] = t, n[2] = r, n
        }

        function Ye(i, t, r) {
          return i[0] = t[0] + r[0], i[1] = t[1] + r[1], i[2] = t[2] + r[2], i
        }

        function Le(i, t, r) {
          return i[0] = t[0] * r, i[1] = t[1] * r, i[2] = t[2] * r, i
        }

        function qe(i, t, r) {
          var n = t[0],
            l = t[1],
            p = t[2],
            f = r[0],
            _ = r[1],
            x = r[2];
          return i[0] = l * x - p * _, i[1] = p * f - n * x, i[2] = n * _ - l * f, i
        }
        var _t, Qe = Ae;

        function Ge(i, t, r) {
          var n = t[0],
            l = t[1],
            p = t[2],
            f = t[3];
          return i[0] = r[0] * n + r[4] * l + r[8] * p + r[12] * f, i[1] = r[1] * n + r[5] * l + r[9] * p + r[13] * f, i[2] = r[2] * n + r[6] * l + r[10] * p + r[14] * f, i[3] = r[3] * n + r[7] * l + r[11] * p + r[15] * f, i
        }

        function ft() {
          var i = new xe(4);
          return xe != Float32Array && (i[0] = 0, i[1] = 0, i[2] = 0), i[3] = 1, i
        }

        function Vt(i, t, r, n) {
          var l = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "zyx",
            p = Math.PI / 360;
          t *= p, n *= p, r *= p;
          var f = Math.sin(t),
            _ = Math.cos(t),
            x = Math.sin(r),
            M = Math.cos(r),
            C = Math.sin(n),
            L = Math.cos(n);
          switch (l) {
            case "xyz":
              i[0] = f * M * L + _ * x * C, i[1] = _ * x * L - f * M * C, i[2] = _ * M * C + f * x * L, i[3] = _ * M * L - f * x * C;
              break;
            case "xzy":
              i[0] = f * M * L - _ * x * C, i[1] = _ * x * L - f * M * C, i[2] = _ * M * C + f * x * L, i[3] = _ * M * L + f * x * C;
              break;
            case "yxz":
              i[0] = f * M * L + _ * x * C, i[1] = _ * x * L - f * M * C, i[2] = _ * M * C - f * x * L, i[3] = _ * M * L + f * x * C;
              break;
            case "yzx":
              i[0] = f * M * L + _ * x * C, i[1] = _ * x * L + f * M * C, i[2] = _ * M * C - f * x * L, i[3] = _ * M * L - f * x * C;
              break;
            case "zxy":
              i[0] = f * M * L - _ * x * C, i[1] = _ * x * L + f * M * C, i[2] = _ * M * C + f * x * L, i[3] = _ * M * L - f * x * C;
              break;
            case "zyx":
              i[0] = f * M * L - _ * x * C, i[1] = _ * x * L + f * M * C, i[2] = _ * M * C - f * x * L, i[3] = _ * M * L + f * x * C;
              break;
            default:
              throw new Error("Unknown angle order " + l)
          }
          return i
        }

        function Et() {
          var i = new xe(2);
          return xe != Float32Array && (i[0] = 0, i[1] = 0), i
        }

        function Pt(i, t) {
          var r = new xe(2);
          return r[0] = i, r[1] = t, r
        }
        Xe(), _t = new xe(4), xe != Float32Array && (_t[0] = 0, _t[1] = 0, _t[2] = 0, _t[3] = 0), Xe(), De(1, 0, 0), De(0, 1, 0), ft(), ft(), $e(), Et();
        const ot = 8192;

        function Ht(i, t, r) {
          return t * (ot / (i.tileSize * Math.pow(2, r - i.tileID.overscaledZ)))
        }

        function vt(i, t) {
          return (i % t + t) % t
        }

        function Dt(i, t, r) {
          return i * (1 - r) + t * r
        }

        function Rt(i) {
          if (i <= 0) return 0;
          if (i >= 1) return 1;
          const t = i * i,
            r = t * i;
          return 4 * (i < .5 ? r : 3 * (i - t) + r - .75)
        }

        function $t(i, t, r, n) {
          const l = new me(i, t, r, n);
          return p => l.solve(p)
        }
        const pr = $t(.25, .1, .25, 1);

        function Xt(i, t, r) {
          return Math.min(r, Math.max(t, i))
        }

        function or(i, t, r) {
          const n = r - t,
            l = ((i - t) % n + n) % n + t;
          return l === t ? r : l
        }

        function nt(i, ...t) {
          for (const r of t)
            for (const n in r) i[n] = r[n];
          return i
        }
        let rt = 1;

        function Zt(i, t, r) {
          const n = {};
          for (const l in i) n[l] = t.call(this, i[l], l, i);
          return n
        }

        function Jt(i, t, r) {
          const n = {};
          for (const l in i) t.call(this, i[l], l, i) && (n[l] = i[l]);
          return n
        }

        function Ot(i) {
          return Array.isArray(i) ? i.map(Ot) : typeof i == "object" && i ? Zt(i, Ot) : i
        }
        const mr = {};

        function At(i) {
          mr[i] || (typeof console < "u" && console.warn(i), mr[i] = !0)
        }

        function Mt(i, t, r) {
          return (r.y - i.y) * (t.x - i.x) > (t.y - i.y) * (r.x - i.x)
        }

        function wt(i) {
          return typeof WorkerGlobalScope < "u" && i !== void 0 && i instanceof WorkerGlobalScope
        }
        let It = null;

        function Ut(i) {
          if (It == null) {
            const t = i.navigator ? i.navigator.userAgent : null;
            It = !!i.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome")))
          }
          return It
        }

        function ut(i) {
          return typeof ImageBitmap < "u" && i instanceof ImageBitmap
        }
        const ur = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";

        function br(i, t, r, n, l) {
          return s(this, void 0, void 0, (function*() {
            if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
            const p = new VideoFrame(i, {
              timestamp: 0
            });
            try {
              const f = p == null ? void 0 : p.format;
              if (!f || !f.startsWith("BGR") && !f.startsWith("RGB")) throw new Error(`Unrecognized format ${f}`);
              const _ = f.startsWith("BGR"),
                x = new Uint8ClampedArray(n * l * 4);
              if (yield p.copyTo(x, (function(M, C, L, O, N) {
                  const G = 4 * Math.max(-C, 0),
                    K = (Math.max(0, L) - L) * O * 4 + G,
                    ie = 4 * O,
                    pe = Math.max(0, C),
                    Ne = Math.max(0, L);
                  return {
                    rect: {
                      x: pe,
                      y: Ne,
                      width: Math.min(M.width, C + O) - pe,
                      height: Math.min(M.height, L + N) - Ne
                    },
                    layout: [{
                      offset: K,
                      stride: ie
                    }]
                  }
                })(i, t, r, n, l)), _)
                for (let M = 0; M < x.length; M += 4) {
                  const C = x[M];
                  x[M] = x[M + 2], x[M + 2] = C
                }
              return x
            } finally {
              p.close()
            }
          }))
        }
        let cr, jr;

        function wr(i, t, r, n) {
          return i.addEventListener(t, r, n), {
            unsubscribe: () => {
              i.removeEventListener(t, r, n)
            }
          }
        }

        function Nr(i) {
          return i * Math.PI / 180
        }

        function Gr(i) {
          return i / Math.PI * 180
        }
        const er = {
            touchstart: !0,
            touchmove: !0,
            touchmoveWindow: !0,
            touchend: !0,
            touchcancel: !0
          },
          Wr = {
            dblclick: !0,
            click: !0,
            mouseover: !0,
            mouseout: !0,
            mousedown: !0,
            mousemove: !0,
            mousemoveWindow: !0,
            mouseup: !0,
            mouseupWindow: !0,
            contextmenu: !0,
            wheel: !0
          },
          sr = "AbortError";

        function de() {
          return new Error(sr)
        }
        const j = {
          MAX_PARALLEL_IMAGE_REQUESTS: 16,
          MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8,
          MAX_TILE_CACHE_ZOOM_LEVELS: 5,
          REGISTERED_PROTOCOLS: {},
          WORKER_URL: ""
        };

        function V(i) {
          return j.REGISTERED_PROTOCOLS[i.substring(0, i.indexOf("://"))]
        }
        const X = "global-dispatcher";
        class re extends Error {
          constructor(t, r, n, l) {
            super(`AJAXError: ${r} (${t}): ${n}`), this.status = t, this.statusText = r, this.url = n, this.body = l
          }
        }
        const Q = () => wt(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href,
          ue = function(i, t) {
            if (/:\/\//.test(i.url) && !/^https?:|^file:/.test(i.url)) {
              const n = V(i.url);
              if (n) return n(i, t);
              if (wt(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
                type: "GR",
                data: i,
                targetMapId: X
              }, t)
            }
            if (!(/^file:/.test(r = i.url) || /^file:/.test(Q()) && !/^\w+:/.test(r))) {
              if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return (function(n, l) {
                return s(this, void 0, void 0, (function*() {
                  const p = new Request(n.url, {
                    method: n.method || "GET",
                    body: n.body,
                    credentials: n.credentials,
                    headers: n.headers,
                    cache: n.cache,
                    referrer: Q(),
                    signal: l.signal
                  });
                  let f, _;
                  n.type !== "json" || p.headers.has("Accept") || p.headers.set("Accept", "application/json");
                  try {
                    f = yield fetch(p)
                  } catch (M) {
                    throw new re(0, M.message, n.url, new Blob)
                  }
                  if (!f.ok) {
                    const M = yield f.blob();
                    throw new re(f.status, f.statusText, n.url, M)
                  }
                  _ = n.type === "arrayBuffer" || n.type === "image" ? f.arrayBuffer() : n.type === "json" ? f.json() : f.text();
                  const x = yield _;
                  if (l.signal.aborted) throw de();
                  return {
                    data: x,
                    cacheControl: f.headers.get("Cache-Control"),
                    expires: f.headers.get("Expires")
                  }
                }))
              })(i, t);
              if (wt(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
                type: "GR",
                data: i,
                mustQueue: !0,
                targetMapId: X
              }, t)
            }
            var r;
            return (function(n, l) {
              return new Promise(((p, f) => {
                var _;
                const x = new XMLHttpRequest;
                x.open(n.method || "GET", n.url, !0), n.type !== "arrayBuffer" && n.type !== "image" || (x.responseType = "arraybuffer");
                for (const M in n.headers) x.setRequestHeader(M, n.headers[M]);
                n.type === "json" && (x.responseType = "text", !((_ = n.headers) === null || _ === void 0) && _.Accept || x.setRequestHeader("Accept", "application/json")), x.withCredentials = n.credentials === "include", x.onerror = () => {
                  f(new Error(x.statusText))
                }, x.onload = () => {
                  if (!l.signal.aborted)
                    if ((x.status >= 200 && x.status < 300 || x.status === 0) && x.response !== null) {
                      let M = x.response;
                      if (n.type === "json") try {
                        M = JSON.parse(x.response)
                      } catch (C) {
                        return void f(C)
                      }
                      p({
                        data: M,
                        cacheControl: x.getResponseHeader("Cache-Control"),
                        expires: x.getResponseHeader("Expires")
                      })
                    } else {
                      const M = new Blob([x.response], {
                        type: x.getResponseHeader("Content-Type")
                      });
                      f(new re(x.status, x.statusText, n.url, M))
                    }
                }, l.signal.addEventListener("abort", (() => {
                  x.abort(), f(de())
                })), x.send(n.body)
              }))
            })(i, t)
          };

        function Te(i) {
          if (!i || i.indexOf("://") <= 0 || i.indexOf("data:image/") === 0 || i.indexOf("blob:") === 0) return !0;
          const t = new URL(i),
            r = window.location;
          return t.protocol === r.protocol && t.host === r.host
        }

        function be(i, t, r) {
          r[i] && r[i].indexOf(t) !== -1 || (r[i] = r[i] || [], r[i].push(t))
        }

        function ze(i, t, r) {
          if (r && r[i]) {
            const n = r[i].indexOf(t);
            n !== -1 && r[i].splice(n, 1)
          }
        }
        class We {
          constructor(t, r = {}) {
            nt(this, r), this.type = t
          }
        }
        class Be extends We {
          constructor(t, r = {}) {
            super("error", nt({
              error: t
            }, r))
          }
        }
        class ae {
          on(t, r) {
            return this._listeners = this._listeners || {}, be(t, r, this._listeners), {
              unsubscribe: () => {
                this.off(t, r)
              }
            }
          }
          off(t, r) {
            return ze(t, r, this._listeners), ze(t, r, this._oneTimeListeners), this
          }
          once(t, r) {
            return r ? (this._oneTimeListeners = this._oneTimeListeners || {}, be(t, r, this._oneTimeListeners), this) : new Promise((n => this.once(t, n)))
          }
          fire(t, r) {
            typeof t == "string" && (t = new We(t, r || {}));
            const n = t.type;
            if (this.listens(n)) {
              t.target = this;
              const l = this._listeners && this._listeners[n] ? this._listeners[n].slice() : [];
              for (const _ of l) _.call(this, t);
              const p = this._oneTimeListeners && this._oneTimeListeners[n] ? this._oneTimeListeners[n].slice() : [];
              for (const _ of p) ze(n, _, this._oneTimeListeners), _.call(this, t);
              const f = this._eventedParent;
              f && (nt(t, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), f.fire(t))
            } else t instanceof Be && console.error(t.error);
            return this
          }
          listens(t) {
            return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t)
          }
          setEventedParent(t, r) {
            return this._eventedParent = t, this._eventedParentData = r, this
          }
        }
        var J = {
          $version: 8,
          $root: {
            version: {
              required: !0,
              type: "enum",
              values: [8]
            },
            name: {
              type: "string"
            },
            metadata: {
              type: "*"
            },
            center: {
              type: "array",
              value: "number"
            },
            centerAltitude: {
              type: "number"
            },
            zoom: {
              type: "number"
            },
            bearing: {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees"
            },
            pitch: {
              type: "number",
              default: 0,
              units: "degrees"
            },
            roll: {
              type: "number",
              default: 0,
              units: "degrees"
            },
            state: {
              type: "state",
              default: {}
            },
            light: {
              type: "light"
            },
            sky: {
              type: "sky"
            },
            projection: {
              type: "projection"
            },
            terrain: {
              type: "terrain"
            },
            sources: {
              required: !0,
              type: "sources"
            },
            sprite: {
              type: "sprite"
            },
            glyphs: {
              type: "string"
            },
            "font-faces": {
              type: "array",
              value: "fontFaces"
            },
            transition: {
              type: "transition"
            },
            layers: {
              required: !0,
              type: "array",
              value: "layer"
            }
          },
          sources: {
            "*": {
              type: "source"
            }
          },
          source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"],
          source_vector: {
            type: {
              required: !0,
              type: "enum",
              values: {
                vector: {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            scheme: {
              type: "enum",
              values: {
                xyz: {},
                tms: {}
              },
              default: "xyz"
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            attribution: {
              type: "string"
            },
            promoteId: {
              type: "promoteId"
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            encoding: {
              type: "enum",
              values: {
                mvt: {},
                mlt: {}
              },
              default: "mvt"
            },
            "*": {
              type: "*"
            }
          },
          source_raster: {
            type: {
              required: !0,
              type: "enum",
              values: {
                raster: {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            tileSize: {
              type: "number",
              default: 512,
              units: "pixels"
            },
            scheme: {
              type: "enum",
              values: {
                xyz: {},
                tms: {}
              },
              default: "xyz"
            },
            attribution: {
              type: "string"
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            "*": {
              type: "*"
            }
          },
          source_raster_dem: {
            type: {
              required: !0,
              type: "enum",
              values: {
                "raster-dem": {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            tileSize: {
              type: "number",
              default: 512,
              units: "pixels"
            },
            attribution: {
              type: "string"
            },
            encoding: {
              type: "enum",
              values: {
                terrarium: {},
                mapbox: {},
                custom: {}
              },
              default: "mapbox"
            },
            redFactor: {
              type: "number",
              default: 1
            },
            blueFactor: {
              type: "number",
              default: 1
            },
            greenFactor: {
              type: "number",
              default: 1
            },
            baseShift: {
              type: "number",
              default: 0
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            "*": {
              type: "*"
            }
          },
          source_geojson: {
            type: {
              required: !0,
              type: "enum",
              values: {
                geojson: {}
              }
            },
            data: {
              required: !0,
              type: "*"
            },
            maxzoom: {
              type: "number",
              default: 18
            },
            attribution: {
              type: "string"
            },
            buffer: {
              type: "number",
              default: 128,
              maximum: 512,
              minimum: 0
            },
            filter: {
              type: "*"
            },
            tolerance: {
              type: "number",
              default: .375
            },
            cluster: {
              type: "boolean",
              default: !1
            },
            clusterRadius: {
              type: "number",
              default: 50,
              minimum: 0
            },
            clusterMaxZoom: {
              type: "number"
            },
            clusterMinPoints: {
              type: "number"
            },
            clusterProperties: {
              type: "*"
            },
            lineMetrics: {
              type: "boolean",
              default: !1
            },
            generateId: {
              type: "boolean",
              default: !1
            },
            promoteId: {
              type: "promoteId"
            }
          },
          source_video: {
            type: {
              required: !0,
              type: "enum",
              values: {
                video: {}
              }
            },
            urls: {
              required: !0,
              type: "array",
              value: "string"
            },
            coordinates: {
              required: !0,
              type: "array",
              length: 4,
              value: {
                type: "array",
                length: 2,
                value: "number"
              }
            }
          },
          source_image: {
            type: {
              required: !0,
              type: "enum",
              values: {
                image: {}
              }
            },
            url: {
              required: !0,
              type: "string"
            },
            coordinates: {
              required: !0,
              type: "array",
              length: 4,
              value: {
                type: "array",
                length: 2,
                value: "number"
              }
            }
          },
          layer: {
            id: {
              type: "string",
              required: !0
            },
            type: {
              type: "enum",
              values: {
                fill: {},
                line: {},
                symbol: {},
                circle: {},
                heatmap: {},
                "fill-extrusion": {},
                raster: {},
                hillshade: {},
                "color-relief": {},
                background: {}
              },
              required: !0
            },
            metadata: {
              type: "*"
            },
            source: {
              type: "string"
            },
            "source-layer": {
              type: "string"
            },
            minzoom: {
              type: "number",
              minimum: 0,
              maximum: 24
            },
            maxzoom: {
              type: "number",
              minimum: 0,
              maximum: 24
            },
            filter: {
              type: "filter"
            },
            layout: {
              type: "layout"
            },
            paint: {
              type: "paint"
            }
          },
          layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"],
          layout_background: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_fill: {
            "fill-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_circle: {
            "circle-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_heatmap: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          "layout_fill-extrusion": {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_line: {
            "line-cap": {
              type: "enum",
              values: {
                butt: {},
                round: {},
                square: {}
              },
              default: "butt",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-join": {
              type: "enum",
              values: {
                bevel: {},
                round: {},
                miter: {}
              },
              default: "miter",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "line-miter-limit": {
              type: "number",
              default: 2,
              requires: [{
                "line-join": "miter"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-round-limit": {
              type: "number",
              default: 1.05,
              requires: [{
                "line-join": "round"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_symbol: {
            "symbol-placement": {
              type: "enum",
              values: {
                point: {},
                line: {},
                "line-center": {}
              },
              default: "point",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-spacing": {
              type: "number",
              default: 250,
              minimum: 1,
              units: "pixels",
              requires: [{
                "symbol-placement": "line"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-avoid-edges": {
              type: "boolean",
              default: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "symbol-z-order": {
              type: "enum",
              values: {
                auto: {},
                "viewport-y": {},
                source: {}
              },
              default: "auto",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-allow-overlap": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", {
                "!": "icon-overlap"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-overlap": {
              type: "enum",
              values: {
                never: {},
                always: {},
                cooperative: {}
              },
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-ignore-placement": {
              type: "boolean",
              default: !1,
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-optional": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", "text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-rotation-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-size": {
              type: "number",
              default: 1,
              minimum: 0,
              units: "factor of the original icon size",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-text-fit": {
              type: "enum",
              values: {
                none: {},
                width: {},
                height: {},
                both: {}
              },
              default: "none",
              requires: ["icon-image", "text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-text-fit-padding": {
              type: "array",
              value: "number",
              length: 4,
              default: [0, 0, 0, 0],
              units: "pixels",
              requires: ["icon-image", "text-field", {
                "icon-text-fit": ["both", "width", "height"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-image": {
              type: "resolvedImage",
              tokens: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-rotate": {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-padding": {
              type: "padding",
              default: [2],
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-keep-upright": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", {
                "icon-rotation-alignment": "map"
              }, {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-offset": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-anchor": {
              type: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              default: "center",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-rotation-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                "viewport-glyph": {},
                auto: {}
              },
              default: "auto",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-field": {
              type: "formatted",
              default: "",
              tokens: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-font": {
              type: "array",
              value: "string",
              default: ["Open Sans Regular", "Arial Unicode MS Regular"],
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-size": {
              type: "number",
              default: 16,
              minimum: 0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-max-width": {
              type: "number",
              default: 10,
              minimum: 0,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-line-height": {
              type: "number",
              default: 1.2,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-letter-spacing": {
              type: "number",
              default: 0,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-justify": {
              type: "enum",
              values: {
                auto: {},
                left: {},
                center: {},
                right: {}
              },
              default: "center",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-radial-offset": {
              type: "number",
              units: "ems",
              default: 0,
              requires: ["text-field"],
              "property-type": "data-driven",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              }
            },
            "text-variable-anchor": {
              type: "array",
              value: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-variable-anchor-offset": {
              type: "variableAnchorOffsetCollection",
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-anchor": {
              type: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              default: "center",
              requires: ["text-field", {
                "!": "text-variable-anchor"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-max-angle": {
              type: "number",
              default: 45,
              units: "degrees",
              requires: ["text-field", {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-writing-mode": {
              type: "array",
              value: "enum",
              values: {
                horizontal: {},
                vertical: {}
              },
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-rotate": {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-padding": {
              type: "number",
              default: 2,
              minimum: 0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-keep-upright": {
              type: "boolean",
              default: !0,
              requires: ["text-field", {
                "text-rotation-alignment": "map"
              }, {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-transform": {
              type: "enum",
              values: {
                none: {},
                uppercase: {},
                lowercase: {}
              },
              default: "none",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-offset": {
              type: "array",
              value: "number",
              units: "ems",
              length: 2,
              default: [0, 0],
              requires: ["text-field", {
                "!": "text-radial-offset"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-allow-overlap": {
              type: "boolean",
              default: !1,
              requires: ["text-field", {
                "!": "text-overlap"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-overlap": {
              type: "enum",
              values: {
                never: {},
                always: {},
                cooperative: {}
              },
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-ignore-placement": {
              type: "boolean",
              default: !1,
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-optional": {
              type: "boolean",
              default: !1,
              requires: ["text-field", "icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_raster: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_hillshade: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          "layout_color-relief": {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          filter: {
            type: "array",
            value: "*"
          },
          filter_operator: {
            type: "enum",
            values: {
              "==": {},
              "!=": {},
              ">": {},
              ">=": {},
              "<": {},
              "<=": {},
              in: {},
              "!in": {},
              all: {},
              any: {},
              none: {},
              has: {},
              "!has": {}
            }
          },
          geometry_type: {
            type: "enum",
            values: {
              Point: {},
              LineString: {},
              Polygon: {}
            }
          },
          function: {
            expression: {
              type: "expression"
            },
            stops: {
              type: "array",
              value: "function_stop"
            },
            base: {
              type: "number",
              default: 1,
              minimum: 0
            },
            property: {
              type: "string",
              default: "$zoom"
            },
            type: {
              type: "enum",
              values: {
                identity: {},
                exponential: {},
                interval: {},
                categorical: {}
              },
              default: "exponential"
            },
            colorSpace: {
              type: "enum",
              values: {
                rgb: {},
                lab: {},
                hcl: {}
              },
              default: "rgb"
            },
            default: {
              type: "*",
              required: !1
            }
          },
          function_stop: {
            type: "array",
            minimum: 0,
            maximum: 24,
            value: ["number", "color"],
            length: 2
          },
          expression: {
            type: "array",
            value: "*",
            minimum: 1
          },
          light: {
            anchor: {
              type: "enum",
              default: "viewport",
              values: {
                map: {},
                viewport: {}
              },
              "property-type": "data-constant",
              transition: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              }
            },
            position: {
              type: "array",
              default: [1.15, 210, 30],
              length: 3,
              value: "number",
              "property-type": "data-constant",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              }
            },
            color: {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            intensity: {
              type: "number",
              "property-type": "data-constant",
              default: .5,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            }
          },
          sky: {
            "sky-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#88C6FC",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "horizon-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "fog-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "fog-ground-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .5,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "horizon-fog-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "sky-horizon-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "atmosphere-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            }
          },
          terrain: {
            source: {
              type: "string",
              required: !0
            },
            exaggeration: {
              type: "number",
              minimum: 0,
              default: 1
            }
          },
          projection: {
            type: {
              type: "projectionDefinition",
              default: "mercator",
              "property-type": "data-constant",
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              }
            }
          },
          paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"],
          paint_fill: {
            "fill-antialias": {
              type: "boolean",
              default: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "fill-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-outline-color": {
              type: "color",
              transition: !0,
              requires: [{
                "!": "fill-pattern"
              }, {
                "fill-antialias": !0
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["fill-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            }
          },
          "paint_fill-extrusion": {
            "fill-extrusion-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "fill-extrusion-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["fill-extrusion-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "fill-extrusion-height": {
              type: "number",
              default: 0,
              minimum: 0,
              units: "meters",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-base": {
              type: "number",
              default: 0,
              minimum: 0,
              units: "meters",
              transition: !0,
              requires: ["fill-extrusion-height"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-vertical-gradient": {
              type: "boolean",
              default: !0,
              transition: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_line: {
            "line-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "line-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["line-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-width": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-gap-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-offset": {
              type: "number",
              default: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-dasharray": {
              type: "array",
              value: "number",
              minimum: 0,
              transition: !0,
              units: "line widths",
              requires: [{
                "!": "line-pattern"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "line-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "line-gradient": {
              type: "color",
              transition: !1,
              requires: [{
                "!": "line-dasharray"
              }, {
                "!": "line-pattern"
              }, {
                source: "geojson",
                has: {
                  lineMetrics: !0
                }
              }],
              expression: {
                interpolated: !0,
                parameters: ["line-progress"]
              },
              "property-type": "color-ramp"
            }
          },
          paint_circle: {
            "circle-radius": {
              type: "number",
              default: 5,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-blur": {
              type: "number",
              default: 0,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["circle-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-pitch-scale": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "viewport",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-stroke-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-stroke-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-stroke-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            }
          },
          paint_heatmap: {
            "heatmap-radius": {
              type: "number",
              default: 30,
              minimum: 1,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "heatmap-weight": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "heatmap-intensity": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "heatmap-color": {
              type: "color",
              default: ["interpolate", ["linear"],
                ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", .1, "royalblue", .3, "cyan", .5, "lime", .7, "yellow", 1, "red"
              ],
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["heatmap-density"]
              },
              "property-type": "color-ramp"
            },
            "heatmap-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_symbol: {
            "icon-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-color": {
              type: "color",
              default: "rgba(0, 0, 0, 0)",
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["icon-image", "icon-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              overridable: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-color": {
              type: "color",
              default: "rgba(0, 0, 0, 0)",
              transition: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["text-field", "text-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_raster: {
            "raster-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-hue-rotate": {
              type: "number",
              default: 0,
              period: 360,
              transition: !0,
              units: "degrees",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-brightness-min": {
              type: "number",
              default: 0,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-brightness-max": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-saturation": {
              type: "number",
              default: 0,
              minimum: -1,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-contrast": {
              type: "number",
              default: 0,
              minimum: -1,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-resampling": {
              type: "enum",
              values: {
                linear: {},
                nearest: {}
              },
              default: "linear",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-fade-duration": {
              type: "number",
              default: 300,
              minimum: 0,
              transition: !1,
              units: "milliseconds",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_hillshade: {
            "hillshade-illumination-direction": {
              type: "numberArray",
              default: 335,
              minimum: 0,
              maximum: 359,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-illumination-altitude": {
              type: "numberArray",
              default: 45,
              minimum: 0,
              maximum: 90,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-illumination-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "viewport",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-exaggeration": {
              type: "number",
              default: .5,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-shadow-color": {
              type: "colorArray",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-highlight-color": {
              type: "colorArray",
              default: "#FFFFFF",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-accent-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-method": {
              type: "enum",
              values: {
                standard: {},
                basic: {},
                combined: {},
                igor: {},
                multidirectional: {}
              },
              default: "standard",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          "paint_color-relief": {
            "color-relief-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "color-relief-color": {
              type: "color",
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["elevation"]
              },
              "property-type": "color-ramp"
            }
          },
          paint_background: {
            "background-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "background-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "background-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "cross-faded"
            },
            "background-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          transition: {
            duration: {
              type: "number",
              default: 300,
              minimum: 0,
              units: "milliseconds"
            },
            delay: {
              type: "number",
              default: 0,
              minimum: 0,
              units: "milliseconds"
            }
          },
          "property-type": {
            "data-driven": {
              type: "property-type"
            },
            "cross-faded": {
              type: "property-type"
            },
            "cross-faded-data-driven": {
              type: "property-type"
            },
            "color-ramp": {
              type: "property-type"
            },
            "data-constant": {
              type: "property-type"
            },
            constant: {
              type: "property-type"
            }
          },
          promoteId: {
            "*": {
              type: "string"
            }
          }
        };
        const Ve = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];

        function tt(i, t) {
          const r = {};
          for (const n in i) n !== "ref" && (r[n] = i[n]);
          return Ve.forEach((n => {
            n in t && (r[n] = t[n])
          })), r
        }

        function Ze(i, t) {
          if (Array.isArray(i)) {
            if (!Array.isArray(t) || i.length !== t.length) return !1;
            for (let r = 0; r < i.length; r++)
              if (!Ze(i[r], t[r])) return !1;
            return !0
          }
          if (typeof i == "object" && i !== null && t !== null) {
            if (typeof t != "object" || Object.keys(i).length !== Object.keys(t).length) return !1;
            for (const r in i)
              if (!Ze(i[r], t[r])) return !1;
            return !0
          }
          return i === t
        }

        function ne(i, t) {
          i.push(t)
        }

        function Ce(i, t, r) {
          ne(r, {
            command: "addSource",
            args: [i, t[i]]
          })
        }

        function He(i, t, r) {
          ne(t, {
            command: "removeSource",
            args: [i]
          }), r[i] = !0
        }

        function ht(i, t, r, n) {
          He(i, r, n), Ce(i, t, r)
        }

        function Tt(i, t, r) {
          let n;
          for (n in i[r])
            if (Object.prototype.hasOwnProperty.call(i[r], n) && n !== "data" && !Ze(i[r][n], t[r][n])) return !1;
          for (n in t[r])
            if (Object.prototype.hasOwnProperty.call(t[r], n) && n !== "data" && !Ze(i[r][n], t[r][n])) return !1;
          return !0
        }

        function dt(i, t, r, n, l, p) {
          i = i || {}, t = t || {};
          for (const f in i) Object.prototype.hasOwnProperty.call(i, f) && (Ze(i[f], t[f]) || r.push({
            command: p,
            args: [n, f, t[f], l]
          }));
          for (const f in t) Object.prototype.hasOwnProperty.call(t, f) && !Object.prototype.hasOwnProperty.call(i, f) && (Ze(i[f], t[f]) || r.push({
            command: p,
            args: [n, f, t[f], l]
          }))
        }

        function St(i) {
          return i.id
        }

        function jt(i, t) {
          return i[t.id] = t, i
        }
        class je {
          constructor(t, r, n, l) {
            this.message = (t ? `${t}: ` : "") + n, l && (this.identifier = l), r != null && r.__line__ && (this.line = r.__line__)
          }
        }

        function yt(i, ...t) {
          for (const r of t)
            for (const n in r) i[n] = r[n];
          return i
        }
        class Kt extends Error {
          constructor(t, r) {
            super(r), this.message = r, this.key = t
          }
        }
        class Cr {
          constructor(t, r = []) {
            this.parent = t, this.bindings = {};
            for (const [n, l] of r) this.bindings[n] = l
          }
          concat(t) {
            return new Cr(this, t)
          }
          get(t) {
            if (this.bindings[t]) return this.bindings[t];
            if (this.parent) return this.parent.get(t);
            throw new Error(`${t} not found in scope.`)
          }
          has(t) {
            return !!this.bindings[t] || !!this.parent && this.parent.has(t)
          }
        }
        const fr = {
            kind: "null"
          },
          Je = {
            kind: "number"
          },
          tr = {
            kind: "string"
          },
          Yt = {
            kind: "boolean"
          },
          Tr = {
            kind: "color"
          },
          Dr = {
            kind: "projectionDefinition"
          },
          Jr = {
            kind: "object"
          },
          yr = {
            kind: "value"
          },
          qt = {
            kind: "collator"
          },
          bt = {
            kind: "formatted"
          },
          Ue = {
            kind: "padding"
          },
          xt = {
            kind: "colorArray"
          },
          Gt = {
            kind: "numberArray"
          },
          kt = {
            kind: "resolvedImage"
          },
          dr = {
            kind: "variableAnchorOffsetCollection"
          };

        function ar(i, t) {
          return {
            kind: "array",
            itemType: i,
            N: t
          }
        }

        function Ar(i) {
          if (i.kind === "array") {
            const t = Ar(i.itemType);
            return typeof i.N == "number" ? `array<${t}, ${i.N}>` : i.itemType.kind === "value" ? "array" : `array<${t}>`
          }
          return i.kind
        }
        const Kr = [fr, Je, tr, Yt, Tr, Dr, bt, Jr, ar(yr), Ue, Gt, xt, kt, dr];

        function Rr(i, t) {
          if (t.kind === "error") return null;
          if (i.kind === "array") {
            if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !Rr(i.itemType, t.itemType)) && (typeof i.N != "number" || i.N === t.N)) return null
          } else {
            if (i.kind === t.kind) return null;
            if (i.kind === "value") {
              for (const r of Kr)
                if (!Rr(r, t)) return null
            }
          }
          return `Expected ${Ar(i)} but found ${Ar(t)} instead.`
        }

        function Or(i, t) {
          return t.some((r => r.kind === i.kind))
        }

        function Fr(i, t) {
          return t.some((r => r === "null" ? i === null : r === "array" ? Array.isArray(i) : r === "object" ? i && !Array.isArray(i) && typeof i == "object" : r === typeof i))
        }

        function ti(i, t) {
          return i.kind === "array" && t.kind === "array" ? i.itemType.kind === t.itemType.kind && typeof i.N == "number" : i.kind === t.kind
        }
        const Ai = .96422,
          bi = .82521,
          Yr = 4 / 29,
          Zr = 6 / 29,
          Ii = 3 * Zr * Zr,
          ki = Zr * Zr * Zr,
          wi = Math.PI / 180,
          Vi = 180 / Math.PI;

        function Yi(i) {
          return (i %= 360) < 0 && (i += 360), i
        }

        function pt([i, t, r, n]) {
          let l, p;
          const f = zr((.2225045 * (i = Ft(i)) + .7168786 * (t = Ft(t)) + .0606169 * (r = Ft(r))) / 1);
          i === t && t === r ? l = p = f : (l = zr((.4360747 * i + .3850649 * t + .1430804 * r) / Ai), p = zr((.0139322 * i + .0971045 * t + .7141733 * r) / bi));
          const _ = 116 * f - 16;
          return [_ < 0 ? 0 : _, 500 * (l - f), 200 * (f - p), n]
        }

        function Ft(i) {
          return i <= .04045 ? i / 12.92 : Math.pow((i + .055) / 1.055, 2.4)
        }

        function zr(i) {
          return i > ki ? Math.pow(i, 1 / 3) : i / Ii + Yr
        }

        function Bi([i, t, r, n]) {
          let l = (i + 16) / 116,
            p = isNaN(t) ? l : l + t / 500,
            f = isNaN(r) ? l : l - r / 200;
          return l = 1 * Ta(l), p = Ai * Ta(p), f = bi * Ta(f), [Zi(3.1338561 * p - 1.6168667 * l - .4906146 * f), Zi(-.9787684 * p + 1.9161415 * l + .033454 * f), Zi(.0719453 * p - .2289914 * l + 1.4052427 * f), n]
        }

        function Zi(i) {
          return (i = i <= .00304 ? 12.92 * i : 1.055 * Math.pow(i, 1 / 2.4) - .055) < 0 ? 0 : i > 1 ? 1 : i
        }

        function Ta(i) {
          return i > Zr ? i * i * i : Ii * (i - Yr)
        }
        const Xi = Object.hasOwn || function(i, t) {
          return Object.prototype.hasOwnProperty.call(i, t)
        };

        function ji(i, t) {
          return Xi(i, t) ? i[t] : void 0
        }

        function La(i) {
          return parseInt(i.padEnd(2, i), 16) / 255
        }

        function Br(i, t) {
          return Pr(t ? i / 100 : i, 0, 1)
        }

        function Pr(i, t, r) {
          return Math.min(Math.max(t, i), r)
        }

        function zi(i) {
          return !i.some(Number.isNaN)
        }
        const hi = {
          aliceblue: [240, 248, 255],
          antiquewhite: [250, 235, 215],
          aqua: [0, 255, 255],
          aquamarine: [127, 255, 212],
          azure: [240, 255, 255],
          beige: [245, 245, 220],
          bisque: [255, 228, 196],
          black: [0, 0, 0],
          blanchedalmond: [255, 235, 205],
          blue: [0, 0, 255],
          blueviolet: [138, 43, 226],
          brown: [165, 42, 42],
          burlywood: [222, 184, 135],
          cadetblue: [95, 158, 160],
          chartreuse: [127, 255, 0],
          chocolate: [210, 105, 30],
          coral: [255, 127, 80],
          cornflowerblue: [100, 149, 237],
          cornsilk: [255, 248, 220],
          crimson: [220, 20, 60],
          cyan: [0, 255, 255],
          darkblue: [0, 0, 139],
          darkcyan: [0, 139, 139],
          darkgoldenrod: [184, 134, 11],
          darkgray: [169, 169, 169],
          darkgreen: [0, 100, 0],
          darkgrey: [169, 169, 169],
          darkkhaki: [189, 183, 107],
          darkmagenta: [139, 0, 139],
          darkolivegreen: [85, 107, 47],
          darkorange: [255, 140, 0],
          darkorchid: [153, 50, 204],
          darkred: [139, 0, 0],
          darksalmon: [233, 150, 122],
          darkseagreen: [143, 188, 143],
          darkslateblue: [72, 61, 139],
          darkslategray: [47, 79, 79],
          darkslategrey: [47, 79, 79],
          darkturquoise: [0, 206, 209],
          darkviolet: [148, 0, 211],
          deeppink: [255, 20, 147],
          deepskyblue: [0, 191, 255],
          dimgray: [105, 105, 105],
          dimgrey: [105, 105, 105],
          dodgerblue: [30, 144, 255],
          firebrick: [178, 34, 34],
          floralwhite: [255, 250, 240],
          forestgreen: [34, 139, 34],
          fuchsia: [255, 0, 255],
          gainsboro: [220, 220, 220],
          ghostwhite: [248, 248, 255],
          gold: [255, 215, 0],
          goldenrod: [218, 165, 32],
          gray: [128, 128, 128],
          green: [0, 128, 0],
          greenyellow: [173, 255, 47],
          grey: [128, 128, 128],
          honeydew: [240, 255, 240],
          hotpink: [255, 105, 180],
          indianred: [205, 92, 92],
          indigo: [75, 0, 130],
          ivory: [255, 255, 240],
          khaki: [240, 230, 140],
          lavender: [230, 230, 250],
          lavenderblush: [255, 240, 245],
          lawngreen: [124, 252, 0],
          lemonchiffon: [255, 250, 205],
          lightblue: [173, 216, 230],
          lightcoral: [240, 128, 128],
          lightcyan: [224, 255, 255],
          lightgoldenrodyellow: [250, 250, 210],
          lightgray: [211, 211, 211],
          lightgreen: [144, 238, 144],
          lightgrey: [211, 211, 211],
          lightpink: [255, 182, 193],
          lightsalmon: [255, 160, 122],
          lightseagreen: [32, 178, 170],
          lightskyblue: [135, 206, 250],
          lightslategray: [119, 136, 153],
          lightslategrey: [119, 136, 153],
          lightsteelblue: [176, 196, 222],
          lightyellow: [255, 255, 224],
          lime: [0, 255, 0],
          limegreen: [50, 205, 50],
          linen: [250, 240, 230],
          magenta: [255, 0, 255],
          maroon: [128, 0, 0],
          mediumaquamarine: [102, 205, 170],
          mediumblue: [0, 0, 205],
          mediumorchid: [186, 85, 211],
          mediumpurple: [147, 112, 219],
          mediumseagreen: [60, 179, 113],
          mediumslateblue: [123, 104, 238],
          mediumspringgreen: [0, 250, 154],
          mediumturquoise: [72, 209, 204],
          mediumvioletred: [199, 21, 133],
          midnightblue: [25, 25, 112],
          mintcream: [245, 255, 250],
          mistyrose: [255, 228, 225],
          moccasin: [255, 228, 181],
          navajowhite: [255, 222, 173],
          navy: [0, 0, 128],
          oldlace: [253, 245, 230],
          olive: [128, 128, 0],
          olivedrab: [107, 142, 35],
          orange: [255, 165, 0],
          orangered: [255, 69, 0],
          orchid: [218, 112, 214],
          palegoldenrod: [238, 232, 170],
          palegreen: [152, 251, 152],
          paleturquoise: [175, 238, 238],
          palevioletred: [219, 112, 147],
          papayawhip: [255, 239, 213],
          peachpuff: [255, 218, 185],
          peru: [205, 133, 63],
          pink: [255, 192, 203],
          plum: [221, 160, 221],
          powderblue: [176, 224, 230],
          purple: [128, 0, 128],
          rebeccapurple: [102, 51, 153],
          red: [255, 0, 0],
          rosybrown: [188, 143, 143],
          royalblue: [65, 105, 225],
          saddlebrown: [139, 69, 19],
          salmon: [250, 128, 114],
          sandybrown: [244, 164, 96],
          seagreen: [46, 139, 87],
          seashell: [255, 245, 238],
          sienna: [160, 82, 45],
          silver: [192, 192, 192],
          skyblue: [135, 206, 235],
          slateblue: [106, 90, 205],
          slategray: [112, 128, 144],
          slategrey: [112, 128, 144],
          snow: [255, 250, 250],
          springgreen: [0, 255, 127],
          steelblue: [70, 130, 180],
          tan: [210, 180, 140],
          teal: [0, 128, 128],
          thistle: [216, 191, 216],
          tomato: [255, 99, 71],
          turquoise: [64, 224, 208],
          violet: [238, 130, 238],
          wheat: [245, 222, 179],
          white: [255, 255, 255],
          whitesmoke: [245, 245, 245],
          yellow: [255, 255, 0],
          yellowgreen: [154, 205, 50]
        };

        function kr(i, t, r) {
          return i + r * (t - i)
        }

        function mi(i, t, r) {
          return i.map(((n, l) => kr(n, t[l], r)))
        }
        class Ir {
          constructor(t, r, n, l = 1, p = !0) {
            this.r = t, this.g = r, this.b = n, this.a = l, p || (this.r *= l, this.g *= l, this.b *= l, l || this.overwriteGetter("rgb", [t, r, n, l]))
          }
          static parse(t) {
            if (t instanceof Ir) return t;
            if (typeof t != "string") return;
            const r = (function(n) {
              if ((n = n.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
              const l = ji(hi, n);
              if (l) {
                const [f, _, x] = l;
                return [f / 255, _ / 255, x / 255, 1]
              }
              if (n.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(n)) {
                const f = n.length < 6 ? 1 : 2;
                let _ = 1;
                return [La(n.slice(_, _ += f)), La(n.slice(_, _ += f)), La(n.slice(_, _ += f)), La(n.slice(_, _ + f) || "ff")]
              }
              if (n.startsWith("rgb")) {
                const f = n.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (f) {
                  const [_, x, M, C, L, O, N, G, K, ie, pe, Ne] = f, ye = [C || " ", N || " ", ie].join("");
                  if (ye === "  " || ye === "  /" || ye === ",," || ye === ",,,") {
                    const ke = [M, O, K].join(""),
                      at = ke === "%%%" ? 100 : ke === "" ? 255 : 0;
                    if (at) {
                      const gt = [Pr(+x / at, 0, 1), Pr(+L / at, 0, 1), Pr(+G / at, 0, 1), pe ? Br(+pe, Ne) : 1];
                      if (zi(gt)) return gt
                    }
                  }
                  return
                }
              }
              const p = n.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (p) {
                const [f, _, x, M, C, L, O, N, G] = p, K = [x || " ", C || " ", O].join("");
                if (K === "  " || K === "  /" || K === ",," || K === ",,,") {
                  const ie = [+_, Pr(+M, 0, 100), Pr(+L, 0, 100), N ? Br(+N, G) : 1];
                  if (zi(ie)) return (function([pe, Ne, ye, ke]) {
                    function at(gt) {
                      const Wt = (gt + pe / 30) % 12,
                        xr = Ne * Math.min(ye, 1 - ye);
                      return ye - xr * Math.max(-1, Math.min(Wt - 3, 9 - Wt, 1))
                    }
                    return pe = Yi(pe), Ne /= 100, ye /= 100, [at(0), at(8), at(4), ke]
                  })(ie)
                }
              }
            })(t);
            return r ? new Ir(...r, !1) : void 0
          }
          get rgb() {
            const {
              r: t,
              g: r,
              b: n,
              a: l
            } = this, p = l || 1 / 0;
            return this.overwriteGetter("rgb", [t / p, r / p, n / p, l])
          }
          get hcl() {
            return this.overwriteGetter("hcl", (function(t) {
              const [r, n, l, p] = pt(t), f = Math.sqrt(n * n + l * l);
              return [Math.round(1e4 * f) ? Yi(Math.atan2(l, n) * Vi) : NaN, f, r, p]
            })(this.rgb))
          }
          get lab() {
            return this.overwriteGetter("lab", pt(this.rgb))
          }
          overwriteGetter(t, r) {
            return Object.defineProperty(this, t, {
              value: r
            }), r
          }
          toString() {
            const [t, r, n, l] = this.rgb;
            return `rgba(${[t,r,n].map((p=>Math.round(255*p))).join(",")},${l})`
          }
          static interpolate(t, r, n, l = "rgb") {
            switch (l) {
              case "rgb": {
                const [p, f, _, x] = mi(t.rgb, r.rgb, n);
                return new Ir(p, f, _, x, !1)
              }
              case "hcl": {
                const [p, f, _, x] = t.hcl, [M, C, L, O] = r.hcl;
                let N, G;
                if (isNaN(p) || isNaN(M)) isNaN(p) ? isNaN(M) ? N = NaN : (N = M, _ !== 1 && _ !== 0 || (G = C)) : (N = p, L !== 1 && L !== 0 || (G = f));
                else {
                  let ye = M - p;
                  M > p && ye > 180 ? ye -= 360 : M < p && p - M > 180 && (ye += 360), N = p + n * ye
                }
                const [K, ie, pe, Ne] = (function([ye, ke, at, gt]) {
                  return ye = isNaN(ye) ? 0 : ye * wi, Bi([at, Math.cos(ye) * ke, Math.sin(ye) * ke, gt])
                })([N, G ?? kr(f, C, n), kr(_, L, n), kr(x, O, n)]);
                return new Ir(K, ie, pe, Ne, !1)
              }
              case "lab": {
                const [p, f, _, x] = Bi(mi(t.lab, r.lab, n));
                return new Ir(p, f, _, x, !1)
              }
            }
          }
        }
        Ir.black = new Ir(0, 0, 0, 1), Ir.white = new Ir(1, 1, 1, 1), Ir.transparent = new Ir(0, 0, 0, 0), Ir.red = new Ir(1, 0, 0, 1);
        class ei {
          constructor(t, r, n) {
            this.sensitivity = t ? r ? "variant" : "case" : r ? "accent" : "base", this.locale = n, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
              sensitivity: this.sensitivity,
              usage: "search"
            })
          }
          compare(t, r) {
            return this.collator.compare(t, r)
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale
          }
        }
        const Ni = ["bottom", "center", "top"];
        class Oi {
          constructor(t, r, n, l, p, f) {
            this.text = t, this.image = r, this.scale = n, this.fontStack = l, this.textColor = p, this.verticalAlign = f
          }
        }
        class Ei {
          constructor(t) {
            this.sections = t
          }
          static fromString(t) {
            return new Ei([new Oi(t, null, null, null, null, null)])
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some((t => t.text.length !== 0 || t.image && t.image.name.length !== 0))
          }
          static factory(t) {
            return t instanceof Ei ? t : Ei.fromString(t)
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map((t => t.text)).join("")
          }
        }
        class Si {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof Si) return t;
            if (typeof t == "number") return new Si([t, t, t, t]);
            if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
              for (const r of t)
                if (typeof r != "number") return;
              switch (t.length) {
                case 1:
                  t = [t[0], t[0], t[0], t[0]];
                  break;
                case 2:
                  t = [t[0], t[1], t[0], t[1]];
                  break;
                case 3:
                  t = [t[0], t[1], t[2], t[1]]
              }
              return new Si(t)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, r, n) {
            return new Si(mi(t.values, r.values, n))
          }
        }
        class Pi {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof Pi) return t;
            if (typeof t == "number") return new Pi([t]);
            if (Array.isArray(t)) {
              for (const r of t)
                if (typeof r != "number") return;
              return new Pi(t)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, r, n) {
            return new Pi(mi(t.values, r.values, n))
          }
        }
        class di {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof di) return t;
            if (typeof t == "string") {
              const n = Ir.parse(t);
              return n ? new di([n]) : void 0
            }
            if (!Array.isArray(t)) return;
            const r = [];
            for (const n of t) {
              if (typeof n != "string") return;
              const l = Ir.parse(n);
              if (!l) return;
              r.push(l)
            }
            return new di(r)
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, r, n, l = "rgb") {
            const p = [];
            if (t.values.length != r.values.length) throw new Error(`colorArray: Arrays have mismatched length (${t.values.length} vs. ${r.values.length}), cannot interpolate.`);
            for (let f = 0; f < t.values.length; f++) p.push(Ir.interpolate(t.values[f], r.values[f], n, l));
            return new di(p)
          }
        }
        class li extends Error {
          constructor(t) {
            super(t), this.name = "RuntimeError"
          }
          toJSON() {
            return this.message
          }
        }
        const rn = new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class Ui {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof Ui) return t;
            if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
              for (let r = 0; r < t.length; r += 2) {
                const n = t[r],
                  l = t[r + 1];
                if (typeof n != "string" || !rn.has(n) || !Array.isArray(l) || l.length !== 2 || typeof l[0] != "number" || typeof l[1] != "number") return
              }
              return new Ui(t)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, r, n) {
            const l = t.values,
              p = r.values;
            if (l.length !== p.length) throw new li(`Cannot interpolate values of different length. from: ${t.toString()}, to: ${r.toString()}`);
            const f = [];
            for (let _ = 0; _ < l.length; _ += 2) {
              if (l[_] !== p[_]) throw new li(`Cannot interpolate values containing mismatched anchors. from[${_}]: ${l[_]}, to[${_}]: ${p[_]}`);
              f.push(l[_]);
              const [x, M] = l[_ + 1], [C, L] = p[_ + 1];
              f.push([kr(x, C, n), kr(M, L, n)])
            }
            return new Ui(f)
          }
        }
        class ra {
          constructor(t) {
            this.name = t.name, this.available = t.available
          }
          toString() {
            return this.name
          }
          static fromString(t) {
            return t ? new ra({
              name: t,
              available: !1
            }) : null
          }
        }
        class sa {
          constructor(t, r, n) {
            this.from = t, this.to = r, this.transition = n
          }
          static interpolate(t, r, n) {
            return new sa(t, r, n)
          }
          static parse(t) {
            return t instanceof sa ? t : Array.isArray(t) && t.length === 3 && typeof t[0] == "string" && typeof t[1] == "string" && typeof t[2] == "number" ? new sa(t[0], t[1], t[2]) : typeof t == "object" && typeof t.from == "string" && typeof t.to == "string" && typeof t.transition == "number" ? new sa(t.from, t.to, t.transition) : typeof t == "string" ? new sa(t, t, 1) : void 0
          }
        }

        function Da(i, t, r, n) {
          return typeof i == "number" && i >= 0 && i <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof r == "number" && r >= 0 && r <= 255 ? n === void 0 || typeof n == "number" && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[i,t,r,n].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof n=="number"?[i,t,r,n]:[i,t,r]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`
        }

        function Sa(i) {
          if (i === null || typeof i == "string" || typeof i == "boolean" || typeof i == "number" || i instanceof sa || i instanceof Ir || i instanceof ei || i instanceof Ei || i instanceof Si || i instanceof Pi || i instanceof di || i instanceof Ui || i instanceof ra) return !0;
          if (Array.isArray(i)) {
            for (const t of i)
              if (!Sa(t)) return !1;
            return !0
          }
          if (typeof i == "object") {
            for (const t in i)
              if (!Sa(i[t])) return !1;
            return !0
          }
          return !1
        }

        function Ki(i) {
          if (i === null) return fr;
          if (typeof i == "string") return tr;
          if (typeof i == "boolean") return Yt;
          if (typeof i == "number") return Je;
          if (i instanceof Ir) return Tr;
          if (i instanceof sa) return Dr;
          if (i instanceof ei) return qt;
          if (i instanceof Ei) return bt;
          if (i instanceof Si) return Ue;
          if (i instanceof Pi) return Gt;
          if (i instanceof di) return xt;
          if (i instanceof Ui) return dr;
          if (i instanceof ra) return kt;
          if (Array.isArray(i)) {
            const t = i.length;
            let r;
            for (const n of i) {
              const l = Ki(n);
              if (r) {
                if (r === l) continue;
                r = yr;
                break
              }
              r = l
            }
            return ar(r || yr, t)
          }
          return Jr
        }

        function ca(i) {
          const t = typeof i;
          return i === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(i) : i instanceof Ir || i instanceof sa || i instanceof Ei || i instanceof Si || i instanceof Pi || i instanceof di || i instanceof Ui || i instanceof ra ? i.toString() : JSON.stringify(i)
        }
        class Pa {
          constructor(t, r) {
            this.type = t, this.value = r
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`'literal' expression requires exactly one argument, but found ${t.length-1} instead.`);
            if (!Sa(t[1])) return r.error("invalid value");
            const n = t[1];
            let l = Ki(n);
            const p = r.expectedType;
            return l.kind !== "array" || l.N !== 0 || !p || p.kind !== "array" || typeof p.N == "number" && p.N !== 0 || (l = p), new Pa(l, n)
          }
          evaluate() {
            return this.value
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        const ja = {
          string: tr,
          number: Je,
          boolean: Yt,
          object: Jr
        };
        class Ti {
          constructor(t, r) {
            this.type = t, this.args = r
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            let n, l = 1;
            const p = t[0];
            if (p === "array") {
              let _, x;
              if (t.length > 2) {
                const M = t[1];
                if (typeof M != "string" || !(M in ja) || M === "object") return r.error('The item type argument of "array" must be one of string, number, boolean', 1);
                _ = ja[M], l++
              } else _ = yr;
              if (t.length > 3) {
                if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2]))) return r.error('The length argument to "array" must be a positive integer literal', 2);
                x = t[2], l++
              }
              n = ar(_, x)
            } else {
              if (!ja[p]) throw new Error(`Types doesn't contain name = ${p}`);
              n = ja[p]
            }
            const f = [];
            for (; l < t.length; l++) {
              const _ = r.parse(t[l], l, yr);
              if (!_) return null;
              f.push(_)
            }
            return new Ti(n, f)
          }
          evaluate(t) {
            for (let r = 0; r < this.args.length; r++) {
              const n = this.args[r].evaluate(t);
              if (!Rr(this.type, Ki(n))) return n;
              if (r === this.args.length - 1) throw new li(`Expected value to be of type ${Ar(this.type)}, but found ${Ar(Ki(n))} instead.`)
            }
            throw new Error
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return this.args.every((t => t.outputDefined()))
          }
        }
        const bn = {
          "to-boolean": Yt,
          "to-color": Tr,
          "to-number": Je,
          "to-string": tr
        };
        class gi {
          constructor(t, r) {
            this.type = t, this.args = r
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            const n = t[0];
            if (!bn[n]) throw new Error(`Can't parse ${n} as it is not part of the known types`);
            if ((n === "to-boolean" || n === "to-string") && t.length !== 2) return r.error("Expected one argument.");
            const l = bn[n],
              p = [];
            for (let f = 1; f < t.length; f++) {
              const _ = r.parse(t[f], f, yr);
              if (!_) return null;
              p.push(_)
            }
            return new gi(l, p)
          }
          evaluate(t) {
            switch (this.type.kind) {
              case "boolean":
                return !!this.args[0].evaluate(t);
              case "color": {
                let r, n;
                for (const l of this.args) {
                  if (r = l.evaluate(t), n = null, r instanceof Ir) return r;
                  if (typeof r == "string") {
                    const p = t.parseColor(r);
                    if (p) return p
                  } else if (Array.isArray(r) && (n = r.length < 3 || r.length > 4 ? `Invalid rgba value ${JSON.stringify(r)}: expected an array containing either three or four numeric values.` : Da(r[0], r[1], r[2], r[3]), !n)) return new Ir(r[0] / 255, r[1] / 255, r[2] / 255, r[3])
                }
                throw new li(n || `Could not parse color from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "padding": {
                let r;
                for (const n of this.args) {
                  r = n.evaluate(t);
                  const l = Si.parse(r);
                  if (l) return l
                }
                throw new li(`Could not parse padding from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "numberArray": {
                let r;
                for (const n of this.args) {
                  r = n.evaluate(t);
                  const l = Pi.parse(r);
                  if (l) return l
                }
                throw new li(`Could not parse numberArray from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "colorArray": {
                let r;
                for (const n of this.args) {
                  r = n.evaluate(t);
                  const l = di.parse(r);
                  if (l) return l
                }
                throw new li(`Could not parse colorArray from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "variableAnchorOffsetCollection": {
                let r;
                for (const n of this.args) {
                  r = n.evaluate(t);
                  const l = Ui.parse(r);
                  if (l) return l
                }
                throw new li(`Could not parse variableAnchorOffsetCollection from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "number": {
                let r = null;
                for (const n of this.args) {
                  if (r = n.evaluate(t), r === null) return 0;
                  const l = Number(r);
                  if (!isNaN(l)) return l
                }
                throw new li(`Could not convert ${JSON.stringify(r)} to number.`)
              }
              case "formatted":
                return Ei.fromString(ca(this.args[0].evaluate(t)));
              case "resolvedImage":
                return ra.fromString(ca(this.args[0].evaluate(t)));
              case "projectionDefinition":
                return this.args[0].evaluate(t);
              default:
                return ca(this.args[0].evaluate(t))
            }
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return this.args.every((t => t.outputDefined()))
          }
        }
        const _i = ["Unknown", "Point", "LineString", "Polygon"];
        class Bn {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = new Map, this.availableImages = null, this.canonical = null
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? _i[this.feature.type] : this.feature.type : null
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null
          }
          canonicalID() {
            return this.canonical
          }
          properties() {
            return this.feature && this.feature.properties || {}
          }
          parseColor(t) {
            let r = this._parseColorCache.get(t);
            return r || (r = Ir.parse(t), this._parseColorCache.set(t, r)), r
          }
        }
        class Li {
          constructor(t, r, n = [], l, p = new Cr, f = []) {
            this.registry = t, this.path = n, this.key = n.map((_ => `[${_}]`)).join(""), this.scope = p, this.errors = f, this.expectedType = l, this._isConstant = r
          }
          parse(t, r, n, l, p = {}) {
            return r ? this.concat(r, n, l)._parse(t, p) : this._parse(t, p)
          }
          _parse(t, r) {
            function n(l, p, f) {
              return f === "assert" ? new Ti(p, [l]) : f === "coerce" ? new gi(p, [l]) : l
            }
            if (t !== null && typeof t != "string" && typeof t != "boolean" && typeof t != "number" || (t = ["literal", t]), Array.isArray(t)) {
              if (t.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const l = t[0];
              if (typeof l != "string") return this.error(`Expression name must be a string, but found ${typeof l} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const p = this.registry[l];
              if (p) {
                let f = p.parse(t, this);
                if (!f) return null;
                if (this.expectedType) {
                  const _ = this.expectedType,
                    x = f.type;
                  if (_.kind !== "string" && _.kind !== "number" && _.kind !== "boolean" && _.kind !== "object" && _.kind !== "array" || x.kind !== "value") {
                    if (_.kind === "projectionDefinition" && ["string", "array"].includes(x.kind) || ["color", "formatted", "resolvedImage"].includes(_.kind) && ["value", "string"].includes(x.kind) || ["padding", "numberArray"].includes(_.kind) && ["value", "number", "array"].includes(x.kind) || _.kind === "colorArray" && ["value", "string", "array"].includes(x.kind) || _.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(x.kind)) f = n(f, _, r.typeAnnotation || "coerce");
                    else if (this.checkSubtype(_, x)) return null
                  } else f = n(f, _, r.typeAnnotation || "assert")
                }
                if (!(f instanceof Pa) && f.type.kind !== "resolvedImage" && this._isConstant(f)) {
                  const _ = new Bn;
                  try {
                    f = new Pa(f.type, f.evaluate(_))
                  } catch (x) {
                    return this.error(x.message), null
                  }
                }
                return f
              }
              return this.error(`Unknown expression "${l}". If you wanted a literal array, use ["literal", [...]].`, 0)
            }
            return this.error(t === void 0 ? "'undefined' value invalid. Use null instead." : typeof t == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`)
          }
          concat(t, r, n) {
            const l = typeof t == "number" ? this.path.concat(t) : this.path,
              p = n ? this.scope.concat(n) : this.scope;
            return new Li(this.registry, this._isConstant, l, r || null, p, this.errors)
          }
          error(t, ...r) {
            const n = `${this.key}${r.map((l=>`[${l}]`)).join("")}`;
            this.errors.push(new Kt(n, t))
          }
          checkSubtype(t, r) {
            const n = Rr(t, r);
            return n && this.error(n), n
          }
        }
        class On {
          constructor(t, r) {
            this.type = r.type, this.bindings = [].concat(t), this.result = r
          }
          evaluate(t) {
            return this.result.evaluate(t)
          }
          eachChild(t) {
            for (const r of this.bindings) t(r[1]);
            t(this.result)
          }
          static parse(t, r) {
            if (t.length < 4) return r.error(`Expected at least 3 arguments, but found ${t.length-1} instead.`);
            const n = [];
            for (let p = 1; p < t.length - 1; p += 2) {
              const f = t[p];
              if (typeof f != "string") return r.error(`Expected string, but found ${typeof f} instead.`, p);
              if (/[^a-zA-Z0-9_]/.test(f)) return r.error("Variable names must contain only alphanumeric characters or '_'.", p);
              const _ = r.parse(t[p + 1], p + 1);
              if (!_) return null;
              n.push([f, _])
            }
            const l = r.parse(t[t.length - 1], t.length - 1, r.expectedType, n);
            return l ? new On(n, l) : null
          }
          outputDefined() {
            return this.result.outputDefined()
          }
        }
        class qa {
          constructor(t, r) {
            this.type = r.type, this.name = t, this.boundExpression = r
          }
          static parse(t, r) {
            if (t.length !== 2 || typeof t[1] != "string") return r.error("'var' expression requires exactly one string literal argument.");
            const n = t[1];
            return r.scope.has(n) ? new qa(n, r.scope.get(n)) : r.error(`Unknown variable "${n}". Make sure "${n}" has been bound in an enclosing "let" expression before using it.`, 1)
          }
          evaluate(t) {
            return this.boundExpression.evaluate(t)
          }
          eachChild() {}
          outputDefined() {
            return !1
          }
        }
        class Qn {
          constructor(t, r, n) {
            this.type = t, this.index = r, this.input = n
          }
          static parse(t, r) {
            if (t.length !== 3) return r.error(`Expected 2 arguments, but found ${t.length-1} instead.`);
            const n = r.parse(t[1], 1, Je),
              l = r.parse(t[2], 2, ar(r.expectedType || yr));
            return n && l ? new Qn(l.type.itemType, n, l) : null
          }
          evaluate(t) {
            const r = this.index.evaluate(t),
              n = this.input.evaluate(t);
            if (r < 0) throw new li(`Array index out of bounds: ${r} < 0.`);
            if (r >= n.length) throw new li(`Array index out of bounds: ${r} > ${n.length-1}.`);
            if (r !== Math.floor(r)) throw new li(`Array index must be an integer, but found ${r} instead.`);
            return n[r]
          }
          eachChild(t) {
            t(this.index), t(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        class jn {
          constructor(t, r) {
            this.type = Yt, this.needle = t, this.haystack = r
          }
          static parse(t, r) {
            if (t.length !== 3) return r.error(`Expected 2 arguments, but found ${t.length-1} instead.`);
            const n = r.parse(t[1], 1, yr),
              l = r.parse(t[2], 2, yr);
            return n && l ? Or(n.type, [Yt, tr, Je, fr, yr]) ? new jn(n, l) : r.error(`Expected first argument to be of type boolean, string, number or null, but found ${Ar(n.type)} instead`) : null
          }
          evaluate(t) {
            const r = this.needle.evaluate(t),
              n = this.haystack.evaluate(t);
            if (!n) return !1;
            if (!Fr(r, ["boolean", "string", "number", "null"])) throw new li(`Expected first argument to be of type boolean, string, number or null, but found ${Ar(Ki(r))} instead.`);
            if (!Fr(n, ["string", "array"])) throw new li(`Expected second argument to be of type array or string, but found ${Ar(Ki(n))} instead.`);
            return n.indexOf(r) >= 0
          }
          eachChild(t) {
            t(this.needle), t(this.haystack)
          }
          outputDefined() {
            return !0
          }
        }
        class wn {
          constructor(t, r, n) {
            this.type = Je, this.needle = t, this.haystack = r, this.fromIndex = n
          }
          static parse(t, r) {
            if (t.length <= 2 || t.length >= 5) return r.error(`Expected 2 or 3 arguments, but found ${t.length-1} instead.`);
            const n = r.parse(t[1], 1, yr),
              l = r.parse(t[2], 2, yr);
            if (!n || !l) return null;
            if (!Or(n.type, [Yt, tr, Je, fr, yr])) return r.error(`Expected first argument to be of type boolean, string, number or null, but found ${Ar(n.type)} instead`);
            if (t.length === 4) {
              const p = r.parse(t[3], 3, Je);
              return p ? new wn(n, l, p) : null
            }
            return new wn(n, l)
          }
          evaluate(t) {
            const r = this.needle.evaluate(t),
              n = this.haystack.evaluate(t);
            if (!Fr(r, ["boolean", "string", "number", "null"])) throw new li(`Expected first argument to be of type boolean, string, number or null, but found ${Ar(Ki(r))} instead.`);
            let l;
            if (this.fromIndex && (l = this.fromIndex.evaluate(t)), Fr(n, ["string"])) {
              const p = n.indexOf(r, l);
              return p === -1 ? -1 : [...n.slice(0, p)].length
            }
            if (Fr(n, ["array"])) return n.indexOf(r, l);
            throw new li(`Expected second argument to be of type array or string, but found ${Ar(Ki(n))} instead.`)
          }
          eachChild(t) {
            t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex)
          }
          outputDefined() {
            return !1
          }
        }
        class ns {
          constructor(t, r, n, l, p, f) {
            this.inputType = t, this.type = r, this.input = n, this.cases = l, this.outputs = p, this.otherwise = f
          }
          static parse(t, r) {
            if (t.length < 5) return r.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
            if (t.length % 2 != 1) return r.error("Expected an even number of arguments.");
            let n, l;
            r.expectedType && r.expectedType.kind !== "value" && (l = r.expectedType);
            const p = {},
              f = [];
            for (let M = 2; M < t.length - 1; M += 2) {
              let C = t[M];
              const L = t[M + 1];
              Array.isArray(C) || (C = [C]);
              const O = r.concat(M);
              if (C.length === 0) return O.error("Expected at least one branch label.");
              for (const G of C) {
                if (typeof G != "number" && typeof G != "string") return O.error("Branch labels must be numbers or strings.");
                if (typeof G == "number" && Math.abs(G) > Number.MAX_SAFE_INTEGER) return O.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof G == "number" && Math.floor(G) !== G) return O.error("Numeric branch labels must be integer values.");
                if (n) {
                  if (O.checkSubtype(n, Ki(G))) return null
                } else n = Ki(G);
                if (p[String(G)] !== void 0) return O.error("Branch labels must be unique.");
                p[String(G)] = f.length
              }
              const N = r.parse(L, M, l);
              if (!N) return null;
              l = l || N.type, f.push(N)
            }
            const _ = r.parse(t[1], 1, yr);
            if (!_) return null;
            const x = r.parse(t[t.length - 1], t.length - 1, l);
            return x ? _.type.kind !== "value" && r.concat(1).checkSubtype(n, _.type) ? null : new ns(n, l, _, p, f, x) : null
          }
          evaluate(t) {
            const r = this.input.evaluate(t);
            return (Ki(r) === this.inputType && this.outputs[this.cases[r]] || this.otherwise).evaluate(t)
          }
          eachChild(t) {
            t(this.input), this.outputs.forEach(t), t(this.otherwise)
          }
          outputDefined() {
            return this.outputs.every((t => t.outputDefined())) && this.otherwise.outputDefined()
          }
        }
        class qn {
          constructor(t, r, n) {
            this.type = t, this.branches = r, this.otherwise = n
          }
          static parse(t, r) {
            if (t.length < 4) return r.error(`Expected at least 3 arguments, but found only ${t.length-1}.`);
            if (t.length % 2 != 0) return r.error("Expected an odd number of arguments.");
            let n;
            r.expectedType && r.expectedType.kind !== "value" && (n = r.expectedType);
            const l = [];
            for (let f = 1; f < t.length - 1; f += 2) {
              const _ = r.parse(t[f], f, Yt);
              if (!_) return null;
              const x = r.parse(t[f + 1], f + 1, n);
              if (!x) return null;
              l.push([_, x]), n = n || x.type
            }
            const p = r.parse(t[t.length - 1], t.length - 1, n);
            if (!p) return null;
            if (!n) throw new Error("Can't infer output type");
            return new qn(n, l, p)
          }
          evaluate(t) {
            for (const [r, n] of this.branches)
              if (r.evaluate(t)) return n.evaluate(t);
            return this.otherwise.evaluate(t)
          }
          eachChild(t) {
            for (const [r, n] of this.branches) t(r), t(n);
            t(this.otherwise)
          }
          outputDefined() {
            return this.branches.every((([t, r]) => r.outputDefined())) && this.otherwise.outputDefined()
          }
        }
        class es {
          constructor(t, r, n, l) {
            this.type = t, this.input = r, this.beginIndex = n, this.endIndex = l
          }
          static parse(t, r) {
            if (t.length <= 2 || t.length >= 5) return r.error(`Expected 2 or 3 arguments, but found ${t.length-1} instead.`);
            const n = r.parse(t[1], 1, yr),
              l = r.parse(t[2], 2, Je);
            if (!n || !l) return null;
            if (!Or(n.type, [ar(yr), tr, yr])) return r.error(`Expected first argument to be of type array or string, but found ${Ar(n.type)} instead`);
            if (t.length === 4) {
              const p = r.parse(t[3], 3, Je);
              return p ? new es(n.type, n, l, p) : null
            }
            return new es(n.type, n, l)
          }
          evaluate(t) {
            const r = this.input.evaluate(t),
              n = this.beginIndex.evaluate(t);
            let l;
            if (this.endIndex && (l = this.endIndex.evaluate(t)), Fr(r, ["string"])) return [...r].slice(n, l).join("");
            if (Fr(r, ["array"])) return r.slice(n, l);
            throw new li(`Expected first argument to be of type array or string, but found ${Ar(Ki(r))} instead.`)
          }
          eachChild(t) {
            t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex)
          }
          outputDefined() {
            return !1
          }
        }

        function ua(i, t) {
          const r = i.length - 1;
          let n, l, p = 0,
            f = r,
            _ = 0;
          for (; p <= f;)
            if (_ = Math.floor((p + f) / 2), n = i[_], l = i[_ + 1], n <= t) {
              if (_ === r || t < l) return _;
              p = _ + 1
            } else {
              if (!(n > t)) throw new li("Input is not a number.");
              f = _ - 1
            } return 0
        }
        class Ma {
          constructor(t, r, n) {
            this.type = t, this.input = r, this.labels = [], this.outputs = [];
            for (const [l, p] of n) this.labels.push(l), this.outputs.push(p)
          }
          static parse(t, r) {
            if (t.length - 1 < 4) return r.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
            if ((t.length - 1) % 2 != 0) return r.error("Expected an even number of arguments.");
            const n = r.parse(t[1], 1, Je);
            if (!n) return null;
            const l = [];
            let p = null;
            r.expectedType && r.expectedType.kind !== "value" && (p = r.expectedType);
            for (let f = 1; f < t.length; f += 2) {
              const _ = f === 1 ? -1 / 0 : t[f],
                x = t[f + 1],
                M = f,
                C = f + 1;
              if (typeof _ != "number") return r.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', M);
              if (l.length && l[l.length - 1][0] >= _) return r.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', M);
              const L = r.parse(x, C, p);
              if (!L) return null;
              p = p || L.type, l.push([_, L])
            }
            return new Ma(p, n, l)
          }
          evaluate(t) {
            const r = this.labels,
              n = this.outputs;
            if (r.length === 1) return n[0].evaluate(t);
            const l = this.input.evaluate(t);
            if (l <= r[0]) return n[0].evaluate(t);
            const p = r.length;
            return l >= r[p - 1] ? n[p - 1].evaluate(t) : n[ua(r, l)].evaluate(t)
          }
          eachChild(t) {
            t(this.input);
            for (const r of this.outputs) t(r)
          }
          outputDefined() {
            return this.outputs.every((t => t.outputDefined()))
          }
        }

        function fn(i) {
          return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i
        }
        var ha, Vn, Fs = (function() {
            if (Vn) return ha;

            function i(t, r, n, l) {
              this.cx = 3 * t, this.bx = 3 * (n - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * r, this.by = 3 * (l - r) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = r, this.p2x = n, this.p2y = l
            }
            return Vn = 1, ha = i, i.prototype = {
              sampleCurveX: function(t) {
                return ((this.ax * t + this.bx) * t + this.cx) * t
              },
              sampleCurveY: function(t) {
                return ((this.ay * t + this.by) * t + this.cy) * t
              },
              sampleCurveDerivativeX: function(t) {
                return (3 * this.ax * t + 2 * this.bx) * t + this.cx
              },
              solveCurveX: function(t, r) {
                if (r === void 0 && (r = 1e-6), t < 0) return 0;
                if (t > 1) return 1;
                for (var n = t, l = 0; l < 8; l++) {
                  var p = this.sampleCurveX(n) - t;
                  if (Math.abs(p) < r) return n;
                  var f = this.sampleCurveDerivativeX(n);
                  if (Math.abs(f) < 1e-6) break;
                  n -= p / f
                }
                var _ = 0,
                  x = 1;
                for (n = t, l = 0; l < 20 && (p = this.sampleCurveX(n), !(Math.abs(p - t) < r)); l++) t > p ? _ = n : x = n, n = .5 * (x - _) + _;
                return n
              },
              solve: function(t, r) {
                return this.sampleCurveY(this.solveCurveX(t, r))
              }
            }, ha
          })(),
          _o = fn(Fs);
        class Gi {
          constructor(t, r, n, l, p) {
            this.type = t, this.operator = r, this.interpolation = n, this.input = l, this.labels = [], this.outputs = [];
            for (const [f, _] of p) this.labels.push(f), this.outputs.push(_)
          }
          static interpolationFactor(t, r, n, l) {
            let p = 0;
            if (t.name === "exponential") p = bl(r, t.base, n, l);
            else if (t.name === "linear") p = bl(r, 1, n, l);
            else if (t.name === "cubic-bezier") {
              const f = t.controlPoints;
              p = new _o(f[0], f[1], f[2], f[3]).solve(bl(r, 1, n, l))
            }
            return p
          }
          static parse(t, r) {
            let [n, l, p, ...f] = t;
            if (!Array.isArray(l) || l.length === 0) return r.error("Expected an interpolation type expression.", 1);
            if (l[0] === "linear") l = {
              name: "linear"
            };
            else if (l[0] === "exponential") {
              const M = l[1];
              if (typeof M != "number") return r.error("Exponential interpolation requires a numeric base.", 1, 1);
              l = {
                name: "exponential",
                base: M
              }
            } else {
              if (l[0] !== "cubic-bezier") return r.error(`Unknown interpolation type ${String(l[0])}`, 1, 0);
              {
                const M = l.slice(1);
                if (M.length !== 4 || M.some((C => typeof C != "number" || C < 0 || C > 1))) return r.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                l = {
                  name: "cubic-bezier",
                  controlPoints: M
                }
              }
            }
            if (t.length - 1 < 4) return r.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
            if ((t.length - 1) % 2 != 0) return r.error("Expected an even number of arguments.");
            if (p = r.parse(p, 2, Je), !p) return null;
            const _ = [];
            let x = null;
            n !== "interpolate-hcl" && n !== "interpolate-lab" || r.expectedType == xt ? r.expectedType && r.expectedType.kind !== "value" && (x = r.expectedType) : x = Tr;
            for (let M = 0; M < f.length; M += 2) {
              const C = f[M],
                L = f[M + 1],
                O = M + 3,
                N = M + 4;
              if (typeof C != "number") return r.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', O);
              if (_.length && _[_.length - 1][0] >= C) return r.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', O);
              const G = r.parse(L, N, x);
              if (!G) return null;
              x = x || G.type, _.push([C, G])
            }
            return ti(x, Je) || ti(x, Dr) || ti(x, Tr) || ti(x, Ue) || ti(x, Gt) || ti(x, xt) || ti(x, dr) || ti(x, ar(Je)) ? new Gi(x, n, l, p, _) : r.error(`Type ${Ar(x)} is not interpolatable.`)
          }
          evaluate(t) {
            const r = this.labels,
              n = this.outputs;
            if (r.length === 1) return n[0].evaluate(t);
            const l = this.input.evaluate(t);
            if (l <= r[0]) return n[0].evaluate(t);
            const p = r.length;
            if (l >= r[p - 1]) return n[p - 1].evaluate(t);
            const f = ua(r, l),
              _ = Gi.interpolationFactor(this.interpolation, l, r[f], r[f + 1]),
              x = n[f].evaluate(t),
              M = n[f + 1].evaluate(t);
            switch (this.operator) {
              case "interpolate":
                switch (this.type.kind) {
                  case "number":
                    return kr(x, M, _);
                  case "color":
                    return Ir.interpolate(x, M, _);
                  case "padding":
                    return Si.interpolate(x, M, _);
                  case "colorArray":
                    return di.interpolate(x, M, _);
                  case "numberArray":
                    return Pi.interpolate(x, M, _);
                  case "variableAnchorOffsetCollection":
                    return Ui.interpolate(x, M, _);
                  case "array":
                    return mi(x, M, _);
                  case "projectionDefinition":
                    return sa.interpolate(x, M, _)
                }
              case "interpolate-hcl":
                switch (this.type.kind) {
                  case "color":
                    return Ir.interpolate(x, M, _, "hcl");
                  case "colorArray":
                    return di.interpolate(x, M, _, "hcl")
                }
              case "interpolate-lab":
                switch (this.type.kind) {
                  case "color":
                    return Ir.interpolate(x, M, _, "lab");
                  case "colorArray":
                    return di.interpolate(x, M, _, "lab")
                }
            }
          }
          eachChild(t) {
            t(this.input);
            for (const r of this.outputs) t(r)
          }
          outputDefined() {
            return this.outputs.every((t => t.outputDefined()))
          }
        }

        function bl(i, t, r, n) {
          const l = n - r,
            p = i - r;
          return l === 0 ? 0 : t === 1 ? p / l : (Math.pow(t, p) - 1) / (Math.pow(t, l) - 1)
        }
        const zn = {
          color: Ir.interpolate,
          number: kr,
          padding: Si.interpolate,
          numberArray: Pi.interpolate,
          colorArray: di.interpolate,
          variableAnchorOffsetCollection: Ui.interpolate,
          array: mi
        };
        class qo {
          constructor(t, r) {
            this.type = t, this.args = r
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            let n = null;
            const l = r.expectedType;
            l && l.kind !== "value" && (n = l);
            const p = [];
            for (const _ of t.slice(1)) {
              const x = r.parse(_, 1 + p.length, n, void 0, {
                typeAnnotation: "omit"
              });
              if (!x) return null;
              n = n || x.type, p.push(x)
            }
            if (!n) throw new Error("No output type");
            const f = l && p.some((_ => Rr(l, _.type)));
            return new qo(f ? yr : n, p)
          }
          evaluate(t) {
            let r, n = null,
              l = 0;
            for (const p of this.args)
              if (l++, n = p.evaluate(t), n && n instanceof ra && !n.available && (r || (r = n.name), n = null, l === this.args.length && (n = r)), n !== null) break;
            return n
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return this.args.every((t => t.outputDefined()))
          }
        }

        function Lh(i, t) {
          return i === "==" || i === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value"
        }

        function Bs(i, t, r, n) {
          return n.compare(t, r) === 0
        }

        function ss(i, t, r) {
          const n = i !== "==" && i !== "!=";
          return class E0 {
            constructor(p, f, _) {
              this.type = Yt, this.lhs = p, this.rhs = f, this.collator = _, this.hasUntypedArgument = p.type.kind === "value" || f.type.kind === "value"
            }
            static parse(p, f) {
              if (p.length !== 3 && p.length !== 4) return f.error("Expected two or three arguments.");
              const _ = p[0];
              let x = f.parse(p[1], 1, yr);
              if (!x) return null;
              if (!Lh(_, x.type)) return f.concat(1).error(`"${_}" comparisons are not supported for type '${Ar(x.type)}'.`);
              let M = f.parse(p[2], 2, yr);
              if (!M) return null;
              if (!Lh(_, M.type)) return f.concat(2).error(`"${_}" comparisons are not supported for type '${Ar(M.type)}'.`);
              if (x.type.kind !== M.type.kind && x.type.kind !== "value" && M.type.kind !== "value") return f.error(`Cannot compare types '${Ar(x.type)}' and '${Ar(M.type)}'.`);
              n && (x.type.kind === "value" && M.type.kind !== "value" ? x = new Ti(M.type, [x]) : x.type.kind !== "value" && M.type.kind === "value" && (M = new Ti(x.type, [M])));
              let C = null;
              if (p.length === 4) {
                if (x.type.kind !== "string" && M.type.kind !== "string" && x.type.kind !== "value" && M.type.kind !== "value") return f.error("Cannot use collator to compare non-string types.");
                if (C = f.parse(p[3], 3, qt), !C) return null
              }
              return new E0(x, M, C)
            }
            evaluate(p) {
              const f = this.lhs.evaluate(p),
                _ = this.rhs.evaluate(p);
              if (n && this.hasUntypedArgument) {
                const x = Ki(f),
                  M = Ki(_);
                if (x.kind !== M.kind || x.kind !== "string" && x.kind !== "number") throw new li(`Expected arguments for "${i}" to be (string, string) or (number, number), but found (${x.kind}, ${M.kind}) instead.`)
              }
              if (this.collator && !n && this.hasUntypedArgument) {
                const x = Ki(f),
                  M = Ki(_);
                if (x.kind !== "string" || M.kind !== "string") return t(p, f, _)
              }
              return this.collator ? r(p, f, _, this.collator.evaluate(p)) : t(p, f, _)
            }
            eachChild(p) {
              p(this.lhs), p(this.rhs), this.collator && p(this.collator)
            }
            outputDefined() {
              return !0
            }
          }
        }
        const Bc = ss("==", (function(i, t, r) {
            return t === r
          }), Bs),
          Fp = ss("!=", (function(i, t, r) {
            return t !== r
          }), (function(i, t, r, n) {
            return !Bs(0, t, r, n)
          })),
          Dh = ss("<", (function(i, t, r) {
            return t < r
          }), (function(i, t, r, n) {
            return n.compare(t, r) < 0
          })),
          wl = ss(">", (function(i, t, r) {
            return t > r
          }), (function(i, t, r, n) {
            return n.compare(t, r) > 0
          })),
          Tl = ss("<=", (function(i, t, r) {
            return t <= r
          }), (function(i, t, r, n) {
            return n.compare(t, r) <= 0
          })),
          Zn = ss(">=", (function(i, t, r) {
            return t >= r
          }), (function(i, t, r, n) {
            return n.compare(t, r) >= 0
          }));
        class Vo {
          constructor(t, r, n) {
            this.type = qt, this.locale = n, this.caseSensitive = t, this.diacriticSensitive = r
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error("Expected one argument.");
            const n = t[1];
            if (typeof n != "object" || Array.isArray(n)) return r.error("Collator options argument must be an object.");
            const l = r.parse(n["case-sensitive"] !== void 0 && n["case-sensitive"], 1, Yt);
            if (!l) return null;
            const p = r.parse(n["diacritic-sensitive"] !== void 0 && n["diacritic-sensitive"], 1, Yt);
            if (!p) return null;
            let f = null;
            return n.locale && (f = r.parse(n.locale, 1, tr), !f) ? null : new Vo(l, p, f)
          }
          evaluate(t) {
            return new ei(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null)
          }
          eachChild(t) {
            t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale)
          }
          outputDefined() {
            return !1
          }
        }
        class vo {
          constructor(t, r, n, l, p) {
            this.type = tr, this.number = t, this.locale = r, this.currency = n, this.minFractionDigits = l, this.maxFractionDigits = p
          }
          static parse(t, r) {
            if (t.length !== 3) return r.error("Expected two arguments.");
            const n = r.parse(t[1], 1, Je);
            if (!n) return null;
            const l = t[2];
            if (typeof l != "object" || Array.isArray(l)) return r.error("NumberFormat options argument must be an object.");
            let p = null;
            if (l.locale && (p = r.parse(l.locale, 1, tr), !p)) return null;
            let f = null;
            if (l.currency && (f = r.parse(l.currency, 1, tr), !f)) return null;
            let _ = null;
            if (l["min-fraction-digits"] && (_ = r.parse(l["min-fraction-digits"], 1, Je), !_)) return null;
            let x = null;
            return l["max-fraction-digits"] && (x = r.parse(l["max-fraction-digits"], 1, Je), !x) ? null : new vo(n, p, f, _, x)
          }
          evaluate(t) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], {
              style: this.currency ? "currency" : "decimal",
              currency: this.currency ? this.currency.evaluate(t) : void 0,
              minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,
              maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0
            }).format(this.number.evaluate(t))
          }
          eachChild(t) {
            t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits)
          }
          outputDefined() {
            return !1
          }
        }
        class Sl {
          constructor(t) {
            this.type = bt, this.sections = t
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            const n = t[1];
            if (!Array.isArray(n) && typeof n == "object") return r.error("First argument must be an image or text section.");
            const l = [];
            let p = !1;
            for (let f = 1; f <= t.length - 1; ++f) {
              const _ = t[f];
              if (p && typeof _ == "object" && !Array.isArray(_)) {
                p = !1;
                let x = null;
                if (_["font-scale"] && (x = r.parse(_["font-scale"], 1, Je), !x)) return null;
                let M = null;
                if (_["text-font"] && (M = r.parse(_["text-font"], 1, ar(tr)), !M)) return null;
                let C = null;
                if (_["text-color"] && (C = r.parse(_["text-color"], 1, Tr), !C)) return null;
                let L = null;
                if (_["vertical-align"]) {
                  if (typeof _["vertical-align"] == "string" && !Ni.includes(_["vertical-align"])) return r.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${_["vertical-align"]}' instead.`);
                  if (L = r.parse(_["vertical-align"], 1, tr), !L) return null
                }
                const O = l[l.length - 1];
                O.scale = x, O.font = M, O.textColor = C, O.verticalAlign = L
              } else {
                const x = r.parse(t[f], 1, yr);
                if (!x) return null;
                const M = x.type.kind;
                if (M !== "string" && M !== "value" && M !== "null" && M !== "resolvedImage") return r.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                p = !0, l.push({
                  content: x,
                  scale: null,
                  font: null,
                  textColor: null,
                  verticalAlign: null
                })
              }
            }
            return new Sl(l)
          }
          evaluate(t) {
            return new Ei(this.sections.map((r => {
              const n = r.content.evaluate(t);
              return Ki(n) === kt ? new Oi("", n, null, null, null, r.verticalAlign ? r.verticalAlign.evaluate(t) : null) : new Oi(ca(n), null, r.scale ? r.scale.evaluate(t) : null, r.font ? r.font.evaluate(t).join(",") : null, r.textColor ? r.textColor.evaluate(t) : null, r.verticalAlign ? r.verticalAlign.evaluate(t) : null)
            })))
          }
          eachChild(t) {
            for (const r of this.sections) t(r.content), r.scale && t(r.scale), r.font && t(r.font), r.textColor && t(r.textColor), r.verticalAlign && t(r.verticalAlign)
          }
          outputDefined() {
            return !1
          }
        }
        class Zo {
          constructor(t) {
            this.type = kt, this.input = t
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error("Expected two arguments.");
            const n = r.parse(t[1], 1, tr);
            return n ? new Zo(n) : r.error("No image name provided.")
          }
          evaluate(t) {
            const r = this.input.evaluate(t),
              n = ra.fromString(r);
            return n && t.availableImages && (n.available = t.availableImages.indexOf(r) > -1), n
          }
          eachChild(t) {
            t(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        class Oc {
          constructor(t) {
            this.type = Je, this.input = t
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`Expected 1 argument, but found ${t.length-1} instead.`);
            const n = r.parse(t[1], 1);
            return n ? n.type.kind !== "array" && n.type.kind !== "string" && n.type.kind !== "value" ? r.error(`Expected argument of type string or array, but found ${Ar(n.type)} instead.`) : new Oc(n) : null
          }
          evaluate(t) {
            const r = this.input.evaluate(t);
            if (typeof r == "string") return [...r].length;
            if (Array.isArray(r)) return r.length;
            throw new li(`Expected value to be of type string or array, but found ${Ar(Ki(r))} instead.`)
          }
          eachChild(t) {
            t(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        const ts = 8192;

        function Bp(i, t) {
          const r = (180 + i[0]) / 360,
            n = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i[1] * Math.PI / 360))) / 360,
            l = Math.pow(2, t.z);
          return [Math.round(r * l * ts), Math.round(n * l * ts)]
        }

        function jc(i, t) {
          const r = Math.pow(2, t.z);
          return [(l = (i[0] / ts + t.x) / r, 360 * l - 180), (n = (i[1] / ts + t.y) / r, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n) * Math.PI / 180)) - 90)];
          var n, l
        }

        function Ts(i, t) {
          i[0] = Math.min(i[0], t[0]), i[1] = Math.min(i[1], t[1]), i[2] = Math.max(i[2], t[0]), i[3] = Math.max(i[3], t[1])
        }

        function No(i, t) {
          return !(i[0] <= t[0] || i[2] >= t[2] || i[1] <= t[1] || i[3] >= t[3])
        }

        function Rh(i, t, r) {
          const n = i[0] - t[0],
            l = i[1] - t[1],
            p = i[0] - r[0],
            f = i[1] - r[1];
          return n * f - p * l == 0 && n * p <= 0 && l * f <= 0
        }

        function Uo(i, t, r, n) {
          return (l = [n[0] - r[0], n[1] - r[1]])[0] * (p = [t[0] - i[0], t[1] - i[1]])[1] - l[1] * p[0] != 0 && !(!Bh(i, t, r, n) || !Bh(r, n, i, t));
          var l, p
        }

        function Op(i, t, r) {
          for (const n of r)
            for (let l = 0; l < n.length - 1; ++l)
              if (Uo(i, t, n[l], n[l + 1])) return !0;
          return !1
        }

        function Os(i, t, r = !1) {
          let n = !1;
          for (const _ of t)
            for (let x = 0; x < _.length - 1; x++) {
              if (Rh(i, _[x], _[x + 1])) return r;
              (p = _[x])[1] > (l = i)[1] != (f = _[x + 1])[1] > l[1] && l[0] < (f[0] - p[0]) * (l[1] - p[1]) / (f[1] - p[1]) + p[0] && (n = !n)
            }
          var l, p, f;
          return n
        }

        function jp(i, t) {
          for (const r of t)
            if (Os(i, r)) return !0;
          return !1
        }

        function Fh(i, t) {
          for (const r of i)
            if (!Os(r, t)) return !1;
          for (let r = 0; r < i.length - 1; ++r)
            if (Op(i[r], i[r + 1], t)) return !1;
          return !0
        }

        function qp(i, t) {
          for (const r of t)
            if (Fh(i, r)) return !0;
          return !1
        }

        function Bh(i, t, r, n) {
          const l = n[0] - r[0],
            p = n[1] - r[1],
            f = (i[0] - r[0]) * p - l * (i[1] - r[1]),
            _ = (t[0] - r[0]) * p - l * (t[1] - r[1]);
          return f > 0 && _ < 0 || f < 0 && _ > 0
        }

        function qc(i, t, r) {
          const n = [];
          for (let l = 0; l < i.length; l++) {
            const p = [];
            for (let f = 0; f < i[l].length; f++) {
              const _ = Bp(i[l][f], r);
              Ts(t, _), p.push(_)
            }
            n.push(p)
          }
          return n
        }

        function Vc(i, t, r) {
          const n = [];
          for (let l = 0; l < i.length; l++) {
            const p = qc(i[l], t, r);
            n.push(p)
          }
          return n
        }

        function Zc(i, t, r, n) {
          if (i[0] < r[0] || i[0] > r[2]) {
            const l = .5 * n;
            let p = i[0] - r[0] > l ? -n : r[0] - i[0] > l ? n : 0;
            p === 0 && (p = i[0] - r[2] > l ? -n : r[2] - i[0] > l ? n : 0), i[0] += p
          }
          Ts(t, i)
        }

        function Nc(i, t, r, n) {
          const l = Math.pow(2, n.z) * ts,
            p = [n.x * ts, n.y * ts],
            f = [];
          for (const _ of i)
            for (const x of _) {
              const M = [x.x + p[0], x.y + p[1]];
              Zc(M, t, r, l), f.push(M)
            }
          return f
        }

        function Oh(i, t, r, n) {
          const l = Math.pow(2, n.z) * ts,
            p = [n.x * ts, n.y * ts],
            f = [];
          for (const x of i) {
            const M = [];
            for (const C of x) {
              const L = [C.x + p[0], C.y + p[1]];
              Ts(t, L), M.push(L)
            }
            f.push(M)
          }
          if (t[2] - t[0] <= l / 2) {
            (_ = t)[0] = _[1] = 1 / 0, _[2] = _[3] = -1 / 0;
            for (const x of f)
              for (const M of x) Zc(M, t, r, l)
          }
          var _;
          return f
        }
        class js {
          constructor(t, r) {
            this.type = Yt, this.geojson = t, this.geometries = r
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`'within' expression requires exactly one argument, but found ${t.length-1} instead.`);
            if (Sa(t[1])) {
              const n = t[1];
              if (n.type === "FeatureCollection") {
                const l = [];
                for (const p of n.features) {
                  const {
                    type: f,
                    coordinates: _
                  } = p.geometry;
                  f === "Polygon" && l.push(_), f === "MultiPolygon" && l.push(..._)
                }
                if (l.length) return new js(n, {
                  type: "MultiPolygon",
                  coordinates: l
                })
              } else if (n.type === "Feature") {
                const l = n.geometry.type;
                if (l === "Polygon" || l === "MultiPolygon") return new js(n, n.geometry)
              } else if (n.type === "Polygon" || n.type === "MultiPolygon") return new js(n, n)
            }
            return r.error("'within' expression requires valid geojson object that contains polygon geometry type.")
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(r, n) {
                const l = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  p = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  f = r.canonicalID();
                if (n.type === "Polygon") {
                  const _ = qc(n.coordinates, p, f),
                    x = Nc(r.geometry(), l, p, f);
                  if (!No(l, p)) return !1;
                  for (const M of x)
                    if (!Os(M, _)) return !1
                }
                if (n.type === "MultiPolygon") {
                  const _ = Vc(n.coordinates, p, f),
                    x = Nc(r.geometry(), l, p, f);
                  if (!No(l, p)) return !1;
                  for (const M of x)
                    if (!jp(M, _)) return !1
                }
                return !0
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(r, n) {
                const l = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  p = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  f = r.canonicalID();
                if (n.type === "Polygon") {
                  const _ = qc(n.coordinates, p, f),
                    x = Oh(r.geometry(), l, p, f);
                  if (!No(l, p)) return !1;
                  for (const M of x)
                    if (!Fh(M, _)) return !1
                }
                if (n.type === "MultiPolygon") {
                  const _ = Vc(n.coordinates, p, f),
                    x = Oh(r.geometry(), l, p, f);
                  if (!No(l, p)) return !1;
                  for (const M of x)
                    if (!qp(M, _)) return !1
                }
                return !0
              })(t, this.geometries)
            }
            return !1
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        let jh = class {
          constructor(i = [], t = (r, n) => r < n ? -1 : r > n ? 1 : 0) {
            if (this.data = i, this.length = this.data.length, this.compare = t, this.length > 0)
              for (let r = (this.length >> 1) - 1; r >= 0; r--) this._down(r)
          }
          push(i) {
            this.data.push(i), this._up(this.length++)
          }
          pop() {
            if (this.length === 0) return;
            const i = this.data[0],
              t = this.data.pop();
            return --this.length > 0 && (this.data[0] = t, this._down(0)), i
          }
          peek() {
            return this.data[0]
          }
          _up(i) {
            const {
              data: t,
              compare: r
            } = this, n = t[i];
            for (; i > 0;) {
              const l = i - 1 >> 1,
                p = t[l];
              if (r(n, p) >= 0) break;
              t[i] = p, i = l
            }
            t[i] = n
          }
          _down(i) {
            const {
              data: t,
              compare: r
            } = this, n = this.length >> 1, l = t[i];
            for (; i < n;) {
              let p = 1 + (i << 1);
              const f = p + 1;
              if (f < this.length && r(t[f], t[p]) < 0 && (p = f), r(t[p], l) >= 0) break;
              t[i] = t[p], i = p
            }
            t[i] = l
          }
        };

        function qh(i, t, r = 0, n = i.length - 1, l = Vp) {
          for (; n > r;) {
            if (n - r > 600) {
              const x = n - r + 1,
                M = t - r + 1,
                C = Math.log(x),
                L = .5 * Math.exp(2 * C / 3),
                O = .5 * Math.sqrt(C * L * (x - L) / x) * (M - x / 2 < 0 ? -1 : 1);
              qh(i, t, Math.max(r, Math.floor(t - M * L / x + O)), Math.min(n, Math.floor(t + (x - M) * L / x + O)), l)
            }
            const p = i[t];
            let f = r,
              _ = n;
            for (Ss(i, r, t), l(i[n], p) > 0 && Ss(i, r, n); f < _;) {
              for (Ss(i, f, _), f++, _--; l(i[f], p) < 0;) f++;
              for (; l(i[_], p) > 0;) _--
            }
            l(i[r], p) === 0 ? Ss(i, r, _) : (_++, Ss(i, _, n)), _ <= t && (r = _ + 1), t <= _ && (n = _ - 1)
          }
        }

        function Ss(i, t, r) {
          const n = i[t];
          i[t] = i[r], i[r] = n
        }

        function Vp(i, t) {
          return i < t ? -1 : i > t ? 1 : 0
        }

        function Pl(i, t) {
          if (i.length <= 1) return [i];
          const r = [];
          let n, l;
          for (const p of i) {
            const f = Np(p);
            f !== 0 && (p.area = Math.abs(f), l === void 0 && (l = f < 0), l === f < 0 ? (n && r.push(n), n = [p]) : n.push(p))
          }
          if (n && r.push(n), t > 1)
            for (let p = 0; p < r.length; p++) r[p].length <= t || (qh(r[p], t, 1, r[p].length - 1, Zp), r[p] = r[p].slice(0, t));
          return r
        }

        function Zp(i, t) {
          return t.area - i.area
        }

        function Np(i) {
          let t = 0;
          for (let r, n, l = 0, p = i.length, f = p - 1; l < p; f = l++) r = i[l], n = i[f], t += (n.x - r.x) * (r.y + n.y);
          return t
        }
        const Ml = 1 / 298.257223563,
          Uc = Ml * (2 - Ml),
          Vh = Math.PI / 180;
        class Gc {
          constructor(t) {
            const r = 6378.137 * Vh * 1e3,
              n = Math.cos(t * Vh),
              l = 1 / (1 - Uc * (1 - n * n)),
              p = Math.sqrt(l);
            this.kx = r * p * n, this.ky = r * p * l * (1 - Uc)
          }
          distance(t, r) {
            const n = this.wrap(t[0] - r[0]) * this.kx,
              l = (t[1] - r[1]) * this.ky;
            return Math.sqrt(n * n + l * l)
          }
          pointOnLine(t, r) {
            let n, l, p, f, _ = 1 / 0;
            for (let x = 0; x < t.length - 1; x++) {
              let M = t[x][0],
                C = t[x][1],
                L = this.wrap(t[x + 1][0] - M) * this.kx,
                O = (t[x + 1][1] - C) * this.ky,
                N = 0;
              L === 0 && O === 0 || (N = (this.wrap(r[0] - M) * this.kx * L + (r[1] - C) * this.ky * O) / (L * L + O * O), N > 1 ? (M = t[x + 1][0], C = t[x + 1][1]) : N > 0 && (M += L / this.kx * N, C += O / this.ky * N)), L = this.wrap(r[0] - M) * this.kx, O = (r[1] - C) * this.ky;
              const G = L * L + O * O;
              G < _ && (_ = G, n = M, l = C, p = x, f = N)
            }
            return {
              point: [n, l],
              index: p,
              t: Math.max(0, Math.min(1, f))
            }
          }
          wrap(t) {
            for (; t < -180;) t += 360;
            for (; t > 180;) t -= 360;
            return t
          }
        }

        function Wc(i, t) {
          return t[0] - i[0]
        }

        function Go(i) {
          return i[1] - i[0] + 1
        }

        function os(i, t) {
          return i[1] >= i[0] && i[1] < t
        }

        function Hc(i, t) {
          if (i[0] > i[1]) return [null, null];
          const r = Go(i);
          if (t) {
            if (r === 2) return [i, null];
            const l = Math.floor(r / 2);
            return [
              [i[0], i[0] + l],
              [i[0] + l, i[1]]
            ]
          }
          if (r === 1) return [i, null];
          const n = Math.floor(r / 2) - 1;
          return [
            [i[0], i[0] + n],
            [i[0] + n + 1, i[1]]
          ]
        }

        function $c(i, t) {
          if (!os(t, i.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let n = t[0]; n <= t[1]; ++n) Ts(r, i[n]);
          return r
        }

        function Il(i) {
          const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (const r of i)
            for (const n of r) Ts(t, n);
          return t
        }

        function Zh(i) {
          return i[0] !== -1 / 0 && i[1] !== -1 / 0 && i[2] !== 1 / 0 && i[3] !== 1 / 0
        }

        function Xc(i, t, r) {
          if (!Zh(i) || !Zh(t)) return NaN;
          let n = 0,
            l = 0;
          return i[2] < t[0] && (n = t[0] - i[2]), i[0] > t[2] && (n = i[0] - t[2]), i[1] > t[3] && (l = i[1] - t[3]), i[3] < t[1] && (l = t[1] - i[3]), r.distance([0, 0], [n, l])
        }

        function qs(i, t, r) {
          const n = r.pointOnLine(t, i);
          return r.distance(i, n.point)
        }

        function Yc(i, t, r, n, l) {
          const p = Math.min(qs(i, [r, n], l), qs(t, [r, n], l)),
            f = Math.min(qs(r, [i, t], l), qs(n, [i, t], l));
          return Math.min(p, f)
        }

        function Wi(i, t, r, n, l) {
          if (!os(t, i.length) || !os(n, r.length)) return 1 / 0;
          let p = 1 / 0;
          for (let f = t[0]; f < t[1]; ++f) {
            const _ = i[f],
              x = i[f + 1];
            for (let M = n[0]; M < n[1]; ++M) {
              const C = r[M],
                L = r[M + 1];
              if (Uo(_, x, C, L)) return 0;
              p = Math.min(p, Yc(_, x, C, L, l))
            }
          }
          return p
        }

        function Up(i, t, r, n, l) {
          if (!os(t, i.length) || !os(n, r.length)) return NaN;
          let p = 1 / 0;
          for (let f = t[0]; f <= t[1]; ++f)
            for (let _ = n[0]; _ <= n[1]; ++_)
              if (p = Math.min(p, l.distance(i[f], r[_])), p === 0) return p;
          return p
        }

        function Gp(i, t, r) {
          if (Os(i, t, !0)) return 0;
          let n = 1 / 0;
          for (const l of t) {
            const p = l[0],
              f = l[l.length - 1];
            if (p !== f && (n = Math.min(n, qs(i, [f, p], r)), n === 0)) return n;
            const _ = r.pointOnLine(l, i);
            if (n = Math.min(n, r.distance(i, _.point)), n === 0) return n
          }
          return n
        }

        function Wp(i, t, r, n) {
          if (!os(t, i.length)) return NaN;
          for (let p = t[0]; p <= t[1]; ++p)
            if (Os(i[p], r, !0)) return 0;
          let l = 1 / 0;
          for (let p = t[0]; p < t[1]; ++p) {
            const f = i[p],
              _ = i[p + 1];
            for (const x of r)
              for (let M = 0, C = x.length, L = C - 1; M < C; L = M++) {
                const O = x[L],
                  N = x[M];
                if (Uo(f, _, O, N)) return 0;
                l = Math.min(l, Yc(f, _, O, N, n))
              }
          }
          return l
        }

        function Nh(i, t) {
          for (const r of i)
            for (const n of r)
              if (Os(n, t, !0)) return !0;
          return !1
        }

        function Hp(i, t, r, n = 1 / 0) {
          const l = Il(i),
            p = Il(t);
          if (n !== 1 / 0 && Xc(l, p, r) >= n) return n;
          if (No(l, p)) {
            if (Nh(i, t)) return 0
          } else if (Nh(t, i)) return 0;
          let f = 1 / 0;
          for (const _ of i)
            for (let x = 0, M = _.length, C = M - 1; x < M; C = x++) {
              const L = _[C],
                O = _[x];
              for (const N of t)
                for (let G = 0, K = N.length, ie = K - 1; G < K; ie = G++) {
                  const pe = N[ie],
                    Ne = N[G];
                  if (Uo(L, O, pe, Ne)) return 0;
                  f = Math.min(f, Yc(L, O, pe, Ne, r))
                }
            }
          return f
        }

        function Uh(i, t, r, n, l, p) {
          if (!p) return;
          const f = Xc($c(n, p), l, r);
          f < t && i.push([f, p, [0, 0]])
        }

        function Cl(i, t, r, n, l, p, f) {
          if (!p || !f) return;
          const _ = Xc($c(n, p), $c(l, f), r);
          _ < t && i.push([_, p, f])
        }

        function Al(i, t, r, n, l = 1 / 0) {
          let p = Math.min(n.distance(i[0], r[0][0]), l);
          if (p === 0) return p;
          const f = new jh([
              [0, [0, i.length - 1],
                [0, 0]
              ]
            ], Wc),
            _ = Il(r);
          for (; f.length > 0;) {
            const x = f.pop();
            if (x[0] >= p) continue;
            const M = x[1],
              C = t ? 50 : 100;
            if (Go(M) <= C) {
              if (!os(M, i.length)) return NaN;
              if (t) {
                const L = Wp(i, M, r, n);
                if (isNaN(L) || L === 0) return L;
                p = Math.min(p, L)
              } else
                for (let L = M[0]; L <= M[1]; ++L) {
                  const O = Gp(i[L], r, n);
                  if (p = Math.min(p, O), p === 0) return 0
                }
            } else {
              const L = Hc(M, t);
              Uh(f, p, n, i, _, L[0]), Uh(f, p, n, i, _, L[1])
            }
          }
          return p
        }

        function kl(i, t, r, n, l, p = 1 / 0) {
          let f = Math.min(p, l.distance(i[0], r[0]));
          if (f === 0) return f;
          const _ = new jh([
            [0, [0, i.length - 1],
              [0, r.length - 1]
            ]
          ], Wc);
          for (; _.length > 0;) {
            const x = _.pop();
            if (x[0] >= f) continue;
            const M = x[1],
              C = x[2],
              L = t ? 50 : 100,
              O = n ? 50 : 100;
            if (Go(M) <= L && Go(C) <= O) {
              if (!os(M, i.length) && os(C, r.length)) return NaN;
              let N;
              if (t && n) N = Wi(i, M, r, C, l), f = Math.min(f, N);
              else if (t && !n) {
                const G = i.slice(M[0], M[1] + 1);
                for (let K = C[0]; K <= C[1]; ++K)
                  if (N = qs(r[K], G, l), f = Math.min(f, N), f === 0) return f
              } else if (!t && n) {
                const G = r.slice(C[0], C[1] + 1);
                for (let K = M[0]; K <= M[1]; ++K)
                  if (N = qs(i[K], G, l), f = Math.min(f, N), f === 0) return f
              } else N = Up(i, M, r, C, l), f = Math.min(f, N)
            } else {
              const N = Hc(M, t),
                G = Hc(C, n);
              Cl(_, f, l, i, r, N[0], G[0]), Cl(_, f, l, i, r, N[0], G[1]), Cl(_, f, l, i, r, N[1], G[0]), Cl(_, f, l, i, r, N[1], G[1])
            }
          }
          return f
        }

        function Kc(i) {
          return i.type === "MultiPolygon" ? i.coordinates.map((t => ({
            type: "Polygon",
            coordinates: t
          }))) : i.type === "MultiLineString" ? i.coordinates.map((t => ({
            type: "LineString",
            coordinates: t
          }))) : i.type === "MultiPoint" ? i.coordinates.map((t => ({
            type: "Point",
            coordinates: t
          }))) : [i]
        }
        class Vs {
          constructor(t, r) {
            this.type = Je, this.geojson = t, this.geometries = r
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`'distance' expression requires exactly one argument, but found ${t.length-1} instead.`);
            if (Sa(t[1])) {
              const n = t[1];
              if (n.type === "FeatureCollection") return new Vs(n, n.features.map((l => Kc(l.geometry))).flat());
              if (n.type === "Feature") return new Vs(n, Kc(n.geometry));
              if ("type" in n && "coordinates" in n) return new Vs(n, Kc(n))
            }
            return r.error("'distance' expression requires valid geojson object that contains polygon geometry type.")
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(r, n) {
                const l = r.geometry(),
                  p = l.flat().map((x => jc([x.x, x.y], r.canonical)));
                if (l.length === 0) return NaN;
                const f = new Gc(p[0][1]);
                let _ = 1 / 0;
                for (const x of n) {
                  switch (x.type) {
                    case "Point":
                      _ = Math.min(_, kl(p, !1, [x.coordinates], !1, f, _));
                      break;
                    case "LineString":
                      _ = Math.min(_, kl(p, !1, x.coordinates, !0, f, _));
                      break;
                    case "Polygon":
                      _ = Math.min(_, Al(p, !1, x.coordinates, f, _))
                  }
                  if (_ === 0) return _
                }
                return _
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(r, n) {
                const l = r.geometry(),
                  p = l.flat().map((x => jc([x.x, x.y], r.canonical)));
                if (l.length === 0) return NaN;
                const f = new Gc(p[0][1]);
                let _ = 1 / 0;
                for (const x of n) {
                  switch (x.type) {
                    case "Point":
                      _ = Math.min(_, kl(p, !0, [x.coordinates], !1, f, _));
                      break;
                    case "LineString":
                      _ = Math.min(_, kl(p, !0, x.coordinates, !0, f, _));
                      break;
                    case "Polygon":
                      _ = Math.min(_, Al(p, !0, x.coordinates, f, _))
                  }
                  if (_ === 0) return _
                }
                return _
              })(t, this.geometries);
              if (t.geometryType() === "Polygon") return (function(r, n) {
                const l = r.geometry();
                if (l.length === 0 || l[0].length === 0) return NaN;
                const p = Pl(l, 0).map((x => x.map((M => M.map((C => jc([C.x, C.y], r.canonical))))))),
                  f = new Gc(p[0][0][0][1]);
                let _ = 1 / 0;
                for (const x of n)
                  for (const M of p) {
                    switch (x.type) {
                      case "Point":
                        _ = Math.min(_, Al([x.coordinates], !1, M, f, _));
                        break;
                      case "LineString":
                        _ = Math.min(_, Al(x.coordinates, !0, M, f, _));
                        break;
                      case "Polygon":
                        _ = Math.min(_, Hp(M, x.coordinates, f, _))
                    }
                    if (_ === 0) return _
                  }
                return _
              })(t, this.geometries)
            }
            return NaN
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        class Wo {
          constructor(t) {
            this.type = yr, this.key = t
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`Expected 1 argument, but found ${t.length-1} instead.`);
            const n = t[1];
            return n == null ? r.error("Global state property must be defined.") : typeof n != "string" ? r.error(`Global state property must be string, but found ${typeof t[1]} instead.`) : new Wo(n)
          }
          evaluate(t) {
            var r;
            const n = (r = t.globals) === null || r === void 0 ? void 0 : r.globalState;
            return n && Object.keys(n).length !== 0 ? ji(n, this.key) : null
          }
          eachChild() {}
          outputDefined() {
            return !1
          }
        }
        const yo = {
          "==": Bc,
          "!=": Fp,
          ">": wl,
          "<": Dh,
          ">=": Zn,
          "<=": Tl,
          array: Ti,
          at: Qn,
          boolean: Ti,
          case: qn,
          coalesce: qo,
          collator: Vo,
          format: Sl,
          image: Zo,
          in: jn,
          "index-of": wn,
          interpolate: Gi,
          "interpolate-hcl": Gi,
          "interpolate-lab": Gi,
          length: Oc,
          let: On,
          literal: Pa,
          match: ns,
          number: Ti,
          "number-format": vo,
          object: Ti,
          slice: es,
          step: Ma,
          string: Ti,
          "to-boolean": gi,
          "to-color": gi,
          "to-number": gi,
          "to-string": gi,
          var: qa,
          within: js,
          distance: Vs,
          "global-state": Wo
        };
        class Ln {
          constructor(t, r, n, l) {
            this.name = t, this.type = r, this._evaluate = n, this.args = l
          }
          evaluate(t) {
            return this._evaluate(t, this.args)
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return !1
          }
          static parse(t, r) {
            const n = t[0],
              l = Ln.definitions[n];
            if (!l) return r.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const p = Array.isArray(l) ? l[0] : l.type,
              f = Array.isArray(l) ? [
                [l[1], l[2]]
              ] : l.overloads,
              _ = f.filter((([M]) => !Array.isArray(M) || M.length === t.length - 1));
            let x = null;
            for (const [M, C] of _) {
              x = new Li(r.registry, El, r.path, null, r.scope);
              const L = [];
              let O = !1;
              for (let N = 1; N < t.length; N++) {
                const G = t[N],
                  K = Array.isArray(M) ? M[N - 1] : M.type,
                  ie = x.parse(G, 1 + L.length, K);
                if (!ie) {
                  O = !0;
                  break
                }
                L.push(ie)
              }
              if (!O)
                if (Array.isArray(M) && M.length !== L.length) x.error(`Expected ${M.length} arguments, but found ${L.length} instead.`);
                else {
                  for (let N = 0; N < L.length; N++) {
                    const G = Array.isArray(M) ? M[N] : M.type,
                      K = L[N];
                    x.concat(N + 1).checkSubtype(G, K.type)
                  }
                  if (x.errors.length === 0) return new Ln(n, p, C, L)
                }
            }
            if (_.length === 1) r.errors.push(...x.errors);
            else {
              const M = (_.length ? _ : f).map((([L]) => {
                  return O = L, Array.isArray(O) ? `(${O.map(Ar).join(", ")})` : `(${Ar(O.type)}...)`;
                  var O
                })).join(" | "),
                C = [];
              for (let L = 1; L < t.length; L++) {
                const O = r.parse(t[L], 1 + C.length);
                if (!O) return null;
                C.push(Ar(O.type))
              }
              r.error(`Expected arguments of type ${M}, but found (${C.join(", ")}) instead.`)
            }
            return null
          }
          static register(t, r) {
            Ln.definitions = r;
            for (const n in r) t[n] = Ln
          }
        }

        function Gh(i, [t, r, n, l]) {
          t = t.evaluate(i), r = r.evaluate(i), n = n.evaluate(i);
          const p = l ? l.evaluate(i) : 1,
            f = Da(t, r, n, p);
          if (f) throw new li(f);
          return new Ir(t / 255, r / 255, n / 255, p, !1)
        }

        function Wh(i, t) {
          return i in t
        }

        function Jc(i, t) {
          const r = t[i];
          return r === void 0 ? null : r
        }

        function Zs(i) {
          return {
            type: i
          }
        }

        function El(i) {
          if (i instanceof qa) return El(i.boundExpression);
          if (i instanceof Ln && i.name === "error" || i instanceof Vo || i instanceof js || i instanceof Vs || i instanceof Wo) return !1;
          const t = i instanceof gi || i instanceof Ti;
          let r = !0;
          return i.eachChild((n => {
            r = t ? r && El(n) : r && n instanceof Pa
          })), !!r && zl(i) && Ll(i, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"])
        }

        function zl(i) {
          if (i instanceof Ln && (i.name === "get" && i.args.length === 1 || i.name === "feature-state" || i.name === "has" && i.args.length === 1 || i.name === "properties" || i.name === "geometry-type" || i.name === "id" || /^filter-/.test(i.name)) || i instanceof js || i instanceof Vs) return !1;
          let t = !0;
          return i.eachChild((r => {
            t && !zl(r) && (t = !1)
          })), t
        }

        function Ho(i) {
          if (i instanceof Ln && i.name === "feature-state") return !1;
          let t = !0;
          return i.eachChild((r => {
            t && !Ho(r) && (t = !1)
          })), t
        }

        function Ll(i, t) {
          if (i instanceof Ln && t.indexOf(i.name) >= 0) return !1;
          let r = !0;
          return i.eachChild((n => {
            r && !Ll(n, t) && (r = !1)
          })), r
        }

        function Hh(i) {
          return {
            result: "success",
            value: i
          }
        }

        function xo(i) {
          return {
            result: "error",
            value: i
          }
        }

        function bo(i) {
          return i["property-type"] === "data-driven" || i["property-type"] === "cross-faded-data-driven"
        }

        function $h(i) {
          return !!i.expression && i.expression.parameters.indexOf("zoom") > -1
        }

        function Qc(i) {
          return !!i.expression && i.expression.interpolated
        }

        function Ri(i) {
          return i instanceof Number ? "number" : i instanceof String ? "string" : i instanceof Boolean ? "boolean" : Array.isArray(i) ? "array" : i === null ? "null" : typeof i
        }

        function Dl(i) {
          return typeof i == "object" && i !== null && !Array.isArray(i) && Ki(i) === Jr
        }

        function $p(i) {
          return i
        }

        function Xh(i, t) {
          const r = i.stops && typeof i.stops[0][0] == "object",
            n = r || !(r || i.property !== void 0),
            l = i.type || (Qc(t) ? "exponential" : "interval"),
            p = (function(C) {
              switch (C.type) {
                case "color":
                  return Ir.parse;
                case "padding":
                  return Si.parse;
                case "numberArray":
                  return Pi.parse;
                case "colorArray":
                  return di.parse;
                default:
                  return null
              }
            })(t);
          if (p && ((i = yt({}, i)).stops && (i.stops = i.stops.map((C => [C[0], p(C[1])]))), i.default = p(i.default ? i.default : t.default)), i.colorSpace && (f = i.colorSpace) !== "rgb" && f !== "hcl" && f !== "lab") throw new Error(`Unknown color space: "${i.colorSpace}"`);
          var f;
          const _ = (function(C) {
            switch (C) {
              case "exponential":
                return Yh;
              case "interval":
                return Yp;
              case "categorical":
                return Xp;
              case "identity":
                return Kh;
              default:
                throw new Error(`Unknown function type "${C}"`)
            }
          })(l);
          let x, M;
          if (l === "categorical") {
            x = Object.create(null);
            for (const C of i.stops) x[C[0]] = C[1];
            M = typeof i.stops[0][0]
          }
          if (r) {
            const C = {},
              L = [];
            for (let G = 0; G < i.stops.length; G++) {
              const K = i.stops[G],
                ie = K[0].zoom;
              C[ie] === void 0 && (C[ie] = {
                zoom: ie,
                type: i.type,
                property: i.property,
                default: i.default,
                stops: []
              }, L.push(ie)), C[ie].stops.push([K[0].value, K[1]])
            }
            const O = [];
            for (const G of L) O.push([C[G].zoom, Xh(C[G], t)]);
            const N = {
              name: "linear"
            };
            return {
              kind: "composite",
              interpolationType: N,
              interpolationFactor: Gi.interpolationFactor.bind(void 0, N),
              zoomStops: O.map((G => G[0])),
              evaluate: ({
                zoom: G
              }, K) => Yh({
                stops: O,
                base: i.base
              }, t, G).evaluate(G, K)
            }
          }
          if (n) {
            const C = l === "exponential" ? {
              name: "exponential",
              base: i.base !== void 0 ? i.base : 1
            } : null;
            return {
              kind: "camera",
              interpolationType: C,
              interpolationFactor: Gi.interpolationFactor.bind(void 0, C),
              zoomStops: i.stops.map((L => L[0])),
              evaluate: ({
                zoom: L
              }) => _(i, t, L, x, M)
            }
          }
          return {
            kind: "source",
            evaluate(C, L) {
              const O = L && L.properties ? L.properties[i.property] : void 0;
              return O === void 0 ? Ns(i.default, t.default) : _(i, t, O, x, M)
            }
          }
        }

        function Ns(i, t, r) {
          return i !== void 0 ? i : t !== void 0 ? t : r !== void 0 ? r : void 0
        }

        function Xp(i, t, r, n, l) {
          return Ns(typeof r === l ? n[r] : void 0, i.default, t.default)
        }

        function Yp(i, t, r) {
          if (Ri(r) !== "number") return Ns(i.default, t.default);
          const n = i.stops.length;
          if (n === 1 || r <= i.stops[0][0]) return i.stops[0][1];
          if (r >= i.stops[n - 1][0]) return i.stops[n - 1][1];
          const l = ua(i.stops.map((p => p[0])), r);
          return i.stops[l][1]
        }

        function Yh(i, t, r) {
          const n = i.base !== void 0 ? i.base : 1;
          if (Ri(r) !== "number") return Ns(i.default, t.default);
          const l = i.stops.length;
          if (l === 1 || r <= i.stops[0][0]) return i.stops[0][1];
          if (r >= i.stops[l - 1][0]) return i.stops[l - 1][1];
          const p = ua(i.stops.map((C => C[0])), r),
            f = (function(C, L, O, N) {
              const G = N - O,
                K = C - O;
              return G === 0 ? 0 : L === 1 ? K / G : (Math.pow(L, K) - 1) / (Math.pow(L, G) - 1)
            })(r, n, i.stops[p][0], i.stops[p + 1][0]),
            _ = i.stops[p][1],
            x = i.stops[p + 1][1],
            M = zn[t.type] || $p;
          return typeof _.evaluate == "function" ? {
            evaluate(...C) {
              const L = _.evaluate.apply(void 0, C),
                O = x.evaluate.apply(void 0, C);
              if (L !== void 0 && O !== void 0) return M(L, O, f, i.colorSpace)
            }
          } : M(_, x, f, i.colorSpace)
        }

        function Kh(i, t, r) {
          switch (t.type) {
            case "color":
              r = Ir.parse(r);
              break;
            case "formatted":
              r = Ei.fromString(r.toString());
              break;
            case "resolvedImage":
              r = ra.fromString(r.toString());
              break;
            case "padding":
              r = Si.parse(r);
              break;
            case "colorArray":
              r = di.parse(r);
              break;
            case "numberArray":
              r = Pi.parse(r);
              break;
            default:
              Ri(r) === t.type || t.type === "enum" && t.values[r] || (r = void 0)
          }
          return Ns(r, i.default, t.default)
        }
        Ln.register(yo, {
          error: [{
              kind: "error"
            },
            [tr], (i, [t]) => {
              throw new li(t.evaluate(i))
            }
          ],
          typeof: [tr, [yr], (i, [t]) => Ar(Ki(t.evaluate(i)))],
          "to-rgba": [ar(Je, 4), [Tr], (i, [t]) => {
            const [r, n, l, p] = t.evaluate(i).rgb;
            return [255 * r, 255 * n, 255 * l, p]
          }],
          rgb: [Tr, [Je, Je, Je], Gh],
          rgba: [Tr, [Je, Je, Je, Je], Gh],
          has: {
            type: Yt,
            overloads: [
              [
                [tr], (i, [t]) => Wh(t.evaluate(i), i.properties())
              ],
              [
                [tr, Jr], (i, [t, r]) => Wh(t.evaluate(i), r.evaluate(i))
              ]
            ]
          },
          get: {
            type: yr,
            overloads: [
              [
                [tr], (i, [t]) => Jc(t.evaluate(i), i.properties())
              ],
              [
                [tr, Jr], (i, [t, r]) => Jc(t.evaluate(i), r.evaluate(i))
              ]
            ]
          },
          "feature-state": [yr, [tr], (i, [t]) => Jc(t.evaluate(i), i.featureState || {})],
          properties: [Jr, [], i => i.properties()],
          "geometry-type": [tr, [], i => i.geometryType()],
          id: [yr, [], i => i.id()],
          zoom: [Je, [], i => i.globals.zoom],
          "heatmap-density": [Je, [], i => i.globals.heatmapDensity || 0],
          elevation: [Je, [], i => i.globals.elevation || 0],
          "line-progress": [Je, [], i => i.globals.lineProgress || 0],
          accumulated: [yr, [], i => i.globals.accumulated === void 0 ? null : i.globals.accumulated],
          "+": [Je, Zs(Je), (i, t) => {
            let r = 0;
            for (const n of t) r += n.evaluate(i);
            return r
          }],
          "*": [Je, Zs(Je), (i, t) => {
            let r = 1;
            for (const n of t) r *= n.evaluate(i);
            return r
          }],
          "-": {
            type: Je,
            overloads: [
              [
                [Je, Je], (i, [t, r]) => t.evaluate(i) - r.evaluate(i)
              ],
              [
                [Je], (i, [t]) => -t.evaluate(i)
              ]
            ]
          },
          "/": [Je, [Je, Je], (i, [t, r]) => t.evaluate(i) / r.evaluate(i)],
          "%": [Je, [Je, Je], (i, [t, r]) => t.evaluate(i) % r.evaluate(i)],
          ln2: [Je, [], () => Math.LN2],
          pi: [Je, [], () => Math.PI],
          e: [Je, [], () => Math.E],
          "^": [Je, [Je, Je], (i, [t, r]) => Math.pow(t.evaluate(i), r.evaluate(i))],
          sqrt: [Je, [Je], (i, [t]) => Math.sqrt(t.evaluate(i))],
          log10: [Je, [Je], (i, [t]) => Math.log(t.evaluate(i)) / Math.LN10],
          ln: [Je, [Je], (i, [t]) => Math.log(t.evaluate(i))],
          log2: [Je, [Je], (i, [t]) => Math.log(t.evaluate(i)) / Math.LN2],
          sin: [Je, [Je], (i, [t]) => Math.sin(t.evaluate(i))],
          cos: [Je, [Je], (i, [t]) => Math.cos(t.evaluate(i))],
          tan: [Je, [Je], (i, [t]) => Math.tan(t.evaluate(i))],
          asin: [Je, [Je], (i, [t]) => Math.asin(t.evaluate(i))],
          acos: [Je, [Je], (i, [t]) => Math.acos(t.evaluate(i))],
          atan: [Je, [Je], (i, [t]) => Math.atan(t.evaluate(i))],
          min: [Je, Zs(Je), (i, t) => Math.min(...t.map((r => r.evaluate(i))))],
          max: [Je, Zs(Je), (i, t) => Math.max(...t.map((r => r.evaluate(i))))],
          abs: [Je, [Je], (i, [t]) => Math.abs(t.evaluate(i))],
          round: [Je, [Je], (i, [t]) => {
            const r = t.evaluate(i);
            return r < 0 ? -Math.round(-r) : Math.round(r)
          }],
          floor: [Je, [Je], (i, [t]) => Math.floor(t.evaluate(i))],
          ceil: [Je, [Je], (i, [t]) => Math.ceil(t.evaluate(i))],
          "filter-==": [Yt, [tr, yr], (i, [t, r]) => i.properties()[t.value] === r.value],
          "filter-id-==": [Yt, [yr], (i, [t]) => i.id() === t.value],
          "filter-type-==": [Yt, [tr], (i, [t]) => i.geometryType() === t.value],
          "filter-<": [Yt, [tr, yr], (i, [t, r]) => {
            const n = i.properties()[t.value],
              l = r.value;
            return typeof n == typeof l && n < l
          }],
          "filter-id-<": [Yt, [yr], (i, [t]) => {
            const r = i.id(),
              n = t.value;
            return typeof r == typeof n && r < n
          }],
          "filter->": [Yt, [tr, yr], (i, [t, r]) => {
            const n = i.properties()[t.value],
              l = r.value;
            return typeof n == typeof l && n > l
          }],
          "filter-id->": [Yt, [yr], (i, [t]) => {
            const r = i.id(),
              n = t.value;
            return typeof r == typeof n && r > n
          }],
          "filter-<=": [Yt, [tr, yr], (i, [t, r]) => {
            const n = i.properties()[t.value],
              l = r.value;
            return typeof n == typeof l && n <= l
          }],
          "filter-id-<=": [Yt, [yr], (i, [t]) => {
            const r = i.id(),
              n = t.value;
            return typeof r == typeof n && r <= n
          }],
          "filter->=": [Yt, [tr, yr], (i, [t, r]) => {
            const n = i.properties()[t.value],
              l = r.value;
            return typeof n == typeof l && n >= l
          }],
          "filter-id->=": [Yt, [yr], (i, [t]) => {
            const r = i.id(),
              n = t.value;
            return typeof r == typeof n && r >= n
          }],
          "filter-has": [Yt, [yr], (i, [t]) => t.value in i.properties()],
          "filter-has-id": [Yt, [], i => i.id() !== null && i.id() !== void 0],
          "filter-type-in": [Yt, [ar(tr)], (i, [t]) => t.value.indexOf(i.geometryType()) >= 0],
          "filter-id-in": [Yt, [ar(yr)], (i, [t]) => t.value.indexOf(i.id()) >= 0],
          "filter-in-small": [Yt, [tr, ar(yr)], (i, [t, r]) => r.value.indexOf(i.properties()[t.value]) >= 0],
          "filter-in-large": [Yt, [tr, ar(yr)], (i, [t, r]) => (function(n, l, p, f) {
            for (; p <= f;) {
              const _ = p + f >> 1;
              if (l[_] === n) return !0;
              l[_] > n ? f = _ - 1 : p = _ + 1
            }
            return !1
          })(i.properties()[t.value], r.value, 0, r.value.length - 1)],
          all: {
            type: Yt,
            overloads: [
              [
                [Yt, Yt], (i, [t, r]) => t.evaluate(i) && r.evaluate(i)
              ],
              [Zs(Yt), (i, t) => {
                for (const r of t)
                  if (!r.evaluate(i)) return !1;
                return !0
              }]
            ]
          },
          any: {
            type: Yt,
            overloads: [
              [
                [Yt, Yt], (i, [t, r]) => t.evaluate(i) || r.evaluate(i)
              ],
              [Zs(Yt), (i, t) => {
                for (const r of t)
                  if (r.evaluate(i)) return !0;
                return !1
              }]
            ]
          },
          "!": [Yt, [Yt], (i, [t]) => !t.evaluate(i)],
          "is-supported-script": [Yt, [tr], (i, [t]) => {
            const r = i.globals && i.globals.isSupportedScript;
            return !r || r(t.evaluate(i))
          }],
          upcase: [tr, [tr], (i, [t]) => t.evaluate(i).toUpperCase()],
          downcase: [tr, [tr], (i, [t]) => t.evaluate(i).toLowerCase()],
          concat: [tr, Zs(yr), (i, t) => t.map((r => ca(r.evaluate(i)))).join("")],
          "resolved-locale": [tr, [qt], (i, [t]) => t.evaluate(i).resolvedLocale()]
        });
        class eu {
          constructor(t, r, n) {
            this.expression = t, this._warningHistory = {}, this._evaluator = new Bn, this._defaultValue = r ? (function(l) {
              if (l.type === "color" && Dl(l.default)) return new Ir(0, 0, 0, 0);
              switch (l.type) {
                case "color":
                  return Ir.parse(l.default) || null;
                case "padding":
                  return Si.parse(l.default) || null;
                case "numberArray":
                  return Pi.parse(l.default) || null;
                case "colorArray":
                  return di.parse(l.default) || null;
                case "variableAnchorOffsetCollection":
                  return Ui.parse(l.default) || null;
                case "projectionDefinition":
                  return sa.parse(l.default) || null;
                default:
                  return l.default === void 0 ? null : l.default
              }
            })(r) : null, this._enumValues = r && r.type === "enum" ? r.values : null, this._globalState = n
          }
          evaluateWithoutErrorHandling(t, r, n, l, p, f) {
            return this._globalState && (t = Gs(t, this._globalState)), this._evaluator.globals = t, this._evaluator.feature = r, this._evaluator.featureState = n, this._evaluator.canonical = l, this._evaluator.availableImages = p || null, this._evaluator.formattedSection = f, this.expression.evaluate(this._evaluator)
          }
          evaluate(t, r, n, l, p, f) {
            this._globalState && (t = Gs(t, this._globalState)), this._evaluator.globals = t, this._evaluator.feature = r || null, this._evaluator.featureState = n || null, this._evaluator.canonical = l, this._evaluator.availableImages = p || null, this._evaluator.formattedSection = f || null;
            try {
              const _ = this.expression.evaluate(this._evaluator);
              if (_ == null || typeof _ == "number" && _ != _) return this._defaultValue;
              if (this._enumValues && !(_ in this._enumValues)) throw new li(`Expected value to be one of ${Object.keys(this._enumValues).map((x=>JSON.stringify(x))).join(", ")}, but found ${JSON.stringify(_)} instead.`);
              return _
            } catch (_) {
              return this._warningHistory[_.message] || (this._warningHistory[_.message] = !0, typeof console < "u" && console.warn(_.message)), this._defaultValue
            }
          }
        }

        function Rl(i) {
          return Array.isArray(i) && i.length > 0 && typeof i[0] == "string" && i[0] in yo
        }

        function Us(i, t, r) {
          const n = new Li(yo, El, [], t ? (function(p) {
              const f = {
                color: Tr,
                string: tr,
                number: Je,
                enum: tr,
                boolean: Yt,
                formatted: bt,
                padding: Ue,
                numberArray: Gt,
                colorArray: xt,
                projectionDefinition: Dr,
                resolvedImage: kt,
                variableAnchorOffsetCollection: dr
              };
              return p.type === "array" ? ar(f[p.value] || yr, p.length) : f[p.type]
            })(t) : void 0),
            l = n.parse(i, void 0, void 0, void 0, t && t.type === "string" ? {
              typeAnnotation: "coerce"
            } : void 0);
          return l ? Hh(new eu(l, t, r)) : xo(n.errors)
        }
        class $o {
          constructor(t, r, n) {
            this.kind = t, this._styleExpression = r, this.isStateDependent = t !== "constant" && !Ho(r.expression), this.globalStateRefs = Ol(r.expression), this._globalState = n
          }
          evaluateWithoutErrorHandling(t, r, n, l, p, f) {
            return this._globalState && (t = Gs(t, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(t, r, n, l, p, f)
          }
          evaluate(t, r, n, l, p, f) {
            return this._globalState && (t = Gs(t, this._globalState)), this._styleExpression.evaluate(t, r, n, l, p, f)
          }
        }
        class tu {
          constructor(t, r, n, l, p) {
            this.kind = t, this.zoomStops = n, this._styleExpression = r, this.isStateDependent = t !== "camera" && !Ho(r.expression), this.globalStateRefs = Ol(r.expression), this.interpolationType = l, this._globalState = p
          }
          evaluateWithoutErrorHandling(t, r, n, l, p, f) {
            return this._globalState && (t = Gs(t, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(t, r, n, l, p, f)
          }
          evaluate(t, r, n, l, p, f) {
            return this._globalState && (t = Gs(t, this._globalState)), this._styleExpression.evaluate(t, r, n, l, p, f)
          }
          interpolationFactor(t, r, n) {
            return this.interpolationType ? Gi.interpolationFactor(this.interpolationType, t, r, n) : 0
          }
        }

        function Jh(i, t, r) {
          const n = Us(i, t, r);
          if (n.result === "error") return n;
          const l = n.value.expression,
            p = zl(l);
          if (!p && !bo(t)) return xo([new Kt("", "data expressions not supported")]);
          const f = Ll(l, ["zoom"]);
          if (!f && !$h(t)) return xo([new Kt("", "zoom expressions not supported")]);
          const _ = Bl(l);
          return _ || f ? _ instanceof Kt ? xo([_]) : _ instanceof Gi && !Qc(t) ? xo([new Kt("", '"interpolate" expressions cannot be used with this property')]) : Hh(_ ? new tu(p ? "camera" : "composite", n.value, _.labels, _ instanceof Gi ? _.interpolation : void 0, r) : new $o(p ? "constant" : "source", n.value, r)) : xo([new Kt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')])
        }
        class Fl {
          constructor(t, r) {
            this._parameters = t, this._specification = r, yt(this, Xh(this._parameters, this._specification))
          }
          static deserialize(t) {
            return new Fl(t._parameters, t._specification)
          }
          static serialize(t) {
            return {
              _parameters: t._parameters,
              _specification: t._specification
            }
          }
        }

        function Bl(i) {
          let t = null;
          if (i instanceof On) t = Bl(i.result);
          else if (i instanceof qo) {
            for (const r of i.args)
              if (t = Bl(r), t) break
          } else(i instanceof Ma || i instanceof Gi) && i.input instanceof Ln && i.input.name === "zoom" && (t = i);
          return t instanceof Kt || i.eachChild((r => {
            const n = Bl(r);
            n instanceof Kt ? t = n : !t && n ? t = new Kt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && n && t !== n && (t = new Kt("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'))
          })), t
        }

        function Ol(i, t = new Set) {
          return i instanceof Wo && t.add(i.key), i.eachChild((r => {
            Ol(r, t)
          })), t
        }

        function Gs(i, t) {
          const {
            zoom: r,
            heatmapDensity: n,
            elevation: l,
            lineProgress: p,
            isSupportedScript: f,
            accumulated: _
          } = i ?? {};
          return {
            zoom: r,
            heatmapDensity: n,
            elevation: l,
            lineProgress: p,
            isSupportedScript: f,
            accumulated: _,
            globalState: t
          }
        }

        function jl(i) {
          if (i === !0 || i === !1) return !0;
          if (!Array.isArray(i) || i.length === 0) return !1;
          switch (i[0]) {
            case "has":
              return i.length >= 2 && i[1] !== "$id" && i[1] !== "$type";
            case "in":
              return i.length >= 3 && (typeof i[1] != "string" || Array.isArray(i[2]));
            case "!in":
            case "!has":
            case "none":
              return !1;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return i.length !== 3 || Array.isArray(i[1]) || Array.isArray(i[2]);
            case "any":
            case "all":
              for (const t of i.slice(1))
                if (!jl(t) && typeof t != "boolean") return !1;
              return !0;
            default:
              return !0
          }
        }
        const Kp = {
          type: "boolean",
          default: !1,
          transition: !1,
          "property-type": "data-driven",
          expression: {
            interpolated: !1,
            parameters: ["zoom", "feature"]
          }
        };

        function Xo(i, t) {
          if (i == null) return {
            filter: () => !0,
            needGeometry: !1,
            getGlobalStateRefs: () => new Set
          };
          jl(i) || (i = Yo(i));
          const r = Us(i, Kp, t);
          if (r.result === "error") throw new Error(r.value.map((n => `${n.key}: ${n.message}`)).join(", "));
          return {
            filter: (n, l, p) => r.value.evaluate(n, l, {}, p),
            needGeometry: ru(i),
            getGlobalStateRefs: () => Ol(r.value.expression)
          }
        }

        function Qh(i, t) {
          return i < t ? -1 : i > t ? 1 : 0
        }

        function ru(i) {
          if (!Array.isArray(i)) return !1;
          if (i[0] === "within" || i[0] === "distance") return !0;
          for (let t = 1; t < i.length; t++)
            if (ru(i[t])) return !0;
          return !1
        }

        function Yo(i) {
          if (!i) return !0;
          const t = i[0];
          return i.length <= 1 ? t !== "any" : t === "==" ? iu(i[1], i[2], "==") : t === "!=" ? ql(iu(i[1], i[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? iu(i[1], i[2], t) : t === "any" ? (r = i.slice(1), ["any"].concat(r.map(Yo))) : t === "all" ? ["all"].concat(i.slice(1).map(Yo)) : t === "none" ? ["all"].concat(i.slice(1).map(Yo).map(ql)) : t === "in" ? ed(i[1], i.slice(2)) : t === "!in" ? ql(ed(i[1], i.slice(2))) : t === "has" ? td(i[1]) : t !== "!has" || ql(td(i[1]));
          var r
        }

        function iu(i, t, r) {
          switch (i) {
            case "$type":
              return [`filter-type-${r}`, t];
            case "$id":
              return [`filter-id-${r}`, t];
            default:
              return [`filter-${r}`, i, t]
          }
        }

        function ed(i, t) {
          if (t.length === 0) return !1;
          switch (i) {
            case "$type":
              return ["filter-type-in", ["literal", t]];
            case "$id":
              return ["filter-id-in", ["literal", t]];
            default:
              return t.length > 200 && !t.some((r => typeof r != typeof t[0])) ? ["filter-in-large", i, ["literal", t.sort(Qh)]] : ["filter-in-small", i, ["literal", t]]
          }
        }

        function td(i) {
          switch (i) {
            case "$type":
              return !0;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", i]
          }
        }

        function ql(i) {
          return ["!", i]
        }

        function Vl(i) {
          const t = typeof i;
          if (t === "number" || t === "boolean" || t === "string" || i == null) return JSON.stringify(i);
          if (Array.isArray(i)) {
            let l = "[";
            for (const p of i) l += `${Vl(p)},`;
            return `${l}]`
          }
          const r = Object.keys(i).sort();
          let n = "{";
          for (let l = 0; l < r.length; l++) n += `${JSON.stringify(r[l])}:${Vl(i[r[l]])},`;
          return `${n}}`
        }

        function rd(i) {
          let t = "";
          for (const r of Ve) t += `/${Vl(i[r])}`;
          return t
        }

        function Zl(i) {
          const t = i.value;
          return t ? [new je(i.key, t, "constants have been deprecated as of v8")] : []
        }

        function da(i) {
          return i instanceof Number || i instanceof String || i instanceof Boolean ? i.valueOf() : i
        }

        function ls(i) {
          if (Array.isArray(i)) return i.map(ls);
          if (i instanceof Object && !(i instanceof Number || i instanceof String || i instanceof Boolean)) {
            const t = {};
            for (const r in i) t[r] = ls(i[r]);
            return t
          }
          return da(i)
        }

        function mn(i) {
          const t = i.key,
            r = i.value,
            n = i.valueSpec || {},
            l = i.objectElementValidators || {},
            p = i.style,
            f = i.styleSpec,
            _ = i.validateSpec;
          let x = [];
          const M = Ri(r);
          if (M !== "object") return [new je(t, r, `object expected, ${M} found`)];
          for (const C in r) {
            const L = C.split(".")[0],
              O = ji(n, L) || n["*"];
            let N;
            if (ji(l, L)) N = l[L];
            else if (ji(n, L)) N = _;
            else if (l["*"]) N = l["*"];
            else {
              if (!n["*"]) {
                x.push(new je(t, r[C], `unknown property "${C}"`));
                continue
              }
              N = _
            }
            x = x.concat(N({
              key: (t && `${t}.`) + C,
              value: r[C],
              valueSpec: O,
              style: p,
              styleSpec: f,
              object: r,
              objectKey: C,
              validateSpec: _
            }, r))
          }
          for (const C in n) l[C] || n[C].required && n[C].default === void 0 && r[C] === void 0 && x.push(new je(t, r, `missing required property "${C}"`));
          return x
        }

        function wo(i) {
          const t = i.value,
            r = i.valueSpec,
            n = i.style,
            l = i.styleSpec,
            p = i.key,
            f = i.arrayElementValidator || i.validateSpec;
          if (Ri(t) !== "array") return [new je(p, t, `array expected, ${Ri(t)} found`)];
          if (r.length && t.length !== r.length) return [new je(p, t, `array length ${r.length} expected, length ${t.length} found`)];
          if (r["min-length"] && t.length < r["min-length"]) return [new je(p, t, `array length at least ${r["min-length"]} expected, length ${t.length} found`)];
          let _ = {
            type: r.value,
            values: r.values
          };
          l.$version < 7 && (_.function = r.function), Ri(r.value) === "object" && (_ = r.value);
          let x = [];
          for (let M = 0; M < t.length; M++) x = x.concat(f({
            array: t,
            arrayIndex: M,
            value: t[M],
            valueSpec: _,
            validateSpec: i.validateSpec,
            style: n,
            styleSpec: l,
            key: `${p}[${M}]`
          }));
          return x
        }

        function Nl(i) {
          const t = i.key,
            r = i.value,
            n = i.valueSpec;
          let l = Ri(r);
          return l === "number" && r != r && (l = "NaN"), l !== "number" ? [new je(t, r, `number expected, ${l} found`)] : "minimum" in n && r < n.minimum ? [new je(t, r, `${r} is less than the minimum value ${n.minimum}`)] : "maximum" in n && r > n.maximum ? [new je(t, r, `${r} is greater than the maximum value ${n.maximum}`)] : []
        }

        function id(i) {
          const t = i.valueSpec,
            r = da(i.value.type);
          let n, l, p, f = {};
          const _ = r !== "categorical" && i.value.property === void 0,
            x = !_,
            M = Ri(i.value.stops) === "array" && Ri(i.value.stops[0]) === "array" && Ri(i.value.stops[0][0]) === "object",
            C = mn({
              key: i.key,
              value: i.value,
              valueSpec: i.styleSpec.function,
              validateSpec: i.validateSpec,
              style: i.style,
              styleSpec: i.styleSpec,
              objectElementValidators: {
                stops: function(N) {
                  if (r === "identity") return [new je(N.key, N.value, 'identity function may not have a "stops" property')];
                  let G = [];
                  const K = N.value;
                  return G = G.concat(wo({
                    key: N.key,
                    value: K,
                    valueSpec: N.valueSpec,
                    validateSpec: N.validateSpec,
                    style: N.style,
                    styleSpec: N.styleSpec,
                    arrayElementValidator: L
                  })), Ri(K) === "array" && K.length === 0 && G.push(new je(N.key, K, "array must have at least one stop")), G
                },
                default: function(N) {
                  return N.validateSpec({
                    key: N.key,
                    value: N.value,
                    valueSpec: t,
                    validateSpec: N.validateSpec,
                    style: N.style,
                    styleSpec: N.styleSpec
                  })
                }
              }
            });
          return r === "identity" && _ && C.push(new je(i.key, i.value, 'missing required property "property"')), r === "identity" || i.value.stops || C.push(new je(i.key, i.value, 'missing required property "stops"')), r === "exponential" && i.valueSpec.expression && !Qc(i.valueSpec) && C.push(new je(i.key, i.value, "exponential functions not supported")), i.styleSpec.$version >= 8 && (x && !bo(i.valueSpec) ? C.push(new je(i.key, i.value, "property functions not supported")) : _ && !$h(i.valueSpec) && C.push(new je(i.key, i.value, "zoom functions not supported"))), r !== "categorical" && !M || i.value.property !== void 0 || C.push(new je(i.key, i.value, '"property" property is required')), C;

          function L(N) {
            let G = [];
            const K = N.value,
              ie = N.key;
            if (Ri(K) !== "array") return [new je(ie, K, `array expected, ${Ri(K)} found`)];
            if (K.length !== 2) return [new je(ie, K, `array length 2 expected, length ${K.length} found`)];
            if (M) {
              if (Ri(K[0]) !== "object") return [new je(ie, K, `object expected, ${Ri(K[0])} found`)];
              if (K[0].zoom === void 0) return [new je(ie, K, "object stop key must have zoom")];
              if (K[0].value === void 0) return [new je(ie, K, "object stop key must have value")];
              if (p && p > da(K[0].zoom)) return [new je(ie, K[0].zoom, "stop zoom values must appear in ascending order")];
              da(K[0].zoom) !== p && (p = da(K[0].zoom), l = void 0, f = {}), G = G.concat(mn({
                key: `${ie}[0]`,
                value: K[0],
                valueSpec: {
                  zoom: {}
                },
                validateSpec: N.validateSpec,
                style: N.style,
                styleSpec: N.styleSpec,
                objectElementValidators: {
                  zoom: Nl,
                  value: O
                }
              }))
            } else G = G.concat(O({
              key: `${ie}[0]`,
              value: K[0],
              validateSpec: N.validateSpec,
              style: N.style,
              styleSpec: N.styleSpec
            }, K));
            return Rl(ls(K[1])) ? G.concat([new je(`${ie}[1]`, K[1], "expressions are not allowed in function stops.")]) : G.concat(N.validateSpec({
              key: `${ie}[1]`,
              value: K[1],
              valueSpec: t,
              validateSpec: N.validateSpec,
              style: N.style,
              styleSpec: N.styleSpec
            }))
          }

          function O(N, G) {
            const K = Ri(N.value),
              ie = da(N.value),
              pe = N.value !== null ? N.value : G;
            if (n) {
              if (K !== n) return [new je(N.key, pe, `${K} stop domain type must match previous stop domain type ${n}`)]
            } else n = K;
            if (K !== "number" && K !== "string" && K !== "boolean") return [new je(N.key, pe, "stop domain value must be a number, string, or boolean")];
            if (K !== "number" && r !== "categorical") {
              let Ne = `number expected, ${K} found`;
              return bo(t) && r === void 0 && (Ne += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new je(N.key, pe, Ne)]
            }
            return r !== "categorical" || K !== "number" || isFinite(ie) && Math.floor(ie) === ie ? r !== "categorical" && K === "number" && l !== void 0 && ie < l ? [new je(N.key, pe, "stop domain values must appear in ascending order")] : (l = ie, r === "categorical" && ie in f ? [new je(N.key, pe, "stop domain values must be unique")] : (f[ie] = !0, [])) : [new je(N.key, pe, `integer expected, found ${ie}`)]
          }
        }

        function To(i) {
          const t = (i.expressionContext === "property" ? Jh : Us)(ls(i.value), i.valueSpec);
          if (t.result === "error") return t.value.map((n => new je(`${i.key}${n.key}`, i.value, n.message)));
          const r = t.value.expression || t.value._styleExpression.expression;
          if (i.expressionContext === "property" && i.propertyKey === "text-font" && !r.outputDefined()) return [new je(i.key, i.value, `Invalid data expression for "${i.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (i.expressionContext === "property" && i.propertyType === "layout" && !Ho(r)) return [new je(i.key, i.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (i.expressionContext === "filter" && !Ho(r)) return [new je(i.key, i.value, '"feature-state" data expressions are not supported with filters.')];
          if (i.expressionContext && i.expressionContext.indexOf("cluster") === 0) {
            if (!Ll(r, ["zoom", "feature-state"])) return [new je(i.key, i.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (i.expressionContext === "cluster-initial" && !zl(r)) return [new je(i.key, i.value, "Feature data expressions are not supported with initial expression part of cluster properties.")]
          }
          return []
        }

        function au(i) {
          const t = i.key,
            r = i.value,
            n = Ri(r);
          return n !== "string" ? [new je(t, r, `color expected, ${n} found`)] : Ir.parse(String(r)) ? [] : [new je(t, r, `color expected, "${r}" found`)]
        }

        function Ko(i) {
          const t = i.key,
            r = i.value,
            n = i.valueSpec,
            l = [];
          return Array.isArray(n.values) ? n.values.indexOf(da(r)) === -1 && l.push(new je(t, r, `expected one of [${n.values.join(", ")}], ${JSON.stringify(r)} found`)) : Object.keys(n.values).indexOf(da(r)) === -1 && l.push(new je(t, r, `expected one of [${Object.keys(n.values).join(", ")}], ${JSON.stringify(r)} found`)), l
        }

        function nu(i) {
          return jl(ls(i.value)) ? To(yt({}, i, {
            expressionContext: "filter",
            valueSpec: {
              value: "boolean"
            }
          })) : su(i)
        }

        function su(i) {
          const t = i.value,
            r = i.key;
          if (Ri(t) !== "array") return [new je(r, t, `array expected, ${Ri(t)} found`)];
          const n = i.styleSpec;
          let l, p = [];
          if (t.length < 1) return [new je(r, t, "filter array must have at least 1 element")];
          switch (p = p.concat(Ko({
              key: `${r}[0]`,
              value: t[0],
              valueSpec: n.filter_operator,
              style: i.style,
              styleSpec: i.styleSpec
            })), da(t[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              t.length >= 2 && da(t[1]) === "$type" && p.push(new je(r, t, `"$type" cannot be use with operator "${t[0]}"`));
            case "==":
            case "!=":
              t.length !== 3 && p.push(new je(r, t, `filter array for operator "${t[0]}" must have 3 elements`));
            case "in":
            case "!in":
              t.length >= 2 && (l = Ri(t[1]), l !== "string" && p.push(new je(`${r}[1]`, t[1], `string expected, ${l} found`)));
              for (let f = 2; f < t.length; f++) l = Ri(t[f]), da(t[1]) === "$type" ? p = p.concat(Ko({
                key: `${r}[${f}]`,
                value: t[f],
                valueSpec: n.geometry_type,
                style: i.style,
                styleSpec: i.styleSpec
              })) : l !== "string" && l !== "number" && l !== "boolean" && p.push(new je(`${r}[${f}]`, t[f], `string, number, or boolean expected, ${l} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let f = 1; f < t.length; f++) p = p.concat(su({
                key: `${r}[${f}]`,
                value: t[f],
                style: i.style,
                styleSpec: i.styleSpec
              }));
              break;
            case "has":
            case "!has":
              l = Ri(t[1]), t.length !== 2 ? p.push(new je(r, t, `filter array for "${t[0]}" operator must have 2 elements`)) : l !== "string" && p.push(new je(`${r}[1]`, t[1], `string expected, ${l} found`))
          }
          return p
        }

        function ou(i, t) {
          const r = i.key,
            n = i.validateSpec,
            l = i.style,
            p = i.styleSpec,
            f = i.value,
            _ = i.objectKey,
            x = p[`${t}_${i.layerType}`];
          if (!x) return [];
          const M = _.match(/^(.*)-transition$/);
          if (t === "paint" && M && x[M[1]] && x[M[1]].transition) return n({
            key: r,
            value: f,
            valueSpec: p.transition,
            style: l,
            styleSpec: p
          });
          const C = i.valueSpec || x[_];
          if (!C) return [new je(r, f, `unknown property "${_}"`)];
          let L;
          if (Ri(f) === "string" && bo(C) && !C.tokens && (L = /^{([^}]+)}$/.exec(f))) return [new je(r, f, `"${_}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(L[1])} }\`.`)];
          const O = [];
          return i.layerType === "symbol" && _ === "text-font" && Dl(ls(f)) && da(f.type) === "identity" && O.push(new je(r, f, '"text-font" does not support identity functions')), O.concat(n({
            key: i.key,
            value: f,
            valueSpec: C,
            style: l,
            styleSpec: p,
            expressionContext: "property",
            propertyType: t,
            propertyKey: _
          }))
        }

        function Jo(i) {
          return ou(i, "paint")
        }

        function ad(i) {
          return ou(i, "layout")
        }

        function lu(i) {
          let t = [];
          const r = i.value,
            n = i.key,
            l = i.style,
            p = i.styleSpec;
          if (Ri(r) !== "object") return [new je(n, r, `object expected, ${Ri(r)} found`)];
          r.type || r.ref || t.push(new je(n, r, 'either "type" or "ref" is required'));
          let f = da(r.type);
          const _ = da(r.ref);
          if (r.id) {
            const x = da(r.id);
            for (let M = 0; M < i.arrayIndex; M++) {
              const C = l.layers[M];
              da(C.id) === x && t.push(new je(n, r.id, `duplicate layer id "${r.id}", previously used at line ${C.id.__line__}`))
            }
          }
          if ("ref" in r) {
            let x;
            ["type", "source", "source-layer", "filter", "layout"].forEach((M => {
              M in r && t.push(new je(n, r[M], `"${M}" is prohibited for ref layers`))
            })), l.layers.forEach((M => {
              da(M.id) === _ && (x = M)
            })), x ? x.ref ? t.push(new je(n, r.ref, "ref cannot reference another ref layer")) : f = da(x.type) : t.push(new je(n, r.ref, `ref layer "${_}" not found`))
          } else if (f !== "background")
            if (r.source) {
              const x = l.sources && l.sources[r.source],
                M = x && da(x.type);
              x ? M === "vector" && f === "raster" ? t.push(new je(n, r.source, `layer "${r.id}" requires a raster source`)) : M !== "raster-dem" && f === "hillshade" || M !== "raster-dem" && f === "color-relief" ? t.push(new je(n, r.source, `layer "${r.id}" requires a raster-dem source`)) : M === "raster" && f !== "raster" ? t.push(new je(n, r.source, `layer "${r.id}" requires a vector source`)) : M !== "vector" || r["source-layer"] ? M === "raster-dem" && f !== "hillshade" && f !== "color-relief" ? t.push(new je(n, r.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : f !== "line" || !r.paint || !r.paint["line-gradient"] || M === "geojson" && x.lineMetrics || t.push(new je(n, r, `layer "${r.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new je(n, r, `layer "${r.id}" must specify a "source-layer"`)) : t.push(new je(n, r.source, `source "${r.source}" not found`))
            } else t.push(new je(n, r, 'missing required property "source"'));
          return t = t.concat(mn({
            key: n,
            value: r,
            valueSpec: p.layer,
            style: i.style,
            styleSpec: i.styleSpec,
            validateSpec: i.validateSpec,
            objectElementValidators: {
              "*": () => [],
              type: () => i.validateSpec({
                key: `${n}.type`,
                value: r.type,
                valueSpec: p.layer.type,
                style: i.style,
                styleSpec: i.styleSpec,
                validateSpec: i.validateSpec,
                object: r,
                objectKey: "type"
              }),
              filter: nu,
              layout: x => mn({
                layer: r,
                key: x.key,
                value: x.value,
                style: x.style,
                styleSpec: x.styleSpec,
                validateSpec: x.validateSpec,
                objectElementValidators: {
                  "*": M => ad(yt({
                    layerType: f
                  }, M))
                }
              }),
              paint: x => mn({
                layer: r,
                key: x.key,
                value: x.value,
                style: x.style,
                styleSpec: x.styleSpec,
                validateSpec: x.validateSpec,
                objectElementValidators: {
                  "*": M => Jo(yt({
                    layerType: f
                  }, M))
                }
              })
            }
          })), t
        }

        function Ps(i) {
          const t = i.value,
            r = i.key,
            n = Ri(t);
          return n !== "string" ? [new je(r, t, `string expected, ${n} found`)] : []
        }
        const nd = {
          promoteId: function({
            key: i,
            value: t
          }) {
            if (Ri(t) === "string") return Ps({
              key: i,
              value: t
            });
            {
              const r = [];
              for (const n in t) r.push(...Ps({
                key: `${i}.${n}`,
                value: t[n]
              }));
              return r
            }
          }
        };

        function cu(i) {
          const t = i.value,
            r = i.key,
            n = i.styleSpec,
            l = i.style,
            p = i.validateSpec;
          if (!t.type) return [new je(r, t, '"type" is required')];
          const f = da(t.type);
          let _;
          switch (f) {
            case "vector":
            case "raster":
              return _ = mn({
                key: r,
                value: t,
                valueSpec: n[`source_${f.replace("-","_")}`],
                style: i.style,
                styleSpec: n,
                objectElementValidators: nd,
                validateSpec: p
              }), _;
            case "raster-dem":
              return _ = (function(x) {
                var M;
                const C = (M = x.sourceName) !== null && M !== void 0 ? M : "",
                  L = x.value,
                  O = x.styleSpec,
                  N = O.source_raster_dem,
                  G = x.style;
                let K = [];
                const ie = Ri(L);
                if (L === void 0) return K;
                if (ie !== "object") return K.push(new je("source_raster_dem", L, `object expected, ${ie} found`)), K;
                const pe = da(L.encoding) === "custom",
                  Ne = ["redFactor", "greenFactor", "blueFactor", "baseShift"],
                  ye = x.value.encoding ? `"${x.value.encoding}"` : "Default";
                for (const ke in L) !pe && Ne.includes(ke) ? K.push(new je(ke, L[ke], `In "${C}": "${ke}" is only valid when "encoding" is set to "custom". ${ye} encoding found`)) : N[ke] ? K = K.concat(x.validateSpec({
                  key: ke,
                  value: L[ke],
                  valueSpec: N[ke],
                  validateSpec: x.validateSpec,
                  style: G,
                  styleSpec: O
                })) : K.push(new je(ke, L[ke], `unknown property "${ke}"`));
                return K
              })({
                sourceName: r,
                value: t,
                style: i.style,
                styleSpec: n,
                validateSpec: p
              }), _;
            case "geojson":
              if (_ = mn({
                  key: r,
                  value: t,
                  valueSpec: n.source_geojson,
                  style: l,
                  styleSpec: n,
                  validateSpec: p,
                  objectElementValidators: nd
                }), t.cluster)
                for (const x in t.clusterProperties) {
                  const [M, C] = t.clusterProperties[x], L = typeof M == "string" ? [M, ["accumulated"],
                    ["get", x]
                  ] : M;
                  _.push(...To({
                    key: `${r}.${x}.map`,
                    value: C,
                    expressionContext: "cluster-map"
                  })), _.push(...To({
                    key: `${r}.${x}.reduce`,
                    value: L,
                    expressionContext: "cluster-reduce"
                  }))
                }
              return _;
            case "video":
              return mn({
                key: r,
                value: t,
                valueSpec: n.source_video,
                style: l,
                validateSpec: p,
                styleSpec: n
              });
            case "image":
              return mn({
                key: r,
                value: t,
                valueSpec: n.source_image,
                style: l,
                validateSpec: p,
                styleSpec: n
              });
            case "canvas":
              return [new je(r, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return Ko({
                key: `${r}.type`,
                value: t.type,
                valueSpec: {
                  values: ["vector", "raster", "raster-dem", "geojson", "video", "image"]
                }
              })
          }
        }

        function uu(i) {
          const t = i.value,
            r = i.styleSpec,
            n = r.light,
            l = i.style;
          let p = [];
          const f = Ri(t);
          if (t === void 0) return p;
          if (f !== "object") return p = p.concat([new je("light", t, `object expected, ${f} found`)]), p;
          for (const _ in t) {
            const x = _.match(/^(.*)-transition$/);
            p = p.concat(x && n[x[1]] && n[x[1]].transition ? i.validateSpec({
              key: _,
              value: t[_],
              valueSpec: r.transition,
              validateSpec: i.validateSpec,
              style: l,
              styleSpec: r
            }) : n[_] ? i.validateSpec({
              key: _,
              value: t[_],
              valueSpec: n[_],
              validateSpec: i.validateSpec,
              style: l,
              styleSpec: r
            }) : [new je(_, t[_], `unknown property "${_}"`)])
          }
          return p
        }

        function So(i) {
          const t = i.value,
            r = i.styleSpec,
            n = r.sky,
            l = i.style,
            p = Ri(t);
          if (t === void 0) return [];
          if (p !== "object") return [new je("sky", t, `object expected, ${p} found`)];
          let f = [];
          for (const _ in t) f = f.concat(n[_] ? i.validateSpec({
            key: _,
            value: t[_],
            valueSpec: n[_],
            style: l,
            styleSpec: r
          }) : [new je(_, t[_], `unknown property "${_}"`)]);
          return f
        }

        function sd(i) {
          const t = i.value,
            r = i.styleSpec,
            n = r.terrain,
            l = i.style;
          let p = [];
          const f = Ri(t);
          if (t === void 0) return p;
          if (f !== "object") return p = p.concat([new je("terrain", t, `object expected, ${f} found`)]), p;
          for (const _ in t) p = p.concat(n[_] ? i.validateSpec({
            key: _,
            value: t[_],
            valueSpec: n[_],
            validateSpec: i.validateSpec,
            style: l,
            styleSpec: r
          }) : [new je(_, t[_], `unknown property "${_}"`)]);
          return p
        }

        function od(i) {
          let t = [];
          const r = i.value,
            n = i.key;
          if (Array.isArray(r)) {
            const l = [],
              p = [];
            for (const f in r) r[f].id && l.includes(r[f].id) && t.push(new je(n, r, `all the sprites' ids must be unique, but ${r[f].id} is duplicated`)), l.push(r[f].id), r[f].url && p.includes(r[f].url) && t.push(new je(n, r, `all the sprites' URLs must be unique, but ${r[f].url} is duplicated`)), p.push(r[f].url), t = t.concat(mn({
              key: `${n}[${f}]`,
              value: r[f],
              valueSpec: {
                id: {
                  type: "string",
                  required: !0
                },
                url: {
                  type: "string",
                  required: !0
                }
              },
              validateSpec: i.validateSpec
            }));
            return t
          }
          return Ps({
            key: n,
            value: r
          })
        }

        function ld(i) {
          return t = i.value, t && t.constructor === Object ? [] : [new je(i.key, i.value, `object expected, ${Ri(i.value)} found`)];
          var t
        }
        const cd = {
          "*": () => [],
          array: wo,
          boolean: function(i) {
            const t = i.value,
              r = i.key,
              n = Ri(t);
            return n !== "boolean" ? [new je(r, t, `boolean expected, ${n} found`)] : []
          },
          number: Nl,
          color: au,
          constants: Zl,
          enum: Ko,
          filter: nu,
          function: id,
          layer: lu,
          object: mn,
          source: cu,
          light: uu,
          sky: So,
          terrain: sd,
          projection: function(i) {
            const t = i.value,
              r = i.styleSpec,
              n = r.projection,
              l = i.style,
              p = Ri(t);
            if (t === void 0) return [];
            if (p !== "object") return [new je("projection", t, `object expected, ${p} found`)];
            let f = [];
            for (const _ in t) f = f.concat(n[_] ? i.validateSpec({
              key: _,
              value: t[_],
              valueSpec: n[_],
              style: l,
              styleSpec: r
            }) : [new je(_, t[_], `unknown property "${_}"`)]);
            return f
          },
          projectionDefinition: function(i) {
            const t = i.key;
            let r = i.value;
            r = r instanceof String ? r.valueOf() : r;
            const n = Ri(r);
            return n !== "array" || (function(l) {
              return Array.isArray(l) && l.length === 3 && typeof l[0] == "string" && typeof l[1] == "string" && typeof l[2] == "number"
            })(r) || (function(l) {
              return !!["interpolate", "step", "literal"].includes(l[0])
            })(r) ? ["array", "string"].includes(n) ? [] : [new je(t, r, `projection expected, invalid type "${n}" found`)] : [new je(t, r, `projection expected, invalid array ${JSON.stringify(r)} found`)]
          },
          string: Ps,
          formatted: function(i) {
            return Ps(i).length === 0 ? [] : To(i)
          },
          resolvedImage: function(i) {
            return Ps(i).length === 0 ? [] : To(i)
          },
          padding: function(i) {
            const t = i.key,
              r = i.value;
            if (Ri(r) === "array") {
              if (r.length < 1 || r.length > 4) return [new je(t, r, `padding requires 1 to 4 values; ${r.length} values found`)];
              const n = {
                type: "number"
              };
              let l = [];
              for (let p = 0; p < r.length; p++) l = l.concat(i.validateSpec({
                key: `${t}[${p}]`,
                value: r[p],
                validateSpec: i.validateSpec,
                valueSpec: n
              }));
              return l
            }
            return Nl({
              key: t,
              value: r,
              valueSpec: {}
            })
          },
          numberArray: function(i) {
            const t = i.key,
              r = i.value;
            if (Ri(r) === "array") {
              const n = {
                type: "number"
              };
              if (r.length < 1) return [new je(t, r, "array length at least 1 expected, length 0 found")];
              let l = [];
              for (let p = 0; p < r.length; p++) l = l.concat(i.validateSpec({
                key: `${t}[${p}]`,
                value: r[p],
                validateSpec: i.validateSpec,
                valueSpec: n
              }));
              return l
            }
            return Nl({
              key: t,
              value: r,
              valueSpec: {}
            })
          },
          colorArray: function(i) {
            const t = i.key,
              r = i.value;
            if (Ri(r) === "array") {
              if (r.length < 1) return [new je(t, r, "array length at least 1 expected, length 0 found")];
              let n = [];
              for (let l = 0; l < r.length; l++) n = n.concat(au({
                key: `${t}[${l}]`,
                value: r[l]
              }));
              return n
            }
            return au({
              key: t,
              value: r
            })
          },
          variableAnchorOffsetCollection: function(i) {
            const t = i.key,
              r = i.value,
              n = Ri(r),
              l = i.styleSpec;
            if (n !== "array" || r.length < 1 || r.length % 2 != 0) return [new je(t, r, "variableAnchorOffsetCollection requires a non-empty array of even length")];
            let p = [];
            for (let f = 0; f < r.length; f += 2) p = p.concat(Ko({
              key: `${t}[${f}]`,
              value: r[f],
              valueSpec: l.layout_symbol["text-anchor"]
            })), p = p.concat(wo({
              key: `${t}[${f+1}]`,
              value: r[f + 1],
              valueSpec: {
                length: 2,
                value: "number"
              },
              validateSpec: i.validateSpec,
              style: i.style,
              styleSpec: l
            }));
            return p
          },
          sprite: od,
          state: ld
        };

        function Ul(i) {
          const t = i.value,
            r = i.valueSpec,
            n = i.styleSpec;
          return i.validateSpec = Ul, r.expression && Dl(da(t)) ? id(i) : r.expression && Rl(ls(t)) ? To(i) : r.type && cd[r.type] ? cd[r.type](i) : mn(yt({}, i, {
            valueSpec: r.type ? n[r.type] : r
          }))
        }

        function ud(i) {
          const t = i.value,
            r = i.key,
            n = Ps(i);
          return n.length || (t.indexOf("{fontstack}") === -1 && n.push(new je(r, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf("{range}") === -1 && n.push(new je(r, t, '"glyphs" url must include a "{range}" token'))), n
        }

        function an(i, t = J) {
          let r = [];
          return r = r.concat(Ul({
            key: "",
            value: i,
            valueSpec: t.$root,
            styleSpec: t,
            style: i,
            validateSpec: Ul,
            objectElementValidators: {
              glyphs: ud,
              "*": () => []
            }
          })), i.constants && (r = r.concat(Zl({
            key: "constants",
            value: i.constants
          }))), gn(r)
        }

        function ln(i) {
          return function(t) {
            return i(Object.assign({}, t, {
              validateSpec: Ul
            }))
          }
        }

        function gn(i) {
          return [].concat(i).sort(((t, r) => t.line - r.line))
        }

        function cn(i) {
          return function(...t) {
            return gn(i.apply(this, t))
          }
        }
        an.source = cn(ln(cu)), an.sprite = cn(ln(od)), an.glyphs = cn(ln(ud)), an.light = cn(ln(uu)), an.sky = cn(ln(So)), an.terrain = cn(ln(sd)), an.state = cn(ln(ld)), an.layer = cn(ln(lu)), an.filter = cn(ln(nu)), an.paintProperty = cn(ln(Jo)), an.layoutProperty = cn(ln(ad));
        const hd = J,
          Po = an,
          Jp = Po.light,
          Qo = Po.sky,
          dd = Po.paintProperty,
          hu = Po.layoutProperty;

        function pd(i, t) {
          let r = !1;
          if (t && t.length)
            for (const n of t) i.fire(new Be(new Error(n.message))), r = !0;
          return r
        }
        class Ws {
          constructor(t, r, n) {
            const l = this.cells = [];
            if (t instanceof ArrayBuffer) {
              this.arrayBuffer = t;
              const f = new Int32Array(this.arrayBuffer);
              t = f[0], this.d = (r = f[1]) + 2 * (n = f[2]);
              for (let x = 0; x < this.d * this.d; x++) {
                const M = f[3 + x],
                  C = f[3 + x + 1];
                l.push(M === C ? null : f.subarray(M, C))
              }
              const _ = f[3 + l.length + 1];
              this.keys = f.subarray(f[3 + l.length], _), this.bboxes = f.subarray(_), this.insert = this._insertReadonly
            } else {
              this.d = r + 2 * n;
              for (let f = 0; f < this.d * this.d; f++) l.push([]);
              this.keys = [], this.bboxes = []
            }
            this.n = r, this.extent = t, this.padding = n, this.scale = r / t, this.uid = 0;
            const p = n / r * t;
            this.min = -p, this.max = t + p
          }
          insert(t, r, n, l, p) {
            this._forEachCell(r, n, l, p, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t), this.bboxes.push(r), this.bboxes.push(n), this.bboxes.push(l), this.bboxes.push(p)
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.")
          }
          _insertCell(t, r, n, l, p, f) {
            this.cells[p].push(f)
          }
          query(t, r, n, l, p) {
            const f = this.min,
              _ = this.max;
            if (t <= f && r <= f && _ <= n && _ <= l && !p) return Array.prototype.slice.call(this.keys);
            {
              const x = [];
              return this._forEachCell(t, r, n, l, this._queryCell, x, {}, p), x
            }
          }
          _queryCell(t, r, n, l, p, f, _, x) {
            const M = this.cells[p];
            if (M !== null) {
              const C = this.keys,
                L = this.bboxes;
              for (let O = 0; O < M.length; O++) {
                const N = M[O];
                if (_[N] === void 0) {
                  const G = 4 * N;
                  (x ? x(L[G + 0], L[G + 1], L[G + 2], L[G + 3]) : t <= L[G + 2] && r <= L[G + 3] && n >= L[G + 0] && l >= L[G + 1]) ? (_[N] = !0, f.push(C[N])) : _[N] = !1
                }
              }
            }
          }
          _forEachCell(t, r, n, l, p, f, _, x) {
            const M = this._convertToCellCoord(t),
              C = this._convertToCellCoord(r),
              L = this._convertToCellCoord(n),
              O = this._convertToCellCoord(l);
            for (let N = M; N <= L; N++)
              for (let G = C; G <= O; G++) {
                const K = this.d * G + N;
                if ((!x || x(this._convertFromCellCoord(N), this._convertFromCellCoord(G), this._convertFromCellCoord(N + 1), this._convertFromCellCoord(G + 1))) && p.call(this, t, r, n, l, K, f, _, x)) return
              }
          }
          _convertFromCellCoord(t) {
            return (t - this.padding) / this.scale
          }
          _convertToCellCoord(t) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding))
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const t = this.cells,
              r = 3 + this.cells.length + 1 + 1;
            let n = 0;
            for (let f = 0; f < this.cells.length; f++) n += this.cells[f].length;
            const l = new Int32Array(r + n + this.keys.length + this.bboxes.length);
            l[0] = this.extent, l[1] = this.n, l[2] = this.padding;
            let p = r;
            for (let f = 0; f < t.length; f++) {
              const _ = t[f];
              l[3 + f] = p, l.set(_, p), p += _.length
            }
            return l[3 + t.length] = p, l.set(this.keys, p), p += this.keys.length, l[3 + t.length + 1] = p, l.set(this.bboxes, p), p += this.bboxes.length, l.buffer
          }
          static serialize(t, r) {
            const n = t.toArrayBuffer();
            return r && r.push(n), {
              buffer: n
            }
          }
          static deserialize(t) {
            return new Ws(t.buffer)
          }
        }
        const cs = {};

        function Mr(i, t, r = {}) {
          if (cs[i]) throw new Error(`${i} is already registered.`);
          Object.defineProperty(t, "_classRegistryKey", {
            value: i,
            writeable: !1
          }), cs[i] = {
            klass: t,
            omit: r.omit || [],
            shallow: r.shallow || []
          }
        }
        Mr("Object", Object), Mr("Set", Set), Mr("TransferableGridIndex", Ws), Mr("Color", Ir), Mr("Error", Error), Mr("AJAXError", re), Mr("ResolvedImage", ra), Mr("StylePropertyFunction", Fl), Mr("StyleExpression", eu, {
          omit: ["_evaluator"]
        }), Mr("ZoomDependentExpression", tu), Mr("ZoomConstantExpression", $o), Mr("CompoundExpression", Ln, {
          omit: ["_evaluate"]
        });
        for (const i in yo) yo[i]._classRegistryKey || Mr(`Expression_${i}`, yo[i]);

        function fd(i) {
          return i && typeof ArrayBuffer < "u" && (i instanceof ArrayBuffer || i.constructor && i.constructor.name === "ArrayBuffer")
        }

        function du(i) {
          return i.$name || i.constructor._classRegistryKey
        }

        function md(i) {
          return !(function(t) {
            if (t === null || typeof t != "object") return !1;
            const r = du(t);
            return !(!r || r === "Object")
          })(i) && (i == null || typeof i == "boolean" || typeof i == "number" || typeof i == "string" || i instanceof Boolean || i instanceof Number || i instanceof String || i instanceof Date || i instanceof RegExp || i instanceof Blob || i instanceof Error || fd(i) || ut(i) || ArrayBuffer.isView(i) || i instanceof ImageData)
        }

        function us(i, t) {
          if (md(i)) return (fd(i) || ut(i)) && t && t.push(i), ArrayBuffer.isView(i) && t && t.push(i.buffer), i instanceof ImageData && t && t.push(i.data.buffer), i;
          if (Array.isArray(i)) {
            const p = [];
            for (const f of i) p.push(us(f, t));
            return p
          }
          if (typeof i != "object") throw new Error("can't serialize object of type " + typeof i);
          const r = du(i);
          if (!r) throw new Error(`can't serialize object of unregistered class ${i.constructor.name}`);
          if (!cs[r]) throw new Error(`${r} is not registered.`);
          const {
            klass: n
          } = cs[r], l = n.serialize ? n.serialize(i, t) : {};
          if (n.serialize) {
            if (t && l === t[t.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property")
          } else {
            for (const p in i) {
              if (!i.hasOwnProperty(p) || cs[r].omit.indexOf(p) >= 0) continue;
              const f = i[p];
              l[p] = cs[r].shallow.indexOf(p) >= 0 ? f : us(f, t)
            }
            i instanceof Error && (l.message = i.message)
          }
          if (l.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return r !== "Object" && (l.$name = r), l
        }

        function el(i) {
          if (md(i)) return i;
          if (Array.isArray(i)) return i.map(el);
          if (typeof i != "object") throw new Error("can't deserialize object of type " + typeof i);
          const t = du(i) || "Object";
          if (!cs[t]) throw new Error(`can't deserialize unregistered class ${t}`);
          const {
            klass: r
          } = cs[t];
          if (!r) throw new Error(`can't deserialize unregistered class ${t}`);
          if (r.deserialize) return r.deserialize(i);
          const n = Object.create(r.prototype);
          for (const l of Object.keys(i)) {
            if (l === "$name") continue;
            const p = i[l];
            n[l] = cs[t].shallow.indexOf(l) >= 0 ? p : el(p)
          }
          return n
        }
        class pu {
          constructor() {
            this.first = !0
          }
          update(t, r) {
            const n = Math.floor(t);
            return this.first ? (this.first = !1, this.lastIntegerZoom = n, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = n, !0) : (this.lastFloorZoom > n ? (this.lastIntegerZoom = n + 1, this.lastIntegerZoomTime = r) : this.lastFloorZoom < n && (this.lastIntegerZoom = n, this.lastIntegerZoomTime = r), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = n, !0))
          }
        }
        const Di = {
          "Latin-1 Supplement": i => i >= 128 && i <= 255,
          "Hangul Jamo": i => i >= 4352 && i <= 4607,
          Khmer: i => i >= 6016 && i <= 6143,
          "General Punctuation": i => i >= 8192 && i <= 8303,
          "Letterlike Symbols": i => i >= 8448 && i <= 8527,
          "Number Forms": i => i >= 8528 && i <= 8591,
          "Miscellaneous Technical": i => i >= 8960 && i <= 9215,
          "Control Pictures": i => i >= 9216 && i <= 9279,
          "Optical Character Recognition": i => i >= 9280 && i <= 9311,
          "Enclosed Alphanumerics": i => i >= 9312 && i <= 9471,
          "Geometric Shapes": i => i >= 9632 && i <= 9727,
          "Miscellaneous Symbols": i => i >= 9728 && i <= 9983,
          "Miscellaneous Symbols and Arrows": i => i >= 11008 && i <= 11263,
          "Ideographic Description Characters": i => i >= 12272 && i <= 12287,
          "CJK Symbols and Punctuation": i => i >= 12288 && i <= 12351,
          Hiragana: i => i >= 12352 && i <= 12447,
          Katakana: i => i >= 12448 && i <= 12543,
          Kanbun: i => i >= 12688 && i <= 12703,
          "CJK Strokes": i => i >= 12736 && i <= 12783,
          "Enclosed CJK Letters and Months": i => i >= 12800 && i <= 13055,
          "CJK Compatibility": i => i >= 13056 && i <= 13311,
          "Yijing Hexagram Symbols": i => i >= 19904 && i <= 19967,
          "CJK Unified Ideographs": i => i >= 19968 && i <= 40959,
          "Hangul Syllables": i => i >= 44032 && i <= 55215,
          "Private Use Area": i => i >= 57344 && i <= 63743,
          "Vertical Forms": i => i >= 65040 && i <= 65055,
          "CJK Compatibility Forms": i => i >= 65072 && i <= 65103,
          "Small Form Variants": i => i >= 65104 && i <= 65135,
          "Halfwidth and Fullwidth Forms": i => i >= 65280 && i <= 65519
        };

        function fu(i) {
          for (const t of i)
            if (Gl(t.charCodeAt(0))) return !0;
          return !1
        }

        function mu(i) {
          for (const t of i)
            if (!_d(t.charCodeAt(0))) return !1;
          return !0
        }

        function Mo(i) {
          const t = i.map((r => {
            try {
              return new RegExp(`\\p{sc=${r}}`, "u").source
            } catch {
              return null
            }
          })).filter((r => r));
          return new RegExp(t.join("|"), "u")
        }
        const gd = Mo(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);

        function _d(i) {
          return !gd.test(String.fromCodePoint(i))
        }
        const gu = Mo(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);

        function Gl(i) {
          return !(i !== 746 && i !== 747 && (i < 4352 || !(Di["CJK Compatibility Forms"](i) && !(i >= 65097 && i <= 65103) || Di["CJK Compatibility"](i) || Di["CJK Strokes"](i) || !(!Di["CJK Symbols and Punctuation"](i) || i >= 12296 && i <= 12305 || i >= 12308 && i <= 12319 || i === 12336) || Di["Enclosed CJK Letters and Months"](i) || Di["Ideographic Description Characters"](i) || Di.Kanbun(i) || Di.Katakana(i) && i !== 12540 || !(!Di["Halfwidth and Fullwidth Forms"](i) || i === 65288 || i === 65289 || i === 65293 || i >= 65306 && i <= 65310 || i === 65339 || i === 65341 || i === 65343 || i >= 65371 && i <= 65503 || i === 65507 || i >= 65512 && i <= 65519) || !(!Di["Small Form Variants"](i) || i >= 65112 && i <= 65118 || i >= 65123 && i <= 65126) || Di["Vertical Forms"](i) || Di["Yijing Hexagram Symbols"](i) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(i)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(i)) || gu.test(String.fromCodePoint(i)))))
        }

        function Wl(i) {
          return !(Gl(i) || (function(t) {
            return !!(Di["Latin-1 Supplement"](t) && (t === 167 || t === 169 || t === 174 || t === 177 || t === 188 || t === 189 || t === 190 || t === 215 || t === 247) || Di["General Punctuation"](t) && (t === 8214 || t === 8224 || t === 8225 || t === 8240 || t === 8241 || t === 8251 || t === 8252 || t === 8258 || t === 8263 || t === 8264 || t === 8265 || t === 8273) || Di["Letterlike Symbols"](t) || Di["Number Forms"](t) || Di["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || t === 9003 || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || t === 9167 || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || Di["Control Pictures"](t) && t !== 9251 || Di["Optical Character Recognition"](t) || Di["Enclosed Alphanumerics"](t) || Di["Geometric Shapes"](t) || Di["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || Di["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || Di["CJK Symbols and Punctuation"](t) || Di.Katakana(t) || Di["Private Use Area"](t) || Di["CJK Compatibility Forms"](t) || Di["Small Form Variants"](t) || Di["Halfwidth and Fullwidth Forms"](t) || t === 8734 || t === 8756 || t === 8757 || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || t === 65532 || t === 65533)
          })(i))
        }
        const vd = Mo(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);

        function yd(i) {
          return vd.test(String.fromCodePoint(i))
        }

        function xd(i, t) {
          return !(!t && yd(i) || i >= 2304 && i <= 3583 || i >= 3840 && i <= 4255 || Di.Khmer(i))
        }

        function Qp(i) {
          for (const t of i)
            if (yd(t.charCodeAt(0))) return !0;
          return !1
        }
        const hs = new class {
          constructor() {
            this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {}
          }
          setState(i) {
            this.pluginStatus = i.pluginStatus, this.pluginURL = i.pluginURL
          }
          getState() {
            return {
              pluginStatus: this.pluginStatus,
              pluginURL: this.pluginURL
            }
          }
          setMethods(i) {
            if (hs.isParsed()) throw new Error("RTL text plugin already registered.");
            this.applyArabicShaping = i.applyArabicShaping, this.processBidirectionalText = i.processBidirectionalText, this.processStyledBidirectionalText = i.processStyledBidirectionalText, this.loadScriptResolve()
          }
          isParsed() {
            return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus
          }
          syncState(i, t) {
            return s(this, void 0, void 0, (function*() {
              if (this.isParsed()) return this.getState();
              if (i.pluginStatus !== "loading") return this.setState(i), i;
              const r = i.pluginURL,
                n = new Promise((p => {
                  this.loadScriptResolve = p
                }));
              t(r);
              const l = new Promise((p => setTimeout((() => p()), this.TIMEOUT)));
              if (yield Promise.race([n, l]), this.isParsed()) {
                const p = {
                  pluginStatus: "loaded",
                  pluginURL: r
                };
                return this.setState(p), p
              }
              throw this.setState({
                pluginStatus: "error",
                pluginURL: ""
              }), new Error(`RTL Text Plugin failed to import scripts from ${r}`)
            }))
          }
        };
        class Ji {
          constructor(t, r) {
            this.isSupportedScript = bd, this.zoom = t, r ? (this.now = r.now || 0, this.fadeDuration = r.fadeDuration || 0, this.zoomHistory = r.zoomHistory || new pu, this.transition = r.transition || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new pu, this.transition = {})
          }
          crossFadingFactor() {
            return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1)
          }
          getCrossfadeParameters() {
            const t = this.zoom,
              r = t - Math.floor(t),
              n = this.crossFadingFactor();
            return t > this.zoomHistory.lastIntegerZoom ? {
              fromScale: 2,
              toScale: 1,
              t: r + (1 - r) * n
            } : {
              fromScale: .5,
              toScale: 1,
              t: 1 - (1 - n) * r
            }
          }
        }

        function bd(i) {
          return (function(t, r) {
            for (const n of t)
              if (!xd(n.charCodeAt(0), r)) return !1;
            return !0
          })(i, hs.getRTLTextPluginStatus() === "loaded")
        }
        class tl {
          constructor(t, r, n) {
            this.property = t, this.value = r, this.expression = (function(l, p, f) {
              if (Dl(l)) return new Fl(l, p);
              if (Rl(l)) {
                const _ = Jh(l, p, f);
                if (_.result === "error") throw new Error(_.value.map((x => `${x.key}: ${x.message}`)).join(", "));
                return _.value
              } {
                let _ = l;
                return p.type === "color" && typeof l == "string" ? _ = Ir.parse(l) : p.type !== "padding" || typeof l != "number" && !Array.isArray(l) ? p.type !== "numberArray" || typeof l != "number" && !Array.isArray(l) ? p.type !== "colorArray" || typeof l != "string" && !Array.isArray(l) ? p.type === "variableAnchorOffsetCollection" && Array.isArray(l) ? _ = Ui.parse(l) : p.type === "projectionDefinition" && typeof l == "string" && (_ = sa.parse(l)) : _ = di.parse(l) : _ = Pi.parse(l) : _ = Si.parse(l), {
                  globalStateRefs: new Set,
                  _globalState: null,
                  kind: "constant",
                  evaluate: () => _
                }
              }
            })(r === void 0 ? t.specification.default : r, t.specification, n)
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite"
          }
          getGlobalStateRefs() {
            return this.expression.globalStateRefs || new Set
          }
          possiblyEvaluate(t, r, n) {
            return this.property.possiblyEvaluate(this, t, r, n)
          }
        }
        class _u {
          constructor(t, r) {
            this.property = t, this.value = new tl(t, void 0, r)
          }
          transitioned(t, r) {
            return new vu(this.property, this.value, r, nt({}, t.transition, this.transition), t.now)
          }
          untransitioned() {
            return new vu(this.property, this.value, null, {}, 0)
          }
        }
        class wd {
          constructor(t, r) {
            this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues), this._globalState = r
          }
          getValue(t) {
            return Ot(this._values[t].value.value)
          }
          setValue(t, r) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new _u(this._values[t].property, this._globalState)), this._values[t].value = new tl(this._values[t].property, r === null ? void 0 : Ot(r), this._globalState)
          }
          getTransition(t) {
            return Ot(this._values[t].transition)
          }
          setTransition(t, r) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new _u(this._values[t].property, this._globalState)), this._values[t].transition = Ot(r) || void 0
          }
          serialize() {
            const t = {};
            for (const r of Object.keys(this._values)) {
              const n = this.getValue(r);
              n !== void 0 && (t[r] = n);
              const l = this.getTransition(r);
              l !== void 0 && (t[`${r}-transition`] = l)
            }
            return t
          }
          transitioned(t, r) {
            const n = new yu(this._properties);
            for (const l of Object.keys(this._values)) n._values[l] = this._values[l].transitioned(t, r._values[l]);
            return n
          }
          untransitioned() {
            const t = new yu(this._properties);
            for (const r of Object.keys(this._values)) t._values[r] = this._values[r].untransitioned();
            return t
          }
        }
        class vu {
          constructor(t, r, n, l, p) {
            this.property = t, this.value = r, this.begin = p + l.delay || 0, this.end = this.begin + l.duration || 0, t.specification.transition && (l.delay || l.duration) && (this.prior = n)
          }
          possiblyEvaluate(t, r, n) {
            const l = t.now || 0,
              p = this.value.possiblyEvaluate(t, r, n),
              f = this.prior;
            if (f) {
              if (l > this.end) return this.prior = null, p;
              if (this.value.isDataDriven()) return this.prior = null, p;
              if (l < this.begin) return f.possiblyEvaluate(t, r, n);
              {
                const _ = (l - this.begin) / (this.end - this.begin);
                return this.property.interpolate(f.possiblyEvaluate(t, r, n), p, Rt(_))
              }
            }
            return p
          }
        }
        class yu {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues)
          }
          possiblyEvaluate(t, r, n) {
            const l = new Hs(this._properties);
            for (const p of Object.keys(this._values)) l._values[p] = this._values[p].possiblyEvaluate(t, r, n);
            return l
          }
          hasTransition() {
            for (const t of Object.keys(this._values))
              if (this._values[t].prior) return !0;
            return !1
          }
        }
        class Td {
          constructor(t, r) {
            this._properties = t, this._values = Object.create(t.defaultPropertyValues), this._globalState = r
          }
          hasValue(t) {
            return this._values[t].value !== void 0
          }
          getValue(t) {
            return Ot(this._values[t].value)
          }
          setValue(t, r) {
            this._values[t] = new tl(this._values[t].property, r === null ? void 0 : Ot(r), this._globalState)
          }
          serialize() {
            const t = {};
            for (const r of Object.keys(this._values)) {
              const n = this.getValue(r);
              n !== void 0 && (t[r] = n)
            }
            return t
          }
          possiblyEvaluate(t, r, n) {
            const l = new Hs(this._properties);
            for (const p of Object.keys(this._values)) l._values[p] = this._values[p].possiblyEvaluate(t, r, n);
            return l
          }
        }
        class Nn {
          constructor(t, r, n) {
            this.property = t, this.value = r, this.parameters = n
          }
          isConstant() {
            return this.value.kind === "constant"
          }
          constantOr(t) {
            return this.value.kind === "constant" ? this.value.value : t
          }
          evaluate(t, r, n, l) {
            return this.property.evaluate(this.value, this.parameters, t, r, n, l)
          }
        }
        class Hs {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues)
          }
          get(t) {
            return this._values[t]
          }
        }
        class $r {
          constructor(t) {
            this.specification = t
          }
          possiblyEvaluate(t, r) {
            if (t.isDataDriven()) throw new Error("Value should not be data driven");
            return t.expression.evaluate(r)
          }
          interpolate(t, r, n) {
            const l = zn[this.specification.type];
            return l ? l(t, r, n) : t
          }
        }
        class si {
          constructor(t, r) {
            this.specification = t, this.overrides = r
          }
          possiblyEvaluate(t, r, n, l) {
            return new Nn(this, t.expression.kind === "constant" || t.expression.kind === "camera" ? {
              kind: "constant",
              value: t.expression.evaluate(r, null, {}, n, l)
            } : t.expression, r)
          }
          interpolate(t, r, n) {
            if (t.value.kind !== "constant" || r.value.kind !== "constant") return t;
            if (t.value.value === void 0 || r.value.value === void 0) return new Nn(this, {
              kind: "constant",
              value: void 0
            }, t.parameters);
            const l = zn[this.specification.type];
            if (l) {
              const p = l(t.value.value, r.value.value, n);
              return new Nn(this, {
                kind: "constant",
                value: p
              }, t.parameters)
            }
            return t
          }
          evaluate(t, r, n, l, p, f) {
            return t.kind === "constant" ? t.value : t.evaluate(r, n, l, p, f)
          }
        }
        class rl extends si {
          possiblyEvaluate(t, r, n, l) {
            if (t.value === void 0) return new Nn(this, {
              kind: "constant",
              value: void 0
            }, r);
            if (t.expression.kind === "constant") {
              const p = t.expression.evaluate(r, null, {}, n, l),
                f = t.property.specification.type === "resolvedImage" && typeof p != "string" ? p.name : p,
                _ = this._calculate(f, f, f, r);
              return new Nn(this, {
                kind: "constant",
                value: _
              }, r)
            }
            if (t.expression.kind === "camera") {
              const p = this._calculate(t.expression.evaluate({
                zoom: r.zoom - 1
              }), t.expression.evaluate({
                zoom: r.zoom
              }), t.expression.evaluate({
                zoom: r.zoom + 1
              }), r);
              return new Nn(this, {
                kind: "constant",
                value: p
              }, r)
            }
            return new Nn(this, t.expression, r)
          }
          evaluate(t, r, n, l, p, f) {
            if (t.kind === "source") {
              const _ = t.evaluate(r, n, l, p, f);
              return this._calculate(_, _, _, r)
            }
            return t.kind === "composite" ? this._calculate(t.evaluate({
              zoom: Math.floor(r.zoom) - 1
            }, n, l), t.evaluate({
              zoom: Math.floor(r.zoom)
            }, n, l), t.evaluate({
              zoom: Math.floor(r.zoom) + 1
            }, n, l), r) : t.value
          }
          _calculate(t, r, n, l) {
            return l.zoom > l.zoomHistory.lastIntegerZoom ? {
              from: t,
              to: r
            } : {
              from: n,
              to: r
            }
          }
          interpolate(t) {
            return t
          }
        }
        class Sd {
          constructor(t) {
            this.specification = t
          }
          possiblyEvaluate(t, r, n, l) {
            if (t.value !== void 0) {
              if (t.expression.kind === "constant") {
                const p = t.expression.evaluate(r, null, {}, n, l);
                return this._calculate(p, p, p, r)
              }
              return this._calculate(t.expression.evaluate(new Ji(Math.floor(r.zoom - 1), r)), t.expression.evaluate(new Ji(Math.floor(r.zoom), r)), t.expression.evaluate(new Ji(Math.floor(r.zoom + 1), r)), r)
            }
          }
          _calculate(t, r, n, l) {
            return l.zoom > l.zoomHistory.lastIntegerZoom ? {
              from: t,
              to: r
            } : {
              from: n,
              to: r
            }
          }
          interpolate(t) {
            return t
          }
        }
        class il {
          constructor(t) {
            this.specification = t
          }
          possiblyEvaluate(t, r, n, l) {
            return !!t.expression.evaluate(r, null, {}, n, l)
          }
          interpolate() {
            return !1
          }
        }
        class nn {
          constructor(t) {
            this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const r in t) {
              const n = t[r];
              n.specification.overridable && this.overridableProperties.push(r);
              const l = this.defaultPropertyValues[r] = new tl(n, void 0, void 0),
                p = this.defaultTransitionablePropertyValues[r] = new _u(n, void 0);
              this.defaultTransitioningPropertyValues[r] = p.untransitioned(), this.defaultPossiblyEvaluatedValues[r] = l.possiblyEvaluate({})
            }
          }
        }
        Mr("DataDrivenProperty", si), Mr("DataConstantProperty", $r), Mr("CrossFadedDataDrivenProperty", rl), Mr("CrossFadedProperty", Sd), Mr("ColorRampProperty", il);
        const xu = "-transition";
        class Un extends ae {
          constructor(t, r, n) {
            if (super(), this.id = t.id, this.type = t.type, this._globalState = n, this._featureFilter = {
                filter: () => !0,
                needGeometry: !1,
                getGlobalStateRefs: () => new Set
              }, t.type !== "custom" && (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, t.type !== "background" && (this.source = t.source, this.sourceLayer = t["source-layer"], this.filter = t.filter, this._featureFilter = Xo(t.filter, n)), r.layout && (this._unevaluatedLayout = new Td(r.layout, n)), r.paint)) {
              this._transitionablePaint = new wd(r.paint, n);
              for (const l in t.paint) this.setPaintProperty(l, t.paint[l], {
                validate: !1
              });
              for (const l in t.layout) this.setLayoutProperty(l, t.layout[l], {
                validate: !1
              });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Hs(r.paint)
            }
          }
          setFilter(t) {
            this.filter = t, this._featureFilter = Xo(t, this._globalState)
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters
          }
          getLayoutProperty(t) {
            return t === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t)
          }
          getLayoutAffectingGlobalStateRefs() {
            const t = new Set;
            if (this._unevaluatedLayout)
              for (const r in this._unevaluatedLayout._values) {
                const n = this._unevaluatedLayout._values[r];
                for (const l of n.getGlobalStateRefs()) t.add(l)
              }
            for (const r of this._featureFilter.getGlobalStateRefs()) t.add(r);
            return t
          }
          getPaintAffectingGlobalStateRefs() {
            var t;
            const r = new globalThis.Map;
            if (this._transitionablePaint)
              for (const n in this._transitionablePaint._values) {
                const l = this._transitionablePaint._values[n].value;
                for (const p of l.getGlobalStateRefs()) {
                  const f = (t = r.get(p)) !== null && t !== void 0 ? t : [];
                  f.push({
                    name: n,
                    value: l.value
                  }), r.set(p, f)
                }
              }
            return r
          }
          setLayoutProperty(t, r, n = {}) {
            r != null && this._validate(hu, `layers.${this.id}.layout.${t}`, t, r, n) || (t !== "visibility" ? this._unevaluatedLayout.setValue(t, r) : this.visibility = r)
          }
          getPaintProperty(t) {
            return t.endsWith(xu) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t)
          }
          setPaintProperty(t, r, n = {}) {
            if (r != null && this._validate(dd, `layers.${this.id}.paint.${t}`, t, r, n)) return !1;
            if (t.endsWith(xu)) return this._transitionablePaint.setTransition(t.slice(0, -11), r || void 0), !1;
            {
              const l = this._transitionablePaint._values[t],
                p = l.property.specification["property-type"] === "cross-faded-data-driven",
                f = l.value.isDataDriven(),
                _ = l.value;
              this._transitionablePaint.setValue(t, r), this._handleSpecialPaintPropertyUpdate(t);
              const x = this._transitionablePaint._values[t].value;
              return x.isDataDriven() || f || p || this._handleOverridablePaintPropertyUpdate(t, _, x)
            }
          }
          _handleSpecialPaintPropertyUpdate(t) {}
          _handleOverridablePaintPropertyUpdate(t, r, n) {
            return !1
          }
          isHidden(t, r = !1) {
            return !!(this.minzoom && t < (r ? Math.floor(this.minzoom) : this.minzoom)) || !!(this.maxzoom && t >= this.maxzoom) || this.visibility === "none"
          }
          updateTransitions(t) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint)
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition()
          }
          recalculate(t, r) {
            t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, r)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, r)
          }
          serialize() {
            const t = {
              id: this.id,
              type: this.type,
              source: this.source,
              "source-layer": this.sourceLayer,
              metadata: this.metadata,
              minzoom: this.minzoom,
              maxzoom: this.maxzoom,
              filter: this.filter,
              layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
              paint: this._transitionablePaint && this._transitionablePaint.serialize()
            };
            return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), Jt(t, ((r, n) => !(r === void 0 || n === "layout" && !Object.keys(r).length || n === "paint" && !Object.keys(r).length)))
          }
          _validate(t, r, n, l, p = {}) {
            return (!p || p.validate !== !1) && pd(this, t.call(Po, {
              key: r,
              layerType: this.type,
              objectKey: n,
              value: l,
              styleSpec: J,
              style: {
                glyphs: !0,
                sprite: !0
              }
            }))
          }
          is3D() {
            return !1
          }
          isTileClipped() {
            return !1
          }
          hasOffscreenPass() {
            return !1
          }
          resize() {}
          isStateDependent() {
            for (const t in this.paint._values) {
              const r = this.paint.get(t);
              if (r instanceof Nn && bo(r.property.specification) && (r.value.kind === "source" || r.value.kind === "composite") && r.value.isStateDependent) return !0
            }
            return !1
          }
        }
        let Pd;
        var ef = {
          get paint() {
            return Pd = Pd || new nn({
              "raster-opacity": new $r(J.paint_raster["raster-opacity"]),
              "raster-hue-rotate": new $r(J.paint_raster["raster-hue-rotate"]),
              "raster-brightness-min": new $r(J.paint_raster["raster-brightness-min"]),
              "raster-brightness-max": new $r(J.paint_raster["raster-brightness-max"]),
              "raster-saturation": new $r(J.paint_raster["raster-saturation"]),
              "raster-contrast": new $r(J.paint_raster["raster-contrast"]),
              "raster-resampling": new $r(J.paint_raster["raster-resampling"]),
              "raster-fade-duration": new $r(J.paint_raster["raster-fade-duration"])
            })
          }
        };
        class tf extends Un {
          constructor(t, r) {
            super(t, ef, r)
          }
        }
        const rf = {
          Int8: Int8Array,
          Uint8: Uint8Array,
          Int16: Int16Array,
          Uint16: Uint16Array,
          Int32: Int32Array,
          Uint32: Uint32Array,
          Float32: Float32Array
        };
        class rs {
          constructor(t, r) {
            this._structArray = t, this._pos1 = r * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8
          }
        }
        class pa {
          constructor() {
            this.isTransferred = !1, this.capacity = -1, this.resize(0)
          }
          static serialize(t, r) {
            return t._trim(), r && (t.isTransferred = !0, r.push(t.arrayBuffer)), {
              length: t.length,
              arrayBuffer: t.arrayBuffer
            }
          }
          static deserialize(t) {
            const r = Object.create(this.prototype);
            return r.arrayBuffer = t.arrayBuffer, r.length = t.length, r.capacity = t.arrayBuffer.byteLength / r.bytesPerElement, r._refreshViews(), r
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews())
          }
          clear() {
            this.length = 0
          }
          resize(t) {
            this.reserve(t), this.length = t
          }
          reserve(t) {
            if (t > this.capacity) {
              this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const r = this.uint8;
              this._refreshViews(), r && this.uint8.set(r)
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout")
          }
        }

        function xa(i, t = 1) {
          let r = 0,
            n = 0;
          return {
            members: i.map((l => {
              const p = rf[l.type].BYTES_PER_ELEMENT,
                f = r = Md(r, Math.max(t, p)),
                _ = l.components || 1;
              return n = Math.max(n, p), r += p * _, {
                name: l.name,
                type: l.type,
                components: _,
                offset: f
              }
            })),
            size: Md(r, Math.max(n, t)),
            alignment: t
          }
        }

        function Md(i, t) {
          return Math.ceil(i / t) * t
        }
        class Io extends pa {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t, r)
          }
          emplace(t, r, n) {
            const l = 2 * t;
            return this.int16[l + 0] = r, this.int16[l + 1] = n, t
          }
        }
        Io.prototype.bytesPerElement = 4, Mr("StructArrayLayout2i4", Io);
        class Hl extends pa {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n) {
            const l = this.length;
            return this.resize(l + 1), this.emplace(l, t, r, n)
          }
          emplace(t, r, n, l) {
            const p = 3 * t;
            return this.int16[p + 0] = r, this.int16[p + 1] = n, this.int16[p + 2] = l, t
          }
        }
        Hl.prototype.bytesPerElement = 6, Mr("StructArrayLayout3i6", Hl);
        class bu extends pa {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n, l) {
            const p = this.length;
            return this.resize(p + 1), this.emplace(p, t, r, n, l)
          }
          emplace(t, r, n, l, p) {
            const f = 4 * t;
            return this.int16[f + 0] = r, this.int16[f + 1] = n, this.int16[f + 2] = l, this.int16[f + 3] = p, t
          }
        }
        bu.prototype.bytesPerElement = 8, Mr("StructArrayLayout4i8", bu);
        class ds extends pa {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n, l, p, f) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, t, r, n, l, p, f)
          }
          emplace(t, r, n, l, p, f, _) {
            const x = 6 * t;
            return this.int16[x + 0] = r, this.int16[x + 1] = n, this.int16[x + 2] = l, this.int16[x + 3] = p, this.int16[x + 4] = f, this.int16[x + 5] = _, t
          }
        }
        ds.prototype.bytesPerElement = 12, Mr("StructArrayLayout2i4i12", ds);
        class $l extends pa {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n, l, p, f) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, t, r, n, l, p, f)
          }
          emplace(t, r, n, l, p, f, _) {
            const x = 4 * t,
              M = 8 * t;
            return this.int16[x + 0] = r, this.int16[x + 1] = n, this.uint8[M + 4] = l, this.uint8[M + 5] = p, this.uint8[M + 6] = f, this.uint8[M + 7] = _, t
          }
        }
        $l.prototype.bytesPerElement = 8, Mr("StructArrayLayout2i4ub8", $l);
        class $s extends pa {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t, r)
          }
          emplace(t, r, n) {
            const l = 2 * t;
            return this.float32[l + 0] = r, this.float32[l + 1] = n, t
          }
        }
        $s.prototype.bytesPerElement = 8, Mr("StructArrayLayout2f8", $s);
        class Xl extends pa {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n, l, p, f, _, x, M, C) {
            const L = this.length;
            return this.resize(L + 1), this.emplace(L, t, r, n, l, p, f, _, x, M, C)
          }
          emplace(t, r, n, l, p, f, _, x, M, C, L) {
            const O = 10 * t;
            return this.uint16[O + 0] = r, this.uint16[O + 1] = n, this.uint16[O + 2] = l, this.uint16[O + 3] = p, this.uint16[O + 4] = f, this.uint16[O + 5] = _, this.uint16[O + 6] = x, this.uint16[O + 7] = M, this.uint16[O + 8] = C, this.uint16[O + 9] = L, t
          }
        }
        Xl.prototype.bytesPerElement = 20, Mr("StructArrayLayout10ui20", Xl);
        class al extends pa {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n, l, p, f, _, x) {
            const M = this.length;
            return this.resize(M + 1), this.emplace(M, t, r, n, l, p, f, _, x)
          }
          emplace(t, r, n, l, p, f, _, x, M) {
            const C = 8 * t;
            return this.uint16[C + 0] = r, this.uint16[C + 1] = n, this.uint16[C + 2] = l, this.uint16[C + 3] = p, this.uint16[C + 4] = f, this.uint16[C + 5] = _, this.uint16[C + 6] = x, this.uint16[C + 7] = M, t
          }
        }
        al.prototype.bytesPerElement = 16, Mr("StructArrayLayout8ui16", al);
        class wu extends pa {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n, l, p, f, _, x, M, C, L, O) {
            const N = this.length;
            return this.resize(N + 1), this.emplace(N, t, r, n, l, p, f, _, x, M, C, L, O)
          }
          emplace(t, r, n, l, p, f, _, x, M, C, L, O, N) {
            const G = 12 * t;
            return this.int16[G + 0] = r, this.int16[G + 1] = n, this.int16[G + 2] = l, this.int16[G + 3] = p, this.uint16[G + 4] = f, this.uint16[G + 5] = _, this.uint16[G + 6] = x, this.uint16[G + 7] = M, this.int16[G + 8] = C, this.int16[G + 9] = L, this.int16[G + 10] = O, this.int16[G + 11] = N, t
          }
        }
        wu.prototype.bytesPerElement = 24, Mr("StructArrayLayout4i4ui4i24", wu);
        class Co extends pa {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n) {
            const l = this.length;
            return this.resize(l + 1), this.emplace(l, t, r, n)
          }
          emplace(t, r, n, l) {
            const p = 3 * t;
            return this.float32[p + 0] = r, this.float32[p + 1] = n, this.float32[p + 2] = l, t
          }
        }
        Co.prototype.bytesPerElement = 12, Mr("StructArrayLayout3f12", Co);
        class Xs extends pa {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer)
          }
          emplaceBack(t) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, t)
          }
          emplace(t, r) {
            return this.uint32[1 * t + 0] = r, t
          }
        }
        Xs.prototype.bytesPerElement = 4, Mr("StructArrayLayout1ul4", Xs);
        class Tu extends pa {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n, l, p, f, _, x, M) {
            const C = this.length;
            return this.resize(C + 1), this.emplace(C, t, r, n, l, p, f, _, x, M)
          }
          emplace(t, r, n, l, p, f, _, x, M, C) {
            const L = 10 * t,
              O = 5 * t;
            return this.int16[L + 0] = r, this.int16[L + 1] = n, this.int16[L + 2] = l, this.int16[L + 3] = p, this.int16[L + 4] = f, this.int16[L + 5] = _, this.uint32[O + 3] = x, this.uint16[L + 8] = M, this.uint16[L + 9] = C, t
          }
        }
        Tu.prototype.bytesPerElement = 20, Mr("StructArrayLayout6i1ul2ui20", Tu);
        class Yl extends pa {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n, l, p, f) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, t, r, n, l, p, f)
          }
          emplace(t, r, n, l, p, f, _) {
            const x = 6 * t;
            return this.int16[x + 0] = r, this.int16[x + 1] = n, this.int16[x + 2] = l, this.int16[x + 3] = p, this.int16[x + 4] = f, this.int16[x + 5] = _, t
          }
        }
        Yl.prototype.bytesPerElement = 12, Mr("StructArrayLayout2i2i2i12", Yl);
        class Ys extends pa {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n, l, p) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, t, r, n, l, p)
          }
          emplace(t, r, n, l, p, f) {
            const _ = 4 * t,
              x = 8 * t;
            return this.float32[_ + 0] = r, this.float32[_ + 1] = n, this.float32[_ + 2] = l, this.int16[x + 6] = p, this.int16[x + 7] = f, t
          }
        }
        Ys.prototype.bytesPerElement = 16, Mr("StructArrayLayout2f1f2i16", Ys);
        class Su extends pa {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n, l, p, f) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, t, r, n, l, p, f)
          }
          emplace(t, r, n, l, p, f, _) {
            const x = 16 * t,
              M = 4 * t,
              C = 8 * t;
            return this.uint8[x + 0] = r, this.uint8[x + 1] = n, this.float32[M + 1] = l, this.float32[M + 2] = p, this.int16[C + 6] = f, this.int16[C + 7] = _, t
          }
        }
        Su.prototype.bytesPerElement = 16, Mr("StructArrayLayout2ub2f2i16", Su);
        class Kl extends pa {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n) {
            const l = this.length;
            return this.resize(l + 1), this.emplace(l, t, r, n)
          }
          emplace(t, r, n, l) {
            const p = 3 * t;
            return this.uint16[p + 0] = r, this.uint16[p + 1] = n, this.uint16[p + 2] = l, t
          }
        }
        Kl.prototype.bytesPerElement = 6, Mr("StructArrayLayout3ui6", Kl);
        class Jl extends pa {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n, l, p, f, _, x, M, C, L, O, N, G, K, ie, pe) {
            const Ne = this.length;
            return this.resize(Ne + 1), this.emplace(Ne, t, r, n, l, p, f, _, x, M, C, L, O, N, G, K, ie, pe)
          }
          emplace(t, r, n, l, p, f, _, x, M, C, L, O, N, G, K, ie, pe, Ne) {
            const ye = 24 * t,
              ke = 12 * t,
              at = 48 * t;
            return this.int16[ye + 0] = r, this.int16[ye + 1] = n, this.uint16[ye + 2] = l, this.uint16[ye + 3] = p, this.uint32[ke + 2] = f, this.uint32[ke + 3] = _, this.uint32[ke + 4] = x, this.uint16[ye + 10] = M, this.uint16[ye + 11] = C, this.uint16[ye + 12] = L, this.float32[ke + 7] = O, this.float32[ke + 8] = N, this.uint8[at + 36] = G, this.uint8[at + 37] = K, this.uint8[at + 38] = ie, this.uint32[ke + 10] = pe, this.int16[ye + 22] = Ne, t
          }
        }
        Jl.prototype.bytesPerElement = 48, Mr("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Jl);
        class Pu extends pa {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n, l, p, f, _, x, M, C, L, O, N, G, K, ie, pe, Ne, ye, ke, at, gt, Wt, xr, hr, _r, Qr, gr) {
            const vr = this.length;
            return this.resize(vr + 1), this.emplace(vr, t, r, n, l, p, f, _, x, M, C, L, O, N, G, K, ie, pe, Ne, ye, ke, at, gt, Wt, xr, hr, _r, Qr, gr)
          }
          emplace(t, r, n, l, p, f, _, x, M, C, L, O, N, G, K, ie, pe, Ne, ye, ke, at, gt, Wt, xr, hr, _r, Qr, gr, vr) {
            const zt = 32 * t,
              ci = 16 * t;
            return this.int16[zt + 0] = r, this.int16[zt + 1] = n, this.int16[zt + 2] = l, this.int16[zt + 3] = p, this.int16[zt + 4] = f, this.int16[zt + 5] = _, this.int16[zt + 6] = x, this.int16[zt + 7] = M, this.uint16[zt + 8] = C, this.uint16[zt + 9] = L, this.uint16[zt + 10] = O, this.uint16[zt + 11] = N, this.uint16[zt + 12] = G, this.uint16[zt + 13] = K, this.uint16[zt + 14] = ie, this.uint16[zt + 15] = pe, this.uint16[zt + 16] = Ne, this.uint16[zt + 17] = ye, this.uint16[zt + 18] = ke, this.uint16[zt + 19] = at, this.uint16[zt + 20] = gt, this.uint16[zt + 21] = Wt, this.uint16[zt + 22] = xr, this.uint32[ci + 12] = hr, this.float32[ci + 13] = _r, this.float32[ci + 14] = Qr, this.uint16[zt + 30] = gr, this.uint16[zt + 31] = vr, t
          }
        }
        Pu.prototype.bytesPerElement = 64, Mr("StructArrayLayout8i15ui1ul2f2ui64", Pu);
        class h extends pa {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, t)
          }
          emplace(t, r) {
            return this.float32[1 * t + 0] = r, t
          }
        }
        h.prototype.bytesPerElement = 4, Mr("StructArrayLayout1f4", h);
        class e extends pa {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n) {
            const l = this.length;
            return this.resize(l + 1), this.emplace(l, t, r, n)
          }
          emplace(t, r, n, l) {
            const p = 3 * t;
            return this.uint16[6 * t + 0] = r, this.float32[p + 1] = n, this.float32[p + 2] = l, t
          }
        }
        e.prototype.bytesPerElement = 12, Mr("StructArrayLayout1ui2f12", e);
        class a extends pa {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n) {
            const l = this.length;
            return this.resize(l + 1), this.emplace(l, t, r, n)
          }
          emplace(t, r, n, l) {
            const p = 4 * t;
            return this.uint32[2 * t + 0] = r, this.uint16[p + 2] = n, this.uint16[p + 3] = l, t
          }
        }
        a.prototype.bytesPerElement = 8, Mr("StructArrayLayout1ul2ui8", a);
        class o extends pa {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t, r)
          }
          emplace(t, r, n) {
            const l = 2 * t;
            return this.uint16[l + 0] = r, this.uint16[l + 1] = n, t
          }
        }
        o.prototype.bytesPerElement = 4, Mr("StructArrayLayout2ui4", o);
        class c extends pa {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, t)
          }
          emplace(t, r) {
            return this.uint16[1 * t + 0] = r, t
          }
        }
        c.prototype.bytesPerElement = 2, Mr("StructArrayLayout1ui2", c);
        class d extends pa {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n, l) {
            const p = this.length;
            return this.resize(p + 1), this.emplace(p, t, r, n, l)
          }
          emplace(t, r, n, l, p) {
            const f = 4 * t;
            return this.float32[f + 0] = r, this.float32[f + 1] = n, this.float32[f + 2] = l, this.float32[f + 3] = p, t
          }
        }
        d.prototype.bytesPerElement = 16, Mr("StructArrayLayout4f16", d);
        class g extends rs {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2]
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3]
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4]
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5]
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3]
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8]
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9]
          }
          get anchorPoint() {
            return new B(this.anchorPointX, this.anchorPointY)
          }
        }
        g.prototype.size = 20;
        class w extends Tu {
          get(t) {
            return new g(this, t)
          }
        }
        Mr("CollisionBoxArray", w);
        class S extends rs {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2]
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3]
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2]
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3]
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4]
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10]
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11]
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12]
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7]
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8]
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36]
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37]
          }
          set placedOrientation(t) {
            this._structArray.uint8[this._pos1 + 37] = t
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38]
          }
          set hidden(t) {
            this._structArray.uint8[this._pos1 + 38] = t
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10]
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 10] = t
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22]
          }
        }
        S.prototype.size = 48;
        class A extends Jl {
          get(t) {
            return new S(this, t)
          }
        }
        Mr("PlacedSymbolArray", A);
        class E extends rs {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2]
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3]
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4]
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5]
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6]
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7]
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8]
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9]
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10]
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11]
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12]
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13]
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14]
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15]
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16]
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17]
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18]
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19]
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20]
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21]
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22]
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12]
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 12] = t
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13]
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14]
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30]
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31]
          }
        }
        E.prototype.size = 64;
        class F extends Pu {
          get(t) {
            return new E(this, t)
          }
        }
        Mr("SymbolInstanceArray", F);
        class R extends h {
          getoffsetX(t) {
            return this.float32[1 * t + 0]
          }
        }
        Mr("GlyphOffsetArray", R);
        class U extends Hl {
          getx(t) {
            return this.int16[3 * t + 0]
          }
          gety(t) {
            return this.int16[3 * t + 1]
          }
          gettileUnitDistanceFromAnchor(t) {
            return this.int16[3 * t + 2]
          }
        }
        Mr("SymbolLineVertexArray", U);
        class Y extends rs {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0]
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1]
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2]
          }
        }
        Y.prototype.size = 12;
        class se extends e {
          get(t) {
            return new Y(this, t)
          }
        }
        Mr("TextAnchorOffsetArray", se);
        class le extends rs {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0]
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2]
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3]
          }
        }
        le.prototype.size = 8;
        class ce extends a {
          get(t) {
            return new le(this, t)
          }
        }
        Mr("FeatureIndexArray", ce);
        class ge extends Io {}
        class Pe extends Io {}
        class fe extends Io {}
        class Me extends ds {}
        class Ee extends $l {}
        class ve extends $s {}
        class Oe extends Xl {}
        class lt extends al {}
        class it extends wu {}
        class st extends Co {}
        class ct extends Xs {}
        class nr extends Yl {}
        class lr extends Su {}
        class Bt extends Kl {}
        class qr extends o {}
        const yi = xa([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: Hi
          } = yi;
        class Ci {
          constructor(t = []) {
            this._forceNewSegmentOnNextPrepare = !1, this.segments = t
          }
          prepareSegment(t, r, n, l) {
            const p = this.segments[this.segments.length - 1];
            return t > Ci.MAX_VERTEX_ARRAY_LENGTH && At(`Max vertices per segment is ${Ci.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${Ci.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !p || p.vertexLength + t > Ci.MAX_VERTEX_ARRAY_LENGTH || p.sortKey !== l ? this.createNewSegment(r, n, l) : p
          }
          createNewSegment(t, r, n) {
            const l = {
              vertexOffset: t.length,
              primitiveOffset: r.length,
              vertexLength: 0,
              primitiveLength: 0,
              vaos: {}
            };
            return n !== void 0 && (l.sortKey = n), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(l), l
          }
          getOrCreateLatestSegment(t, r, n) {
            return this.prepareSegment(0, t, r, n)
          }
          forceNewSegmentOnNextPrepare() {
            this._forceNewSegmentOnNextPrepare = !0
          }
          get() {
            return this.segments
          }
          destroy() {
            for (const t of this.segments)
              for (const r in t.vaos) t.vaos[r].destroy()
          }
          static simpleSegment(t, r, n, l) {
            return new Ci([{
              vertexOffset: t,
              primitiveOffset: r,
              vertexLength: n,
              primitiveLength: l,
              vaos: {},
              sortKey: 0
            }])
          }
        }

        function Qi(i, t) {
          return 256 * (i = Xt(Math.floor(i), 0, 255)) + Xt(Math.floor(t), 0, 255)
        }
        Ci.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Mr("SegmentVector", Ci);
        const fa = xa([{
            name: "a_pattern_from",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_pattern_to",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_pixel_ratio_from",
            components: 1,
            type: "Uint16"
          }, {
            name: "a_pixel_ratio_to",
            components: 1,
            type: "Uint16"
          }]),
          ta = xa([{
            name: "a_dasharray_from",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_dasharray_to",
            components: 4,
            type: "Uint16"
          }]);
        var ka, oa, Va, la = {
            exports: {}
          },
          Ia = {
            exports: {}
          },
          un = {
            exports: {}
          },
          Ks = (function() {
            if (Va) return la.exports;
            Va = 1;
            var i = (ka || (ka = 1, Ia.exports = function(r, n) {
                var l, p, f, _, x, M, C, L;
                for (p = r.length - (l = 3 & r.length), f = n, x = 3432918353, M = 461845907, L = 0; L < p;) C = 255 & r.charCodeAt(L) | (255 & r.charCodeAt(++L)) << 8 | (255 & r.charCodeAt(++L)) << 16 | (255 & r.charCodeAt(++L)) << 24, ++L, f = 27492 + (65535 & (_ = 5 * (65535 & (f = (f ^= C = (65535 & (C = (C = (65535 & C) * x + (((C >>> 16) * x & 65535) << 16) & 4294967295) << 15 | C >>> 17)) * M + (((C >>> 16) * M & 65535) << 16) & 4294967295) << 13 | f >>> 19)) + ((5 * (f >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (_ >>> 16) & 65535) << 16);
                switch (C = 0, l) {
                  case 3:
                    C ^= (255 & r.charCodeAt(L + 2)) << 16;
                  case 2:
                    C ^= (255 & r.charCodeAt(L + 1)) << 8;
                  case 1:
                    f ^= C = (65535 & (C = (C = (65535 & (C ^= 255 & r.charCodeAt(L))) * x + (((C >>> 16) * x & 65535) << 16) & 4294967295) << 15 | C >>> 17)) * M + (((C >>> 16) * M & 65535) << 16) & 4294967295
                }
                return f ^= r.length, f = 2246822507 * (65535 & (f ^= f >>> 16)) + ((2246822507 * (f >>> 16) & 65535) << 16) & 4294967295, f = 3266489909 * (65535 & (f ^= f >>> 13)) + ((3266489909 * (f >>> 16) & 65535) << 16) & 4294967295, (f ^= f >>> 16) >>> 0
              }), Ia.exports),
              t = (oa || (oa = 1, un.exports = function(r, n) {
                for (var l, p = r.length, f = n ^ p, _ = 0; p >= 4;) l = 1540483477 * (65535 & (l = 255 & r.charCodeAt(_) | (255 & r.charCodeAt(++_)) << 8 | (255 & r.charCodeAt(++_)) << 16 | (255 & r.charCodeAt(++_)) << 24)) + ((1540483477 * (l >>> 16) & 65535) << 16), f = 1540483477 * (65535 & f) + ((1540483477 * (f >>> 16) & 65535) << 16) ^ (l = 1540483477 * (65535 & (l ^= l >>> 24)) + ((1540483477 * (l >>> 16) & 65535) << 16)), p -= 4, ++_;
                switch (p) {
                  case 3:
                    f ^= (255 & r.charCodeAt(_ + 2)) << 16;
                  case 2:
                    f ^= (255 & r.charCodeAt(_ + 1)) << 8;
                  case 1:
                    f = 1540483477 * (65535 & (f ^= 255 & r.charCodeAt(_))) + ((1540483477 * (f >>> 16) & 65535) << 16)
                }
                return f = 1540483477 * (65535 & (f ^= f >>> 13)) + ((1540483477 * (f >>> 16) & 65535) << 16), (f ^= f >>> 15) >>> 0
              }), un.exports);
            return la.exports = i, la.exports.murmur3 = i, la.exports.murmur2 = t, la.exports
          })(),
          ps = W(Ks);
        class is {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = !1
          }
          add(t, r, n, l) {
            this.ids.push(Js(t)), this.positions.push(r, n, l)
          }
          getPositions(t) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const r = Js(t);
            let n = 0,
              l = this.ids.length - 1;
            for (; n < l;) {
              const f = n + l >> 1;
              this.ids[f] >= r ? l = f : n = f + 1
            }
            const p = [];
            for (; this.ids[n] === r;) p.push({
              index: this.positions[3 * n],
              start: this.positions[3 * n + 1],
              end: this.positions[3 * n + 2]
            }), n++;
            return p
          }
          static serialize(t, r) {
            const n = new Float64Array(t.ids),
              l = new Uint32Array(t.positions);
            return Ao(n, l, 0, n.length - 1), r && r.push(n.buffer, l.buffer), {
              ids: n,
              positions: l
            }
          }
          static deserialize(t) {
            const r = new is;
            return r.ids = t.ids, r.positions = t.positions, r.indexed = !0, r
          }
        }

        function Js(i) {
          const t = +i;
          return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER ? t : ps(String(i))
        }

        function Ao(i, t, r, n) {
          for (; r < n;) {
            const l = i[r + n >> 1];
            let p = r - 1,
              f = n + 1;
            for (;;) {
              do p++; while (i[p] < l);
              do f--; while (i[f] > l);
              if (p >= f) break;
              Qs(i, p, f), Qs(t, 3 * p, 3 * f), Qs(t, 3 * p + 1, 3 * f + 1), Qs(t, 3 * p + 2, 3 * f + 2)
            }
            f - r < n - f ? (Ao(i, t, r, f), r = f + 1) : (Ao(i, t, f + 1, n), n = f)
          }
        }

        function Qs(i, t, r) {
          const n = i[t];
          i[t] = i[r], i[r] = n
        }
        Mr("FeaturePositionMap", is);
        class _n {
          constructor(t, r) {
            this.gl = t.gl, this.location = r
          }
        }
        class hn extends _n {
          constructor(t, r) {
            super(t, r), this.current = 0
          }
          set(t) {
            this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t))
          }
        }
        class fs extends _n {
          constructor(t, r) {
            super(t, r), this.current = [0, 0, 0, 0]
          }
          set(t) {
            t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]))
          }
        }
        class Ms extends _n {
          constructor(t, r) {
            super(t, r), this.current = Ir.transparent
          }
          set(t) {
            t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a))
          }
        }
        const nl = new Float32Array(16);

        function Ca(i) {
          return [Qi(255 * i.r, 255 * i.g), Qi(255 * i.b, 255 * i.a)]
        }
        class ba {
          constructor(t, r, n) {
            this.value = t, this.uniformNames = r.map((l => `u_${l}`)), this.type = n
          }
          setUniform(t, r, n) {
            t.set(n.constantOr(this.value))
          }
          getBinding(t, r, n) {
            return this.type === "color" ? new Ms(t, r) : new hn(t, r)
          }
        }
        class Za {
          constructor(t, r) {
            this.uniformNames = r.map((n => `u_${n}`)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1
          }
          setConstantPatternPositions(t, r) {
            this.pixelRatioFrom = r.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = r.tlbr, this.patternTo = t.tlbr
          }
          setConstantDashPositions(t, r) {
            this.dashTo = [0, t.y, t.height, t.width], this.dashFrom = [0, r.y, r.height, r.width]
          }
          setUniform(t, r, n, l) {
            let p = null;
            l === "u_pattern_to" ? p = this.patternTo : l === "u_pattern_from" ? p = this.patternFrom : l === "u_dasharray_to" ? p = this.dashTo : l === "u_dasharray_from" ? p = this.dashFrom : l === "u_pixel_ratio_to" ? p = this.pixelRatioTo : l === "u_pixel_ratio_from" && (p = this.pixelRatioFrom), p !== null && t.set(p)
          }
          getBinding(t, r, n) {
            return n.substr(0, 9) === "u_pattern" || n.substr(0, 12) === "u_dasharray_" ? new fs(t, r) : new hn(t, r)
          }
        }
        class ia {
          constructor(t, r, n, l) {
            this.expression = t, this.type = n, this.maxValue = 0, this.paintVertexAttributes = r.map((p => ({
              name: `a_${p}`,
              type: "Float32",
              components: n === "color" ? 2 : 1,
              offset: 0
            }))), this.paintVertexArray = new l
          }
          populatePaintArray(t, r, n) {
            const l = this.paintVertexArray.length,
              p = this.expression.evaluate(new Ji(0, n), r, {}, n.canonical, [], n.formattedSection);
            this.paintVertexArray.resize(t), this._setPaintValue(l, t, p)
          }
          updatePaintArray(t, r, n, l, p) {
            const f = this.expression.evaluate(new Ji(0, p), n, l);
            this._setPaintValue(t, r, f)
          }
          _setPaintValue(t, r, n) {
            if (this.type === "color") {
              const l = Ca(n);
              for (let p = t; p < r; p++) this.paintVertexArray.emplace(p, l[0], l[1])
            } else {
              for (let l = t; l < r; l++) this.paintVertexArray.emplace(l, n);
              this.maxValue = Math.max(this.maxValue, Math.abs(n))
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy()
          }
        }
        class Gn {
          constructor(t, r, n, l, p, f) {
            this.expression = t, this.uniformNames = r.map((_ => `u_${_}_t`)), this.type = n, this.useIntegerZoom = l, this.zoom = p, this.maxValue = 0, this.paintVertexAttributes = r.map((_ => ({
              name: `a_${_}`,
              type: "Float32",
              components: n === "color" ? 4 : 2,
              offset: 0
            }))), this.paintVertexArray = new f
          }
          populatePaintArray(t, r, n) {
            const l = this.expression.evaluate(new Ji(this.zoom, n), r, {}, n.canonical, [], n.formattedSection),
              p = this.expression.evaluate(new Ji(this.zoom + 1, n), r, {}, n.canonical, [], n.formattedSection),
              f = this.paintVertexArray.length;
            this.paintVertexArray.resize(t), this._setPaintValue(f, t, l, p)
          }
          updatePaintArray(t, r, n, l, p) {
            const f = this.expression.evaluate(new Ji(this.zoom, p), n, l),
              _ = this.expression.evaluate(new Ji(this.zoom + 1, p), n, l);
            this._setPaintValue(t, r, f, _)
          }
          _setPaintValue(t, r, n, l) {
            if (this.type === "color") {
              const p = Ca(n),
                f = Ca(l);
              for (let _ = t; _ < r; _++) this.paintVertexArray.emplace(_, p[0], p[1], f[0], f[1])
            } else {
              for (let p = t; p < r; p++) this.paintVertexArray.emplace(p, n, l);
              this.maxValue = Math.max(this.maxValue, Math.abs(n), Math.abs(l))
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy()
          }
          setUniform(t, r) {
            const n = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom,
              l = Xt(this.expression.interpolationFactor(n, this.zoom, this.zoom + 1), 0, 1);
            t.set(l)
          }
          getBinding(t, r, n) {
            return new hn(t, r)
          }
        }
        class Is {
          constructor(t, r, n, l, p, f) {
            this.expression = t, this.type = r, this.useIntegerZoom = n, this.zoom = l, this.layerId = f, this.zoomInPaintVertexArray = new p, this.zoomOutPaintVertexArray = new p
          }
          populatePaintArray(t, r, n) {
            const l = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(l, t, this.getPositionIds(r), n)
          }
          updatePaintArray(t, r, n, l, p) {
            this._setPaintValues(t, r, this.getPositionIds(n), p)
          }
          _setPaintValues(t, r, n, l) {
            const p = this.getPositions(l);
            if (!p || !n) return;
            const f = p[n.min],
              _ = p[n.mid],
              x = p[n.max];
            if (f && _ && x)
              for (let M = t; M < r; M++) this.emplace(this.zoomInPaintVertexArray, M, _, f), this.emplace(this.zoomOutPaintVertexArray, M, _, x)
          }
          upload(t) {
            if (this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer) {
              const r = this.getVertexAttributes();
              this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, r, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, r, this.expression.isStateDependent)
            }
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy()
          }
        }
        class Id extends Is {
          getPositions(t) {
            return t.imagePositions
          }
          getPositionIds(t) {
            return t.patterns && t.patterns[this.layerId]
          }
          getVertexAttributes() {
            return fa.members
          }
          emplace(t, r, n, l) {
            t.emplace(r, n.tlbr[0], n.tlbr[1], n.tlbr[2], n.tlbr[3], l.tlbr[0], l.tlbr[1], l.tlbr[2], l.tlbr[3], n.pixelRatio, l.pixelRatio)
          }
        }
        class Cd extends Is {
          getPositions(t) {
            return t.dashPositions
          }
          getPositionIds(t) {
            return t.dashes && t.dashes[this.layerId]
          }
          getVertexAttributes() {
            return ta.members
          }
          emplace(t, r, n, l) {
            t.emplace(r, 0, n.y, n.height, n.width, 0, l.y, l.height, l.width)
          }
        }
        class Ad {
          constructor(t, r, n) {
            this.binders = {}, this._buffers = [];
            const l = [];
            for (const p in t.paint._values) {
              if (!n(p)) continue;
              const f = t.paint.get(p);
              if (!(f instanceof Nn && bo(f.property.specification))) continue;
              const _ = to(p, t.type),
                x = f.value,
                M = f.property.specification.type,
                C = f.property.useIntegerZoom,
                L = f.property.specification["property-type"],
                O = L === "cross-faded" || L === "cross-faded-data-driven";
              if (x.kind === "constant") this.binders[p] = O ? new Za(x.value, _) : new ba(x.value, _, M), l.push(`/u_${p}`);
              else if (x.kind === "source" || O) {
                const N = Mu(p, M, "source");
                this.binders[p] = O ? p === "line-dasharray" ? new Cd(x, M, C, r, N, t.id) : new Id(x, M, C, r, N, t.id) : new ia(x, _, M, N), l.push(`/a_${p}`)
              } else {
                const N = Mu(p, M, "composite");
                this.binders[p] = new Gn(x, _, M, C, r, N), l.push(`/z_${p}`)
              }
            }
            this.cacheKey = l.sort().join("")
          }
          getMaxValue(t) {
            const r = this.binders[t];
            return r instanceof ia || r instanceof Gn ? r.maxValue : 0
          }
          populatePaintArrays(t, r, n) {
            for (const l in this.binders) {
              const p = this.binders[l];
              (p instanceof ia || p instanceof Gn || p instanceof Is) && p.populatePaintArray(t, r, n)
            }
          }
          setConstantPatternPositions(t, r) {
            for (const n in this.binders) {
              const l = this.binders[n];
              l instanceof Za && l.setConstantPatternPositions(t, r)
            }
          }
          setConstantDashPositions(t, r) {
            for (const n in this.binders) {
              const l = this.binders[n];
              l instanceof Za && l.setConstantDashPositions(t, r)
            }
          }
          updatePaintArrays(t, r, n, l, p) {
            let f = !1;
            for (const _ in t) {
              const x = r.getPositions(_);
              for (const M of x) {
                const C = n.feature(M.index);
                for (const L in this.binders) {
                  const O = this.binders[L];
                  if ((O instanceof ia || O instanceof Gn || O instanceof Is) && O.expression.isStateDependent === !0) {
                    const N = l.paint.get(L);
                    O.expression = N.value, O.updatePaintArray(M.start, M.end, C, t[_], p), f = !0
                  }
                }
              }
            }
            return f
          }
          defines() {
            const t = [];
            for (const r in this.binders) {
              const n = this.binders[r];
              (n instanceof ba || n instanceof Za) && t.push(...n.uniformNames.map((l => `#define HAS_UNIFORM_${l}`)))
            }
            return t
          }
          getBinderAttributes() {
            const t = [];
            for (const r in this.binders) {
              const n = this.binders[r];
              if (n instanceof ia || n instanceof Gn)
                for (let l = 0; l < n.paintVertexAttributes.length; l++) t.push(n.paintVertexAttributes[l].name);
              else if (n instanceof Is) {
                const l = n.getVertexAttributes();
                for (const p of l) t.push(p.name)
              }
            }
            return t
          }
          getBinderUniforms() {
            const t = [];
            for (const r in this.binders) {
              const n = this.binders[r];
              if (n instanceof ba || n instanceof Za || n instanceof Gn)
                for (const l of n.uniformNames) t.push(l)
            }
            return t
          }
          getPaintVertexBuffers() {
            return this._buffers
          }
          getUniforms(t, r) {
            const n = [];
            for (const l in this.binders) {
              const p = this.binders[l];
              if (p instanceof ba || p instanceof Za || p instanceof Gn) {
                for (const f of p.uniformNames)
                  if (r[f]) {
                    const _ = p.getBinding(t, r[f], f);
                    n.push({
                      name: f,
                      property: l,
                      binding: _
                    })
                  }
              }
            }
            return n
          }
          setUniforms(t, r, n, l) {
            for (const {
                name: p,
                property: f,
                binding: _
              }
              of r) this.binders[f].setUniform(_, l, n.get(f), p)
          }
          updatePaintBuffers(t) {
            this._buffers = [];
            for (const r in this.binders) {
              const n = this.binders[r];
              if (t && n instanceof Is) {
                const l = t.fromScale === 2 ? n.zoomInPaintVertexBuffer : n.zoomOutPaintVertexBuffer;
                l && this._buffers.push(l)
              } else(n instanceof ia || n instanceof Gn) && n.paintVertexBuffer && this._buffers.push(n.paintVertexBuffer)
            }
          }
          upload(t) {
            for (const r in this.binders) {
              const n = this.binders[r];
              (n instanceof ia || n instanceof Gn || n instanceof Is) && n.upload(t)
            }
            this.updatePaintBuffers()
          }
          destroy() {
            for (const t in this.binders) {
              const r = this.binders[t];
              (r instanceof ia || r instanceof Gn || r instanceof Is) && r.destroy()
            }
          }
        }
        class eo {
          constructor(t, r, n = () => !0) {
            this.programConfigurations = {};
            for (const l of t) this.programConfigurations[l.id] = new Ad(l, r, n);
            this.needsUpload = !1, this._featureMap = new is, this._bufferOffset = 0
          }
          populatePaintArrays(t, r, n, l) {
            for (const p in this.programConfigurations) this.programConfigurations[p].populatePaintArrays(t, r, l);
            r.id !== void 0 && this._featureMap.add(r.id, n, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0
          }
          updatePaintArrays(t, r, n, l) {
            for (const p of n) this.needsUpload = this.programConfigurations[p.id].updatePaintArrays(t, this._featureMap, r, p, l) || this.needsUpload
          }
          get(t) {
            return this.programConfigurations[t]
          }
          upload(t) {
            if (this.needsUpload) {
              for (const r in this.programConfigurations) this.programConfigurations[r].upload(t);
              this.needsUpload = !1
            }
          }
          destroy() {
            for (const t in this.programConfigurations) this.programConfigurations[t].destroy()
          }
        }

        function to(i, t) {
          return {
            "text-opacity": ["opacity"],
            "icon-opacity": ["opacity"],
            "text-color": ["fill_color"],
            "icon-color": ["fill_color"],
            "text-halo-color": ["halo_color"],
            "icon-halo-color": ["halo_color"],
            "text-halo-blur": ["halo_blur"],
            "icon-halo-blur": ["halo_blur"],
            "text-halo-width": ["halo_width"],
            "icon-halo-width": ["halo_width"],
            "line-gap-width": ["gapwidth"],
            "line-dasharray": ["dasharray_to", "dasharray_from"],
            "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
            "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
            "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"]
          } [i] || [i.replace(`${t}-`, "").replace(/-/g, "_")]
        }

        function Mu(i, t, r) {
          const n = {
              color: {
                source: $s,
                composite: d
              },
              number: {
                source: h,
                composite: $s
              }
            },
            l = (function(p) {
              return {
                "line-pattern": {
                  source: Oe,
                  composite: Oe
                },
                "fill-pattern": {
                  source: Oe,
                  composite: Oe
                },
                "fill-extrusion-pattern": {
                  source: Oe,
                  composite: Oe
                },
                "line-dasharray": {
                  source: lt,
                  composite: lt
                }
              } [p]
            })(i);
          return l && l[r] || n[t][r]
        }
        Mr("ConstantBinder", ba), Mr("CrossFadedConstantBinder", Za), Mr("SourceExpressionBinder", ia), Mr("CrossFadedPatternBinder", Id), Mr("CrossFadedDasharrayBinder", Cd), Mr("CompositeExpressionBinder", Gn), Mr("ProgramConfiguration", Ad, {
          omit: ["_buffers"]
        }), Mr("ProgramConfigurationSet", eo);
        const Ql = Math.pow(2, 14) - 1,
          Iu = -Ql - 1;

        function ms(i) {
          const t = ot / i.extent,
            r = i.loadGeometry();
          for (let n = 0; n < r.length; n++) {
            const l = r[n];
            for (let p = 0; p < l.length; p++) {
              const f = l[p],
                _ = Math.round(f.x * t),
                x = Math.round(f.y * t);
              f.x = Xt(_, Iu, Ql), f.y = Xt(x, Iu, Ql), (_ < f.x || _ > f.x + 1 || x < f.y || x > f.y + 1) && At("Geometry exceeds allowed extent, reduce your vector tile buffer size")
            }
          }
          return r
        }

        function Cs(i, t) {
          return {
            type: i.type,
            id: i.id,
            properties: i.properties,
            geometry: t ? ms(i) : []
          }
        }
        const ec = -32768;

        function Ty(i, t, r, n, l) {
          i.emplaceBack(ec + 8 * t + n, ec + 8 * r + l)
        }
        class af {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r => r.id)), this.index = t.index, this.hasDependencies = !1, this.layoutVertexArray = new Pe, this.indexArray = new Bt, this.segments = new Ci, this.programConfigurations = new eo(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
          }
          populate(t, r, n) {
            const l = this.layers[0],
              p = [];
            let f = null,
              _ = !1,
              x = l.type === "heatmap";
            if (l.type === "circle") {
              const C = l;
              f = C.layout.get("circle-sort-key"), _ = !f.isConstant(), x = x || C.paint.get("circle-pitch-alignment") === "map"
            }
            const M = x ? r.subdivisionGranularity.circle : 1;
            for (const {
                feature: C,
                id: L,
                index: O,
                sourceLayerIndex: N
              }
              of t) {
              const G = this.layers[0]._featureFilter.needGeometry,
                K = Cs(C, G);
              if (!this.layers[0]._featureFilter.filter(new Ji(this.zoom), K, n)) continue;
              const ie = _ ? f.evaluate(K, {}, n) : void 0,
                pe = {
                  id: L,
                  properties: C.properties,
                  type: C.type,
                  sourceLayerIndex: N,
                  index: O,
                  geometry: G ? K.geometry : ms(C),
                  patterns: {},
                  sortKey: ie
                };
              p.push(pe)
            }
            _ && p.sort(((C, L) => C.sortKey - L.sortKey));
            for (const C of p) {
              const {
                geometry: L,
                index: O,
                sourceLayerIndex: N
              } = C, G = t[O].feature;
              this.addFeature(C, L, O, n, M), r.featureIndex.insert(G, L, O, N, this.index)
            }
          }
          update(t, r, n) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, {
              imagePositions: n
            })
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Hi), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy())
          }
          addFeature(t, r, n, l, p = 1) {
            let f;
            switch (p) {
              case 1:
                f = [0, 7];
                break;
              case 3:
                f = [0, 2, 5, 7];
                break;
              case 5:
                f = [0, 1, 3, 4, 6, 7];
                break;
              case 7:
                f = [0, 1, 2, 3, 4, 5, 6, 7];
                break;
              default:
                throw new Error(`Invalid circle bucket granularity: ${p}; valid values are 1, 3, 5, 7.`)
            }
            const _ = f.length;
            for (const x of r)
              for (const M of x) {
                const C = M.x,
                  L = M.y;
                if (C < 0 || C >= ot || L < 0 || L >= ot) continue;
                const O = this.segments.prepareSegment(_ * _, this.layoutVertexArray, this.indexArray, t.sortKey),
                  N = O.vertexLength;
                for (let G = 0; G < _; G++)
                  for (let K = 0; K < _; K++) Ty(this.layoutVertexArray, C, L, f[K], f[G]);
                for (let G = 0; G < _ - 1; G++)
                  for (let K = 0; K < _ - 1; K++) {
                    const ie = N + G * _ + K,
                      pe = N + (G + 1) * _ + K;
                    this.indexArray.emplaceBack(ie, pe + 1, ie + 1), this.indexArray.emplaceBack(ie, pe, pe + 1)
                  }
                O.vertexLength += _ * _, O.primitiveLength += (_ - 1) * (_ - 1) * 2
              }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, n, {
              imagePositions: {},
              canonical: l
            })
          }
        }

        function Sg(i, t) {
          for (let r = 0; r < i.length; r++)
            if (tc(t, i[r])) return !0;
          for (let r = 0; r < t.length; r++)
            if (tc(i, t[r])) return !0;
          return !!nf(i, t)
        }

        function kd(i, t, r) {
          return !!tc(i, t) || !!sf(t, i, r)
        }

        function Pg(i, t) {
          if (i.length === 1) return Ig(t, i[0]);
          for (let r = 0; r < t.length; r++) {
            const n = t[r];
            for (let l = 0; l < n.length; l++)
              if (tc(i, n[l])) return !0
          }
          for (let r = 0; r < i.length; r++)
            if (Ig(t, i[r])) return !0;
          for (let r = 0; r < t.length; r++)
            if (nf(i, t[r])) return !0;
          return !1
        }

        function Sy(i, t, r) {
          if (i.length > 1) {
            if (nf(i, t)) return !0;
            for (let n = 0; n < t.length; n++)
              if (sf(t[n], i, r)) return !0
          }
          for (let n = 0; n < i.length; n++)
            if (sf(i[n], t, r)) return !0;
          return !1
        }

        function nf(i, t) {
          if (i.length === 0 || t.length === 0) return !1;
          for (let r = 0; r < i.length - 1; r++) {
            const n = i[r],
              l = i[r + 1];
            for (let p = 0; p < t.length - 1; p++)
              if (Py(n, l, t[p], t[p + 1])) return !0
          }
          return !1
        }

        function Py(i, t, r, n) {
          return Mt(i, r, n) !== Mt(t, r, n) && Mt(i, t, r) !== Mt(i, t, n)
        }

        function sf(i, t, r) {
          const n = r * r;
          if (t.length === 1) return i.distSqr(t[0]) < n;
          for (let l = 1; l < t.length; l++)
            if (Mg(i, t[l - 1], t[l]) < n) return !0;
          return !1
        }

        function Mg(i, t, r) {
          const n = t.distSqr(r);
          if (n === 0) return i.distSqr(t);
          const l = ((i.x - t.x) * (r.x - t.x) + (i.y - t.y) * (r.y - t.y)) / n;
          return i.distSqr(l < 0 ? t : l > 1 ? r : r.sub(t)._mult(l)._add(t))
        }

        function Ig(i, t) {
          let r, n, l, p = !1;
          for (let f = 0; f < i.length; f++) {
            r = i[f];
            for (let _ = 0, x = r.length - 1; _ < r.length; x = _++) n = r[_], l = r[x], n.y > t.y != l.y > t.y && t.x < (l.x - n.x) * (t.y - n.y) / (l.y - n.y) + n.x && (p = !p)
          }
          return p
        }

        function tc(i, t) {
          let r = !1;
          for (let n = 0, l = i.length - 1; n < i.length; l = n++) {
            const p = i[n],
              f = i[l];
            p.y > t.y != f.y > t.y && t.x < (f.x - p.x) * (t.y - p.y) / (f.y - p.y) + p.x && (r = !r)
          }
          return r
        }

        function My(i, t, r) {
          const n = r[0],
            l = r[2];
          if (i.x < n.x && t.x < n.x || i.x > l.x && t.x > l.x || i.y < n.y && t.y < n.y || i.y > l.y && t.y > l.y) return !1;
          const p = Mt(i, t, r[0]);
          return p !== Mt(i, t, r[1]) || p !== Mt(i, t, r[2]) || p !== Mt(i, t, r[3])
        }

        function rc(i, t, r) {
          const n = t.paint.get(i).value;
          return n.kind === "constant" ? n.value : r.programConfigurations.get(t.id).getMaxValue(i)
        }

        function Ed(i) {
          return Math.sqrt(i[0] * i[0] + i[1] * i[1])
        }

        function zd(i, t, r, n, l) {
          if (!t[0] && !t[1]) return i;
          const p = B.convert(t)._mult(l);
          r === "viewport" && p._rotate(-n);
          const f = [];
          for (let _ = 0; _ < i.length; _++) f.push(i[_].sub(p));
          return f
        }

        function Iy({
          queryGeometry: i,
          size: t
        }, r) {
          return kd(i, r, t)
        }

        function Cy({
          queryGeometry: i,
          size: t,
          transform: r,
          unwrappedTileID: n,
          getElevation: l
        }, p) {
          return kd(i, p, t * (r.projectTileCoordinates(p.x, p.y, n, l).signedDistanceFromCamera / r.cameraToCenterDistance))
        }

        function Ay({
          queryGeometry: i,
          size: t,
          transform: r,
          unwrappedTileID: n,
          getElevation: l
        }, p) {
          const f = r.projectTileCoordinates(p.x, p.y, n, l).signedDistanceFromCamera,
            _ = t * (r.cameraToCenterDistance / f);
          return kd(i, of(p, r, n, l), _)
        }

        function ky({
          queryGeometry: i,
          size: t,
          transform: r,
          unwrappedTileID: n,
          getElevation: l
        }, p) {
          return kd(i, of(p, r, n, l), t)
        }

        function Cg({
          queryGeometry: i,
          size: t,
          transform: r,
          unwrappedTileID: n,
          getElevation: l,
          pitchAlignment: p = "map",
          pitchScale: f = "map"
        }, _) {
          const x = p === "map" ? f === "map" ? Iy : Cy : f === "map" ? Ay : ky,
            M = {
              queryGeometry: i,
              size: t,
              transform: r,
              unwrappedTileID: n,
              getElevation: l
            };
          for (const C of _)
            for (const L of C)
              if (x(M, L)) return !0;
          return !1
        }

        function of(i, t, r, n) {
          const l = t.projectTileCoordinates(i.x, i.y, r, n).point;
          return new B((.5 * l.x + .5) * t.width, (.5 * -l.y + .5) * t.height)
        }
        let Ag, kg;
        Mr("CircleBucket", af, {
          omit: ["layers"]
        });
        var Ey = {
          get paint() {
            return kg = kg || new nn({
              "circle-radius": new si(J.paint_circle["circle-radius"]),
              "circle-color": new si(J.paint_circle["circle-color"]),
              "circle-blur": new si(J.paint_circle["circle-blur"]),
              "circle-opacity": new si(J.paint_circle["circle-opacity"]),
              "circle-translate": new $r(J.paint_circle["circle-translate"]),
              "circle-translate-anchor": new $r(J.paint_circle["circle-translate-anchor"]),
              "circle-pitch-scale": new $r(J.paint_circle["circle-pitch-scale"]),
              "circle-pitch-alignment": new $r(J.paint_circle["circle-pitch-alignment"]),
              "circle-stroke-width": new si(J.paint_circle["circle-stroke-width"]),
              "circle-stroke-color": new si(J.paint_circle["circle-stroke-color"]),
              "circle-stroke-opacity": new si(J.paint_circle["circle-stroke-opacity"])
            })
          },
          get layout() {
            return Ag = Ag || new nn({
              "circle-sort-key": new si(J.layout_circle["circle-sort-key"])
            })
          }
        };
        class zy extends Un {
          constructor(t, r) {
            super(t, Ey, r)
          }
          createBucket(t) {
            return new af(t)
          }
          queryRadius(t) {
            const r = t;
            return rc("circle-radius", this, r) + rc("circle-stroke-width", this, r) + Ed(this.paint.get("circle-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: r,
            featureState: n,
            geometry: l,
            transform: p,
            pixelsToTileUnits: f,
            unwrappedTileID: _,
            getElevation: x
          }) {
            const M = zd(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -p.bearingInRadians, f),
              C = this.paint.get("circle-radius").evaluate(r, n) + this.paint.get("circle-stroke-width").evaluate(r, n),
              L = this.paint.get("circle-pitch-scale"),
              O = this.paint.get("circle-pitch-alignment");
            let N, G;
            return O === "map" ? (N = M, G = C * f) : (N = (function(K, ie, pe, Ne) {
              return K.map((ye => of(ye, ie, pe, Ne)))
            })(M, p, _, x), G = C), Cg({
              queryGeometry: N,
              size: G,
              transform: p,
              unwrappedTileID: _,
              getElevation: x,
              pitchAlignment: O,
              pitchScale: L
            }, l)
          }
        }
        class Eg extends af {}
        let zg;
        Mr("HeatmapBucket", Eg, {
          omit: ["layers"]
        });
        var Ly = {
          get paint() {
            return zg = zg || new nn({
              "heatmap-radius": new si(J.paint_heatmap["heatmap-radius"]),
              "heatmap-weight": new si(J.paint_heatmap["heatmap-weight"]),
              "heatmap-intensity": new $r(J.paint_heatmap["heatmap-intensity"]),
              "heatmap-color": new il(J.paint_heatmap["heatmap-color"]),
              "heatmap-opacity": new $r(J.paint_heatmap["heatmap-opacity"])
            })
          }
        };

        function lf(i, {
          width: t,
          height: r
        }, n, l) {
          if (l) {
            if (l instanceof Uint8ClampedArray) l = new Uint8Array(l.buffer);
            else if (l.length !== t * r * n) throw new RangeError(`mismatched image size. expected: ${l.length} but got: ${t*r*n}`)
          } else l = new Uint8Array(t * r * n);
          return i.width = t, i.height = r, i.data = l, i
        }

        function Lg(i, {
          width: t,
          height: r
        }, n) {
          if (t === i.width && r === i.height) return;
          const l = lf({}, {
            width: t,
            height: r
          }, n);
          cf(i, l, {
            x: 0,
            y: 0
          }, {
            x: 0,
            y: 0
          }, {
            width: Math.min(i.width, t),
            height: Math.min(i.height, r)
          }, n), i.width = t, i.height = r, i.data = l.data
        }

        function cf(i, t, r, n, l, p) {
          if (l.width === 0 || l.height === 0) return t;
          if (l.width > i.width || l.height > i.height || r.x > i.width - l.width || r.y > i.height - l.height) throw new RangeError("out of range source coordinates for image copy");
          if (l.width > t.width || l.height > t.height || n.x > t.width - l.width || n.y > t.height - l.height) throw new RangeError("out of range destination coordinates for image copy");
          const f = i.data,
            _ = t.data;
          if (f === _) throw new Error("srcData equals dstData, so image is already copied");
          for (let x = 0; x < l.height; x++) {
            const M = ((r.y + x) * i.width + r.x) * p,
              C = ((n.y + x) * t.width + n.x) * p;
            for (let L = 0; L < l.width * p; L++) _[C + L] = f[M + L]
          }
          return t
        }
        class Cu {
          constructor(t, r) {
            lf(this, t, 1, r)
          }
          resize(t) {
            Lg(this, t, 1)
          }
          clone() {
            return new Cu({
              width: this.width,
              height: this.height
            }, new Uint8Array(this.data))
          }
          static copy(t, r, n, l, p) {
            cf(t, r, n, l, p, 1)
          }
        }
        class Tn {
          constructor(t, r) {
            lf(this, t, 4, r)
          }
          resize(t) {
            Lg(this, t, 4)
          }
          replace(t, r) {
            r ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t
          }
          clone() {
            return new Tn({
              width: this.width,
              height: this.height
            }, new Uint8Array(this.data))
          }
          static copy(t, r, n, l, p) {
            cf(t, r, n, l, p, 4)
          }
          setPixel(t, r, n) {
            const l = 4 * (t * this.width + r);
            this.data[l + 0] = Math.round(255 * n.r / n.a), this.data[l + 1] = Math.round(255 * n.g / n.a), this.data[l + 2] = Math.round(255 * n.b / n.a), this.data[l + 3] = Math.round(255 * n.a)
          }
        }

        function Dg(i) {
          const t = {},
            r = i.resolution || 256,
            n = i.clips ? i.clips.length : 1,
            l = i.image || new Tn({
              width: r,
              height: n
            });
          if (Math.log(r) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${r}`);
          const p = (f, _, x) => {
            t[i.evaluationKey] = x;
            const M = i.expression.evaluate(t);
            l.setPixel(f / 4 / r, _ / 4, M)
          };
          if (i.clips)
            for (let f = 0, _ = 0; f < n; ++f, _ += 4 * r)
              for (let x = 0, M = 0; x < r; x++, M += 4) {
                const C = x / (r - 1),
                  {
                    start: L,
                    end: O
                  } = i.clips[f];
                p(_, M, L * (1 - C) + O * C)
              } else
                for (let f = 0, _ = 0; f < r; f++, _ += 4) p(0, _, f / (r - 1));
          return l
        }
        Mr("AlphaImage", Cu), Mr("RGBAImage", Tn);
        const uf = "big-fb";
        class Dy extends Un {
          createBucket(t) {
            return new Eg(t)
          }
          constructor(t, r) {
            super(t, Ly, r), this.heatmapFbos = new Map, this._updateColorRamp()
          }
          _handleSpecialPaintPropertyUpdate(t) {
            t === "heatmap-color" && this._updateColorRamp()
          }
          _updateColorRamp() {
            this.colorRamp = Dg({
              expression: this._transitionablePaint._values["heatmap-color"].value.expression,
              evaluationKey: "heatmapDensity",
              image: this.colorRamp
            }), this.colorRampTexture = null
          }
          resize() {
            this.heatmapFbos.has(uf) && this.heatmapFbos.delete(uf)
          }
          queryRadius(t) {
            return rc("heatmap-radius", this, t)
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: r,
            featureState: n,
            geometry: l,
            transform: p,
            pixelsToTileUnits: f,
            unwrappedTileID: _,
            getElevation: x
          }) {
            return Cg({
              queryGeometry: t,
              size: this.paint.get("heatmap-radius").evaluate(r, n) * f,
              transform: p,
              unwrappedTileID: _,
              getElevation: x
            }, l)
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none"
          }
        }
        let Rg;
        var Ry = {
          get paint() {
            return Rg = Rg || new nn({
              "hillshade-illumination-direction": new $r(J.paint_hillshade["hillshade-illumination-direction"]),
              "hillshade-illumination-altitude": new $r(J.paint_hillshade["hillshade-illumination-altitude"]),
              "hillshade-illumination-anchor": new $r(J.paint_hillshade["hillshade-illumination-anchor"]),
              "hillshade-exaggeration": new $r(J.paint_hillshade["hillshade-exaggeration"]),
              "hillshade-shadow-color": new $r(J.paint_hillshade["hillshade-shadow-color"]),
              "hillshade-highlight-color": new $r(J.paint_hillshade["hillshade-highlight-color"]),
              "hillshade-accent-color": new $r(J.paint_hillshade["hillshade-accent-color"]),
              "hillshade-method": new $r(J.paint_hillshade["hillshade-method"])
            })
          }
        };
        class Fy extends Un {
          constructor(t, r) {
            super(t, Ry, r), this.recalculate({
              zoom: 0,
              zoomHistory: {}
            }, void 0)
          }
          getIlluminationProperties() {
            let t = this.paint.get("hillshade-illumination-direction").values,
              r = this.paint.get("hillshade-illumination-altitude").values,
              n = this.paint.get("hillshade-highlight-color").values,
              l = this.paint.get("hillshade-shadow-color").values;
            const p = Math.max(t.length, r.length, n.length, l.length);
            t = t.concat(Array(p - t.length).fill(t.at(-1))), r = r.concat(Array(p - r.length).fill(r.at(-1))), n = n.concat(Array(p - n.length).fill(n.at(-1))), l = l.concat(Array(p - l.length).fill(l.at(-1)));
            const f = r.map(Nr);
            return {
              directionRadians: t.map(Nr),
              altitudeRadians: f,
              shadowColor: l,
              highlightColor: n
            }
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none"
          }
        }
        let Fg;
        var By = {
          get paint() {
            return Fg = Fg || new nn({
              "color-relief-opacity": new $r(J["paint_color-relief"]["color-relief-opacity"]),
              "color-relief-color": new il(J["paint_color-relief"]["color-relief-color"])
            })
          }
        };
        class hf {
          constructor(t, r, n, l) {
            this.context = t, this.format = n, this.texture = t.gl.createTexture(), this.update(r, l)
          }
          update(t, r, n) {
            const {
              width: l,
              height: p
            } = t, f = !(this.size && this.size[0] === l && this.size[1] === p || n), {
              context: _
            } = this, {
              gl: x
            } = _;
            if (this.useMipmap = !!(r && r.useMipmap), x.bindTexture(x.TEXTURE_2D, this.texture), _.pixelStoreUnpackFlipY.set(!1), _.pixelStoreUnpack.set(1), _.pixelStoreUnpackPremultiplyAlpha.set(this.format === x.RGBA && (!r || r.premultiply !== !1)), f) this.size = [l, p], t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || ut(t) ? x.texImage2D(x.TEXTURE_2D, 0, this.format, this.format, x.UNSIGNED_BYTE, t) : x.texImage2D(x.TEXTURE_2D, 0, this.format, l, p, 0, this.format, x.UNSIGNED_BYTE, t.data);
            else {
              const {
                x: M,
                y: C
              } = n || {
                x: 0,
                y: 0
              };
              t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || ut(t) ? x.texSubImage2D(x.TEXTURE_2D, 0, M, C, x.RGBA, x.UNSIGNED_BYTE, t) : x.texSubImage2D(x.TEXTURE_2D, 0, M, C, l, p, x.RGBA, x.UNSIGNED_BYTE, t.data)
            }
            this.useMipmap && this.isSizePowerOfTwo() && x.generateMipmap(x.TEXTURE_2D), _.pixelStoreUnpackFlipY.setDefault(), _.pixelStoreUnpack.setDefault(), _.pixelStoreUnpackPremultiplyAlpha.setDefault()
          }
          bind(t, r, n) {
            const {
              context: l
            } = this, {
              gl: p
            } = l;
            p.bindTexture(p.TEXTURE_2D, this.texture), n !== p.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (n = p.LINEAR), t !== this.filter && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, t), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, n || t), this.filter = t), r !== this.wrap && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, r), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, r), this.wrap = r)
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0
          }
          destroy() {
            const {
              gl: t
            } = this.context;
            t.deleteTexture(this.texture), this.texture = null
          }
        }
        class Bg {
          constructor(t, r, n, l = 1, p = 1, f = 1, _ = 0) {
            if (this.uid = t, r.height !== r.width) throw new RangeError("DEM tiles must be square");
            if (n && !["mapbox", "terrarium", "custom"].includes(n)) return void At(`"${n}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = r.height;
            const x = this.dim = r.height - 2;
            switch (this.data = new Uint32Array(r.data.buffer), n) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = l, this.greenFactor = p, this.blueFactor = f, this.baseShift = _;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = .1, this.baseShift = 1e4
            }
            for (let M = 0; M < x; M++) this.data[this._idx(-1, M)] = this.data[this._idx(0, M)], this.data[this._idx(x, M)] = this.data[this._idx(x - 1, M)], this.data[this._idx(M, -1)] = this.data[this._idx(M, 0)], this.data[this._idx(M, x)] = this.data[this._idx(M, x - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(x, -1)] = this.data[this._idx(x - 1, 0)], this.data[this._idx(-1, x)] = this.data[this._idx(0, x - 1)], this.data[this._idx(x, x)] = this.data[this._idx(x - 1, x - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let M = 0; M < x; M++)
              for (let C = 0; C < x; C++) {
                const L = this.get(M, C);
                L > this.max && (this.max = L), L < this.min && (this.min = L)
              }
          }
          get(t, r) {
            const n = new Uint8Array(this.data.buffer),
              l = 4 * this._idx(t, r);
            return this.unpack(n[l], n[l + 1], n[l + 2])
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift]
          }
          _idx(t, r) {
            if (t < -1 || t >= this.dim + 1 || r < -1 || r >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (r + 1) * this.stride + (t + 1)
          }
          unpack(t, r, n) {
            return t * this.redFactor + r * this.greenFactor + n * this.blueFactor - this.baseShift
          }
          pack(t) {
            return Og(t, this.getUnpackVector())
          }
          getPixels() {
            return new Tn({
              width: this.stride,
              height: this.stride
            }, new Uint8Array(this.data.buffer))
          }
          backfillBorder(t, r, n) {
            if (this.dim !== t.dim) throw new Error("dem dimension mismatch");
            let l = r * this.dim,
              p = r * this.dim + this.dim,
              f = n * this.dim,
              _ = n * this.dim + this.dim;
            switch (r) {
              case -1:
                l = p - 1;
                break;
              case 1:
                p = l + 1
            }
            switch (n) {
              case -1:
                f = _ - 1;
                break;
              case 1:
                _ = f + 1
            }
            const x = -r * this.dim,
              M = -n * this.dim;
            for (let C = f; C < _; C++)
              for (let L = l; L < p; L++) this.data[this._idx(L, C)] = t.data[this._idx(L + x, C + M)]
          }
        }

        function Og(i, t) {
          const r = t[0],
            n = t[1],
            l = t[2],
            p = t[3],
            f = Math.min(r, n, l),
            _ = Math.round((i + p) / f);
          return {
            r: Math.floor(_ * f / r) % 256,
            g: Math.floor(_ * f / n) % 256,
            b: Math.floor(_ * f / l) % 256
          }
        }
        Mr("DEMData", Bg);
        class Oy extends Un {
          constructor(t, r) {
            super(t, By, r)
          }
          _createColorRamp(t) {
            const r = {
                elevationStops: [],
                colorStops: []
              },
              n = this._transitionablePaint._values["color-relief-color"].value.expression;
            if (n instanceof $o && n._styleExpression.expression instanceof Gi) {
              this.colorRampExpression = n;
              const f = n._styleExpression.expression;
              r.elevationStops = f.labels, r.colorStops = [];
              for (const _ of r.elevationStops) r.colorStops.push(f.evaluate({
                globals: {
                  elevation: _
                }
              }))
            }
            if (r.elevationStops.length < 1 && (r.elevationStops = [0], r.colorStops = [Ir.transparent]), r.elevationStops.length < 2 && (r.elevationStops.push(r.elevationStops[0] + 1), r.colorStops.push(r.colorStops[0])), r.elevationStops.length <= t) return r;
            const l = {
                elevationStops: [],
                colorStops: []
              },
              p = (r.elevationStops.length - 1) / (t - 1);
            for (let f = 0; f < r.elevationStops.length - .5; f += p) l.elevationStops.push(r.elevationStops[Math.round(f)]), l.colorStops.push(r.colorStops[Math.round(f)]);
            return At(`Too many colors in specification of ${this.id} color-relief layer, may not render properly. Max possible colors: ${t}, provided: ${r.elevationStops.length}`), l
          }
          _colorRampChanged() {
            return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression
          }
          getColorRampTextures(t, r, n) {
            if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
            const l = this._createColorRamp(r),
              p = new Tn({
                width: l.colorStops.length,
                height: 1
              }),
              f = new Tn({
                width: l.colorStops.length,
                height: 1
              });
            for (let _ = 0; _ < l.elevationStops.length; _++) {
              const x = Og(l.elevationStops[_], n);
              f.setPixel(0, _, new Ir(x.r / 255, x.g / 255, x.b / 255, 1)), p.setPixel(0, _, l.colorStops[_])
            }
            return this.colorRampTextures = {
              elevationTexture: new hf(t, f, t.gl.RGBA),
              colorTexture: new hf(t, p, t.gl.RGBA)
            }, this.colorRampTextures
          }
          hasOffscreenPass() {
            return this.visibility !== "none" && !!this.colorRampTextures
          }
        }
        const jy = xa([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: qy
          } = jy;

        function Ld(i, t, r) {
          const n = r.patternDependencies;
          let l = !1;
          for (const p of t) {
            const f = p.paint.get(`${i}-pattern`);
            f.isConstant() || (l = !0);
            const _ = f.constantOr(null);
            _ && (l = !0, n[_.to] = !0, n[_.from] = !0)
          }
          return l
        }

        function df(i, t, r, n, l) {
          const {
            zoom: p
          } = n, f = l.patternDependencies;
          for (const _ of t) {
            const x = _.paint.get(`${i}-pattern`).value;
            if (x.kind !== "constant") {
              let M = x.evaluate({
                  zoom: p - 1
                }, r, {}, l.availableImages),
                C = x.evaluate({
                  zoom: p
                }, r, {}, l.availableImages),
                L = x.evaluate({
                  zoom: p + 1
                }, r, {}, l.availableImages);
              M = M && M.name ? M.name : M, C = C && C.name ? C.name : C, L = L && L.name ? L.name : L, f[M] = !0, f[C] = !0, f[L] = !0, r.patterns[_.id] = {
                min: M,
                mid: C,
                max: L
              }
            }
          }
          return r
        }

        function jg(i, t, r, n, l) {
          let p;
          if (l === (function(f, _, x, M) {
              let C = 0;
              for (let L = _, O = x - M; L < x; L += M) C += (f[O] - f[L]) * (f[L + 1] + f[O + 1]), O = L;
              return C
            })(i, t, r, n) > 0)
            for (let f = t; f < r; f += n) p = Ng(f / n | 0, i[f], i[f + 1], p);
          else
            for (let f = r - n; f >= t; f -= n) p = Ng(f / n | 0, i[f], i[f + 1], p);
          return p && ic(p, p.next) && (zu(p), p = p.next), p
        }

        function sl(i, t) {
          if (!i) return i;
          t || (t = i);
          let r, n = i;
          do
            if (r = !1, n.steiner || !ic(n, n.next) && Aa(n.prev, n, n.next) !== 0) n = n.next;
            else {
              if (zu(n), n = t = n.prev, n === n.next) break;
              r = !0
            } while (r || n !== t);
          return t
        }

        function Au(i, t, r, n, l, p, f) {
          if (!i) return;
          !f && p && (function(x, M, C, L) {
            let O = x;
            do O.z === 0 && (O.z = pf(O.x, O.y, M, C, L)), O.prevZ = O.prev, O.nextZ = O.next, O = O.next; while (O !== x);
            O.prevZ.nextZ = null, O.prevZ = null, (function(N) {
              let G, K = 1;
              do {
                let ie, pe = N;
                N = null;
                let Ne = null;
                for (G = 0; pe;) {
                  G++;
                  let ye = pe,
                    ke = 0;
                  for (let gt = 0; gt < K && (ke++, ye = ye.nextZ, ye); gt++);
                  let at = K;
                  for (; ke > 0 || at > 0 && ye;) ke !== 0 && (at === 0 || !ye || pe.z <= ye.z) ? (ie = pe, pe = pe.nextZ, ke--) : (ie = ye, ye = ye.nextZ, at--), Ne ? Ne.nextZ = ie : N = ie, ie.prevZ = Ne, Ne = ie;
                  pe = ye
                }
                Ne.nextZ = null, K *= 2
              } while (G > 1)
            })(O)
          })(i, n, l, p);
          let _ = i;
          for (; i.prev !== i.next;) {
            const x = i.prev,
              M = i.next;
            if (p ? Zy(i, n, l, p) : Vy(i)) t.push(x.i, i.i, M.i), zu(i), i = M.next, _ = M.next;
            else if ((i = M) === _) {
              f ? f === 1 ? Au(i = Ny(sl(i), t), t, r, n, l, p, 2) : f === 2 && Uy(i, t, r, n, l, p) : Au(sl(i), t, r, n, l, p, 1);
              break
            }
          }
        }

        function Vy(i) {
          const t = i.prev,
            r = i,
            n = i.next;
          if (Aa(t, r, n) >= 0) return !1;
          const l = t.x,
            p = r.x,
            f = n.x,
            _ = t.y,
            x = r.y,
            M = n.y,
            C = Math.min(l, p, f),
            L = Math.min(_, x, M),
            O = Math.max(l, p, f),
            N = Math.max(_, x, M);
          let G = n.next;
          for (; G !== t;) {
            if (G.x >= C && G.x <= O && G.y >= L && G.y <= N && ku(l, _, p, x, f, M, G.x, G.y) && Aa(G.prev, G, G.next) >= 0) return !1;
            G = G.next
          }
          return !0
        }

        function Zy(i, t, r, n) {
          const l = i.prev,
            p = i,
            f = i.next;
          if (Aa(l, p, f) >= 0) return !1;
          const _ = l.x,
            x = p.x,
            M = f.x,
            C = l.y,
            L = p.y,
            O = f.y,
            N = Math.min(_, x, M),
            G = Math.min(C, L, O),
            K = Math.max(_, x, M),
            ie = Math.max(C, L, O),
            pe = pf(N, G, t, r, n),
            Ne = pf(K, ie, t, r, n);
          let ye = i.prevZ,
            ke = i.nextZ;
          for (; ye && ye.z >= pe && ke && ke.z <= Ne;) {
            if (ye.x >= N && ye.x <= K && ye.y >= G && ye.y <= ie && ye !== l && ye !== f && ku(_, C, x, L, M, O, ye.x, ye.y) && Aa(ye.prev, ye, ye.next) >= 0 || (ye = ye.prevZ, ke.x >= N && ke.x <= K && ke.y >= G && ke.y <= ie && ke !== l && ke !== f && ku(_, C, x, L, M, O, ke.x, ke.y) && Aa(ke.prev, ke, ke.next) >= 0)) return !1;
            ke = ke.nextZ
          }
          for (; ye && ye.z >= pe;) {
            if (ye.x >= N && ye.x <= K && ye.y >= G && ye.y <= ie && ye !== l && ye !== f && ku(_, C, x, L, M, O, ye.x, ye.y) && Aa(ye.prev, ye, ye.next) >= 0) return !1;
            ye = ye.prevZ
          }
          for (; ke && ke.z <= Ne;) {
            if (ke.x >= N && ke.x <= K && ke.y >= G && ke.y <= ie && ke !== l && ke !== f && ku(_, C, x, L, M, O, ke.x, ke.y) && Aa(ke.prev, ke, ke.next) >= 0) return !1;
            ke = ke.nextZ
          }
          return !0
        }

        function Ny(i, t) {
          let r = i;
          do {
            const n = r.prev,
              l = r.next.next;
            !ic(n, l) && Vg(n, r, r.next, l) && Eu(n, l) && Eu(l, n) && (t.push(n.i, r.i, l.i), zu(r), zu(r.next), r = i = l), r = r.next
          } while (r !== i);
          return sl(r)
        }

        function Uy(i, t, r, n, l, p) {
          let f = i;
          do {
            let _ = f.next.next;
            for (; _ !== f.prev;) {
              if (f.i !== _.i && Xy(f, _)) {
                let x = Zg(f, _);
                return f = sl(f, f.next), x = sl(x, x.next), Au(f, t, r, n, l, p, 0), void Au(x, t, r, n, l, p, 0)
              }
              _ = _.next
            }
            f = f.next
          } while (f !== i)
        }

        function Gy(i, t) {
          let r = i.x - t.x;
          return r === 0 && (r = i.y - t.y, r === 0) && (r = (i.next.y - i.y) / (i.next.x - i.x) - (t.next.y - t.y) / (t.next.x - t.x)), r
        }

        function Wy(i, t) {
          const r = (function(l, p) {
            let f = p;
            const _ = l.x,
              x = l.y;
            let M, C = -1 / 0;
            if (ic(l, f)) return f;
            do {
              if (ic(l, f.next)) return f.next;
              if (x <= f.y && x >= f.next.y && f.next.y !== f.y) {
                const K = f.x + (x - f.y) * (f.next.x - f.x) / (f.next.y - f.y);
                if (K <= _ && K > C && (C = K, M = f.x < f.next.x ? f : f.next, K === _)) return M
              }
              f = f.next
            } while (f !== p);
            if (!M) return null;
            const L = M,
              O = M.x,
              N = M.y;
            let G = 1 / 0;
            f = M;
            do {
              if (_ >= f.x && f.x >= O && _ !== f.x && qg(x < N ? _ : C, x, O, N, x < N ? C : _, x, f.x, f.y)) {
                const K = Math.abs(x - f.y) / (_ - f.x);
                Eu(f, l) && (K < G || K === G && (f.x > M.x || f.x === M.x && Hy(M, f))) && (M = f, G = K)
              }
              f = f.next
            } while (f !== L);
            return M
          })(i, t);
          if (!r) return t;
          const n = Zg(r, i);
          return sl(n, n.next), sl(r, r.next)
        }

        function Hy(i, t) {
          return Aa(i.prev, i, t.prev) < 0 && Aa(t.next, i, i.next) < 0
        }

        function pf(i, t, r, n, l) {
          return (i = 1431655765 & ((i = 858993459 & ((i = 252645135 & ((i = 16711935 & ((i = (i - r) * l | 0) | i << 8)) | i << 4)) | i << 2)) | i << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - n) * l | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
        }

        function $y(i) {
          let t = i,
            r = i;
          do(t.x < r.x || t.x === r.x && t.y < r.y) && (r = t), t = t.next; while (t !== i);
          return r
        }

        function qg(i, t, r, n, l, p, f, _) {
          return (l - f) * (t - _) >= (i - f) * (p - _) && (i - f) * (n - _) >= (r - f) * (t - _) && (r - f) * (p - _) >= (l - f) * (n - _)
        }

        function ku(i, t, r, n, l, p, f, _) {
          return !(i === f && t === _) && qg(i, t, r, n, l, p, f, _)
        }

        function Xy(i, t) {
          return i.next.i !== t.i && i.prev.i !== t.i && !(function(r, n) {
            let l = r;
            do {
              if (l.i !== r.i && l.next.i !== r.i && l.i !== n.i && l.next.i !== n.i && Vg(l, l.next, r, n)) return !0;
              l = l.next
            } while (l !== r);
            return !1
          })(i, t) && (Eu(i, t) && Eu(t, i) && (function(r, n) {
            let l = r,
              p = !1;
            const f = (r.x + n.x) / 2,
              _ = (r.y + n.y) / 2;
            do l.y > _ != l.next.y > _ && l.next.y !== l.y && f < (l.next.x - l.x) * (_ - l.y) / (l.next.y - l.y) + l.x && (p = !p), l = l.next; while (l !== r);
            return p
          })(i, t) && (Aa(i.prev, i, t.prev) || Aa(i, t.prev, t)) || ic(i, t) && Aa(i.prev, i, i.next) > 0 && Aa(t.prev, t, t.next) > 0)
        }

        function Aa(i, t, r) {
          return (t.y - i.y) * (r.x - t.x) - (t.x - i.x) * (r.y - t.y)
        }

        function ic(i, t) {
          return i.x === t.x && i.y === t.y
        }

        function Vg(i, t, r, n) {
          const l = Rd(Aa(i, t, r)),
            p = Rd(Aa(i, t, n)),
            f = Rd(Aa(r, n, i)),
            _ = Rd(Aa(r, n, t));
          return l !== p && f !== _ || !(l !== 0 || !Dd(i, r, t)) || !(p !== 0 || !Dd(i, n, t)) || !(f !== 0 || !Dd(r, i, n)) || !(_ !== 0 || !Dd(r, t, n))
        }

        function Dd(i, t, r) {
          return t.x <= Math.max(i.x, r.x) && t.x >= Math.min(i.x, r.x) && t.y <= Math.max(i.y, r.y) && t.y >= Math.min(i.y, r.y)
        }

        function Rd(i) {
          return i > 0 ? 1 : i < 0 ? -1 : 0
        }

        function Eu(i, t) {
          return Aa(i.prev, i, i.next) < 0 ? Aa(i, t, i.next) >= 0 && Aa(i, i.prev, t) >= 0 : Aa(i, t, i.prev) < 0 || Aa(i, i.next, t) < 0
        }

        function Zg(i, t) {
          const r = ff(i.i, i.x, i.y),
            n = ff(t.i, t.x, t.y),
            l = i.next,
            p = t.prev;
          return i.next = t, t.prev = i, r.next = l, l.prev = r, n.next = r, r.prev = n, p.next = n, n.prev = p, n
        }

        function Ng(i, t, r, n) {
          const l = ff(i, t, r);
          return n ? (l.next = n.next, l.prev = n, n.next.prev = l, n.next = l) : (l.prev = l, l.next = l), l
        }

        function zu(i) {
          i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ)
        }

        function ff(i, t, r) {
          return {
            i,
            x: t,
            y: r,
            prev: null,
            next: null,
            z: 0,
            prevZ: null,
            nextZ: null,
            steiner: !1
          }
        }
        class ac {
          constructor(t, r) {
            if (r > t) throw new Error("Min granularity must not be greater than base granularity.");
            this._baseZoomGranularity = t, this._minGranularity = r
          }
          getGranularityForZoomLevel(t) {
            return Math.max(Math.floor(this._baseZoomGranularity / (1 << t)), this._minGranularity, 1)
          }
        }
        class Fd {
          constructor(t) {
            this.fill = t.fill, this.line = t.line, this.tile = t.tile, this.stencil = t.stencil, this.circle = t.circle
          }
        }
        Fd.noSubdivision = new Fd({
          fill: new ac(0, 0),
          line: new ac(0, 0),
          tile: new ac(0, 0),
          stencil: new ac(0, 0),
          circle: 1
        }), Mr("SubdivisionGranularityExpression", ac), Mr("SubdivisionGranularitySetting", Fd);
        const nc = -32768,
          Lu = 32767;
        class Yy {
          constructor(t, r) {
            this._vertexBuffer = [], this._vertexDictionary = new Map, this._used = !1, this._granularity = t, this._granularityCellSize = ot / t, this._canonical = r
          }
          _getKey(t, r) {
            return (t += 32768) << 16 | r + 32768
          }
          _vertexToIndex(t, r) {
            if (t < -32768 || r < -32768 || t > 32767 || r > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
            const n = 0 | Math.round(t),
              l = 0 | Math.round(r),
              p = this._getKey(n, l);
            if (this._vertexDictionary.has(p)) return this._vertexDictionary.get(p);
            const f = this._vertexBuffer.length / 2;
            return this._vertexDictionary.set(p, f), this._vertexBuffer.push(n, l), f
          }
          _subdivideTrianglesScanline(t) {
            if (this._granularity < 2) return (function(l, p) {
              const f = [];
              for (let _ = 0; _ < p.length; _ += 3) {
                const x = p[_],
                  M = p[_ + 1],
                  C = p[_ + 2],
                  L = l[2 * x],
                  O = l[2 * x + 1];
                (l[2 * M] - L) * (l[2 * C + 1] - O) - (l[2 * M + 1] - O) * (l[2 * C] - L) > 0 ? (f.push(x), f.push(C), f.push(M)) : (f.push(x), f.push(M), f.push(C))
              }
              return f
            })(this._vertexBuffer, t);
            const r = [],
              n = t.length;
            for (let l = 0; l < n; l += 3) {
              const p = [t[l + 0], t[l + 1], t[l + 2]],
                f = [this._vertexBuffer[2 * t[l + 0] + 0], this._vertexBuffer[2 * t[l + 0] + 1], this._vertexBuffer[2 * t[l + 1] + 0], this._vertexBuffer[2 * t[l + 1] + 1], this._vertexBuffer[2 * t[l + 2] + 0], this._vertexBuffer[2 * t[l + 2] + 1]];
              let _ = 1 / 0,
                x = 1 / 0,
                M = -1 / 0,
                C = -1 / 0;
              for (let K = 0; K < 3; K++) {
                const ie = f[2 * K],
                  pe = f[2 * K + 1];
                _ = Math.min(_, ie), M = Math.max(M, ie), x = Math.min(x, pe), C = Math.max(C, pe)
              }
              if (_ === M || x === C) continue;
              const L = Math.floor(_ / this._granularityCellSize),
                O = Math.ceil(M / this._granularityCellSize),
                N = Math.floor(x / this._granularityCellSize),
                G = Math.ceil(C / this._granularityCellSize);
              if (L !== O || N !== G)
                for (let K = N; K < G; K++) {
                  const ie = this._scanlineGenerateVertexRingForCellRow(K, f, p);
                  Ky(this._vertexBuffer, ie, r)
                } else r.push(...p)
            }
            return r
          }
          _scanlineGenerateVertexRingForCellRow(t, r, n) {
            const l = t * this._granularityCellSize,
              p = l + this._granularityCellSize,
              f = [];
            for (let _ = 0; _ < 3; _++) {
              const x = r[2 * _],
                M = r[2 * _ + 1],
                C = r[2 * (_ + 1) % 6],
                L = r[(2 * (_ + 1) + 1) % 6],
                O = r[2 * (_ + 2) % 6],
                N = r[(2 * (_ + 2) + 1) % 6],
                G = C - x,
                K = L - M,
                ie = G === 0,
                pe = K === 0,
                Ne = (l - M) / K,
                ye = (p - M) / K,
                ke = Math.min(Ne, ye),
                at = Math.max(Ne, ye);
              if (!pe && (ke >= 1 || at <= 0) || pe && (M < l || M > p)) {
                L >= l && L <= p && f.push(n[(_ + 1) % 3]);
                continue
              }!pe && ke > 0 && f.push(this._vertexToIndex(x + G * ke, M + K * ke));
              const gt = x + G * Math.max(ke, 0),
                Wt = x + G * Math.min(at, 1);
              ie || this._generateIntraEdgeVertices(f, x, M, C, L, gt, Wt), !pe && at < 1 && f.push(this._vertexToIndex(x + G * at, M + K * at)), (pe || L >= l && L <= p) && f.push(n[(_ + 1) % 3]), !pe && (L <= l || L >= p) && this._generateInterEdgeVertices(f, x, M, C, L, O, N, Wt, l, p)
            }
            return f
          }
          _generateIntraEdgeVertices(t, r, n, l, p, f, _) {
            const x = l - r,
              M = p - n,
              C = M === 0,
              L = C ? Math.min(r, l) : Math.min(f, _),
              O = C ? Math.max(r, l) : Math.max(f, _),
              N = Math.floor(L / this._granularityCellSize) + 1,
              G = Math.ceil(O / this._granularityCellSize) - 1;
            if (C ? r < l : f < _)
              for (let K = N; K <= G; K++) {
                const ie = K * this._granularityCellSize;
                t.push(this._vertexToIndex(ie, n + M * (ie - r) / x))
              } else
                for (let K = G; K >= N; K--) {
                  const ie = K * this._granularityCellSize;
                  t.push(this._vertexToIndex(ie, n + M * (ie - r) / x))
                }
          }
          _generateInterEdgeVertices(t, r, n, l, p, f, _, x, M, C) {
            const L = p - n,
              O = f - l,
              N = _ - p,
              G = (M - p) / N,
              K = (C - p) / N,
              ie = Math.min(G, K),
              pe = Math.max(G, K),
              Ne = l + O * ie;
            let ye = Math.floor(Math.min(Ne, x) / this._granularityCellSize) + 1,
              ke = Math.ceil(Math.max(Ne, x) / this._granularityCellSize) - 1,
              at = x < Ne;
            const gt = N === 0;
            if (gt && (_ === M || _ === C)) return;
            if (gt || ie >= 1 || pe <= 0) {
              const xr = n - _,
                hr = f + (r - f) * Math.min((M - _) / xr, (C - _) / xr);
              ye = Math.floor(Math.min(hr, x) / this._granularityCellSize) + 1, ke = Math.ceil(Math.max(hr, x) / this._granularityCellSize) - 1, at = x < hr
            }
            const Wt = L > 0 ? C : M;
            if (at)
              for (let xr = ye; xr <= ke; xr++) t.push(this._vertexToIndex(xr * this._granularityCellSize, Wt));
            else
              for (let xr = ke; xr >= ye; xr--) t.push(this._vertexToIndex(xr * this._granularityCellSize, Wt))
          }
          _generateOutline(t) {
            const r = [];
            for (const n of t) {
              const l = ol(n, this._granularity, !0),
                p = this._pointArrayToIndices(l),
                f = [];
              for (let _ = 1; _ < p.length; _++) f.push(p[_ - 1]), f.push(p[_]);
              r.push(f)
            }
            return r
          }
          _handlePoles(t) {
            let r = !1,
              n = !1;
            this._canonical && (this._canonical.y === 0 && (r = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (n = !0)), (r || n) && this._fillPoles(t, r, n)
          }
          _ensureNoPoleVertices() {
            const t = this._vertexBuffer;
            for (let r = 0; r < t.length; r += 2) {
              const n = t[r + 1];
              n === nc && (t[r + 1] = -32767), n === Lu && (t[r + 1] = 32766)
            }
          }
          _generatePoleQuad(t, r, n, l, p, f) {
            l > p != (f === nc) ? (t.push(r), t.push(n), t.push(this._vertexToIndex(l, f)), t.push(n), t.push(this._vertexToIndex(p, f)), t.push(this._vertexToIndex(l, f))) : (t.push(n), t.push(r), t.push(this._vertexToIndex(l, f)), t.push(this._vertexToIndex(p, f)), t.push(n), t.push(this._vertexToIndex(l, f)))
          }
          _fillPoles(t, r, n) {
            const l = this._vertexBuffer,
              p = ot,
              f = t.length;
            for (let _ = 2; _ < f; _ += 3) {
              const x = t[_ - 2],
                M = t[_ - 1],
                C = t[_],
                L = l[2 * x],
                O = l[2 * x + 1],
                N = l[2 * M],
                G = l[2 * M + 1],
                K = l[2 * C],
                ie = l[2 * C + 1];
              r && (O === 0 && G === 0 && this._generatePoleQuad(t, x, M, L, N, nc), G === 0 && ie === 0 && this._generatePoleQuad(t, M, C, N, K, nc), ie === 0 && O === 0 && this._generatePoleQuad(t, C, x, K, L, nc)), n && (O === p && G === p && this._generatePoleQuad(t, x, M, L, N, Lu), G === p && ie === p && this._generatePoleQuad(t, M, C, N, K, Lu), ie === p && O === p && this._generatePoleQuad(t, C, x, K, L, Lu))
            }
          }
          _initializeVertices(t) {
            for (let r = 0; r < t.length; r += 2) this._vertexToIndex(t[r], t[r + 1])
          }
          subdividePolygonInternal(t, r) {
            if (this._used) throw new Error("Subdivision: multiple use not allowed.");
            this._used = !0;
            const {
              flattened: n,
              holeIndices: l
            } = (function(_) {
              const x = [],
                M = [];
              for (const C of _)
                if (C.length !== 0) {
                  C !== _[0] && x.push(M.length / 2);
                  for (let L = 0; L < C.length; L++) M.push(C[L].x), M.push(C[L].y)
                } return {
                flattened: M,
                holeIndices: x
              }
            })(t);
            let p;
            this._initializeVertices(n);
            try {
              const _ = (function(M, C, L = 2) {
                  const O = C && C.length,
                    N = O ? C[0] * L : M.length;
                  let G = jg(M, 0, N, L, !0);
                  const K = [];
                  if (!G || G.next === G.prev) return K;
                  let ie, pe, Ne;
                  if (O && (G = (function(ye, ke, at, gt) {
                      const Wt = [];
                      for (let xr = 0, hr = ke.length; xr < hr; xr++) {
                        const _r = jg(ye, ke[xr] * gt, xr < hr - 1 ? ke[xr + 1] * gt : ye.length, gt, !1);
                        _r === _r.next && (_r.steiner = !0), Wt.push($y(_r))
                      }
                      Wt.sort(Gy);
                      for (let xr = 0; xr < Wt.length; xr++) at = Wy(Wt[xr], at);
                      return at
                    })(M, C, G, L)), M.length > 80 * L) {
                    ie = M[0], pe = M[1];
                    let ye = ie,
                      ke = pe;
                    for (let at = L; at < N; at += L) {
                      const gt = M[at],
                        Wt = M[at + 1];
                      gt < ie && (ie = gt), Wt < pe && (pe = Wt), gt > ye && (ye = gt), Wt > ke && (ke = Wt)
                    }
                    Ne = Math.max(ye - ie, ke - pe), Ne = Ne !== 0 ? 32767 / Ne : 0
                  }
                  return Au(G, K, L, ie, pe, Ne, 0), K
                })(n, l),
                x = this._convertIndices(n, _);
              p = this._subdivideTrianglesScanline(x)
            } catch (_) {
              console.error(_)
            }
            let f = [];
            return r && (f = this._generateOutline(t)), this._ensureNoPoleVertices(), this._handlePoles(p), {
              verticesFlattened: this._vertexBuffer,
              indicesTriangles: p,
              indicesLineList: f
            }
          }
          _convertIndices(t, r) {
            const n = [];
            for (let l = 0; l < r.length; l++) n.push(this._vertexToIndex(t[2 * r[l]], t[2 * r[l] + 1]));
            return n
          }
          _pointArrayToIndices(t) {
            const r = [];
            for (let n = 0; n < t.length; n++) {
              const l = t[n];
              r.push(this._vertexToIndex(l.x, l.y))
            }
            return r
          }
        }

        function Ug(i, t, r, n = !0) {
          return new Yy(r, t).subdividePolygonInternal(i, n)
        }

        function ol(i, t, r = !1) {
          if (!i || i.length < 1) return [];
          if (i.length < 2) return [];
          const n = i[0],
            l = i[i.length - 1],
            p = r && (n.x !== l.x || n.y !== l.y);
          if (t < 2) return p ? [...i, i[0]] : [...i];
          const f = Math.floor(ot / t),
            _ = [];
          _.push(new B(i[0].x, i[0].y));
          const x = i.length,
            M = p ? x : x - 1;
          for (let C = 0; C < M; C++) {
            const L = i[C],
              O = C < x - 1 ? i[C + 1] : i[0],
              N = L.x,
              G = L.y,
              K = O.x,
              ie = O.y,
              pe = N !== K,
              Ne = G !== ie;
            if (!pe && !Ne) continue;
            const ye = K - N,
              ke = ie - G,
              at = Math.abs(ye),
              gt = Math.abs(ke);
            let Wt = N,
              xr = G;
            for (;;) {
              const _r = ye > 0 ? (Math.floor(Wt / f) + 1) * f : (Math.ceil(Wt / f) - 1) * f,
                Qr = ke > 0 ? (Math.floor(xr / f) + 1) * f : (Math.ceil(xr / f) - 1) * f,
                gr = Math.abs(Wt - _r),
                vr = Math.abs(xr - Qr),
                zt = Math.abs(Wt - K),
                ci = Math.abs(xr - ie),
                pi = pe ? gr / at : Number.POSITIVE_INFINITY,
                ai = Ne ? vr / gt : Number.POSITIVE_INFINITY;
              if ((zt <= gr || !pe) && (ci <= vr || !Ne)) break;
              if (pi < ai && pe || !Ne) {
                Wt = _r, xr += ke * pi;
                const Hr = new B(Wt, Math.round(xr));
                _[_.length - 1].x === Hr.x && _[_.length - 1].y === Hr.y || _.push(Hr)
              } else {
                Wt += ye * ai, xr = Qr;
                const Hr = new B(Math.round(Wt), xr);
                _[_.length - 1].x === Hr.x && _[_.length - 1].y === Hr.y || _.push(Hr)
              }
            }
            const hr = new B(K, ie);
            _[_.length - 1].x === hr.x && _[_.length - 1].y === hr.y || _.push(hr)
          }
          return _
        }

        function Ky(i, t, r) {
          if (t.length === 0) throw new Error("Subdivision vertex ring is empty.");
          let n = 0,
            l = i[2 * t[0]];
          for (let x = 1; x < t.length; x++) {
            const M = i[2 * t[x]];
            M < l && (l = M, n = x)
          }
          const p = t.length;
          let f = n,
            _ = (f + 1) % p;
          for (;;) {
            const x = f - 1 >= 0 ? f - 1 : p - 1,
              M = (_ + 1) % p,
              C = i[2 * t[x]],
              L = i[2 * t[M]],
              O = i[2 * t[f]],
              N = i[2 * t[f] + 1],
              G = i[2 * t[_] + 1];
            let K = !1;
            if (C < L) K = !0;
            else if (C > L) K = !1;
            else {
              const ie = G - N,
                pe = -(i[2 * t[_]] - O),
                Ne = N < G ? 1 : -1;
              ((C - O) * ie + (i[2 * t[x] + 1] - N) * pe) * Ne > ((L - O) * ie + (i[2 * t[M] + 1] - N) * pe) * Ne && (K = !0)
            }
            if (K) {
              const ie = t[x],
                pe = t[f],
                Ne = t[_];
              ie !== pe && ie !== Ne && pe !== Ne && r.push(Ne, pe, ie), f--, f < 0 && (f = p - 1)
            } else {
              const ie = t[M],
                pe = t[f],
                Ne = t[_];
              ie !== pe && ie !== Ne && pe !== Ne && r.push(Ne, pe, ie), _++, _ >= p && (_ = 0)
            }
            if (x === M) break
          }
        }

        function Gg(i, t, r, n, l, p, f, _, x) {
          const M = l.length / 2,
            C = f && _ && x;
          if (M < Ci.MAX_VERTEX_ARRAY_LENGTH) {
            const L = t.prepareSegment(M, r, n),
              O = L.vertexLength;
            for (let K = 0; K < p.length; K += 3) n.emplaceBack(O + p[K], O + p[K + 1], O + p[K + 2]);
            let N, G;
            L.vertexLength += M, L.primitiveLength += p.length / 3, C && (G = f.prepareSegment(M, r, _), N = G.vertexLength, G.vertexLength += M);
            for (let K = 0; K < l.length; K += 2) i(l[K], l[K + 1]);
            if (C)
              for (let K = 0; K < x.length; K++) {
                const ie = x[K];
                for (let pe = 1; pe < ie.length; pe += 2) _.emplaceBack(N + ie[pe - 1], N + ie[pe]);
                G.primitiveLength += ie.length / 2
              }
          } else(function(L, O, N, G, K, ie) {
            const pe = [];
            for (let gt = 0; gt < G.length / 2; gt++) pe.push(-1);
            const Ne = {
              count: 0
            };
            let ye = 0,
              ke = L.getOrCreateLatestSegment(O, N),
              at = ke.vertexLength;
            for (let gt = 2; gt < K.length; gt += 3) {
              const Wt = K[gt - 2],
                xr = K[gt - 1],
                hr = K[gt];
              let _r = pe[Wt] < ye,
                Qr = pe[xr] < ye,
                gr = pe[hr] < ye;
              ke.vertexLength + ((_r ? 1 : 0) + (Qr ? 1 : 0) + (gr ? 1 : 0)) > Ci.MAX_VERTEX_ARRAY_LENGTH && (ke = L.createNewSegment(O, N), ye = Ne.count, _r = !0, Qr = !0, gr = !0, at = 0);
              const vr = Du(pe, G, ie, Ne, Wt, _r, ke),
                zt = Du(pe, G, ie, Ne, xr, Qr, ke),
                ci = Du(pe, G, ie, Ne, hr, gr, ke);
              N.emplaceBack(at + vr - ye, at + zt - ye, at + ci - ye), ke.primitiveLength++
            }
          })(t, r, n, l, p, i), C && (function(L, O, N, G, K, ie) {
            const pe = [];
            for (let gt = 0; gt < G.length / 2; gt++) pe.push(-1);
            const Ne = {
              count: 0
            };
            let ye = 0,
              ke = L.getOrCreateLatestSegment(O, N),
              at = ke.vertexLength;
            for (let gt = 0; gt < K.length; gt++) {
              const Wt = K[gt];
              for (let xr = 1; xr < K[gt].length; xr += 2) {
                const hr = Wt[xr - 1],
                  _r = Wt[xr];
                let Qr = pe[hr] < ye,
                  gr = pe[_r] < ye;
                ke.vertexLength + ((Qr ? 1 : 0) + (gr ? 1 : 0)) > Ci.MAX_VERTEX_ARRAY_LENGTH && (ke = L.createNewSegment(O, N), ye = Ne.count, Qr = !0, gr = !0, at = 0);
                const vr = Du(pe, G, ie, Ne, hr, Qr, ke),
                  zt = Du(pe, G, ie, Ne, _r, gr, ke);
                N.emplaceBack(at + vr - ye, at + zt - ye), ke.primitiveLength++
              }
            }
          })(f, r, _, l, x, i), t.forceNewSegmentOnNextPrepare(), f == null || f.forceNewSegmentOnNextPrepare()
        }

        function Du(i, t, r, n, l, p, f) {
          if (p) {
            const _ = n.count;
            return r(t[2 * l], t[2 * l + 1]), i[l] = n.count, n.count++, f.vertexLength++, _
          }
          return i[l]
        }
        class mf {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r => r.id)), this.index = t.index, this.hasDependencies = !1, this.patternFeatures = [], this.layoutVertexArray = new fe, this.indexArray = new Bt, this.indexArray2 = new qr, this.programConfigurations = new eo(t.layers, t.zoom), this.segments = new Ci, this.segments2 = new Ci, this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
          }
          populate(t, r, n) {
            this.hasDependencies = Ld("fill", this.layers, r);
            const l = this.layers[0].layout.get("fill-sort-key"),
              p = !l.isConstant(),
              f = [];
            for (const {
                feature: _,
                id: x,
                index: M,
                sourceLayerIndex: C
              }
              of t) {
              const L = this.layers[0]._featureFilter.needGeometry,
                O = Cs(_, L);
              if (!this.layers[0]._featureFilter.filter(new Ji(this.zoom), O, n)) continue;
              const N = p ? l.evaluate(O, {}, n, r.availableImages) : void 0,
                G = {
                  id: x,
                  properties: _.properties,
                  type: _.type,
                  sourceLayerIndex: C,
                  index: M,
                  geometry: L ? O.geometry : ms(_),
                  patterns: {},
                  sortKey: N
                };
              f.push(G)
            }
            p && f.sort(((_, x) => _.sortKey - x.sortKey));
            for (const _ of f) {
              const {
                geometry: x,
                index: M,
                sourceLayerIndex: C
              } = _;
              if (this.hasDependencies) {
                const L = df("fill", this.layers, _, {
                  zoom: this.zoom
                }, r);
                this.patternFeatures.push(L)
              } else this.addFeature(_, x, M, n, {}, r.subdivisionGranularity);
              r.featureIndex.insert(t[M].feature, x, M, C, this.index)
            }
          }
          update(t, r, n) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, {
              imagePositions: n
            })
          }
          addFeatures(t, r, n) {
            for (const l of this.patternFeatures) this.addFeature(l, l.geometry, l.index, r, n, t.subdivisionGranularity)
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, qy), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy())
          }
          addFeature(t, r, n, l, p, f) {
            for (const _ of Pl(r, 500)) {
              const x = Ug(_, l, f.fill.getGranularityForZoomLevel(l.z)),
                M = this.layoutVertexArray;
              Gg(((C, L) => {
                M.emplaceBack(C, L)
              }), this.segments, this.layoutVertexArray, this.indexArray, x.verticesFlattened, x.indicesTriangles, this.segments2, this.indexArray2, x.indicesLineList)
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, n, {
              imagePositions: p,
              canonical: l
            })
          }
        }
        let Wg, Hg;
        Mr("FillBucket", mf, {
          omit: ["layers", "patternFeatures"]
        });
        var Jy = {
          get paint() {
            return Hg = Hg || new nn({
              "fill-antialias": new $r(J.paint_fill["fill-antialias"]),
              "fill-opacity": new si(J.paint_fill["fill-opacity"]),
              "fill-color": new si(J.paint_fill["fill-color"]),
              "fill-outline-color": new si(J.paint_fill["fill-outline-color"]),
              "fill-translate": new $r(J.paint_fill["fill-translate"]),
              "fill-translate-anchor": new $r(J.paint_fill["fill-translate-anchor"]),
              "fill-pattern": new rl(J.paint_fill["fill-pattern"])
            })
          },
          get layout() {
            return Wg = Wg || new nn({
              "fill-sort-key": new si(J.layout_fill["fill-sort-key"])
            })
          }
        };
        class Qy extends Un {
          constructor(t, r) {
            super(t, Jy, r)
          }
          recalculate(t, r) {
            super.recalculate(t, r);
            const n = this.paint._values["fill-outline-color"];
            n.value.kind === "constant" && n.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"])
          }
          createBucket(t) {
            return new mf(t)
          }
          queryRadius() {
            return Ed(this.paint.get("fill-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: t,
            geometry: r,
            transform: n,
            pixelsToTileUnits: l
          }) {
            return Pg(zd(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -n.bearingInRadians, l), r)
          }
          isTileClipped() {
            return !0
          }
        }
        const ex = xa([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_normal_ed",
            components: 4,
            type: "Int16"
          }], 4),
          tx = xa([{
            name: "a_centroid",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: rx
          } = ex;
        class sc {
          constructor(t, r, n, l, p) {
            this.properties = {}, this.extent = n, this.type = 0, this.id = void 0, this._pbf = t, this._geometry = -1, this._keys = l, this._values = p, t.readFields(ix, this, r)
          }
          loadGeometry() {
            const t = this._pbf;
            t.pos = this._geometry;
            const r = t.readVarint() + t.pos,
              n = [];
            let l, p = 1,
              f = 0,
              _ = 0,
              x = 0;
            for (; t.pos < r;) {
              if (f <= 0) {
                const M = t.readVarint();
                p = 7 & M, f = M >> 3
              }
              if (f--, p === 1 || p === 2) _ += t.readSVarint(), x += t.readSVarint(), p === 1 && (l && n.push(l), l = []), l && l.push(new B(_, x));
              else {
                if (p !== 7) throw new Error(`unknown command ${p}`);
                l && l.push(l[0].clone())
              }
            }
            return l && n.push(l), n
          }
          bbox() {
            const t = this._pbf;
            t.pos = this._geometry;
            const r = t.readVarint() + t.pos;
            let n = 1,
              l = 0,
              p = 0,
              f = 0,
              _ = 1 / 0,
              x = -1 / 0,
              M = 1 / 0,
              C = -1 / 0;
            for (; t.pos < r;) {
              if (l <= 0) {
                const L = t.readVarint();
                n = 7 & L, l = L >> 3
              }
              if (l--, n === 1 || n === 2) p += t.readSVarint(), f += t.readSVarint(), p < _ && (_ = p), p > x && (x = p), f < M && (M = f), f > C && (C = f);
              else if (n !== 7) throw new Error(`unknown command ${n}`)
            }
            return [_, M, x, C]
          }
          toGeoJSON(t, r, n) {
            const l = this.extent * Math.pow(2, n),
              p = this.extent * t,
              f = this.extent * r,
              _ = this.loadGeometry();

            function x(O) {
              return [360 * (O.x + p) / l - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (O.y + f) / l) * Math.PI)) - 90]
            }

            function M(O) {
              return O.map(x)
            }
            let C;
            if (this.type === 1) {
              const O = [];
              for (const G of _) O.push(G[0]);
              const N = M(O);
              C = O.length === 1 ? {
                type: "Point",
                coordinates: N[0]
              } : {
                type: "MultiPoint",
                coordinates: N
              }
            } else if (this.type === 2) {
              const O = _.map(M);
              C = O.length === 1 ? {
                type: "LineString",
                coordinates: O[0]
              } : {
                type: "MultiLineString",
                coordinates: O
              }
            } else {
              if (this.type !== 3) throw new Error("unknown feature type");
              {
                const O = (function(G) {
                    const K = G.length;
                    if (K <= 1) return [G];
                    const ie = [];
                    let pe, Ne;
                    for (let ye = 0; ye < K; ye++) {
                      const ke = ax(G[ye]);
                      ke !== 0 && (Ne === void 0 && (Ne = ke < 0), Ne === ke < 0 ? (pe && ie.push(pe), pe = [G[ye]]) : pe && pe.push(G[ye]))
                    }
                    return pe && ie.push(pe), ie
                  })(_),
                  N = [];
                for (const G of O) N.push(G.map(M));
                C = N.length === 1 ? {
                  type: "Polygon",
                  coordinates: N[0]
                } : {
                  type: "MultiPolygon",
                  coordinates: N
                }
              }
            }
            const L = {
              type: "Feature",
              geometry: C,
              properties: this.properties
            };
            return this.id != null && (L.id = this.id), L
          }
        }

        function ix(i, t, r) {
          i === 1 ? t.id = r.readVarint() : i === 2 ? (function(n, l) {
            const p = n.readVarint() + n.pos;
            for (; n.pos < p;) {
              const f = l._keys[n.readVarint()],
                _ = l._values[n.readVarint()];
              l.properties[f] = _
            }
          })(r, t) : i === 3 ? t.type = r.readVarint() : i === 4 && (t._geometry = r.pos)
        }

        function ax(i) {
          let t = 0;
          for (let r, n, l = 0, p = i.length, f = p - 1; l < p; f = l++) r = i[l], n = i[f], t += (n.x - r.x) * (r.y + n.y);
          return t
        }
        sc.types = ["Unknown", "Point", "LineString", "Polygon"];
        class $g {
          constructor(t, r) {
            this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(nx, this, r), this.length = this._features.length
          }
          feature(t) {
            if (t < 0 || t >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t];
            const r = this._pbf.readVarint() + this._pbf.pos;
            return new sc(this._pbf, r, this.extent, this._keys, this._values)
          }
        }

        function nx(i, t, r) {
          i === 15 ? t.version = r.readVarint() : i === 1 ? t.name = r.readString() : i === 5 ? t.extent = r.readVarint() : i === 2 ? t._features.push(r.pos) : i === 3 ? t._keys.push(r.readString()) : i === 4 && t._values.push((function(n) {
            let l = null;
            const p = n.readVarint() + n.pos;
            for (; n.pos < p;) {
              const f = n.readVarint() >> 3;
              l = f === 1 ? n.readString() : f === 2 ? n.readFloat() : f === 3 ? n.readDouble() : f === 4 ? n.readVarint64() : f === 5 ? n.readVarint() : f === 6 ? n.readSVarint() : f === 7 ? n.readBoolean() : null
            }
            if (l == null) throw new Error("unknown feature value");
            return l
          })(r))
        }
        class Xg {
          constructor(t, r) {
            this.layers = t.readFields(sx, {}, r)
          }
        }

        function sx(i, t, r) {
          if (i === 3) {
            const n = new $g(r, r.readVarint() + r.pos);
            n.length && (t[n.name] = n)
          }
        }
        const gf = Math.pow(2, 13);

        function Ru(i, t, r, n, l, p, f, _) {
          i.emplaceBack(t, r, 2 * Math.floor(n * gf) + f, l * gf * 2, p * gf * 2, Math.round(_))
        }
        class _f {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r => r.id)), this.index = t.index, this.hasDependencies = !1, this.layoutVertexArray = new Me, this.centroidVertexArray = new ge, this.indexArray = new Bt, this.programConfigurations = new eo(t.layers, t.zoom), this.segments = new Ci, this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
          }
          populate(t, r, n) {
            this.features = [], this.hasDependencies = Ld("fill-extrusion", this.layers, r);
            for (const {
                feature: l,
                id: p,
                index: f,
                sourceLayerIndex: _
              }
              of t) {
              const x = this.layers[0]._featureFilter.needGeometry,
                M = Cs(l, x);
              if (!this.layers[0]._featureFilter.filter(new Ji(this.zoom), M, n)) continue;
              const C = {
                id: p,
                sourceLayerIndex: _,
                index: f,
                geometry: x ? M.geometry : ms(l),
                properties: l.properties,
                type: l.type,
                patterns: {}
              };
              this.hasDependencies ? this.features.push(df("fill-extrusion", this.layers, C, {
                zoom: this.zoom
              }, r)) : this.addFeature(C, C.geometry, f, n, {}, r.subdivisionGranularity), r.featureIndex.insert(l, C.geometry, f, _, this.index, !0)
            }
          }
          addFeatures(t, r, n) {
            for (const l of this.features) {
              const {
                geometry: p
              } = l;
              this.addFeature(l, p, l.index, r, n, t.subdivisionGranularity)
            }
          }
          update(t, r, n) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, {
              imagePositions: n
            })
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, rx), this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, tx.members, !0), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy())
          }
          addFeature(t, r, n, l, p, f) {
            for (const _ of Pl(r, 500)) {
              const x = {
                  x: 0,
                  y: 0,
                  sampleCount: 0
                },
                M = this.layoutVertexArray.length;
              this.processPolygon(x, l, t, _, f);
              const C = this.layoutVertexArray.length - M,
                L = Math.floor(x.x / x.sampleCount),
                O = Math.floor(x.y / x.sampleCount);
              for (let N = 0; N < C; N++) this.centroidVertexArray.emplaceBack(L, O)
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, n, {
              imagePositions: p,
              canonical: l
            })
          }
          processPolygon(t, r, n, l, p) {
            if (l.length < 1 || Yg(l[0])) return;
            for (const L of l) L.length !== 0 && ox(t, L);
            const f = {
                segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray)
              },
              _ = p.fill.getGranularityForZoomLevel(r.z),
              x = sc.types[n.type] === "Polygon";
            for (const L of l) {
              if (L.length === 0 || Yg(L)) continue;
              const O = ol(L, _, x);
              this._generateSideFaces(O, f)
            }
            if (!x) return;
            const M = Ug(l, r, _, !1),
              C = this.layoutVertexArray;
            Gg(((L, O) => {
              Ru(C, L, O, 0, 0, 1, 1, 0)
            }), this.segments, this.layoutVertexArray, this.indexArray, M.verticesFlattened, M.indicesTriangles)
          }
          _generateSideFaces(t, r) {
            let n = 0;
            for (let l = 1; l < t.length; l++) {
              const p = t[l],
                f = t[l - 1];
              if (lx(p, f)) continue;
              r.segment.vertexLength + 4 > Ci.MAX_VERTEX_ARRAY_LENGTH && (r.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              const _ = p.sub(f)._perp()._unit(),
                x = f.dist(p);
              n + x > 32768 && (n = 0), Ru(this.layoutVertexArray, p.x, p.y, _.x, _.y, 0, 0, n), Ru(this.layoutVertexArray, p.x, p.y, _.x, _.y, 0, 1, n), n += x, Ru(this.layoutVertexArray, f.x, f.y, _.x, _.y, 0, 0, n), Ru(this.layoutVertexArray, f.x, f.y, _.x, _.y, 0, 1, n);
              const M = r.segment.vertexLength;
              this.indexArray.emplaceBack(M, M + 2, M + 1), this.indexArray.emplaceBack(M + 1, M + 2, M + 3), r.segment.vertexLength += 4, r.segment.primitiveLength += 2
            }
          }
        }

        function ox(i, t) {
          for (let r = 0; r < t.length; r++) {
            const n = t[r];
            r === t.length - 1 && t[0].x === n.x && t[0].y === n.y || (i.x += n.x, i.y += n.y, i.sampleCount++)
          }
        }

        function lx(i, t) {
          return i.x === t.x && (i.x < 0 || i.x > ot) || i.y === t.y && (i.y < 0 || i.y > ot)
        }

        function Yg(i) {
          return i.every((t => t.x < 0)) || i.every((t => t.x > ot)) || i.every((t => t.y < 0)) || i.every((t => t.y > ot))
        }
        let Kg;
        Mr("FillExtrusionBucket", _f, {
          omit: ["layers", "features"]
        });
        var cx = {
          get paint() {
            return Kg = Kg || new nn({
              "fill-extrusion-opacity": new $r(J["paint_fill-extrusion"]["fill-extrusion-opacity"]),
              "fill-extrusion-color": new si(J["paint_fill-extrusion"]["fill-extrusion-color"]),
              "fill-extrusion-translate": new $r(J["paint_fill-extrusion"]["fill-extrusion-translate"]),
              "fill-extrusion-translate-anchor": new $r(J["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
              "fill-extrusion-pattern": new rl(J["paint_fill-extrusion"]["fill-extrusion-pattern"]),
              "fill-extrusion-height": new si(J["paint_fill-extrusion"]["fill-extrusion-height"]),
              "fill-extrusion-base": new si(J["paint_fill-extrusion"]["fill-extrusion-base"]),
              "fill-extrusion-vertical-gradient": new $r(J["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])
            })
          }
        };
        class ux extends Un {
          constructor(t, r) {
            super(t, cx, r)
          }
          createBucket(t) {
            return new _f(t)
          }
          queryRadius() {
            return Ed(this.paint.get("fill-extrusion-translate"))
          }
          is3D() {
            return !0
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: r,
            featureState: n,
            geometry: l,
            transform: p,
            pixelsToTileUnits: f,
            pixelPosMatrix: _
          }) {
            const x = zd(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -p.bearingInRadians, f),
              M = this.paint.get("fill-extrusion-height").evaluate(r, n),
              C = this.paint.get("fill-extrusion-base").evaluate(r, n),
              L = (function(N, G) {
                const K = [];
                for (const ie of N) {
                  const pe = [ie.x, ie.y, 0, 1];
                  Ge(pe, pe, G), K.push(new B(pe[0] / pe[3], pe[1] / pe[3]))
                }
                return K
              })(x, _),
              O = (function(N, G, K, ie) {
                const pe = [],
                  Ne = [],
                  ye = ie[8] * G,
                  ke = ie[9] * G,
                  at = ie[10] * G,
                  gt = ie[11] * G,
                  Wt = ie[8] * K,
                  xr = ie[9] * K,
                  hr = ie[10] * K,
                  _r = ie[11] * K;
                for (const Qr of N) {
                  const gr = [],
                    vr = [];
                  for (const zt of Qr) {
                    const ci = zt.x,
                      pi = zt.y,
                      ai = ie[0] * ci + ie[4] * pi + ie[12],
                      Hr = ie[1] * ci + ie[5] * pi + ie[13],
                      Fi = ie[2] * ci + ie[6] * pi + ie[14],
                      va = ie[3] * ci + ie[7] * pi + ie[15],
                      Ra = Fi + at,
                      on = va + gt,
                      Hn = ai + Wt,
                      Sn = Hr + xr,
                      Ka = Fi + hr,
                      ma = va + _r,
                      Ua = new B((ai + ye) / on, (Hr + ke) / on);
                    Ua.z = Ra / on, gr.push(Ua);
                    const Ja = new B(Hn / ma, Sn / ma);
                    Ja.z = Ka / ma, vr.push(Ja)
                  }
                  pe.push(gr), Ne.push(vr)
                }
                return [pe, Ne]
              })(l, C, M, _);
            return (function(N, G, K) {
              let ie = 1 / 0;
              Pg(K, G) && (ie = Jg(K, G[0]));
              for (let pe = 0; pe < G.length; pe++) {
                const Ne = G[pe],
                  ye = N[pe];
                for (let ke = 0; ke < Ne.length - 1; ke++) {
                  const at = Ne[ke],
                    gt = [at, Ne[ke + 1], ye[ke + 1], ye[ke], at];
                  Sg(K, gt) && (ie = Math.min(ie, Jg(K, gt)))
                }
              }
              return ie !== 1 / 0 && ie
            })(O[0], O[1], L)
          }
        }

        function Fu(i, t) {
          return i.x * t.x + i.y * t.y
        }

        function Jg(i, t) {
          if (i.length === 1) {
            let r = 0;
            const n = t[r++];
            let l;
            for (; !l || n.equals(l);)
              if (l = t[r++], !l) return 1 / 0;
            for (; r < t.length; r++) {
              const p = t[r],
                f = i[0],
                _ = l.sub(n),
                x = p.sub(n),
                M = f.sub(n),
                C = Fu(_, _),
                L = Fu(_, x),
                O = Fu(x, x),
                N = Fu(M, _),
                G = Fu(M, x),
                K = C * O - L * L,
                ie = (O * N - L * G) / K,
                pe = (C * G - L * N) / K,
                Ne = n.z * (1 - ie - pe) + l.z * ie + p.z * pe;
              if (isFinite(Ne)) return Ne
            }
            return 1 / 0
          } {
            let r = 1 / 0;
            for (const n of t) r = Math.min(r, n.z);
            return r
          }
        }
        const hx = xa([{
            name: "a_pos_normal",
            components: 2,
            type: "Int16"
          }, {
            name: "a_data",
            components: 4,
            type: "Uint8"
          }], 4),
          {
            members: dx
          } = hx,
          px = xa([{
            name: "a_uv_x",
            components: 1,
            type: "Float32"
          }, {
            name: "a_split_index",
            components: 1,
            type: "Float32"
          }]),
          {
            members: fx
          } = px,
          mx = Math.cos(Math.PI / 180 * 37.5),
          Qg = Math.pow(2, 14) / .5;
        class vf {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r => r.id)), this.index = t.index, this.hasDependencies = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((r => {
              this.gradients[r.id] = {}
            })), this.layoutVertexArray = new Ee, this.layoutVertexArray2 = new ve, this.indexArray = new Bt, this.programConfigurations = new eo(t.layers, t.zoom), this.segments = new Ci, this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
          }
          populate(t, r, n) {
            this.hasDependencies = Ld("line", this.layers, r) || this.hasLineDasharray(this.layers);
            const l = this.layers[0].layout.get("line-sort-key"),
              p = !l.isConstant(),
              f = [];
            for (const {
                feature: _,
                id: x,
                index: M,
                sourceLayerIndex: C
              }
              of t) {
              const L = this.layers[0]._featureFilter.needGeometry,
                O = Cs(_, L);
              if (!this.layers[0]._featureFilter.filter(new Ji(this.zoom), O, n)) continue;
              const N = p ? l.evaluate(O, {}, n) : void 0,
                G = {
                  id: x,
                  properties: _.properties,
                  type: _.type,
                  sourceLayerIndex: C,
                  index: M,
                  geometry: L ? O.geometry : ms(_),
                  patterns: {},
                  dashes: {},
                  sortKey: N
                };
              f.push(G)
            }
            p && f.sort(((_, x) => _.sortKey - x.sortKey));
            for (const _ of f) {
              const {
                geometry: x,
                index: M,
                sourceLayerIndex: C
              } = _;
              this.hasDependencies ? (Ld("line", this.layers, r) ? df("line", this.layers, _, {
                zoom: this.zoom
              }, r) : this.hasLineDasharray(this.layers) && this.addLineDashDependencies(this.layers, _, this.zoom, r), this.patternFeatures.push(_)) : this.addFeature(_, x, M, n, {}, {}, r.subdivisionGranularity), r.featureIndex.insert(t[M].feature, x, M, C, this.index)
            }
          }
          update(t, r, n, l) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, {
              imagePositions: n,
              dashPositions: l
            })
          }
          addFeatures(t, r, n, l) {
            for (const p of this.patternFeatures) this.addFeature(p, p.geometry, p.index, r, n, l, t.subdivisionGranularity)
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, fx)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, dx), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy())
          }
          lineFeatureClips(t) {
            if (t.properties && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_end")) return {
              start: +t.properties.mapbox_clip_start,
              end: +t.properties.mapbox_clip_end
            }
          }
          addFeature(t, r, n, l, p, f, _) {
            const x = this.layers[0].layout,
              M = x.get("line-join").evaluate(t, {}),
              C = x.get("line-cap"),
              L = x.get("line-miter-limit"),
              O = x.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t);
            for (const N of r) this.addLine(N, t, M, C, L, O, l, _);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, n, {
              imagePositions: p,
              dashPositions: f,
              canonical: l
            })
          }
          addLine(t, r, n, l, p, f, _, x) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t = ol(t, _ ? x.line.getGranularityForZoomLevel(_.z) : 1), this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let ye = 0; ye < t.length - 1; ye++) this.totalDistance += t[ye].dist(t[ye + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance)
            }
            const M = sc.types[r.type] === "Polygon";
            let C = t.length;
            for (; C >= 2 && t[C - 1].equals(t[C - 2]);) C--;
            let L = 0;
            for (; L < C - 1 && t[L].equals(t[L + 1]);) L++;
            if (C < (M ? 3 : 2)) return;
            n === "bevel" && (p = 1.05);
            const O = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0,
              N = this.segments.prepareSegment(10 * C, this.layoutVertexArray, this.indexArray);
            let G, K, ie, pe, Ne;
            this.e1 = this.e2 = -1, M && (G = t[C - 2], Ne = t[L].sub(G)._unit()._perp());
            for (let ye = L; ye < C; ye++) {
              if (ie = ye === C - 1 ? M ? t[L + 1] : void 0 : t[ye + 1], ie && t[ye].equals(ie)) continue;
              Ne && (pe = Ne), G && (K = G), G = t[ye], Ne = ie ? ie.sub(G)._unit()._perp() : pe, pe = pe || Ne;
              let ke = pe.add(Ne);
              ke.x === 0 && ke.y === 0 || ke._unit();
              const at = pe.x * Ne.x + pe.y * Ne.y,
                gt = ke.x * Ne.x + ke.y * Ne.y,
                Wt = gt !== 0 ? 1 / gt : 1 / 0,
                xr = 2 * Math.sqrt(2 - 2 * gt),
                hr = gt < mx && K && ie,
                _r = pe.x * Ne.y - pe.y * Ne.x > 0;
              if (hr && ye > L) {
                const vr = G.dist(K);
                if (vr > 2 * O) {
                  const zt = G.sub(G.sub(K)._mult(O / vr)._round());
                  this.updateDistance(K, zt), this.addCurrentVertex(zt, pe, 0, 0, N), K = zt
                }
              }
              const Qr = K && ie;
              let gr = Qr ? n : M ? "butt" : l;
              if (Qr && gr === "round" && (Wt < f ? gr = "miter" : Wt <= 2 && (gr = "fakeround")), gr === "miter" && Wt > p && (gr = "bevel"), gr === "bevel" && (Wt > 2 && (gr = "flipbevel"), Wt < p && (gr = "miter")), K && this.updateDistance(K, G), gr === "miter") ke._mult(Wt), this.addCurrentVertex(G, ke, 0, 0, N);
              else if (gr === "flipbevel") {
                if (Wt > 100) ke = Ne.mult(-1);
                else {
                  const vr = Wt * pe.add(Ne).mag() / pe.sub(Ne).mag();
                  ke._perp()._mult(vr * (_r ? -1 : 1))
                }
                this.addCurrentVertex(G, ke, 0, 0, N), this.addCurrentVertex(G, ke.mult(-1), 0, 0, N)
              } else if (gr === "bevel" || gr === "fakeround") {
                const vr = -Math.sqrt(Wt * Wt - 1),
                  zt = _r ? vr : 0,
                  ci = _r ? 0 : vr;
                if (K && this.addCurrentVertex(G, pe, zt, ci, N), gr === "fakeround") {
                  const pi = Math.round(180 * xr / Math.PI / 20);
                  for (let ai = 1; ai < pi; ai++) {
                    let Hr = ai / pi;
                    if (Hr !== .5) {
                      const va = Hr - .5;
                      Hr += Hr * va * (Hr - 1) * ((1.0904 + at * (at * (3.55645 - 1.43519 * at) - 3.2452)) * va * va + (.848013 + at * (.215638 * at - 1.06021)))
                    }
                    const Fi = Ne.sub(pe)._mult(Hr)._add(pe)._unit()._mult(_r ? -1 : 1);
                    this.addHalfVertex(G, Fi.x, Fi.y, !1, _r, 0, N)
                  }
                }
                ie && this.addCurrentVertex(G, Ne, -zt, -ci, N)
              } else if (gr === "butt") this.addCurrentVertex(G, ke, 0, 0, N);
              else if (gr === "square") {
                const vr = K ? 1 : -1;
                this.addCurrentVertex(G, ke, vr, vr, N)
              } else gr === "round" && (K && (this.addCurrentVertex(G, pe, 0, 0, N), this.addCurrentVertex(G, pe, 1, 1, N, !0)), ie && (this.addCurrentVertex(G, Ne, -1, -1, N, !0), this.addCurrentVertex(G, Ne, 0, 0, N)));
              if (hr && ye < C - 1) {
                const vr = G.dist(ie);
                if (vr > 2 * O) {
                  const zt = G.add(ie.sub(G)._mult(O / vr)._round());
                  this.updateDistance(G, zt), this.addCurrentVertex(zt, Ne, 0, 0, N), G = zt
                }
              }
            }
          }
          addCurrentVertex(t, r, n, l, p, f = !1) {
            const _ = r.y * l - r.x,
              x = -r.y - r.x * l;
            this.addHalfVertex(t, r.x + r.y * n, r.y - r.x * n, f, !1, n, p), this.addHalfVertex(t, _, x, f, !0, -l, p), this.distance > Qg / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t, r, n, l, p, f))
          }
          addHalfVertex({
            x: t,
            y: r
          }, n, l, p, f, _, x) {
            const M = .5 * (this.lineClips ? this.scaledDistance * (Qg - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((t << 1) + (p ? 1 : 0), (r << 1) + (f ? 1 : 0), Math.round(63 * n) + 128, Math.round(63 * l) + 128, 1 + (_ === 0 ? 0 : _ < 0 ? -1 : 1) | (63 & M) << 2, M >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const C = x.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, C, this.e2), x.primitiveLength++), f ? this.e2 = C : this.e1 = C
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance
          }
          updateDistance(t, r) {
            this.distance += t.dist(r), this.updateScaledDistance()
          }
          hasLineDasharray(t) {
            for (const r of t) {
              const n = r.paint.get("line-dasharray");
              if (n && !n.isConstant()) return !0
            }
            return !1
          }
          addLineDashDependencies(t, r, n, l) {
            for (const p of t) {
              const f = p.paint.get("line-dasharray");
              if (!f || f.value.kind === "constant") continue;
              const _ = p.layout.get("line-cap") === "round",
                x = {
                  dasharray: f.value.evaluate({
                    zoom: n - 1
                  }, r, {}),
                  round: _
                },
                M = {
                  dasharray: f.value.evaluate({
                    zoom: n
                  }, r, {}),
                  round: _
                },
                C = {
                  dasharray: f.value.evaluate({
                    zoom: n + 1
                  }, r, {}),
                  round: _
                },
                L = `${x.dasharray.join(",")},${x.round}`,
                O = `${M.dasharray.join(",")},${M.round}`,
                N = `${C.dasharray.join(",")},${C.round}`;
              l.dashDependencies[L] = x, l.dashDependencies[O] = M, l.dashDependencies[N] = C, r.dashes[p.id] = {
                min: L,
                mid: O,
                max: N
              }
            }
          }
        }
        let e_, t_;
        Mr("LineBucket", vf, {
          omit: ["layers", "patternFeatures"]
        });
        var r_ = {
          get paint() {
            return t_ = t_ || new nn({
              "line-opacity": new si(J.paint_line["line-opacity"]),
              "line-color": new si(J.paint_line["line-color"]),
              "line-translate": new $r(J.paint_line["line-translate"]),
              "line-translate-anchor": new $r(J.paint_line["line-translate-anchor"]),
              "line-width": new si(J.paint_line["line-width"]),
              "line-gap-width": new si(J.paint_line["line-gap-width"]),
              "line-offset": new si(J.paint_line["line-offset"]),
              "line-blur": new si(J.paint_line["line-blur"]),
              "line-dasharray": new rl(J.paint_line["line-dasharray"]),
              "line-pattern": new rl(J.paint_line["line-pattern"]),
              "line-gradient": new il(J.paint_line["line-gradient"])
            })
          },
          get layout() {
            return e_ = e_ || new nn({
              "line-cap": new $r(J.layout_line["line-cap"]),
              "line-join": new si(J.layout_line["line-join"]),
              "line-miter-limit": new $r(J.layout_line["line-miter-limit"]),
              "line-round-limit": new $r(J.layout_line["line-round-limit"]),
              "line-sort-key": new si(J.layout_line["line-sort-key"])
            })
          }
        };
        class gx extends si {
          possiblyEvaluate(t, r) {
            return r = new Ji(Math.floor(r.zoom), {
              now: r.now,
              fadeDuration: r.fadeDuration,
              zoomHistory: r.zoomHistory,
              transition: r.transition
            }), super.possiblyEvaluate(t, r)
          }
          evaluate(t, r, n, l) {
            return r = nt({}, r, {
              zoom: Math.floor(r.zoom)
            }), super.evaluate(t, r, n, l)
          }
        }
        let Bd;
        class _x extends Un {
          constructor(t, r) {
            super(t, r_, r), this.gradientVersion = 0, Bd || (Bd = new gx(r_.paint.properties["line-width"].specification), Bd.useIntegerZoom = !0)
          }
          _handleSpecialPaintPropertyUpdate(t) {
            if (t === "line-gradient") {
              const r = this.gradientExpression();
              this.stepInterpolant = !!(function(n) {
                return n._styleExpression !== void 0
              })(r) && r._styleExpression.expression instanceof Ma, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression
          }
          recalculate(t, r) {
            super.recalculate(t, r), this.paint._values["line-floorwidth"] = Bd.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t)
          }
          createBucket(t) {
            return new vf(t)
          }
          queryRadius(t) {
            const r = t,
              n = i_(rc("line-width", this, r), rc("line-gap-width", this, r)),
              l = rc("line-offset", this, r);
            return n / 2 + Math.abs(l) + Ed(this.paint.get("line-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: r,
            featureState: n,
            geometry: l,
            transform: p,
            pixelsToTileUnits: f
          }) {
            const _ = zd(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -p.bearingInRadians, f),
              x = f / 2 * i_(this.paint.get("line-width").evaluate(r, n), this.paint.get("line-gap-width").evaluate(r, n)),
              M = this.paint.get("line-offset").evaluate(r, n);
            return M && (l = (function(C, L) {
              const O = [];
              for (let N = 0; N < C.length; N++) {
                const G = C[N],
                  K = [];
                for (let ie = 0; ie < G.length; ie++) {
                  const pe = G[ie - 1],
                    Ne = G[ie],
                    ye = G[ie + 1],
                    ke = ie === 0 ? new B(0, 0) : Ne.sub(pe)._unit()._perp(),
                    at = ie === G.length - 1 ? new B(0, 0) : ye.sub(Ne)._unit()._perp(),
                    gt = ke._add(at)._unit(),
                    Wt = gt.x * at.x + gt.y * at.y;
                  Wt !== 0 && gt._mult(1 / Wt), K.push(gt._mult(L)._add(Ne))
                }
                O.push(K)
              }
              return O
            })(l, M * f)), (function(C, L, O) {
              for (let N = 0; N < L.length; N++) {
                const G = L[N];
                if (C.length >= 3) {
                  for (let K = 0; K < G.length; K++)
                    if (tc(C, G[K])) return !0
                }
                if (Sy(C, G, O)) return !0
              }
              return !1
            })(_, l, x)
          }
          isTileClipped() {
            return !0
          }
        }

        function i_(i, t) {
          return t > 0 ? t + 2 * i : i
        }
        const vx = xa([{
            name: "a_pos_offset",
            components: 4,
            type: "Int16"
          }, {
            name: "a_data",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_pixeloffset",
            components: 4,
            type: "Int16"
          }], 4),
          yx = xa([{
            name: "a_projected_pos",
            components: 3,
            type: "Float32"
          }], 4);
        xa([{
          name: "a_fade_opacity",
          components: 1,
          type: "Uint32"
        }], 4);
        const xx = xa([{
          name: "a_placed",
          components: 2,
          type: "Uint8"
        }, {
          name: "a_shift",
          components: 2,
          type: "Float32"
        }, {
          name: "a_box_real",
          components: 2,
          type: "Int16"
        }]);
        xa([{
          type: "Int16",
          name: "anchorPointX"
        }, {
          type: "Int16",
          name: "anchorPointY"
        }, {
          type: "Int16",
          name: "x1"
        }, {
          type: "Int16",
          name: "y1"
        }, {
          type: "Int16",
          name: "x2"
        }, {
          type: "Int16",
          name: "y2"
        }, {
          type: "Uint32",
          name: "featureIndex"
        }, {
          type: "Uint16",
          name: "sourceLayerIndex"
        }, {
          type: "Uint16",
          name: "bucketIndex"
        }]);
        const a_ = xa([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_anchor_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_extrude",
            components: 2,
            type: "Int16"
          }], 4),
          bx = xa([{
            name: "a_pos",
            components: 2,
            type: "Float32"
          }, {
            name: "a_radius",
            components: 1,
            type: "Float32"
          }, {
            name: "a_flags",
            components: 2,
            type: "Int16"
          }], 4);

        function wx(i, t, r) {
          return i.sections.forEach((n => {
            n.text = (function(l, p, f) {
              const _ = p.layout.get("text-transform").evaluate(f, {});
              return _ === "uppercase" ? l = l.toLocaleUpperCase() : _ === "lowercase" && (l = l.toLocaleLowerCase()), hs.applyArabicShaping && (l = hs.applyArabicShaping(l)), l
            })(n.text, t, r)
          })), i
        }
        xa([{
          name: "triangle",
          components: 3,
          type: "Uint16"
        }]), xa([{
          type: "Int16",
          name: "anchorX"
        }, {
          type: "Int16",
          name: "anchorY"
        }, {
          type: "Uint16",
          name: "glyphStartIndex"
        }, {
          type: "Uint16",
          name: "numGlyphs"
        }, {
          type: "Uint32",
          name: "vertexStartIndex"
        }, {
          type: "Uint32",
          name: "lineStartIndex"
        }, {
          type: "Uint32",
          name: "lineLength"
        }, {
          type: "Uint16",
          name: "segment"
        }, {
          type: "Uint16",
          name: "lowerSize"
        }, {
          type: "Uint16",
          name: "upperSize"
        }, {
          type: "Float32",
          name: "lineOffsetX"
        }, {
          type: "Float32",
          name: "lineOffsetY"
        }, {
          type: "Uint8",
          name: "writingMode"
        }, {
          type: "Uint8",
          name: "placedOrientation"
        }, {
          type: "Uint8",
          name: "hidden"
        }, {
          type: "Uint32",
          name: "crossTileID"
        }, {
          type: "Int16",
          name: "associatedIconIndex"
        }]), xa([{
          type: "Int16",
          name: "anchorX"
        }, {
          type: "Int16",
          name: "anchorY"
        }, {
          type: "Int16",
          name: "rightJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "centerJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "leftJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "verticalPlacedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "placedIconSymbolIndex"
        }, {
          type: "Int16",
          name: "verticalPlacedIconSymbolIndex"
        }, {
          type: "Uint16",
          name: "key"
        }, {
          type: "Uint16",
          name: "textBoxStartIndex"
        }, {
          type: "Uint16",
          name: "textBoxEndIndex"
        }, {
          type: "Uint16",
          name: "verticalTextBoxStartIndex"
        }, {
          type: "Uint16",
          name: "verticalTextBoxEndIndex"
        }, {
          type: "Uint16",
          name: "iconBoxStartIndex"
        }, {
          type: "Uint16",
          name: "iconBoxEndIndex"
        }, {
          type: "Uint16",
          name: "verticalIconBoxStartIndex"
        }, {
          type: "Uint16",
          name: "verticalIconBoxEndIndex"
        }, {
          type: "Uint16",
          name: "featureIndex"
        }, {
          type: "Uint16",
          name: "numHorizontalGlyphVertices"
        }, {
          type: "Uint16",
          name: "numVerticalGlyphVertices"
        }, {
          type: "Uint16",
          name: "numIconVertices"
        }, {
          type: "Uint16",
          name: "numVerticalIconVertices"
        }, {
          type: "Uint16",
          name: "useRuntimeCollisionCircles"
        }, {
          type: "Uint32",
          name: "crossTileID"
        }, {
          type: "Float32",
          name: "textBoxScale"
        }, {
          type: "Float32",
          name: "collisionCircleDiameter"
        }, {
          type: "Uint16",
          name: "textAnchorOffsetStartIndex"
        }, {
          type: "Uint16",
          name: "textAnchorOffsetEndIndex"
        }]), xa([{
          type: "Float32",
          name: "offsetX"
        }]), xa([{
          type: "Int16",
          name: "x"
        }, {
          type: "Int16",
          name: "y"
        }, {
          type: "Int16",
          name: "tileUnitDistanceFromAnchor"
        }]), xa([{
          type: "Uint16",
          name: "textAnchor"
        }, {
          type: "Float32",
          components: 2,
          name: "textOffset"
        }]);
        const Bu = {
          "!": "",
          "#": "",
          $: "",
          "%": "",
          "&": "",
          "(": "",
          ")": "",
          "*": "",
          "+": "",
          ",": "",
          "-": "",
          ".": "",
          "/": "",
          ":": "",
          ";": "",
          "<": "",
          "=": "",
          ">": "",
          "?": "",
          "@": "",
          "[": "",
          "\\": "",
          "]": "",
          "^": "",
          _: "",
          "`": "",
          "{": "",
          "|": "",
          "}": "",
          "~": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": ""
        };
        var Na = 24;
        const yf = 4294967296,
          n_ = 1 / yf,
          s_ = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
        class xf {
          constructor(t = new Uint8Array(16)) {
            this.buf = ArrayBuffer.isView(t) ? t : new Uint8Array(t), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length
          }
          readFields(t, r, n = this.length) {
            for (; this.pos < n;) {
              const l = this.readVarint(),
                p = l >> 3,
                f = this.pos;
              this.type = 7 & l, t(p, r, this), this.pos === f && this.skip(l)
            }
            return r
          }
          readMessage(t, r) {
            return this.readFields(t, r, this.readVarint() + this.pos)
          }
          readFixed32() {
            const t = this.dataView.getUint32(this.pos, !0);
            return this.pos += 4, t
          }
          readSFixed32() {
            const t = this.dataView.getInt32(this.pos, !0);
            return this.pos += 4, t
          }
          readFixed64() {
            const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * yf;
            return this.pos += 8, t
          }
          readSFixed64() {
            const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * yf;
            return this.pos += 8, t
          }
          readFloat() {
            const t = this.dataView.getFloat32(this.pos, !0);
            return this.pos += 4, t
          }
          readDouble() {
            const t = this.dataView.getFloat64(this.pos, !0);
            return this.pos += 8, t
          }
          readVarint(t) {
            const r = this.buf;
            let n, l;
            return l = r[this.pos++], n = 127 & l, l < 128 ? n : (l = r[this.pos++], n |= (127 & l) << 7, l < 128 ? n : (l = r[this.pos++], n |= (127 & l) << 14, l < 128 ? n : (l = r[this.pos++], n |= (127 & l) << 21, l < 128 ? n : (l = r[this.pos], n |= (15 & l) << 28, (function(p, f, _) {
              const x = _.buf;
              let M, C;
              if (C = x[_.pos++], M = (112 & C) >> 4, C < 128 || (C = x[_.pos++], M |= (127 & C) << 3, C < 128) || (C = x[_.pos++], M |= (127 & C) << 10, C < 128) || (C = x[_.pos++], M |= (127 & C) << 17, C < 128) || (C = x[_.pos++], M |= (127 & C) << 24, C < 128) || (C = x[_.pos++], M |= (1 & C) << 31, C < 128)) return oc(p, M, f);
              throw new Error("Expected varint not more than 10 bytes")
            })(n, t, this)))))
          }
          readVarint64() {
            return this.readVarint(!0)
          }
          readSVarint() {
            const t = this.readVarint();
            return t % 2 == 1 ? (t + 1) / -2 : t / 2
          }
          readBoolean() {
            return !!this.readVarint()
          }
          readString() {
            const t = this.readVarint() + this.pos,
              r = this.pos;
            return this.pos = t, t - r >= 12 && s_ ? s_.decode(this.buf.subarray(r, t)) : (function(n, l, p) {
              let f = "",
                _ = l;
              for (; _ < p;) {
                const x = n[_];
                let M, C, L, O = null,
                  N = x > 239 ? 4 : x > 223 ? 3 : x > 191 ? 2 : 1;
                if (_ + N > p) break;
                N === 1 ? x < 128 && (O = x) : N === 2 ? (M = n[_ + 1], (192 & M) == 128 && (O = (31 & x) << 6 | 63 & M, O <= 127 && (O = null))) : N === 3 ? (M = n[_ + 1], C = n[_ + 2], (192 & M) == 128 && (192 & C) == 128 && (O = (15 & x) << 12 | (63 & M) << 6 | 63 & C, (O <= 2047 || O >= 55296 && O <= 57343) && (O = null))) : N === 4 && (M = n[_ + 1], C = n[_ + 2], L = n[_ + 3], (192 & M) == 128 && (192 & C) == 128 && (192 & L) == 128 && (O = (15 & x) << 18 | (63 & M) << 12 | (63 & C) << 6 | 63 & L, (O <= 65535 || O >= 1114112) && (O = null))), O === null ? (O = 65533, N = 1) : O > 65535 && (O -= 65536, f += String.fromCharCode(O >>> 10 & 1023 | 55296), O = 56320 | 1023 & O), f += String.fromCharCode(O), _ += N
              }
              return f
            })(this.buf, r, t)
          }
          readBytes() {
            const t = this.readVarint() + this.pos,
              r = this.buf.subarray(this.pos, t);
            return this.pos = t, r
          }
          readPackedVarint(t = [], r) {
            const n = this.readPackedEnd();
            for (; this.pos < n;) t.push(this.readVarint(r));
            return t
          }
          readPackedSVarint(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readSVarint());
            return t
          }
          readPackedBoolean(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readBoolean());
            return t
          }
          readPackedFloat(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readFloat());
            return t
          }
          readPackedDouble(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readDouble());
            return t
          }
          readPackedFixed32(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readFixed32());
            return t
          }
          readPackedSFixed32(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readSFixed32());
            return t
          }
          readPackedFixed64(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readFixed64());
            return t
          }
          readPackedSFixed64(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readSFixed64());
            return t
          }
          readPackedEnd() {
            return this.type === 2 ? this.readVarint() + this.pos : this.pos + 1
          }
          skip(t) {
            const r = 7 & t;
            if (r === 0)
              for (; this.buf[this.pos++] > 127;);
            else if (r === 2) this.pos = this.readVarint() + this.pos;
            else if (r === 5) this.pos += 4;
            else {
              if (r !== 1) throw new Error(`Unimplemented type: ${r}`);
              this.pos += 8
            }
          }
          writeTag(t, r) {
            this.writeVarint(t << 3 | r)
          }
          realloc(t) {
            let r = this.length || 16;
            for (; r < this.pos + t;) r *= 2;
            if (r !== this.length) {
              const n = new Uint8Array(r);
              n.set(this.buf), this.buf = n, this.dataView = new DataView(n.buffer), this.length = r
            }
          }
          finish() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length)
          }
          writeFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, !0), this.pos += 4
          }
          writeSFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, !0), this.pos += 4
          }
          writeFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t * n_), !0), this.pos += 8
          }
          writeSFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t * n_), !0), this.pos += 8
          }
          writeVarint(t) {
            (t = +t || 0) > 268435455 || t < 0 ? (function(r, n) {
              let l, p;
              if (r >= 0 ? (l = r % 4294967296 | 0, p = r / 4294967296 | 0) : (l = ~(-r % 4294967296), p = ~(-r / 4294967296), 4294967295 ^ l ? l = l + 1 | 0 : (l = 0, p = p + 1 | 0)), r >= 18446744073709552e3 || r < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              n.realloc(10), (function(f, _, x) {
                x.buf[x.pos++] = 127 & f | 128, f >>>= 7, x.buf[x.pos++] = 127 & f | 128, f >>>= 7, x.buf[x.pos++] = 127 & f | 128, f >>>= 7, x.buf[x.pos++] = 127 & f | 128, x.buf[x.pos] = 127 & (f >>>= 7)
              })(l, 0, n), (function(f, _) {
                const x = (7 & f) << 4;
                _.buf[_.pos++] |= x | ((f >>>= 3) ? 128 : 0), f && (_.buf[_.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0), f && (_.buf[_.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0), f && (_.buf[_.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0), f && (_.buf[_.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0), f && (_.buf[_.pos++] = 127 & f)))))
              })(p, n)
            })(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))))
          }
          writeSVarint(t) {
            this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t)
          }
          writeBoolean(t) {
            this.writeVarint(+t)
          }
          writeString(t) {
            t = String(t), this.realloc(4 * t.length), this.pos++;
            const r = this.pos;
            this.pos = (function(l, p, f) {
              for (let _, x, M = 0; M < p.length; M++) {
                if (_ = p.charCodeAt(M), _ > 55295 && _ < 57344) {
                  if (!x) {
                    _ > 56319 || M + 1 === p.length ? (l[f++] = 239, l[f++] = 191, l[f++] = 189) : x = _;
                    continue
                  }
                  if (_ < 56320) {
                    l[f++] = 239, l[f++] = 191, l[f++] = 189, x = _;
                    continue
                  }
                  _ = x - 55296 << 10 | _ - 56320 | 65536, x = null
                } else x && (l[f++] = 239, l[f++] = 191, l[f++] = 189, x = null);
                _ < 128 ? l[f++] = _ : (_ < 2048 ? l[f++] = _ >> 6 | 192 : (_ < 65536 ? l[f++] = _ >> 12 | 224 : (l[f++] = _ >> 18 | 240, l[f++] = _ >> 12 & 63 | 128), l[f++] = _ >> 6 & 63 | 128), l[f++] = 63 & _ | 128)
              }
              return f
            })(this.buf, t, this.pos);
            const n = this.pos - r;
            n >= 128 && o_(r, n, this), this.pos = r - 1, this.writeVarint(n), this.pos += n
          }
          writeFloat(t) {
            this.realloc(4), this.dataView.setFloat32(this.pos, t, !0), this.pos += 4
          }
          writeDouble(t) {
            this.realloc(8), this.dataView.setFloat64(this.pos, t, !0), this.pos += 8
          }
          writeBytes(t) {
            const r = t.length;
            this.writeVarint(r), this.realloc(r);
            for (let n = 0; n < r; n++) this.buf[this.pos++] = t[n]
          }
          writeRawMessage(t, r) {
            this.pos++;
            const n = this.pos;
            t(r, this);
            const l = this.pos - n;
            l >= 128 && o_(n, l, this), this.pos = n - 1, this.writeVarint(l), this.pos += l
          }
          writeMessage(t, r, n) {
            this.writeTag(t, 2), this.writeRawMessage(r, n)
          }
          writePackedVarint(t, r) {
            r.length && this.writeMessage(t, Tx, r)
          }
          writePackedSVarint(t, r) {
            r.length && this.writeMessage(t, Sx, r)
          }
          writePackedBoolean(t, r) {
            r.length && this.writeMessage(t, Ix, r)
          }
          writePackedFloat(t, r) {
            r.length && this.writeMessage(t, Px, r)
          }
          writePackedDouble(t, r) {
            r.length && this.writeMessage(t, Mx, r)
          }
          writePackedFixed32(t, r) {
            r.length && this.writeMessage(t, Cx, r)
          }
          writePackedSFixed32(t, r) {
            r.length && this.writeMessage(t, Ax, r)
          }
          writePackedFixed64(t, r) {
            r.length && this.writeMessage(t, kx, r)
          }
          writePackedSFixed64(t, r) {
            r.length && this.writeMessage(t, Ex, r)
          }
          writeBytesField(t, r) {
            this.writeTag(t, 2), this.writeBytes(r)
          }
          writeFixed32Field(t, r) {
            this.writeTag(t, 5), this.writeFixed32(r)
          }
          writeSFixed32Field(t, r) {
            this.writeTag(t, 5), this.writeSFixed32(r)
          }
          writeFixed64Field(t, r) {
            this.writeTag(t, 1), this.writeFixed64(r)
          }
          writeSFixed64Field(t, r) {
            this.writeTag(t, 1), this.writeSFixed64(r)
          }
          writeVarintField(t, r) {
            this.writeTag(t, 0), this.writeVarint(r)
          }
          writeSVarintField(t, r) {
            this.writeTag(t, 0), this.writeSVarint(r)
          }
          writeStringField(t, r) {
            this.writeTag(t, 2), this.writeString(r)
          }
          writeFloatField(t, r) {
            this.writeTag(t, 5), this.writeFloat(r)
          }
          writeDoubleField(t, r) {
            this.writeTag(t, 1), this.writeDouble(r)
          }
          writeBooleanField(t, r) {
            this.writeVarintField(t, +r)
          }
        }

        function oc(i, t, r) {
          return r ? 4294967296 * t + (i >>> 0) : 4294967296 * (t >>> 0) + (i >>> 0)
        }

        function o_(i, t, r) {
          const n = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (7 * Math.LN2));
          r.realloc(n);
          for (let l = r.pos - 1; l >= i; l--) r.buf[l + n] = r.buf[l]
        }

        function Tx(i, t) {
          for (let r = 0; r < i.length; r++) t.writeVarint(i[r])
        }

        function Sx(i, t) {
          for (let r = 0; r < i.length; r++) t.writeSVarint(i[r])
        }

        function Px(i, t) {
          for (let r = 0; r < i.length; r++) t.writeFloat(i[r])
        }

        function Mx(i, t) {
          for (let r = 0; r < i.length; r++) t.writeDouble(i[r])
        }

        function Ix(i, t) {
          for (let r = 0; r < i.length; r++) t.writeBoolean(i[r])
        }

        function Cx(i, t) {
          for (let r = 0; r < i.length; r++) t.writeFixed32(i[r])
        }

        function Ax(i, t) {
          for (let r = 0; r < i.length; r++) t.writeSFixed32(i[r])
        }

        function kx(i, t) {
          for (let r = 0; r < i.length; r++) t.writeFixed64(i[r])
        }

        function Ex(i, t) {
          for (let r = 0; r < i.length; r++) t.writeSFixed64(i[r])
        }

        function zx(i, t, r) {
          i === 1 && r.readMessage(Lx, t)
        }

        function Lx(i, t, r) {
          if (i === 3) {
            const {
              id: n,
              bitmap: l,
              width: p,
              height: f,
              left: _,
              top: x,
              advance: M
            } = r.readMessage(Dx, {});
            t.push({
              id: n,
              bitmap: new Cu({
                width: p + 6,
                height: f + 6
              }, l),
              metrics: {
                width: p,
                height: f,
                left: _,
                top: x,
                advance: M
              }
            })
          }
        }

        function Dx(i, t, r) {
          i === 1 ? t.id = r.readVarint() : i === 2 ? t.bitmap = r.readBytes() : i === 3 ? t.width = r.readVarint() : i === 4 ? t.height = r.readVarint() : i === 5 ? t.left = r.readSVarint() : i === 6 ? t.top = r.readSVarint() : i === 7 && (t.advance = r.readVarint())
        }

        function l_(i) {
          let t = 0,
            r = 0;
          for (const f of i) t += f.w * f.h, r = Math.max(r, f.w);
          i.sort(((f, _) => _.h - f.h));
          const n = [{
            x: 0,
            y: 0,
            w: Math.max(Math.ceil(Math.sqrt(t / .95)), r),
            h: 1 / 0
          }];
          let l = 0,
            p = 0;
          for (const f of i)
            for (let _ = n.length - 1; _ >= 0; _--) {
              const x = n[_];
              if (!(f.w > x.w || f.h > x.h)) {
                if (f.x = x.x, f.y = x.y, p = Math.max(p, f.y + f.h), l = Math.max(l, f.x + f.w), f.w === x.w && f.h === x.h) {
                  const M = n.pop();
                  M && _ < n.length && (n[_] = M)
                } else f.h === x.h ? (x.x += f.w, x.w -= f.w) : f.w === x.w ? (x.y += f.h, x.h -= f.h) : (n.push({
                  x: x.x + f.w,
                  y: x.y,
                  w: x.w - f.w,
                  h: f.h
                }), x.y += f.h, x.h -= f.h);
                break
              }
            }
          return {
            w: l,
            h: p,
            fill: t / (l * p) || 0
          }
        }
        class bf {
          constructor(t, {
            pixelRatio: r,
            version: n,
            stretchX: l,
            stretchY: p,
            content: f,
            textFitWidth: _,
            textFitHeight: x
          }) {
            this.paddedRect = t, this.pixelRatio = r, this.stretchX = l, this.stretchY = p, this.content = f, this.version = n, this.textFitWidth = _, this.textFitHeight = x
          }
          get tl() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1]
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1]
          }
          get tlbr() {
            return this.tl.concat(this.br)
          }
          get displaySize() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio]
          }
        }
        class c_ {
          constructor(t, r) {
            const n = {},
              l = {};
            this.haveRenderCallbacks = [];
            const p = [];
            this.addImages(t, n, p), this.addImages(r, l, p);
            const {
              w: f,
              h: _
            } = l_(p), x = new Tn({
              width: f || 1,
              height: _ || 1
            });
            for (const M in t) {
              const C = t[M],
                L = n[M].paddedRect;
              Tn.copy(C.data, x, {
                x: 0,
                y: 0
              }, {
                x: L.x + 1,
                y: L.y + 1
              }, C.data)
            }
            for (const M in r) {
              const C = r[M],
                L = l[M].paddedRect,
                O = L.x + 1,
                N = L.y + 1,
                G = C.data.width,
                K = C.data.height;
              Tn.copy(C.data, x, {
                x: 0,
                y: 0
              }, {
                x: O,
                y: N
              }, C.data), Tn.copy(C.data, x, {
                x: 0,
                y: K - 1
              }, {
                x: O,
                y: N - 1
              }, {
                width: G,
                height: 1
              }), Tn.copy(C.data, x, {
                x: 0,
                y: 0
              }, {
                x: O,
                y: N + K
              }, {
                width: G,
                height: 1
              }), Tn.copy(C.data, x, {
                x: G - 1,
                y: 0
              }, {
                x: O - 1,
                y: N
              }, {
                width: 1,
                height: K
              }), Tn.copy(C.data, x, {
                x: 0,
                y: 0
              }, {
                x: O + G,
                y: N
              }, {
                width: 1,
                height: K
              })
            }
            this.image = x, this.iconPositions = n, this.patternPositions = l
          }
          addImages(t, r, n) {
            for (const l in t) {
              const p = t[l],
                f = {
                  x: 0,
                  y: 0,
                  w: p.data.width + 2,
                  h: p.data.height + 2
                };
              n.push(f), r[l] = new bf(f, p), p.hasRenderCallback && this.haveRenderCallbacks.push(l)
            }
          }
          patchUpdatedImages(t, r) {
            t.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const n in t.updatedImages) this.patchUpdatedImage(this.iconPositions[n], t.getImage(n), r), this.patchUpdatedImage(this.patternPositions[n], t.getImage(n), r)
          }
          patchUpdatedImage(t, r, n) {
            if (!t || !r || t.version === r.version) return;
            t.version = r.version;
            const [l, p] = t.tl;
            n.update(r.data, void 0, {
              x: l,
              y: p
            })
          }
        }
        var ko;
        Mr("ImagePosition", bf), Mr("ImageAtlas", c_), T.as = void 0, (ko = T.as || (T.as = {}))[ko.none = 0] = "none", ko[ko.horizontal = 1] = "horizontal", ko[ko.vertical = 2] = "vertical", ko[ko.horizontalOnly = 3] = "horizontalOnly";
        class Ou {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom"
          }
          static forText(t, r, n) {
            const l = new Ou;
            return l.scale = t || 1, l.fontStack = r, l.verticalAlign = n || "bottom", l
          }
          static forImage(t, r) {
            const n = new Ou;
            return n.imageName = t, n.verticalAlign = r || "bottom", n
          }
        }
        class lc {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null
          }
          static fromFeature(t, r) {
            const n = new lc;
            for (let l = 0; l < t.sections.length; l++) {
              const p = t.sections[l];
              p.image ? n.addImageSection(p) : n.addTextSection(p, r)
            }
            return n
          }
          length() {
            return this.text.length
          }
          getSection(t) {
            return this.sections[this.sectionIndex[t]]
          }
          getSectionIndex(t) {
            return this.sectionIndex[t]
          }
          getCharCode(t) {
            return this.text.charCodeAt(t)
          }
          verticalizePunctuation() {
            this.text = (function(t) {
              let r = "";
              for (let n = 0; n < t.length; n++) {
                const l = t.charCodeAt(n + 1) || null,
                  p = t.charCodeAt(n - 1) || null;
                r += l && Wl(l) && !Bu[t[n + 1]] || p && Wl(p) && !Bu[t[n - 1]] || !Bu[t[n]] ? t[n] : Bu[t[n]]
              }
              return r
            })(this.text)
          }
          trim() {
            let t = 0;
            for (let n = 0; n < this.text.length && jd[this.text.charCodeAt(n)]; n++) t++;
            let r = this.text.length;
            for (let n = this.text.length - 1; n >= 0 && n >= t && jd[this.text.charCodeAt(n)]; n--) r--;
            this.text = this.text.substring(t, r), this.sectionIndex = this.sectionIndex.slice(t, r)
          }
          substring(t, r) {
            const n = new lc;
            return n.text = this.text.substring(t, r), n.sectionIndex = this.sectionIndex.slice(t, r), n.sections = this.sections, n
          }
          toString() {
            return this.text
          }
          getMaxScale() {
            return this.sectionIndex.reduce(((t, r) => Math.max(t, this.sections[r].scale)), 0)
          }
          getMaxImageSize(t) {
            let r = 0,
              n = 0;
            for (let l = 0; l < this.length(); l++) {
              const p = this.getSection(l);
              if (p.imageName) {
                const f = t[p.imageName];
                if (!f) continue;
                const _ = f.displaySize;
                r = Math.max(r, _[0]), n = Math.max(n, _[1])
              }
            }
            return {
              maxImageWidth: r,
              maxImageHeight: n
            }
          }
          addTextSection(t, r) {
            this.text += t.text, this.sections.push(Ou.forText(t.scale, t.fontStack || r, t.verticalAlign));
            const n = this.sections.length - 1;
            for (let l = 0; l < t.text.length; ++l) this.sectionIndex.push(n)
          }
          addImageSection(t) {
            const r = t.image ? t.image.name : "";
            if (r.length === 0) return void At("Can't add FormattedSection with an empty image.");
            const n = this.getNextImageSectionCharCode();
            n ? (this.text += String.fromCharCode(n), this.sections.push(Ou.forImage(r, t.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : At("Reached maximum number of images 6401")
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID)
          }
        }

        function Od(i, t, r, n, l, p, f, _, x, M, C, L, O, N, G) {
          const K = lc.fromFeature(i, l);
          let ie;
          L === T.as.vertical && K.verticalizePunctuation();
          const {
            processBidirectionalText: pe,
            processStyledBidirectionalText: Ne
          } = hs;
          if (pe && K.sections.length === 1) {
            ie = [];
            const at = pe(K.toString(), wf(K, M, p, t, n, N));
            for (const gt of at) {
              const Wt = new lc;
              Wt.text = gt, Wt.sections = K.sections;
              for (let xr = 0; xr < gt.length; xr++) Wt.sectionIndex.push(0);
              ie.push(Wt)
            }
          } else if (Ne) {
            ie = [];
            const at = Ne(K.text, K.sectionIndex, wf(K, M, p, t, n, N));
            for (const gt of at) {
              const Wt = new lc;
              Wt.text = gt[0], Wt.sectionIndex = gt[1], Wt.sections = K.sections, ie.push(Wt)
            }
          } else ie = (function(at, gt) {
            const Wt = [],
              xr = at.text;
            let hr = 0;
            for (const _r of gt) Wt.push(at.substring(hr, _r)), hr = _r;
            return hr < xr.length && Wt.push(at.substring(hr, xr.length)), Wt
          })(K, wf(K, M, p, t, n, N));
          const ye = [],
            ke = {
              positionedLines: ye,
              text: K.toString(),
              top: C[1],
              bottom: C[1],
              left: C[0],
              right: C[0],
              writingMode: L,
              iconsInText: !1,
              verticalizable: !1
            };
          return (function(at, gt, Wt, xr, hr, _r, Qr, gr, vr, zt, ci, pi) {
            let ai = 0,
              Hr = 0,
              Fi = 0,
              va = 0;
            const Ra = gr === "right" ? 1 : gr === "left" ? 0 : .5,
              on = Na / pi;
            let Hn = 0;
            for (const ma of hr) {
              ma.trim();
              const Ua = ma.getMaxScale(),
                Ja = {
                  positionedGlyphs: [],
                  lineOffset: 0
                };
              at.positionedLines[Hn] = Ja;
              const Qa = Ja.positionedGlyphs;
              let vn = 0;
              if (!ma.length()) {
                Hr += _r, ++Hn;
                continue
              }
              const $n = Ox(xr, ma, on);
              for (let Pn = 0; Pn < ma.length(); Pn++) {
                const Fa = ma.getSection(Pn),
                  Wa = ma.getSectionIndex(Pn),
                  Ha = ma.getCharCode(Pn),
                  Ea = jx(vr, ci, Ha);
                let aa;
                if (Fa.imageName) {
                  if (at.iconsInText = !0, Fa.scale = Fa.scale * on, aa = Vx(Fa, Ea, Ua, $n, xr), !aa) continue;
                  vn = Math.max(vn, aa.imageOffset)
                } else if (aa = qx(Fa, Ha, Ea, $n, gt, Wt), !aa) continue;
                const {
                  rect: gs,
                  metrics: dc,
                  baselineOffset: _s
                } = aa;
                Qa.push({
                  glyph: Ha,
                  imageName: Fa.imageName,
                  x: ai,
                  y: Hr + _s + -17,
                  vertical: Ea,
                  scale: Fa.scale,
                  fontStack: Fa.fontStack,
                  sectionIndex: Wa,
                  metrics: dc,
                  rect: gs
                }), Ea ? (at.verticalizable = !0, ai += (Fa.imageName ? dc.advance : Na) * Fa.scale + zt) : ai += dc.advance * Fa.scale + zt
              }
              Qa.length !== 0 && (Fi = Math.max(ai - zt, Fi), Zx(Qa, 0, Qa.length - 1, Ra)), ai = 0, Ja.lineOffset = Math.max(vn, (Ua - 1) * Na);
              const Ga = _r * Ua + vn;
              Hr += Ga, va = Math.max(Ga, va), ++Hn
            }
            const {
              horizontalAlign: Sn,
              verticalAlign: Ka
            } = Tf(Qr);
            (function(ma, Ua, Ja, Qa, vn, $n, Ga, Pn, Fa) {
              const Wa = (Ua - Ja) * vn;
              let Ha = 0;
              Ha = $n !== Ga ? -Pn * Qa - -17 : -Qa * Fa * Ga + .5 * Ga;
              for (const Ea of ma)
                for (const aa of Ea.positionedGlyphs) aa.x += Wa, aa.y += Ha
            })(at.positionedLines, Ra, Sn, Ka, Fi, va, _r, Hr, hr.length), at.top += -Ka * Hr, at.bottom = at.top + Hr, at.left += -Sn * Fi, at.right = at.left + Fi
          })(ke, t, r, n, ie, f, _, x, L, M, O, G), !(function(at) {
            for (const gt of at)
              if (gt.positionedGlyphs.length !== 0) return !1;
            return !0
          })(ye) && ke
        }
        const jd = {
            9: !0,
            10: !0,
            11: !0,
            12: !0,
            13: !0,
            32: !0
          },
          Rx = {
            10: !0,
            32: !0,
            38: !0,
            41: !0,
            43: !0,
            45: !0,
            47: !0,
            173: !0,
            183: !0,
            8203: !0,
            8208: !0,
            8211: !0,
            8231: !0
          },
          Fx = {
            40: !0
          };

        function u_(i, t, r, n, l, p) {
          if (t.imageName) {
            const f = n[t.imageName];
            return f ? f.displaySize[0] * t.scale * Na / p + l : 0
          } {
            const f = r[t.fontStack],
              _ = f && f[i];
            return _ ? _.metrics.advance * t.scale + l : 0
          }
        }

        function h_(i, t, r, n) {
          const l = Math.pow(i - t, 2);
          return n ? i < t ? l / 2 : 2 * l : l + Math.abs(r) * r
        }

        function Bx(i, t, r) {
          let n = 0;
          return i === 10 && (n -= 1e4), r && (n += 150), i !== 40 && i !== 65288 || (n += 50), t !== 41 && t !== 65289 || (n += 50), n
        }

        function d_(i, t, r, n, l, p) {
          let f = null,
            _ = h_(t, r, l, p);
          for (const x of n) {
            const M = h_(t - x.x, r, l, p) + x.badness;
            M <= _ && (f = x, _ = M)
          }
          return {
            index: i,
            x: t,
            priorBreak: f,
            badness: _
          }
        }

        function p_(i) {
          return i ? p_(i.priorBreak).concat(i.index) : []
        }

        function wf(i, t, r, n, l, p) {
          if (!i) return [];
          const f = [],
            _ = (function(L, O, N, G, K, ie) {
              let pe = 0;
              for (let Ne = 0; Ne < L.length(); Ne++) {
                const ye = L.getSection(Ne);
                pe += u_(L.getCharCode(Ne), ye, G, K, O, ie)
              }
              return pe / Math.max(1, Math.ceil(pe / N))
            })(i, t, r, n, l, p),
            x = i.text.indexOf("") >= 0;
          let M = 0;
          for (let L = 0; L < i.length(); L++) {
            const O = i.getSection(L),
              N = i.getCharCode(L);
            if (jd[N] || (M += u_(N, O, n, l, t, p)), L < i.length() - 1) {
              const G = !((C = N) < 11904) && (!!Di["CJK Compatibility Forms"](C) || !!Di["CJK Compatibility"](C) || !!Di["CJK Strokes"](C) || !!Di["CJK Symbols and Punctuation"](C) || !!Di["Enclosed CJK Letters and Months"](C) || !!Di["Halfwidth and Fullwidth Forms"](C) || !!Di["Ideographic Description Characters"](C) || !!Di["Vertical Forms"](C) || gu.test(String.fromCodePoint(C)));
              (Rx[N] || G || O.imageName || L !== i.length() - 2 && Fx[i.getCharCode(L + 1)]) && f.push(d_(L + 1, M, _, f, Bx(N, i.getCharCode(L + 1), G && x), !1))
            }
          }
          var C;
          return p_(d_(i.length(), M, _, f, 0, !0))
        }

        function Tf(i) {
          let t = .5,
            r = .5;
          switch (i) {
            case "right":
            case "top-right":
            case "bottom-right":
              t = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              t = 0
          }
          switch (i) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              r = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              r = 0
          }
          return {
            horizontalAlign: t,
            verticalAlign: r
          }
        }

        function Ox(i, t, r) {
          const n = t.getMaxScale() * Na,
            {
              maxImageWidth: l,
              maxImageHeight: p
            } = t.getMaxImageSize(i),
            f = Math.max(n, p * r);
          return {
            verticalLineContentWidth: Math.max(n, l * r),
            horizontalLineContentHeight: f
          }
        }

        function f_(i) {
          switch (i) {
            case "top":
              return 0;
            case "center":
              return .5;
            default:
              return 1
          }
        }

        function jx(i, t, r) {
          return !(i === T.as.horizontal || !t && !Gl(r) || t && (jd[r] || (n = r, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(n)))));
          var n
        }

        function qx(i, t, r, n, l, p) {
          const f = p[i.fontStack],
            _ = (function(M, C, L, O) {
              if (M && M.rect) return M;
              const N = C[L.fontStack],
                G = N && N[O];
              return G ? {
                rect: null,
                metrics: G.metrics
              } : null
            })(f && f[t], l, i, t);
          if (_ === null) return null;
          let x;
          if (r) x = n.verticalLineContentWidth - i.scale * Na;
          else {
            const M = f_(i.verticalAlign);
            x = (n.horizontalLineContentHeight - i.scale * Na) * M
          }
          return {
            rect: _.rect,
            metrics: _.metrics,
            baselineOffset: x
          }
        }

        function Vx(i, t, r, n, l) {
          const p = l[i.imageName];
          if (!p) return null;
          const f = p.paddedRect,
            _ = p.displaySize,
            x = {
              width: _[0],
              height: _[1],
              left: 1,
              top: -3,
              advance: t ? _[1] : _[0]
            };
          let M;
          if (t) M = n.verticalLineContentWidth - _[1] * i.scale;
          else {
            const C = f_(i.verticalAlign);
            M = (n.horizontalLineContentHeight - _[1] * i.scale) * C
          }
          return {
            rect: f,
            metrics: x,
            baselineOffset: M,
            imageOffset: (t ? _[0] : _[1]) * i.scale - Na * r
          }
        }

        function Zx(i, t, r, n) {
          if (n === 0) return;
          const l = i[r],
            p = (i[r].x + l.metrics.advance * l.scale) * n;
          for (let f = t; f <= r; f++) i[f].x -= p
        }

        function Nx(i, t, r) {
          const {
            horizontalAlign: n,
            verticalAlign: l
          } = Tf(r), p = t[0] - i.displaySize[0] * n, f = t[1] - i.displaySize[1] * l;
          return {
            image: i,
            top: f,
            bottom: f + i.displaySize[1],
            left: p,
            right: p + i.displaySize[0]
          }
        }

        function m_(i) {
          var t, r;
          let n = i.left,
            l = i.top,
            p = i.right - n,
            f = i.bottom - l;
          const _ = (t = i.image.textFitWidth) !== null && t !== void 0 ? t : "stretchOrShrink",
            x = (r = i.image.textFitHeight) !== null && r !== void 0 ? r : "stretchOrShrink",
            M = (i.image.content[2] - i.image.content[0]) / (i.image.content[3] - i.image.content[1]);
          if (x === "proportional") {
            if (_ === "stretchOnly" && p / f < M || _ === "proportional") {
              const C = Math.ceil(f * M);
              n *= C / p, p = C
            }
          } else if (_ === "proportional" && x === "stretchOnly" && M !== 0 && p / f > M) {
            const C = Math.ceil(p / M);
            l *= C / f, f = C
          }
          return {
            x1: n,
            y1: l,
            x2: n + p,
            y2: l + f
          }
        }

        function g_(i, t, r, n, l, p) {
          const f = i.image;
          let _;
          if (f.content) {
            const ie = f.content,
              pe = f.pixelRatio || 1;
            _ = [ie[0] / pe, ie[1] / pe, f.displaySize[0] - ie[2] / pe, f.displaySize[1] - ie[3] / pe]
          }
          const x = t.left * p,
            M = t.right * p;
          let C, L, O, N;
          r === "width" || r === "both" ? (N = l[0] + x - n[3], L = l[0] + M + n[1]) : (N = l[0] + (x + M - f.displaySize[0]) / 2, L = N + f.displaySize[0]);
          const G = t.top * p,
            K = t.bottom * p;
          return r === "height" || r === "both" ? (C = l[1] + G - n[0], O = l[1] + K + n[2]) : (C = l[1] + (G + K - f.displaySize[1]) / 2, O = C + f.displaySize[1]), {
            image: f,
            top: C,
            right: L,
            bottom: O,
            left: N,
            collisionPadding: _
          }
        }
        const ro = 128,
          Eo = 32640;

        function __(i, t) {
          const {
            expression: r
          } = t;
          if (r.kind === "constant") return {
            kind: "constant",
            layoutSize: r.evaluate(new Ji(i + 1))
          };
          if (r.kind === "source") return {
            kind: "source"
          };
          {
            const {
              zoomStops: n,
              interpolationType: l
            } = r;
            let p = 0;
            for (; p < n.length && n[p] <= i;) p++;
            p = Math.max(0, p - 1);
            let f = p;
            for (; f < n.length && n[f] < i + 1;) f++;
            f = Math.min(n.length - 1, f);
            const _ = n[p],
              x = n[f];
            return r.kind === "composite" ? {
              kind: "composite",
              minZoom: _,
              maxZoom: x,
              interpolationType: l
            } : {
              kind: "camera",
              minZoom: _,
              maxZoom: x,
              minSize: r.evaluate(new Ji(_)),
              maxSize: r.evaluate(new Ji(x)),
              interpolationType: l
            }
          }
        }

        function Sf(i, t, r) {
          let n = "never";
          const l = i.get(t);
          return l ? n = l : i.get(r) && (n = "always"), n
        }
        const Ux = [{
          name: "a_fade_opacity",
          components: 1,
          type: "Uint8",
          offset: 0
        }];

        function qd(i, t, r, n, l, p, f, _, x, M, C, L, O) {
          const N = _ ? Math.min(Eo, Math.round(_[0])) : 0,
            G = _ ? Math.min(Eo, Math.round(_[1])) : 0;
          i.emplaceBack(t, r, Math.round(32 * n), Math.round(32 * l), p, f, (N << 1) + (x ? 1 : 0), G, 16 * M, 16 * C, 256 * L, 256 * O)
        }

        function Pf(i, t, r) {
          i.emplaceBack(t.x, t.y, r), i.emplaceBack(t.x, t.y, r), i.emplaceBack(t.x, t.y, r), i.emplaceBack(t.x, t.y, r)
        }

        function Gx(i) {
          for (const t of i.sections)
            if (Qp(t.text)) return !0;
          return !1
        }
        class Mf {
          constructor(t) {
            this.layoutVertexArray = new it, this.indexArray = new Bt, this.programConfigurations = t, this.segments = new Ci, this.dynamicLayoutVertexArray = new st, this.opacityVertexArray = new ct, this.hasVisibleVertices = !1, this.placedSymbolArray = new A
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0
          }
          upload(t, r, n, l) {
            this.isEmpty() || (n && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, vx.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, r), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, yx.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, Ux, !0), this.opacityVertexBuffer.itemSize = 1), (n || l) && this.programConfigurations.upload(t))
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy())
          }
        }
        Mr("SymbolBuffers", Mf);
        class If {
          constructor(t, r, n) {
            this.layoutVertexArray = new t, this.layoutAttributes = r, this.indexArray = new n, this.segments = new Ci, this.collisionVertexArray = new lr
          }
          upload(t) {
            this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, xx.members, !0)
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy())
          }
        }
        Mr("CollisionBuffers", If);
        class cc {
          constructor(t) {
            this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = Ut(globalThis) ? Math.min(t.overscaling, 128) : t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((f => f.id)), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasDependencies = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [];
            const r = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = __(this.zoom, r["text-size"]), this.iconSizeData = __(this.zoom, r["icon-size"]);
            const n = this.layers[0].layout,
              l = n.get("symbol-sort-key"),
              p = n.get("symbol-z-order");
            this.canOverlap = Sf(n, "text-overlap", "text-allow-overlap") !== "never" || Sf(n, "icon-overlap", "icon-allow-overlap") !== "never" || n.get("text-ignore-placement") || n.get("icon-ignore-placement"), this.sortFeaturesByKey = p !== "viewport-y" && !l.isConstant(), this.sortFeaturesByY = (p === "viewport-y" || p === "auto" && !this.sortFeaturesByKey) && this.canOverlap, n.get("symbol-placement") === "point" && (this.writingModes = n.get("text-writing-mode").map((f => T.as[f]))), this.stateDependentLayerIds = this.layers.filter((f => f.isStateDependent())).map((f => f.id)), this.sourceID = t.sourceID
          }
          createArrays() {
            this.text = new Mf(new eo(this.layers, this.zoom, (t => /^text/.test(t)))), this.icon = new Mf(new eo(this.layers, this.zoom, (t => /^icon/.test(t)))), this.glyphOffsetArray = new R, this.lineVertexArray = new U, this.symbolInstances = new F, this.textAnchorOffsets = new se
          }
          calculateGlyphDependencies(t, r, n, l, p) {
            for (let f = 0; f < t.length; f++)
              if (r[t.charCodeAt(f)] = !0, (n || l) && p) {
                const _ = Bu[t.charAt(f)];
                _ && (r[_.charCodeAt(0)] = !0)
              }
          }
          populate(t, r, n) {
            const l = this.layers[0],
              p = l.layout,
              f = p.get("text-font"),
              _ = p.get("text-field"),
              x = p.get("icon-image"),
              M = (_.value.kind !== "constant" || _.value.value instanceof Ei && !_.value.value.isEmpty() || _.value.value.toString().length > 0) && (f.value.kind !== "constant" || f.value.value.length > 0),
              C = x.value.kind !== "constant" || !!x.value.value || Object.keys(x.parameters).length > 0,
              L = p.get("symbol-sort-key");
            if (this.features = [], !M && !C) return;
            const O = r.iconDependencies,
              N = r.glyphDependencies,
              G = r.availableImages,
              K = new Ji(this.zoom);
            for (const {
                feature: ie,
                id: pe,
                index: Ne,
                sourceLayerIndex: ye
              }
              of t) {
              const ke = l._featureFilter.needGeometry,
                at = Cs(ie, ke);
              if (!l._featureFilter.filter(K, at, n)) continue;
              let gt, Wt;
              if (ke || (at.geometry = ms(ie)), M) {
                const hr = l.getValueAndResolveTokens("text-field", at, n, G),
                  _r = Ei.factory(hr),
                  Qr = this.hasRTLText = this.hasRTLText || Gx(_r);
                (!Qr || hs.getRTLTextPluginStatus() === "unavailable" || Qr && hs.isParsed()) && (gt = wx(_r, l, at))
              }
              if (C) {
                const hr = l.getValueAndResolveTokens("icon-image", at, n, G);
                Wt = hr instanceof ra ? hr : ra.fromString(hr)
              }
              if (!gt && !Wt) continue;
              const xr = this.sortFeaturesByKey ? L.evaluate(at, {}, n) : void 0;
              if (this.features.push({
                  id: pe,
                  text: gt,
                  icon: Wt,
                  index: Ne,
                  sourceLayerIndex: ye,
                  geometry: at.geometry,
                  properties: ie.properties,
                  type: sc.types[ie.type],
                  sortKey: xr
                }), Wt && (O[Wt.name] = !0), gt) {
                const hr = f.evaluate(at, {}, n).join(","),
                  _r = p.get("text-rotation-alignment") !== "viewport" && p.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(T.as.vertical) >= 0;
                for (const Qr of gt.sections)
                  if (Qr.image) O[Qr.image.name] = !0;
                  else {
                    const gr = fu(gt.toString()),
                      vr = Qr.fontStack || hr,
                      zt = N[vr] = N[vr] || {};
                    this.calculateGlyphDependencies(Qr.text, zt, _r, this.allowVerticalPlacement, gr)
                  }
              }
            }
            p.get("symbol-placement") === "line" && (this.features = (function(ie) {
              const pe = {},
                Ne = {},
                ye = [];
              let ke = 0;

              function at(hr) {
                ye.push(ie[hr]), ke++
              }

              function gt(hr, _r, Qr) {
                const gr = Ne[hr];
                return delete Ne[hr], Ne[_r] = gr, ye[gr].geometry[0].pop(), ye[gr].geometry[0] = ye[gr].geometry[0].concat(Qr[0]), gr
              }

              function Wt(hr, _r, Qr) {
                const gr = pe[_r];
                return delete pe[_r], pe[hr] = gr, ye[gr].geometry[0].shift(), ye[gr].geometry[0] = Qr[0].concat(ye[gr].geometry[0]), gr
              }

              function xr(hr, _r, Qr) {
                const gr = Qr ? _r[0][_r[0].length - 1] : _r[0][0];
                return `${hr}:${gr.x}:${gr.y}`
              }
              for (let hr = 0; hr < ie.length; hr++) {
                const _r = ie[hr],
                  Qr = _r.geometry,
                  gr = _r.text ? _r.text.toString() : null;
                if (!gr) {
                  at(hr);
                  continue
                }
                const vr = xr(gr, Qr),
                  zt = xr(gr, Qr, !0);
                if (vr in Ne && zt in pe && Ne[vr] !== pe[zt]) {
                  const ci = Wt(vr, zt, Qr),
                    pi = gt(vr, zt, ye[ci].geometry);
                  delete pe[vr], delete Ne[zt], Ne[xr(gr, ye[pi].geometry, !0)] = pi, ye[ci].geometry = null
                } else vr in Ne ? gt(vr, zt, Qr) : zt in pe ? Wt(vr, zt, Qr) : (at(hr), pe[vr] = ke - 1, Ne[zt] = ke - 1)
              }
              return ye.filter((hr => hr.geometry))
            })(this.features)), this.sortFeaturesByKey && this.features.sort(((ie, pe) => ie.sortKey - pe.sortKey))
          }
          update(t, r, n) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, r, this.layers, {
              imagePositions: n
            }), this.icon.programConfigurations.updatePaintArrays(t, r, this.layers, {
              imagePositions: n
            }))
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload
          }
          upload(t) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy()
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData()
          }
          addToLineVertexArray(t, r) {
            const n = this.lineVertexArray.length;
            if (t.segment !== void 0) {
              let l = t.dist(r[t.segment + 1]),
                p = t.dist(r[t.segment]);
              const f = {};
              for (let _ = t.segment + 1; _ < r.length; _++) f[_] = {
                x: r[_].x,
                y: r[_].y,
                tileUnitDistanceFromAnchor: l
              }, _ < r.length - 1 && (l += r[_ + 1].dist(r[_]));
              for (let _ = t.segment || 0; _ >= 0; _--) f[_] = {
                x: r[_].x,
                y: r[_].y,
                tileUnitDistanceFromAnchor: p
              }, _ > 0 && (p += r[_ - 1].dist(r[_]));
              for (let _ = 0; _ < r.length; _++) {
                const x = f[_];
                this.lineVertexArray.emplaceBack(x.x, x.y, x.tileUnitDistanceFromAnchor)
              }
            }
            return {
              lineStartIndex: n,
              lineLength: this.lineVertexArray.length - n
            }
          }
          addSymbols(t, r, n, l, p, f, _, x, M, C, L, O) {
            const N = t.indexArray,
              G = t.layoutVertexArray,
              K = t.segments.prepareSegment(4 * r.length, G, N, this.canOverlap ? f.sortKey : void 0),
              ie = this.glyphOffsetArray.length,
              pe = K.vertexLength,
              Ne = this.allowVerticalPlacement && _ === T.as.vertical ? Math.PI / 2 : 0,
              ye = f.text && f.text.sections;
            for (let ke = 0; ke < r.length; ke++) {
              const {
                tl: at,
                tr: gt,
                bl: Wt,
                br: xr,
                tex: hr,
                pixelOffsetTL: _r,
                pixelOffsetBR: Qr,
                minFontScaleX: gr,
                minFontScaleY: vr,
                glyphOffset: zt,
                isSDF: ci,
                sectionIndex: pi
              } = r[ke], ai = K.vertexLength, Hr = zt[1];
              qd(G, x.x, x.y, at.x, Hr + at.y, hr.x, hr.y, n, ci, _r.x, _r.y, gr, vr), qd(G, x.x, x.y, gt.x, Hr + gt.y, hr.x + hr.w, hr.y, n, ci, Qr.x, _r.y, gr, vr), qd(G, x.x, x.y, Wt.x, Hr + Wt.y, hr.x, hr.y + hr.h, n, ci, _r.x, Qr.y, gr, vr), qd(G, x.x, x.y, xr.x, Hr + xr.y, hr.x + hr.w, hr.y + hr.h, n, ci, Qr.x, Qr.y, gr, vr), Pf(t.dynamicLayoutVertexArray, x, Ne), N.emplaceBack(ai, ai + 2, ai + 1), N.emplaceBack(ai + 1, ai + 2, ai + 3), K.vertexLength += 4, K.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(zt[0]), ke !== r.length - 1 && pi === r[ke + 1].sectionIndex || t.programConfigurations.populatePaintArrays(G.length, f, f.index, {
                imagePositions: {},
                canonical: O,
                formattedSection: ye && ye[pi]
              })
            }
            t.placedSymbolArray.emplaceBack(x.x, x.y, ie, this.glyphOffsetArray.length - ie, pe, M, C, x.segment, n ? n[0] : 0, n ? n[1] : 0, l[0], l[1], _, 0, !1, 0, L)
          }
          _addCollisionDebugVertex(t, r, n, l, p, f) {
            return r.emplaceBack(0, 0), t.emplaceBack(n.x, n.y, l, p, Math.round(f.x), Math.round(f.y))
          }
          addCollisionDebugVertices(t, r, n, l, p, f, _) {
            const x = p.segments.prepareSegment(4, p.layoutVertexArray, p.indexArray),
              M = x.vertexLength,
              C = p.layoutVertexArray,
              L = p.collisionVertexArray,
              O = _.anchorX,
              N = _.anchorY;
            this._addCollisionDebugVertex(C, L, f, O, N, new B(t, r)), this._addCollisionDebugVertex(C, L, f, O, N, new B(n, r)), this._addCollisionDebugVertex(C, L, f, O, N, new B(n, l)), this._addCollisionDebugVertex(C, L, f, O, N, new B(t, l)), x.vertexLength += 4;
            const G = p.indexArray;
            G.emplaceBack(M, M + 1), G.emplaceBack(M + 1, M + 2), G.emplaceBack(M + 2, M + 3), G.emplaceBack(M + 3, M), x.primitiveLength += 4
          }
          addDebugCollisionBoxes(t, r, n, l) {
            for (let p = t; p < r; p++) {
              const f = this.collisionBoxArray.get(p);
              this.addCollisionDebugVertices(f.x1, f.y1, f.x2, f.y2, l ? this.textCollisionBox : this.iconCollisionBox, f.anchorPoint, n)
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new If(nr, a_.members, qr), this.iconCollisionBox = new If(nr, a_.members, qr);
            for (let t = 0; t < this.symbolInstances.length; t++) {
              const r = this.symbolInstances.get(t);
              this.addDebugCollisionBoxes(r.textBoxStartIndex, r.textBoxEndIndex, r, !0), this.addDebugCollisionBoxes(r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r, !0), this.addDebugCollisionBoxes(r.iconBoxStartIndex, r.iconBoxEndIndex, r, !1), this.addDebugCollisionBoxes(r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex, r, !1)
            }
          }
          _deserializeCollisionBoxesForSymbol(t, r, n, l, p, f, _, x, M) {
            const C = {};
            for (let L = r; L < n; L++) {
              const O = t.get(L);
              C.textBox = {
                x1: O.x1,
                y1: O.y1,
                x2: O.x2,
                y2: O.y2,
                anchorPointX: O.anchorPointX,
                anchorPointY: O.anchorPointY
              }, C.textFeatureIndex = O.featureIndex;
              break
            }
            for (let L = l; L < p; L++) {
              const O = t.get(L);
              C.verticalTextBox = {
                x1: O.x1,
                y1: O.y1,
                x2: O.x2,
                y2: O.y2,
                anchorPointX: O.anchorPointX,
                anchorPointY: O.anchorPointY
              }, C.verticalTextFeatureIndex = O.featureIndex;
              break
            }
            for (let L = f; L < _; L++) {
              const O = t.get(L);
              C.iconBox = {
                x1: O.x1,
                y1: O.y1,
                x2: O.x2,
                y2: O.y2,
                anchorPointX: O.anchorPointX,
                anchorPointY: O.anchorPointY
              }, C.iconFeatureIndex = O.featureIndex;
              break
            }
            for (let L = x; L < M; L++) {
              const O = t.get(L);
              C.verticalIconBox = {
                x1: O.x1,
                y1: O.y1,
                x2: O.x2,
                y2: O.y2,
                anchorPointX: O.anchorPointX,
                anchorPointY: O.anchorPointY
              }, C.verticalIconFeatureIndex = O.featureIndex;
              break
            }
            return C
          }
          deserializeCollisionBoxes(t) {
            this.collisionArrays = [];
            for (let r = 0; r < this.symbolInstances.length; r++) {
              const n = this.symbolInstances.get(r);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, n.textBoxStartIndex, n.textBoxEndIndex, n.verticalTextBoxStartIndex, n.verticalTextBoxEndIndex, n.iconBoxStartIndex, n.iconBoxEndIndex, n.verticalIconBoxStartIndex, n.verticalIconBoxEndIndex))
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0
          }
          hasIconData() {
            return this.icon.segments.get().length > 0
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0
          }
          addIndicesForPlacedSymbol(t, r) {
            const n = t.placedSymbolArray.get(r),
              l = n.vertexStartIndex + 4 * n.numGlyphs;
            for (let p = n.vertexStartIndex; p < l; p += 4) t.indexArray.emplaceBack(p, p + 2, p + 1), t.indexArray.emplaceBack(p + 1, p + 2, p + 3)
          }
          getSortedSymbolIndexes(t) {
            if (this.sortedAngle === t && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
            const r = Math.sin(t),
              n = Math.cos(t),
              l = [],
              p = [],
              f = [];
            for (let _ = 0; _ < this.symbolInstances.length; ++_) {
              f.push(_);
              const x = this.symbolInstances.get(_);
              l.push(0 | Math.round(r * x.anchorX + n * x.anchorY)), p.push(x.featureIndex)
            }
            return f.sort(((_, x) => l[_] - l[x] || p[x] - p[_])), f
          }
          addToSortKeyRanges(t, r) {
            const n = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            n && n.sortKey === r ? n.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({
              sortKey: r,
              symbolInstanceStart: t,
              symbolInstanceEnd: t + 1
            })
          }
          sortFeatures(t) {
            if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const r of this.symbolInstanceIndexes) {
                const n = this.symbolInstances.get(r);
                this.featureSortOrder.push(n.featureIndex), [n.rightJustifiedTextSymbolIndex, n.centerJustifiedTextSymbolIndex, n.leftJustifiedTextSymbolIndex].forEach(((l, p, f) => {
                  l >= 0 && f.indexOf(l) === p && this.addIndicesForPlacedSymbol(this.text, l)
                })), n.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, n.verticalPlacedTextSymbolIndex), n.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, n.placedIconSymbolIndex), n.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, n.verticalPlacedIconSymbolIndex)
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray)
            }
          }
        }
        let v_, y_;
        Mr("SymbolBucket", cc, {
          omit: ["layers", "collisionBoxArray", "features", "compareText"]
        }), cc.MAX_GLYPHS = 65535, cc.addDynamicAttributes = Pf;
        var Cf = {
          get paint() {
            return y_ = y_ || new nn({
              "icon-opacity": new si(J.paint_symbol["icon-opacity"]),
              "icon-color": new si(J.paint_symbol["icon-color"]),
              "icon-halo-color": new si(J.paint_symbol["icon-halo-color"]),
              "icon-halo-width": new si(J.paint_symbol["icon-halo-width"]),
              "icon-halo-blur": new si(J.paint_symbol["icon-halo-blur"]),
              "icon-translate": new $r(J.paint_symbol["icon-translate"]),
              "icon-translate-anchor": new $r(J.paint_symbol["icon-translate-anchor"]),
              "text-opacity": new si(J.paint_symbol["text-opacity"]),
              "text-color": new si(J.paint_symbol["text-color"], {
                runtimeType: Tr,
                getOverride: i => i.textColor,
                hasOverride: i => !!i.textColor
              }),
              "text-halo-color": new si(J.paint_symbol["text-halo-color"]),
              "text-halo-width": new si(J.paint_symbol["text-halo-width"]),
              "text-halo-blur": new si(J.paint_symbol["text-halo-blur"]),
              "text-translate": new $r(J.paint_symbol["text-translate"]),
              "text-translate-anchor": new $r(J.paint_symbol["text-translate-anchor"])
            })
          },
          get layout() {
            return v_ = v_ || new nn({
              "symbol-placement": new $r(J.layout_symbol["symbol-placement"]),
              "symbol-spacing": new $r(J.layout_symbol["symbol-spacing"]),
              "symbol-avoid-edges": new $r(J.layout_symbol["symbol-avoid-edges"]),
              "symbol-sort-key": new si(J.layout_symbol["symbol-sort-key"]),
              "symbol-z-order": new $r(J.layout_symbol["symbol-z-order"]),
              "icon-allow-overlap": new $r(J.layout_symbol["icon-allow-overlap"]),
              "icon-overlap": new $r(J.layout_symbol["icon-overlap"]),
              "icon-ignore-placement": new $r(J.layout_symbol["icon-ignore-placement"]),
              "icon-optional": new $r(J.layout_symbol["icon-optional"]),
              "icon-rotation-alignment": new $r(J.layout_symbol["icon-rotation-alignment"]),
              "icon-size": new si(J.layout_symbol["icon-size"]),
              "icon-text-fit": new $r(J.layout_symbol["icon-text-fit"]),
              "icon-text-fit-padding": new $r(J.layout_symbol["icon-text-fit-padding"]),
              "icon-image": new si(J.layout_symbol["icon-image"]),
              "icon-rotate": new si(J.layout_symbol["icon-rotate"]),
              "icon-padding": new si(J.layout_symbol["icon-padding"]),
              "icon-keep-upright": new $r(J.layout_symbol["icon-keep-upright"]),
              "icon-offset": new si(J.layout_symbol["icon-offset"]),
              "icon-anchor": new si(J.layout_symbol["icon-anchor"]),
              "icon-pitch-alignment": new $r(J.layout_symbol["icon-pitch-alignment"]),
              "text-pitch-alignment": new $r(J.layout_symbol["text-pitch-alignment"]),
              "text-rotation-alignment": new $r(J.layout_symbol["text-rotation-alignment"]),
              "text-field": new si(J.layout_symbol["text-field"]),
              "text-font": new si(J.layout_symbol["text-font"]),
              "text-size": new si(J.layout_symbol["text-size"]),
              "text-max-width": new si(J.layout_symbol["text-max-width"]),
              "text-line-height": new $r(J.layout_symbol["text-line-height"]),
              "text-letter-spacing": new si(J.layout_symbol["text-letter-spacing"]),
              "text-justify": new si(J.layout_symbol["text-justify"]),
              "text-radial-offset": new si(J.layout_symbol["text-radial-offset"]),
              "text-variable-anchor": new $r(J.layout_symbol["text-variable-anchor"]),
              "text-variable-anchor-offset": new si(J.layout_symbol["text-variable-anchor-offset"]),
              "text-anchor": new si(J.layout_symbol["text-anchor"]),
              "text-max-angle": new $r(J.layout_symbol["text-max-angle"]),
              "text-writing-mode": new $r(J.layout_symbol["text-writing-mode"]),
              "text-rotate": new si(J.layout_symbol["text-rotate"]),
              "text-padding": new $r(J.layout_symbol["text-padding"]),
              "text-keep-upright": new $r(J.layout_symbol["text-keep-upright"]),
              "text-transform": new si(J.layout_symbol["text-transform"]),
              "text-offset": new si(J.layout_symbol["text-offset"]),
              "text-allow-overlap": new $r(J.layout_symbol["text-allow-overlap"]),
              "text-overlap": new $r(J.layout_symbol["text-overlap"]),
              "text-ignore-placement": new $r(J.layout_symbol["text-ignore-placement"]),
              "text-optional": new $r(J.layout_symbol["text-optional"])
            })
          }
        };
        class x_ {
          constructor(t) {
            if (t.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = t.property.overrides ? t.property.overrides.runtimeType : fr, this.defaultValue = t
          }
          evaluate(t) {
            if (t.formattedSection) {
              const r = this.defaultValue.property.overrides;
              if (r && r.hasOverride(t.formattedSection)) return r.getOverride(t.formattedSection)
            }
            return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default
          }
          eachChild(t) {
            this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression)
          }
          outputDefined() {
            return !1
          }
          serialize() {
            return null
          }
        }
        Mr("FormatSectionOverride", x_, {
          omit: ["defaultValue"]
        });
        class Vd extends Un {
          constructor(t, r) {
            super(t, Cf, r)
          }
          recalculate(t, r) {
            if (super.recalculate(t, r), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
              const n = this.layout.get("text-writing-mode");
              if (n) {
                const l = [];
                for (const p of n) l.indexOf(p) < 0 && l.push(p);
                this.layout._values["text-writing-mode"] = l
              } else this.layout._values["text-writing-mode"] = ["horizontal"]
            }
            this._setPaintOverrides()
          }
          getValueAndResolveTokens(t, r, n, l) {
            const p = this.layout.get(t).evaluate(r, {}, n, l),
              f = this._unevaluatedLayout._values[t];
            return f.isDataDriven() || Rl(f.value) || !p ? p : (function(_, x) {
              return x.replace(/{([^{}]+)}/g, ((M, C) => _ && C in _ ? String(_[C]) : ""))
            })(r.properties, p)
          }
          createBucket(t) {
            return new cc(t)
          }
          queryRadius() {
            return 0
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex")
          }
          _setPaintOverrides() {
            for (const t of Cf.paint.overridableProperties) {
              if (!Vd.hasPaintOverride(this.layout, t)) continue;
              const r = this.paint.get(t),
                n = new x_(r),
                l = new eu(n, r.property.specification);
              let p = null;
              p = r.value.kind === "constant" || r.value.kind === "source" ? new $o("source", l) : new tu("composite", l, r.value.zoomStops), this.paint._values[t] = new Nn(r.property, p, r.parameters)
            }
          }
          _handleOverridablePaintPropertyUpdate(t, r, n) {
            return !(!this.layout || r.isDataDriven() || n.isDataDriven()) && Vd.hasPaintOverride(this.layout, t)
          }
          static hasPaintOverride(t, r) {
            const n = t.get("text-field"),
              l = Cf.paint.properties[r];
            let p = !1;
            const f = _ => {
              for (const x of _)
                if (l.overrides && l.overrides.hasOverride(x)) return void(p = !0)
            };
            if (n.value.kind === "constant" && n.value.value instanceof Ei) f(n.value.value.sections);
            else if (n.value.kind === "source" || n.value.kind === "composite") {
              const _ = M => {
                  p || (M instanceof Pa && Ki(M.value) === bt ? f(M.value.sections) : M instanceof Sl ? f(M.sections) : M.eachChild(_))
                },
                x = n.value;
              x._styleExpression && _(x._styleExpression.expression)
            }
            return p
          }
        }
        let b_;
        var Wx = {
          get paint() {
            return b_ = b_ || new nn({
              "background-color": new $r(J.paint_background["background-color"]),
              "background-pattern": new Sd(J.paint_background["background-pattern"]),
              "background-opacity": new $r(J.paint_background["background-opacity"])
            })
          }
        };
        class Hx extends Un {
          constructor(t, r) {
            super(t, Wx, r)
          }
        }
        class $x extends Un {
          constructor(t, r) {
            super(t, {}, r), this.onAdd = n => {
              this.implementation.onAdd && this.implementation.onAdd(n, n.painter.context.gl)
            }, this.onRemove = n => {
              this.implementation.onRemove && this.implementation.onRemove(n, n.painter.context.gl)
            }, this.implementation = t
          }
          is3D() {
            return this.implementation.renderingMode === "3d"
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0
          }
          recalculate() {}
          updateTransitions() {}
          hasTransition() {
            return !1
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized")
          }
        }
        class Xx {
          constructor(t) {
            this._methodToThrottle = t, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel, this._channel.port2.onmessage = () => {
              this._triggered = !1, this._methodToThrottle()
            })
          }
          trigger() {
            this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout((() => {
              this._triggered = !1, this._methodToThrottle()
            }), 0))
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {}
          }
        }
        const Yx = {
            once: !0
          },
          Af = 63710088e-1;
        class zo {
          constructor(t, r) {
            if (isNaN(t) || isNaN(r)) throw new Error(`Invalid LngLat object: (${t}, ${r})`);
            if (this.lng = +t, this.lat = +r, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90")
          }
          wrap() {
            return new zo(or(this.lng, -180, 180), this.lat)
          }
          toArray() {
            return [this.lng, this.lat]
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`
          }
          distanceTo(t) {
            const r = Math.PI / 180,
              n = this.lat * r,
              l = t.lat * r,
              p = Math.sin(n) * Math.sin(l) + Math.cos(n) * Math.cos(l) * Math.cos((t.lng - this.lng) * r);
            return Af * Math.acos(Math.min(p, 1))
          }
          static convert(t) {
            if (t instanceof zo) return t;
            if (Array.isArray(t) && (t.length === 2 || t.length === 3)) return new zo(Number(t[0]), Number(t[1]));
            if (!Array.isArray(t) && typeof t == "object" && t !== null) return new zo(Number("lng" in t ? t.lng : t.lon), Number(t.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")
          }
        }
        const w_ = 2 * Math.PI * Af;

        function T_(i) {
          return w_ * Math.cos(i * Math.PI / 180)
        }

        function S_(i) {
          return (180 + i) / 360
        }

        function P_(i) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i * Math.PI / 360))) / 360
        }

        function M_(i, t) {
          return i / T_(t)
        }

        function I_(i) {
          return 360 * i - 180
        }

        function Zd(i) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * i) * Math.PI / 180)) - 90
        }

        function C_(i, t) {
          return i * T_(Zd(t))
        }
        class ju {
          constructor(t, r, n = 0) {
            this.x = +t, this.y = +r, this.z = +n
          }
          static fromLngLat(t, r = 0) {
            const n = zo.convert(t);
            return new ju(S_(n.lng), P_(n.lat), M_(r, n.lat))
          }
          toLngLat() {
            return new zo(I_(this.x), Zd(this.y))
          }
          toAltitude() {
            return C_(this.z, this.y)
          }
          meterInMercatorCoordinateUnits() {
            return 1 / w_ * (t = Zd(this.y), 1 / Math.cos(t * Math.PI / 180));
            var t
          }
        }

        function A_(i, t, r) {
          var n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);
          return [i * n - 2 * Math.PI * 6378137 / 2, t * n - 2 * Math.PI * 6378137 / 2]
        }
        class kf {
          constructor(t, r, n) {
            if (!(function(l, p, f) {
                return !(l < 0 || l > 25 || f < 0 || f >= Math.pow(2, l) || p < 0 || p >= Math.pow(2, l))
              })(t, r, n)) throw new Error(`x=${r}, y=${n}, z=${t} outside of bounds. 0<=x<${Math.pow(2,t)}, 0<=y<${Math.pow(2,t)} 0<=z<=25 `);
            this.z = t, this.x = r, this.y = n, this.key = uc(0, t, t, r, n)
          }
          equals(t) {
            return this.z === t.z && this.x === t.x && this.y === t.y
          }
          url(t, r, n) {
            const l = (f = this.y, _ = this.z, x = A_(256 * (p = this.x), 256 * (f = Math.pow(2, _) - f - 1), _), M = A_(256 * (p + 1), 256 * (f + 1), _), x[0] + "," + x[1] + "," + M[0] + "," + M[1]);
            var p, f, _, x, M;
            const C = (function(L, O, N) {
              let G, K = "";
              for (let ie = L; ie > 0; ie--) G = 1 << ie - 1, K += (O & G ? 1 : 0) + (N & G ? 2 : 0);
              return K
            })(this.z, this.x, this.y);
            return t[(this.x + this.y) % t.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(n === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, r > 1 ? "@2x" : "").replace(/{quadkey}/g, C).replace(/{bbox-epsg-3857}/g, l)
          }
          isChildOf(t) {
            const r = this.z - t.z;
            return r > 0 && t.x === this.x >> r && t.y === this.y >> r
          }
          getTilePoint(t) {
            const r = Math.pow(2, this.z);
            return new B((t.x * r - this.x) * ot, (t.y * r - this.y) * ot)
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`
          }
        }
        class k_ {
          constructor(t, r) {
            this.wrap = t, this.canonical = r, this.key = uc(t, r.z, r.z, r.x, r.y)
          }
        }
        class Wn {
          constructor(t, r, n, l, p) {
            if (this.terrainRttPosMatrix32f = null, t < n) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t}; z = ${n}`);
            this.overscaledZ = t, this.wrap = r, this.canonical = new kf(n, +l, +p), this.key = uc(r, t, n, l, p)
          }
          clone() {
            return new Wn(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          equals(t) {
            return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical)
          }
          scaledTo(t) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const r = this.canonical.z - t;
            return t > this.canonical.z ? new Wn(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Wn(t, this.wrap, t, this.canonical.x >> r, this.canonical.y >> r)
          }
          isOverscaled() {
            return this.overscaledZ > this.canonical.z
          }
          calculateScaledKey(t, r) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const n = this.canonical.z - t;
            return t > this.canonical.z ? uc(this.wrap * +r, t, this.canonical.z, this.canonical.x, this.canonical.y) : uc(this.wrap * +r, t, t, this.canonical.x >> n, this.canonical.y >> n)
          }
          isChildOf(t) {
            if (t.wrap !== this.wrap || this.overscaledZ - t.overscaledZ <= 0) return !1;
            if (t.overscaledZ === 0) return this.overscaledZ > 0;
            const r = this.canonical.z - t.canonical.z;
            return !(r < 0) && t.canonical.x === this.canonical.x >> r && t.canonical.y === this.canonical.y >> r
          }
          children(t) {
            if (this.overscaledZ >= t) return [new Wn(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const r = this.canonical.z + 1,
              n = 2 * this.canonical.x,
              l = 2 * this.canonical.y;
            return [new Wn(r, this.wrap, r, n, l), new Wn(r, this.wrap, r, n + 1, l), new Wn(r, this.wrap, r, n, l + 1), new Wn(r, this.wrap, r, n + 1, l + 1)]
          }
          isLessThan(t) {
            return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y))
          }
          wrapped() {
            return new Wn(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          unwrapTo(t) {
            return new Wn(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z)
          }
          toUnwrapped() {
            return new k_(this.wrap, this.canonical)
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`
          }
          getTilePoint(t) {
            return this.canonical.getTilePoint(new ju(t.x - this.wrap, t.y))
          }
        }

        function uc(i, t, r, n, l) {
          (i *= 2) < 0 && (i = -1 * i - 1);
          const p = 1 << r;
          return (p * p * i + p * l + n).toString(36) + r.toString(36) + t.toString(36)
        }

        function qu(i, t) {
          return t ? i.properties[t] : i.id
        }
        Mr("CanonicalTileID", kf), Mr("OverscaledTileID", Wn, {
          omit: ["terrainRttPosMatrix32f"]
        });
        class ll {
          constructor() {
            this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0
          }
          extend(t) {
            return this.minX = Math.min(this.minX, t.x), this.minY = Math.min(this.minY, t.y), this.maxX = Math.max(this.maxX, t.x), this.maxY = Math.max(this.maxY, t.y), this
          }
          expandBy(t) {
            return this.minX -= t, this.minY -= t, this.maxX += t, this.maxY += t, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0), this
          }
          shrinkBy(t) {
            return this.expandBy(-t)
          }
          map(t) {
            const r = new ll;
            return r.extend(t(new B(this.minX, this.minY))), r.extend(t(new B(this.maxX, this.minY))), r.extend(t(new B(this.minX, this.maxY))), r.extend(t(new B(this.maxX, this.maxY))), r
          }
          static fromPoints(t) {
            const r = new ll;
            for (const n of t) r.extend(n);
            return r
          }
          contains(t) {
            return t.x >= this.minX && t.x <= this.maxX && t.y >= this.minY && t.y <= this.maxY
          }
          empty() {
            return this.minX > this.maxX
          }
          width() {
            return this.maxX - this.minX
          }
          height() {
            return this.maxY - this.minY
          }
          covers(t) {
            return !this.empty() && !t.empty() && t.minX >= this.minX && t.maxX <= this.maxX && t.minY >= this.minY && t.maxY <= this.maxY
          }
          intersects(t) {
            return !this.empty() && !t.empty() && t.minX <= this.maxX && t.maxX >= this.minX && t.minY <= this.maxY && t.maxY >= this.minY
          }
        }
        class E_ {
          constructor(t) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let r = 0; r < t.length; r++) {
              const n = t[r];
              this._stringToNumber[n] = r, this._numberToString[r] = n
            }
          }
          encode(t) {
            return this._stringToNumber[t]
          }
          decode(t) {
            if (t >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[t]
          }
        }
        class z_ {
          constructor(t, r, n, l, p) {
            this.type = "Feature", this._vectorTileFeature = t, t._z = r, t._x = n, t._y = l, this.properties = t.properties, this.id = p
          }
          get geometry() {
            return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry
          }
          set geometry(t) {
            this._geometry = t
          }
          toJSON() {
            const t = {
              geometry: this.geometry
            };
            for (const r in this) r !== "_geometry" && r !== "_vectorTileFeature" && (t[r] = this[r]);
            return t
          }
        }
        class L_ {
          constructor(t, r) {
            this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new Ws(ot, 16, 0), this.grid3D = new Ws(ot, 16, 0), this.featureIndexArray = new ce, this.promoteId = r
          }
          insert(t, r, n, l, p, f) {
            const _ = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(n, l, p);
            const x = f ? this.grid3D : this.grid;
            for (let M = 0; M < r.length; M++) {
              const C = r[M],
                L = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let O = 0; O < C.length; O++) {
                const N = C[O];
                L[0] = Math.min(L[0], N.x), L[1] = Math.min(L[1], N.y), L[2] = Math.max(L[2], N.x), L[3] = Math.max(L[3], N.y)
              }
              L[0] < ot && L[1] < ot && L[2] >= 0 && L[3] >= 0 && x.insert(_, L[0], L[1], L[2], L[3])
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new Xg(new xf(this.rawTileData)).layers, this.sourceLayerCoder = new E_(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers
          }
          query(t, r, n, l) {
            this.loadVTLayers();
            const p = t.params,
              f = ot / t.tileSize / t.scale,
              _ = Xo(p.filter, p.globalState),
              x = t.queryGeometry,
              M = t.queryPadding * f,
              C = ll.fromPoints(x),
              L = this.grid.query(C.minX - M, C.minY - M, C.maxX + M, C.maxY + M),
              O = ll.fromPoints(t.cameraQueryGeometry).expandBy(M),
              N = this.grid3D.query(O.minX, O.minY, O.maxX, O.maxY, ((ie, pe, Ne, ye) => (function(ke, at, gt, Wt, xr) {
                for (const _r of ke)
                  if (at <= _r.x && gt <= _r.y && Wt >= _r.x && xr >= _r.y) return !0;
                const hr = [new B(at, gt), new B(at, xr), new B(Wt, xr), new B(Wt, gt)];
                if (ke.length > 2) {
                  for (const _r of hr)
                    if (tc(ke, _r)) return !0
                }
                for (let _r = 0; _r < ke.length - 1; _r++)
                  if (My(ke[_r], ke[_r + 1], hr)) return !0;
                return !1
              })(t.cameraQueryGeometry, ie - M, pe - M, Ne + M, ye + M)));
            for (const ie of N) L.push(ie);
            L.sort(Kx);
            const G = {};
            let K;
            for (let ie = 0; ie < L.length; ie++) {
              const pe = L[ie];
              if (pe === K) continue;
              K = pe;
              const Ne = this.featureIndexArray.get(pe);
              let ye = null;
              this.loadMatchingFeature(G, Ne.bucketIndex, Ne.sourceLayerIndex, Ne.featureIndex, _, p.layers, p.availableImages, r, n, l, ((ke, at, gt) => (ye || (ye = ms(ke)), at.queryIntersectsFeature({
                queryGeometry: x,
                feature: ke,
                featureState: gt,
                geometry: ye,
                zoom: this.z,
                transform: t.transform,
                pixelsToTileUnits: f,
                pixelPosMatrix: t.pixelPosMatrix,
                unwrappedTileID: this.tileID.toUnwrapped(),
                getElevation: t.getElevation
              }))))
            }
            return G
          }
          loadMatchingFeature(t, r, n, l, p, f, _, x, M, C, L) {
            const O = this.bucketLayerIDs[r];
            if (f && !O.some((ie => f.has(ie)))) return;
            const N = this.sourceLayerCoder.decode(n),
              G = this.vtLayers[N].feature(l);
            if (p.needGeometry) {
              const ie = Cs(G, !0);
              if (!p.filter(new Ji(this.tileID.overscaledZ), ie, this.tileID.canonical)) return
            } else if (!p.filter(new Ji(this.tileID.overscaledZ), G)) return;
            const K = this.getId(G, N);
            for (let ie = 0; ie < O.length; ie++) {
              const pe = O[ie];
              if (f && !f.has(pe)) continue;
              const Ne = x[pe];
              if (!Ne) continue;
              let ye = {};
              K && C && (ye = C.getState(Ne.sourceLayer || "_geojsonTileLayer", K));
              const ke = nt({}, M[pe]);
              ke.paint = D_(ke.paint, Ne.paint, G, ye, _), ke.layout = D_(ke.layout, Ne.layout, G, ye, _);
              const at = !L || L(G, Ne, ye);
              if (!at) continue;
              const gt = new z_(G, this.z, this.x, this.y, K);
              gt.layer = ke;
              let Wt = t[pe];
              Wt === void 0 && (Wt = t[pe] = []), Wt.push({
                featureIndex: l,
                feature: gt,
                intersectionZ: at
              })
            }
          }
          lookupSymbolFeatures(t, r, n, l, p, f, _, x) {
            const M = {};
            this.loadVTLayers();
            const C = Xo(p.filterSpec, p.globalState);
            for (const L of t) this.loadMatchingFeature(M, n, l, L, C, f, _, x, r);
            return M
          }
          hasLayer(t) {
            for (const r of this.bucketLayerIDs)
              for (const n of r)
                if (t === n) return !0;
            return !1
          }
          getId(t, r) {
            var n;
            let l = t.id;
            return this.promoteId && (l = t.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[r]], typeof l == "boolean" && (l = Number(l)), l === void 0 && (!((n = t.properties) === null || n === void 0) && n.cluster) && this.promoteId && (l = Number(t.properties.cluster_id))), l
          }
        }

        function D_(i, t, r, n, l) {
          return Zt(i, ((p, f) => {
            const _ = t instanceof Hs ? t.get(f) : null;
            return _ && _.evaluate ? _.evaluate(r, n, l) : _
          }))
        }

        function Kx(i, t) {
          return t - i
        }

        function R_(i, t, r, n, l) {
          const p = [];
          for (let f = 0; f < i.length; f++) {
            const _ = i[f];
            let x;
            for (let M = 0; M < _.length - 1; M++) {
              let C = _[M],
                L = _[M + 1];
              C.x < t && L.x < t || (C.x < t ? C = new B(t, C.y + (t - C.x) / (L.x - C.x) * (L.y - C.y))._round() : L.x < t && (L = new B(t, C.y + (t - C.x) / (L.x - C.x) * (L.y - C.y))._round()), C.y < r && L.y < r || (C.y < r ? C = new B(C.x + (r - C.y) / (L.y - C.y) * (L.x - C.x), r)._round() : L.y < r && (L = new B(C.x + (r - C.y) / (L.y - C.y) * (L.x - C.x), r)._round()), C.x >= n && L.x >= n || (C.x >= n ? C = new B(n, C.y + (n - C.x) / (L.x - C.x) * (L.y - C.y))._round() : L.x >= n && (L = new B(n, C.y + (n - C.x) / (L.x - C.x) * (L.y - C.y))._round()), C.y >= l && L.y >= l || (C.y >= l ? C = new B(C.x + (l - C.y) / (L.y - C.y) * (L.x - C.x), l)._round() : L.y >= l && (L = new B(C.x + (l - C.y) / (L.y - C.y) * (L.x - C.x), l)._round()), x && C.equals(x[x.length - 1]) || (x = [C], p.push(x)), x.push(L)))))
            }
          }
          return p
        }
        Mr("FeatureIndex", L_, {
          omit: ["rawTileData", "sourceLayerCoder"]
        });
        class Lo extends B {
          constructor(t, r, n, l) {
            super(t, r), this.angle = n, l !== void 0 && (this.segment = l)
          }
          clone() {
            return new Lo(this.x, this.y, this.angle, this.segment)
          }
        }

        function F_(i, t, r, n, l) {
          if (t.segment === void 0 || r === 0) return !0;
          let p = t,
            f = t.segment + 1,
            _ = 0;
          for (; _ > -r / 2;) {
            if (f--, f < 0) return !1;
            _ -= i[f].dist(p), p = i[f]
          }
          _ += i[f].dist(i[f + 1]), f++;
          const x = [];
          let M = 0;
          for (; _ < r / 2;) {
            const C = i[f],
              L = i[f + 1];
            if (!L) return !1;
            let O = i[f - 1].angleTo(C) - C.angleTo(L);
            for (O = Math.abs((O + 3 * Math.PI) % (2 * Math.PI) - Math.PI), x.push({
                distance: _,
                angleDelta: O
              }), M += O; _ - x[0].distance > n;) M -= x.shift().angleDelta;
            if (M > l) return !1;
            f++, _ += C.dist(L)
          }
          return !0
        }

        function B_(i) {
          let t = 0;
          for (let r = 0; r < i.length - 1; r++) t += i[r].dist(i[r + 1]);
          return t
        }

        function O_(i, t, r) {
          return i ? .6 * t * r : 0
        }

        function j_(i, t) {
          return Math.max(i ? i.right - i.left : 0, t ? t.right - t.left : 0)
        }

        function Jx(i, t, r, n, l, p) {
          const f = O_(r, l, p),
            _ = j_(r, n) * p;
          let x = 0;
          const M = B_(i) / 2;
          for (let C = 0; C < i.length - 1; C++) {
            const L = i[C],
              O = i[C + 1],
              N = L.dist(O);
            if (x + N > M) {
              const G = (M - x) / N,
                K = zn.number(L.x, O.x, G),
                ie = zn.number(L.y, O.y, G),
                pe = new Lo(K, ie, O.angleTo(L), C);
              return pe._round(), !f || F_(i, pe, _, f, t) ? pe : void 0
            }
            x += N
          }
        }

        function Qx(i, t, r, n, l, p, f, _, x) {
          const M = O_(n, p, f),
            C = j_(n, l),
            L = C * f,
            O = i[0].x === 0 || i[0].x === x || i[0].y === 0 || i[0].y === x;
          return t - L < t / 4 && (t = L + t / 4), q_(i, O ? t / 2 * _ % t : (C / 2 + 2 * p) * f * _ % t, t, M, r, L, O, !1, x)
        }

        function q_(i, t, r, n, l, p, f, _, x) {
          const M = p / 2,
            C = B_(i);
          let L = 0,
            O = t - r,
            N = [];
          for (let G = 0; G < i.length - 1; G++) {
            const K = i[G],
              ie = i[G + 1],
              pe = K.dist(ie),
              Ne = ie.angleTo(K);
            for (; O + r < L + pe;) {
              O += r;
              const ye = (O - L) / pe,
                ke = zn.number(K.x, ie.x, ye),
                at = zn.number(K.y, ie.y, ye);
              if (ke >= 0 && ke < x && at >= 0 && at < x && O - M >= 0 && O + M <= C) {
                const gt = new Lo(ke, at, Ne, G);
                gt._round(), n && !F_(i, gt, p, n, l) || N.push(gt)
              }
            }
            L += pe
          }
          return _ || N.length || f || (N = q_(i, L / 2, r, n, l, p, f, !0, x)), N
        }

        function V_(i, t, r, n) {
          const l = [],
            p = i.image,
            f = p.pixelRatio,
            _ = p.paddedRect.w - 2,
            x = p.paddedRect.h - 2;
          let M = {
            x1: i.left,
            y1: i.top,
            x2: i.right,
            y2: i.bottom
          };
          const C = p.stretchX || [
              [0, _]
            ],
            L = p.stretchY || [
              [0, x]
            ],
            O = (zt, ci) => zt + ci[1] - ci[0],
            N = C.reduce(O, 0),
            G = L.reduce(O, 0),
            K = _ - N,
            ie = x - G;
          let pe = 0,
            Ne = N,
            ye = 0,
            ke = G,
            at = 0,
            gt = K,
            Wt = 0,
            xr = ie;
          if (p.content && n) {
            const zt = p.content,
              ci = zt[2] - zt[0],
              pi = zt[3] - zt[1];
            (p.textFitWidth || p.textFitHeight) && (M = m_(i)), pe = Nd(C, 0, zt[0]), ye = Nd(L, 0, zt[1]), Ne = Nd(C, zt[0], zt[2]), ke = Nd(L, zt[1], zt[3]), at = zt[0] - pe, Wt = zt[1] - ye, gt = ci - Ne, xr = pi - ke
          }
          const hr = M.x1,
            _r = M.y1,
            Qr = M.x2 - hr,
            gr = M.y2 - _r,
            vr = (zt, ci, pi, ai) => {
              const Hr = Ud(zt.stretch - pe, Ne, Qr, hr),
                Fi = Gd(zt.fixed - at, gt, zt.stretch, N),
                va = Ud(ci.stretch - ye, ke, gr, _r),
                Ra = Gd(ci.fixed - Wt, xr, ci.stretch, G),
                on = Ud(pi.stretch - pe, Ne, Qr, hr),
                Hn = Gd(pi.fixed - at, gt, pi.stretch, N),
                Sn = Ud(ai.stretch - ye, ke, gr, _r),
                Ka = Gd(ai.fixed - Wt, xr, ai.stretch, G),
                ma = new B(Hr, va),
                Ua = new B(on, va),
                Ja = new B(on, Sn),
                Qa = new B(Hr, Sn),
                vn = new B(Fi / f, Ra / f),
                $n = new B(Hn / f, Ka / f),
                Ga = t * Math.PI / 180;
              if (Ga) {
                const Wa = Math.sin(Ga),
                  Ha = Math.cos(Ga),
                  Ea = [Ha, -Wa, Wa, Ha];
                ma._matMult(Ea), Ua._matMult(Ea), Qa._matMult(Ea), Ja._matMult(Ea)
              }
              const Pn = zt.stretch + zt.fixed,
                Fa = ci.stretch + ci.fixed;
              return {
                tl: ma,
                tr: Ua,
                bl: Qa,
                br: Ja,
                tex: {
                  x: p.paddedRect.x + 1 + Pn,
                  y: p.paddedRect.y + 1 + Fa,
                  w: pi.stretch + pi.fixed - Pn,
                  h: ai.stretch + ai.fixed - Fa
                },
                writingMode: void 0,
                glyphOffset: [0, 0],
                sectionIndex: 0,
                pixelOffsetTL: vn,
                pixelOffsetBR: $n,
                minFontScaleX: gt / f / Qr,
                minFontScaleY: xr / f / gr,
                isSDF: r
              }
            };
          if (n && (p.stretchX || p.stretchY)) {
            const zt = Z_(C, K, N),
              ci = Z_(L, ie, G);
            for (let pi = 0; pi < zt.length - 1; pi++) {
              const ai = zt[pi],
                Hr = zt[pi + 1];
              for (let Fi = 0; Fi < ci.length - 1; Fi++) l.push(vr(ai, ci[Fi], Hr, ci[Fi + 1]))
            }
          } else l.push(vr({
            fixed: 0,
            stretch: -1
          }, {
            fixed: 0,
            stretch: -1
          }, {
            fixed: 0,
            stretch: _ + 1
          }, {
            fixed: 0,
            stretch: x + 1
          }));
          return l
        }

        function Nd(i, t, r) {
          let n = 0;
          for (const l of i) n += Math.max(t, Math.min(r, l[1])) - Math.max(t, Math.min(r, l[0]));
          return n
        }

        function Z_(i, t, r) {
          const n = [{
            fixed: -1,
            stretch: 0
          }];
          for (const [l, p] of i) {
            const f = n[n.length - 1];
            n.push({
              fixed: l - f.stretch,
              stretch: f.stretch
            }), n.push({
              fixed: l - f.stretch,
              stretch: f.stretch + (p - l)
            })
          }
          return n.push({
            fixed: t + 1,
            stretch: r
          }), n
        }

        function Ud(i, t, r, n) {
          return i / t * r + n
        }

        function Gd(i, t, r, n) {
          return i - t * r / n
        }
        Mr("Anchor", Lo);
        class Wd {
          constructor(t, r, n, l, p, f, _, x, M, C) {
            var L;
            if (this.boxStartIndex = t.length, M) {
              let O = f.top,
                N = f.bottom;
              const G = f.collisionPadding;
              G && (O -= G[1], N += G[3]);
              let K = N - O;
              K > 0 && (K = Math.max(10, K), this.circleDiameter = K)
            } else {
              const O = !((L = f.image) === null || L === void 0) && L.content && (f.image.textFitWidth || f.image.textFitHeight) ? m_(f) : {
                x1: f.left,
                y1: f.top,
                x2: f.right,
                y2: f.bottom
              };
              O.y1 = O.y1 * _ - x[0], O.y2 = O.y2 * _ + x[2], O.x1 = O.x1 * _ - x[3], O.x2 = O.x2 * _ + x[1];
              const N = f.collisionPadding;
              if (N && (O.x1 -= N[0] * _, O.y1 -= N[1] * _, O.x2 += N[2] * _, O.y2 += N[3] * _), C) {
                const G = new B(O.x1, O.y1),
                  K = new B(O.x2, O.y1),
                  ie = new B(O.x1, O.y2),
                  pe = new B(O.x2, O.y2),
                  Ne = C * Math.PI / 180;
                G._rotate(Ne), K._rotate(Ne), ie._rotate(Ne), pe._rotate(Ne), O.x1 = Math.min(G.x, K.x, ie.x, pe.x), O.x2 = Math.max(G.x, K.x, ie.x, pe.x), O.y1 = Math.min(G.y, K.y, ie.y, pe.y), O.y2 = Math.max(G.y, K.y, ie.y, pe.y)
              }
              t.emplaceBack(r.x, r.y, O.x1, O.y1, O.x2, O.y2, n, l, p)
            }
            this.boxEndIndex = t.length
          }
        }
        class e1 {
          constructor(t = [], r = (n, l) => n < l ? -1 : n > l ? 1 : 0) {
            if (this.data = t, this.length = this.data.length, this.compare = r, this.length > 0)
              for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n)
          }
          push(t) {
            this.data.push(t), this._up(this.length++)
          }
          pop() {
            if (this.length === 0) return;
            const t = this.data[0],
              r = this.data.pop();
            return --this.length > 0 && (this.data[0] = r, this._down(0)), t
          }
          peek() {
            return this.data[0]
          }
          _up(t) {
            const {
              data: r,
              compare: n
            } = this, l = r[t];
            for (; t > 0;) {
              const p = t - 1 >> 1,
                f = r[p];
              if (n(l, f) >= 0) break;
              r[t] = f, t = p
            }
            r[t] = l
          }
          _down(t) {
            const {
              data: r,
              compare: n
            } = this, l = this.length >> 1, p = r[t];
            for (; t < l;) {
              let f = 1 + (t << 1);
              const _ = f + 1;
              if (_ < this.length && n(r[_], r[f]) < 0 && (f = _), n(r[f], p) >= 0) break;
              r[t] = r[f], t = f
            }
            r[t] = p
          }
        }

        function t1(i, t = 1, r = !1) {
          const n = ll.fromPoints(i[0]),
            l = Math.min(n.width(), n.height());
          let p = l / 2;
          const f = new e1([], r1),
            {
              minX: _,
              minY: x,
              maxX: M,
              maxY: C
            } = n;
          if (l === 0) return new B(_, x);
          for (let N = _; N < M; N += l)
            for (let G = x; G < C; G += l) f.push(new hc(N + p, G + p, p, i));
          let L = (function(N) {
              let G = 0,
                K = 0,
                ie = 0;
              const pe = N[0];
              for (let Ne = 0, ye = pe.length, ke = ye - 1; Ne < ye; ke = Ne++) {
                const at = pe[Ne],
                  gt = pe[ke],
                  Wt = at.x * gt.y - gt.x * at.y;
                K += (at.x + gt.x) * Wt, ie += (at.y + gt.y) * Wt, G += 3 * Wt
              }
              return new hc(K / G, ie / G, 0, N)
            })(i),
            O = f.length;
          for (; f.length;) {
            const N = f.pop();
            (N.d > L.d || !L.d) && (L = N, r && console.log("found best %d after %d probes", Math.round(1e4 * N.d) / 1e4, O)), N.max - L.d <= t || (p = N.h / 2, f.push(new hc(N.p.x - p, N.p.y - p, p, i)), f.push(new hc(N.p.x + p, N.p.y - p, p, i)), f.push(new hc(N.p.x - p, N.p.y + p, p, i)), f.push(new hc(N.p.x + p, N.p.y + p, p, i)), O += 4)
          }
          return r && (console.log(`num probes: ${O}`), console.log(`best distance: ${L.d}`)), L.p
        }

        function r1(i, t) {
          return t.max - i.max
        }

        function hc(i, t, r, n) {
          this.p = new B(i, t), this.h = r, this.d = (function(l, p) {
            let f = !1,
              _ = 1 / 0;
            for (let x = 0; x < p.length; x++) {
              const M = p[x];
              for (let C = 0, L = M.length, O = L - 1; C < L; O = C++) {
                const N = M[C],
                  G = M[O];
                N.y > l.y != G.y > l.y && l.x < (G.x - N.x) * (l.y - N.y) / (G.y - N.y) + N.x && (f = !f), _ = Math.min(_, Mg(l, N, G))
              }
            }
            return (f ? 1 : -1) * Math.sqrt(_)
          })(this.p, n), this.max = this.d + this.h * Math.SQRT2
        }
        var sn;
        T.aI = void 0, (sn = T.aI || (T.aI = {}))[sn.center = 1] = "center", sn[sn.left = 2] = "left", sn[sn.right = 3] = "right", sn[sn.top = 4] = "top", sn[sn.bottom = 5] = "bottom", sn[sn["top-left"] = 6] = "top-left", sn[sn["top-right"] = 7] = "top-right", sn[sn["bottom-left"] = 8] = "bottom-left", sn[sn["bottom-right"] = 9] = "bottom-right";
        const Ef = Number.POSITIVE_INFINITY;

        function N_(i, t) {
          return t[1] !== Ef ? (function(r, n, l) {
            let p = 0,
              f = 0;
            switch (n = Math.abs(n), l = Math.abs(l), r) {
              case "top-right":
              case "top-left":
              case "top":
                f = l - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                f = 7 - l
            }
            switch (r) {
              case "top-right":
              case "bottom-right":
              case "right":
                p = -n;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                p = n
            }
            return [p, f]
          })(i, t[0], t[1]) : (function(r, n) {
            let l = 0,
              p = 0;
            n < 0 && (n = 0);
            const f = n / Math.SQRT2;
            switch (r) {
              case "top-right":
              case "top-left":
                p = f - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                p = 7 - f;
                break;
              case "bottom":
                p = 7 - n;
                break;
              case "top":
                p = n - 7
            }
            switch (r) {
              case "top-right":
              case "bottom-right":
                l = -f;
                break;
              case "top-left":
              case "bottom-left":
                l = f;
                break;
              case "left":
                l = n;
                break;
              case "right":
                l = -n
            }
            return [l, p]
          })(i, t[0])
        }

        function U_(i, t, r) {
          var n;
          const l = i.layout,
            p = (n = l.get("text-variable-anchor-offset")) === null || n === void 0 ? void 0 : n.evaluate(t, {}, r);
          if (p) {
            const _ = p.values,
              x = [];
            for (let M = 0; M < _.length; M += 2) {
              const C = x[M] = _[M],
                L = _[M + 1].map((O => O * Na));
              C.startsWith("top") ? L[1] -= 7 : C.startsWith("bottom") && (L[1] += 7), x[M + 1] = L
            }
            return new Ui(x)
          }
          const f = l.get("text-variable-anchor");
          if (f) {
            let _;
            _ = i._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [l.get("text-radial-offset").evaluate(t, {}, r) * Na, Ef] : l.get("text-offset").evaluate(t, {}, r).map((M => M * Na));
            const x = [];
            for (const M of f) x.push(M, N_(M, _));
            return new Ui(x)
          }
          return null
        }

        function zf(i) {
          switch (i) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left"
          }
          return "center"
        }

        function i1(i, t, r, n, l, p, f, _, x, M, C, L) {
          let O = p.textMaxSize.evaluate(t, {});
          O === void 0 && (O = f);
          const N = i.layers[0].layout,
            G = N.get("icon-offset").evaluate(t, {}, C),
            K = W_(r.horizontal),
            ie = f / 24,
            pe = i.tilePixelRatio * ie,
            Ne = i.tilePixelRatio * O / 24,
            ye = i.tilePixelRatio * _,
            ke = i.tilePixelRatio * N.get("symbol-spacing"),
            at = N.get("text-padding") * i.tilePixelRatio,
            gt = (function(pi, ai, Hr, Fi = 1) {
              const va = pi.get("icon-padding").evaluate(ai, {}, Hr),
                Ra = va && va.values;
              return [Ra[0] * Fi, Ra[1] * Fi, Ra[2] * Fi, Ra[3] * Fi]
            })(N, t, C, i.tilePixelRatio),
            Wt = N.get("text-max-angle") / 180 * Math.PI,
            xr = N.get("text-rotation-alignment") !== "viewport" && N.get("symbol-placement") !== "point",
            hr = N.get("icon-rotation-alignment") === "map" && N.get("symbol-placement") !== "point",
            _r = N.get("symbol-placement"),
            Qr = ke / 2,
            gr = N.get("icon-text-fit");
          let vr;
          n && gr !== "none" && (i.allowVerticalPlacement && r.vertical && (vr = g_(n, r.vertical, gr, N.get("icon-text-fit-padding"), G, ie)), K && (n = g_(n, K, gr, N.get("icon-text-fit-padding"), G, ie)));
          const zt = C ? L.line.getGranularityForZoomLevel(C.z) : 1,
            ci = (pi, ai) => {
              ai.x < 0 || ai.x >= ot || ai.y < 0 || ai.y >= ot || (function(Hr, Fi, va, Ra, on, Hn, Sn, Ka, ma, Ua, Ja, Qa, vn, $n, Ga, Pn, Fa, Wa, Ha, Ea, aa, gs, dc, _s, s1) {
                const pc = Hr.addToLineVertexArray(Fi, va);
                let cl, fc, mc, gc, Y_ = 0,
                  K_ = 0,
                  J_ = 0,
                  Q_ = 0,
                  qf = -1,
                  Vf = -1;
                const io = {};
                let ev = ps("");
                if (Hr.allowVerticalPlacement && Ra.vertical) {
                  const dn = Ka.layout.get("text-rotate").evaluate(aa, {}, _s) + 90;
                  mc = new Wd(ma, Fi, Ua, Ja, Qa, Ra.vertical, vn, $n, Ga, dn), Sn && (gc = new Wd(ma, Fi, Ua, Ja, Qa, Sn, Fa, Wa, Ga, dn))
                }
                if (on) {
                  const dn = Ka.layout.get("icon-rotate").evaluate(aa, {}),
                    Xn = Ka.layout.get("icon-text-fit") !== "none",
                    ul = V_(on, dn, dc, Xn),
                    ys = Sn ? V_(Sn, dn, dc, Xn) : void 0;
                  fc = new Wd(ma, Fi, Ua, Ja, Qa, on, Fa, Wa, !1, dn), Y_ = 4 * ul.length;
                  const hl = Hr.iconSizeData;
                  let As = null;
                  hl.kind === "source" ? (As = [ro * Ka.layout.get("icon-size").evaluate(aa, {})], As[0] > Eo && At(`${Hr.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : hl.kind === "composite" && (As = [ro * gs.compositeIconSizes[0].evaluate(aa, {}, _s), ro * gs.compositeIconSizes[1].evaluate(aa, {}, _s)], (As[0] > Eo || As[1] > Eo) && At(`${Hr.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), Hr.addSymbols(Hr.icon, ul, As, Ea, Ha, aa, T.as.none, Fi, pc.lineStartIndex, pc.lineLength, -1, _s), qf = Hr.icon.placedSymbolArray.length - 1, ys && (K_ = 4 * ys.length, Hr.addSymbols(Hr.icon, ys, As, Ea, Ha, aa, T.as.vertical, Fi, pc.lineStartIndex, pc.lineLength, -1, _s), Vf = Hr.icon.placedSymbolArray.length - 1)
                }
                const tv = Object.keys(Ra.horizontal);
                for (const dn of tv) {
                  const Xn = Ra.horizontal[dn];
                  if (!cl) {
                    ev = ps(Xn.text);
                    const ys = Ka.layout.get("text-rotate").evaluate(aa, {}, _s);
                    cl = new Wd(ma, Fi, Ua, Ja, Qa, Xn, vn, $n, Ga, ys)
                  }
                  const ul = Xn.positionedLines.length === 1;
                  if (J_ += G_(Hr, Fi, Xn, Hn, Ka, Ga, aa, Pn, pc, Ra.vertical ? T.as.horizontal : T.as.horizontalOnly, ul ? tv : [dn], io, qf, gs, _s), ul) break
                }
                Ra.vertical && (Q_ += G_(Hr, Fi, Ra.vertical, Hn, Ka, Ga, aa, Pn, pc, T.as.vertical, ["vertical"], io, Vf, gs, _s));
                const o1 = cl ? cl.boxStartIndex : Hr.collisionBoxArray.length,
                  l1 = cl ? cl.boxEndIndex : Hr.collisionBoxArray.length,
                  c1 = mc ? mc.boxStartIndex : Hr.collisionBoxArray.length,
                  u1 = mc ? mc.boxEndIndex : Hr.collisionBoxArray.length,
                  h1 = fc ? fc.boxStartIndex : Hr.collisionBoxArray.length,
                  d1 = fc ? fc.boxEndIndex : Hr.collisionBoxArray.length,
                  p1 = gc ? gc.boxStartIndex : Hr.collisionBoxArray.length,
                  f1 = gc ? gc.boxEndIndex : Hr.collisionBoxArray.length;
                let vs = -1;
                const $d = (dn, Xn) => dn && dn.circleDiameter ? Math.max(dn.circleDiameter, Xn) : Xn;
                vs = $d(cl, vs), vs = $d(mc, vs), vs = $d(fc, vs), vs = $d(gc, vs);
                const rv = vs > -1 ? 1 : 0;
                rv && (vs *= s1 / Na), Hr.glyphOffsetArray.length >= cc.MAX_GLYPHS && At("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), aa.sortKey !== void 0 && Hr.addToSortKeyRanges(Hr.symbolInstances.length, aa.sortKey);
                const m1 = U_(Ka, aa, _s),
                  [g1, _1] = (function(dn, Xn) {
                    const ul = dn.length,
                      ys = Xn == null ? void 0 : Xn.values;
                    if ((ys == null ? void 0 : ys.length) > 0)
                      for (let hl = 0; hl < ys.length; hl += 2) {
                        const As = ys[hl + 1];
                        dn.emplaceBack(T.aI[ys[hl]], As[0], As[1])
                      }
                    return [ul, dn.length]
                  })(Hr.textAnchorOffsets, m1);
                Hr.symbolInstances.emplaceBack(Fi.x, Fi.y, io.right >= 0 ? io.right : -1, io.center >= 0 ? io.center : -1, io.left >= 0 ? io.left : -1, io.vertical || -1, qf, Vf, ev, o1, l1, c1, u1, h1, d1, p1, f1, Ua, J_, Q_, Y_, K_, rv, 0, vn, vs, g1, _1)
              })(i, ai, pi, r, n, l, vr, i.layers[0], i.collisionBoxArray, t.index, t.sourceLayerIndex, i.index, pe, [at, at, at, at], xr, x, ye, gt, hr, G, t, p, M, C, f)
            };
          if (_r === "line")
            for (const pi of R_(t.geometry, 0, 0, ot, ot)) {
              const ai = ol(pi, zt),
                Hr = Qx(ai, ke, Wt, r.vertical || K, n, 24, Ne, i.overscaling, ot);
              for (const Fi of Hr) K && a1(i, K.text, Qr, Fi) || ci(ai, Fi)
            } else if (_r === "line-center") {
              for (const pi of t.geometry)
                if (pi.length > 1) {
                  const ai = ol(pi, zt),
                    Hr = Jx(ai, Wt, r.vertical || K, n, 24, Ne);
                  Hr && ci(ai, Hr)
                }
            } else if (t.type === "Polygon")
            for (const pi of Pl(t.geometry, 0)) {
              const ai = t1(pi, 16);
              ci(ol(pi[0], zt, !0), new Lo(ai.x, ai.y, 0))
            } else if (t.type === "LineString")
              for (const pi of t.geometry) {
                const ai = ol(pi, zt);
                ci(ai, new Lo(ai[0].x, ai[0].y, 0))
              } else if (t.type === "Point")
                for (const pi of t.geometry)
                  for (const ai of pi) ci([ai], new Lo(ai.x, ai.y, 0))
        }

        function G_(i, t, r, n, l, p, f, _, x, M, C, L, O, N, G) {
          const K = (function(Ne, ye, ke, at, gt, Wt, xr, hr) {
              const _r = at.layout.get("text-rotate").evaluate(Wt, {}) * Math.PI / 180,
                Qr = [];
              for (const gr of ye.positionedLines)
                for (const vr of gr.positionedGlyphs) {
                  if (!vr.rect) continue;
                  const zt = vr.rect || {};
                  let ci = 4,
                    pi = !0,
                    ai = 1,
                    Hr = 0;
                  const Fi = (gt || hr) && vr.vertical,
                    va = vr.metrics.advance * vr.scale / 2;
                  if (hr && ye.verticalizable && (Hr = gr.lineOffset / 2 - (vr.imageName ? -(Na - vr.metrics.width * vr.scale) / 2 : (vr.scale - 1) * Na)), vr.imageName) {
                    const Wa = xr[vr.imageName];
                    pi = Wa.sdf, ai = Wa.pixelRatio, ci = 1 / ai
                  }
                  const Ra = gt ? [vr.x + va, vr.y] : [0, 0];
                  let on = gt ? [0, 0] : [vr.x + va + ke[0], vr.y + ke[1] - Hr],
                    Hn = [0, 0];
                  Fi && (Hn = on, on = [0, 0]);
                  const Sn = vr.metrics.isDoubleResolution ? 2 : 1,
                    Ka = (vr.metrics.left - ci) * vr.scale - va + on[0],
                    ma = (-vr.metrics.top - ci) * vr.scale + on[1],
                    Ua = Ka + zt.w / Sn * vr.scale / ai,
                    Ja = ma + zt.h / Sn * vr.scale / ai,
                    Qa = new B(Ka, ma),
                    vn = new B(Ua, ma),
                    $n = new B(Ka, Ja),
                    Ga = new B(Ua, Ja);
                  if (Fi) {
                    const Wa = new B(-va, va - -17),
                      Ha = -Math.PI / 2,
                      Ea = 12 - va,
                      aa = new B(22 - Ea, -(vr.imageName ? Ea : 0)),
                      gs = new B(...Hn);
                    Qa._rotateAround(Ha, Wa)._add(aa)._add(gs), vn._rotateAround(Ha, Wa)._add(aa)._add(gs), $n._rotateAround(Ha, Wa)._add(aa)._add(gs), Ga._rotateAround(Ha, Wa)._add(aa)._add(gs)
                  }
                  if (_r) {
                    const Wa = Math.sin(_r),
                      Ha = Math.cos(_r),
                      Ea = [Ha, -Wa, Wa, Ha];
                    Qa._matMult(Ea), vn._matMult(Ea), $n._matMult(Ea), Ga._matMult(Ea)
                  }
                  const Pn = new B(0, 0),
                    Fa = new B(0, 0);
                  Qr.push({
                    tl: Qa,
                    tr: vn,
                    bl: $n,
                    br: Ga,
                    tex: zt,
                    writingMode: ye.writingMode,
                    glyphOffset: Ra,
                    sectionIndex: vr.sectionIndex,
                    isSDF: pi,
                    pixelOffsetTL: Pn,
                    pixelOffsetBR: Fa,
                    minFontScaleX: 0,
                    minFontScaleY: 0
                  })
                }
              return Qr
            })(0, r, _, l, p, f, n, i.allowVerticalPlacement),
            ie = i.textSizeData;
          let pe = null;
          ie.kind === "source" ? (pe = [ro * l.layout.get("text-size").evaluate(f, {})], pe[0] > Eo && At(`${i.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : ie.kind === "composite" && (pe = [ro * N.compositeTextSizes[0].evaluate(f, {}, G), ro * N.compositeTextSizes[1].evaluate(f, {}, G)], (pe[0] > Eo || pe[1] > Eo) && At(`${i.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), i.addSymbols(i.text, K, pe, _, p, f, M, t, x.lineStartIndex, x.lineLength, O, G);
          for (const Ne of C) L[Ne] = i.text.placedSymbolArray.length - 1;
          return 4 * K.length
        }

        function W_(i) {
          for (const t in i) return i[t];
          return null
        }

        function a1(i, t, r, n) {
          const l = i.compareText;
          if (t in l) {
            const p = l[t];
            for (let f = p.length - 1; f >= 0; f--)
              if (n.dist(p[f]) < r) return !0
          } else l[t] = [];
          return l[t].push(n), !1
        }
        const H_ = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class Lf {
          static from(t) {
            if (!(t instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [r, n] = new Uint8Array(t, 0, 2);
            if (r !== 219) throw new Error("Data does not appear to be in a KDBush format.");
            const l = n >> 4;
            if (l !== 1) throw new Error(`Got v${l} data when expected v1.`);
            const p = H_[15 & n];
            if (!p) throw new Error("Unrecognized array type.");
            const [f] = new Uint16Array(t, 2, 1), [_] = new Uint32Array(t, 4, 1);
            return new Lf(_, f, p, t)
          }
          constructor(t, r = 64, n = Float64Array, l) {
            if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
            this.numItems = +t, this.nodeSize = Math.min(Math.max(+r, 2), 65535), this.ArrayType = n, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
            const p = H_.indexOf(this.ArrayType),
              f = 2 * t * this.ArrayType.BYTES_PER_ELEMENT,
              _ = t * this.IndexArrayType.BYTES_PER_ELEMENT,
              x = (8 - _ % 8) % 8;
            if (p < 0) throw new Error(`Unexpected typed array class: ${n}.`);
            l && l instanceof ArrayBuffer ? (this.data = l, this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + _ + x, 2 * t), this._pos = 2 * t, this._finished = !0) : (this.data = new ArrayBuffer(8 + f + _ + x), this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + _ + x, 2 * t), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + p]), new Uint16Array(this.data, 2, 1)[0] = r, new Uint32Array(this.data, 4, 1)[0] = t)
          }
          add(t, r) {
            const n = this._pos >> 1;
            return this.ids[n] = n, this.coords[this._pos++] = t, this.coords[this._pos++] = r, n
          }
          finish() {
            const t = this._pos >> 1;
            if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`);
            return Df(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this
          }
          range(t, r, n, l) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const {
              ids: p,
              coords: f,
              nodeSize: _
            } = this, x = [0, p.length - 1, 0], M = [];
            for (; x.length;) {
              const C = x.pop() || 0,
                L = x.pop() || 0,
                O = x.pop() || 0;
              if (L - O <= _) {
                for (let ie = O; ie <= L; ie++) {
                  const pe = f[2 * ie],
                    Ne = f[2 * ie + 1];
                  pe >= t && pe <= n && Ne >= r && Ne <= l && M.push(p[ie])
                }
                continue
              }
              const N = O + L >> 1,
                G = f[2 * N],
                K = f[2 * N + 1];
              G >= t && G <= n && K >= r && K <= l && M.push(p[N]), (C === 0 ? t <= G : r <= K) && (x.push(O), x.push(N - 1), x.push(1 - C)), (C === 0 ? n >= G : l >= K) && (x.push(N + 1), x.push(L), x.push(1 - C))
            }
            return M
          }
          within(t, r, n) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const {
              ids: l,
              coords: p,
              nodeSize: f
            } = this, _ = [0, l.length - 1, 0], x = [], M = n * n;
            for (; _.length;) {
              const C = _.pop() || 0,
                L = _.pop() || 0,
                O = _.pop() || 0;
              if (L - O <= f) {
                for (let ie = O; ie <= L; ie++) X_(p[2 * ie], p[2 * ie + 1], t, r) <= M && x.push(l[ie]);
                continue
              }
              const N = O + L >> 1,
                G = p[2 * N],
                K = p[2 * N + 1];
              X_(G, K, t, r) <= M && x.push(l[N]), (C === 0 ? t - n <= G : r - n <= K) && (_.push(O), _.push(N - 1), _.push(1 - C)), (C === 0 ? t + n >= G : r + n >= K) && (_.push(N + 1), _.push(L), _.push(1 - C))
            }
            return x
          }
        }

        function Df(i, t, r, n, l, p) {
          if (l - n <= r) return;
          const f = n + l >> 1;
          $_(i, t, f, n, l, p), Df(i, t, r, n, f - 1, 1 - p), Df(i, t, r, f + 1, l, 1 - p)
        }

        function $_(i, t, r, n, l, p) {
          for (; l > n;) {
            if (l - n > 600) {
              const M = l - n + 1,
                C = r - n + 1,
                L = Math.log(M),
                O = .5 * Math.exp(2 * L / 3),
                N = .5 * Math.sqrt(L * O * (M - O) / M) * (C - M / 2 < 0 ? -1 : 1);
              $_(i, t, r, Math.max(n, Math.floor(r - C * O / M + N)), Math.min(l, Math.floor(r + (M - C) * O / M + N)), p)
            }
            const f = t[2 * r + p];
            let _ = n,
              x = l;
            for (Vu(i, t, n, r), t[2 * l + p] > f && Vu(i, t, n, l); _ < x;) {
              for (Vu(i, t, _, x), _++, x--; t[2 * _ + p] < f;) _++;
              for (; t[2 * x + p] > f;) x--
            }
            t[2 * n + p] === f ? Vu(i, t, n, x) : (x++, Vu(i, t, x, l)), x <= r && (n = x + 1), r <= x && (l = x - 1)
          }
        }

        function Vu(i, t, r, n) {
          Rf(i, r, n), Rf(t, 2 * r, 2 * n), Rf(t, 2 * r + 1, 2 * n + 1)
        }

        function Rf(i, t, r) {
          const n = i[t];
          i[t] = i[r], i[r] = n
        }

        function X_(i, t, r, n) {
          const l = i - r,
            p = t - n;
          return l * l + p * p
        }
        var Ff;
        T.cA = void 0, (Ff = T.cA || (T.cA = {})).create = "create", Ff.load = "load", Ff.fullLoad = "fullLoad";
        let Hd = null,
          Zu = [];
        const Bf = 1e3 / 60,
          Of = "loadTime",
          jf = "fullLoadTime",
          n1 = {
            mark(i) {
              performance.mark(i)
            },
            frame(i) {
              const t = i;
              Hd != null && Zu.push(t - Hd), Hd = t
            },
            clearMetrics() {
              Hd = null, Zu = [], performance.clearMeasures(Of), performance.clearMeasures(jf);
              for (const i in T.cA) performance.clearMarks(T.cA[i])
            },
            getPerformanceMetrics() {
              performance.measure(Of, T.cA.create, T.cA.load), performance.measure(jf, T.cA.create, T.cA.fullLoad);
              const i = performance.getEntriesByName(Of)[0].duration,
                t = performance.getEntriesByName(jf)[0].duration,
                r = Zu.length,
                n = 1 / (Zu.reduce(((p, f) => p + f), 0) / r / 1e3),
                l = Zu.filter((p => p > Bf)).reduce(((p, f) => p + (f - Bf) / Bf), 0);
              return {
                loadTime: i,
                fullLoadTime: t,
                fps: n,
                percentDroppedFrames: l / (r + l) * 100,
                totalFrames: r
              }
            }
          };
        T.$ = br, T.A = xe, T.B = Po, T.C = function([i, t, r]) {
          return t += 90, t *= Math.PI / 180, r *= Math.PI / 180, {
            x: i * Math.cos(t) * Math.sin(r),
            y: i * Math.sin(t) * Math.sin(r),
            z: i * Math.cos(r)
          }
        }, T.D = $r, T.E = ae, T.F = zn, T.G = Ji, T.H = Qo, T.I = bf, T.J = Ut, T.K = class {
          constructor(i, t) {
            this.target = i, this.mapId = t, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new Xx((() => this.process())), this.subscription = wr(this.target, "message", (r => this.receive(r)), !1), this.globalScope = wt(self) ? i : window
          }
          registerMessageHandler(i, t) {
            this.messageHandlers[i] = t
          }
          sendAsync(i, t) {
            return new Promise(((r, n) => {
              const l = Math.round(1e18 * Math.random()).toString(36).substring(0, 10),
                p = t ? wr(t.signal, "abort", (() => {
                  p == null || p.unsubscribe(), delete this.resolveRejects[l];
                  const x = {
                    id: l,
                    type: "<cancel>",
                    origin: location.origin,
                    targetMapId: i.targetMapId,
                    sourceMapId: this.mapId
                  };
                  this.target.postMessage(x)
                }), Yx) : null;
              this.resolveRejects[l] = {
                resolve: x => {
                  p == null || p.unsubscribe(), r(x)
                },
                reject: x => {
                  p == null || p.unsubscribe(), n(x)
                }
              };
              const f = [],
                _ = Object.assign(Object.assign({}, i), {
                  id: l,
                  sourceMapId: this.mapId,
                  origin: location.origin,
                  data: us(i.data, f)
                });
              this.target.postMessage(_, {
                transfer: f
              })
            }))
          }
          receive(i) {
            const t = i.data,
              r = t.id;
            if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== "resource://android" && location.origin !== "resource://android" && t.origin !== location.origin || t.targetMapId && this.mapId !== t.targetMapId)) {
              if (t.type === "<cancel>") {
                delete this.tasks[r];
                const n = this.abortControllers[r];
                return delete this.abortControllers[r], void(n && n.abort())
              }
              if (wt(self) || t.mustQueue) return this.tasks[r] = t, this.taskQueue.push(r), void this.invoker.trigger();
              this.processTask(r, t)
            }
          }
          process() {
            if (this.taskQueue.length === 0) return;
            const i = this.taskQueue.shift(),
              t = this.tasks[i];
            delete this.tasks[i], this.taskQueue.length > 0 && this.invoker.trigger(), t && this.processTask(i, t)
          }
          processTask(i, t) {
            return s(this, void 0, void 0, (function*() {
              if (t.type === "<response>") {
                const l = this.resolveRejects[i];
                return delete this.resolveRejects[i], l ? void(t.error ? l.reject(el(t.error)) : l.resolve(el(t.data))) : void 0
              }
              if (!this.messageHandlers[t.type]) return void this.completeTask(i, new Error(`Could not find a registered handler for ${t.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const r = el(t.data),
                n = new AbortController;
              this.abortControllers[i] = n;
              try {
                const l = yield this.messageHandlers[t.type](t.sourceMapId, r, n);
                this.completeTask(i, null, l)
              } catch (l) {
                this.completeTask(i, l)
              }
            }))
          }
          completeTask(i, t, r) {
            const n = [];
            delete this.abortControllers[i];
            const l = {
              id: i,
              type: "<response>",
              sourceMapId: this.mapId,
              origin: location.origin,
              error: t ? us(t) : null,
              data: us(r, n)
            };
            this.target.postMessage(l, {
              transfer: n
            })
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe()
          }
        }, T.L = X, T.M = function() {
          var i = new xe(16);
          return xe != Float32Array && (i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0), i[0] = 1, i[5] = 1, i[10] = 1, i[15] = 1, i
        }, T.N = function(i, t, r) {
          var n, l, p, f, _, x, M, C, L, O, N, G, K = r[0],
            ie = r[1],
            pe = r[2];
          return t === i ? (i[12] = t[0] * K + t[4] * ie + t[8] * pe + t[12], i[13] = t[1] * K + t[5] * ie + t[9] * pe + t[13], i[14] = t[2] * K + t[6] * ie + t[10] * pe + t[14], i[15] = t[3] * K + t[7] * ie + t[11] * pe + t[15]) : (l = t[1], p = t[2], f = t[3], _ = t[4], x = t[5], M = t[6], C = t[7], L = t[8], O = t[9], N = t[10], G = t[11], i[0] = n = t[0], i[1] = l, i[2] = p, i[3] = f, i[4] = _, i[5] = x, i[6] = M, i[7] = C, i[8] = L, i[9] = O, i[10] = N, i[11] = G, i[12] = n * K + _ * ie + L * pe + t[12], i[13] = l * K + x * ie + O * pe + t[13], i[14] = p * K + M * ie + N * pe + t[14], i[15] = f * K + C * ie + G * pe + t[15]), i
        }, T.O = function(i, t, r) {
          var n = r[0],
            l = r[1],
            p = r[2];
          return i[0] = t[0] * n, i[1] = t[1] * n, i[2] = t[2] * n, i[3] = t[3] * n, i[4] = t[4] * l, i[5] = t[5] * l, i[6] = t[6] * l, i[7] = t[7] * l, i[8] = t[8] * p, i[9] = t[9] * p, i[10] = t[10] * p, i[11] = t[11] * p, i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15], i
        }, T.P = B, T.Q = function(i, t, r) {
          var n = t[0],
            l = t[1],
            p = t[2],
            f = t[3],
            _ = t[4],
            x = t[5],
            M = t[6],
            C = t[7],
            L = t[8],
            O = t[9],
            N = t[10],
            G = t[11],
            K = t[12],
            ie = t[13],
            pe = t[14],
            Ne = t[15],
            ye = r[0],
            ke = r[1],
            at = r[2],
            gt = r[3];
          return i[0] = ye * n + ke * _ + at * L + gt * K, i[1] = ye * l + ke * x + at * O + gt * ie, i[2] = ye * p + ke * M + at * N + gt * pe, i[3] = ye * f + ke * C + at * G + gt * Ne, i[4] = (ye = r[4]) * n + (ke = r[5]) * _ + (at = r[6]) * L + (gt = r[7]) * K, i[5] = ye * l + ke * x + at * O + gt * ie, i[6] = ye * p + ke * M + at * N + gt * pe, i[7] = ye * f + ke * C + at * G + gt * Ne, i[8] = (ye = r[8]) * n + (ke = r[9]) * _ + (at = r[10]) * L + (gt = r[11]) * K, i[9] = ye * l + ke * x + at * O + gt * ie, i[10] = ye * p + ke * M + at * N + gt * pe, i[11] = ye * f + ke * C + at * G + gt * Ne, i[12] = (ye = r[12]) * n + (ke = r[13]) * _ + (at = r[14]) * L + (gt = r[15]) * K, i[13] = ye * l + ke * x + at * O + gt * ie, i[14] = ye * p + ke * M + at * N + gt * pe, i[15] = ye * f + ke * C + at * G + gt * Ne, i
        }, T.R = Tn, T.S = function(i, t) {
          const r = {};
          for (let n = 0; n < t.length; n++) {
            const l = t[n];
            l in i && (r[l] = i[l])
          }
          return r
        }, T.T = hf, T.U = zo, T.V = or, T.W = P_, T.X = S_, T.Y = Ie, T.Z = we, T._ = s, T.a = j, T.a$ = function(i, t, r) {
          return i[0] = t[0] * r[0], i[1] = t[1] * r[1], i[2] = t[2] * r[2], i[3] = t[3] * r[3], i
        }, T.a0 = Wn, T.a1 = I_, T.a2 = Zd, T.a3 = ot, T.a4 = function(i, t) {
          var r, n, l, p, f;
          if (!i) return t ?? {};
          if (!t) return i;
          let _ = Object.assign({}, i);
          if (t.removeAll && (_ = {
              removeAll: !0
            }), t.remove) {
            const x = new Set(t.remove);
            _.add && (_.add = _.add.filter((C => !x.has(C.id)))), _.update && (_.update = _.update.filter((C => !x.has(C.id))));
            const M = new Set(((r = i.add) !== null && r !== void 0 ? r : []).map((C => C.id)));
            t.remove = t.remove.filter((C => !M.has(C)))
          }
          if (t.remove) {
            const x = new Set(_.remove ? _.remove.concat(t.remove) : t.remove);
            _.remove = Array.from(x.values())
          }
          if (t.add) {
            const x = _.add ? _.add.concat(t.add) : t.add,
              M = new Map(x.map((C => [C.id, C])));
            _.add = Array.from(M.values())
          }
          if (t.update) {
            const x = new Map((n = _.update) === null || n === void 0 ? void 0 : n.map((M => [M.id, M])));
            for (const M of t.update) {
              const C = (l = x.get(M.id)) !== null && l !== void 0 ? l : {
                id: M.id
              };
              M.newGeometry && (C.newGeometry = M.newGeometry), M.addOrUpdateProperties && (C.addOrUpdateProperties = ((p = C.addOrUpdateProperties) !== null && p !== void 0 ? p : []).concat(M.addOrUpdateProperties)), M.removeProperties && (C.removeProperties = ((f = C.removeProperties) !== null && f !== void 0 ? f : []).concat(M.removeProperties)), M.removeAllProperties && (C.removeAllProperties = !0), x.set(M.id, C)
            }
            _.update = Array.from(x.values())
          }
          return _.remove && _.add && (_.remove = _.remove.filter((x => _.add.findIndex((M => M.id === x)) === -1))), _
        }, T.a5 = ju, T.a6 = ll, T.a7 = 25, T.a8 = kf, T.a9 = i => {
          const t = window.document.createElement("video");
          return t.muted = !0, new Promise((r => {
            t.onloadstart = () => {
              r(t)
            };
            for (const n of i) {
              const l = window.document.createElement("source");
              Te(n) || (t.crossOrigin = "Anonymous"), l.src = n, t.appendChild(l)
            }
          }))
        }, T.aA = Ge, T.aB = function(i, t, r, n) {
          const l = t.y - i.y,
            p = t.x - i.x,
            f = n.y - r.y,
            _ = n.x - r.x,
            x = f * p - _ * l;
          if (x === 0) return null;
          const M = (_ * (i.y - r.y) - f * (i.x - r.x)) / x;
          return new B(i.x + M * p, i.y + M * l)
        }, T.aC = R_, T.aD = Sg, T.aE = function(i) {
          let t = 1 / 0,
            r = 1 / 0,
            n = -1 / 0,
            l = -1 / 0;
          for (const p of i) t = Math.min(t, p.x), r = Math.min(r, p.y), n = Math.max(n, p.x), l = Math.max(l, p.y);
          return [t, r, n, l]
        }, T.aF = Na, T.aG = Ht, T.aH = function(i, t, r, n, l = !1) {
          if (!r[0] && !r[1]) return [0, 0];
          const p = l ? n === "map" ? -i.bearingInRadians : 0 : n === "viewport" ? i.bearingInRadians : 0;
          if (p) {
            const f = Math.sin(p),
              _ = Math.cos(p);
            r = [r[0] * _ - r[1] * f, r[0] * f + r[1] * _]
          }
          return [l ? r[0] : Ht(t, r[0], i.zoom), l ? r[1] : Ht(t, r[1], i.zoom)]
        }, T.aJ = Sf, T.aK = zf, T.aL = Tf, T.aM = Lf, T.aN = xa, T.aO = Fd, T.aP = ge, T.aQ = Ci, T.aR = Bt, T.aS = Gr, T.aT = C_, T.aU = Le, T.aV = Ye, T.aW = function(i) {
          var t = new xe(3);
          return t[0] = i[0], t[1] = i[1], t[2] = i[2], t
        }, T.aX = function(i, t, r) {
          return i[0] = t[0] - r[0], i[1] = t[1] - r[1], i[2] = t[2] - r[2], i
        }, T.aY = function(i, t) {
          var r = t[0],
            n = t[1],
            l = t[2],
            p = r * r + n * n + l * l;
          return p > 0 && (p = 1 / Math.sqrt(p)), i[0] = t[0] * p, i[1] = t[1] * p, i[2] = t[2] * p, i
        }, T.aZ = qe, T.a_ = function(i, t) {
          return i[0] * t[0] + i[1] * t[1] + i[2] * t[2]
        }, T.aa = je, T.ab = function() {
          return rt++
        }, T.ac = w, T.ad = cc, T.ae = Xo, T.af = Cs, T.ag = z_, T.ah = function(i) {
          const t = {};
          if (i.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((r, n, l, p) => {
              const f = l || p;
              return t[n] = !f || f.toLowerCase(), ""
            })), t["max-age"]) {
            const r = parseInt(t["max-age"], 10);
            isNaN(r) ? delete t["max-age"] : t["max-age"] = r
          }
          return t
        }, T.ai = Xt, T.aj = 85.051129, T.ak = Nr, T.al = function(i) {
          return Math.pow(2, i)
        }, T.am = et, T.an = M_, T.ao = function(i) {
          return Math.log(i) / Math.LN2
        }, T.ap = function(i) {
          var t = i[0],
            r = i[1];
          return t * t + r * r
        }, T.aq = function(i) {
          if (!i.length) return new Set;
          const t = Math.max(...i.map((x => x.canonical.z)));
          let r = 1 / 0,
            n = -1 / 0,
            l = 1 / 0,
            p = -1 / 0;
          const f = [];
          for (const x of i) {
            const {
              x: M,
              y: C,
              z: L
            } = x.canonical, O = Math.pow(2, t - L), N = M * O, G = C * O;
            f.push({
              id: x,
              x: N,
              y: G
            }), N < r && (r = N), N > n && (n = N), G < l && (l = G), G > p && (p = G)
          }
          const _ = new Set;
          for (const x of f) x.x !== r && x.x !== n && x.y !== l && x.y !== p || _.add(x.id);
          return _
        }, T.ar = function(i, t) {
          let r = 0,
            n = 0;
          if (i.kind === "constant") n = i.layoutSize;
          else if (i.kind !== "source") {
            const {
              interpolationType: l,
              minZoom: p,
              maxZoom: f
            } = i, _ = l ? Xt(Gi.interpolationFactor(l, t, p, f), 0, 1) : 0;
            i.kind === "camera" ? n = zn.number(i.minSize, i.maxSize, _) : r = _
          }
          return {
            uSizeT: r,
            uSize: n
          }
        }, T.at = function(i, {
          uSize: t,
          uSizeT: r
        }, {
          lowerSize: n,
          upperSize: l
        }) {
          return i.kind === "source" ? n / ro : i.kind === "composite" ? zn.number(n / ro, l / ro, r) : t
        }, T.au = function(i, t) {
          var r = t[0],
            n = t[1],
            l = t[2],
            p = t[3],
            f = t[4],
            _ = t[5],
            x = t[6],
            M = t[7],
            C = t[8],
            L = t[9],
            O = t[10],
            N = t[11],
            G = t[12],
            K = t[13],
            ie = t[14],
            pe = t[15],
            Ne = r * _ - n * f,
            ye = r * x - l * f,
            ke = r * M - p * f,
            at = n * x - l * _,
            gt = n * M - p * _,
            Wt = l * M - p * x,
            xr = C * K - L * G,
            hr = C * ie - O * G,
            _r = C * pe - N * G,
            Qr = L * ie - O * K,
            gr = L * pe - N * K,
            vr = O * pe - N * ie,
            zt = Ne * vr - ye * gr + ke * Qr + at * _r - gt * hr + Wt * xr;
          return zt ? (i[0] = (_ * vr - x * gr + M * Qr) * (zt = 1 / zt), i[1] = (l * gr - n * vr - p * Qr) * zt, i[2] = (K * Wt - ie * gt + pe * at) * zt, i[3] = (O * gt - L * Wt - N * at) * zt, i[4] = (x * _r - f * vr - M * hr) * zt, i[5] = (r * vr - l * _r + p * hr) * zt, i[6] = (ie * ke - G * Wt - pe * ye) * zt, i[7] = (C * Wt - O * ke + N * ye) * zt, i[8] = (f * gr - _ * _r + M * xr) * zt, i[9] = (n * _r - r * gr - p * xr) * zt, i[10] = (G * gt - K * ke + pe * Ne) * zt, i[11] = (L * ke - C * gt - N * Ne) * zt, i[12] = (_ * hr - f * Qr - x * xr) * zt, i[13] = (r * Qr - n * hr + l * xr) * zt, i[14] = (K * ye - G * at - ie * Ne) * zt, i[15] = (C * at - L * ye + O * Ne) * zt, i) : null
        }, T.av = Et, T.aw = function(i) {
          var t = i[0],
            r = i[1];
          return Math.sqrt(t * t + r * r)
        }, T.ax = function(i) {
          return i[0] = 0, i[1] = 0, i
        }, T.ay = function(i, t, r) {
          return i[0] = t[0] * r, i[1] = t[1] * r, i
        }, T.az = Pf, T.b = ut, T.b$ = function(i, t, r) {
          var n = t[0],
            l = t[1],
            p = t[2];
          return i[0] = n * r[0] + l * r[3] + p * r[6], i[1] = n * r[1] + l * r[4] + p * r[7], i[2] = n * r[2] + l * r[5] + p * r[8], i
        }, T.b0 = Ae, T.b1 = function(i, t, r) {
          const n = t[0] * r[0] + t[1] * r[1] + t[2] * r[2];
          return n === 0 ? null : (-(i[0] * r[0] + i[1] * r[1] + i[2] * r[2]) - r[3]) / n
        }, T.b2 = Qe, T.b3 = function(i, t, r) {
          return i[0] = t[0] * r, i[1] = t[1] * r, i[2] = t[2] * r, i[3] = t[3] * r, i
        }, T.b4 = function(i, t) {
          return i[0] * t[0] + i[1] * t[1] + i[2] * t[2] + i[3]
        }, T.b5 = k_, T.b6 = uc, T.b7 = function(i, t, r, n, l) {
          var p = 1 / Math.tan(t / 2);
          if (i[0] = p / r, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = p, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = -1, i[12] = 0, i[13] = 0, i[15] = 0, l != null && l !== 1 / 0) {
            var f = 1 / (n - l);
            i[10] = (l + n) * f, i[14] = 2 * l * n * f
          } else i[10] = -1, i[14] = -2 * n;
          return i
        }, T.b8 = function(i) {
          var t = new xe(16);
          return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], t
        }, T.b9 = function(i, t, r) {
          var n = Math.sin(r),
            l = Math.cos(r),
            p = t[0],
            f = t[1],
            _ = t[2],
            x = t[3],
            M = t[4],
            C = t[5],
            L = t[6],
            O = t[7];
          return t !== i && (i[8] = t[8], i[9] = t[9], i[10] = t[10], i[11] = t[11], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[0] = p * l + M * n, i[1] = f * l + C * n, i[2] = _ * l + L * n, i[3] = x * l + O * n, i[4] = M * l - p * n, i[5] = C * l - f * n, i[6] = L * l - _ * n, i[7] = O * l - x * n, i
        }, T.bA = function(i, t, r, n) {
          var l = [],
            p = [];
          return l[0] = t[0] - r[0], l[1] = t[1] - r[1], l[2] = t[2] - r[2], p[0] = l[0], p[1] = l[1] * Math.cos(n) - l[2] * Math.sin(n), p[2] = l[1] * Math.sin(n) + l[2] * Math.cos(n), i[0] = p[0] + r[0], i[1] = p[1] + r[1], i[2] = p[2] + r[2], i
        }, T.bB = function(i, t, r, n) {
          var l = [],
            p = [];
          return l[0] = t[0] - r[0], l[1] = t[1] - r[1], l[2] = t[2] - r[2], p[0] = l[2] * Math.sin(n) + l[0] * Math.cos(n), p[1] = l[1], p[2] = l[2] * Math.cos(n) - l[0] * Math.sin(n), i[0] = p[0] + r[0], i[1] = p[1] + r[1], i[2] = p[2] + r[2], i
        }, T.bC = function(i, t, r) {
          var n = Math.sin(r),
            l = Math.cos(r),
            p = t[0],
            f = t[1],
            _ = t[2],
            x = t[3],
            M = t[8],
            C = t[9],
            L = t[10],
            O = t[11];
          return t !== i && (i[4] = t[4], i[5] = t[5], i[6] = t[6], i[7] = t[7], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[0] = p * l - M * n, i[1] = f * l - C * n, i[2] = _ * l - L * n, i[3] = x * l - O * n, i[8] = p * n + M * l, i[9] = f * n + C * l, i[10] = _ * n + L * l, i[11] = x * n + O * l, i
        }, T.bD = function(i, t) {
          const r = vt(i, 360),
            n = vt(t, 360),
            l = n - r,
            p = n > r ? l - 360 : l + 360;
          return Math.abs(l) < Math.abs(p) ? l : p
        }, T.bE = function(i) {
          return i[0] = 0, i[1] = 0, i[2] = 0, i
        }, T.bF = function(i, t, r, n) {
          const l = Math.sqrt(i * i + t * t),
            p = Math.sqrt(r * r + n * n);
          i /= l, t /= l, r /= p, n /= p;
          const f = Math.acos(i * r + t * n);
          return -t * r + i * n > 0 ? f : -f
        }, T.bG = function(i, t) {
          const r = vt(i, 2 * Math.PI),
            n = vt(t, 2 * Math.PI);
          return Math.min(Math.abs(r - n), Math.abs(r - n + 2 * Math.PI), Math.abs(r - n - 2 * Math.PI))
        }, T.bH = function() {
          const i = {},
            t = J.$version;
          for (const r in J.$root) {
            const n = J.$root[r];
            if (n.required) {
              let l = null;
              l = r === "version" ? t : n.type === "array" ? [] : {}, l != null && (i[r] = l)
            }
          }
          return i
        }, T.bI = pu, T.bJ = Q, T.bK = function i(t, r) {
          if (Array.isArray(t)) {
            if (!Array.isArray(r) || t.length !== r.length) return !1;
            for (let n = 0; n < t.length; n++)
              if (!i(t[n], r[n])) return !1;
            return !0
          }
          if (typeof t == "object" && t !== null && r !== null) {
            if (typeof r != "object" || Object.keys(t).length !== Object.keys(r).length) return !1;
            for (const n in t)
              if (!i(t[n], r[n])) return !1;
            return !0
          }
          return t === r
        }, T.bL = function(i) {
          i = i.slice();
          const t = Object.create(null);
          for (let r = 0; r < i.length; r++) t[i[r].id] = i[r];
          for (let r = 0; r < i.length; r++) "ref" in i[r] && (i[r] = tt(i[r], t[i[r].ref]));
          return i
        }, T.bM = function(i, t) {
          if (i.type === "custom") return new $x(i, t);
          switch (i.type) {
            case "background":
              return new Hx(i, t);
            case "circle":
              return new zy(i, t);
            case "color-relief":
              return new Oy(i, t);
            case "fill":
              return new Qy(i, t);
            case "fill-extrusion":
              return new ux(i, t);
            case "heatmap":
              return new Dy(i, t);
            case "hillshade":
              return new Fy(i, t);
            case "line":
              return new _x(i, t);
            case "raster":
              return new tf(i, t);
            case "symbol":
              return new Vd(i, t)
          }
        }, T.bN = i => i.type === "raster", T.bO = Ot, T.bP = function(i, t) {
          if (!i) return [{
            command: "setStyle",
            args: [t]
          }];
          let r = [];
          try {
            if (!Ze(i.version, t.version)) return [{
              command: "setStyle",
              args: [t]
            }];
            Ze(i.center, t.center) || r.push({
              command: "setCenter",
              args: [t.center]
            }), Ze(i.state, t.state) || r.push({
              command: "setGlobalState",
              args: [t.state]
            }), Ze(i.centerAltitude, t.centerAltitude) || r.push({
              command: "setCenterAltitude",
              args: [t.centerAltitude]
            }), Ze(i.zoom, t.zoom) || r.push({
              command: "setZoom",
              args: [t.zoom]
            }), Ze(i.bearing, t.bearing) || r.push({
              command: "setBearing",
              args: [t.bearing]
            }), Ze(i.pitch, t.pitch) || r.push({
              command: "setPitch",
              args: [t.pitch]
            }), Ze(i.roll, t.roll) || r.push({
              command: "setRoll",
              args: [t.roll]
            }), Ze(i.sprite, t.sprite) || r.push({
              command: "setSprite",
              args: [t.sprite]
            }), Ze(i.glyphs, t.glyphs) || r.push({
              command: "setGlyphs",
              args: [t.glyphs]
            }), Ze(i.transition, t.transition) || r.push({
              command: "setTransition",
              args: [t.transition]
            }), Ze(i.light, t.light) || r.push({
              command: "setLight",
              args: [t.light]
            }), Ze(i.terrain, t.terrain) || r.push({
              command: "setTerrain",
              args: [t.terrain]
            }), Ze(i.sky, t.sky) || r.push({
              command: "setSky",
              args: [t.sky]
            }), Ze(i.projection, t.projection) || r.push({
              command: "setProjection",
              args: [t.projection]
            });
            const n = {},
              l = [];
            (function(f, _, x, M) {
              let C;
              for (C in _ = _ || {}, f = f || {}) Object.prototype.hasOwnProperty.call(f, C) && (Object.prototype.hasOwnProperty.call(_, C) || He(C, x, M));
              for (C in _) Object.prototype.hasOwnProperty.call(_, C) && (Object.prototype.hasOwnProperty.call(f, C) ? Ze(f[C], _[C]) || (f[C].type === "geojson" && _[C].type === "geojson" && Tt(f, _, C) ? ne(x, {
                command: "setGeoJSONSourceData",
                args: [C, _[C].data]
              }) : ht(C, _, x, M)) : Ce(C, _, x))
            })(i.sources, t.sources, l, n);
            const p = [];
            i.layers && i.layers.forEach((f => {
              "source" in f && n[f.source] ? r.push({
                command: "removeLayer",
                args: [f.id]
              }) : p.push(f)
            })), r = r.concat(l), (function(f, _, x) {
              _ = _ || [];
              const M = (f = f || []).map(St),
                C = _.map(St),
                L = f.reduce(jt, {}),
                O = _.reduce(jt, {}),
                N = M.slice(),
                G = Object.create(null);
              let K, ie, pe, Ne, ye;
              for (let ke = 0, at = 0; ke < M.length; ke++) K = M[ke], Object.prototype.hasOwnProperty.call(O, K) ? at++ : (ne(x, {
                command: "removeLayer",
                args: [K]
              }), N.splice(N.indexOf(K, at), 1));
              for (let ke = 0, at = 0; ke < C.length; ke++) K = C[C.length - 1 - ke], N[N.length - 1 - ke] !== K && (Object.prototype.hasOwnProperty.call(L, K) ? (ne(x, {
                command: "removeLayer",
                args: [K]
              }), N.splice(N.lastIndexOf(K, N.length - at), 1)) : at++, Ne = N[N.length - ke], ne(x, {
                command: "addLayer",
                args: [O[K], Ne]
              }), N.splice(N.length - ke, 0, K), G[K] = !0);
              for (let ke = 0; ke < C.length; ke++)
                if (K = C[ke], ie = L[K], pe = O[K], !G[K] && !Ze(ie, pe))
                  if (Ze(ie.source, pe.source) && Ze(ie["source-layer"], pe["source-layer"]) && Ze(ie.type, pe.type)) {
                    for (ye in dt(ie.layout, pe.layout, x, K, null, "setLayoutProperty"), dt(ie.paint, pe.paint, x, K, null, "setPaintProperty"), Ze(ie.filter, pe.filter) || ne(x, {
                        command: "setFilter",
                        args: [K, pe.filter]
                      }), Ze(ie.minzoom, pe.minzoom) && Ze(ie.maxzoom, pe.maxzoom) || ne(x, {
                        command: "setLayerZoomRange",
                        args: [K, pe.minzoom, pe.maxzoom]
                      }), ie) Object.prototype.hasOwnProperty.call(ie, ye) && ye !== "layout" && ye !== "paint" && ye !== "filter" && ye !== "metadata" && ye !== "minzoom" && ye !== "maxzoom" && (ye.indexOf("paint.") === 0 ? dt(ie[ye], pe[ye], x, K, ye.slice(6), "setPaintProperty") : Ze(ie[ye], pe[ye]) || ne(x, {
                      command: "setLayerProperty",
                      args: [K, ye, pe[ye]]
                    }));
                    for (ye in pe) Object.prototype.hasOwnProperty.call(pe, ye) && !Object.prototype.hasOwnProperty.call(ie, ye) && ye !== "layout" && ye !== "paint" && ye !== "filter" && ye !== "metadata" && ye !== "minzoom" && ye !== "maxzoom" && (ye.indexOf("paint.") === 0 ? dt(ie[ye], pe[ye], x, K, ye.slice(6), "setPaintProperty") : Ze(ie[ye], pe[ye]) || ne(x, {
                      command: "setLayerProperty",
                      args: [K, ye, pe[ye]]
                    }))
                  } else ne(x, {
                    command: "removeLayer",
                    args: [K]
                  }), Ne = N[N.lastIndexOf(K) + 1], ne(x, {
                    command: "addLayer",
                    args: [pe, Ne]
                  })
            })(p, t.layers, r)
          } catch (n) {
            console.warn("Unable to compute style diff:", n), r = [{
              command: "setStyle",
              args: [t]
            }]
          }
          return r
        }, T.bQ = function(i) {
          const t = [],
            r = i.id;
          return r === void 0 && t.push({
            message: `layers.${r}: missing required property "id"`
          }), i.render === void 0 && t.push({
            message: `layers.${r}: missing required method "render"`
          }), i.renderingMode && i.renderingMode !== "2d" && i.renderingMode !== "3d" && t.push({
            message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"`
          }), t
        }, T.bR = Zt, T.bS = Jt, T.bT = class extends _n {
          constructor(i, t) {
            super(i, t), this.current = 0
          }
          set(i) {
            this.current !== i && (this.current = i, this.gl.uniform1i(this.location, i))
          }
        }, T.bU = Ms, T.bV = class extends _n {
          constructor(i, t) {
            super(i, t), this.current = nl
          }
          set(i) {
            if (i[12] !== this.current[12] || i[0] !== this.current[0]) return this.current = i, void this.gl.uniformMatrix4fv(this.location, !1, i);
            for (let t = 1; t < 16; t++)
              if (i[t] !== this.current[t]) {
                this.current = i, this.gl.uniformMatrix4fv(this.location, !1, i);
                break
              }
          }
        }, T.bW = fs, T.bX = class extends _n {
          constructor(i, t) {
            super(i, t), this.current = [0, 0, 0]
          }
          set(i) {
            i[0] === this.current[0] && i[1] === this.current[1] && i[2] === this.current[2] || (this.current = i, this.gl.uniform3f(this.location, i[0], i[1], i[2]))
          }
        }, T.bY = class extends _n {
          constructor(i, t) {
            super(i, t), this.current = [0, 0]
          }
          set(i) {
            i[0] === this.current[0] && i[1] === this.current[1] || (this.current = i, this.gl.uniform2f(this.location, i[0], i[1]))
          }
        }, T.bZ = $e, T.b_ = function(i, t) {
          var r = Math.sin(t),
            n = Math.cos(t);
          return i[0] = n, i[1] = r, i[2] = 0, i[3] = -r, i[4] = n, i[5] = 0, i[6] = 0, i[7] = 0, i[8] = 1, i
        }, T.ba = function(i, t, r) {
          var n = Math.sin(r),
            l = Math.cos(r),
            p = t[4],
            f = t[5],
            _ = t[6],
            x = t[7],
            M = t[8],
            C = t[9],
            L = t[10],
            O = t[11];
          return t !== i && (i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[4] = p * l + M * n, i[5] = f * l + C * n, i[6] = _ * l + L * n, i[7] = x * l + O * n, i[8] = M * l - p * n, i[9] = C * l - f * n, i[10] = L * l - _ * n, i[11] = O * l - x * n, i
        }, T.bb = function() {
          const i = new Float32Array(16);
          return et(i), i
        }, T.bc = function() {
          const i = new Float64Array(16);
          return et(i), i
        }, T.bd = function() {
          return new Float64Array(16)
        }, T.be = function(i, t, r) {
          const n = new Float64Array(4);
          return Vt(n, i, t - 90, r), n
        }, T.bf = function(i, t, r, n) {
          var l, p, f, _, x, M = t[0],
            C = t[1],
            L = t[2],
            O = t[3],
            N = r[0],
            G = r[1],
            K = r[2],
            ie = r[3];
          return (p = M * N + C * G + L * K + O * ie) < 0 && (p = -p, N = -N, G = -G, K = -K, ie = -ie), 1 - p > Fe ? (l = Math.acos(p), f = Math.sin(l), _ = Math.sin((1 - n) * l) / f, x = Math.sin(n * l) / f) : (_ = 1 - n, x = n), i[0] = _ * M + x * N, i[1] = _ * C + x * G, i[2] = _ * L + x * K, i[3] = _ * O + x * ie, i
        }, T.bg = function(i) {
          const t = new Float64Array(9);
          var r, n, l, p, f, _, x, M, C, L, O, N, G, K, ie, pe, Ne, ye;
          L = (l = (n = i)[0]) * (x = l + l), O = (p = n[1]) * x, G = (f = n[2]) * x, K = f * (M = p + p), pe = (_ = n[3]) * x, Ne = _ * M, ye = _ * (C = f + f), (r = t)[0] = 1 - (N = p * M) - (ie = f * C), r[3] = O - ye, r[6] = G + Ne, r[1] = O + ye, r[4] = 1 - L - ie, r[7] = K - pe, r[2] = G - Ne, r[5] = K + pe, r[8] = 1 - L - N;
          const ke = Gr(-Math.asin(Xt(t[2], -1, 1)));
          let at, gt;
          return Math.hypot(t[5], t[8]) < .001 ? (at = 0, gt = -Gr(Math.atan2(t[3], t[4]))) : (at = Gr(t[5] === 0 && t[8] === 0 ? 0 : Math.atan2(t[5], t[8])), gt = Gr(t[1] === 0 && t[0] === 0 ? 0 : Math.atan2(t[1], t[0]))), {
            roll: at,
            pitch: ke + 90,
            bearing: gt
          }
        }, T.bh = function(i, t) {
          return i.roll == t.roll && i.pitch == t.pitch && i.bearing == t.bearing
        }, T.bi = Ir, T.bj = hn, T.bk = nc, T.bl = Lu, T.bm = ac, T.bn = Dt, T.bo = Rt, T.bp = sa, T.bq = function(i, t, r, n, l) {
          return Dt(n, l, Xt((i - t) / (r - t), 0, 1))
        }, T.br = vt, T.bs = function() {
          return new Float64Array(3)
        }, T.bt = function(i, t, r, n) {
          return i[0] = t[0] + r[0] * n, i[1] = t[1] + r[1] * n, i[2] = t[2] + r[2] * n, i
        }, T.bu = Vt, T.bv = function(i, t, r) {
          var n = r[0],
            l = r[1],
            p = r[2],
            f = r[3],
            _ = t[0],
            x = t[1],
            M = t[2],
            C = l * M - p * x,
            L = p * _ - n * M,
            O = n * x - l * _;
          return i[0] = _ + f * (C += C) + l * (O += O) - p * (L += L), i[1] = x + f * L + p * C - n * O, i[2] = M + f * O + n * L - l * C, i
        }, T.bw = function(i, t, r) {
          const n = (l = [i[0], i[1], i[2], t[0], t[1], t[2], r[0], r[1], r[2]])[0] * ((C = l[8]) * (f = l[4]) - (_ = l[5]) * (M = l[7])) + l[1] * (-C * (p = l[3]) + _ * (x = l[6])) + l[2] * (M * p - f * x);
          var l, p, f, _, x, M, C;
          if (n === 0) return null;
          const L = qe([], [t[0], t[1], t[2]], [r[0], r[1], r[2]]),
            O = qe([], [r[0], r[1], r[2]], [i[0], i[1], i[2]]),
            N = qe([], [i[0], i[1], i[2]], [t[0], t[1], t[2]]),
            G = Le([], L, -i[3]);
          return Ye(G, G, Le([], O, -t[3])), Ye(G, G, Le([], N, -r[3])), Le(G, G, 1 / n), G
        }, T.bx = Af, T.by = function() {
          return new Float64Array(4)
        }, T.bz = function(i, t, r, n) {
          var l = [],
            p = [];
          return l[0] = t[0] - r[0], l[1] = t[1] - r[1], l[2] = t[2] - r[2], p[0] = l[0] * Math.cos(n) - l[1] * Math.sin(n), p[1] = l[0] * Math.sin(n) + l[1] * Math.cos(n), p[2] = l[2], i[0] = p[0] + r[0], i[1] = p[1] + r[1], i[2] = p[2] + r[2], i
        }, T.c = de, T.c0 = function(i, t, r, n, l, p, f) {
          var _ = 1 / (t - r),
            x = 1 / (n - l),
            M = 1 / (p - f);
          return i[0] = -2 * _, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = -2 * x, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 2 * M, i[11] = 0, i[12] = (t + r) * _, i[13] = (l + n) * x, i[14] = (f + p) * M, i[15] = 1, i
        }, T.c1 = class extends _n {
          constructor(i, t) {
            super(i, t), this.current = new Array
          }
          set(i) {
            if (i != this.current) {
              this.current = i;
              const t = new Float32Array(4 * i.length);
              for (let r = 0; r < i.length; r++) t[4 * r] = i[r].r, t[4 * r + 1] = i[r].g, t[4 * r + 2] = i[r].b, t[4 * r + 3] = i[r].a;
              this.gl.uniform4fv(this.location, t)
            }
          }
        }, T.c2 = class extends _n {
          constructor(i, t) {
            super(i, t), this.current = new Array
          }
          set(i) {
            if (i != this.current) {
              this.current = i;
              const t = new Float32Array(i);
              this.gl.uniform1fv(this.location, t)
            }
          }
        }, T.c3 = class extends Ys {}, T.c4 = bx, T.c5 = class extends Kl {}, T.c6 = uf, T.c7 = function(i) {
          return i <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(i) / Math.LN2))
        }, T.c8 = Dg, T.c9 = function(i, t, r) {
          var n = t[0],
            l = t[1],
            p = t[2],
            f = r[3] * n + r[7] * l + r[11] * p + r[15];
          return i[0] = (r[0] * n + r[4] * l + r[8] * p + r[12]) / (f = f || 1), i[1] = (r[1] * n + r[5] * l + r[9] * p + r[13]) / f, i[2] = (r[2] * n + r[6] * l + r[10] * p + r[14]) / f, i
        }, T.cB = function(i) {
          return i.message === sr
        }, T.cC = re, T.cD = function(i, t) {
          j.REGISTERED_PROTOCOLS[i] = t
        }, T.cE = function(i) {
          delete j.REGISTERED_PROTOCOLS[i]
        }, T.cF = function(i, t) {
          const r = {};
          for (let l = 0; l < i.length; l++) {
            const p = t && t[i[l].id] || rd(i[l]);
            t && (t[i[l].id] = p);
            let f = r[p];
            f || (f = r[p] = []), f.push(i[l])
          }
          const n = [];
          for (const l in r) n.push(r[l]);
          return n
        }, T.cG = Mr, T.cH = E_, T.cI = L_, T.cJ = c_, T.cK = function(i) {
          i.bucket.createArrays(), i.bucket.tilePixelRatio = ot / (512 * i.bucket.overscaling), i.bucket.compareText = {}, i.bucket.iconsNeedLinear = !1;
          const t = i.bucket.layers[0],
            r = t.layout,
            n = t._unevaluatedLayout._values,
            l = {
              layoutIconSize: n["icon-size"].possiblyEvaluate(new Ji(i.bucket.zoom + 1), i.canonical),
              layoutTextSize: n["text-size"].possiblyEvaluate(new Ji(i.bucket.zoom + 1), i.canonical),
              textMaxSize: n["text-size"].possiblyEvaluate(new Ji(18))
            };
          if (i.bucket.textSizeData.kind === "composite") {
            const {
              minZoom: M,
              maxZoom: C
            } = i.bucket.textSizeData;
            l.compositeTextSizes = [n["text-size"].possiblyEvaluate(new Ji(M), i.canonical), n["text-size"].possiblyEvaluate(new Ji(C), i.canonical)]
          }
          if (i.bucket.iconSizeData.kind === "composite") {
            const {
              minZoom: M,
              maxZoom: C
            } = i.bucket.iconSizeData;
            l.compositeIconSizes = [n["icon-size"].possiblyEvaluate(new Ji(M), i.canonical), n["icon-size"].possiblyEvaluate(new Ji(C), i.canonical)]
          }
          const p = r.get("text-line-height") * Na,
            f = r.get("text-rotation-alignment") !== "viewport" && r.get("symbol-placement") !== "point",
            _ = r.get("text-keep-upright"),
            x = r.get("text-size");
          for (const M of i.bucket.features) {
            const C = r.get("text-font").evaluate(M, {}, i.canonical).join(","),
              L = x.evaluate(M, {}, i.canonical),
              O = l.layoutTextSize.evaluate(M, {}, i.canonical),
              N = l.layoutIconSize.evaluate(M, {}, i.canonical),
              G = {
                horizontal: {},
                vertical: void 0
              },
              K = M.text;
            let ie, pe = [0, 0];
            if (K) {
              const ke = K.toString(),
                at = r.get("text-letter-spacing").evaluate(M, {}, i.canonical) * Na,
                gt = mu(ke) ? at : 0,
                Wt = r.get("text-anchor").evaluate(M, {}, i.canonical),
                xr = U_(t, M, i.canonical);
              if (!xr) {
                const gr = r.get("text-radial-offset").evaluate(M, {}, i.canonical);
                pe = gr ? N_(Wt, [gr * Na, Ef]) : r.get("text-offset").evaluate(M, {}, i.canonical).map((vr => vr * Na))
              }
              let hr = f ? "center" : r.get("text-justify").evaluate(M, {}, i.canonical);
              const _r = r.get("symbol-placement") === "point" ? r.get("text-max-width").evaluate(M, {}, i.canonical) * Na : 1 / 0,
                Qr = () => {
                  i.bucket.allowVerticalPlacement && fu(ke) && (G.vertical = Od(K, i.glyphMap, i.glyphPositions, i.imagePositions, C, _r, p, Wt, "left", gt, pe, T.as.vertical, !0, O, L))
                };
              if (!f && xr) {
                const gr = new Set;
                if (hr === "auto")
                  for (let zt = 0; zt < xr.values.length; zt += 2) gr.add(zf(xr.values[zt]));
                else gr.add(hr);
                let vr = !1;
                for (const zt of gr)
                  if (!G.horizontal[zt])
                    if (vr) G.horizontal[zt] = G.horizontal[0];
                    else {
                      const ci = Od(K, i.glyphMap, i.glyphPositions, i.imagePositions, C, _r, p, "center", zt, gt, pe, T.as.horizontal, !1, O, L);
                      ci && (G.horizontal[zt] = ci, vr = ci.positionedLines.length === 1)
                    } Qr()
              } else {
                hr === "auto" && (hr = zf(Wt));
                const gr = Od(K, i.glyphMap, i.glyphPositions, i.imagePositions, C, _r, p, Wt, hr, gt, pe, T.as.horizontal, !1, O, L);
                gr && (G.horizontal[hr] = gr), Qr(), fu(ke) && f && _ && (G.vertical = Od(K, i.glyphMap, i.glyphPositions, i.imagePositions, C, _r, p, Wt, hr, gt, pe, T.as.vertical, !1, O, L))
              }
            }
            let Ne = !1;
            if (M.icon && M.icon.name) {
              const ke = i.imageMap[M.icon.name];
              ke && (ie = Nx(i.imagePositions[M.icon.name], r.get("icon-offset").evaluate(M, {}, i.canonical), r.get("icon-anchor").evaluate(M, {}, i.canonical)), Ne = !!ke.sdf, i.bucket.sdfIcons === void 0 ? i.bucket.sdfIcons = Ne : i.bucket.sdfIcons !== Ne && At("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (ke.pixelRatio !== i.bucket.pixelRatio || r.get("icon-rotate").constantOr(1) !== 0) && (i.bucket.iconsNeedLinear = !0))
            }
            const ye = W_(G.horizontal) || G.vertical;
            i.bucket.iconsInText = !!ye && ye.iconsInText, (ye || ie) && i1(i.bucket, M, G, ie, i.imageMap, l, O, N, pe, Ne, i.canonical, i.subdivisionGranularity)
          }
          i.showCollisionBoxes && i.bucket.generateCollisionDebugBuffers()
        }, T.cL = mf, T.cM = _f, T.cN = vf, T.cO = Xg, T.cP = xf, T.cQ = class {
          constructor(i) {
            this._marks = {
              start: [i.url, "start"].join("#"),
              end: [i.url, "end"].join("#"),
              measure: i.url.toString()
            }, performance.mark(this._marks.start)
          }
          finish() {
            performance.mark(this._marks.end);
            let i = performance.getEntriesByName(this._marks.measure);
            return i.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), i = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), i
          }
        }, T.cR = function(i, t, r, n, l) {
          return s(this, void 0, void 0, (function*() {
            if (we()) try {
              return yield br(i, t, r, n, l)
            } catch {}
            return (function(p, f, _, x, M) {
              const C = p.width,
                L = p.height;
              cr && jr || (cr = new OffscreenCanvas(C, L), jr = cr.getContext("2d", {
                willReadFrequently: !0
              })), cr.width = C, cr.height = L, jr.drawImage(p, 0, 0, C, L);
              const O = jr.getImageData(f, _, x, M);
              return jr.clearRect(0, 0, C, L), O.data
            })(i, t, r, n, l)
          }))
        }, T.cS = Bg, T.cT = W, T.cU = $g, T.cV = sc, T.cW = Us, T.cX = function(i, t) {
          const r = new Map;
          if (i != null)
            if (i.type === "Feature") r.set(qu(i, t), i);
            else
              for (const n of i.features) r.set(qu(n, t), n);
          return r
        }, T.cY = function(i, t) {
          if (i == null) return !0;
          if (i.type === "Feature") return qu(i, t) != null;
          if (i.type === "FeatureCollection") {
            const r = new Set;
            for (const n of i.features) {
              const l = qu(n, t);
              if (l == null || r.has(l)) return !1;
              r.add(l)
            }
            return !0
          }
          return !1
        }, T.cZ = function(i, t, r) {
          var n, l, p, f;
          if (t.removeAll && i.clear(), t.remove)
            for (const _ of t.remove) i.delete(_);
          if (t.add)
            for (const _ of t.add) {
              const x = qu(_, r);
              x != null && i.set(x, _)
            }
          if (t.update)
            for (const _ of t.update) {
              let x = i.get(_.id);
              if (x == null) continue;
              const M = !_.removeAllProperties && (((n = _.removeProperties) === null || n === void 0 ? void 0 : n.length) > 0 || ((l = _.addOrUpdateProperties) === null || l === void 0 ? void 0 : l.length) > 0);
              if ((_.newGeometry || _.removeAllProperties || M) && (x = Object.assign({}, x), i.set(_.id, x), M && (x.properties = Object.assign({}, x.properties))), _.newGeometry && (x.geometry = _.newGeometry), _.removeAllProperties) x.properties = {};
              else if (((p = _.removeProperties) === null || p === void 0 ? void 0 : p.length) > 0)
                for (const C of _.removeProperties) Object.prototype.hasOwnProperty.call(x.properties, C) && delete x.properties[C];
              if (((f = _.addOrUpdateProperties) === null || f === void 0 ? void 0 : f.length) > 0)
                for (const {
                    key: C,
                    value: L
                  }
                  of _.addOrUpdateProperties) x.properties[C] = L
            }
        }, T.c_ = hs, T.ca = class extends bu {}, T.cb = class extends c {}, T.cc = function(i, t) {
          return i[0] === t[0] && i[1] === t[1] && i[2] === t[2] && i[3] === t[3] && i[4] === t[4] && i[5] === t[5] && i[6] === t[6] && i[7] === t[7] && i[8] === t[8] && i[9] === t[9] && i[10] === t[10] && i[11] === t[11] && i[12] === t[12] && i[13] === t[13] && i[14] === t[14] && i[15] === t[15]
        }, T.cd = function(i, t) {
          var r = i[0],
            n = i[1],
            l = i[2],
            p = i[3],
            f = i[4],
            _ = i[5],
            x = i[6],
            M = i[7],
            C = i[8],
            L = i[9],
            O = i[10],
            N = i[11],
            G = i[12],
            K = i[13],
            ie = i[14],
            pe = i[15],
            Ne = t[0],
            ye = t[1],
            ke = t[2],
            at = t[3],
            gt = t[4],
            Wt = t[5],
            xr = t[6],
            hr = t[7],
            _r = t[8],
            Qr = t[9],
            gr = t[10],
            vr = t[11],
            zt = t[12],
            ci = t[13],
            pi = t[14],
            ai = t[15];
          return Math.abs(r - Ne) <= Fe * Math.max(1, Math.abs(r), Math.abs(Ne)) && Math.abs(n - ye) <= Fe * Math.max(1, Math.abs(n), Math.abs(ye)) && Math.abs(l - ke) <= Fe * Math.max(1, Math.abs(l), Math.abs(ke)) && Math.abs(p - at) <= Fe * Math.max(1, Math.abs(p), Math.abs(at)) && Math.abs(f - gt) <= Fe * Math.max(1, Math.abs(f), Math.abs(gt)) && Math.abs(_ - Wt) <= Fe * Math.max(1, Math.abs(_), Math.abs(Wt)) && Math.abs(x - xr) <= Fe * Math.max(1, Math.abs(x), Math.abs(xr)) && Math.abs(M - hr) <= Fe * Math.max(1, Math.abs(M), Math.abs(hr)) && Math.abs(C - _r) <= Fe * Math.max(1, Math.abs(C), Math.abs(_r)) && Math.abs(L - Qr) <= Fe * Math.max(1, Math.abs(L), Math.abs(Qr)) && Math.abs(O - gr) <= Fe * Math.max(1, Math.abs(O), Math.abs(gr)) && Math.abs(N - vr) <= Fe * Math.max(1, Math.abs(N), Math.abs(vr)) && Math.abs(G - zt) <= Fe * Math.max(1, Math.abs(G), Math.abs(zt)) && Math.abs(K - ci) <= Fe * Math.max(1, Math.abs(K), Math.abs(ci)) && Math.abs(ie - pi) <= Fe * Math.max(1, Math.abs(ie), Math.abs(pi)) && Math.abs(pe - ai) <= Fe * Math.max(1, Math.abs(pe), Math.abs(ai))
        }, T.ce = function(i, t) {
          return i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[4] = t[4], i[5] = t[5], i[6] = t[6], i[7] = t[7], i[8] = t[8], i[9] = t[9], i[10] = t[10], i[11] = t[11], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15], i
        }, T.cf = i => i.type === "symbol", T.cg = i => i.type === "circle", T.ch = i => i.type === "heatmap", T.ci = i => i.type === "line", T.cj = i => i.type === "fill", T.ck = i => i.type === "fill-extrusion", T.cl = i => i.type === "hillshade", T.cm = i => i.type === "color-relief", T.cn = i => i.type === "background", T.co = i => i.type === "custom", T.cp = $t, T.cq = function(i, t, r) {
          const n = Pt(t.x - r.x, t.y - r.y),
            l = Pt(i.x - r.x, i.y - r.y);
          var p, f;
          return Gr(Math.atan2(n[0] * l[1] - n[1] * l[0], (p = n)[0] * (f = l)[0] + p[1] * f[1]))
        }, T.cr = pr, T.cs = function(i, t) {
          return Wr[t] && (i instanceof MouseEvent || i instanceof WheelEvent)
        }, T.ct = function(i, t) {
          return er[t] && "touches" in i
        }, T.cu = function(i) {
          return er[i] || Wr[i]
        }, T.cv = function(i, t, r) {
          var n = t[0],
            l = t[1];
          return i[0] = r[0] * n + r[4] * l + r[12], i[1] = r[1] * n + r[5] * l + r[13], i
        }, T.cw = function(i, t) {
          const {
            x: r,
            y: n
          } = ju.fromLngLat(t);
          return !(i < 0 || i > 25 || n < 0 || n >= 1 || r < 0 || r >= 1)
        }, T.cx = function(i, t) {
          return i[0] = t[0], i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = t[1], i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = t[2], i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i
        }, T.cy = class extends Hl {}, T.cz = n1, T.d = Te, T.e = nt, T.f = i => s(void 0, void 0, void 0, (function*() {
          if (i.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
          const t = new Blob([new Uint8Array(i)], {
            type: "image/png"
          });
          try {
            return createImageBitmap(t)
          } catch (r) {
            throw new Error(`Could not load image because of ${r.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`)
          }
        })), T.g = V, T.h = i => new Promise(((t, r) => {
          const n = new Image;
          n.onload = () => {
            t(n), URL.revokeObjectURL(n.src), n.onload = null, window.requestAnimationFrame((() => {
              n.src = ur
            }))
          }, n.onerror = () => r(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const l = new Blob([new Uint8Array(i)], {
            type: "image/png"
          });
          n.src = i.byteLength ? URL.createObjectURL(l) : ur
        })), T.i = wt, T.j = (i, t) => ue(nt(i, {
          type: "json"
        }), t), T.k = Be, T.l = We, T.m = ue, T.n = (i, t) => ue(nt(i, {
          type: "arrayBuffer"
        }), t), T.o = function(i) {
          return new xf(i).readFields(zx, [])
        }, T.p = l_, T.q = Cu, T.r = nn, T.s = wr, T.t = J, T.u = Di, T.v = hd, T.w = At, T.x = wd, T.y = Jp, T.z = pd
      })), k("worker", ["./shared"], (function(T) {
        class s {
          constructor(j, V) {
            this.keyCache = {}, j && this.replace(j, V)
          }
          replace(j, V) {
            this._layerConfigs = {}, this._layers = {}, this.update(j, [], V)
          }
          update(j, V, X) {
            for (const Q of j) {
              this._layerConfigs[Q.id] = Q;
              const ue = this._layers[Q.id] = T.bM(Q, X);
              ue._featureFilter = T.ae(ue.filter, X), this.keyCache[Q.id] && delete this.keyCache[Q.id]
            }
            for (const Q of V) delete this.keyCache[Q], delete this._layerConfigs[Q], delete this._layers[Q];
            this.familiesBySource = {};
            const re = T.cF(Object.values(this._layerConfigs), this.keyCache);
            for (const Q of re) {
              const ue = Q.map((ae => this._layers[ae.id])),
                Te = ue[0];
              if (Te.visibility === "none") continue;
              const be = Te.source || "";
              let ze = this.familiesBySource[be];
              ze || (ze = this.familiesBySource[be] = {});
              const We = Te.sourceLayer || "_geojsonTileLayer";
              let Be = ze[We];
              Be || (Be = ze[We] = []), Be.push(ue)
            }
          }
        }
        class B {
          constructor(j) {
            const V = {},
              X = [];
            for (const Te in j) {
              const be = j[Te],
                ze = V[Te] = {};
              for (const We in be) {
                const Be = be[+We];
                if (!Be || Be.bitmap.width === 0 || Be.bitmap.height === 0) continue;
                const ae = {
                  x: 0,
                  y: 0,
                  w: Be.bitmap.width + 2,
                  h: Be.bitmap.height + 2
                };
                X.push(ae), ze[We] = {
                  rect: ae,
                  metrics: Be.metrics
                }
              }
            }
            const {
              w: re,
              h: Q
            } = T.p(X), ue = new T.q({
              width: re || 1,
              height: Q || 1
            });
            for (const Te in j) {
              const be = j[Te];
              for (const ze in be) {
                const We = be[+ze];
                if (!We || We.bitmap.width === 0 || We.bitmap.height === 0) continue;
                const Be = V[Te][ze].rect;
                T.q.copy(We.bitmap, ue, {
                  x: 0,
                  y: 0
                }, {
                  x: Be.x + 1,
                  y: Be.y + 1
                }, We.bitmap)
              }
            }
            this.image = ue, this.positions = V
          }
        }
        T.cG("GlyphAtlas", B);
        class W {
          constructor(j) {
            this.tileID = new T.a0(j.tileID.overscaledZ, j.tileID.wrap, j.tileID.canonical.z, j.tileID.canonical.x, j.tileID.canonical.y), this.uid = j.uid, this.zoom = j.zoom, this.pixelRatio = j.pixelRatio, this.tileSize = j.tileSize, this.source = j.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = j.showCollisionBoxes, this.collectResourceTiming = !!j.collectResourceTiming, this.returnDependencies = !!j.returnDependencies, this.promoteId = j.promoteId, this.inFlightDependencies = []
          }
          parse(j, V, X, re, Q) {
            return T._(this, void 0, void 0, (function*() {
              this.status = "parsing", this.data = j, this.collisionBoxArray = new T.ac;
              const ue = new T.cH(Object.keys(j.layers).sort()),
                Te = new T.cI(this.tileID, this.promoteId);
              Te.bucketLayerIDs = [];
              const be = {},
                ze = {
                  featureIndex: Te,
                  iconDependencies: {},
                  patternDependencies: {},
                  glyphDependencies: {},
                  dashDependencies: {},
                  availableImages: X,
                  subdivisionGranularity: Q
                },
                We = V.familiesBySource[this.source];
              for (const je in We) {
                const yt = j.layers[je];
                if (!yt) continue;
                yt.version === 1 && T.w(`Vector tile source "${this.source}" layer "${je}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const Kt = ue.encode(je),
                  Cr = [];
                for (let fr = 0; fr < yt.length; fr++) {
                  const Je = yt.feature(fr),
                    tr = Te.getId(Je, je);
                  Cr.push({
                    feature: Je,
                    id: tr,
                    index: fr,
                    sourceLayerIndex: Kt
                  })
                }
                for (const fr of We[je]) {
                  const Je = fr[0];
                  Je.source !== this.source && T.w(`layer.source = ${Je.source} does not equal this.source = ${this.source}`), Je.isHidden(this.zoom, !0) || (ee(fr, this.zoom, X), (be[Je.id] = Je.createBucket({
                    index: Te.bucketLayerIDs.length,
                    layers: fr,
                    zoom: this.zoom,
                    pixelRatio: this.pixelRatio,
                    overscaling: this.overscaling,
                    collisionBoxArray: this.collisionBoxArray,
                    sourceLayerIndex: Kt,
                    sourceID: this.source
                  })).populate(Cr, ze, this.tileID.canonical), Te.bucketLayerIDs.push(fr.map((tr => tr.id))))
                }
              }
              const Be = T.bR(ze.glyphDependencies, (je => Object.keys(je).map(Number)));
              this.inFlightDependencies.forEach((je => je == null ? void 0 : je.abort())), this.inFlightDependencies = [];
              let ae = Promise.resolve({});
              if (Object.keys(Be).length) {
                const je = new AbortController;
                this.inFlightDependencies.push(je), ae = re.sendAsync({
                  type: "GG",
                  data: {
                    stacks: Be,
                    source: this.source,
                    tileID: this.tileID,
                    type: "glyphs"
                  }
                }, je)
              }
              const J = Object.keys(ze.iconDependencies);
              let Ve = Promise.resolve({});
              if (J.length) {
                const je = new AbortController;
                this.inFlightDependencies.push(je), Ve = re.sendAsync({
                  type: "GI",
                  data: {
                    icons: J,
                    source: this.source,
                    tileID: this.tileID,
                    type: "icons"
                  }
                }, je)
              }
              const tt = Object.keys(ze.patternDependencies);
              let Ze = Promise.resolve({});
              if (tt.length) {
                const je = new AbortController;
                this.inFlightDependencies.push(je), Ze = re.sendAsync({
                  type: "GI",
                  data: {
                    icons: tt,
                    source: this.source,
                    tileID: this.tileID,
                    type: "patterns"
                  }
                }, je)
              }
              const ne = ze.dashDependencies;
              let Ce = Promise.resolve({});
              if (Object.keys(ne).length) {
                const je = new AbortController;
                this.inFlightDependencies.push(je), Ce = re.sendAsync({
                  type: "GDA",
                  data: {
                    dashes: ne
                  }
                }, je)
              }
              const [He, ht, Tt, dt] = yield Promise.all([ae, Ve, Ze, Ce]), St = new B(He), jt = new T.cJ(ht, Tt);
              for (const je in be) {
                const yt = be[je];
                yt instanceof T.ad ? (ee(yt.layers, this.zoom, X), T.cK({
                  bucket: yt,
                  glyphMap: He,
                  glyphPositions: St.positions,
                  imageMap: ht,
                  imagePositions: jt.iconPositions,
                  showCollisionBoxes: this.showCollisionBoxes,
                  canonical: this.tileID.canonical,
                  subdivisionGranularity: ze.subdivisionGranularity
                })) : yt.hasDependencies && (yt instanceof T.cL || yt instanceof T.cM || yt instanceof T.cN) && (ee(yt.layers, this.zoom, X), yt.addFeatures(ze, this.tileID.canonical, jt.patternPositions, dt))
              }
              return this.status = "done", {
                buckets: Object.values(be).filter((je => !je.isEmpty())),
                featureIndex: Te,
                collisionBoxArray: this.collisionBoxArray,
                glyphAtlasImage: St.image,
                imageAtlas: jt,
                dashPositions: dt,
                glyphMap: this.returnDependencies ? He : null,
                iconMap: this.returnDependencies ? ht : null,
                glyphPositions: this.returnDependencies ? St.positions : null
              }
            }))
          }
        }

        function ee(de, j, V) {
          const X = new T.G(j);
          for (const re of de) re.recalculate(X, V)
        }
        class $ {
          constructor(j, V, X) {
            this.actor = j, this.layerIndex = V, this.availableImages = X, this.fetching = {}, this.loading = {}, this.loaded = {}
          }
          loadVectorTile(j, V) {
            return T._(this, void 0, void 0, (function*() {
              const X = yield T.n(j.request, V);
              try {
                return {
                  vectorTile: new T.cO(new T.cP(X.data)),
                  rawData: X.data,
                  cacheControl: X.cacheControl,
                  expires: X.expires
                }
              } catch (re) {
                const Q = new Uint8Array(X.data);
                let ue = `Unable to parse the tile at ${j.request.url}, `;
                throw ue += Q[0] === 31 && Q[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${re.message}`, new Error(ue)
              }
            }))
          }
          loadTile(j) {
            return T._(this, void 0, void 0, (function*() {
              const V = j.uid,
                X = !!(j && j.request && j.request.collectResourceTiming) && new T.cQ(j.request),
                re = new W(j);
              this.loading[V] = re;
              const Q = new AbortController;
              re.abort = Q;
              try {
                const ue = yield this.loadVectorTile(j, Q);
                if (delete this.loading[V], !ue) return null;
                const Te = ue.rawData,
                  be = {};
                ue.expires && (be.expires = ue.expires), ue.cacheControl && (be.cacheControl = ue.cacheControl);
                const ze = {};
                if (X) {
                  const Be = X.finish();
                  Be && (ze.resourceTiming = JSON.parse(JSON.stringify(Be)))
                }
                re.vectorTile = ue.vectorTile;
                const We = re.parse(ue.vectorTile, this.layerIndex, this.availableImages, this.actor, j.subdivisionGranularity);
                this.loaded[V] = re, this.fetching[V] = {
                  rawTileData: Te,
                  cacheControl: be,
                  resourceTiming: ze
                };
                try {
                  const Be = yield We;
                  return T.e({
                    rawTileData: Te.slice(0)
                  }, Be, be, ze)
                } finally {
                  delete this.fetching[V]
                }
              } catch (ue) {
                throw delete this.loading[V], re.status = "done", this.loaded[V] = re, ue
              }
            }))
          }
          reloadTile(j) {
            return T._(this, void 0, void 0, (function*() {
              const V = j.uid;
              if (!this.loaded || !this.loaded[V]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const X = this.loaded[V];
              if (X.showCollisionBoxes = j.showCollisionBoxes, X.status === "parsing") {
                const re = yield X.parse(X.vectorTile, this.layerIndex, this.availableImages, this.actor, j.subdivisionGranularity);
                let Q;
                if (this.fetching[V]) {
                  const {
                    rawTileData: ue,
                    cacheControl: Te,
                    resourceTiming: be
                  } = this.fetching[V];
                  delete this.fetching[V], Q = T.e({
                    rawTileData: ue.slice(0)
                  }, re, Te, be)
                } else Q = re;
                return Q
              }
              if (X.status === "done" && X.vectorTile) return X.parse(X.vectorTile, this.layerIndex, this.availableImages, this.actor, j.subdivisionGranularity)
            }))
          }
          abortTile(j) {
            return T._(this, void 0, void 0, (function*() {
              const V = this.loading,
                X = j.uid;
              V && V[X] && V[X].abort && (V[X].abort.abort(), delete V[X])
            }))
          }
          removeTile(j) {
            return T._(this, void 0, void 0, (function*() {
              this.loaded && this.loaded[j.uid] && delete this.loaded[j.uid]
            }))
          }
        }
        class oe {
          constructor() {
            this.loaded = {}
          }
          loadTile(j) {
            return T._(this, void 0, void 0, (function*() {
              const {
                uid: V,
                encoding: X,
                rawImageData: re,
                redFactor: Q,
                greenFactor: ue,
                blueFactor: Te,
                baseShift: be
              } = j, ze = re.width + 2, We = re.height + 2, Be = T.b(re) ? new T.R({
                width: ze,
                height: We
              }, yield T.cR(re, -1, -1, ze, We)) : re, ae = new T.cS(V, Be, X, Q, ue, Te, be);
              return this.loaded = this.loaded || {}, this.loaded[V] = ae, ae
            }))
          }
          removeTile(j) {
            const V = this.loaded,
              X = j.uid;
            V && V[X] && delete V[X]
          }
        }
        var me, _e, Z = (function() {
            if (_e) return me;

            function de(V, X) {
              if (V.length !== 0) {
                j(V[0], X);
                for (var re = 1; re < V.length; re++) j(V[re], !X)
              }
            }

            function j(V, X) {
              for (var re = 0, Q = 0, ue = 0, Te = V.length, be = Te - 1; ue < Te; be = ue++) {
                var ze = (V[ue][0] - V[be][0]) * (V[be][1] + V[ue][1]),
                  We = re + ze;
                Q += Math.abs(re) >= Math.abs(ze) ? re - We + ze : ze - We + re, re = We
              }
              re + Q >= 0 != !!X && V.reverse()
            }
            return _e = 1, me = function V(X, re) {
              var Q, ue = X && X.type;
              if (ue === "FeatureCollection")
                for (Q = 0; Q < X.features.length; Q++) V(X.features[Q], re);
              else if (ue === "GeometryCollection")
                for (Q = 0; Q < X.geometries.length; Q++) V(X.geometries[Q], re);
              else if (ue === "Feature") V(X.geometry, re);
              else if (ue === "Polygon") de(X.coordinates, re);
              else if (ue === "MultiPolygon")
                for (Q = 0; Q < X.coordinates.length; Q++) de(X.coordinates[Q], re);
              return X
            }
          })(),
          Ie = T.cT(Z);
        class we extends T.cV {
          constructor(j, V) {
            super(new T.cP, 0, V, [], []), this.feature = j, this.type = j.type, this.properties = j.tags ? j.tags : {}, "id" in j && (typeof j.id == "string" ? this.id = parseInt(j.id, 10) : typeof j.id != "number" || isNaN(j.id) || (this.id = j.id))
          }
          loadGeometry() {
            const j = [],
              V = this.feature.type === 1 ? [this.feature.geometry] : this.feature.geometry;
            for (const X of V) {
              const re = [];
              for (const Q of X) re.push(new T.P(Q[0], Q[1]));
              j.push(re)
            }
            return j
          }
        }
        class Fe extends T.cU {
          constructor(j, V) {
            super(new T.cP), this.layers = {
              _geojsonTileLayer: this
            }, this.name = "_geojsonTileLayer", this.version = V ? V.version : 1, this.extent = V ? V.extent : 4096, this.length = j.length, this.features = j
          }
          feature(j) {
            return new we(this.features[j], this.extent)
          }
        }

        function xe(de, j) {
          j.writeVarintField(15, de.version || 1), j.writeStringField(1, de.name || ""), j.writeVarintField(5, de.extent || 4096);
          const V = {
            keys: [],
            values: [],
            keycache: {},
            valuecache: {}
          };
          for (let Q = 0; Q < de.length; Q++) V.feature = de.feature(Q), j.writeMessage(2, $e, V);
          const X = V.keys;
          for (const Q of X) j.writeStringField(3, Q);
          const re = V.values;
          for (const Q of re) j.writeMessage(4, Ye, Q)
        }

        function $e(de, j) {
          if (!de.feature) return;
          const V = de.feature;
          V.id !== void 0 && j.writeVarintField(1, V.id), j.writeMessage(2, et, de), j.writeVarintField(3, V.type), j.writeMessage(4, De, V)
        }

        function et(de, j) {
          var V;
          for (const X in (V = de.feature) == null ? void 0 : V.properties) {
            let re = de.feature.properties[X],
              Q = de.keycache[X];
            if (re === null) continue;
            Q === void 0 && (de.keys.push(X), Q = de.keys.length - 1, de.keycache[X] = Q), j.writeVarint(Q), typeof re != "string" && typeof re != "boolean" && typeof re != "number" && (re = JSON.stringify(re));
            const ue = typeof re + ":" + re;
            let Te = de.valuecache[ue];
            Te === void 0 && (de.values.push(re), Te = de.values.length - 1, de.valuecache[ue] = Te), j.writeVarint(Te)
          }
        }

        function Xe(de, j) {
          return (j << 3) + (7 & de)
        }

        function Ae(de) {
          return de << 1 ^ de >> 31
        }

        function De(de, j) {
          const V = de.loadGeometry(),
            X = de.type;
          let re = 0,
            Q = 0;
          for (const ue of V) {
            let Te = 1;
            X === 1 && (Te = ue.length), j.writeVarint(Xe(1, Te));
            const be = X === 3 ? ue.length - 1 : ue.length;
            for (let ze = 0; ze < be; ze++) {
              ze === 1 && X !== 1 && j.writeVarint(Xe(2, be - 1));
              const We = ue[ze].x - re,
                Be = ue[ze].y - Q;
              j.writeVarint(Ae(We)), j.writeVarint(Ae(Be)), re += We, Q += Be
            }
            de.type === 3 && j.writeVarint(Xe(7, 1))
          }
        }

        function Ye(de, j) {
          const V = typeof de;
          V === "string" ? j.writeStringField(1, de) : V === "boolean" ? j.writeBooleanField(7, de) : V === "number" && (de % 1 != 0 ? j.writeDoubleField(3, de) : de < 0 ? j.writeSVarintField(6, de) : j.writeVarintField(5, de))
        }
        const Le = {
            minZoom: 0,
            maxZoom: 16,
            minPoints: 2,
            radius: 40,
            extent: 512,
            nodeSize: 64,
            log: !1,
            generateId: !1,
            reduce: null,
            map: de => de
          },
          qe = Math.fround || (_t = new Float32Array(1), de => (_t[0] = +de, _t[0]));
        var _t;
        class Qe {
          constructor(j) {
            this.options = Object.assign(Object.create(Le), j), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = []
          }
          load(j) {
            const {
              log: V,
              minZoom: X,
              maxZoom: re
            } = this.options;
            V && console.time("total time");
            const Q = `prepare ${j.length} points`;
            V && console.time(Q), this.points = j;
            const ue = [];
            for (let be = 0; be < j.length; be++) {
              const ze = j[be];
              if (!ze.geometry) continue;
              const [We, Be] = ze.geometry.coordinates, ae = qe(Vt(We)), J = qe(Et(Be));
              ue.push(ae, J, 1 / 0, be, -1, 1), this.options.reduce && ue.push(0)
            }
            let Te = this.trees[re + 1] = this._createTree(ue);
            V && console.timeEnd(Q);
            for (let be = re; be >= X; be--) {
              const ze = +Date.now();
              Te = this.trees[be] = this._createTree(this._cluster(Te, be)), V && console.log("z%d: %d clusters in %dms", be, Te.numItems, +Date.now() - ze)
            }
            return V && console.timeEnd("total time"), this
          }
          getClusters(j, V) {
            let X = ((j[0] + 180) % 360 + 360) % 360 - 180;
            const re = Math.max(-90, Math.min(90, j[1]));
            let Q = j[2] === 180 ? 180 : ((j[2] + 180) % 360 + 360) % 360 - 180;
            const ue = Math.max(-90, Math.min(90, j[3]));
            if (j[2] - j[0] >= 360) X = -180, Q = 180;
            else if (X > Q) {
              const Be = this.getClusters([X, re, 180, ue], V),
                ae = this.getClusters([-180, re, Q, ue], V);
              return Be.concat(ae)
            }
            const Te = this.trees[this._limitZoom(V)],
              be = Te.range(Vt(X), Et(ue), Vt(Q), Et(re)),
              ze = Te.data,
              We = [];
            for (const Be of be) {
              const ae = this.stride * Be;
              We.push(ze[ae + 5] > 1 ? Ge(ze, ae, this.clusterProps) : this.points[ze[ae + 3]])
            }
            return We
          }
          getChildren(j) {
            const V = this._getOriginId(j),
              X = this._getOriginZoom(j),
              re = "No cluster with the specified id.",
              Q = this.trees[X];
            if (!Q) throw new Error(re);
            const ue = Q.data;
            if (V * this.stride >= ue.length) throw new Error(re);
            const Te = this.options.radius / (this.options.extent * Math.pow(2, X - 1)),
              be = Q.within(ue[V * this.stride], ue[V * this.stride + 1], Te),
              ze = [];
            for (const We of be) {
              const Be = We * this.stride;
              ue[Be + 4] === j && ze.push(ue[Be + 5] > 1 ? Ge(ue, Be, this.clusterProps) : this.points[ue[Be + 3]])
            }
            if (ze.length === 0) throw new Error(re);
            return ze
          }
          getLeaves(j, V, X) {
            const re = [];
            return this._appendLeaves(re, j, V = V || 10, X = X || 0, 0), re
          }
          getTile(j, V, X) {
            const re = this.trees[this._limitZoom(j)],
              Q = Math.pow(2, j),
              {
                extent: ue,
                radius: Te
              } = this.options,
              be = Te / ue,
              ze = (X - be) / Q,
              We = (X + 1 + be) / Q,
              Be = {
                features: []
              };
            return this._addTileFeatures(re.range((V - be) / Q, ze, (V + 1 + be) / Q, We), re.data, V, X, Q, Be), V === 0 && this._addTileFeatures(re.range(1 - be / Q, ze, 1, We), re.data, Q, X, Q, Be), V === Q - 1 && this._addTileFeatures(re.range(0, ze, be / Q, We), re.data, -1, X, Q, Be), Be.features.length ? Be : null
          }
          getClusterExpansionZoom(j) {
            let V = this._getOriginZoom(j) - 1;
            for (; V <= this.options.maxZoom;) {
              const X = this.getChildren(j);
              if (V++, X.length !== 1) break;
              j = X[0].properties.cluster_id
            }
            return V
          }
          _appendLeaves(j, V, X, re, Q) {
            const ue = this.getChildren(V);
            for (const Te of ue) {
              const be = Te.properties;
              if (be && be.cluster ? Q + be.point_count <= re ? Q += be.point_count : Q = this._appendLeaves(j, be.cluster_id, X, re, Q) : Q < re ? Q++ : j.push(Te), j.length === X) break
            }
            return Q
          }
          _createTree(j) {
            const V = new T.aM(j.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let X = 0; X < j.length; X += this.stride) V.add(j[X], j[X + 1]);
            return V.finish(), V.data = j, V
          }
          _addTileFeatures(j, V, X, re, Q, ue) {
            for (const Te of j) {
              const be = Te * this.stride,
                ze = V[be + 5] > 1;
              let We, Be, ae;
              if (ze) We = ft(V, be, this.clusterProps), Be = V[be], ae = V[be + 1];
              else {
                const tt = this.points[V[be + 3]];
                We = tt.properties;
                const [Ze, ne] = tt.geometry.coordinates;
                Be = Vt(Ze), ae = Et(ne)
              }
              const J = {
                type: 1,
                geometry: [
                  [Math.round(this.options.extent * (Be * Q - X)), Math.round(this.options.extent * (ae * Q - re))]
                ],
                tags: We
              };
              let Ve;
              Ve = ze || this.options.generateId ? V[be + 3] : this.points[V[be + 3]].id, Ve !== void 0 && (J.id = Ve), ue.features.push(J)
            }
          }
          _limitZoom(j) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+j), this.options.maxZoom + 1))
          }
          _cluster(j, V) {
            const {
              radius: X,
              extent: re,
              reduce: Q,
              minPoints: ue
            } = this.options, Te = X / (re * Math.pow(2, V)), be = j.data, ze = [], We = this.stride;
            for (let Be = 0; Be < be.length; Be += We) {
              if (be[Be + 2] <= V) continue;
              be[Be + 2] = V;
              const ae = be[Be],
                J = be[Be + 1],
                Ve = j.within(be[Be], be[Be + 1], Te),
                tt = be[Be + 5];
              let Ze = tt;
              for (const ne of Ve) {
                const Ce = ne * We;
                be[Ce + 2] > V && (Ze += be[Ce + 5])
              }
              if (Ze > tt && Ze >= ue) {
                let ne, Ce = ae * tt,
                  He = J * tt,
                  ht = -1;
                const Tt = (Be / We << 5) + (V + 1) + this.points.length;
                for (const dt of Ve) {
                  const St = dt * We;
                  if (be[St + 2] <= V) continue;
                  be[St + 2] = V;
                  const jt = be[St + 5];
                  Ce += be[St] * jt, He += be[St + 1] * jt, be[St + 4] = Tt, Q && (ne || (ne = this._map(be, Be, !0), ht = this.clusterProps.length, this.clusterProps.push(ne)), Q(ne, this._map(be, St)))
                }
                be[Be + 4] = Tt, ze.push(Ce / Ze, He / Ze, 1 / 0, Tt, -1, Ze), Q && ze.push(ht)
              } else {
                for (let ne = 0; ne < We; ne++) ze.push(be[Be + ne]);
                if (Ze > 1)
                  for (const ne of Ve) {
                    const Ce = ne * We;
                    if (!(be[Ce + 2] <= V)) {
                      be[Ce + 2] = V;
                      for (let He = 0; He < We; He++) ze.push(be[Ce + He])
                    }
                  }
              }
            }
            return ze
          }
          _getOriginId(j) {
            return j - this.points.length >> 5
          }
          _getOriginZoom(j) {
            return (j - this.points.length) % 32
          }
          _map(j, V, X) {
            if (j[V + 5] > 1) {
              const ue = this.clusterProps[j[V + 6]];
              return X ? Object.assign({}, ue) : ue
            }
            const re = this.points[j[V + 3]].properties,
              Q = this.options.map(re);
            return X && Q === re ? Object.assign({}, Q) : Q
          }
        }

        function Ge(de, j, V) {
          return {
            type: "Feature",
            id: de[j + 3],
            properties: ft(de, j, V),
            geometry: {
              type: "Point",
              coordinates: [(X = de[j], 360 * (X - .5)), Pt(de[j + 1])]
            }
          };
          var X
        }

        function ft(de, j, V) {
          const X = de[j + 5],
            re = X >= 1e4 ? `${Math.round(X/1e3)}k` : X >= 1e3 ? Math.round(X / 100) / 10 + "k" : X,
            Q = de[j + 6],
            ue = Q === -1 ? {} : Object.assign({}, V[Q]);
          return Object.assign(ue, {
            cluster: !0,
            cluster_id: de[j + 3],
            point_count: X,
            point_count_abbreviated: re
          })
        }

        function Vt(de) {
          return de / 360 + .5
        }

        function Et(de) {
          const j = Math.sin(de * Math.PI / 180),
            V = .5 - .25 * Math.log((1 + j) / (1 - j)) / Math.PI;
          return V < 0 ? 0 : V > 1 ? 1 : V
        }

        function Pt(de) {
          const j = (180 - 360 * de) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(j)) / Math.PI - 90
        }

        function ot(de, j, V, X) {
          let re = X;
          const Q = j + (V - j >> 1);
          let ue, Te = V - j;
          const be = de[j],
            ze = de[j + 1],
            We = de[V],
            Be = de[V + 1];
          for (let ae = j + 3; ae < V; ae += 3) {
            const J = Ht(de[ae], de[ae + 1], be, ze, We, Be);
            if (J > re) ue = ae, re = J;
            else if (J === re) {
              const Ve = Math.abs(ae - Q);
              Ve < Te && (ue = ae, Te = Ve)
            }
          }
          re > X && (ue - j > 3 && ot(de, j, ue, X), de[ue + 2] = re, V - ue > 3 && ot(de, ue, V, X))
        }

        function Ht(de, j, V, X, re, Q) {
          let ue = re - V,
            Te = Q - X;
          if (ue !== 0 || Te !== 0) {
            const be = ((de - V) * ue + (j - X) * Te) / (ue * ue + Te * Te);
            be > 1 ? (V = re, X = Q) : be > 0 && (V += ue * be, X += Te * be)
          }
          return ue = de - V, Te = j - X, ue * ue + Te * Te
        }

        function vt(de, j, V, X) {
          const re = {
            id: de ?? null,
            type: j,
            geometry: V,
            tags: X,
            minX: 1 / 0,
            minY: 1 / 0,
            maxX: -1 / 0,
            maxY: -1 / 0
          };
          if (j === "Point" || j === "MultiPoint" || j === "LineString") Dt(re, V);
          else if (j === "Polygon") Dt(re, V[0]);
          else if (j === "MultiLineString")
            for (const Q of V) Dt(re, Q);
          else if (j === "MultiPolygon")
            for (const Q of V) Dt(re, Q[0]);
          return re
        }

        function Dt(de, j) {
          for (let V = 0; V < j.length; V += 3) de.minX = Math.min(de.minX, j[V]), de.minY = Math.min(de.minY, j[V + 1]), de.maxX = Math.max(de.maxX, j[V]), de.maxY = Math.max(de.maxY, j[V + 1])
        }

        function Rt(de, j, V, X) {
          if (!j.geometry) return;
          const re = j.geometry.coordinates;
          if (re && re.length === 0) return;
          const Q = j.geometry.type,
            ue = Math.pow(V.tolerance / ((1 << V.maxZoom) * V.extent), 2);
          let Te = [],
            be = j.id;
          if (V.promoteId ? be = j.properties[V.promoteId] : V.generateId && (be = X || 0), Q === "Point") $t(re, Te);
          else if (Q === "MultiPoint")
            for (const ze of re) $t(ze, Te);
          else if (Q === "LineString") pr(re, Te, ue, !1);
          else if (Q === "MultiLineString") {
            if (V.lineMetrics) {
              for (const ze of re) Te = [], pr(ze, Te, ue, !1), de.push(vt(be, "LineString", Te, j.properties));
              return
            }
            Xt(re, Te, ue, !1)
          } else if (Q === "Polygon") Xt(re, Te, ue, !0);
          else {
            if (Q !== "MultiPolygon") {
              if (Q === "GeometryCollection") {
                for (const ze of j.geometry.geometries) Rt(de, {
                  id: be,
                  geometry: ze,
                  properties: j.properties
                }, V, X);
                return
              }
              throw new Error("Input data is not a valid GeoJSON object.")
            }
            for (const ze of re) {
              const We = [];
              Xt(ze, We, ue, !0), Te.push(We)
            }
          }
          de.push(vt(be, Q, Te, j.properties))
        }

        function $t(de, j) {
          j.push(or(de[0]), nt(de[1]), 0)
        }

        function pr(de, j, V, X) {
          let re, Q, ue = 0;
          for (let be = 0; be < de.length; be++) {
            const ze = or(de[be][0]),
              We = nt(de[be][1]);
            j.push(ze, We, 0), be > 0 && (ue += X ? (re * We - ze * Q) / 2 : Math.sqrt(Math.pow(ze - re, 2) + Math.pow(We - Q, 2))), re = ze, Q = We
          }
          const Te = j.length - 3;
          j[2] = 1, ot(j, 0, Te, V), j[Te + 2] = 1, j.size = Math.abs(ue), j.start = 0, j.end = j.size
        }

        function Xt(de, j, V, X) {
          for (let re = 0; re < de.length; re++) {
            const Q = [];
            pr(de[re], Q, V, X), j.push(Q)
          }
        }

        function or(de) {
          return de / 360 + .5
        }

        function nt(de) {
          const j = Math.sin(de * Math.PI / 180),
            V = .5 - .25 * Math.log((1 + j) / (1 - j)) / Math.PI;
          return V < 0 ? 0 : V > 1 ? 1 : V
        }

        function rt(de, j, V, X, re, Q, ue, Te) {
          if (X /= j, Q >= (V /= j) && ue < X) return de;
          if (ue < V || Q >= X) return null;
          const be = [];
          for (const ze of de) {
            const We = ze.geometry;
            let Be = ze.type;
            const ae = re === 0 ? ze.minX : ze.minY,
              J = re === 0 ? ze.maxX : ze.maxY;
            if (ae >= V && J < X) {
              be.push(ze);
              continue
            }
            if (J < V || ae >= X) continue;
            let Ve = [];
            if (Be === "Point" || Be === "MultiPoint") Zt(We, Ve, V, X, re);
            else if (Be === "LineString") Jt(We, Ve, V, X, re, !1, Te.lineMetrics);
            else if (Be === "MultiLineString") mr(We, Ve, V, X, re, !1);
            else if (Be === "Polygon") mr(We, Ve, V, X, re, !0);
            else if (Be === "MultiPolygon")
              for (const tt of We) {
                const Ze = [];
                mr(tt, Ze, V, X, re, !0), Ze.length && Ve.push(Ze)
              }
            if (Ve.length) {
              if (Te.lineMetrics && Be === "LineString") {
                for (const tt of Ve) be.push(vt(ze.id, Be, tt, ze.tags));
                continue
              }
              Be !== "LineString" && Be !== "MultiLineString" || (Ve.length === 1 ? (Be = "LineString", Ve = Ve[0]) : Be = "MultiLineString"), Be !== "Point" && Be !== "MultiPoint" || (Be = Ve.length === 3 ? "Point" : "MultiPoint"), be.push(vt(ze.id, Be, Ve, ze.tags))
            }
          }
          return be.length ? be : null
        }

        function Zt(de, j, V, X, re) {
          for (let Q = 0; Q < de.length; Q += 3) {
            const ue = de[Q + re];
            ue >= V && ue <= X && At(j, de[Q], de[Q + 1], de[Q + 2])
          }
        }

        function Jt(de, j, V, X, re, Q, ue) {
          let Te = Ot(de);
          const be = re === 0 ? Mt : wt;
          let ze, We, Be = de.start;
          for (let Ze = 0; Ze < de.length - 3; Ze += 3) {
            const ne = de[Ze],
              Ce = de[Ze + 1],
              He = de[Ze + 2],
              ht = de[Ze + 3],
              Tt = de[Ze + 4],
              dt = re === 0 ? ne : Ce,
              St = re === 0 ? ht : Tt;
            let jt = !1;
            ue && (ze = Math.sqrt(Math.pow(ne - ht, 2) + Math.pow(Ce - Tt, 2))), dt < V ? St > V && (We = be(Te, ne, Ce, ht, Tt, V), ue && (Te.start = Be + ze * We)) : dt > X ? St < X && (We = be(Te, ne, Ce, ht, Tt, X), ue && (Te.start = Be + ze * We)) : At(Te, ne, Ce, He), St < V && dt >= V && (We = be(Te, ne, Ce, ht, Tt, V), jt = !0), St > X && dt <= X && (We = be(Te, ne, Ce, ht, Tt, X), jt = !0), !Q && jt && (ue && (Te.end = Be + ze * We), j.push(Te), Te = Ot(de)), ue && (Be += ze)
          }
          let ae = de.length - 3;
          const J = de[ae],
            Ve = de[ae + 1],
            tt = re === 0 ? J : Ve;
          tt >= V && tt <= X && At(Te, J, Ve, de[ae + 2]), ae = Te.length - 3, Q && ae >= 3 && (Te[ae] !== Te[0] || Te[ae + 1] !== Te[1]) && At(Te, Te[0], Te[1], Te[2]), Te.length && j.push(Te)
        }

        function Ot(de) {
          const j = [];
          return j.size = de.size, j.start = de.start, j.end = de.end, j
        }

        function mr(de, j, V, X, re, Q) {
          for (const ue of de) Jt(ue, j, V, X, re, Q, !1)
        }

        function At(de, j, V, X) {
          de.push(j, V, X)
        }

        function Mt(de, j, V, X, re, Q) {
          const ue = (Q - j) / (X - j);
          return At(de, Q, V + (re - V) * ue, 1), ue
        }

        function wt(de, j, V, X, re, Q) {
          const ue = (Q - V) / (re - V);
          return At(de, j + (X - j) * ue, Q, 1), ue
        }

        function It(de, j) {
          const V = [];
          for (let X = 0; X < de.length; X++) {
            const re = de[X],
              Q = re.type;
            let ue;
            if (Q === "Point" || Q === "MultiPoint" || Q === "LineString") ue = Ut(re.geometry, j);
            else if (Q === "MultiLineString" || Q === "Polygon") {
              ue = [];
              for (const Te of re.geometry) ue.push(Ut(Te, j))
            } else if (Q === "MultiPolygon") {
              ue = [];
              for (const Te of re.geometry) {
                const be = [];
                for (const ze of Te) be.push(Ut(ze, j));
                ue.push(be)
              }
            }
            V.push(vt(re.id, Q, ue, re.tags))
          }
          return V
        }

        function Ut(de, j) {
          const V = [];
          V.size = de.size, de.start !== void 0 && (V.start = de.start, V.end = de.end);
          for (let X = 0; X < de.length; X += 3) V.push(de[X] + j, de[X + 1], de[X + 2]);
          return V
        }

        function ut(de, j) {
          if (de.transformed) return de;
          const V = 1 << de.z,
            X = de.x,
            re = de.y;
          for (const Q of de.features) {
            const ue = Q.geometry,
              Te = Q.type;
            if (Q.geometry = [], Te === 1)
              for (let be = 0; be < ue.length; be += 2) Q.geometry.push(ur(ue[be], ue[be + 1], j, V, X, re));
            else
              for (let be = 0; be < ue.length; be++) {
                const ze = [];
                for (let We = 0; We < ue[be].length; We += 2) ze.push(ur(ue[be][We], ue[be][We + 1], j, V, X, re));
                Q.geometry.push(ze)
              }
          }
          return de.transformed = !0, de
        }

        function ur(de, j, V, X, re, Q) {
          return [Math.round(V * (de * X - re)), Math.round(V * (j * X - Q))]
        }

        function br(de, j, V, X, re) {
          const Q = j === re.maxZoom ? 0 : re.tolerance / ((1 << j) * re.extent),
            ue = {
              features: [],
              numPoints: 0,
              numSimplified: 0,
              numFeatures: de.length,
              source: null,
              x: V,
              y: X,
              z: j,
              transformed: !1,
              minX: 2,
              minY: 1,
              maxX: -1,
              maxY: 0
            };
          for (const Te of de) cr(ue, Te, Q, re);
          return ue
        }

        function cr(de, j, V, X) {
          const re = j.geometry,
            Q = j.type,
            ue = [];
          if (de.minX = Math.min(de.minX, j.minX), de.minY = Math.min(de.minY, j.minY), de.maxX = Math.max(de.maxX, j.maxX), de.maxY = Math.max(de.maxY, j.maxY), Q === "Point" || Q === "MultiPoint")
            for (let Te = 0; Te < re.length; Te += 3) ue.push(re[Te], re[Te + 1]), de.numPoints++, de.numSimplified++;
          else if (Q === "LineString") jr(ue, re, de, V, !1, !1);
          else if (Q === "MultiLineString" || Q === "Polygon")
            for (let Te = 0; Te < re.length; Te++) jr(ue, re[Te], de, V, Q === "Polygon", Te === 0);
          else if (Q === "MultiPolygon")
            for (let Te = 0; Te < re.length; Te++) {
              const be = re[Te];
              for (let ze = 0; ze < be.length; ze++) jr(ue, be[ze], de, V, !0, ze === 0)
            }
          if (ue.length) {
            let Te = j.tags || null;
            if (Q === "LineString" && X.lineMetrics) {
              Te = {};
              for (const ze in j.tags) Te[ze] = j.tags[ze];
              Te.mapbox_clip_start = re.start / re.size, Te.mapbox_clip_end = re.end / re.size
            }
            const be = {
              geometry: ue,
              type: Q === "Polygon" || Q === "MultiPolygon" ? 3 : Q === "LineString" || Q === "MultiLineString" ? 2 : 1,
              tags: Te
            };
            j.id !== null && (be.id = j.id), de.features.push(be)
          }
        }

        function jr(de, j, V, X, re, Q) {
          const ue = X * X;
          if (X > 0 && j.size < (re ? ue : X)) return void(V.numPoints += j.length / 3);
          const Te = [];
          for (let be = 0; be < j.length; be += 3)(X === 0 || j[be + 2] > ue) && (V.numSimplified++, Te.push(j[be], j[be + 1])), V.numPoints++;
          re && (function(be, ze) {
            let We = 0;
            for (let Be = 0, ae = be.length, J = ae - 2; Be < ae; J = Be, Be += 2) We += (be[Be] - be[J]) * (be[Be + 1] + be[J + 1]);
            if (We > 0 === ze)
              for (let Be = 0, ae = be.length; Be < ae / 2; Be += 2) {
                const J = be[Be],
                  Ve = be[Be + 1];
                be[Be] = be[ae - 2 - Be], be[Be + 1] = be[ae - 1 - Be], be[ae - 2 - Be] = J, be[ae - 1 - Be] = Ve
              }
          })(Te, Q), de.push(Te)
        }
        const wr = {
          maxZoom: 14,
          indexMaxZoom: 5,
          indexMaxPoints: 1e5,
          tolerance: 3,
          extent: 4096,
          buffer: 64,
          lineMetrics: !1,
          promoteId: null,
          generateId: !1,
          debug: 0
        };
        class Nr {
          constructor(j, V) {
            const X = (V = this.options = (function(Q, ue) {
              for (const Te in ue) Q[Te] = ue[Te];
              return Q
            })(Object.create(wr), V)).debug;
            if (X && console.time("preprocess data"), V.maxZoom < 0 || V.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (V.promoteId && V.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let re = (function(Q, ue) {
              const Te = [];
              if (Q.type === "FeatureCollection")
                for (let be = 0; be < Q.features.length; be++) Rt(Te, Q.features[be], ue, be);
              else Rt(Te, Q.type === "Feature" ? Q : {
                geometry: Q
              }, ue);
              return Te
            })(j, V);
            this.tiles = {}, this.tileCoords = [], X && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", V.indexMaxZoom, V.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), re = (function(Q, ue) {
              const Te = ue.buffer / ue.extent;
              let be = Q;
              const ze = rt(Q, 1, -1 - Te, Te, 0, -1, 2, ue),
                We = rt(Q, 1, 1 - Te, 2 + Te, 0, -1, 2, ue);
              return (ze || We) && (be = rt(Q, 1, -Te, 1 + Te, 0, -1, 2, ue) || [], ze && (be = It(ze, 1).concat(be)), We && (be = be.concat(It(We, -1)))), be
            })(re, V), re.length && this.splitTile(re, 0, 0, 0), X && (re.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)))
          }
          splitTile(j, V, X, re, Q, ue, Te) {
            const be = [j, V, X, re],
              ze = this.options,
              We = ze.debug;
            for (; be.length;) {
              re = be.pop(), X = be.pop(), V = be.pop(), j = be.pop();
              const Be = 1 << V,
                ae = Gr(V, X, re);
              let J = this.tiles[ae];
              if (!J && (We > 1 && console.time("creation"), J = this.tiles[ae] = br(j, V, X, re, ze), this.tileCoords.push({
                  z: V,
                  x: X,
                  y: re
                }), We)) {
                We > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", V, X, re, J.numFeatures, J.numPoints, J.numSimplified), console.timeEnd("creation"));
                const jt = `z${V}`;
                this.stats[jt] = (this.stats[jt] || 0) + 1, this.total++
              }
              if (J.source = j, Q == null) {
                if (V === ze.indexMaxZoom || J.numPoints <= ze.indexMaxPoints) continue
              } else {
                if (V === ze.maxZoom || V === Q) continue;
                if (Q != null) {
                  const jt = Q - V;
                  if (X !== ue >> jt || re !== Te >> jt) continue
                }
              }
              if (J.source = null, j.length === 0) continue;
              We > 1 && console.time("clipping");
              const Ve = .5 * ze.buffer / ze.extent,
                tt = .5 - Ve,
                Ze = .5 + Ve,
                ne = 1 + Ve;
              let Ce = null,
                He = null,
                ht = null,
                Tt = null,
                dt = rt(j, Be, X - Ve, X + Ze, 0, J.minX, J.maxX, ze),
                St = rt(j, Be, X + tt, X + ne, 0, J.minX, J.maxX, ze);
              j = null, dt && (Ce = rt(dt, Be, re - Ve, re + Ze, 1, J.minY, J.maxY, ze), He = rt(dt, Be, re + tt, re + ne, 1, J.minY, J.maxY, ze), dt = null), St && (ht = rt(St, Be, re - Ve, re + Ze, 1, J.minY, J.maxY, ze), Tt = rt(St, Be, re + tt, re + ne, 1, J.minY, J.maxY, ze), St = null), We > 1 && console.timeEnd("clipping"), be.push(Ce || [], V + 1, 2 * X, 2 * re), be.push(He || [], V + 1, 2 * X, 2 * re + 1), be.push(ht || [], V + 1, 2 * X + 1, 2 * re), be.push(Tt || [], V + 1, 2 * X + 1, 2 * re + 1)
            }
          }
          getTile(j, V, X) {
            j = +j, V = +V, X = +X;
            const re = this.options,
              {
                extent: Q,
                debug: ue
              } = re;
            if (j < 0 || j > 24) return null;
            const Te = 1 << j,
              be = Gr(j, V = V + Te & Te - 1, X);
            if (this.tiles[be]) return ut(this.tiles[be], Q);
            ue > 1 && console.log("drilling down to z%d-%d-%d", j, V, X);
            let ze, We = j,
              Be = V,
              ae = X;
            for (; !ze && We > 0;) We--, Be >>= 1, ae >>= 1, ze = this.tiles[Gr(We, Be, ae)];
            return ze && ze.source ? (ue > 1 && (console.log("found parent tile z%d-%d-%d", We, Be, ae), console.time("drilling down")), this.splitTile(ze.source, We, Be, ae, j, V, X), ue > 1 && console.timeEnd("drilling down"), this.tiles[be] ? ut(this.tiles[be], Q) : null) : null
          }
        }

        function Gr(de, j, V) {
          return 32 * ((1 << de) * V + j) + de
        }
        class er extends $ {
          constructor(j, V, X, re = Wr) {
            super(j, V, X), this._dataUpdateable = new Map, this._createGeoJSONIndex = re
          }
          loadVectorTile(j, V) {
            return T._(this, void 0, void 0, (function*() {
              const X = j.tileID.canonical;
              if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
              const re = this._geoJSONIndex.getTile(X.z, X.x, X.y);
              if (!re) return null;
              const Q = new Fe(re.features, {
                version: 2,
                extent: T.a3
              });
              let ue = (function(Te) {
                const be = new T.cP;
                return (function(ze, We) {
                  for (const Be in ze.layers) We.writeMessage(3, xe, ze.layers[Be])
                })(Te, be), be.finish()
              })(Q);
              return ue.byteOffset === 0 && ue.byteLength === ue.buffer.byteLength || (ue = new Uint8Array(ue)), {
                vectorTile: Q,
                rawData: ue.buffer
              }
            }))
          }
          loadData(j) {
            return T._(this, void 0, void 0, (function*() {
              var V;
              (V = this._pendingRequest) === null || V === void 0 || V.abort();
              const X = !!(j && j.request && j.request.collectResourceTiming) && new T.cQ(j.request);
              this._pendingRequest = new AbortController;
              try {
                (!this._pendingData || j.request || j.data || j.dataDiff) && (this._pendingData = this.loadAndProcessGeoJSON(j, this._pendingRequest));
                const re = yield this._pendingData;
                this._geoJSONIndex = this._createGeoJSONIndex(re, j), this.loaded = {};
                const Q = {
                  data: re
                };
                if (X) {
                  const ue = X.finish();
                  ue && (Q.resourceTiming = {}, Q.resourceTiming[j.source] = JSON.parse(JSON.stringify(ue)))
                }
                return Q
              } catch (re) {
                if (delete this._pendingRequest, T.cB(re)) return {
                  abandoned: !0
                };
                throw re
              }
            }))
          }
          getData() {
            return T._(this, void 0, void 0, (function*() {
              return this._pendingData
            }))
          }
          reloadTile(j) {
            const V = this.loaded;
            return V && V[j.uid] ? super.reloadTile(j) : this.loadTile(j)
          }
          loadAndProcessGeoJSON(j, V) {
            return T._(this, void 0, void 0, (function*() {
              let X = yield this.loadGeoJSON(j, V);
              if (delete this._pendingRequest, typeof X != "object") throw new Error(`Input data given to '${j.source}' is not a valid GeoJSON object.`);
              if (Ie(X, !0), j.filter) {
                const re = T.cW(j.filter, {
                  type: "boolean",
                  "property-type": "data-driven",
                  overridable: !1,
                  transition: !1
                });
                if (re.result === "error") throw new Error(re.value.map((ue => `${ue.key}: ${ue.message}`)).join(", "));
                X = {
                  type: "FeatureCollection",
                  features: X.features.filter((ue => re.value.evaluate({
                    zoom: 0
                  }, ue)))
                }
              }
              return X
            }))
          }
          loadGeoJSON(j, V) {
            return T._(this, void 0, void 0, (function*() {
              const {
                promoteId: X
              } = j;
              if (j.request) {
                const re = yield T.j(j.request, V);
                return this._dataUpdateable = T.cY(re.data, X) ? T.cX(re.data, X) : void 0, re.data
              }
              if (typeof j.data == "string") try {
                const re = JSON.parse(j.data);
                return this._dataUpdateable = T.cY(re, X) ? T.cX(re, X) : void 0, re
              } catch {
                throw new Error(`Input data given to '${j.source}' is not a valid GeoJSON object.`)
              }
              if (!j.dataDiff) throw new Error(`Input data given to '${j.source}' is not a valid GeoJSON object.`);
              if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${j.source}`);
              return T.cZ(this._dataUpdateable, j.dataDiff, X), {
                type: "FeatureCollection",
                features: Array.from(this._dataUpdateable.values())
              }
            }))
          }
          removeSource(j) {
            return T._(this, void 0, void 0, (function*() {
              this._pendingRequest && this._pendingRequest.abort()
            }))
          }
          getClusterExpansionZoom(j) {
            return this._geoJSONIndex.getClusterExpansionZoom(j.clusterId)
          }
          getClusterChildren(j) {
            return this._geoJSONIndex.getChildren(j.clusterId)
          }
          getClusterLeaves(j) {
            return this._geoJSONIndex.getLeaves(j.clusterId, j.limit, j.offset)
          }
        }

        function Wr(de, j) {
          return j.cluster ? new Qe((function({
            superclusterOptions: V,
            clusterProperties: X
          }) {
            if (!X || !V) return V;
            const re = {},
              Q = {},
              ue = {
                accumulated: null,
                zoom: 0
              },
              Te = {
                properties: null
              },
              be = Object.keys(X);
            for (const ze of be) {
              const [We, Be] = X[ze], ae = T.cW(Be), J = T.cW(typeof We == "string" ? [We, ["accumulated"],
                ["get", ze]
              ] : We);
              re[ze] = ae.value, Q[ze] = J.value
            }
            return V.map = ze => {
              Te.properties = ze;
              const We = {};
              for (const Be of be) We[Be] = re[Be].evaluate(ue, Te);
              return We
            }, V.reduce = (ze, We) => {
              Te.properties = We;
              for (const Be of be) ue.accumulated = ze[Be], ze[Be] = Q[Be].evaluate(ue, Te)
            }, V
          })(j)).load(de.features) : (function(V, X) {
            return new Nr(V, X)
          })(de, j.geojsonVtOptions)
        }
        class sr {
          constructor(j) {
            this.self = j, this.actor = new T.K(j), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.globalStates = new Map, this.self.registerWorkerSource = (V, X) => {
              if (this.externalWorkerSourceTypes[V]) throw new Error(`Worker source with name "${V}" already registered.`);
              this.externalWorkerSourceTypes[V] = X
            }, this.self.addProtocol = T.cD, this.self.removeProtocol = T.cE, this.self.registerRTLTextPlugin = V => {
              T.c_.setMethods(V)
            }, this.actor.registerMessageHandler("LDT", ((V, X) => this._getDEMWorkerSource(V, X.source).loadTile(X))), this.actor.registerMessageHandler("RDT", ((V, X) => T._(this, void 0, void 0, (function*() {
              this._getDEMWorkerSource(V, X.source).removeTile(X)
            })))), this.actor.registerMessageHandler("GCEZ", ((V, X) => T._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(V, X.type, X.source).getClusterExpansionZoom(X)
            })))), this.actor.registerMessageHandler("GCC", ((V, X) => T._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(V, X.type, X.source).getClusterChildren(X)
            })))), this.actor.registerMessageHandler("GCL", ((V, X) => T._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(V, X.type, X.source).getClusterLeaves(X)
            })))), this.actor.registerMessageHandler("LD", ((V, X) => this._getWorkerSource(V, X.type, X.source).loadData(X))), this.actor.registerMessageHandler("GD", ((V, X) => this._getWorkerSource(V, X.type, X.source).getData())), this.actor.registerMessageHandler("LT", ((V, X) => this._getWorkerSource(V, X.type, X.source).loadTile(X))), this.actor.registerMessageHandler("RT", ((V, X) => this._getWorkerSource(V, X.type, X.source).reloadTile(X))), this.actor.registerMessageHandler("AT", ((V, X) => this._getWorkerSource(V, X.type, X.source).abortTile(X))), this.actor.registerMessageHandler("RMT", ((V, X) => this._getWorkerSource(V, X.type, X.source).removeTile(X))), this.actor.registerMessageHandler("RS", ((V, X) => T._(this, void 0, void 0, (function*() {
              if (!this.workerSources[V] || !this.workerSources[V][X.type] || !this.workerSources[V][X.type][X.source]) return;
              const re = this.workerSources[V][X.type][X.source];
              delete this.workerSources[V][X.type][X.source], re.removeSource !== void 0 && re.removeSource(X)
            })))), this.actor.registerMessageHandler("RM", (V => T._(this, void 0, void 0, (function*() {
              delete this.layerIndexes[V], delete this.availableImages[V], delete this.workerSources[V], delete this.demWorkerSources[V], this.globalStates.delete(V)
            })))), this.actor.registerMessageHandler("SR", ((V, X) => T._(this, void 0, void 0, (function*() {
              this.referrer = X
            })))), this.actor.registerMessageHandler("SRPS", ((V, X) => this._syncRTLPluginState(V, X))), this.actor.registerMessageHandler("IS", ((V, X) => T._(this, void 0, void 0, (function*() {
              this.self.importScripts(X)
            })))), this.actor.registerMessageHandler("SI", ((V, X) => this._setImages(V, X))), this.actor.registerMessageHandler("UL", ((V, X) => T._(this, void 0, void 0, (function*() {
              this._getLayerIndex(V).update(X.layers, X.removedIds, this._getGlobalState(V))
            })))), this.actor.registerMessageHandler("UGS", ((V, X) => T._(this, void 0, void 0, (function*() {
              const re = this._getGlobalState(V);
              for (const Q in X) re[Q] = X[Q]
            })))), this.actor.registerMessageHandler("SL", ((V, X) => T._(this, void 0, void 0, (function*() {
              this._getLayerIndex(V).replace(X, this._getGlobalState(V))
            }))))
          }
          _getGlobalState(j) {
            let V = this.globalStates.get(j);
            return V || (V = {}, this.globalStates.set(j, V)), V
          }
          _setImages(j, V) {
            return T._(this, void 0, void 0, (function*() {
              this.availableImages[j] = V;
              for (const X in this.workerSources[j]) {
                const re = this.workerSources[j][X];
                for (const Q in re) re[Q].availableImages = V
              }
            }))
          }
          _syncRTLPluginState(j, V) {
            return T._(this, void 0, void 0, (function*() {
              return yield T.c_.syncState(V, this.self.importScripts)
            }))
          }
          _getAvailableImages(j) {
            let V = this.availableImages[j];
            return V || (V = []), V
          }
          _getLayerIndex(j) {
            let V = this.layerIndexes[j];
            return V || (V = this.layerIndexes[j] = new s), V
          }
          _getWorkerSource(j, V, X) {
            if (this.workerSources[j] || (this.workerSources[j] = {}), this.workerSources[j][V] || (this.workerSources[j][V] = {}), !this.workerSources[j][V][X]) {
              const re = {
                sendAsync: (Q, ue) => (Q.targetMapId = j, this.actor.sendAsync(Q, ue))
              };
              switch (V) {
                case "vector":
                  this.workerSources[j][V][X] = new $(re, this._getLayerIndex(j), this._getAvailableImages(j));
                  break;
                case "geojson":
                  this.workerSources[j][V][X] = new er(re, this._getLayerIndex(j), this._getAvailableImages(j));
                  break;
                default:
                  this.workerSources[j][V][X] = new this.externalWorkerSourceTypes[V](re, this._getLayerIndex(j), this._getAvailableImages(j))
              }
            }
            return this.workerSources[j][V][X]
          }
          _getDEMWorkerSource(j, V) {
            return this.demWorkerSources[j] || (this.demWorkerSources[j] = {}), this.demWorkerSources[j][V] || (this.demWorkerSources[j][V] = new oe), this.demWorkerSources[j][V]
          }
        }
        return T.i(self) && (self.worker = new sr(self)), sr
      })), k("index", ["exports", "./shared"], (function(T, s) {
        var B = "5.11.0";

        function W() {
          var h = new s.A(4);
          return s.A != Float32Array && (h[1] = 0, h[2] = 0), h[0] = 1, h[3] = 1, h
        }
        let ee, $;
        const oe = {
            frame(h, e, a) {
              const o = requestAnimationFrame((d => {
                  c(), e(d)
                })),
                {
                  unsubscribe: c
                } = s.s(h.signal, "abort", (() => {
                  c(), cancelAnimationFrame(o), a(s.c())
                }), !1)
            },
            frameAsync(h) {
              return new Promise(((e, a) => {
                this.frame(h, e, a)
              }))
            },
            getImageData(h, e = 0) {
              return this.getImageCanvasContext(h).getImageData(-e, -e, h.width + 2 * e, h.height + 2 * e)
            },
            getImageCanvasContext(h) {
              const e = window.document.createElement("canvas"),
                a = e.getContext("2d", {
                  willReadFrequently: !0
                });
              if (!a) throw new Error("failed to create canvas 2d context");
              return e.width = h.width, e.height = h.height, a.drawImage(h, 0, 0, h.width, h.height), a
            },
            resolveURL: h => (ee || (ee = document.createElement("a")), ee.href = h, ee.href),
            hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4,
            get prefersReducedMotion() {
              return !!matchMedia && ($ == null && ($ = matchMedia("(prefers-reduced-motion: reduce)")), $.matches)
            }
          },
          me = new class {
            constructor() {
              this._realTime = typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), this._frozenAt = null
            }
            getCurrentTime() {
              return this._frozenAt !== null ? this._frozenAt : this._realTime()
            }
            setNow(h) {
              this._frozenAt = h
            }
            restoreNow() {
              this._frozenAt = null
            }
            isFrozen() {
              return this._frozenAt !== null
            }
          };

        function _e() {
          return me.getCurrentTime()
        }
        class Z {
          static testProp(e) {
            if (!Z.docStyle) return e[0];
            for (let a = 0; a < e.length; a++)
              if (e[a] in Z.docStyle) return e[a];
            return e[0]
          }
          static create(e, a, o) {
            const c = window.document.createElement(e);
            return a !== void 0 && (c.className = a), o && o.appendChild(c), c
          }
          static createNS(e, a) {
            return window.document.createElementNS(e, a)
          }
          static disableDrag() {
            Z.docStyle && Z.selectProp && (Z.userSelect = Z.docStyle[Z.selectProp], Z.docStyle[Z.selectProp] = "none")
          }
          static enableDrag() {
            Z.docStyle && Z.selectProp && (Z.docStyle[Z.selectProp] = Z.userSelect)
          }
          static setTransform(e, a) {
            e.style[Z.transformProp] = a
          }
          static addEventListener(e, a, o, c = {}) {
            e.addEventListener(a, o, "passive" in c ? c : c.capture)
          }
          static removeEventListener(e, a, o, c = {}) {
            e.removeEventListener(a, o, "passive" in c ? c : c.capture)
          }
          static suppressClickInternal(e) {
            e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", Z.suppressClickInternal, !0)
          }
          static suppressClick() {
            window.addEventListener("click", Z.suppressClickInternal, !0), window.setTimeout((() => {
              window.removeEventListener("click", Z.suppressClickInternal, !0)
            }), 0)
          }
          static getScale(e) {
            const a = e.getBoundingClientRect();
            return {
              x: a.width / e.offsetWidth || 1,
              y: a.height / e.offsetHeight || 1,
              boundingClientRect: a
            }
          }
          static getPoint(e, a, o) {
            const c = a.boundingClientRect;
            return new s.P((o.clientX - c.left) / a.x - e.clientLeft, (o.clientY - c.top) / a.y - e.clientTop)
          }
          static mousePos(e, a) {
            const o = Z.getScale(e);
            return Z.getPoint(e, o, a)
          }
          static touchPos(e, a) {
            const o = [],
              c = Z.getScale(e);
            for (let d = 0; d < a.length; d++) o.push(Z.getPoint(e, c, a[d]));
            return o
          }
          static mouseButton(e) {
            return e.button
          }
          static remove(e) {
            e.parentNode && e.parentNode.removeChild(e)
          }
          static sanitize(e) {
            const a = new DOMParser().parseFromString(e, "text/html").body || document.createElement("body"),
              o = a.querySelectorAll("script");
            for (const c of o) c.remove();
            return Z.clean(a), a.innerHTML
          }
          static isPossiblyDangerous(e, a) {
            const o = a.replace(/\s+/g, "").toLowerCase();
            return !(!["src", "href", "xlink:href"].includes(e) || !o.includes("javascript:") && !o.includes("data:")) || !!e.startsWith("on") || void 0
          }
          static clean(e) {
            const a = e.children;
            for (const o of a) Z.removeAttributes(o), Z.clean(o)
          }
          static removeAttributes(e) {
            for (const {
                name: a,
                value: o
              }
              of e.attributes) Z.isPossiblyDangerous(a, o) && e.removeAttribute(a)
          }
        }
        Z.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, Z.selectProp = Z.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), Z.transformProp = Z.testProp(["transform", "WebkitTransform"]);
        const Ie = {
          supported: !1,
          testSupport: function(h) {
            !xe && Fe && ($e ? et(h) : we = h)
          }
        };
        let we, Fe, xe = !1,
          $e = !1;

        function et(h) {
          const e = h.createTexture();
          h.bindTexture(h.TEXTURE_2D, e);
          try {
            if (h.texImage2D(h.TEXTURE_2D, 0, h.RGBA, h.RGBA, h.UNSIGNED_BYTE, Fe), h.isContextLost()) return;
            Ie.supported = !0
          } catch {}
          h.deleteTexture(e), xe = !0
        }
        var Xe;
        typeof document < "u" && (Fe = document.createElement("img"), Fe.onload = () => {
          we && et(we), we = null, $e = !0
        }, Fe.onerror = () => {
          xe = !0, we = null
        }, Fe.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), (function(h) {
          let e, a, o, c;
          h.resetRequestQueue = () => {
            e = [], a = 0, o = 0, c = {}
          }, h.addThrottleControl = S => {
            const A = o++;
            return c[A] = S, A
          }, h.removeThrottleControl = S => {
            delete c[S], g()
          }, h.getImage = (S, A, E = !0) => new Promise(((F, R) => {
            Ie.supported && (S.headers || (S.headers = {}), S.headers.accept = "image/webp,*/*"), s.e(S, {
              type: "image"
            }), e.push({
              abortController: A,
              requestParameters: S,
              supportImageRefresh: E,
              state: "queued",
              onError: U => {
                R(U)
              },
              onSuccess: U => {
                F(U)
              }
            }), g()
          }));
          const d = S => s._(this, void 0, void 0, (function*() {
              S.state = "running";
              const {
                requestParameters: A,
                supportImageRefresh: E,
                onError: F,
                onSuccess: R,
                abortController: U
              } = S, Y = E === !1 && !s.i(self) && !s.g(A.url) && (!A.headers || Object.keys(A.headers).reduce(((ce, ge) => ce && ge === "accept"), !0));
              a++;
              const se = Y ? w(A, U) : s.m(A, U);
              try {
                const ce = yield se;
                delete S.abortController, S.state = "completed", ce.data instanceof HTMLImageElement || s.b(ce.data) ? R(ce) : ce.data && R({
                  data: yield(le = ce.data, typeof createImageBitmap == "function" ? s.f(le) : s.h(le)),
                  cacheControl: ce.cacheControl,
                  expires: ce.expires
                })
              } catch (ce) {
                delete S.abortController, F(ce)
              } finally {
                a--, g()
              }
              var le
            })),
            g = () => {
              const S = (() => {
                for (const A of Object.keys(c))
                  if (c[A]()) return !0;
                return !1
              })() ? s.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : s.a.MAX_PARALLEL_IMAGE_REQUESTS;
              for (let A = a; A < S && e.length > 0; A++) {
                const E = e.shift();
                E.abortController.signal.aborted ? A-- : d(E)
              }
            },
            w = (S, A) => new Promise(((E, F) => {
              const R = new Image,
                U = S.url,
                Y = S.credentials;
              Y && Y === "include" ? R.crossOrigin = "use-credentials" : (Y && Y === "same-origin" || !s.d(U)) && (R.crossOrigin = "anonymous"), A.signal.addEventListener("abort", (() => {
                R.src = "", F(s.c())
              })), R.fetchPriority = "high", R.onload = () => {
                R.onerror = R.onload = null, E({
                  data: R
                })
              }, R.onerror = () => {
                R.onerror = R.onload = null, A.signal.aborted || F(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."))
              }, R.src = U
            }))
        })(Xe || (Xe = {})), Xe.resetRequestQueue();
        class Ae {
          constructor(e) {
            this._transformRequestFn = e ?? null
          }
          transformRequest(e, a) {
            return this._transformRequestFn && this._transformRequestFn(e, a) || {
              url: e
            }
          }
          setTransformRequest(e) {
            this._transformRequestFn = e
          }
        }

        function De(h) {
          const e = [];
          if (typeof h == "string") e.push({
            id: "default",
            url: h
          });
          else if (h && h.length > 0) {
            const a = [];
            for (const {
                id: o,
                url: c
              }
              of h) {
              const d = `${o}${c}`;
              a.indexOf(d) === -1 && (a.push(d), e.push({
                id: o,
                url: c
              }))
            }
          }
          return e
        }

        function Ye(h, e, a) {
          try {
            const o = new URL(h);
            return o.pathname += `${e}${a}`, o.toString()
          } catch {
            throw new Error(`Invalid sprite URL "${h}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`)
          }
        }

        function Le(h) {
          const {
            userImage: e
          } = h;
          return !!(e && e.render && e.render()) && (h.data.replace(new Uint8Array(e.data.buffer)), !0)
        }
        class qe extends s.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new s.R({
              width: 1,
              height: 1
            }), this.dirty = !0
          }
          isLoaded() {
            return this.loaded
          }
          setLoaded(e) {
            if (this.loaded !== e && (this.loaded = e, e)) {
              for (const {
                  ids: a,
                  promiseResolve: o
                }
                of this.requestors) o(this._getImagesForIds(a));
              this.requestors = []
            }
          }
          getImage(e) {
            const a = this.images[e];
            if (a && !a.data && a.spriteData) {
              const o = a.spriteData;
              a.data = new s.R({
                width: o.width,
                height: o.height
              }, o.context.getImageData(o.x, o.y, o.width, o.height).data), a.spriteData = null
            }
            return a
          }
          addImage(e, a) {
            if (this.images[e]) throw new Error(`Image id ${e} already exist, use updateImage instead`);
            this._validate(e, a) && (this.images[e] = a)
          }
          _validate(e, a) {
            let o = !0;
            const c = a.data || a.spriteData;
            return this._validateStretch(a.stretchX, c && c.width) || (this.fire(new s.k(new Error(`Image "${e}" has invalid "stretchX" value`))), o = !1), this._validateStretch(a.stretchY, c && c.height) || (this.fire(new s.k(new Error(`Image "${e}" has invalid "stretchY" value`))), o = !1), this._validateContent(a.content, a) || (this.fire(new s.k(new Error(`Image "${e}" has invalid "content" value`))), o = !1), o
          }
          _validateStretch(e, a) {
            if (!e) return !0;
            let o = 0;
            for (const c of e) {
              if (c[0] < o || c[1] < c[0] || a < c[1]) return !1;
              o = c[1]
            }
            return !0
          }
          _validateContent(e, a) {
            if (!e) return !0;
            if (e.length !== 4) return !1;
            const o = a.spriteData,
              c = o && o.width || a.data.width,
              d = o && o.height || a.data.height;
            return !(e[0] < 0 || c < e[0] || e[1] < 0 || d < e[1] || e[2] < 0 || c < e[2] || e[3] < 0 || d < e[3] || e[2] < e[0] || e[3] < e[1])
          }
          updateImage(e, a, o = !0) {
            const c = this.getImage(e);
            if (o && (c.data.width !== a.data.width || c.data.height !== a.data.height)) throw new Error(`size mismatch between old image (${c.data.width}x${c.data.height}) and new image (${a.data.width}x${a.data.height}).`);
            a.version = c.version + 1, this.images[e] = a, this.updatedImages[e] = !0
          }
          removeImage(e) {
            const a = this.images[e];
            delete this.images[e], delete this.patterns[e], a.userImage && a.userImage.onRemove && a.userImage.onRemove()
          }
          listImages() {
            return Object.keys(this.images)
          }
          getImages(e) {
            return new Promise(((a, o) => {
              let c = !0;
              if (!this.isLoaded())
                for (const d of e) this.images[d] || (c = !1);
              this.isLoaded() || c ? a(this._getImagesForIds(e)) : this.requestors.push({
                ids: e,
                promiseResolve: a
              })
            }))
          }
          _getImagesForIds(e) {
            const a = {};
            for (const o of e) {
              let c = this.getImage(o);
              c || (this.fire(new s.l("styleimagemissing", {
                id: o
              })), c = this.getImage(o)), c ? a[o] = {
                data: c.data.clone(),
                pixelRatio: c.pixelRatio,
                sdf: c.sdf,
                version: c.version,
                stretchX: c.stretchX,
                stretchY: c.stretchY,
                content: c.content,
                textFitWidth: c.textFitWidth,
                textFitHeight: c.textFitHeight,
                hasRenderCallback: !!(c.userImage && c.userImage.render)
              } : s.w(`Image "${o}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`)
            }
            return a
          }
          getPixelSize() {
            const {
              width: e,
              height: a
            } = this.atlasImage;
            return {
              width: e,
              height: a
            }
          }
          getPattern(e) {
            const a = this.patterns[e],
              o = this.getImage(e);
            if (!o) return null;
            if (a && a.position.version === o.version) return a.position;
            if (a) a.position.version = o.version;
            else {
              const c = {
                  w: o.data.width + 2,
                  h: o.data.height + 2,
                  x: 0,
                  y: 0
                },
                d = new s.I(c, o);
              this.patterns[e] = {
                bin: c,
                position: d
              }
            }
            return this._updatePatternAtlas(), this.patterns[e].position
          }
          bind(e) {
            const a = e.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new s.T(e, this.atlasImage, a.RGBA), this.atlasTexture.bind(a.LINEAR, a.CLAMP_TO_EDGE)
          }
          _updatePatternAtlas() {
            const e = [];
            for (const d in this.patterns) e.push(this.patterns[d].bin);
            const {
              w: a,
              h: o
            } = s.p(e), c = this.atlasImage;
            c.resize({
              width: a || 1,
              height: o || 1
            });
            for (const d in this.patterns) {
              const {
                bin: g
              } = this.patterns[d], w = g.x + 1, S = g.y + 1, A = this.getImage(d).data, E = A.width, F = A.height;
              s.R.copy(A, c, {
                x: 0,
                y: 0
              }, {
                x: w,
                y: S
              }, {
                width: E,
                height: F
              }), s.R.copy(A, c, {
                x: 0,
                y: F - 1
              }, {
                x: w,
                y: S - 1
              }, {
                width: E,
                height: 1
              }), s.R.copy(A, c, {
                x: 0,
                y: 0
              }, {
                x: w,
                y: S + F
              }, {
                width: E,
                height: 1
              }), s.R.copy(A, c, {
                x: E - 1,
                y: 0
              }, {
                x: w - 1,
                y: S
              }, {
                width: 1,
                height: F
              }), s.R.copy(A, c, {
                x: 0,
                y: 0
              }, {
                x: w + E,
                y: S
              }, {
                width: 1,
                height: F
              })
            }
            this.dirty = !0
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {}
          }
          dispatchRenderCallbacks(e) {
            for (const a of e) {
              if (this.callbackDispatchedThisFrame[a]) continue;
              this.callbackDispatchedThisFrame[a] = !0;
              const o = this.getImage(a);
              o || s.w(`Image with ID: "${a}" was not found`), Le(o) && this.updateImage(a, o)
            }
          }
        }
        const _t = 1e20;

        function Qe(h, e, a, o, c, d, g, w, S) {
          for (let A = e; A < e + o; A++) Ge(h, a * d + A, d, c, g, w, S);
          for (let A = a; A < a + c; A++) Ge(h, A * d + e, 1, o, g, w, S)
        }

        function Ge(h, e, a, o, c, d, g) {
          d[0] = 0, g[0] = -_t, g[1] = _t, c[0] = h[e];
          for (let w = 1, S = 0, A = 0; w < o; w++) {
            c[w] = h[e + w * a];
            const E = w * w;
            do {
              const F = d[S];
              A = (c[w] - c[F] + E - F * F) / (w - F) / 2
            } while (A <= g[S] && --S > -1);
            S++, d[S] = w, g[S] = A, g[S + 1] = _t
          }
          for (let w = 0, S = 0; w < o; w++) {
            for (; g[S + 1] < w;) S++;
            const A = d[S],
              E = w - A;
            h[e + w * a] = c[A] + E * E
          }
        }
        const ft = s.v.layout_symbol["text-font"].default.join(",");
        class Vt {
          constructor(e, a, o) {
            this.requestManager = e, this.localIdeographFontFamily = a, this.entries = {}, this.lang = o
          }
          setURL(e) {
            this.url = e
          }
          getGlyphs(e) {
            return s._(this, void 0, void 0, (function*() {
              const a = [];
              for (const d in e)
                for (const g of e[d]) a.push(this._getAndCacheGlyphsPromise(d, g));
              const o = yield Promise.all(a), c = {};
              for (const {
                  stack: d,
                  id: g,
                  glyph: w
                }
                of o) c[d] || (c[d] = {}), c[d][g] = w && {
                id: w.id,
                bitmap: w.bitmap.clone(),
                metrics: w.metrics
              };
              return c
            }))
          }
          _getAndCacheGlyphsPromise(e, a) {
            return s._(this, void 0, void 0, (function*() {
              let o = this.entries[e];
              o || (o = this.entries[e] = {
                glyphs: {},
                requests: {},
                ranges: {}
              });
              let c = o.glyphs[a];
              return c !== void 0 ? {
                stack: e,
                id: a,
                glyph: c
              } : !this.url || this._charUsesLocalIdeographFontFamily(a) ? (c = o.glyphs[a] = this._drawGlyph(o, e, a), {
                stack: e,
                id: a,
                glyph: c
              }) : yield this._downloadAndCacheRangePromise(e, a)
            }))
          }
          _downloadAndCacheRangePromise(e, a) {
            return s._(this, void 0, void 0, (function*() {
              const o = Math.floor(a / 256);
              if (256 * o > 65535) throw new Error("glyphs > 65535 not supported");
              const c = this.entries[e];
              if (c.ranges[o]) return {
                stack: e,
                id: a,
                glyph: null
              };
              if (!c.requests[o]) {
                const d = Vt.loadGlyphRange(e, o, this.url, this.requestManager);
                c.requests[o] = d
              }
              try {
                const d = yield c.requests[o];
                for (const g in d) c.glyphs[+g] = d[+g];
                return c.ranges[o] = !0, {
                  stack: e,
                  id: a,
                  glyph: d[a] || null
                }
              } catch (d) {
                const g = c.glyphs[a] = this._drawGlyph(c, e, a);
                return this._warnOnMissingGlyphRange(g, o, a, d), {
                  stack: e,
                  id: a,
                  glyph: g
                }
              }
            }))
          }
          _warnOnMissingGlyphRange(e, a, o, c) {
            const d = 256 * a,
              g = d + 255,
              w = o.toString(16).padStart(4, "0").toUpperCase();
            s.w(`Unable to load glyph range ${a}, ${d}-${g}. Rendering codepoint U+${w} locally instead. ${c}`)
          }
          _charUsesLocalIdeographFontFamily(e) {
            return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(e)) || s.u["CJK Unified Ideographs"](e) || s.u["Hangul Syllables"](e) || s.u.Hiragana(e) || s.u.Katakana(e) || s.u["CJK Symbols and Punctuation"](e) || s.u["Halfwidth and Fullwidth Forms"](e))
          }
          _drawGlyph(e, a, o) {
            const c = a === ft && this.localIdeographFontFamily !== "" && this._charUsesLocalIdeographFontFamily(o),
              d = c ? "ideographTinySDF" : "tinySDF";
            e[d] || (e[d] = this._createTinySDF(c ? this.localIdeographFontFamily : a));
            const g = e[d].draw(String.fromCharCode(o));
            return {
              id: o,
              bitmap: new s.q({
                width: g.width || 60,
                height: g.height || 60
              }, g.data),
              metrics: {
                width: g.glyphWidth / 2 || 24,
                height: g.glyphHeight / 2 || 24,
                left: g.glyphLeft / 2 + .5 || 0,
                top: g.glyphTop / 2 - 27.5 || -8,
                advance: g.glyphAdvance / 2 || 24,
                isDoubleResolution: !0
              }
            }
          }
          _createTinySDF(e) {
            const a = e ? e.split(",") : [];
            a.push("sans-serif");
            const o = a.map((c => /[-\w]+/.test(c) ? c : `'${CSS.escape(c)}'`)).join(",");
            return new Vt.TinySDF({
              fontSize: 48,
              buffer: 6,
              radius: 16,
              cutoff: .25,
              fontFamily: o,
              fontWeight: this._fontWeight(a[0]),
              fontStyle: this._fontStyle(a[0]),
              lang: this.lang
            })
          }
          _fontStyle(e) {
            return /italic/i.test(e) ? "italic" : /oblique/i.test(e) ? "oblique" : "normal"
          }
          _fontWeight(e) {
            const a = {
              thin: 100,
              hairline: 100,
              "extra light": 200,
              "ultra light": 200,
              light: 300,
              normal: 400,
              regular: 400,
              medium: 500,
              semibold: 600,
              demibold: 600,
              bold: 700,
              "extra bold": 800,
              "ultra bold": 800,
              black: 900,
              heavy: 900,
              "extra black": 950,
              "ultra black": 950
            };
            let o;
            for (const [c, d] of Object.entries(a)) new RegExp(`\\b${c}\\b`, "i").test(e) && (o = `${d}`);
            return o
          }
        }
        Vt.loadGlyphRange = function(h, e, a, o) {
          return s._(this, void 0, void 0, (function*() {
            const c = 256 * e,
              d = c + 255,
              g = o.transformRequest(a.replace("{fontstack}", h).replace("{range}", `${c}-${d}`), "Glyphs"),
              w = yield s.n(g, new AbortController);
            if (!w || !w.data) throw new Error(`Could not load glyph range. range: ${e}, ${c}-${d}`);
            const S = {};
            for (const A of s.o(w.data)) S[A.id] = A;
            return S
          }))
        }, Vt.TinySDF = class {
          constructor({
            fontSize: h = 24,
            buffer: e = 3,
            radius: a = 8,
            cutoff: o = .25,
            fontFamily: c = "sans-serif",
            fontWeight: d = "normal",
            fontStyle: g = "normal",
            lang: w = null
          } = {}) {
            this.buffer = e, this.cutoff = o, this.radius = a, this.lang = w;
            const S = this.size = h + 4 * e,
              A = this._createCanvas(S),
              E = this.ctx = A.getContext("2d", {
                willReadFrequently: !0
              });
            E.font = `${g} ${d} ${h}px ${c}`, E.textBaseline = "alphabetic", E.textAlign = "left", E.fillStyle = "black", this.gridOuter = new Float64Array(S * S), this.gridInner = new Float64Array(S * S), this.f = new Float64Array(S), this.z = new Float64Array(S + 1), this.v = new Uint16Array(S)
          }
          _createCanvas(h) {
            const e = document.createElement("canvas");
            return e.width = e.height = h, e
          }
          draw(h) {
            const {
              width: e,
              actualBoundingBoxAscent: a,
              actualBoundingBoxDescent: o,
              actualBoundingBoxLeft: c,
              actualBoundingBoxRight: d
            } = this.ctx.measureText(h), g = Math.ceil(a), w = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(d - c))), S = Math.min(this.size - this.buffer, g + Math.ceil(o)), A = w + 2 * this.buffer, E = S + 2 * this.buffer, F = Math.max(A * E, 0), R = new Uint8ClampedArray(F), U = {
              data: R,
              width: A,
              height: E,
              glyphWidth: w,
              glyphHeight: S,
              glyphTop: g,
              glyphLeft: 0,
              glyphAdvance: e
            };
            if (w === 0 || S === 0) return U;
            const {
              ctx: Y,
              buffer: se,
              gridInner: le,
              gridOuter: ce
            } = this;
            this.lang && (Y.lang = this.lang), Y.clearRect(se, se, w, S), Y.fillText(h, se, se + g);
            const ge = Y.getImageData(se, se, w, S);
            ce.fill(_t, 0, F), le.fill(0, 0, F);
            for (let Pe = 0; Pe < S; Pe++)
              for (let fe = 0; fe < w; fe++) {
                const Me = ge.data[4 * (Pe * w + fe) + 3] / 255;
                if (Me === 0) continue;
                const Ee = (Pe + se) * A + fe + se;
                if (Me === 1) ce[Ee] = 0, le[Ee] = _t;
                else {
                  const ve = .5 - Me;
                  ce[Ee] = ve > 0 ? ve * ve : 0, le[Ee] = ve < 0 ? ve * ve : 0
                }
              }
            Qe(ce, 0, 0, A, E, A, this.f, this.v, this.z), Qe(le, se, se, w, S, A, this.f, this.v, this.z);
            for (let Pe = 0; Pe < F; Pe++) {
              const fe = Math.sqrt(ce[Pe]) - Math.sqrt(le[Pe]);
              R[Pe] = Math.round(255 - 255 * (fe / this.radius + this.cutoff))
            }
            return U
          }
        };
        class Et {
          constructor() {
            this.specification = s.t.light.position
          }
          possiblyEvaluate(e, a) {
            return s.C(e.expression.evaluate(a))
          }
          interpolate(e, a, o) {
            return {
              x: s.F.number(e.x, a.x, o),
              y: s.F.number(e.y, a.y, o),
              z: s.F.number(e.z, a.z, o)
            }
          }
        }
        let Pt;
        class ot extends s.E {
          constructor(e) {
            super(), Pt = Pt || new s.r({
              anchor: new s.D(s.t.light.anchor),
              position: new Et,
              color: new s.D(s.t.light.color),
              intensity: new s.D(s.t.light.intensity)
            }), this._transitionable = new s.x(Pt, void 0), this.setLight(e), this._transitioning = this._transitionable.untransitioned()
          }
          getLight() {
            return this._transitionable.serialize()
          }
          setLight(e, a = {}) {
            if (!this._validate(s.y, e, a))
              for (const o in e) {
                const c = e[o];
                o.endsWith("-transition") ? this._transitionable.setTransition(o.slice(0, -11), c) : this._transitionable.setValue(o, c)
              }
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          _validate(e, a, o) {
            return (!o || o.validate !== !1) && s.z(this, e.call(s.B, {
              value: a,
              style: {
                glyphs: !0,
                sprite: !0
              },
              styleSpec: s.t
            }))
          }
        }
        const Ht = new s.r({
          "sky-color": new s.D(s.t.sky["sky-color"]),
          "horizon-color": new s.D(s.t.sky["horizon-color"]),
          "fog-color": new s.D(s.t.sky["fog-color"]),
          "fog-ground-blend": new s.D(s.t.sky["fog-ground-blend"]),
          "horizon-fog-blend": new s.D(s.t.sky["horizon-fog-blend"]),
          "sky-horizon-blend": new s.D(s.t.sky["sky-horizon-blend"]),
          "atmosphere-blend": new s.D(s.t.sky["atmosphere-blend"])
        });
        class vt extends s.E {
          constructor(e) {
            super(), this._transitionable = new s.x(Ht, void 0), this.setSky(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new s.G(0))
          }
          setSky(e, a = {}) {
            if (!this._validate(s.H, e, a)) {
              e || (e = {
                "sky-color": "transparent",
                "horizon-color": "transparent",
                "fog-color": "transparent",
                "fog-ground-blend": 1,
                "atmosphere-blend": 0
              });
              for (const o in e) {
                const c = e[o];
                o.endsWith("-transition") ? this._transitionable.setTransition(o.slice(0, -11), c) : this._transitionable.setValue(o, c)
              }
            }
          }
          getSky() {
            return this._transitionable.serialize()
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          _validate(e, a, o = {}) {
            return (o == null ? void 0 : o.validate) !== !1 && s.z(this, e.call(s.B, s.e({
              value: a,
              style: {
                glyphs: !0,
                sprite: !0
              },
              styleSpec: s.t
            })))
          }
          calculateFogBlendOpacity(e) {
            return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1
          }
        }
        class Dt {
          constructor(e, a) {
            this.width = e, this.height = a, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {}
          }
          getDash(e, a) {
            const o = e.join(",") + String(a);
            return this.dashEntry[o] || (this.dashEntry[o] = this.addDash(e, a)), this.dashEntry[o]
          }
          getDashRanges(e, a, o) {
            const c = [];
            let d = e.length % 2 == 1 ? -e[e.length - 1] * o : 0,
              g = e[0] * o,
              w = !0;
            c.push({
              left: d,
              right: g,
              isDash: w,
              zeroLength: e[0] === 0
            });
            let S = e[0];
            for (let A = 1; A < e.length; A++) {
              w = !w;
              const E = e[A];
              d = S * o, S += E, g = S * o, c.push({
                left: d,
                right: g,
                isDash: w,
                zeroLength: E === 0
              })
            }
            return c
          }
          addRoundDash(e, a, o) {
            const c = a / 2;
            for (let d = -o; d <= o; d++) {
              const g = this.width * (this.nextRow + o + d);
              let w = 0,
                S = e[w];
              for (let A = 0; A < this.width; A++) {
                A / S.right > 1 && (S = e[++w]);
                const E = Math.abs(A - S.left),
                  F = Math.abs(A - S.right),
                  R = Math.min(E, F);
                let U;
                const Y = d / o * (c + 1);
                if (S.isDash) {
                  const se = c - Math.abs(Y);
                  U = Math.sqrt(R * R + se * se)
                } else U = c - Math.sqrt(R * R + Y * Y);
                this.data[g + A] = Math.max(0, Math.min(255, U + 128))
              }
            }
          }
          addRegularDash(e) {
            for (let w = e.length - 1; w >= 0; --w) {
              const S = e[w],
                A = e[w + 1];
              S.zeroLength ? e.splice(w, 1) : A && A.isDash === S.isDash && (A.left = S.left, e.splice(w, 1))
            }
            const a = e[0],
              o = e[e.length - 1];
            a.isDash === o.isDash && (a.left = o.left - this.width, o.right = a.right + this.width);
            const c = this.width * this.nextRow;
            let d = 0,
              g = e[d];
            for (let w = 0; w < this.width; w++) {
              w / g.right > 1 && (g = e[++d]);
              const S = Math.abs(w - g.left),
                A = Math.abs(w - g.right),
                E = Math.min(S, A);
              this.data[c + w] = Math.max(0, Math.min(255, (g.isDash ? E : -E) + 128))
            }
          }
          addDash(e, a) {
            const o = a ? 7 : 0,
              c = 2 * o + 1;
            if (this.nextRow + c > this.height) return s.w("LineAtlas out of space"), null;
            let d = 0;
            for (let w = 0; w < e.length; w++) d += e[w];
            if (d !== 0) {
              const w = this.width / d,
                S = this.getDashRanges(e, this.width, w);
              a ? this.addRoundDash(S, w, o) : this.addRegularDash(S)
            }
            const g = {
              y: this.nextRow + o,
              height: 2 * o,
              width: d
            };
            return this.nextRow += c, this.dirty = !0, g
          }
          bind(e) {
            const a = e.gl;
            this.texture ? (a.bindTexture(a.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, this.width, this.height, a.ALPHA, a.UNSIGNED_BYTE, this.data))) : (this.texture = a.createTexture(), a.bindTexture(a.TEXTURE_2D, this.texture), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.REPEAT), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.REPEAT), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR), a.texImage2D(a.TEXTURE_2D, 0, a.ALPHA, this.width, this.height, 0, a.ALPHA, a.UNSIGNED_BYTE, this.data))
          }
        }
        const Rt = "maplibre_preloaded_worker_pool";
        class $t {
          constructor() {
            this.active = {}
          }
          acquire(e) {
            if (!this.workers)
              for (this.workers = []; this.workers.length < $t.workerCount;) this.workers.push(new Worker(s.a.WORKER_URL));
            return this.active[e] = !0, this.workers.slice()
          }
          release(e) {
            delete this.active[e], this.numActive() === 0 && (this.workers.forEach((a => {
              a.terminate()
            })), this.workers = null)
          }
          isPreloaded() {
            return !!this.active[Rt]
          }
          numActive() {
            return Object.keys(this.active).length
          }
        }
        const pr = Math.floor(oe.hardwareConcurrency / 2);
        let Xt, or;

        function nt() {
          return Xt || (Xt = new $t), Xt
        }
        $t.workerCount = s.J(globalThis) ? Math.max(Math.min(pr, 3), 1) : 1;
        class rt {
          constructor(e, a) {
            this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = a;
            const o = this.workerPool.acquire(a);
            for (let c = 0; c < o.length; c++) {
              const d = new s.K(o[c], a);
              d.name = `Worker ${c}`, this.actors.push(d)
            }
            if (!this.actors.length) throw new Error("No actors found")
          }
          broadcast(e, a) {
            const o = [];
            for (const c of this.actors) o.push(c.sendAsync({
              type: e,
              data: a
            }));
            return Promise.all(o)
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor]
          }
          remove(e = !0) {
            this.actors.forEach((a => {
              a.remove()
            })), this.actors = [], e && this.workerPool.release(this.id)
          }
          registerMessageHandler(e, a) {
            for (const o of this.actors) o.registerMessageHandler(e, a)
          }
        }

        function Zt() {
          return or || (or = new rt(nt(), s.L), or.registerMessageHandler("GR", ((h, e, a) => s.m(e, a)))), or
        }

        function Jt(h, e) {
          const a = s.M();
          return s.N(a, a, [1, 1, 0]), s.O(a, a, [.5 * h.width, .5 * h.height, 1]), h.calculatePosMatrix ? s.Q(a, a, h.calculatePosMatrix(e.toUnwrapped())) : a
        }

        function Ot(h, e, a, o, c, d, g) {
          var w;
          const S = (function(R, U, Y) {
              if (R)
                for (const se of R) {
                  const le = U[se];
                  if (le && le.source === Y && le.type === "fill-extrusion") return !0
                } else
                  for (const se in U) {
                    const le = U[se];
                    if (le.source === Y && le.type === "fill-extrusion") return !0
                  }
              return !1
            })((w = c == null ? void 0 : c.layers) !== null && w !== void 0 ? w : null, e, h.id),
            A = d.maxPitchScaleFactor(),
            E = h.tilesIn(o, A, S);
          E.sort(mr);
          const F = [];
          for (const R of E) F.push({
            wrappedTileID: R.tileID.wrapped().key,
            queryResults: R.tile.queryRenderedFeatures(e, a, h.getState(), R.queryGeometry, R.cameraQueryGeometry, R.scale, c, d, A, Jt(d, R.tileID), g ? (U, Y) => g(R.tileID, U, Y) : void 0)
          });
          return (function(R, U) {
            for (const Y in R)
              for (const se of R[Y]) At(se, U);
            return R
          })((function(R) {
            const U = {},
              Y = {};
            for (const se of R) {
              const le = se.queryResults,
                ce = se.wrappedTileID,
                ge = Y[ce] = Y[ce] || {};
              for (const Pe in le) {
                const fe = le[Pe],
                  Me = ge[Pe] = ge[Pe] || {},
                  Ee = U[Pe] = U[Pe] || [];
                for (const ve of fe) Me[ve.featureIndex] || (Me[ve.featureIndex] = !0, Ee.push(ve))
              }
            }
            return U
          })(F), h)
        }

        function mr(h, e) {
          const a = h.tileID,
            o = e.tileID;
          return a.overscaledZ - o.overscaledZ || a.canonical.y - o.canonical.y || a.wrap - o.wrap || a.canonical.x - o.canonical.x
        }

        function At(h, e) {
          const a = h.feature,
            o = e.getFeatureState(a.layer["source-layer"], a.id);
          a.source = a.layer.source, a.layer["source-layer"] && (a.sourceLayer = a.layer["source-layer"]), a.state = o
        }

        function Mt(h, e, a) {
          return s._(this, void 0, void 0, (function*() {
            let o = h;
            if (h.url ? o = (yield s.j(e.transformRequest(h.url, "Source"), a)).data : yield oe.frameAsync(a), !o) return null;
            const c = s.S(s.e(o, h), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in o && o.vector_layers && (c.vectorLayerIds = o.vector_layers.map((d => d.id))), c
          }))
        }
        class wt {
          constructor(e, a) {
            e && (a ? this.setSouthWest(e).setNorthEast(a) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])))
          }
          setNorthEast(e) {
            return this._ne = e instanceof s.U ? new s.U(e.lng, e.lat) : s.U.convert(e), this
          }
          setSouthWest(e) {
            return this._sw = e instanceof s.U ? new s.U(e.lng, e.lat) : s.U.convert(e), this
          }
          extend(e) {
            const a = this._sw,
              o = this._ne;
            let c, d;
            if (e instanceof s.U) c = e, d = e;
            else {
              if (!(e instanceof wt)) return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(wt.convert(e)) : this.extend(s.U.convert(e)) : e && ("lng" in e || "lon" in e) && "lat" in e ? this.extend(s.U.convert(e)) : this;
              if (c = e._sw, d = e._ne, !c || !d) return this
            }
            return a || o ? (a.lng = Math.min(c.lng, a.lng), a.lat = Math.min(c.lat, a.lat), o.lng = Math.max(d.lng, o.lng), o.lat = Math.max(d.lat, o.lat)) : (this._sw = new s.U(c.lng, c.lat), this._ne = new s.U(d.lng, d.lat)), this
          }
          getCenter() {
            return new s.U((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2)
          }
          getSouthWest() {
            return this._sw
          }
          getNorthEast() {
            return this._ne
          }
          getNorthWest() {
            return new s.U(this.getWest(), this.getNorth())
          }
          getSouthEast() {
            return new s.U(this.getEast(), this.getSouth())
          }
          getWest() {
            return this._sw.lng
          }
          getSouth() {
            return this._sw.lat
          }
          getEast() {
            return this._ne.lng
          }
          getNorth() {
            return this._ne.lat
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()]
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`
          }
          isEmpty() {
            return !(this._sw && this._ne)
          }
          contains(e) {
            const {
              lng: a,
              lat: o
            } = s.U.convert(e);
            let c = this._sw.lng <= a && a <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (c = this._sw.lng >= a && a >= this._ne.lng), this._sw.lat <= o && o <= this._ne.lat && c
          }
          intersects(e) {
            if ((e = wt.convert(e)).getNorth() < this.getSouth() || e.getSouth() > this.getNorth()) return !1;
            const a = s.V(this.getWest(), -180, 180),
              o = s.V(this.getEast(), -180, 180),
              c = s.V(e.getWest(), -180, 180),
              d = s.V(e.getEast(), -180, 180),
              g = a > o,
              w = c > d;
            return !(!g || !w) || (g ? d >= a || c <= o : w ? o >= c || a <= d : !(c > o || d < a))
          }
          static convert(e) {
            return e instanceof wt ? e : e && new wt(e)
          }
          static fromLngLat(e, a = 0) {
            const o = 360 * a / 40075017,
              c = o / Math.cos(Math.PI / 180 * e.lat);
            return new wt(new s.U(e.lng - c, e.lat - o), new s.U(e.lng + c, e.lat + o))
          }
          adjustAntiMeridian() {
            const e = new s.U(this._sw.lng, this._sw.lat),
              a = new s.U(this._ne.lng, this._ne.lat);
            return new wt(e, e.lng > a.lng ? new s.U(a.lng + 360, a.lat) : a)
          }
        }
        class It {
          constructor(e, a, o) {
            this.bounds = wt.convert(this.validateBounds(e)), this.minzoom = a || 0, this.maxzoom = o || 24
          }
          validateBounds(e) {
            return Array.isArray(e) && e.length === 4 ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90]
          }
          contains(e) {
            const a = Math.pow(2, e.z),
              o = Math.floor(s.X(this.bounds.getWest()) * a),
              c = Math.floor(s.W(this.bounds.getNorth()) * a),
              d = Math.ceil(s.X(this.bounds.getEast()) * a),
              g = Math.ceil(s.W(this.bounds.getSouth()) * a);
            return e.x >= o && e.x < d && e.y >= c && e.y < g
          }
        }
        class Ut extends s.E {
          constructor(e, a, o, c) {
            if (super(), this.id = e, this.dispatcher = o, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, s.e(this, s.S(a, ["url", "scheme", "tileSize", "promoteId"])), this._options = s.e({
                type: "vector"
              }, a), this._collectResourceTiming = a.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(c)
          }
          load() {
            return s._(this, void 0, void 0, (function*() {
              this._loaded = !1, this.fire(new s.l("dataloading", {
                dataType: "source"
              })), this._tileJSONRequest = new AbortController;
              try {
                const e = yield Mt(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, this.map.style.tileManagers[this.id].clearTiles(), e && (s.e(this, e), e.bounds && (this.tileBounds = new It(e.bounds, this.minzoom, this.maxzoom)), this.fire(new s.l("data", {
                  dataType: "source",
                  sourceDataType: "metadata"
                })), this.fire(new s.l("data", {
                  dataType: "source",
                  sourceDataType: "content"
                })))
              } catch (e) {
                this._tileJSONRequest = null, this._loaded = !0, this.fire(new s.k(e))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical)
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          setSourceProperty(e) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load()
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e
            })), this
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e
            })), this
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null)
          }
          serialize() {
            return s.e({}, this._options)
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              const a = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme),
                o = {
                  request: this.map._requestManager.transformRequest(a, "Tile"),
                  uid: e.uid,
                  tileID: e.tileID,
                  zoom: e.tileID.overscaledZ,
                  tileSize: this.tileSize * e.tileID.overscaleFactor(),
                  type: this.type,
                  source: this.id,
                  pixelRatio: this.map.getPixelRatio(),
                  showCollisionBoxes: this.map.showCollisionBoxes,
                  promoteId: this.promoteId,
                  subdivisionGranularity: this.map.style.projection.subdivisionGranularity
                };
              o.request.collectResourceTiming = this._collectResourceTiming;
              let c = "RT";
              if (e.actor && e.state !== "expired") {
                if (e.state === "loading") return new Promise(((d, g) => {
                  e.reloadPromise = {
                    resolve: d,
                    reject: g
                  }
                }))
              } else e.actor = this.dispatcher.getActor(), c = "LT";
              e.abortController = new AbortController;
              try {
                const d = yield e.actor.sendAsync({
                  type: c,
                  data: o
                }, e.abortController);
                if (delete e.abortController, e.aborted) return;
                this._afterTileLoadWorkerResponse(e, d)
              } catch (d) {
                if (delete e.abortController, e.aborted) return;
                if (d && d.status !== 404) throw d;
                this._afterTileLoadWorkerResponse(e, null)
              }
            }))
          }
          _afterTileLoadWorkerResponse(e, a) {
            if (a && a.resourceTiming && (e.resourceTiming = a.resourceTiming), a && this.map._refreshExpiredTiles && e.setExpiryData(a), e.loadVectorData(a, this.map.painter), e.reloadPromise) {
              const o = e.reloadPromise;
              e.reloadPromise = null, this.loadTile(e).then(o.resolve).catch(o.reject)
            }
          }
          abortTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && (yield e.actor.sendAsync({
                type: "AT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              }))
            }))
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.unloadVectorData(), e.actor && (yield e.actor.sendAsync({
                type: "RMT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              }))
            }))
          }
          hasTransition() {
            return !1
          }
        }
        class ut extends s.E {
          constructor(e, a, o, c) {
            super(), this.id = e, this.dispatcher = o, this.setEventedParent(c), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = s.e({
              type: "raster"
            }, a), s.e(this, s.S(a, ["url", "scheme", "tileSize"]))
          }
          load() {
            return s._(this, arguments, void 0, (function*(e = !1) {
              this._loaded = !1, this.fire(new s.l("dataloading", {
                dataType: "source"
              })), this._tileJSONRequest = new AbortController;
              try {
                const a = yield Mt(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, a && (s.e(this, a), a.bounds && (this.tileBounds = new It(a.bounds, this.minzoom, this.maxzoom)), this.fire(new s.l("data", {
                  dataType: "source",
                  sourceDataType: "metadata"
                })), this.fire(new s.l("data", {
                  dataType: "source",
                  sourceDataType: "content",
                  sourceDataChanged: e
                })))
              } catch (a) {
                this._tileJSONRequest = null, this._loaded = !0, this.fire(new s.k(a))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null)
          }
          setSourceProperty(e) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e(), this.load(!0)
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e
            })), this
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e
            })), this
          }
          serialize() {
            return s.e({}, this._options)
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical)
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              const a = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              e.abortController = new AbortController;
              try {
                const o = yield Xe.getImage(this.map._requestManager.transformRequest(a, "Tile"), e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void(e.state = "unloaded");
                if (o && o.data) {
                  this.map._refreshExpiredTiles && (o.cacheControl || o.expires) && e.setExpiryData({
                    cacheControl: o.cacheControl,
                    expires: o.expires
                  });
                  const c = this.map.painter.context,
                    d = c.gl,
                    g = o.data;
                  e.texture = this.map.painter.getTileTexture(g.width), e.texture ? e.texture.update(g, {
                    useMipmap: !0
                  }) : (e.texture = new s.T(c, g, d.RGBA, {
                    useMipmap: !0
                  }), e.texture.bind(d.LINEAR, d.CLAMP_TO_EDGE, d.LINEAR_MIPMAP_NEAREST)), e.state = "loaded"
                }
              } catch (o) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (o) throw e.state = "errored", o
              }
            }))
          }
          abortTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController)
            }))
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.texture && this.map.painter.saveTileTexture(e.texture)
            }))
          }
          hasTransition() {
            return !1
          }
        }
        class ur extends ut {
          constructor(e, a, o, c) {
            super(e, a, o, c), this.type = "raster-dem", this.maxzoom = 22, this._options = s.e({
              type: "raster-dem"
            }, a), this.encoding = a.encoding || "mapbox", this.redFactor = a.redFactor, this.greenFactor = a.greenFactor, this.blueFactor = a.blueFactor, this.baseShift = a.baseShift
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              const a = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme),
                o = this.map._requestManager.transformRequest(a, "Tile");
              e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController;
              try {
                const c = yield Xe.getImage(o, e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void(e.state = "unloaded");
                if (c && c.data) {
                  const d = c.data;
                  this.map._refreshExpiredTiles && (c.cacheControl || c.expires) && e.setExpiryData({
                    cacheControl: c.cacheControl,
                    expires: c.expires
                  });
                  const g = s.b(d) && s.Y() ? d : yield this.readImageNow(d), w = {
                    type: this.type,
                    uid: e.uid,
                    source: this.id,
                    rawImageData: g,
                    encoding: this.encoding,
                    redFactor: this.redFactor,
                    greenFactor: this.greenFactor,
                    blueFactor: this.blueFactor,
                    baseShift: this.baseShift
                  };
                  if (!e.actor || e.state === "expired") {
                    e.actor = this.dispatcher.getActor();
                    const S = yield e.actor.sendAsync({
                      type: "LDT",
                      data: w
                    });
                    e.dem = S, e.needsHillshadePrepare = !0, e.needsTerrainPrepare = !0, e.state = "loaded"
                  }
                }
              } catch (c) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (c) throw e.state = "errored", c
              }
            }))
          }
          readImageNow(e) {
            return s._(this, void 0, void 0, (function*() {
              if (typeof VideoFrame < "u" && s.Z()) {
                const a = e.width + 2,
                  o = e.height + 2;
                try {
                  return new s.R({
                    width: a,
                    height: o
                  }, yield s.$(e, -1, -1, a, o))
                } catch {}
              }
              return oe.getImageData(e, 1)
            }))
          }
          _getNeighboringTiles(e) {
            const a = e.canonical,
              o = Math.pow(2, a.z),
              c = (a.x - 1 + o) % o,
              d = a.x === 0 ? e.wrap - 1 : e.wrap,
              g = (a.x + 1 + o) % o,
              w = a.x + 1 === o ? e.wrap + 1 : e.wrap,
              S = {};
            return S[new s.a0(e.overscaledZ, d, a.z, c, a.y).key] = {
              backfilled: !1
            }, S[new s.a0(e.overscaledZ, w, a.z, g, a.y).key] = {
              backfilled: !1
            }, a.y > 0 && (S[new s.a0(e.overscaledZ, d, a.z, c, a.y - 1).key] = {
              backfilled: !1
            }, S[new s.a0(e.overscaledZ, e.wrap, a.z, a.x, a.y - 1).key] = {
              backfilled: !1
            }, S[new s.a0(e.overscaledZ, w, a.z, g, a.y - 1).key] = {
              backfilled: !1
            }), a.y + 1 < o && (S[new s.a0(e.overscaledZ, d, a.z, c, a.y + 1).key] = {
              backfilled: !1
            }, S[new s.a0(e.overscaledZ, e.wrap, a.z, a.x, a.y + 1).key] = {
              backfilled: !1
            }, S[new s.a0(e.overscaledZ, w, a.z, g, a.y + 1).key] = {
              backfilled: !1
            }), S
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && (yield e.actor.sendAsync({
                type: "RDT",
                data: {
                  type: this.type,
                  uid: e.uid,
                  source: this.id
                }
              }))
            }))
          }
        }

        function br(h) {
          return h.type === "GeometryCollection" ? h.geometries.map((e => e.coordinates)).flat(1 / 0) : h.coordinates.flat(1 / 0)
        }

        function cr(h) {
          const e = new wt;
          let a;
          switch (h.type) {
            case "FeatureCollection":
              a = h.features.map((o => br(o.geometry))).flat(1 / 0);
              break;
            case "Feature":
              a = br(h.geometry);
              break;
            default:
              a = br(h)
          }
          if (a.length == 0) return e;
          for (let o = 0; o < a.length - 1; o += 2) e.extend([a[o], a[o + 1]]);
          return e
        }
        class jr extends s.E {
          constructor(e, a, o, c) {
            super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._isUpdatingWorker = !1, this._pendingWorkerUpdate = {
              data: a.data
            }, this.actor = o.getActor(), this.setEventedParent(c), this._data = a.data, this._options = s.e({}, a), this._collectResourceTiming = a.collectResourceTiming, a.maxzoom !== void 0 && (this.maxzoom = a.maxzoom), a.type && (this.type = a.type), a.attribution && (this.attribution = a.attribution), this.promoteId = a.promoteId, a.clusterMaxZoom !== void 0 && this.maxzoom <= a.clusterMaxZoom && s.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${a.clusterMaxZoom}".`), this.workerOptions = s.e({
              source: this.id,
              cluster: a.cluster || !1,
              geojsonVtOptions: {
                buffer: this._pixelsToTileUnits(a.buffer !== void 0 ? a.buffer : 128),
                tolerance: this._pixelsToTileUnits(a.tolerance !== void 0 ? a.tolerance : .375),
                extent: s.a3,
                maxZoom: this.maxzoom,
                lineMetrics: a.lineMetrics || !1,
                generateId: a.generateId || !1
              },
              superclusterOptions: {
                maxZoom: this._getClusterMaxZoom(a.clusterMaxZoom),
                minPoints: Math.max(2, a.clusterMinPoints || 2),
                extent: s.a3,
                radius: this._pixelsToTileUnits(a.clusterRadius || 50),
                log: !1,
                generateId: a.generateId || !1
              },
              clusterProperties: a.clusterProperties,
              filter: a.filter
            }, a.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId)
          }
          _hasPendingWorkerUpdate() {
            return this._pendingWorkerUpdate.data !== void 0 || this._pendingWorkerUpdate.diff !== void 0 || this._pendingWorkerUpdate.optionsChanged
          }
          _pixelsToTileUnits(e) {
            return e * (s.a3 / this.tileSize)
          }
          _getClusterMaxZoom(e) {
            const a = e ? Math.round(e) : this.maxzoom - 1;
            return Number.isInteger(e) || e === void 0 || s.w(`Integer expected for option 'clusterMaxZoom': provided value "${e}" rounded to "${a}"`), a
          }
          load() {
            return s._(this, void 0, void 0, (function*() {
              yield this._updateWorkerData()
            }))
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          setData(e) {
            return this._data = e, this._pendingWorkerUpdate = {
              data: e
            }, this._updateWorkerData(), this
          }
          updateData(e) {
            return this._pendingWorkerUpdate.diff = s.a4(this._pendingWorkerUpdate.diff, e), this._updateWorkerData(), this
          }
          getData() {
            return s._(this, void 0, void 0, (function*() {
              const e = s.e({
                type: this.type
              }, this.workerOptions);
              return this.actor.sendAsync({
                type: "GD",
                data: e
              })
            }))
          }
          getBounds() {
            return s._(this, void 0, void 0, (function*() {
              return cr(yield this.getData())
            }))
          }
          setClusterOptions(e) {
            return this.workerOptions.cluster = e.cluster, e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e.clusterRadius)), e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(e.clusterMaxZoom)), this._pendingWorkerUpdate.optionsChanged = !0, this._updateWorkerData(), this
          }
          getClusterExpansionZoom(e) {
            return this.actor.sendAsync({
              type: "GCEZ",
              data: {
                type: this.type,
                clusterId: e,
                source: this.id
              }
            })
          }
          getClusterChildren(e) {
            return this.actor.sendAsync({
              type: "GCC",
              data: {
                type: this.type,
                clusterId: e,
                source: this.id
              }
            })
          }
          getClusterLeaves(e, a, o) {
            return this.actor.sendAsync({
              type: "GCL",
              data: {
                type: this.type,
                source: this.id,
                clusterId: e,
                limit: a,
                offset: o
              }
            })
          }
          _updateWorkerData() {
            return s._(this, void 0, void 0, (function*() {
              if (this._isUpdatingWorker) return;
              if (!this._hasPendingWorkerUpdate()) return void s.w(`No pending worker updates for GeoJSONSource ${this.id}.`);
              const {
                data: e,
                diff: a
              } = this._pendingWorkerUpdate, o = s.e({
                type: this.type
              }, this.workerOptions);
              e ? (typeof e == "string" ? (o.request = this.map._requestManager.transformRequest(oe.resolveURL(e), "Source"), o.request.collectResourceTiming = this._collectResourceTiming) : o.data = JSON.stringify(e), this._pendingWorkerUpdate.data = void 0) : a && (o.dataDiff = a, this._pendingWorkerUpdate.diff = void 0), this._pendingWorkerUpdate.optionsChanged = void 0, this._isUpdatingWorker = !0, this.fire(new s.l("dataloading", {
                dataType: "source"
              }));
              try {
                const c = yield this.actor.sendAsync({
                  type: "LD",
                  data: o
                });
                if (this._isUpdatingWorker = !1, this._removed || c.abandoned) return void this.fire(new s.l("dataabort", {
                  dataType: "source"
                }));
                this._data = c.data;
                let d = null;
                c.resourceTiming && c.resourceTiming[this.id] && (d = c.resourceTiming[this.id].slice(0));
                const g = {
                  dataType: "source"
                };
                this._collectResourceTiming && d && d.length > 0 && s.e(g, {
                  resourceTiming: d
                }), this.fire(new s.l("data", Object.assign(Object.assign({}, g), {
                  sourceDataType: "metadata"
                }))), this.fire(new s.l("data", Object.assign(Object.assign({}, g), {
                  sourceDataType: "content",
                  shouldReloadTileOptions: this._getShouldReloadTileOptions(a)
                })))
              } catch (c) {
                if (this._isUpdatingWorker = !1, this._removed) return void this.fire(new s.l("dataabort", {
                  dataType: "source"
                }));
                this.fire(new s.k(c))
              } finally {
                this._hasPendingWorkerUpdate() && this._updateWorkerData()
              }
            }))
          }
          _getShouldReloadTileOptions(e) {
            if (!e || e.removeAll) return;
            const {
              add: a = [],
              update: o = [],
              remove: c = []
            } = e || {}, d = new Set([...o.map((g => g.id)), ...c]);
            return {
              nextBounds: [...o.map((g => g.newGeometry)), ...a.map((g => g.geometry))].map((g => cr(g))),
              prevIds: d
            }
          }
          shouldReloadTile(e, {
            nextBounds: a,
            prevIds: o
          }) {
            const c = e.latestFeatureIndex.loadVTLayers();
            for (let S = 0; S < e.latestFeatureIndex.featureIndexArray.length; S++) {
              const A = e.latestFeatureIndex.featureIndexArray.get(S),
                E = c._geojsonTileLayer.feature(A.featureIndex);
              if (o.has(E.id)) return !0
            }
            const {
              buffer: d,
              extent: g
            } = this.workerOptions.geojsonVtOptions, w = (function({
              x: S,
              y: A,
              z: E
            }, F = 0) {
              const R = s.a1((S - F) / Math.pow(2, E)),
                U = s.a2((A + 1 + F) / Math.pow(2, E)),
                Y = s.a1((S + 1 + F) / Math.pow(2, E)),
                se = s.a2((A - F) / Math.pow(2, E));
              return new wt([R, U], [Y, se])
            })(e.tileID.canonical, d / g);
            for (const S of a)
              if (w.intersects(S)) return !0;
            return !1
          }
          loaded() {
            return !this._isUpdatingWorker && !this._hasPendingWorkerUpdate()
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              const a = e.actor ? "RT" : "LT";
              e.actor = this.actor;
              const o = {
                type: this.type,
                uid: e.uid,
                tileID: e.tileID,
                zoom: e.tileID.overscaledZ,
                maxZoom: this.maxzoom,
                tileSize: this.tileSize,
                source: this.id,
                pixelRatio: this.map.getPixelRatio(),
                showCollisionBoxes: this.map.showCollisionBoxes,
                promoteId: this.promoteId,
                subdivisionGranularity: this.map.style.projection.subdivisionGranularity
              };
              e.abortController = new AbortController;
              const c = yield this.actor.sendAsync({
                type: a,
                data: o
              }, e.abortController);
              delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(c, this.map.painter, a === "RT")
            }))
          }
          abortTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = !0
            }))
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.unloadVectorData(), yield this.actor.sendAsync({
                type: "RMT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              })
            }))
          }
          onRemove() {
            this._removed = !0, this.actor.sendAsync({
              type: "RS",
              data: {
                type: this.type,
                source: this.id
              }
            })
          }
          serialize() {
            return s.e({}, this._options, {
              type: this.type,
              data: this._data
            })
          }
          hasTransition() {
            return !1
          }
        }
        class wr extends s.E {
          constructor(e, a, o, c) {
            super(), this.flippedWindingOrder = !1, this.id = e, this.dispatcher = o, this.coordinates = a.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(c), this.options = a
          }
          load(e) {
            return s._(this, void 0, void 0, (function*() {
              this._loaded = !1, this.fire(new s.l("dataloading", {
                dataType: "source"
              })), this.url = this.options.url, this._request = new AbortController;
              try {
                const a = yield Xe.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = !0, a && a.data && (this.image = a.data, e && (this.coordinates = e), this._finishLoading())
              } catch (a) {
                this._request = null, this._loaded = !0, this.fire(new s.k(a))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          updateImage(e) {
            return e.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e.url, this.load(e.coordinates).finally((() => {
              this.texture = null
            })), this) : this
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new s.l("data", {
              dataType: "source",
              sourceDataType: "metadata"
            })))
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null)
          }
          setCoordinates(e) {
            this.coordinates = e;
            const a = e.map(s.a5.fromLngLat);
            var o;
            return this.tileID = (function(c) {
              const d = s.a6.fromPoints(c),
                g = d.width(),
                w = d.height(),
                S = Math.max(g, w),
                A = Math.max(0, Math.floor(-Math.log(S) / Math.LN2)),
                E = Math.pow(2, A);
              return new s.a8(A, Math.floor((d.minX + d.maxX) / 2 * E), Math.floor((d.minY + d.maxY) / 2 * E))
            })(a), this.terrainTileRanges = this._getOverlappingTileRanges(a), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = a.map((c => this.tileID.getTilePoint(c)._round())), this.flippedWindingOrder = ((o = this.tileCoords)[1].x - o[0].x) * (o[2].y - o[0].y) - (o[1].y - o[0].y) * (o[2].x - o[0].x) < 0, this.fire(new s.l("data", {
              dataType: "source",
              sourceDataType: "content"
            })), this
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || !this.image) return;
            const e = this.map.painter.context,
              a = e.gl;
            this.texture || (this.texture = new s.T(e, this.image, a.RGBA), this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE));
            let o = !1;
            for (const c in this.tiles) {
              const d = this.tiles[c];
              d.state !== "loaded" && (d.state = "loaded", d.texture = this.texture, o = !0)
            }
            o && this.fire(new s.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}) : e.state = "errored"
            }))
          }
          serialize() {
            return {
              type: "image",
              url: this.options.url,
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return !1
          }
          _getOverlappingTileRanges(e) {
            const {
              minX: a,
              minY: o,
              maxX: c,
              maxY: d
            } = s.a6.fromPoints(e), g = {};
            for (let w = 0; w <= s.a7; w++) {
              const S = Math.pow(2, w),
                A = Math.floor(a * S),
                E = Math.floor(o * S),
                F = Math.floor(c * S),
                R = Math.floor(d * S);
              g[w] = {
                minTileX: A,
                minTileY: E,
                maxTileX: F,
                maxTileY: R
              }
            }
            return g
          }
        }
        class Nr extends wr {
          constructor(e, a, o, c) {
            super(e, a, o, c), this.roundZoom = !0, this.type = "video", this.options = a
          }
          load() {
            return s._(this, void 0, void 0, (function*() {
              this._loaded = !1;
              const e = this.options;
              this.urls = [];
              for (const a of e.urls) this.urls.push(this.map._requestManager.transformRequest(a, "Source").url);
              try {
                const a = yield s.a9(this.urls);
                if (this._loaded = !0, !a) return;
                this.video = a, this.video.loop = !0, this.video.addEventListener("playing", (() => {
                  this.map.triggerRepaint()
                })), this.map && this.video.play(), this._finishLoading()
              } catch (a) {
                this.fire(new s.k(a))
              }
            }))
          }
          pause() {
            this.video && this.video.pause()
          }
          play() {
            this.video && this.video.play()
          }
          seek(e) {
            if (this.video) {
              const a = this.video.seekable;
              e < a.start(0) || e > a.end(0) ? this.fire(new s.k(new s.aa(`sources.${this.id}`, null, `Playback for this video can be set only between the ${a.start(0)} and ${a.end(0)}-second mark.`))) : this.video.currentTime = e
            }
          }
          getVideo() {
            return this.video
          }
          onAdd(e) {
            this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)))
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
            const e = this.map.painter.context,
              a = e.gl;
            this.texture ? this.video.paused || (this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE), a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, a.RGBA, a.UNSIGNED_BYTE, this.video)) : (this.texture = new s.T(e, this.video, a.RGBA), this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE));
            let o = !1;
            for (const c in this.tiles) {
              const d = this.tiles[c];
              d.state !== "loaded" && (d.state = "loaded", d.texture = this.texture, o = !0)
            }
            o && this.fire(new s.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          serialize() {
            return {
              type: "video",
              urls: this.urls,
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return this.video && !this.video.paused
          }
        }
        class Gr extends wr {
          constructor(e, a, o, c) {
            super(e, a, o, c), a.coordinates ? Array.isArray(a.coordinates) && a.coordinates.length === 4 && !a.coordinates.some((d => !Array.isArray(d) || d.length !== 2 || d.some((g => typeof g != "number")))) || this.fire(new s.k(new s.aa(`sources.${e}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new s.k(new s.aa(`sources.${e}`, null, 'missing required property "coordinates"'))), a.animate && typeof a.animate != "boolean" && this.fire(new s.k(new s.aa(`sources.${e}`, null, 'optional "animate" property must be a boolean value'))), a.canvas ? typeof a.canvas == "string" || a.canvas instanceof HTMLCanvasElement || this.fire(new s.k(new s.aa(`sources.${e}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new s.k(new s.aa(`sources.${e}`, null, 'missing required property "canvas"'))), this.options = a, this.animate = a.animate === void 0 || a.animate
          }
          load() {
            return s._(this, void 0, void 0, (function*() {
              this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new s.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = !0, this.map.triggerRepaint()
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = !1)
              }, this._finishLoading())
            }))
          }
          getCanvas() {
            return this.canvas
          }
          onAdd(e) {
            this.map = e, this.load(), this.canvas && this.animate && this.play()
          }
          onRemove() {
            this.pause()
          }
          prepare() {
            let e = !1;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
            const a = this.map.painter.context,
              o = a.gl;
            this.texture ? (e || this._playing) && this.texture.update(this.canvas, {
              premultiply: !0
            }) : this.texture = new s.T(a, this.canvas, o.RGBA, {
              premultiply: !0
            });
            let c = !1;
            for (const d in this.tiles) {
              const g = this.tiles[d];
              g.state !== "loaded" && (g.state = "loaded", g.texture = this.texture, c = !0)
            }
            c && this.fire(new s.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          serialize() {
            return {
              type: "canvas",
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return this._playing
          }
          _hasInvalidDimensions() {
            for (const e of [this.canvas.width, this.canvas.height])
              if (isNaN(e) || e <= 0) return !0;
            return !1
          }
        }
        const er = {},
          Wr = h => {
            switch (h) {
              case "geojson":
                return jr;
              case "image":
                return wr;
              case "raster":
                return ut;
              case "raster-dem":
                return ur;
              case "vector":
                return Ut;
              case "video":
                return Nr;
              case "canvas":
                return Gr
            }
            return er[h]
          },
          sr = "RTLPluginLoaded";
        class de extends s.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = Zt()
          }
          _syncState(e) {
            return this.status = e, this.dispatcher.broadcast("SRPS", {
              pluginStatus: e,
              pluginURL: this.url
            }).catch((a => {
              throw this.status = "error", a
            }))
          }
          getRTLTextPluginStatus() {
            return this.status
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null
          }
          setRTLTextPlugin(e) {
            return s._(this, arguments, void 0, (function*(a, o = !1) {
              if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (this.url = oe.resolveURL(a), !this.url) throw new Error(`requested url ${a} is invalid`);
              if (this.status === "unavailable") {
                if (!o) return this._requestImport();
                this.status = "deferred", this._syncState(this.status)
              } else if (this.status === "requested") return this._requestImport()
            }))
          }
          _requestImport() {
            return s._(this, void 0, void 0, (function*() {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new s.l(sr))
            }))
          }
          lazyLoad() {
            this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport()
          }
        }
        let j = null;

        function V() {
          return j || (j = new de), j
        }
        var X, re;
        (function(h) {
          h[h.Base = 0] = "Base", h[h.Parent = 1] = "Parent"
        })(X || (X = {})), (function(h) {
          h[h.Departing = 0] = "Departing", h[h.Incoming = 1] = "Incoming"
        })(re || (re = {}));
        class Q {
          constructor(e, a) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.fadeOpacity = 1, this.tileID = e, this.uid = s.ab(), this.uses = 0, this.tileSize = a, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading"
          }
          isRenderable(e) {
            return this.hasData() && (!this.fadeEndTime || this.fadeOpacity > 0) && (e || !this.holdingForSymbolFade())
          }
          setCrossFadeLogic({
            fadingRole: e,
            fadingDirection: a,
            fadingParentID: o,
            fadeEndTime: c
          }) {
            this.resetFadeLogic(), this.fadingRole = e, this.fadingDirection = a, this.fadingParentID = o, this.fadeEndTime = c
          }
          setSelfFadeLogic(e) {
            this.resetFadeLogic(), this.selfFading = !0, this.fadeEndTime = e
          }
          resetFadeLogic() {
            this.fadingRole = null, this.fadingDirection = null, this.fadingParentID = null, this.selfFading = !1, this.timeAdded = _e(), this.fadeEndTime = 0, this.fadeOpacity = 1
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading"
          }
          clearTextures(e) {
            this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null
          }
          loadVectorData(e, a, o) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e) {
              e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = (function(c, d) {
                const g = {};
                if (!d) return g;
                for (const w of c) {
                  const S = w.layerIds.map((A => d.getLayer(A))).filter(Boolean);
                  if (S.length !== 0) {
                    w.layers = S, w.stateDependentLayerIds && (w.stateDependentLayers = w.stateDependentLayerIds.map((A => S.filter((E => E.id === A))[0])));
                    for (const A of S) g[A.id] = w
                  }
                }
                return g
              })(e.buckets, a == null ? void 0 : a.style), this.hasSymbolBuckets = !1;
              for (const c in this.buckets) {
                const d = this.buckets[c];
                if (d instanceof s.ad) {
                  if (this.hasSymbolBuckets = !0, !o) break;
                  d.justReloaded = !0
                }
              }
              if (this.hasRTLText = !1, this.hasSymbolBuckets)
                for (const c in this.buckets) {
                  const d = this.buckets[c];
                  if (d instanceof s.ad && d.hasRTLText) {
                    this.hasRTLText = !0, V().lazyLoad();
                    break
                  }
                }
              this.queryPadding = 0;
              for (const c in this.buckets) {
                const d = this.buckets[c];
                this.queryPadding = Math.max(this.queryPadding, a.style.getLayer(c).queryRadius(d))
              }
              e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage), this.dashPositions = e.dashPositions
            } else this.collisionBoxArray = new s.ac
          }
          unloadVectorData() {
            for (const e in this.buckets) this.buckets[e].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.dashPositions && (this.dashPositions = null), this.latestFeatureIndex = null, this.state = "unloaded"
          }
          getBucket(e) {
            return this.buckets[e.id]
          }
          upload(e) {
            for (const o in this.buckets) {
              const c = this.buckets[o];
              c.uploadPending() && c.upload(e)
            }
            const a = e.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new s.T(e, this.imageAtlas.image, a.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new s.T(e, this.glyphAtlasImage, a.ALPHA), this.glyphAtlasImage = null)
          }
          prepare(e) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture)
          }
          queryRenderedFeatures(e, a, o, c, d, g, w, S, A, E, F) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
              queryGeometry: c,
              cameraQueryGeometry: d,
              scale: g,
              tileSize: this.tileSize,
              pixelPosMatrix: E,
              transform: S,
              params: w,
              queryPadding: this.queryPadding * A,
              getElevation: F
            }, e, a, o) : {}
          }
          querySourceFeatures(e, a) {
            const o = this.latestFeatureIndex;
            if (!o || !o.rawTileData) return;
            const c = o.loadVTLayers(),
              d = a && a.sourceLayer ? a.sourceLayer : "",
              g = c._geojsonTileLayer || c[d];
            if (!g) return;
            const w = s.ae(a == null ? void 0 : a.filter, a == null ? void 0 : a.globalState),
              {
                z: S,
                x: A,
                y: E
              } = this.tileID.canonical,
              F = {
                z: S,
                x: A,
                y: E
              };
            for (let R = 0; R < g.length; R++) {
              const U = g.feature(R);
              if (w.needGeometry) {
                const le = s.af(U, !0);
                if (!w.filter(new s.G(this.tileID.overscaledZ), le, this.tileID.canonical)) continue
              } else if (!w.filter(new s.G(this.tileID.overscaledZ), U)) continue;
              const Y = o.getId(U, d),
                se = new s.ag(U, S, A, E, Y);
              se.tile = F, e.push(se)
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired"
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length
          }
          setExpiryData(e) {
            const a = this.expirationTime;
            if (e.cacheControl) {
              const o = s.ah(e.cacheControl);
              o["max-age"] && (this.expirationTime = Date.now() + 1e3 * o["max-age"])
            } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
            if (this.expirationTime) {
              const o = Date.now();
              let c = !1;
              if (this.expirationTime > o) c = !1;
              else if (a)
                if (this.expirationTime < a) c = !0;
                else {
                  const d = this.expirationTime - a;
                  d ? this.expirationTime = o + Math.max(d, 3e4) : c = !0
                }
              else c = !0;
              c ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1)
          }
          setFeatureState(e, a) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0) return;
            const o = this.latestFeatureIndex.loadVTLayers();
            for (const c in this.buckets) {
              if (!a.style.hasLayer(c)) continue;
              const d = this.buckets[c],
                g = d.layers[0].sourceLayer || "_geojsonTileLayer",
                w = o[g],
                S = e[g];
              if (!w || !S || Object.keys(S).length === 0) continue;
              d.update(S, w, this.imageAtlas && this.imageAtlas.patternPositions || {}, this.dashPositions || {});
              const A = a && a.style && a.style.getLayer(c);
              A && (this.queryPadding = Math.max(this.queryPadding, A.queryRadius(d)))
            }
          }
          holdingForSymbolFade() {
            return this.symbolFadeHoldUntil !== void 0
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < _e()
          }
          clearSymbolFadeHold() {
            this.symbolFadeHoldUntil = void 0
          }
          setSymbolHoldDuration(e) {
            this.symbolFadeHoldUntil = _e() + e
          }
          setDependencies(e, a) {
            const o = {};
            for (const c of a) o[c] = !0;
            this.dependencies[e] = o
          }
          hasDependency(e, a) {
            for (const o of e) {
              const c = this.dependencies[o];
              if (c) {
                for (const d of a)
                  if (c[d]) return !0
              }
            }
            return !1
          }
        }
        class ue {
          constructor(e, a) {
            this.max = e, this.onRemove = a, this.reset()
          }
          reset() {
            for (const e in this.data)
              for (const a of this.data[e]) a.timeout && clearTimeout(a.timeout), this.onRemove(a.value);
            return this.data = {}, this.order = [], this
          }
          add(e, a, o) {
            const c = e.wrapped().key;
            this.data[c] === void 0 && (this.data[c] = []);
            const d = {
              value: a,
              timeout: void 0
            };
            if (o !== void 0 && (d.timeout = setTimeout((() => {
                this.remove(e, d)
              }), o)), this.data[c].push(d), this.order.push(c), this.order.length > this.max) {
              const g = this._getAndRemoveByKey(this.order[0]);
              g && this.onRemove(g)
            }
            return this
          }
          has(e) {
            return e.wrapped().key in this.data
          }
          getAndRemove(e) {
            return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null
          }
          _getAndRemoveByKey(e) {
            const a = this.data[e].shift();
            return a.timeout && clearTimeout(a.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), a.value
          }
          getByKey(e) {
            const a = this.data[e];
            return a ? a[0].value : null
          }
          get(e) {
            return this.has(e) ? this.data[e.wrapped().key][0].value : null
          }
          remove(e, a) {
            if (!this.has(e)) return this;
            const o = e.wrapped().key,
              c = a === void 0 ? 0 : this.data[o].indexOf(a),
              d = this.data[o][c];
            return this.data[o].splice(c, 1), d.timeout && clearTimeout(d.timeout), this.data[o].length === 0 && delete this.data[o], this.onRemove(d.value), this.order.splice(this.order.indexOf(o), 1), this
          }
          setMaxSize(e) {
            for (this.max = e; this.order.length > this.max;) {
              const a = this._getAndRemoveByKey(this.order[0]);
              a && this.onRemove(a)
            }
            return this
          }
          filter(e) {
            const a = [];
            for (const o in this.data)
              for (const c of this.data[o]) e(c.value) || a.push(c);
            for (const o of a) this.remove(o.value.tileID, o)
          }
        }
        class Te {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {}
          }
          updateState(e, a, o) {
            const c = String(a);
            if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][c] = this.stateChanges[e][c] || {}, s.e(this.stateChanges[e][c], o), this.deletedStates[e] === null) {
              this.deletedStates[e] = {};
              for (const d in this.state[e]) d !== c && (this.deletedStates[e][d] = null)
            } else if (this.deletedStates[e] && this.deletedStates[e][c] === null) {
              this.deletedStates[e][c] = {};
              for (const d in this.state[e][c]) o[d] || (this.deletedStates[e][c][d] = null)
            } else
              for (const d in o) this.deletedStates[e] && this.deletedStates[e][c] && this.deletedStates[e][c][d] === null && delete this.deletedStates[e][c][d]
          }
          removeFeatureState(e, a, o) {
            if (this.deletedStates[e] === null) return;
            const c = String(a);
            if (this.deletedStates[e] = this.deletedStates[e] || {}, o && a !== void 0) this.deletedStates[e][c] !== null && (this.deletedStates[e][c] = this.deletedStates[e][c] || {}, this.deletedStates[e][c][o] = null);
            else if (a !== void 0)
              if (this.stateChanges[e] && this.stateChanges[e][c])
                for (o in this.deletedStates[e][c] = {}, this.stateChanges[e][c]) this.deletedStates[e][c][o] = null;
              else this.deletedStates[e][c] = null;
            else this.deletedStates[e] = null
          }
          getState(e, a) {
            const o = String(a),
              c = s.e({}, (this.state[e] || {})[o], (this.stateChanges[e] || {})[o]);
            if (this.deletedStates[e] === null) return {};
            if (this.deletedStates[e]) {
              const d = this.deletedStates[e][a];
              if (d === null) return {};
              for (const g in d) delete c[g]
            }
            return c
          }
          initializeTileState(e, a) {
            e.setFeatureState(this.state, a)
          }
          coalesceChanges(e, a) {
            const o = {};
            for (const c in this.stateChanges) {
              this.state[c] = this.state[c] || {};
              const d = {};
              for (const g in this.stateChanges[c]) this.state[c][g] || (this.state[c][g] = {}), s.e(this.state[c][g], this.stateChanges[c][g]), d[g] = this.state[c][g];
              o[c] = d
            }
            for (const c in this.deletedStates) {
              this.state[c] = this.state[c] || {};
              const d = {};
              if (this.deletedStates[c] === null)
                for (const g in this.state[c]) d[g] = {}, this.state[c][g] = {};
              else
                for (const g in this.deletedStates[c]) {
                  if (this.deletedStates[c][g] === null) this.state[c][g] = {};
                  else
                    for (const w of Object.keys(this.deletedStates[c][g])) delete this.state[c][g][w];
                  d[g] = this.state[c][g]
                }
              o[c] = o[c] || {}, s.e(o[c], d)
            }
            if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(o).length !== 0)
              for (const c in e) e[c].setFeatureState(o, a)
          }
        }
        const be = 89.25;

        function ze(h, e) {
          const a = s.ai(e.lat, -s.aj, s.aj);
          return new s.P(s.X(e.lng) * h, s.W(a) * h)
        }

        function We(h, e) {
          return new s.a5(e.x / h, e.y / h).toLngLat()
        }

        function Be(h) {
          return h.cameraToCenterDistance * Math.min(.85 * Math.tan(s.ak(90 - h.pitch)), Math.tan(s.ak(be - h.pitch)))
        }

        function ae(h, e) {
          const a = h.canonical,
            o = e / s.al(a.z),
            c = a.x + Math.pow(2, a.z) * h.wrap,
            d = s.am(new Float64Array(16));
          return s.N(d, d, [c * o, a.y * o, 0]), s.O(d, d, [o / s.a3, o / s.a3, 1]), d
        }

        function J(h, e, a, o, c) {
          const d = s.a5.fromLngLat(h, e),
            g = c * s.an(1, h.lat),
            w = g * Math.cos(s.ak(a)),
            S = Math.sqrt(g * g - w * w),
            A = S * Math.sin(s.ak(-o)),
            E = S * Math.cos(s.ak(-o));
          return new s.a5(d.x + A, d.y + E, d.z + w)
        }

        function Ve(h, e, a) {
          const o = e.intersectsFrustum(h);
          if (!a || o === 0) return o;
          const c = e.intersectsPlane(a);
          return c === 0 ? 0 : o === 2 && c === 2 ? 2 : 1
        }

        function tt(h, e, a) {
          let o = 0;
          const c = (a - e) / 10;
          for (let d = 0; d < 10; d++) o += c * Math.pow(Math.cos(e + (d + .5) / 10 * (a - e)), h);
          return o
        }

        function Ze(h, e) {
          return function(a, o, c, d, g) {
            const w = 2 * ((h - 1) / s.ao(Math.cos(s.ak(be - g)) / Math.cos(s.ak(be))) - 1),
              S = Math.acos(c / d),
              A = 2 * tt(w - 1, 0, s.ak(g / 2)),
              E = Math.min(s.ak(be), S + s.ak(g / 2)),
              F = tt(w - 1, Math.min(E, S - s.ak(g / 2)), E),
              R = Math.atan(o / c),
              U = Math.hypot(o, c);
            let Y = a;
            return Y += s.ao(d / U / Math.max(.5, Math.cos(s.ak(g / 2)))), Y += w * s.ao(Math.cos(R)) / 2, Y -= s.ao(Math.max(1, F / A / e)) / 2, Y
          }
        }
        const ne = Ze(9.314, 3);

        function Ce(h, e) {
          const a = (e.roundZoom ? Math.round : Math.floor)(h.zoom + s.ao(h.tileSize / e.tileSize));
          return Math.max(0, a)
        }

        function He(h, e) {
          const a = h.getCameraFrustum(),
            o = h.getClippingPlane(),
            c = h.screenPointToMercatorCoordinate(h.getCameraPoint()),
            d = s.a5.fromLngLat(h.center, h.elevation);
          c.z = d.z + Math.cos(h.pitchInRadians) * h.cameraToCenterDistance / h.worldSize;
          const g = h.getCoveringTilesDetailsProvider(),
            w = g.allowVariableZoom(h, e),
            S = Ce(h, e),
            A = e.minzoom || 0,
            E = e.maxzoom !== void 0 ? e.maxzoom : h.maxZoom,
            F = Math.min(Math.max(0, S), E),
            R = Math.pow(2, F),
            U = [R * c.x, R * c.y, 0],
            Y = [R * d.x, R * d.y, 0],
            se = Math.hypot(d.x - c.x, d.y - c.y),
            le = Math.abs(d.z - c.z),
            ce = Math.hypot(se, le),
            ge = Me => ({
              zoom: 0,
              x: 0,
              y: 0,
              wrap: Me,
              fullyVisible: !1
            }),
            Pe = [],
            fe = [];
          if (h.renderWorldCopies && g.allowWorldCopies())
            for (let Me = 1; Me <= 3; Me++) Pe.push(ge(-Me)), Pe.push(ge(Me));
          for (Pe.push(ge(0)); Pe.length > 0;) {
            const Me = Pe.pop(),
              Ee = Me.x,
              ve = Me.y;
            let Oe = Me.fullyVisible;
            const lt = {
                x: Ee,
                y: ve,
                z: Me.zoom
              },
              it = g.getTileBoundingVolume(lt, Me.wrap, h.elevation, e);
            if (!Oe) {
              const lr = Ve(a, it, o);
              if (lr === 0) continue;
              Oe = lr === 2
            }
            const st = g.distanceToTile2d(c.x, c.y, lt, it);
            let ct = S;
            w && (ct = (e.calculateTileZoom || ne)(h.zoom + s.ao(h.tileSize / e.tileSize), st, le, ce, h.fov)), ct = (e.roundZoom ? Math.round : Math.floor)(ct), ct = Math.max(0, ct);
            const nr = Math.min(ct, E);
            if (Me.wrap = g.getWrap(d, lt, Me.wrap), Me.zoom >= nr) {
              if (Me.zoom < A) continue;
              const lr = F - Me.zoom,
                Bt = U[0] - .5 - (Ee << lr),
                qr = U[1] - .5 - (ve << lr),
                yi = e.reparseOverscaled ? Math.max(Me.zoom, ct) : Me.zoom;
              fe.push({
                tileID: new s.a0(Me.zoom === E ? yi : Me.zoom, Me.wrap, Me.zoom, Ee, ve),
                distanceSq: s.ap([Y[0] - .5 - Ee, Y[1] - .5 - ve]),
                tileDistanceToCamera: Math.sqrt(Bt * Bt + qr * qr)
              })
            } else
              for (let lr = 0; lr < 4; lr++) Pe.push({
                zoom: Me.zoom + 1,
                x: (Ee << 1) + lr % 2,
                y: (ve << 1) + (lr >> 1),
                wrap: Me.wrap,
                fullyVisible: Oe
              })
          }
          return fe.sort(((Me, Ee) => Me.distanceSq - Ee.distanceSq)).map((Me => Me.tileID))
        }
        const ht = s.a6.fromPoints([new s.P(0, 0), new s.P(s.a3, s.a3)]);
        class Tt extends s.E {
          constructor(e, a, o) {
            super(), this.id = e, this.dispatcher = o, this.on("data", (c => this._dataHandler(c))), this.on("dataloading", (() => {
              this._sourceErrored = !1
            })), this.on("error", (() => {
              this._sourceErrored = this._source.loaded()
            })), this._source = ((c, d, g, w) => {
              const S = new(Wr(d.type))(c, d, g, w);
              if (S.id !== c) throw new Error(`Expected Source id to be ${c} instead of ${S.id}`);
              return S
            })(e, a, o, this), this._tiles = {}, this._cache = new ue(0, (c => this._unloadTile(c))), this._timers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._rasterFadeDuration = 0, this._maxFadingAncestorLevels = 5, this._state = new Te, this._didEmitContent = !1, this._updated = !1
          }
          onAdd(e) {
            this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e)
          }
          onRemove(e) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e)
          }
          loaded() {
            if (this._sourceErrored) return !0;
            if (!this._sourceLoaded || !this._source.loaded()) return !1;
            if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
            if (!this._updated) return !1;
            for (const e in this._tiles) {
              const a = this._tiles[e];
              if (a.state !== "loaded" && a.state !== "errored") return !1
            }
            return !0
          }
          getSource() {
            return this._source
          }
          getState() {
            return this._state
          }
          pause() {
            this._paused = !0
          }
          resume() {
            if (!this._paused) return;
            const e = this._shouldReloadOnResume;
            this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform, this.terrain)
          }
          _loadTile(e, a, o) {
            return s._(this, void 0, void 0, (function*() {
              try {
                yield this._source.loadTile(e), this._tileLoaded(e, a, o)
              } catch (c) {
                e.state = "errored", c.status !== 404 ? this._source.fire(new s.k(c, {
                  tile: e
                })) : this.update(this.transform, this.terrain)
              }
            }))
          }
          _unloadTile(e) {
            this._source.unloadTile && this._source.unloadTile(e)
          }
          _abortTile(e) {
            this._source.abortTile && this._source.abortTile(e), this._source.fire(new s.l("dataabort", {
              tile: e,
              coord: e.tileID,
              dataType: "source"
            }))
          }
          serialize() {
            return this._source.serialize()
          }
          prepare(e) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const a in this._tiles) {
              const o = this._tiles[a];
              o.upload(e), o.prepare(this.map.style.imageManager)
            }
          }
          getIds() {
            return Object.values(this._tiles).map((e => e.tileID)).sort(dt).map((e => e.key))
          }
          getRenderableIds(e) {
            const a = [];
            for (const o in this._tiles) this._isIdRenderable(o, e) && a.push(this._tiles[o]);
            return e ? a.sort(((o, c) => {
              const d = o.tileID,
                g = c.tileID,
                w = new s.P(d.canonical.x, d.canonical.y)._rotate(-this.transform.bearingInRadians),
                S = new s.P(g.canonical.x, g.canonical.y)._rotate(-this.transform.bearingInRadians);
              return d.overscaledZ - g.overscaledZ || S.y - w.y || S.x - w.x
            })).map((o => o.tileID.key)) : a.map((o => o.tileID)).sort(dt).map((o => o.key))
          }
          hasRenderableParent(e) {
            const a = e.overscaledZ - 1;
            if (a >= this._source.minzoom) {
              const o = this.getLoadedTile(e.scaledTo(a));
              if (o) return this._isIdRenderable(o.tileID.key)
            }
            return !1
          }
          _isIdRenderable(e, a = !1) {
            var o;
            return (o = this._tiles[e]) === null || o === void 0 ? void 0 : o.isRenderable(a)
          }
          reload(e, a = void 0) {
            if (this._paused) this._shouldReloadOnResume = !0;
            else {
              this._cache.reset();
              for (const o in this._tiles) a && this._source.shouldReloadTile && !this._source.shouldReloadTile(this._tiles[o], a) || (e ? this._reloadTile(o, "expired") : this._tiles[o].state !== "errored" && this._reloadTile(o, "reloading"))
            }
          }
          _reloadTile(e, a) {
            return s._(this, void 0, void 0, (function*() {
              const o = this._tiles[e];
              o && (o.state !== "loading" && (o.state = a), yield this._loadTile(o, e, a))
            }))
          }
          _tileLoaded(e, a, o) {
            e.timeAdded = _e(), e.selfFading && (e.fadeEndTime = e.timeAdded + this._rasterFadeDuration), o === "expired" && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(a, e), this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new s.l("data", {
              dataType: "source",
              tile: e,
              coord: e.tileID
            }))
          }
          _backfillDEM(e) {
            const a = this.getRenderableIds();
            for (let c = 0; c < a.length; c++) {
              const d = a[c];
              if (e.neighboringTiles && e.neighboringTiles[d]) {
                const g = this.getTileByID(d);
                o(e, g), o(g, e)
              }
            }

            function o(c, d) {
              c.needsHillshadePrepare = !0, c.needsTerrainPrepare = !0;
              let g = d.tileID.canonical.x - c.tileID.canonical.x;
              const w = d.tileID.canonical.y - c.tileID.canonical.y,
                S = Math.pow(2, c.tileID.canonical.z),
                A = d.tileID.key;
              g === 0 && w === 0 || Math.abs(w) > 1 || (Math.abs(g) > 1 && (Math.abs(g + S) === 1 ? g += S : Math.abs(g - S) === 1 && (g -= S)), d.dem && c.dem && (c.dem.backfillBorder(d.dem, g, w), c.neighboringTiles && c.neighboringTiles[A] && (c.neighboringTiles[A].backfilled = !0)))
            }
          }
          getTile(e) {
            return this.getTileByID(e.key)
          }
          getTileByID(e) {
            return this._tiles[e]
          }
          _retainLoadedChildren(e, a) {
            const o = Object.values(e),
              c = this._getLoadedDescendents(o),
              d = {};
            for (const g of o) {
              const w = c[g.key];
              if (!(w != null && w.length)) {
                d[g.key] = g;
                continue
              }
              const S = g.overscaledZ + Tt.maxUnderzooming,
                A = w.filter((R => R.tileID.overscaledZ <= S));
              if (!A.length) {
                d[g.key] = g;
                continue
              }
              const E = Math.min(...A.map((R => R.tileID.overscaledZ))),
                F = A.filter((R => R.tileID.overscaledZ === E)).map((R => R.tileID));
              for (const R of F) a[R.key] = R;
              this._areDescendentsComplete(F, E, g.overscaledZ) || (d[g.key] = g)
            }
            return d
          }
          _getLoadedDescendents(e) {
            var a;
            const o = {};
            for (const c in this._tiles) {
              const d = this._tiles[c];
              if (d.hasData())
                for (const g of e) d.tileID.isChildOf(g) && (o[a = g.key] || (o[a] = [])).push(d)
            }
            return o
          }
          _areDescendentsComplete(e, a, o) {
            return e.length === 1 && e[0].isOverscaled() ? e[0].overscaledZ === a : Math.pow(4, a - o) === e.length
          }
          getLoadedTile(e) {
            const a = this._tiles[e.key];
            return a != null && a.hasData() ? a : null
          }
          updateCacheSize(e) {
            const a = Math.ceil(e.width / this._source.tileSize) + 1,
              o = Math.ceil(e.height / this._source.tileSize) + 1,
              c = Math.floor(a * o * (this._maxTileCacheZoomLevels === null ? s.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)),
              d = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, c) : c;
            this._cache.setMaxSize(d)
          }
          handleWrapJump(e) {
            const a = Math.round((e - (this._prevLng === void 0 ? e : this._prevLng)) / 360);
            if (this._prevLng = e, a) {
              const o = {};
              for (const c in this._tiles) {
                const d = this._tiles[c];
                d.tileID = d.tileID.unwrapTo(d.tileID.wrap + a), o[d.tileID.key] = d
              }
              this._tiles = o, this._resetTileReloadTimers()
            }
          }
          update(e, a) {
            if (!this._sourceLoaded || this._paused) return;
            let o;
            this.transform = e, this.terrain = a, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this.used || this.usedForTerrain ? this._source.tileID ? o = e.getVisibleUnwrappedCoordinates(this._source.tileID).map((S => new s.a0(S.canonical.z, S.wrap, S.canonical.z, S.canonical.x, S.canonical.y))) : (o = He(e, {
              tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize,
              minzoom: this._source.minzoom,
              maxzoom: this._source.maxzoom,
              roundZoom: !this.usedForTerrain && this._source.roundZoom,
              reparseOverscaled: this._source.reparseOverscaled,
              terrain: a,
              calculateTileZoom: this._source.calculateTileZoom
            }), this._source.hasTile && (o = o.filter((S => this._source.hasTile(S))))) : o = [], this.usedForTerrain && (o = this._addTerrainIdealTiles(o));
            const c = o.length === 0 && !this._updated && this._didEmitContent;
            this._updated = !0, c && this.fire(new s.l("data", {
              sourceDataType: "idle",
              dataType: "source",
              sourceId: this.id
            }));
            const d = Ce(e, this._source),
              g = this._updateRetainedTiles(o, d),
              w = St(this._source.type);
            w && this._rasterFadeDuration > 0 && !a && this._updateFadingTiles(o, g), w ? this._cleanUpRasterTiles(g) : this._cleanUpVectorTiles(g)
          }
          _cleanUpRasterTiles(e) {
            for (const a in this._tiles) e[a] || this._removeTile(a)
          }
          _cleanUpVectorTiles(e) {
            for (const a in this._tiles) {
              const o = this._tiles[a];
              e[a] ? o.clearSymbolFadeHold() : o.hasSymbolBuckets ? o.holdingForSymbolFade() ? o.symbolFadeFinished() && this._removeTile(a) : o.setSymbolHoldDuration(this.map._fadeDuration) : this._removeTile(a)
            }
          }
          _addTerrainIdealTiles(e) {
            const a = [];
            for (const o of e)
              if (o.canonical.z > this._source.minzoom) {
                const c = o.scaledTo(o.canonical.z - 1);
                a.push(c);
                const d = o.scaledTo(Math.max(this._source.minzoom, Math.min(o.canonical.z, 5)));
                a.push(d)
              } return e.concat(a)
          }
          releaseSymbolFadeTiles() {
            for (const e in this._tiles) this._tiles[e].holdingForSymbolFade() && this._removeTile(e)
          }
          _updateRetainedTiles(e, a) {
            var o;
            const c = {},
              d = {},
              g = Math.max(a - Tt.maxOverzooming, this._source.minzoom);
            let w = {};
            for (const S of e) {
              const A = this._addTile(S);
              c[S.key] = S, A.hasData() || (w[S.key] = S)
            }
            w = this._retainLoadedChildren(w, c);
            for (const S in w) {
              const A = w[S];
              let E = this._tiles[S],
                F = E == null ? void 0 : E.wasRequested();
              for (let R = A.overscaledZ - 1; R >= g; --R) {
                const U = A.scaledTo(R);
                if (d[U.key]) break;
                if (d[U.key] = !0, E = this.getTile(U), !E && F && (E = this._addTile(U)), E) {
                  const Y = E.hasData();
                  if ((Y || !(!((o = this.map) === null || o === void 0) && o.cancelPendingTileRequestsWhileZooming) || F) && (c[U.key] = U), F = E.wasRequested(), Y) break
                }
              }
            }
            return c
          }
          _updateFadingTiles(e, a) {
            const o = _e(),
              c = s.aq(e);
            for (const d of e) {
              const g = this._tiles[d.key];
              g.fadingDirection !== re.Departing && g.fadeOpacity !== 0 || g.resetFadeLogic(), this._updateFadingAncestor(g, a, o) || this._updateFadingDescendents(g, a, o) || this._updateFadingEdge(g, c, o) || g.resetFadeLogic()
            }
          }
          _updateFadingAncestor(e, a, o) {
            if (!e.hasData()) return !1;
            const {
              tileID: c,
              fadingRole: d,
              fadingDirection: g,
              fadingParentID: w
            } = e;
            if (d === X.Base && g === re.Incoming && w) return a[w.key] = w, !0;
            const S = Math.max(c.overscaledZ - this._maxFadingAncestorLevels, this._source.minzoom);
            for (let A = c.overscaledZ - 1; A >= S; A--) {
              const E = c.scaledTo(A),
                F = this.getLoadedTile(E);
              if (F) return e.setCrossFadeLogic({
                fadingRole: X.Base,
                fadingDirection: re.Incoming,
                fadingParentID: F.tileID,
                fadeEndTime: o + this._rasterFadeDuration
              }), F.setCrossFadeLogic({
                fadingRole: X.Parent,
                fadingDirection: re.Departing,
                fadeEndTime: o + this._rasterFadeDuration
              }), a[E.key] = E, !0
            }
            return !1
          }
          _updateFadingDescendents(e, a, o) {
            if (!e.hasData()) return !1;
            const c = e.tileID.children(this._source.maxzoom);
            let d = this._updateFadingChildren(e, c, a, o);
            if (d) return !0;
            for (const g of c) {
              const w = g.children(this._source.maxzoom);
              this._updateFadingChildren(e, w, a, o) && (d = !0)
            }
            return d
          }
          _updateFadingChildren(e, a, o, c) {
            if (a[0].overscaledZ >= this._source.maxzoom) return !1;
            let d = !1;
            for (const g of a) {
              const w = this.getLoadedTile(g);
              if (!w) continue;
              const {
                fadingRole: S,
                fadingDirection: A,
                fadingParentID: E
              } = w;
              S === X.Base && A === re.Departing && E || (w.setCrossFadeLogic({
                fadingRole: X.Base,
                fadingDirection: re.Departing,
                fadingParentID: e.tileID,
                fadeEndTime: c + this._rasterFadeDuration
              }), e.setCrossFadeLogic({
                fadingRole: X.Parent,
                fadingDirection: re.Incoming,
                fadeEndTime: c + this._rasterFadeDuration
              })), o[g.key] = g, d = !0
            }
            return d
          }
          _updateFadingEdge(e, a, o) {
            const c = e.tileID;
            return !!e.selfFading || !e.hasData() && !!a.has(c) && (e.setSelfFadeLogic(o + this._rasterFadeDuration), !0)
          }
          _addTile(e) {
            let a = this._tiles[e.key];
            if (a) return a;
            a = this._cache.getAndRemove(e), a && (a.resetFadeLogic(), this._setTileReloadTimer(e.key, a), a.tileID = e, this._state.initializeTileState(a, this.map ? this.map.painter : null));
            const o = a;
            return a || (a = new Q(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(a, e.key, a.state)), a.uses++, this._tiles[e.key] = a, o || this._source.fire(new s.l("dataloading", {
              tile: a,
              coord: a.tileID,
              dataType: "source"
            })), a
          }
          _setTileReloadTimer(e, a) {
            this._clearTileReloadTimer(e);
            const o = a.getExpiryTimeout();
            o && (this._timers[e] = setTimeout((() => {
              this._reloadTile(e, "expired"), delete this._timers[e]
            }), o))
          }
          _clearTileReloadTimer(e) {
            const a = this._timers[e];
            a && (clearTimeout(a), delete this._timers[e])
          }
          _resetTileReloadTimers() {
            for (const e in this._timers) clearTimeout(this._timers[e]), delete this._timers[e];
            for (const e in this._tiles) this._setTileReloadTimer(e, this._tiles[e])
          }
          refreshTiles(e) {
            for (const a in this._tiles)(this._isIdRenderable(a) || this._tiles[a].state == "errored") && e.some((o => o.equals(this._tiles[a].tileID.canonical))) && this._reloadTile(a, "expired")
          }
          _removeTile(e) {
            const a = this._tiles[e];
            a && (a.uses--, delete this._tiles[e], this._clearTileReloadTimer(e), a.uses > 0 || (a.hasData() && a.state !== "reloading" ? this._cache.add(a.tileID, a, a.getExpiryTimeout()) : (a.aborted = !0, this._abortTile(a), this._unloadTile(a))))
          }
          _dataHandler(e) {
            e.dataType === "source" && (e.sourceDataType !== "metadata" ? e.sourceDataType === "content" && this._sourceLoaded && !this._paused && (this.reload(e.sourceDataChanged, e.shouldReloadTileOptions), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0) : this._sourceLoaded = !0)
          }
          clearTiles() {
            this._shouldReloadOnResume = !1, this._paused = !1;
            for (const e in this._tiles) this._removeTile(e);
            this._cache.reset()
          }
          tilesIn(e, a, o) {
            const c = [],
              d = this.transform;
            if (!d) return c;
            const g = d.getCoveringTilesDetailsProvider().allowWorldCopies(),
              w = o ? d.getCameraQueryGeometry(e) : e,
              S = U => d.screenPointToMercatorCoordinate(U, this.terrain),
              A = this.transformBbox(e, S, !g),
              E = this.transformBbox(w, S, !g),
              F = this.getIds(),
              R = s.a6.fromPoints(E);
            for (let U = 0; U < F.length; U++) {
              const Y = this._tiles[F[U]];
              if (Y.holdingForSymbolFade()) continue;
              const se = g ? [Y.tileID] : [Y.tileID.unwrapTo(-1), Y.tileID.unwrapTo(0)],
                le = Math.pow(2, d.zoom - Y.tileID.overscaledZ),
                ce = a * Y.queryPadding * s.a3 / Y.tileSize / le;
              for (const ge of se) {
                const Pe = R.map((fe => ge.getTilePoint(new s.a5(fe.x, fe.y))));
                if (Pe.expandBy(ce), Pe.intersects(ht)) {
                  const fe = A.map((Ee => ge.getTilePoint(Ee))),
                    Me = E.map((Ee => ge.getTilePoint(Ee)));
                  c.push({
                    tile: Y,
                    tileID: g ? ge : ge.unwrapTo(0),
                    queryGeometry: fe,
                    cameraQueryGeometry: Me,
                    scale: le
                  })
                }
              }
            }
            return c
          }
          transformBbox(e, a, o) {
            let c = e.map(a);
            if (o) {
              const d = s.a6.fromPoints(e);
              d.shrinkBy(.001 * Math.min(d.width(), d.height()));
              const g = d.map(a);
              s.a6.fromPoints(c).covers(g) || (c = c.map((w => w.x > .5 ? new s.a5(w.x - 1, w.y, w.z) : w)))
            }
            return c
          }
          getVisibleCoordinates(e) {
            const a = this.getRenderableIds(e).map((o => this._tiles[o].tileID));
            return this.transform && this.transform.populateCache(a), a
          }
          hasTransition() {
            if (this._source.hasTransition()) return !0;
            if (St(this._source.type) && this._rasterFadeDuration > 0) {
              const e = _e();
              for (const a in this._tiles)
                if (this._tiles[a].fadeEndTime >= e) return !0
            }
            return !1
          }
          setRasterFadeDuration(e) {
            this._rasterFadeDuration = e
          }
          setFeatureState(e, a, o) {
            this._state.updateState(e = e || "_geojsonTileLayer", a, o)
          }
          removeFeatureState(e, a, o) {
            this._state.removeFeatureState(e = e || "_geojsonTileLayer", a, o)
          }
          getFeatureState(e, a) {
            return this._state.getState(e = e || "_geojsonTileLayer", a)
          }
          setDependencies(e, a, o) {
            const c = this._tiles[e];
            c && c.setDependencies(a, o)
          }
          reloadTilesForDependencies(e, a) {
            for (const o in this._tiles) this._tiles[o].hasDependency(e, a) && this._reloadTile(o, "reloading");
            this._cache.filter((o => !o.hasDependency(e, a)))
          }
        }

        function dt(h, e) {
          const a = Math.abs(2 * h.wrap) - +(h.wrap < 0),
            o = Math.abs(2 * e.wrap) - +(e.wrap < 0);
          return h.overscaledZ - e.overscaledZ || o - a || e.canonical.y - h.canonical.y || e.canonical.x - h.canonical.x
        }

        function St(h) {
          return h === "raster" || h === "image" || h === "video"
        }
        Tt.maxOverzooming = 10, Tt.maxUnderzooming = 3;
        class jt {
          constructor(e, a) {
            this.reset(e, a)
          }
          reset(e, a) {
            this.points = e || [], this._distances = [0];
            for (let o = 1; o < this.points.length; o++) this._distances[o] = this._distances[o - 1] + this.points[o].dist(this.points[o - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(a || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding
          }
          lerp(e) {
            if (this.points.length === 1) return this.points[0];
            e = s.ai(e, 0, 1);
            let a = 1,
              o = this._distances[a];
            const c = e * this.paddedLength + this.padding;
            for (; o < c && a < this._distances.length;) o = this._distances[++a];
            const d = a - 1,
              g = this._distances[d],
              w = o - g,
              S = w > 0 ? (c - g) / w : 0;
            return this.points[d].mult(1 - S).add(this.points[a].mult(S))
          }
        }

        function je(h, e) {
          let a = !0;
          return h === "always" || h !== "never" && e !== "never" || (a = !1), a
        }
        class yt {
          constructor(e, a, o) {
            const c = this.boxCells = [],
              d = this.circleCells = [];
            this.xCellCount = Math.ceil(e / o), this.yCellCount = Math.ceil(a / o);
            for (let g = 0; g < this.xCellCount * this.yCellCount; g++) c.push([]), d.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = a, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / a, this.boxUid = 0, this.circleUid = 0
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length
          }
          insert(e, a, o, c, d) {
            this._forEachCell(a, o, c, d, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(a), this.bboxes.push(o), this.bboxes.push(c), this.bboxes.push(d)
          }
          insertCircle(e, a, o, c) {
            this._forEachCell(a - c, o - c, a + c, o + c, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(a), this.circles.push(o), this.circles.push(c)
          }
          _insertBoxCell(e, a, o, c, d, g) {
            this.boxCells[d].push(g)
          }
          _insertCircleCell(e, a, o, c, d, g) {
            this.circleCells[d].push(g)
          }
          _query(e, a, o, c, d, g, w) {
            if (o < 0 || e > this.width || c < 0 || a > this.height) return [];
            const S = [];
            if (e <= 0 && a <= 0 && this.width <= o && this.height <= c) {
              if (d) return [{
                key: null,
                x1: e,
                y1: a,
                x2: o,
                y2: c
              }];
              for (let A = 0; A < this.boxKeys.length; A++) S.push({
                key: this.boxKeys[A],
                x1: this.bboxes[4 * A],
                y1: this.bboxes[4 * A + 1],
                x2: this.bboxes[4 * A + 2],
                y2: this.bboxes[4 * A + 3]
              });
              for (let A = 0; A < this.circleKeys.length; A++) {
                const E = this.circles[3 * A],
                  F = this.circles[3 * A + 1],
                  R = this.circles[3 * A + 2];
                S.push({
                  key: this.circleKeys[A],
                  x1: E - R,
                  y1: F - R,
                  x2: E + R,
                  y2: F + R
                })
              }
            } else this._forEachCell(e, a, o, c, this._queryCell, S, {
              hitTest: d,
              overlapMode: g,
              seenUids: {
                box: {},
                circle: {}
              }
            }, w);
            return S
          }
          query(e, a, o, c) {
            return this._query(e, a, o, c, !1, null)
          }
          hitTest(e, a, o, c, d, g) {
            return this._query(e, a, o, c, !0, d, g).length > 0
          }
          hitTestCircle(e, a, o, c, d) {
            const g = e - o,
              w = e + o,
              S = a - o,
              A = a + o;
            if (w < 0 || g > this.width || A < 0 || S > this.height) return !1;
            const E = [];
            return this._forEachCell(g, S, w, A, this._queryCellCircle, E, {
              hitTest: !0,
              overlapMode: c,
              circle: {
                x: e,
                y: a,
                radius: o
              },
              seenUids: {
                box: {},
                circle: {}
              }
            }, d), E.length > 0
          }
          _queryCell(e, a, o, c, d, g, w, S) {
            const {
              seenUids: A,
              hitTest: E,
              overlapMode: F
            } = w, R = this.boxCells[d];
            if (R !== null) {
              const Y = this.bboxes;
              for (const se of R)
                if (!A.box[se]) {
                  A.box[se] = !0;
                  const le = 4 * se,
                    ce = this.boxKeys[se];
                  if (e <= Y[le + 2] && a <= Y[le + 3] && o >= Y[le + 0] && c >= Y[le + 1] && (!S || S(ce)) && (!E || !je(F, ce.overlapMode)) && (g.push({
                      key: ce,
                      x1: Y[le],
                      y1: Y[le + 1],
                      x2: Y[le + 2],
                      y2: Y[le + 3]
                    }), E)) return !0
                }
            }
            const U = this.circleCells[d];
            if (U !== null) {
              const Y = this.circles;
              for (const se of U)
                if (!A.circle[se]) {
                  A.circle[se] = !0;
                  const le = 3 * se,
                    ce = this.circleKeys[se];
                  if (this._circleAndRectCollide(Y[le], Y[le + 1], Y[le + 2], e, a, o, c) && (!S || S(ce)) && (!E || !je(F, ce.overlapMode))) {
                    const ge = Y[le],
                      Pe = Y[le + 1],
                      fe = Y[le + 2];
                    if (g.push({
                        key: ce,
                        x1: ge - fe,
                        y1: Pe - fe,
                        x2: ge + fe,
                        y2: Pe + fe
                      }), E) return !0
                  }
                }
            }
            return !1
          }
          _queryCellCircle(e, a, o, c, d, g, w, S) {
            const {
              circle: A,
              seenUids: E,
              overlapMode: F
            } = w, R = this.boxCells[d];
            if (R !== null) {
              const Y = this.bboxes;
              for (const se of R)
                if (!E.box[se]) {
                  E.box[se] = !0;
                  const le = 4 * se,
                    ce = this.boxKeys[se];
                  if (this._circleAndRectCollide(A.x, A.y, A.radius, Y[le + 0], Y[le + 1], Y[le + 2], Y[le + 3]) && (!S || S(ce)) && !je(F, ce.overlapMode)) return g.push(!0), !0
                }
            }
            const U = this.circleCells[d];
            if (U !== null) {
              const Y = this.circles;
              for (const se of U)
                if (!E.circle[se]) {
                  E.circle[se] = !0;
                  const le = 3 * se,
                    ce = this.circleKeys[se];
                  if (this._circlesCollide(Y[le], Y[le + 1], Y[le + 2], A.x, A.y, A.radius) && (!S || S(ce)) && !je(F, ce.overlapMode)) return g.push(!0), !0
                }
            }
          }
          _forEachCell(e, a, o, c, d, g, w, S) {
            const A = this._convertToXCellCoord(e),
              E = this._convertToYCellCoord(a),
              F = this._convertToXCellCoord(o),
              R = this._convertToYCellCoord(c);
            for (let U = A; U <= F; U++)
              for (let Y = E; Y <= R; Y++)
                if (d.call(this, e, a, o, c, this.xCellCount * Y + U, g, w, S)) return
          }
          _convertToXCellCoord(e) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)))
          }
          _convertToYCellCoord(e) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)))
          }
          _circlesCollide(e, a, o, c, d, g) {
            const w = c - e,
              S = d - a,
              A = o + g;
            return A * A > w * w + S * S
          }
          _circleAndRectCollide(e, a, o, c, d, g, w) {
            const S = (g - c) / 2,
              A = Math.abs(e - (c + S));
            if (A > S + o) return !1;
            const E = (w - d) / 2,
              F = Math.abs(a - (d + E));
            if (F > E + o) return !1;
            if (A <= S || F <= E) return !0;
            const R = A - S,
              U = F - E;
            return R * R + U * U <= o * o
          }
        }

        function Kt(h, e, a) {
          const o = s.M();
          if (!h) {
            const {
              vecSouth: F,
              vecEast: R
            } = fr(e), U = W();
            U[0] = R[0], U[1] = R[1], U[2] = F[0], U[3] = F[1], c = U, (E = (g = (d = U)[0]) * (A = d[3]) - (S = d[2]) * (w = d[1])) && (c[0] = A * (E = 1 / E), c[1] = -w * E, c[2] = -S * E, c[3] = g * E), o[0] = U[0], o[1] = U[1], o[4] = U[2], o[5] = U[3]
          }
          var c, d, g, w, S, A, E;
          return s.O(o, o, [1 / a, 1 / a, 1]), o
        }

        function Cr(h, e, a, o) {
          if (h) {
            const c = s.M();
            if (!e) {
              const {
                vecSouth: d,
                vecEast: g
              } = fr(a);
              c[0] = g[0], c[1] = g[1], c[4] = d[0], c[5] = d[1]
            }
            return s.O(c, c, [o, o, 1]), c
          }
          return a.pixelsToClipSpaceMatrix
        }

        function fr(h) {
          const e = Math.cos(h.rollInRadians),
            a = Math.sin(h.rollInRadians),
            o = Math.cos(h.pitchInRadians),
            c = Math.cos(h.bearingInRadians),
            d = Math.sin(h.bearingInRadians),
            g = s.av();
          g[0] = -c * o * a - d * e, g[1] = -d * o * a + c * e;
          const w = s.aw(g);
          w < 1e-9 ? s.ax(g) : s.ay(g, g, 1 / w);
          const S = s.av();
          S[0] = c * o * e - d * a, S[1] = d * o * e + c * a;
          const A = s.aw(S);
          return A < 1e-9 ? s.ax(S) : s.ay(S, S, 1 / A), {
            vecEast: S,
            vecSouth: g
          }
        }

        function Je(h, e, a, o) {
          let c;
          o ? (c = [h, e, o(h, e), 1], s.aA(c, c, a)) : (c = [h, e, 0, 1], Rr(c, c, a));
          const d = c[3];
          return {
            point: new s.P(c[0] / d, c[1] / d),
            signedDistanceFromCamera: d,
            isOccluded: !1
          }
        }

        function tr(h, e) {
          return .5 + h / e * .5
        }

        function Yt(h, e) {
          return h.x >= -e[0] && h.x <= e[0] && h.y >= -e[1] && h.y <= e[1]
        }

        function Tr(h, e, a, o, c, d, g, w, S, A, E, F, R) {
          const U = a ? h.textSizeData : h.iconSizeData,
            Y = s.ar(U, e.transform.zoom),
            se = [256 / e.width * 2 + 1, 256 / e.height * 2 + 1],
            le = a ? h.text.dynamicLayoutVertexArray : h.icon.dynamicLayoutVertexArray;
          le.clear();
          const ce = h.lineVertexArray,
            ge = a ? h.text.placedSymbolArray : h.icon.placedSymbolArray,
            Pe = e.transform.width / e.transform.height;
          let fe = !1;
          for (let Me = 0; Me < ge.length; Me++) {
            const Ee = ge.get(Me);
            if (Ee.hidden || Ee.writingMode === s.as.vertical && !fe) {
              Kr(Ee.numGlyphs, le);
              continue
            }
            fe = !1;
            const ve = new s.P(Ee.anchorX, Ee.anchorY),
              Oe = {
                getElevation: R,
                pitchedLabelPlaneMatrix: o,
                lineVertexArray: ce,
                pitchWithMap: d,
                projectionCache: {
                  projections: {},
                  offsets: {},
                  cachedAnchorPoint: void 0,
                  anyProjectionOccluded: !1
                },
                transform: e.transform,
                tileAnchorPoint: ve,
                unwrappedTileID: S,
                width: A,
                height: E,
                translation: F
              },
              lt = Gt(Ee.anchorX, Ee.anchorY, Oe);
            if (!Yt(lt.point, se)) {
              Kr(Ee.numGlyphs, le);
              continue
            }
            const it = tr(e.transform.cameraToCenterDistance, lt.signedDistanceFromCamera),
              st = s.at(U, Y, Ee),
              ct = d ? st * e.transform.getPitchedTextCorrection(Ee.anchorX, Ee.anchorY, S) / it : st * it,
              nr = yr({
                projectionContext: Oe,
                pitchedLabelPlaneMatrixInverse: c,
                symbol: Ee,
                fontSize: ct,
                flip: !1,
                keepUpright: g,
                glyphOffsetArray: h.glyphOffsetArray,
                dynamicLayoutVertexArray: le,
                aspectRatio: Pe,
                rotateToLine: w
              });
            fe = nr.useVertical, (nr.notEnoughRoom || fe || nr.needsFlipping && yr({
              projectionContext: Oe,
              pitchedLabelPlaneMatrixInverse: c,
              symbol: Ee,
              fontSize: ct,
              flip: !0,
              keepUpright: g,
              glyphOffsetArray: h.glyphOffsetArray,
              dynamicLayoutVertexArray: le,
              aspectRatio: Pe,
              rotateToLine: w
            }).notEnoughRoom) && Kr(Ee.numGlyphs, le)
          }
          a ? h.text.dynamicLayoutVertexBuffer.updateData(le) : h.icon.dynamicLayoutVertexBuffer.updateData(le)
        }

        function Dr(h, e, a, o, c, d, g, w) {
          const S = d.glyphStartIndex + d.numGlyphs,
            A = d.lineStartIndex,
            E = d.lineStartIndex + d.lineLength,
            F = e.getoffsetX(d.glyphStartIndex),
            R = e.getoffsetX(S - 1),
            U = ar(h * F, a, o, c, d.segment, A, E, w, g);
          if (!U) return null;
          const Y = ar(h * R, a, o, c, d.segment, A, E, w, g);
          return Y ? w.projectionCache.anyProjectionOccluded ? null : {
            first: U,
            last: Y
          } : null
        }

        function Jr(h, e, a, o) {
          return h === s.as.horizontal && Math.abs(a.y - e.y) > Math.abs(a.x - e.x) * o ? {
            useVertical: !0
          } : (h === s.as.vertical ? e.y < a.y : e.x > a.x) ? {
            needsFlipping: !0
          } : null
        }

        function yr(h) {
          const {
            projectionContext: e,
            pitchedLabelPlaneMatrixInverse: a,
            symbol: o,
            fontSize: c,
            flip: d,
            keepUpright: g,
            glyphOffsetArray: w,
            dynamicLayoutVertexArray: S,
            aspectRatio: A,
            rotateToLine: E
          } = h, F = c / 24, R = o.lineOffsetX * F, U = o.lineOffsetY * F;
          let Y;
          if (o.numGlyphs > 1) {
            const se = o.glyphStartIndex + o.numGlyphs,
              le = o.lineStartIndex,
              ce = o.lineStartIndex + o.lineLength,
              ge = Dr(F, w, R, U, d, o, E, e);
            if (!ge) return {
              notEnoughRoom: !0
            };
            const Pe = xt(ge.first.point.x, ge.first.point.y, e, a),
              fe = xt(ge.last.point.x, ge.last.point.y, e, a);
            if (g && !d) {
              const Me = Jr(o.writingMode, Pe, fe, A);
              if (Me) return Me
            }
            Y = [ge.first];
            for (let Me = o.glyphStartIndex + 1; Me < se - 1; Me++) {
              const Ee = ar(F * w.getoffsetX(Me), R, U, d, o.segment, le, ce, e, E);
              if (!Ee) return {
                notEnoughRoom: !0
              };
              Y.push(Ee)
            }
            Y.push(ge.last)
          } else {
            if (g && !d) {
              const le = Ue(e.tileAnchorPoint.x, e.tileAnchorPoint.y, e).point,
                ce = o.lineStartIndex + o.segment + 1,
                ge = new s.P(e.lineVertexArray.getx(ce), e.lineVertexArray.gety(ce)),
                Pe = Ue(ge.x, ge.y, e),
                fe = Pe.signedDistanceFromCamera > 0 ? Pe.point : qt(e.tileAnchorPoint, ge, le, 1, e),
                Me = xt(le.x, le.y, e, a),
                Ee = xt(fe.x, fe.y, e, a),
                ve = Jr(o.writingMode, Me, Ee, A);
              if (ve) return ve
            }
            const se = ar(F * w.getoffsetX(o.glyphStartIndex), R, U, d, o.segment, o.lineStartIndex, o.lineStartIndex + o.lineLength, e, E);
            if (!se || e.projectionCache.anyProjectionOccluded) return {
              notEnoughRoom: !0
            };
            Y = [se]
          }
          for (const se of Y) s.az(S, se.point, se.angle);
          return {}
        }

        function qt(h, e, a, o, c) {
          const d = h.add(h.sub(e)._unit()),
            g = Ue(d.x, d.y, c).point,
            w = a.sub(g);
          return a.add(w._mult(o / w.mag()))
        }

        function bt(h, e, a) {
          const o = e.projectionCache;
          if (o.projections[h]) return o.projections[h];
          const c = new s.P(e.lineVertexArray.getx(h), e.lineVertexArray.gety(h)),
            d = Ue(c.x, c.y, e);
          if (d.signedDistanceFromCamera > 0) return o.projections[h] = d.point, o.anyProjectionOccluded = o.anyProjectionOccluded || d.isOccluded, d.point;
          const g = h - a.direction;
          return qt(a.distanceFromAnchor === 0 ? e.tileAnchorPoint : new s.P(e.lineVertexArray.getx(g), e.lineVertexArray.gety(g)), c, a.previousVertex, a.absOffsetX - a.distanceFromAnchor + 1, e)
        }

        function Ue(h, e, a) {
          const o = h + a.translation[0],
            c = e + a.translation[1];
          let d;
          return a.pitchWithMap ? (d = Je(o, c, a.pitchedLabelPlaneMatrix, a.getElevation), d.isOccluded = !1) : (d = a.transform.projectTileCoordinates(o, c, a.unwrappedTileID, a.getElevation), d.point.x = (.5 * d.point.x + .5) * a.width, d.point.y = (.5 * -d.point.y + .5) * a.height), d
        }

        function xt(h, e, a, o) {
          if (a.pitchWithMap) {
            const c = [h, e, 0, 1];
            return s.aA(c, c, o), a.transform.projectTileCoordinates(c[0] / c[3], c[1] / c[3], a.unwrappedTileID, a.getElevation).point
          }
          return {
            x: h / a.width * 2 - 1,
            y: 1 - e / a.height * 2
          }
        }

        function Gt(h, e, a) {
          return a.transform.projectTileCoordinates(h, e, a.unwrappedTileID, a.getElevation)
        }

        function kt(h, e, a) {
          return h._unit()._perp()._mult(e * a)
        }

        function dr(h, e, a, o, c, d, g, w, S) {
          if (w.projectionCache.offsets[h]) return w.projectionCache.offsets[h];
          const A = a.add(e);
          if (h + S.direction < o || h + S.direction >= c) return w.projectionCache.offsets[h] = A, A;
          const E = bt(h + S.direction, w, S),
            F = kt(E.sub(a), g, S.direction),
            R = a.add(F),
            U = E.add(F);
          return w.projectionCache.offsets[h] = s.aB(d, A, R, U) || A, w.projectionCache.offsets[h]
        }

        function ar(h, e, a, o, c, d, g, w, S) {
          const A = o ? h - e : h + e;
          let E = A > 0 ? 1 : -1,
            F = 0;
          o && (E *= -1, F = Math.PI), E < 0 && (F += Math.PI);
          let R, U = E > 0 ? d + c : d + c + 1;
          w.projectionCache.cachedAnchorPoint ? R = w.projectionCache.cachedAnchorPoint : (R = Ue(w.tileAnchorPoint.x, w.tileAnchorPoint.y, w).point, w.projectionCache.cachedAnchorPoint = R);
          let Y, se, le = R,
            ce = R,
            ge = 0,
            Pe = 0;
          const fe = Math.abs(A),
            Me = [];
          let Ee;
          for (; ge + Pe <= fe;) {
            if (U += E, U < d || U >= g) return null;
            ge += Pe, ce = le, se = Y;
            const lt = {
              absOffsetX: fe,
              direction: E,
              distanceFromAnchor: ge,
              previousVertex: ce
            };
            if (le = bt(U, w, lt), a === 0) Me.push(ce), Ee = le.sub(ce);
            else {
              let it;
              const st = le.sub(ce);
              it = st.mag() === 0 ? kt(bt(U + E, w, lt).sub(le), a, E) : kt(st, a, E), se || (se = ce.add(it)), Y = dr(U, it, le, d, g, se, a, w, lt), Me.push(se), Ee = Y.sub(se)
            }
            Pe = Ee.mag()
          }
          const ve = Ee._mult((fe - ge) / Pe)._add(se || ce),
            Oe = F + Math.atan2(le.y - ce.y, le.x - ce.x);
          return Me.push(ve), {
            point: ve,
            angle: S ? Oe : 0,
            path: Me
          }
        }
        const Ar = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);

        function Kr(h, e) {
          for (let a = 0; a < h; a++) {
            const o = e.length;
            e.resize(o + 4), e.float32.set(Ar, 3 * o)
          }
        }

        function Rr(h, e, a) {
          const o = e[0],
            c = e[1];
          return h[0] = a[0] * o + a[4] * c + a[12], h[1] = a[1] * o + a[5] * c + a[13], h[3] = a[3] * o + a[7] * c + a[15], h
        }
        const Or = 100;
        class Fr {
          constructor(e, a = new yt(e.width + 200, e.height + 200, 25), o = new yt(e.width + 200, e.height + 200, 25)) {
            this.transform = e, this.grid = a, this.ignoredGrid = o, this.pitchFactor = Math.cos(e.pitch * Math.PI / 180) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + Or, this.screenBottomBoundary = e.height + Or, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.perspectiveRatioCutoff = .6
          }
          placeCollisionBox(e, a, o, c, d, g, w, S, A, E, F, R) {
            const U = this.projectAndGetPerspectiveRatio(e.anchorPointX + S[0], e.anchorPointY + S[1], d, E, R),
              Y = o * U.perspectiveRatio;
            let se;
            if (g || w) se = this._projectCollisionBox(e, Y, c, d, g, w, S, U, E, F, R);
            else {
              const Ee = U.x + (F ? F.x * Y : 0),
                ve = U.y + (F ? F.y * Y : 0);
              se = {
                allPointsOccluded: !1,
                box: [Ee + e.x1 * Y, ve + e.y1 * Y, Ee + e.x2 * Y, ve + e.y2 * Y]
              }
            }
            const [le, ce, ge, Pe] = se.box, fe = g ? se.allPointsOccluded : U.isOccluded;
            let Me = fe;
            return Me || (Me = U.perspectiveRatio < this.perspectiveRatioCutoff), Me || (Me = !this.isInsideGrid(le, ce, ge, Pe)), Me || a !== "always" && this.grid.hitTest(le, ce, ge, Pe, a, A) ? {
              box: [le, ce, ge, Pe],
              placeable: !1,
              offscreen: !1,
              occluded: fe
            } : {
              box: [le, ce, ge, Pe],
              placeable: !0,
              offscreen: this.isOffscreen(le, ce, ge, Pe),
              occluded: fe
            }
          }
          placeCollisionCircles(e, a, o, c, d, g, w, S, A, E, F, R, U, Y) {
            const se = [],
              le = new s.P(a.anchorX, a.anchorY),
              ce = this.getPerspectiveRatio(le.x, le.y, g, Y),
              ge = (A ? d * this.transform.getPitchedTextCorrection(a.anchorX, a.anchorY, g) / ce : d * ce) / s.aF,
              Pe = {
                getElevation: Y,
                pitchedLabelPlaneMatrix: w,
                lineVertexArray: o,
                pitchWithMap: A,
                projectionCache: {
                  projections: {},
                  offsets: {},
                  cachedAnchorPoint: void 0,
                  anyProjectionOccluded: !1
                },
                transform: this.transform,
                tileAnchorPoint: le,
                unwrappedTileID: g,
                width: this.transform.width,
                height: this.transform.height,
                translation: U
              },
              fe = Dr(ge, c, a.lineOffsetX * ge, a.lineOffsetY * ge, !1, a, !1, Pe);
            let Me = !1,
              Ee = !1,
              ve = !0;
            if (fe) {
              const Oe = .5 * F * ce + R,
                lt = new s.P(-100, -100),
                it = new s.P(this.screenRightBoundary, this.screenBottomBoundary),
                st = new jt,
                ct = fe.first,
                nr = fe.last;
              let lr = [];
              for (let yi = ct.path.length - 1; yi >= 1; yi--) lr.push(ct.path[yi]);
              for (let yi = 1; yi < nr.path.length; yi++) lr.push(nr.path[yi]);
              const Bt = 2.5 * Oe;
              if (A) {
                const yi = this.projectPathToScreenSpace(lr, Pe);
                lr = yi.some((Hi => Hi.signedDistanceFromCamera <= 0)) ? [] : yi.map((Hi => Hi.point))
              }
              let qr = [];
              if (lr.length > 0) {
                const yi = lr[0].clone(),
                  Hi = lr[0].clone();
                for (let Ci = 1; Ci < lr.length; Ci++) yi.x = Math.min(yi.x, lr[Ci].x), yi.y = Math.min(yi.y, lr[Ci].y), Hi.x = Math.max(Hi.x, lr[Ci].x), Hi.y = Math.max(Hi.y, lr[Ci].y);
                qr = yi.x >= lt.x && Hi.x <= it.x && yi.y >= lt.y && Hi.y <= it.y ? [lr] : Hi.x < lt.x || yi.x > it.x || Hi.y < lt.y || yi.y > it.y ? [] : s.aC([lr], lt.x, lt.y, it.x, it.y)
              }
              for (const yi of qr) {
                st.reset(yi, .25 * Oe);
                let Hi = 0;
                Hi = st.length <= .5 * Oe ? 1 : Math.ceil(st.paddedLength / Bt) + 1;
                for (let Ci = 0; Ci < Hi; Ci++) {
                  const Qi = Ci / Math.max(Hi - 1, 1),
                    fa = st.lerp(Qi),
                    ta = fa.x + Or,
                    ka = fa.y + Or;
                  se.push(ta, ka, Oe, 0);
                  const oa = ta - Oe,
                    Va = ka - Oe,
                    la = ta + Oe,
                    Ia = ka + Oe;
                  if (ve = ve && this.isOffscreen(oa, Va, la, Ia), Ee = Ee || this.isInsideGrid(oa, Va, la, Ia), e !== "always" && this.grid.hitTestCircle(ta, ka, Oe, e, E) && (Me = !0, !S)) return {
                    circles: [],
                    offscreen: !1,
                    collisionDetected: Me
                  }
                }
              }
            }
            return {
              circles: !S && Me || !Ee || ce < this.perspectiveRatioCutoff ? [] : se,
              offscreen: ve,
              collisionDetected: Me
            }
          }
          projectPathToScreenSpace(e, a) {
            const o = (function(c, d) {
              const g = s.M();
              return s.au(g, d.pitchedLabelPlaneMatrix), c.map((w => {
                const S = Je(w.x, w.y, g, d.getElevation),
                  A = d.transform.projectTileCoordinates(S.point.x, S.point.y, d.unwrappedTileID, d.getElevation);
                return A.point.x = (.5 * A.point.x + .5) * d.width, A.point.y = (.5 * -A.point.y + .5) * d.height, A
              }))
            })(e, a);
            return (function(c) {
              let d = 0,
                g = 0,
                w = 0,
                S = 0;
              for (let A = 0; A < c.length; A++) c[A].isOccluded ? (w = A + 1, S = 0) : (S++, S > g && (g = S, d = w));
              return c.slice(d, d + g)
            })(o)
          }
          queryRenderedSymbols(e) {
            if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
            const a = [],
              o = new s.a6;
            for (const F of e) {
              const R = new s.P(F.x + Or, F.y + Or);
              o.extend(R), a.push(R)
            }
            const {
              minX: c,
              minY: d,
              maxX: g,
              maxY: w
            } = o, S = this.grid.query(c, d, g, w).concat(this.ignoredGrid.query(c, d, g, w)), A = {}, E = {};
            for (const F of S) {
              const R = F.key;
              if (A[R.bucketInstanceId] === void 0 && (A[R.bucketInstanceId] = {}), A[R.bucketInstanceId][R.featureIndex]) continue;
              const U = [new s.P(F.x1, F.y1), new s.P(F.x2, F.y1), new s.P(F.x2, F.y2), new s.P(F.x1, F.y2)];
              s.aD(a, U) && (A[R.bucketInstanceId][R.featureIndex] = !0, E[R.bucketInstanceId] === void 0 && (E[R.bucketInstanceId] = []), E[R.bucketInstanceId].push(R.featureIndex))
            }
            return E
          }
          insertCollisionBox(e, a, o, c, d, g) {
            (o ? this.ignoredGrid : this.grid).insert({
              bucketInstanceId: c,
              featureIndex: d,
              collisionGroupID: g,
              overlapMode: a
            }, e[0], e[1], e[2], e[3])
          }
          insertCollisionCircles(e, a, o, c, d, g) {
            const w = o ? this.ignoredGrid : this.grid,
              S = {
                bucketInstanceId: c,
                featureIndex: d,
                collisionGroupID: g,
                overlapMode: a
              };
            for (let A = 0; A < e.length; A += 4) w.insertCircle(S, e[A], e[A + 1], e[A + 2])
          }
          projectAndGetPerspectiveRatio(e, a, o, c, d) {
            if (d) {
              let g;
              c ? (g = [e, a, c(e, a), 1], s.aA(g, g, d)) : (g = [e, a, 0, 1], Rr(g, g, d));
              const w = g[3];
              return {
                x: (g[0] / w + 1) / 2 * this.transform.width + Or,
                y: (-g[1] / w + 1) / 2 * this.transform.height + Or,
                perspectiveRatio: .5 + this.transform.cameraToCenterDistance / w * .5,
                isOccluded: !1,
                signedDistanceFromCamera: w
              }
            } {
              const g = this.transform.projectTileCoordinates(e, a, o, c);
              return {
                x: (g.point.x + 1) / 2 * this.transform.width + Or,
                y: (1 - g.point.y) / 2 * this.transform.height + Or,
                perspectiveRatio: .5 + this.transform.cameraToCenterDistance / g.signedDistanceFromCamera * .5,
                isOccluded: g.isOccluded,
                signedDistanceFromCamera: g.signedDistanceFromCamera
              }
            }
          }
          getPerspectiveRatio(e, a, o, c) {
            const d = this.transform.projectTileCoordinates(e, a, o, c);
            return .5 + this.transform.cameraToCenterDistance / d.signedDistanceFromCamera * .5
          }
          isOffscreen(e, a, o, c) {
            return o < Or || e >= this.screenRightBoundary || c < Or || a > this.screenBottomBoundary
          }
          isInsideGrid(e, a, o, c) {
            return o >= 0 && e < this.gridRightBoundary && c >= 0 && a < this.gridBottomBoundary
          }
          getViewportMatrix() {
            const e = s.am([]);
            return s.N(e, e, [-100, -100, 0]), e
          }
          _projectCollisionBox(e, a, o, c, d, g, w, S, A, E, F) {
            let R = 1,
              U = 0,
              Y = 0,
              se = 1;
            const le = e.anchorPointX + w[0],
              ce = e.anchorPointY + w[1];
            if (g && !d) {
              const lr = this.projectAndGetPerspectiveRatio(le + 1, ce, c, A, F),
                Bt = lr.x - S.x,
                qr = Math.atan((lr.y - S.y) / Bt) + (Bt < 0 ? Math.PI : 0),
                yi = Math.sin(qr),
                Hi = Math.cos(qr);
              R = Hi, U = yi, Y = -yi, se = Hi
            } else if (!g && d) {
              const lr = fr(this.transform);
              R = lr.vecEast[0], U = lr.vecEast[1], Y = lr.vecSouth[0], se = lr.vecSouth[1]
            }
            let ge = S.x,
              Pe = S.y,
              fe = a;
            d && (ge = le, Pe = ce, fe = Math.pow(2, -(this.transform.zoom - o.overscaledZ)), fe *= this.transform.getPitchedTextCorrection(le, ce, c), E || (fe *= s.ai(.5 + S.signedDistanceFromCamera / this.transform.cameraToCenterDistance * .5, 0, 4))), E && (ge += R * E.x * fe + Y * E.y * fe, Pe += U * E.x * fe + se * E.y * fe);
            const Me = e.x1 * fe,
              Ee = e.x2 * fe,
              ve = (Me + Ee) / 2,
              Oe = e.y1 * fe,
              lt = e.y2 * fe,
              it = (Oe + lt) / 2,
              st = [{
                offsetX: Me,
                offsetY: Oe
              }, {
                offsetX: ve,
                offsetY: Oe
              }, {
                offsetX: Ee,
                offsetY: Oe
              }, {
                offsetX: Ee,
                offsetY: it
              }, {
                offsetX: Ee,
                offsetY: lt
              }, {
                offsetX: ve,
                offsetY: lt
              }, {
                offsetX: Me,
                offsetY: lt
              }, {
                offsetX: Me,
                offsetY: it
              }];
            let ct = [];
            for (const {
                offsetX: lr,
                offsetY: Bt
              }
              of st) ct.push(new s.P(ge + R * lr + Y * Bt, Pe + U * lr + se * Bt));
            let nr = !1;
            if (d) {
              const lr = ct.map((Bt => this.projectAndGetPerspectiveRatio(Bt.x, Bt.y, c, A, F)));
              nr = lr.some((Bt => !Bt.isOccluded)), ct = lr.map((Bt => new s.P(Bt.x, Bt.y)))
            } else nr = !0;
            return {
              box: s.aE(ct),
              allPointsOccluded: !nr
            }
          }
        }
        class ti {
          constructor(e, a, o, c) {
            this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? a : -a))) : c && o ? 1 : 0, this.placed = o
          }
          isHidden() {
            return this.opacity === 0 && !this.placed
          }
        }
        class Ai {
          constructor(e, a, o, c, d) {
            this.text = new ti(e ? e.text : null, a, o, d), this.icon = new ti(e ? e.icon : null, a, c, d)
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden()
          }
        }
        class bi {
          constructor(e, a, o) {
            this.text = e, this.icon = a, this.skipFade = o
          }
        }
        class Yr {
          constructor(e, a, o, c, d) {
            this.bucketInstanceId = e, this.featureIndex = a, this.sourceLayerIndex = o, this.bucketIndex = c, this.tileID = d
          }
        }
        class Zr {
          constructor(e) {
            this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {}
          }
          get(e) {
            if (this.crossSourceCollisions) return {
              ID: 0,
              predicate: null
            };
            if (!this.collisionGroups[e]) {
              const a = ++this.maxGroupID;
              this.collisionGroups[e] = {
                ID: a,
                predicate: o => o.collisionGroupID === a
              }
            }
            return this.collisionGroups[e]
          }
        }

        function Ii(h, e, a, o, c) {
          const {
            horizontalAlign: d,
            verticalAlign: g
          } = s.aL(h);
          return new s.P(-(d - .5) * e + o[0] * c, -(g - .5) * a + o[1] * c)
        }
        class ki {
          constructor(e, a, o, c, d) {
            this.transform = e.clone(), this.terrain = a, this.collisionIndex = new Fr(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = o, this.retainedQueryData = {}, this.collisionGroups = new Zr(c), this.collisionCircleArrays = {}, this.collisionBoxArrays = new Map, this.prevPlacement = d, d && (d.prevPlacement = void 0), this.placedOrientations = {}
          }
          _getTerrainElevationFunc(e) {
            const a = this.terrain;
            return a ? (o, c) => a.getElevation(e, o, c) : null
          }
          getBucketParts(e, a, o, c) {
            const d = o.getBucket(a),
              g = o.latestFeatureIndex;
            if (!d || !g || a.id !== d.layerIds[0]) return;
            const w = o.collisionBoxArray,
              S = d.layers[0].layout,
              A = d.layers[0].paint,
              E = Math.pow(2, this.transform.zoom - o.tileID.overscaledZ),
              F = o.tileSize / s.a3,
              R = o.tileID.toUnwrapped(),
              U = S.get("text-rotation-alignment") === "map",
              Y = s.aG(o, 1, this.transform.zoom),
              se = s.aH(this.collisionIndex.transform, o, A.get("text-translate"), A.get("text-translate-anchor")),
              le = s.aH(this.collisionIndex.transform, o, A.get("icon-translate"), A.get("icon-translate-anchor")),
              ce = Kt(U, this.transform, Y);
            this.retainedQueryData[d.bucketInstanceId] = new Yr(d.bucketInstanceId, g, d.sourceLayerIndex, d.index, o.tileID);
            const ge = {
              bucket: d,
              layout: S,
              translationText: se,
              translationIcon: le,
              unwrappedTileID: R,
              pitchedLabelPlaneMatrix: ce,
              scale: E,
              textPixelRatio: F,
              holdingForFade: o.holdingForSymbolFade(),
              collisionBoxArray: w,
              partiallyEvaluatedTextSize: s.ar(d.textSizeData, this.transform.zoom),
              collisionGroup: this.collisionGroups.get(d.sourceID)
            };
            if (c)
              for (const Pe of d.sortKeyRanges) {
                const {
                  sortKey: fe,
                  symbolInstanceStart: Me,
                  symbolInstanceEnd: Ee
                } = Pe;
                e.push({
                  sortKey: fe,
                  symbolInstanceStart: Me,
                  symbolInstanceEnd: Ee,
                  parameters: ge
                })
              } else e.push({
                symbolInstanceStart: 0,
                symbolInstanceEnd: d.symbolInstances.length,
                parameters: ge
              })
          }
          attemptAnchorPlacement(e, a, o, c, d, g, w, S, A, E, F, R, U, Y, se, le, ce, ge, Pe, fe) {
            const Me = s.aI[e.textAnchor],
              Ee = [e.textOffset0, e.textOffset1],
              ve = Ii(Me, o, c, Ee, d),
              Oe = this.collisionIndex.placeCollisionBox(a, R, S, A, E, w, g, le, F.predicate, Pe, ve, fe);
            if ((!ge || this.collisionIndex.placeCollisionBox(ge, R, S, A, E, w, g, ce, F.predicate, Pe, ve, fe).placeable) && Oe.placeable) {
              let lt;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[U.crossTileID] && this.prevPlacement.placements[U.crossTileID] && this.prevPlacement.placements[U.crossTileID].text && (lt = this.prevPlacement.variableOffsets[U.crossTileID].anchor), U.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[U.crossTileID] = {
                textOffset: Ee,
                width: o,
                height: c,
                anchor: Me,
                textBoxScale: d,
                prevAnchor: lt
              }, this.markUsedJustification(Y, Me, U, se), Y.allowVerticalPlacement && (this.markUsedOrientation(Y, se, U), this.placedOrientations[U.crossTileID] = se), {
                shift: ve,
                placedGlyphBoxes: Oe
              }
            }
          }
          placeLayerBucketPart(e, a, o) {
            const {
              bucket: c,
              layout: d,
              translationText: g,
              translationIcon: w,
              unwrappedTileID: S,
              pitchedLabelPlaneMatrix: A,
              textPixelRatio: E,
              holdingForFade: F,
              collisionBoxArray: R,
              partiallyEvaluatedTextSize: U,
              collisionGroup: Y
            } = e.parameters, se = d.get("text-optional"), le = d.get("icon-optional"), ce = s.aJ(d, "text-overlap", "text-allow-overlap"), ge = ce === "always", Pe = s.aJ(d, "icon-overlap", "icon-allow-overlap"), fe = Pe === "always", Me = d.get("text-rotation-alignment") === "map", Ee = d.get("text-pitch-alignment") === "map", ve = d.get("icon-text-fit") !== "none", Oe = d.get("symbol-z-order") === "viewport-y", lt = ge && (fe || !c.hasIconData() || le), it = fe && (ge || !c.hasTextData() || se);
            !c.collisionArrays && R && c.deserializeCollisionBoxes(R);
            const st = this.retainedQueryData[c.bucketInstanceId].tileID,
              ct = this._getTerrainElevationFunc(st),
              nr = this.transform.getFastPathSimpleProjectionMatrix(st),
              lr = (Bt, qr, yi) => {
                var Hi, Ci;
                if (a[Bt.crossTileID]) return;
                if (F) return void(this.placements[Bt.crossTileID] = new bi(!1, !1, !1));
                let Qi = !1,
                  fa = !1,
                  ta = !0,
                  ka = null,
                  oa = {
                    box: null,
                    placeable: !1,
                    offscreen: null,
                    occluded: !1
                  },
                  Va = {
                    placeable: !1
                  },
                  la = null,
                  Ia = null,
                  un = null,
                  Ks = 0,
                  ps = 0,
                  is = 0;
                qr.textFeatureIndex ? Ks = qr.textFeatureIndex : Bt.useRuntimeCollisionCircles && (Ks = Bt.featureIndex), qr.verticalTextFeatureIndex && (ps = qr.verticalTextFeatureIndex);
                const Js = qr.textBox;
                if (Js) {
                  const hn = Ca => {
                      let ba = s.as.horizontal;
                      if (c.allowVerticalPlacement && !Ca && this.prevPlacement) {
                        const Za = this.prevPlacement.placedOrientations[Bt.crossTileID];
                        Za && (this.placedOrientations[Bt.crossTileID] = Za, ba = Za, this.markUsedOrientation(c, ba, Bt))
                      }
                      return ba
                    },
                    fs = (Ca, ba) => {
                      if (c.allowVerticalPlacement && Bt.numVerticalGlyphVertices > 0 && qr.verticalTextBox) {
                        for (const Za of c.writingModes)
                          if (Za === s.as.vertical ? (oa = ba(), Va = oa) : oa = Ca(), oa && oa.placeable) break
                      } else oa = Ca()
                    },
                    Ms = Bt.textAnchorOffsetStartIndex,
                    nl = Bt.textAnchorOffsetEndIndex;
                  if (nl === Ms) {
                    const Ca = (ba, Za) => {
                      const ia = this.collisionIndex.placeCollisionBox(ba, ce, E, st, S, Ee, Me, g, Y.predicate, ct, void 0, nr);
                      return ia && ia.placeable && (this.markUsedOrientation(c, Za, Bt), this.placedOrientations[Bt.crossTileID] = Za), ia
                    };
                    fs((() => Ca(Js, s.as.horizontal)), (() => {
                      const ba = qr.verticalTextBox;
                      return c.allowVerticalPlacement && Bt.numVerticalGlyphVertices > 0 && ba ? Ca(ba, s.as.vertical) : {
                        box: null,
                        offscreen: null
                      }
                    })), hn(oa && oa.placeable)
                  } else {
                    let Ca = s.aI[(Ci = (Hi = this.prevPlacement) === null || Hi === void 0 ? void 0 : Hi.variableOffsets[Bt.crossTileID]) === null || Ci === void 0 ? void 0 : Ci.anchor];
                    const ba = (ia, Gn, Is) => {
                      const Id = ia.x2 - ia.x1,
                        Cd = ia.y2 - ia.y1,
                        Ad = Bt.textBoxScale,
                        eo = ve && Pe === "never" ? Gn : null;
                      let to = null,
                        Mu = ce === "never" ? 1 : 2,
                        Ql = "never";
                      Ca && Mu++;
                      for (let Iu = 0; Iu < Mu; Iu++) {
                        for (let ms = Ms; ms < nl; ms++) {
                          const Cs = c.textAnchorOffsets.get(ms);
                          if (Ca && Cs.textAnchor !== Ca) continue;
                          const ec = this.attemptAnchorPlacement(Cs, ia, Id, Cd, Ad, Me, Ee, E, st, S, Y, Ql, Bt, c, Is, g, w, eo, ct);
                          if (ec && (to = ec.placedGlyphBoxes, to && to.placeable)) return Qi = !0, ka = ec.shift, to
                        }
                        Ca ? Ca = null : Ql = ce
                      }
                      return o && !to && (to = {
                        box: this.collisionIndex.placeCollisionBox(Js, "always", E, st, S, Ee, Me, g, Y.predicate, ct, void 0, nr).box,
                        offscreen: !1,
                        placeable: !1,
                        occluded: !1
                      }), to
                    };
                    fs((() => ba(Js, qr.iconBox, s.as.horizontal)), (() => {
                      const ia = qr.verticalTextBox;
                      return c.allowVerticalPlacement && (!oa || !oa.placeable) && Bt.numVerticalGlyphVertices > 0 && ia ? ba(ia, qr.verticalIconBox, s.as.vertical) : {
                        box: null,
                        occluded: !0,
                        offscreen: null
                      }
                    })), oa && (Qi = oa.placeable, ta = oa.offscreen);
                    const Za = hn(oa && oa.placeable);
                    if (!Qi && this.prevPlacement) {
                      const ia = this.prevPlacement.variableOffsets[Bt.crossTileID];
                      ia && (this.variableOffsets[Bt.crossTileID] = ia, this.markUsedJustification(c, ia.anchor, Bt, Za))
                    }
                  }
                }
                if (la = oa, Qi = la && la.placeable, ta = la && la.offscreen, Bt.useRuntimeCollisionCircles && Bt.centerJustifiedTextSymbolIndex >= 0) {
                  const hn = c.text.placedSymbolArray.get(Bt.centerJustifiedTextSymbolIndex),
                    fs = s.at(c.textSizeData, U, hn),
                    Ms = d.get("text-padding");
                  Ia = this.collisionIndex.placeCollisionCircles(ce, hn, c.lineVertexArray, c.glyphOffsetArray, fs, S, A, o, Ee, Y.predicate, Bt.collisionCircleDiameter, Ms, g, ct), Ia.circles.length && Ia.collisionDetected && !o && s.w("Collisions detected, but collision boxes are not shown"), Qi = ge || Ia.circles.length > 0 && !Ia.collisionDetected, ta = ta && Ia.offscreen
                }
                if (qr.iconFeatureIndex && (is = qr.iconFeatureIndex), qr.iconBox) {
                  const hn = fs => this.collisionIndex.placeCollisionBox(fs, Pe, E, st, S, Ee, Me, w, Y.predicate, ct, ve && ka ? ka : void 0, nr);
                  Va && Va.placeable && qr.verticalIconBox ? (un = hn(qr.verticalIconBox), fa = un.placeable) : (un = hn(qr.iconBox), fa = un.placeable), ta = ta && un.offscreen
                }
                const Ao = se || Bt.numHorizontalGlyphVertices === 0 && Bt.numVerticalGlyphVertices === 0,
                  Qs = le || Bt.numIconVertices === 0;
                Ao || Qs ? Qs ? Ao || (fa = fa && Qi) : Qi = fa && Qi : fa = Qi = fa && Qi;
                const _n = fa && un.placeable;
                if (Qi && la.placeable && this.collisionIndex.insertCollisionBox(la.box, ce, d.get("text-ignore-placement"), c.bucketInstanceId, Va && Va.placeable && ps ? ps : Ks, Y.ID), _n && this.collisionIndex.insertCollisionBox(un.box, Pe, d.get("icon-ignore-placement"), c.bucketInstanceId, is, Y.ID), Ia && Qi && this.collisionIndex.insertCollisionCircles(Ia.circles, ce, d.get("text-ignore-placement"), c.bucketInstanceId, Ks, Y.ID), o && this.storeCollisionData(c.bucketInstanceId, yi, qr, la, un, Ia), Bt.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
                if (c.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
                this.placements[Bt.crossTileID] = new bi((Qi || lt) && !(la != null && la.occluded), (fa || it) && !(un != null && un.occluded), ta || c.justReloaded), a[Bt.crossTileID] = !0
              };
            if (Oe) {
              if (e.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
              const Bt = c.getSortedSymbolIndexes(-this.transform.bearingInRadians);
              for (let qr = Bt.length - 1; qr >= 0; --qr) {
                const yi = Bt[qr];
                lr(c.symbolInstances.get(yi), c.collisionArrays[yi], yi)
              }
            } else
              for (let Bt = e.symbolInstanceStart; Bt < e.symbolInstanceEnd; Bt++) lr(c.symbolInstances.get(Bt), c.collisionArrays[Bt], Bt);
            c.justReloaded = !1
          }
          storeCollisionData(e, a, o, c, d, g) {
            if (o.textBox || o.iconBox) {
              let w, S;
              this.collisionBoxArrays.has(e) ? w = this.collisionBoxArrays.get(e) : (w = new Map, this.collisionBoxArrays.set(e, w)), w.has(a) ? S = w.get(a) : (S = {
                text: null,
                icon: null
              }, w.set(a, S)), o.textBox && (S.text = c.box), o.iconBox && (S.icon = d.box)
            }
            if (g) {
              let w = this.collisionCircleArrays[e];
              w === void 0 && (w = this.collisionCircleArrays[e] = []);
              for (let S = 0; S < g.circles.length; S += 4) w.push(g.circles[S + 0] - Or), w.push(g.circles[S + 1] - Or), w.push(g.circles[S + 2]), w.push(g.collisionDetected ? 1 : 0)
            }
          }
          markUsedJustification(e, a, o, c) {
            let d;
            d = c === s.as.vertical ? o.verticalPlacedTextSymbolIndex : {
              left: o.leftJustifiedTextSymbolIndex,
              center: o.centerJustifiedTextSymbolIndex,
              right: o.rightJustifiedTextSymbolIndex
            } [s.aK(a)];
            const g = [o.leftJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.rightJustifiedTextSymbolIndex, o.verticalPlacedTextSymbolIndex];
            for (const w of g) w >= 0 && (e.text.placedSymbolArray.get(w).crossTileID = d >= 0 && w !== d ? 0 : o.crossTileID)
          }
          markUsedOrientation(e, a, o) {
            const c = a === s.as.horizontal || a === s.as.horizontalOnly ? a : 0,
              d = a === s.as.vertical ? a : 0,
              g = [o.leftJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.rightJustifiedTextSymbolIndex];
            for (const w of g) e.text.placedSymbolArray.get(w).placedOrientation = c;
            o.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(o.verticalPlacedTextSymbolIndex).placedOrientation = d)
          }
          commit(e) {
            this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const a = this.prevPlacement;
            let o = !1;
            this.prevZoomAdjustment = a ? a.zoomAdjustment(this.transform.zoom) : 0;
            const c = a ? a.symbolFadeChange(e) : 1,
              d = a ? a.opacities : {},
              g = a ? a.variableOffsets : {},
              w = a ? a.placedOrientations : {};
            for (const S in this.placements) {
              const A = this.placements[S],
                E = d[S];
              E ? (this.opacities[S] = new Ai(E, c, A.text, A.icon), o = o || A.text !== E.text.placed || A.icon !== E.icon.placed) : (this.opacities[S] = new Ai(null, c, A.text, A.icon, A.skipFade), o = o || A.text || A.icon)
            }
            for (const S in d) {
              const A = d[S];
              if (!this.opacities[S]) {
                const E = new Ai(A, c, !1, !1);
                E.isHidden() || (this.opacities[S] = E, o = o || A.text.placed || A.icon.placed)
              }
            }
            for (const S in g) this.variableOffsets[S] || !this.opacities[S] || this.opacities[S].isHidden() || (this.variableOffsets[S] = g[S]);
            for (const S in w) this.placedOrientations[S] || !this.opacities[S] || this.opacities[S].isHidden() || (this.placedOrientations[S] = w[S]);
            if (a && a.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
            o ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = a ? a.lastPlacementChangeTime : e)
          }
          updateLayerOpacities(e, a) {
            const o = {};
            for (const c of a) {
              const d = c.getBucket(e);
              d && c.latestFeatureIndex && e.id === d.layerIds[0] && this.updateBucketOpacities(d, c.tileID, o, c.collisionBoxArray)
            }
          }
          updateBucketOpacities(e, a, o, c) {
            e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = !1), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = !1), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
            const d = e.layers[0],
              g = d.layout,
              w = new Ai(null, 0, !1, !1, !0),
              S = g.get("text-allow-overlap"),
              A = g.get("icon-allow-overlap"),
              E = d._unevaluatedLayout.hasValue("text-variable-anchor") || d._unevaluatedLayout.hasValue("text-variable-anchor-offset"),
              F = g.get("text-rotation-alignment") === "map",
              R = g.get("text-pitch-alignment") === "map",
              U = g.get("icon-text-fit") !== "none",
              Y = new Ai(null, 0, S && (A || !e.hasIconData() || g.get("icon-optional")), A && (S || !e.hasTextData() || g.get("text-optional")), !0);
            !e.collisionArrays && c && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(c);
            const se = (ce, ge, Pe) => {
                for (let fe = 0; fe < ge / 4; fe++) ce.opacityVertexArray.emplaceBack(Pe);
                ce.hasVisibleVertices = ce.hasVisibleVertices || Pe !== Xi
              },
              le = this.collisionBoxArrays.get(e.bucketInstanceId);
            for (let ce = 0; ce < e.symbolInstances.length; ce++) {
              const ge = e.symbolInstances.get(ce),
                {
                  numHorizontalGlyphVertices: Pe,
                  numVerticalGlyphVertices: fe,
                  crossTileID: Me
                } = ge;
              let Ee = this.opacities[Me];
              o[Me] ? Ee = w : Ee || (Ee = Y, this.opacities[Me] = Ee), o[Me] = !0;
              const ve = ge.numIconVertices > 0,
                Oe = this.placedOrientations[ge.crossTileID],
                lt = Oe === s.as.vertical,
                it = Oe === s.as.horizontal || Oe === s.as.horizontalOnly;
              if (Pe > 0 || fe > 0) {
                const ct = Ta(Ee.text);
                se(e.text, Pe, lt ? Xi : ct), se(e.text, fe, it ? Xi : ct);
                const nr = Ee.text.isHidden();
                [ge.rightJustifiedTextSymbolIndex, ge.centerJustifiedTextSymbolIndex, ge.leftJustifiedTextSymbolIndex].forEach((qr => {
                  qr >= 0 && (e.text.placedSymbolArray.get(qr).hidden = nr || lt ? 1 : 0)
                })), ge.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(ge.verticalPlacedTextSymbolIndex).hidden = nr || it ? 1 : 0);
                const lr = this.variableOffsets[ge.crossTileID];
                lr && this.markUsedJustification(e, lr.anchor, ge, Oe);
                const Bt = this.placedOrientations[ge.crossTileID];
                Bt && (this.markUsedJustification(e, "left", ge, Bt), this.markUsedOrientation(e, Bt, ge))
              }
              if (ve) {
                const ct = Ta(Ee.icon),
                  nr = !(U && ge.verticalPlacedIconSymbolIndex && lt);
                ge.placedIconSymbolIndex >= 0 && (se(e.icon, ge.numIconVertices, nr ? ct : Xi), e.icon.placedSymbolArray.get(ge.placedIconSymbolIndex).hidden = Ee.icon.isHidden()), ge.verticalPlacedIconSymbolIndex >= 0 && (se(e.icon, ge.numVerticalIconVertices, nr ? Xi : ct), e.icon.placedSymbolArray.get(ge.verticalPlacedIconSymbolIndex).hidden = Ee.icon.isHidden())
              }
              const st = le && le.has(ce) ? le.get(ce) : {
                text: null,
                icon: null
              };
              if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
                const ct = e.collisionArrays[ce];
                if (ct) {
                  let nr = new s.P(0, 0);
                  if (ct.textBox || ct.verticalTextBox) {
                    let lr = !0;
                    if (E) {
                      const Bt = this.variableOffsets[Me];
                      Bt ? (nr = Ii(Bt.anchor, Bt.width, Bt.height, Bt.textOffset, Bt.textBoxScale), F && nr._rotate(R ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : lr = !1
                    }
                    if (ct.textBox || ct.verticalTextBox) {
                      let Bt;
                      ct.textBox && (Bt = lt), ct.verticalTextBox && (Bt = it), wi(e.textCollisionBox.collisionVertexArray, Ee.text.placed, !lr || Bt, st.text, nr.x, nr.y)
                    }
                  }
                  if (ct.iconBox || ct.verticalIconBox) {
                    const lr = !!(!it && ct.verticalIconBox);
                    let Bt;
                    ct.iconBox && (Bt = lr), ct.verticalIconBox && (Bt = !lr), wi(e.iconCollisionBox.collisionVertexArray, Ee.icon.placed, Bt, st.icon, U ? nr.x : 0, U ? nr.y : 0)
                  }
                }
              }
            }
            if (e.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`);
            if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`);
            e.bucketInstanceId in this.collisionCircleArrays && (e.collisionCircleArray = this.collisionCircleArrays[e.bucketInstanceId], delete this.collisionCircleArrays[e.bucketInstanceId])
          }
          symbolFadeChange(e) {
            return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment
          }
          zoomAdjustment(e) {
            return Math.max(0, (this.transform.zoom - e) / 1.5)
          }
          hasTransitions(e) {
            return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration
          }
          stillRecent(e, a) {
            const o = this.zoomAtLastRecencyCheck === a ? 1 - this.zoomAdjustment(a) : 1;
            return this.zoomAtLastRecencyCheck = a, this.commitTime + this.fadeDuration * o > e
          }
          setStale() {
            this.stale = !0
          }
        }

        function wi(h, e, a, o, c, d) {
          o && o.length !== 0 || (o = [0, 0, 0, 0]);
          const g = o[0] - Or,
            w = o[1] - Or,
            S = o[2] - Or,
            A = o[3] - Or;
          h.emplaceBack(e ? 1 : 0, a ? 1 : 0, c || 0, d || 0, g, w), h.emplaceBack(e ? 1 : 0, a ? 1 : 0, c || 0, d || 0, S, w), h.emplaceBack(e ? 1 : 0, a ? 1 : 0, c || 0, d || 0, S, A), h.emplaceBack(e ? 1 : 0, a ? 1 : 0, c || 0, d || 0, g, A)
        }
        const Vi = Math.pow(2, 25),
          Yi = Math.pow(2, 24),
          pt = Math.pow(2, 17),
          Ft = Math.pow(2, 16),
          zr = Math.pow(2, 9),
          Bi = Math.pow(2, 8),
          Zi = Math.pow(2, 1);

        function Ta(h) {
          if (h.opacity === 0 && !h.placed) return 0;
          if (h.opacity === 1 && h.placed) return 4294967295;
          const e = h.placed ? 1 : 0,
            a = Math.floor(127 * h.opacity);
          return a * Vi + e * Yi + a * pt + e * Ft + a * zr + e * Bi + a * Zi + e
        }
        const Xi = 0;
        class ji {
          constructor(e) {
            this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = []
          }
          continuePlacement(e, a, o, c, d) {
            const g = this._bucketParts;
            for (; this._currentTileIndex < e.length;)
              if (a.getBucketParts(g, c, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, d()) return !0;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, g.sort(((w, S) => w.sortKey - S.sortKey))); this._currentPartIndex < g.length;)
              if (a.placeLayerBucketPart(g[this._currentPartIndex], this._seenCrossTileIDs, o), this._currentPartIndex++, d()) return !0;
            return !1
          }
        }
        class La {
          constructor(e, a, o, c, d, g, w, S) {
            this.placement = new ki(e, a, g, w, S), this._currentPlacementIndex = o.length - 1, this._forceFullPlacement = c, this._showCollisionBoxes = d, this._done = !1
          }
          isDone() {
            return this._done
          }
          continuePlacement(e, a, o) {
            const c = _e(),
              d = () => !this._forceFullPlacement && _e() - c > 2;
            for (; this._currentPlacementIndex >= 0;) {
              const g = a[e[this._currentPlacementIndex]],
                w = this.placement.collisionIndex.transform.zoom;
              if (g.type === "symbol" && (!g.minzoom || g.minzoom <= w) && (!g.maxzoom || g.maxzoom > w)) {
                if (this._inProgressLayer || (this._inProgressLayer = new ji(g)), this._inProgressLayer.continuePlacement(o[g.source], this.placement, this._showCollisionBoxes, g, d)) return;
                delete this._inProgressLayer
              }
              this._currentPlacementIndex--
            }
            this._done = !0
          }
          commit(e) {
            return this.placement.commit(e), this.placement
          }
        }
        const Br = 512 / s.a3 / 2;
        class Pr {
          constructor(e, a, o) {
            this.tileID = e, this.bucketInstanceId = o, this._symbolsByKey = {};
            const c = new Map;
            for (let d = 0; d < a.length; d++) {
              const g = a.get(d),
                w = g.key,
                S = c.get(w);
              S ? S.push(g) : c.set(w, [g])
            }
            for (const [d, g] of c) {
              const w = {
                positions: g.map((S => ({
                  x: Math.floor(S.anchorX * Br),
                  y: Math.floor(S.anchorY * Br)
                }))),
                crossTileIDs: g.map((S => S.crossTileID))
              };
              if (w.positions.length > 128) {
                const S = new s.aM(w.positions.length, 16, Uint16Array);
                for (const {
                    x: A,
                    y: E
                  }
                  of w.positions) S.add(A, E);
                S.finish(), delete w.positions, w.index = S
              }
              this._symbolsByKey[d] = w
            }
          }
          getScaledCoordinates(e, a) {
            const {
              x: o,
              y: c,
              z: d
            } = this.tileID.canonical, {
              x: g,
              y: w,
              z: S
            } = a.canonical, A = Br / Math.pow(2, S - d), E = (w * s.a3 + e.anchorY) * A, F = c * s.a3 * Br;
            return {
              x: Math.floor((g * s.a3 + e.anchorX) * A - o * s.a3 * Br),
              y: Math.floor(E - F)
            }
          }
          findMatches(e, a, o) {
            const c = this.tileID.canonical.z < a.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - a.canonical.z);
            for (let d = 0; d < e.length; d++) {
              const g = e.get(d);
              if (g.crossTileID) continue;
              const w = this._symbolsByKey[g.key];
              if (!w) continue;
              const S = this.getScaledCoordinates(g, a);
              if (w.index) {
                const A = w.index.range(S.x - c, S.y - c, S.x + c, S.y + c).sort();
                for (const E of A) {
                  const F = w.crossTileIDs[E];
                  if (!o[F]) {
                    o[F] = !0, g.crossTileID = F;
                    break
                  }
                }
              } else if (w.positions)
                for (let A = 0; A < w.positions.length; A++) {
                  const E = w.positions[A],
                    F = w.crossTileIDs[A];
                  if (Math.abs(E.x - S.x) <= c && Math.abs(E.y - S.y) <= c && !o[F]) {
                    o[F] = !0, g.crossTileID = F;
                    break
                  }
                }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map((({
              crossTileIDs: e
            }) => e))
          }
        }
        class zi {
          constructor() {
            this.maxCrossTileID = 0
          }
          generate() {
            return ++this.maxCrossTileID
          }
        }
        class hi {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0
          }
          handleWrapJump(e) {
            const a = Math.round((e - this.lng) / 360);
            if (a !== 0)
              for (const o in this.indexes) {
                const c = this.indexes[o],
                  d = {};
                for (const g in c) {
                  const w = c[g];
                  w.tileID = w.tileID.unwrapTo(w.tileID.wrap + a), d[w.tileID.key] = w
                }
                this.indexes[o] = d
              }
            this.lng = e
          }
          addBucket(e, a, o) {
            if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
              if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === a.bucketInstanceId) return !1;
              this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key])
            }
            for (let d = 0; d < a.symbolInstances.length; d++) a.symbolInstances.get(d).crossTileID = 0;
            this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
            const c = this.usedCrossTileIDs[e.overscaledZ];
            for (const d in this.indexes) {
              const g = this.indexes[d];
              if (Number(d) > e.overscaledZ)
                for (const w in g) {
                  const S = g[w];
                  S.tileID.isChildOf(e) && S.findMatches(a.symbolInstances, e, c)
                } else {
                  const w = g[e.scaledTo(Number(d)).key];
                  w && w.findMatches(a.symbolInstances, e, c)
                }
            }
            for (let d = 0; d < a.symbolInstances.length; d++) {
              const g = a.symbolInstances.get(d);
              g.crossTileID || (g.crossTileID = o.generate(), c[g.crossTileID] = !0)
            }
            return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new Pr(e, a.symbolInstances, a.bucketInstanceId), !0
          }
          removeBucketCrossTileIDs(e, a) {
            for (const o of a.getCrossTileIDsLists())
              for (const c of o) delete this.usedCrossTileIDs[e][c]
          }
          removeStaleBuckets(e) {
            let a = !1;
            for (const o in this.indexes) {
              const c = this.indexes[o];
              for (const d in c) e[c[d].bucketInstanceId] || (this.removeBucketCrossTileIDs(o, c[d]), delete c[d], a = !0)
            }
            return a
          }
        }
        class kr {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new zi, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {}
          }
          addLayer(e, a, o) {
            let c = this.layerIndexes[e.id];
            c === void 0 && (c = this.layerIndexes[e.id] = new hi);
            let d = !1;
            const g = {};
            c.handleWrapJump(o);
            for (const w of a) {
              const S = w.getBucket(e);
              S && e.id === S.layerIds[0] && (S.bucketInstanceId || (S.bucketInstanceId = ++this.maxBucketInstanceId), c.addBucket(w.tileID, S, this.crossTileIDs) && (d = !0), g[S.bucketInstanceId] = !0)
            }
            return c.removeStaleBuckets(g) && (d = !0), d
          }
          pruneUnusedLayers(e) {
            const a = {};
            e.forEach((o => {
              a[o] = !0
            }));
            for (const o in this.layerIndexes) a[o] || delete this.layerIndexes[o]
          }
        }
        var mi = "void main() {fragColor=vec4(1.0);}";
        const Ir = {
          prelude: ei(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`),
          projectionMercator: ei("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"),
          projectionGlobe: ei("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`),
          background: ei(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
          backgroundPattern: ei(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"),
          circle: ei(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`),
          clippingMask: ei(mi, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
          heatmap: ei(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`),
          heatmapTexture: ei(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"),
          collisionBox: ei("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
          collisionCircle: ei("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
          colorRelief: ei(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
          debug: ei("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"),
          depth: ei(mi, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`),
          fill: ei(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`),
          fillOutline: ei(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`),
          fillOutlinePattern: ei(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`),
          fillPattern: ei(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`),
          fillExtrusion: ei(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`),
          fillExtrusionPattern: ei(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`),
          hillshadePrepare: ei(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
          hillshade: ei(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
          line: ei(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
          lineGradient: ei(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
          linePattern: ei(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`),
          lineSDF: ei(`uniform lowp float u_device_pixel_ratio;uniform lowp float u_lineatlas_width;uniform sampler2D u_image;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0/u_device_pixel_ratio)/min(dasharray_from.w,dasharray_to.w);alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`),
          lineGradientSDF: ei(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform sampler2D u_image_dash;uniform float u_mix;uniform lowp float u_lineatlas_width;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);float sdfdist_a=texture(u_image_dash,v_tex_a).a;float sdfdist_b=texture(u_image_dash,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0)/min(dasharray_from.w,dasharray_to.w);float dash_alpha=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*dash_alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;out vec2 v_tex_a;out vec2 v_tex_b;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;float texel_height=1.0/u_image_height;float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`),
          raster: ei(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`),
          symbolIcon: ei(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`),
          symbolSDF: ei(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`),
          symbolTextAndIcon: ei(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`),
          terrain: ei("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"),
          terrainDepth: ei("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"),
          terrainCoords: ei("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"),
          projectionErrorMeasurement: ei("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"),
          atmosphere: ei(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"),
          sky: ei("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}")
        };

        function ei(h, e) {
          const a = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g,
            o = e.match(/in ([\w]+) ([\w]+)/g),
            c = h.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
            d = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
            g = d ? d.concat(c) : c,
            w = {};
          return {
            fragmentSource: h = h.replace(a, ((S, A, E, F, R) => (w[R] = !0, A === "define" ? `
#ifndef HAS_UNIFORM_u_${R}
in ${E} ${F} ${R};
#else
uniform ${E} ${F} u_${R};
#endif
` : `
#ifdef HAS_UNIFORM_u_${R}
    ${E} ${F} ${R} = u_${R};
#endif
`))),
            vertexSource: e = e.replace(a, ((S, A, E, F, R) => {
              const U = F === "float" ? "vec2" : "vec4",
                Y = R.match(/color/) ? "color" : U;
              return w[R] ? A === "define" ? `
#ifndef HAS_UNIFORM_u_${R}
uniform lowp float u_${R}_t;
in ${E} ${U} a_${R};
out ${E} ${F} ${R};
#else
uniform ${E} ${F} u_${R};
#endif
` : Y === "vec4" ? `
#ifndef HAS_UNIFORM_u_${R}
    ${R} = a_${R};
#else
    ${E} ${F} ${R} = u_${R};
#endif
` : `
#ifndef HAS_UNIFORM_u_${R}
    ${R} = unpack_mix_${Y}(a_${R}, u_${R}_t);
#else
    ${E} ${F} ${R} = u_${R};
#endif
` : A === "define" ? `
#ifndef HAS_UNIFORM_u_${R}
uniform lowp float u_${R}_t;
in ${E} ${U} a_${R};
#else
uniform ${E} ${F} u_${R};
#endif
` : Y === "vec4" ? `
#ifndef HAS_UNIFORM_u_${R}
    ${E} ${F} ${R} = a_${R};
#else
    ${E} ${F} ${R} = u_${R};
#endif
` : `
#ifndef HAS_UNIFORM_u_${R}
    ${E} ${F} ${R} = unpack_mix_${Y}(a_${R}, u_${R}_t);
#else
    ${E} ${F} ${R} = u_${R};
#endif
`
            })),
            staticAttributes: o,
            staticUniforms: g
          }
        }
        class Ni {
          constructor(e, a, o) {
            this.vertexBuffer = e, this.indexBuffer = a, this.segments = o
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null
          }
        }
        var Oi = s.aN([{
          name: "a_pos",
          type: "Int16",
          components: 2
        }]);
        const Ei = "#define PROJECTION_MERCATOR",
          Si = "mercator";
        class Pi {
          constructor() {
            this._cachedMesh = null
          }
          get name() {
            return "mercator"
          }
          get useSubdivision() {
            return !1
          }
          get shaderVariantName() {
            return Si
          }
          get shaderDefine() {
            return Ei
          }
          get shaderPreludeCode() {
            return Ir.projectionMercator
          }
          get vertexShaderPreludeCode() {
            return Ir.projectionMercator.vertexSource
          }
          get subdivisionGranularity() {
            return s.aO.noSubdivision
          }
          get useGlobeControls() {
            return !1
          }
          get transitionState() {
            return 0
          }
          get latitudeErrorCorrectionRadians() {
            return 0
          }
          destroy() {}
          updateGPUdependent(e) {}
          getMeshFromTileID(e, a, o, c, d) {
            if (this._cachedMesh) return this._cachedMesh;
            const g = new s.aP;
            g.emplaceBack(0, 0), g.emplaceBack(s.a3, 0), g.emplaceBack(0, s.a3), g.emplaceBack(s.a3, s.a3);
            const w = e.createVertexBuffer(g, Oi.members),
              S = s.aQ.simpleSegment(0, 0, 4, 2),
              A = new s.aR;
            A.emplaceBack(1, 0, 2), A.emplaceBack(1, 2, 3);
            const E = e.createIndexBuffer(A);
            return this._cachedMesh = new Ni(w, E, S), this._cachedMesh
          }
          recalculate() {}
          hasTransition() {
            return !1
          }
          setErrorQueryLatitudeDegrees(e) {}
        }
        class di {
          constructor(e = 0, a = 0, o = 0, c = 0) {
            if (isNaN(e) || e < 0 || isNaN(a) || a < 0 || isNaN(o) || o < 0 || isNaN(c) || c < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = e, this.bottom = a, this.left = o, this.right = c
          }
          interpolate(e, a, o) {
            return a.top != null && e.top != null && (this.top = s.F.number(e.top, a.top, o)), a.bottom != null && e.bottom != null && (this.bottom = s.F.number(e.bottom, a.bottom, o)), a.left != null && e.left != null && (this.left = s.F.number(e.left, a.left, o)), a.right != null && e.right != null && (this.right = s.F.number(e.right, a.right, o)), this
          }
          getCenter(e, a) {
            const o = s.ai((this.left + e - this.right) / 2, 0, e),
              c = s.ai((this.top + a - this.bottom) / 2, 0, a);
            return new s.P(o, c)
          }
          equals(e) {
            return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right
          }
          clone() {
            return new di(this.top, this.bottom, this.left, this.right)
          }
          toJSON() {
            return {
              top: this.top,
              bottom: this.bottom,
              left: this.left,
              right: this.right
            }
          }
        }

        function li(h, e) {
          if (!h.renderWorldCopies || h.lngRange) return;
          const a = e.lng - h.center.lng;
          e.lng += a > 180 ? -360 : a < -180 ? 360 : 0
        }

        function rn(h) {
          return Math.max(0, Math.floor(h))
        }
        class Ui {
          constructor(e, a) {
            var o;
            this._callbacks = e, this._tileSize = 512, this._renderWorldCopies = (a == null ? void 0 : a.renderWorldCopies) === void 0 || !!(a != null && a.renderWorldCopies), this._minZoom = (a == null ? void 0 : a.minZoom) || 0, this._maxZoom = (a == null ? void 0 : a.maxZoom) || 22, this._minPitch = (a == null ? void 0 : a.minPitch) == null ? 0 : a == null ? void 0 : a.minPitch, this._maxPitch = (a == null ? void 0 : a.maxPitch) == null ? 60 : a == null ? void 0 : a.maxPitch, this._constrain = (o = a == null ? void 0 : a.constrain) !== null && o !== void 0 ? o : this._callbacks.constrain, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new s.U(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = rn(this._zoom), this._scale = s.al(this._zoom), this._bearingInRadians = 0, this._fovInRadians = .6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new di, this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0
          }
          apply(e, a, o) {
            this._latRange = e.latRange, this._lngRange = e.lngRange, this._width = e.width, this._height = e.height, this._center = e.center, this._elevation = e.elevation, this._minElevationForCurrentTile = e.minElevationForCurrentTile, this._zoom = e.zoom, this._tileZoom = rn(this._zoom), this._scale = s.al(this._zoom), this._bearingInRadians = e.bearingInRadians, this._fovInRadians = e.fovInRadians, this._pitchInRadians = e.pitchInRadians, this._rollInRadians = e.rollInRadians, this._unmodified = e.unmodified, this._edgeInsets = new di(e.padding.top, e.padding.bottom, e.padding.left, e.padding.right), this._minZoom = e.minZoom, this._maxZoom = e.maxZoom, this._minPitch = e.minPitch, this._maxPitch = e.maxPitch, this._renderWorldCopies = e.renderWorldCopies, this._cameraToCenterDistance = e.cameraToCenterDistance, this._nearZ = e.nearZ, this._farZ = e.farZ, this._autoCalculateNearFarZ = !o && e.autoCalculateNearFarZ, a && this.constrainInternal(), this._calcMatrices()
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile
          }
          setMinElevationForCurrentTile(e) {
            this._minElevationForCurrentTile = e
          }
          get tileSize() {
            return this._tileSize
          }
          get tileZoom() {
            return this._tileZoom
          }
          get scale() {
            return this._scale
          }
          get width() {
            return this._width
          }
          get height() {
            return this._height
          }
          get bearingInRadians() {
            return this._bearingInRadians
          }
          get lngRange() {
            return this._lngRange
          }
          get latRange() {
            return this._latRange
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits
          }
          get minZoom() {
            return this._minZoom
          }
          setMinZoom(e) {
            this._minZoom !== e && (this._minZoom = e, this.setZoom(this.constrain(this._center, this.zoom).zoom))
          }
          get maxZoom() {
            return this._maxZoom
          }
          setMaxZoom(e) {
            this._maxZoom !== e && (this._maxZoom = e, this.setZoom(this.constrain(this._center, this.zoom).zoom))
          }
          get minPitch() {
            return this._minPitch
          }
          setMinPitch(e) {
            this._minPitch !== e && (this._minPitch = e, this.setPitch(Math.max(this.pitch, e)))
          }
          get maxPitch() {
            return this._maxPitch
          }
          setMaxPitch(e) {
            this._maxPitch !== e && (this._maxPitch = e, this.setPitch(Math.min(this.pitch, e)))
          }
          get renderWorldCopies() {
            return this._renderWorldCopies
          }
          setRenderWorldCopies(e) {
            e === void 0 ? e = !0 : e === null && (e = !1), this._renderWorldCopies = e
          }
          get constrain() {
            return this._constrain
          }
          setConstrain(e) {
            e || (e = this._callbacks.constrain), this._constrain = e, this.constrainInternal(), this._calcMatrices()
          }
          get worldSize() {
            return this._tileSize * this._scale
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2))
          }
          get size() {
            return new s.P(this._width, this._height)
          }
          get bearing() {
            return this._bearingInRadians / Math.PI * 180
          }
          setBearing(e) {
            const a = s.V(e, -180, 180) * Math.PI / 180;
            var o, c, d, g, w, S, A, E, F;
            this._bearingInRadians !== a && (this._unmodified = !1, this._bearingInRadians = a, this._calcMatrices(), this._rotationMatrix = W(), o = this._rotationMatrix, d = -this._bearingInRadians, g = (c = this._rotationMatrix)[0], w = c[1], S = c[2], A = c[3], E = Math.sin(d), F = Math.cos(d), o[0] = g * F + S * E, o[1] = w * F + A * E, o[2] = g * -E + S * F, o[3] = w * -E + A * F)
          }
          get rotationMatrix() {
            return this._rotationMatrix
          }
          get pitchInRadians() {
            return this._pitchInRadians
          }
          get pitch() {
            return this._pitchInRadians / Math.PI * 180
          }
          setPitch(e) {
            const a = s.ai(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitchInRadians !== a && (this._unmodified = !1, this._pitchInRadians = a, this._calcMatrices())
          }
          get rollInRadians() {
            return this._rollInRadians
          }
          get roll() {
            return this._rollInRadians / Math.PI * 180
          }
          setRoll(e) {
            const a = e / 180 * Math.PI;
            this._rollInRadians !== a && (this._unmodified = !1, this._rollInRadians = a, this._calcMatrices())
          }
          get fovInRadians() {
            return this._fovInRadians
          }
          get fov() {
            return s.aS(this._fovInRadians)
          }
          setFov(e) {
            e = s.ai(e, .1, 150), this.fov !== e && (this._unmodified = !1, this._fovInRadians = s.ak(e), this._calcMatrices())
          }
          get zoom() {
            return this._zoom
          }
          setZoom(e) {
            const a = this.constrain(this._center, e).zoom;
            this._zoom !== a && (this._unmodified = !1, this._zoom = a, this._tileZoom = Math.max(0, Math.floor(a)), this._scale = s.al(a), this.constrainInternal(), this._calcMatrices())
          }
          get center() {
            return this._center
          }
          setCenter(e) {
            e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this.constrainInternal(), this._calcMatrices())
          }
          get elevation() {
            return this._elevation
          }
          setElevation(e) {
            e !== this._elevation && (this._elevation = e, this.constrainInternal(), this._calcMatrices())
          }
          get padding() {
            return this._edgeInsets.toJSON()
          }
          setPadding(e) {
            this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices())
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height)
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter
          }
          get unmodified() {
            return this._unmodified
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance
          }
          get nearZ() {
            return this._nearZ
          }
          get farZ() {
            return this._farZ
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ
          }
          overrideNearFarZ(e, a) {
            this._autoCalculateNearFarZ = !1, this._nearZ = e, this._farZ = a, this._calcMatrices()
          }
          clearNearFarZOverride() {
            this._autoCalculateNearFarZ = !0, this._calcMatrices()
          }
          isPaddingEqual(e) {
            return this._edgeInsets.equals(e)
          }
          interpolatePadding(e, a, o) {
            this._unmodified = !1, this._edgeInsets.interpolate(e, a, o), this.constrainInternal(), this._calcMatrices()
          }
          resize(e, a, o = !0) {
            this._width = e, this._height = a, o && this.constrainInternal(), this._calcMatrices()
          }
          getMaxBounds() {
            return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new wt([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null
          }
          setMaxBounds(e) {
            e ? (this._lngRange = [e.getWest(), e.getEast()], this._latRange = [e.getSouth(), e.getNorth()], this.constrainInternal()) : (this._lngRange = null, this._latRange = [-s.aj, s.aj])
          }
          getCameraQueryGeometry(e, a) {
            if (a.length === 1) return [a[0], e];
            {
              const {
                minX: o,
                minY: c,
                maxX: d,
                maxY: g
              } = s.a6.fromPoints(a).extend(e);
              return [new s.P(o, c), new s.P(d, c), new s.P(d, g), new s.P(o, g), new s.P(o, c)]
            }
          }
          constrainInternal() {
            if (!this.center || !this._width || !this._height || this._constraining) return;
            this._constraining = !0;
            const e = this._unmodified,
              {
                center: a,
                zoom: o
              } = this.constrain(this.center, this.zoom);
            this.setCenter(a), this.setZoom(o), this._unmodified = e, this._constraining = !1
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let e = s.am(new Float64Array(16));
              s.O(e, e, [this._width / 2, -this._height / 2, 1]), s.N(e, e, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e, e = s.am(new Float64Array(16)), s.O(e, e, [1, -1, 1]), s.N(e, e, [-1, -1, 0]), s.O(e, e, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e, this._cameraToCenterDistance = .5 / Math.tan(this.fovInRadians / 2) * this._height
            }
            this._callbacks.calcMatrices()
          }
          calculateCenterFromCameraLngLatAlt(e, a, o, c) {
            const d = o !== void 0 ? o : this.bearing,
              g = c = c !== void 0 ? c : this.pitch,
              w = s.a5.fromLngLat(e, a),
              S = -Math.cos(s.ak(g)),
              A = Math.sin(s.ak(g)),
              E = A * Math.sin(s.ak(d)),
              F = -A * Math.cos(s.ak(d));
            let R = this.elevation;
            const U = a - R;
            let Y;
            S * U >= 0 || Math.abs(S) < .1 ? (Y = 1e4, R = a + Y * S) : Y = -U / S;
            let se, le, ce = s.aT(1, w.y),
              ge = 0;
            do {
              if (ge += 1, ge > 10) break;
              le = Y / ce, se = new s.a5(w.x + E * le, w.y + F * le), ce = 1 / se.meterInMercatorCoordinateUnits()
            } while (Math.abs(Y - le * ce) > 1e-12);
            return {
              center: se.toLngLat(),
              elevation: R,
              zoom: s.ao(this.height / 2 / Math.tan(this.fovInRadians / 2) / le / this.tileSize)
            }
          }
          recalculateZoomAndCenter(e) {
            if (this.elevation - e == 0) return;
            const a = s.an(1, this.center.lat) * this.worldSize,
              o = this.cameraToCenterDistance / a,
              c = s.a5.fromLngLat(this.center, this.elevation),
              d = J(this.center, this.elevation, this.pitch, this.bearing, o);
            this._elevation = e;
            const g = this.calculateCenterFromCameraLngLatAlt(d.toLngLat(), s.aT(d.z, c.y), this.bearing, this.pitch);
            this._elevation = g.elevation, this._center = g.center, this.setZoom(g.zoom)
          }
          getCameraPoint() {
            const e = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new s.P(e * Math.sin(this.rollInRadians), e * Math.cos(this.rollInRadians)))
          }
          getCameraAltitude() {
            return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation
          }
          getCameraLngLat() {
            const e = s.an(1, this.center.lat) * this.worldSize;
            return J(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e).toLngLat()
          }
          getMercatorTileCoordinates(e) {
            if (!e) return [0, 0, 1, 1];
            const a = e.canonical.z >= 0 ? 1 << e.canonical.z : Math.pow(2, e.canonical.z);
            return [e.canonical.x / a, e.canonical.y / a, 1 / a / s.a3, 1 / a / s.a3]
          }
        }
        class ra {
          constructor(e, a) {
            this.min = e, this.max = a, this.center = s.aU([], s.aV([], this.min, this.max), .5)
          }
          quadrant(e) {
            const a = [e % 2 == 0, e < 2],
              o = s.aW(this.min),
              c = s.aW(this.max);
            for (let d = 0; d < a.length; d++) o[d] = a[d] ? this.min[d] : this.center[d], c[d] = a[d] ? this.center[d] : this.max[d];
            return c[2] = this.max[2], new ra(o, c)
          }
          distanceX(e) {
            return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0]
          }
          distanceY(e) {
            return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1]
          }
          intersectsFrustum(e) {
            let a = !0;
            for (let o = 0; o < e.planes.length; o++) {
              const c = this.intersectsPlane(e.planes[o]);
              if (c === 0) return 0;
              c === 1 && (a = !1)
            }
            return a ? 2 : e.aabb.min[0] > this.max[0] || e.aabb.min[1] > this.max[1] || e.aabb.min[2] > this.max[2] || e.aabb.max[0] < this.min[0] || e.aabb.max[1] < this.min[1] || e.aabb.max[2] < this.min[2] ? 0 : 1
          }
          intersectsPlane(e) {
            let a = e[3],
              o = e[3];
            for (let c = 0; c < 3; c++) e[c] > 0 ? (a += e[c] * this.min[c], o += e[c] * this.max[c]) : (o += e[c] * this.min[c], a += e[c] * this.max[c]);
            return a >= 0 ? 2 : o < 0 ? 0 : 1
          }
        }
        class sa {
          distanceToTile2d(e, a, o, c) {
            const d = c.distanceX([e, a]),
              g = c.distanceY([e, a]);
            return Math.hypot(d, g)
          }
          getWrap(e, a, o) {
            return o
          }
          getTileBoundingVolume(e, a, o, c) {
            var d, g;
            let w = 0,
              S = 0;
            if (c != null && c.terrain) {
              const E = new s.a0(e.z, a, e.z, e.x, e.y),
                F = c.terrain.getMinMaxElevation(E);
              w = (d = F.minElevation) !== null && d !== void 0 ? d : Math.min(0, o), S = (g = F.maxElevation) !== null && g !== void 0 ? g : Math.max(0, o)
            }
            const A = 1 << e.z;
            return new ra([a + e.x / A, e.y / A, w], [a + (e.x + 1) / A, (e.y + 1) / A, S])
          }
          allowVariableZoom(e, a) {
            const o = e.fov * (Math.abs(Math.cos(e.rollInRadians)) * e.height + Math.abs(Math.sin(e.rollInRadians)) * e.width) / e.height,
              c = s.ai(78.5 - o / 2, 0, 60);
            return !!a.terrain || e.pitch > c
          }
          allowWorldCopies() {
            return !0
          }
          prepareNextFrame() {}
        }
        class Da {
          constructor(e, a, o) {
            this.points = e, this.planes = a, this.aabb = o
          }
          static fromInvProjectionMatrix(e, a = 1, o = 0, c, d) {
            const g = d ? [
                [6, 5, 4],
                [0, 1, 2],
                [0, 3, 7],
                [2, 1, 5],
                [3, 2, 6],
                [0, 4, 5]
              ] : [
                [0, 1, 2],
                [6, 5, 4],
                [0, 3, 7],
                [2, 1, 5],
                [3, 2, 6],
                [0, 4, 5]
              ],
              w = Math.pow(2, o),
              S = [
                [-1, 1, -1, 1],
                [1, 1, -1, 1],
                [1, -1, -1, 1],
                [-1, -1, -1, 1],
                [-1, 1, 1, 1],
                [1, 1, 1, 1],
                [1, -1, 1, 1],
                [-1, -1, 1, 1]
              ].map((R => (function(U, Y, se, le) {
                const ce = s.aA([], U, Y),
                  ge = 1 / ce[3] / se * le;
                return s.a$(ce, ce, [ge, ge, 1 / ce[3], ge])
              })(R, e, a, w)));
            c && (function(R, U, Y, se) {
              const le = se ? 4 : 0,
                ce = se ? 0 : 4;
              let ge = 0;
              const Pe = [],
                fe = [];
              for (let ve = 0; ve < 4; ve++) {
                const Oe = s.aX([], R[ve + ce], R[ve + le]),
                  lt = s.b0(Oe);
                s.aU(Oe, Oe, 1 / lt), Pe.push(lt), fe.push(Oe)
              }
              for (let ve = 0; ve < 4; ve++) {
                const Oe = s.b1(R[ve + le], fe[ve], Y);
                ge = Oe !== null && Oe >= 0 ? Math.max(ge, Oe) : Math.max(ge, Pe[ve])
              }
              const Me = (function(ve, Oe) {
                  const lt = s.aX([], ve[Oe[0]], ve[Oe[1]]),
                    it = s.aX([], ve[Oe[2]], ve[Oe[1]]),
                    st = [0, 0, 0, 0];
                  return s.aY(st, s.aZ([], lt, it)), st[3] = -s.a_(st, ve[Oe[0]]), st
                })(R, U),
                Ee = (function(ve, Oe) {
                  const lt = s.b2(ve),
                    it = s.b3([], ve, 1 / lt),
                    st = s.aX([], Oe, s.aU([], it, s.a_(Oe, it))),
                    ct = s.b2(st);
                  if (ct > 0) {
                    const nr = Math.sqrt(1 - it[3] * it[3]),
                      lr = s.aU([], it, -it[3]),
                      Bt = s.aV([], lr, s.aU([], st, nr / ct));
                    return s.b4(Oe, Bt)
                  }
                  return null
                })(Y, Me);
              if (Ee !== null) {
                const ve = Ee / s.a_(fe[0], Me);
                ge = Math.min(ge, ve)
              }
              for (let ve = 0; ve < 4; ve++) {
                const Oe = Math.min(ge, Pe[ve]);
                R[ve + ce] = [R[ve + le][0] + fe[ve][0] * Oe, R[ve + le][1] + fe[ve][1] * Oe, R[ve + le][2] + fe[ve][2] * Oe, 1]
              }
            })(S, g[0], c, d);
            const A = g.map((R => {
                const U = s.aX([], S[R[0]], S[R[1]]),
                  Y = s.aX([], S[R[2]], S[R[1]]),
                  se = s.aY([], s.aZ([], U, Y)),
                  le = -s.a_(se, S[R[1]]);
                return se.concat(le)
              })),
              E = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],
              F = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
            for (const R of S)
              for (let U = 0; U < 3; U++) E[U] = Math.min(E[U], R[U]), F[U] = Math.max(F[U], R[U]);
            return new Da(S, A, new ra(E, F))
          }
        }
        class Sa {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, a, o) {
            return this._helper.interpolatePadding(e, a, o)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, a, o = !0) {
            this._helper.resize(e, a, o)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          setConstrain(e) {
            this._helper.setConstrain(e)
          }
          overrideNearFarZ(e, a) {
            this._helper.overrideNearFarZ(e, a)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          get constrain() {
            return this._helper.constrain
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          setTransitionState(e, a) {}
          constructor(e) {
            this._posMatrixCache = new Map, this._alignedPosMatrixCache = new Map, this._fogMatrixCacheF32 = new Map, this.defaultConstrain = (a, o) => {
              o = s.ai(+o, this.minZoom, this.maxZoom);
              const c = {
                center: new s.U(a.lng, a.lat),
                zoom: o
              };
              let d = this._helper._lngRange;
              if (!this._helper._renderWorldCopies && d === null) {
                const fe = 179.9999999999;
                d = [-fe, fe]
              }
              const g = this.tileSize * s.al(c.zoom);
              let w = 0,
                S = g,
                A = 0,
                E = g,
                F = 0,
                R = 0;
              const {
                x: U,
                y: Y
              } = this.size;
              if (this._helper._latRange) {
                const fe = this._helper._latRange;
                w = s.W(fe[1]) * g, S = s.W(fe[0]) * g, S - w < Y && (F = Y / (S - w))
              }
              d && (A = s.V(s.X(d[0]) * g, 0, g), E = s.V(s.X(d[1]) * g, 0, g), E < A && (E += g), E - A < U && (R = U / (E - A)));
              const {
                x: se,
                y: le
              } = ze(g, a);
              let ce, ge;
              const Pe = Math.max(R || 0, F || 0);
              if (Pe) {
                const fe = new s.P(R ? (E + A) / 2 : se, F ? (S + w) / 2 : le);
                return c.center = We(g, fe).wrap(), c.zoom += s.ao(Pe), c
              }
              if (this._helper._latRange) {
                const fe = Y / 2;
                le - fe < w && (ge = w + fe), le + fe > S && (ge = S - fe)
              }
              if (d) {
                const fe = (A + E) / 2;
                let Me = se;
                this._helper._renderWorldCopies && (Me = s.V(se, fe - g / 2, fe + g / 2));
                const Ee = U / 2;
                Me - Ee < A && (ce = A + Ee), Me + Ee > E && (ce = E - Ee)
              }
              if (ce !== void 0 || ge !== void 0) {
                const fe = new s.P(ce ?? se, ge ?? le);
                c.center = We(g, fe).wrap()
              }
              return c
            }, this._helper = new Ui({
              calcMatrices: () => {
                this._calcMatrices()
              },
              constrain: (a, o) => this.defaultConstrain(a, o)
            }, e), this._coveringTilesDetailsProvider = new sa
          }
          clone() {
            const e = new Sa;
            return e.apply(this), e
          }
          apply(e, a, o) {
            this._helper.apply(e, a, o)
          }
          get cameraPosition() {
            return this._cameraPosition
          }
          get projectionMatrix() {
            return this._projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix
          }
          get mercatorMatrix() {
            return this._mercatorMatrix
          }
          getVisibleUnwrappedCoordinates(e) {
            const a = [new s.b5(0, e)];
            if (this._helper._renderWorldCopies) {
              const o = this.screenPointToMercatorCoordinate(new s.P(0, 0)),
                c = this.screenPointToMercatorCoordinate(new s.P(this._helper._width, 0)),
                d = this.screenPointToMercatorCoordinate(new s.P(this._helper._width, this._helper._height)),
                g = this.screenPointToMercatorCoordinate(new s.P(0, this._helper._height)),
                w = Math.floor(Math.min(o.x, c.x, d.x, g.x)),
                S = Math.floor(Math.max(o.x, c.x, d.x, g.x)),
                A = 1;
              for (let E = w - A; E <= S + A; E++) E !== 0 && a.push(new s.b5(E, e))
            }
            return a
          }
          getCameraFrustum() {
            return Da.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize)
          }
          getClippingPlane() {
            return null
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider
          }
          recalculateZoomAndCenter(e) {
            const a = this.screenPointToLocation(this.centerPoint, e),
              o = e ? e.getElevationForLngLatZoom(a, this._helper._tileZoom) : 0;
            this._helper.recalculateZoomAndCenter(o)
          }
          setLocationAtPoint(e, a) {
            const o = s.an(this.elevation, this.center.lat),
              c = this.screenPointToMercatorCoordinateAtZ(a, o),
              d = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, o),
              g = s.a5.fromLngLat(e),
              w = new s.a5(g.x - (c.x - d.x), g.y - (c.y - d.y));
            this.setCenter(w == null ? void 0 : w.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap())
          }
          locationToScreenPoint(e, a) {
            return a ? this.coordinatePoint(s.a5.fromLngLat(e), a.getElevationForLngLatZoom(e, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(s.a5.fromLngLat(e))
          }
          screenPointToLocation(e, a) {
            var o;
            return (o = this.screenPointToMercatorCoordinate(e, a)) === null || o === void 0 ? void 0 : o.toLngLat()
          }
          screenPointToMercatorCoordinate(e, a) {
            if (a) {
              const o = a.pointCoordinate(e);
              if (o != null) return o
            }
            return this.screenPointToMercatorCoordinateAtZ(e)
          }
          screenPointToMercatorCoordinateAtZ(e, a) {
            const o = a || 0,
              c = [e.x, e.y, 0, 1],
              d = [e.x, e.y, 1, 1];
            s.aA(c, c, this._pixelMatrixInverse), s.aA(d, d, this._pixelMatrixInverse);
            const g = c[3],
              w = d[3],
              S = c[1] / g,
              A = d[1] / w,
              E = c[2] / g,
              F = d[2] / w,
              R = E === F ? 0 : (o - E) / (F - E);
            return new s.a5(s.F.number(c[0] / g, d[0] / w, R) / this.worldSize, s.F.number(S, A, R) / this.worldSize, o)
          }
          coordinatePoint(e, a = 0, o = this._pixelMatrix) {
            const c = [e.x * this.worldSize, e.y * this.worldSize, a, 1];
            return s.aA(c, c, o), new s.P(c[0] / c[3], c[1] / c[3])
          }
          getBounds() {
            const e = Math.max(0, this._helper._height / 2 - Be(this));
            return new wt().extend(this.screenPointToLocation(new s.P(0, e))).extend(this.screenPointToLocation(new s.P(this._helper._width, e))).extend(this.screenPointToLocation(new s.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new s.P(0, this._helper._height)))
          }
          isPointOnMapSurface(e, a) {
            return a ? a.pointCoordinate(e) != null : e.y > this.height / 2 - Be(this)
          }
          calculatePosMatrix(e, a = !1, o) {
            var c;
            const d = (c = e.key) !== null && c !== void 0 ? c : s.b6(e.wrap, e.canonical.z, e.canonical.z, e.canonical.x, e.canonical.y),
              g = a ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (g.has(d)) {
              const A = g.get(d);
              return o ? A.f32 : A.f64
            }
            const w = ae(e, this.worldSize);
            s.Q(w, a ? this._alignedProjMatrix : this._viewProjMatrix, w);
            const S = {
              f64: w,
              f32: new Float32Array(w)
            };
            return g.set(d, S), o ? S.f32 : S.f64
          }
          calculateFogMatrix(e) {
            const a = e.key,
              o = this._fogMatrixCacheF32;
            if (o.has(a)) return o.get(a);
            const c = ae(e, this.worldSize);
            return s.Q(c, this._fogMatrix, c), o.set(a, new Float32Array(c)), o.get(a)
          }
          calculateCenterFromCameraLngLatAlt(e, a, o, c) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, a, o, c)
          }
          _calculateNearFarZIfNeeded(e, a, o) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const c = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100),
              d = e - c * this._helper._pixelPerMeter / Math.cos(a),
              g = c < 0 ? d : e,
              w = Math.PI / 2 + this.pitchInRadians,
              S = s.ak(this.fov) * (Math.abs(Math.cos(s.ak(this.roll))) * this.height + Math.abs(Math.sin(s.ak(this.roll))) * this.width) / this.height * (.5 + o.y / this.height),
              A = Math.sin(S) * g / Math.sin(s.ai(Math.PI - w - S, .01, Math.PI - .01)),
              E = Be(this),
              F = Math.atan(E / this._helper.cameraToCenterDistance),
              R = s.ak(.75),
              U = F > R ? 2 * F * (.5 + o.y / (2 * E)) : R,
              Y = Math.sin(U) * g / Math.sin(s.ai(Math.PI - w - U, .01, Math.PI - .01)),
              se = Math.min(A, Y);
            this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - a) * se + g), this._helper._nearZ = this._helper._height / 50
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const e = this.centerOffset,
              a = ze(this.worldSize, this.center),
              o = a.x,
              c = a.y;
            this._helper._pixelPerMeter = s.an(1, this.center.lat) * this.worldSize;
            const d = s.ak(Math.min(this.pitch, be)),
              g = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(d));
            let w;
            this._calculateNearFarZIfNeeded(g, d, e), w = new Float64Array(16), s.b7(w, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), s.au(this._invProjMatrix, w), w[8] = 2 * -e.x / this._helper._width, w[9] = 2 * e.y / this._helper._height, this._projectionMatrix = s.b8(w), s.O(w, w, [1, -1, 1]), s.N(w, w, [0, 0, -this._helper.cameraToCenterDistance]), s.b9(w, w, -this.rollInRadians), s.ba(w, w, this.pitchInRadians), s.b9(w, w, -this.bearingInRadians), s.N(w, w, [-o, -c, 0]), this._mercatorMatrix = s.O([], w, [this.worldSize, this.worldSize, this.worldSize]), s.O(w, w, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = s.Q(new Float64Array(16), this.clipSpaceToPixelsMatrix, w), s.N(w, w, [0, 0, -this.elevation]), this._viewProjMatrix = w, this._invViewProjMatrix = s.au([], w);
            const S = [0, 0, -1, 1];
            s.aA(S, S, this._invViewProjMatrix), this._cameraPosition = [S[0] / S[3], S[1] / S[3], S[2] / S[3]], this._fogMatrix = new Float64Array(16), s.b7(this._fogMatrix, this.fovInRadians, this.width / this.height, g, this._helper._farZ), this._fogMatrix[8] = 2 * -e.x / this.width, this._fogMatrix[9] = 2 * e.y / this.height, s.O(this._fogMatrix, this._fogMatrix, [1, -1, 1]), s.N(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), s.b9(this._fogMatrix, this._fogMatrix, -this.rollInRadians), s.ba(this._fogMatrix, this._fogMatrix, this.pitchInRadians), s.b9(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), s.N(this._fogMatrix, this._fogMatrix, [-o, -c, 0]), s.O(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), s.N(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = s.Q(new Float64Array(16), this.clipSpaceToPixelsMatrix, w);
            const A = this._helper._width % 2 / 2,
              E = this._helper._height % 2 / 2,
              F = Math.cos(this.bearingInRadians),
              R = Math.sin(-this.bearingInRadians),
              U = o - Math.round(o) + F * A + R * E,
              Y = c - Math.round(c) + F * E + R * A,
              se = new Float64Array(w);
            if (s.N(se, se, [U > .5 ? U - 1 : U, Y > .5 ? Y - 1 : Y, 0]), this._alignedProjMatrix = se, w = s.au(new Float64Array(16), this._pixelMatrix), !w) throw new Error("failed to invert matrix");
            this._pixelMatrixInverse = w, this._clearMatrixCaches()
          }
          _clearMatrixCaches() {
            this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear()
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const e = this.screenPointToMercatorCoordinate(new s.P(0, 0)),
              a = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
            return s.aA(a, a, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            const e = s.an(1, this.center.lat) * this.worldSize;
            return J(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e).toLngLat()
          }
          lngLatToCameraDepth(e, a) {
            const o = s.a5.fromLngLat(e),
              c = [o.x * this.worldSize, o.y * this.worldSize, a, 1];
            return s.aA(c, c, this._viewProjMatrix), c[2] / c[3]
          }
          getProjectionData(e) {
            const {
              overscaledTileID: a,
              aligned: o,
              applyTerrainMatrix: c
            } = e, d = this._helper.getMercatorTileCoordinates(a), g = a ? this.calculatePosMatrix(a, o, !0) : null;
            let w;
            return w = a && a.terrainRttPosMatrix32f && c ? a.terrainRttPosMatrix32f : g || s.bb(), {
              mainMatrix: w,
              tileMercatorCoords: d,
              clippingPlane: [0, 0, 0, 0],
              projectionTransition: 0,
              fallbackMatrix: w
            }
          }
          isLocationOccluded(e) {
            return !1
          }
          getPixelScale() {
            return 1
          }
          getCircleRadiusCorrection() {
            return 1
          }
          getPitchedTextCorrection(e, a, o) {
            return 1
          }
          transformLightDirection(e) {
            return s.aW(e)
          }
          getRayDirectionFromPixel(e) {
            throw new Error("Not implemented.")
          }
          projectTileCoordinates(e, a, o, c) {
            const d = this.calculatePosMatrix(o);
            let g;
            c ? (g = [e, a, c(e, a), 1], s.aA(g, g, d)) : (g = [e, a, 0, 1], Rr(g, g, d));
            const w = g[3];
            return {
              point: new s.P(g[0] / w, g[1] / w),
              signedDistanceFromCamera: w,
              isOccluded: !1
            }
          }
          populateCache(e) {
            for (const a of e) this.calculatePosMatrix(a)
          }
          getMatrixForModel(e, a) {
            const o = s.a5.fromLngLat(e, a),
              c = o.meterInMercatorCoordinateUnits(),
              d = s.bc();
            return s.N(d, d, [o.x, o.y, o.z]), s.b9(d, d, Math.PI), s.ba(d, d, Math.PI / 2), s.O(d, d, [-c, c, c]), d
          }
          getProjectionDataForCustomLayer(e = !0) {
            const a = new s.a0(0, 0, 0, 0, 0),
              o = this.getProjectionData({
                overscaledTileID: a,
                applyGlobeMatrix: e
              }),
              c = ae(a, this.worldSize);
            s.Q(c, this._viewProjMatrix, c), o.tileMercatorCoords = [0, 0, 1, 1];
            const d = [s.a3, s.a3, this.worldSize / this._helper.pixelsPerMeter],
              g = s.bd();
            return s.O(g, c, d), o.fallbackMatrix = g, o.mainMatrix = g, o
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.calculatePosMatrix(e)
          }
        }

        function Ki() {
          s.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.")
        }

        function ca(h) {
          if (h.useSlerp)
            if (h.k < 1) {
              const e = s.be(h.startEulerAngles.roll, h.startEulerAngles.pitch, h.startEulerAngles.bearing),
                a = s.be(h.endEulerAngles.roll, h.endEulerAngles.pitch, h.endEulerAngles.bearing),
                o = new Float64Array(4);
              s.bf(o, e, a, h.k);
              const c = s.bg(o);
              h.tr.setRoll(c.roll), h.tr.setPitch(c.pitch), h.tr.setBearing(c.bearing)
            } else h.tr.setRoll(h.endEulerAngles.roll), h.tr.setPitch(h.endEulerAngles.pitch), h.tr.setBearing(h.endEulerAngles.bearing);
          else h.tr.setRoll(s.F.number(h.startEulerAngles.roll, h.endEulerAngles.roll, h.k)), h.tr.setPitch(s.F.number(h.startEulerAngles.pitch, h.endEulerAngles.pitch, h.k)), h.tr.setBearing(s.F.number(h.startEulerAngles.bearing, h.endEulerAngles.bearing, h.k))
        }

        function Pa(h, e, a, o, c) {
          const d = c.padding,
            g = ze(c.worldSize, a.getNorthWest()),
            w = ze(c.worldSize, a.getNorthEast()),
            S = ze(c.worldSize, a.getSouthEast()),
            A = ze(c.worldSize, a.getSouthWest()),
            E = s.ak(-o),
            F = g.rotate(E),
            R = w.rotate(E),
            U = S.rotate(E),
            Y = A.rotate(E),
            se = new s.P(Math.max(F.x, R.x, Y.x, U.x), Math.max(F.y, R.y, Y.y, U.y)),
            le = new s.P(Math.min(F.x, R.x, Y.x, U.x), Math.min(F.y, R.y, Y.y, U.y)),
            ce = se.sub(le),
            ge = (c.width - (d.left + d.right + e.left + e.right)) / ce.x,
            Pe = (c.height - (d.top + d.bottom + e.top + e.bottom)) / ce.y;
          if (Pe < 0 || ge < 0) return void Ki();
          const fe = Math.min(s.ao(c.scale * Math.min(ge, Pe)), h.maxZoom),
            Me = s.P.convert(h.offset),
            Ee = new s.P((e.left - e.right) / 2, (e.top - e.bottom) / 2).rotate(s.ak(o)),
            ve = Me.add(Ee).mult(c.scale / s.al(fe));
          return {
            center: We(c.worldSize, g.add(S).div(2).sub(ve)),
            zoom: fe,
            bearing: o
          }
        }
        class ja {
          get useGlobeControls() {
            return !1
          }
          handlePanInertia(e, a) {
            const o = e.mag(),
              c = Math.abs(Be(a));
            return {
              easingOffset: e.mult(Math.min(.75 * c / o, 1)),
              easingCenter: a.center
            }
          }
          handleMapControlsRollPitchBearingZoom(e, a) {
            e.bearingDelta && a.setBearing(a.bearing + e.bearingDelta), e.pitchDelta && a.setPitch(a.pitch + e.pitchDelta), e.rollDelta && a.setRoll(a.roll + e.rollDelta), e.zoomDelta && a.setZoom(a.zoom + e.zoomDelta)
          }
          handleMapControlsPan(e, a, o) {
            e.around.distSqr(a.centerPoint) < .01 || a.setLocationAtPoint(o, e.around)
          }
          cameraForBoxAndBearing(e, a, o, c, d) {
            return Pa(e, a, o, c, d)
          }
          handleJumpToCenterZoom(e, a) {
            e.zoom !== (a.zoom !== void 0 ? +a.zoom : e.zoom) && e.setZoom(+a.zoom), a.center !== void 0 && e.setCenter(s.U.convert(a.center))
          }
          handleEaseTo(e, a) {
            const o = e.zoom,
              c = e.padding,
              d = {
                roll: e.roll,
                pitch: e.pitch,
                bearing: e.bearing
              },
              g = {
                roll: a.roll === void 0 ? e.roll : a.roll,
                pitch: a.pitch === void 0 ? e.pitch : a.pitch,
                bearing: a.bearing === void 0 ? e.bearing : a.bearing
              },
              w = a.zoom !== void 0,
              S = !e.isPaddingEqual(a.padding);
            let A = !1;
            const E = w ? +a.zoom : e.zoom;
            let F = e.centerPoint.add(a.offsetAsPoint);
            const R = e.screenPointToLocation(F),
              {
                center: U,
                zoom: Y
              } = e.constrain(s.U.convert(a.center || R), E ?? o);
            li(e, U);
            const se = ze(e.worldSize, R),
              le = ze(e.worldSize, U).sub(se),
              ce = s.al(Y - o);
            return A = Y !== o, {
              easeFunc: ge => {
                if (A && e.setZoom(s.F.number(o, Y, ge)), s.bh(d, g) || ca({
                    startEulerAngles: d,
                    endEulerAngles: g,
                    tr: e,
                    k: ge,
                    useSlerp: d.roll != g.roll
                  }), S && (e.interpolatePadding(c, a.padding, ge), F = e.centerPoint.add(a.offsetAsPoint)), a.around) e.setLocationAtPoint(a.around, a.aroundPoint);
                else {
                  const Pe = s.al(e.zoom - o),
                    fe = Y > o ? Math.min(2, ce) : Math.max(.5, ce),
                    Me = Math.pow(fe, 1 - ge),
                    Ee = We(e.worldSize, se.add(le.mult(ge * Me)).mult(Pe));
                  e.setLocationAtPoint(e.renderWorldCopies ? Ee.wrap() : Ee, F)
                }
              },
              isZooming: A,
              elevationCenter: U
            }
          }
          handleFlyTo(e, a) {
            const o = a.zoom !== void 0,
              c = e.zoom,
              d = e.constrain(s.U.convert(a.center || a.locationAtOffset), o ? +a.zoom : c),
              g = d.center,
              w = d.zoom;
            li(e, g);
            const S = ze(e.worldSize, a.locationAtOffset),
              A = ze(e.worldSize, g).sub(S),
              E = A.mag(),
              F = s.al(w - c);
            let R;
            if (a.minZoom !== void 0) {
              const U = Math.min(+a.minZoom, c, w),
                Y = e.constrain(g, U).zoom;
              R = s.al(Y - c)
            }
            return {
              easeFunc: (U, Y, se, le) => {
                e.setZoom(U === 1 ? w : c + s.ao(Y));
                const ce = U === 1 ? g : We(e.worldSize, S.add(A.mult(se)).mult(Y));
                e.setLocationAtPoint(e.renderWorldCopies ? ce.wrap() : ce, le)
              },
              scaleOfZoom: F,
              targetCenter: g,
              scaleOfMinZoom: R,
              pixelPathLength: E
            }
          }
        }
        class Ti {
          constructor(e, a, o) {
            this.blendFunction = e, this.blendColor = a, this.mask = o
          }
        }
        Ti.Replace = [1, 0], Ti.disabled = new Ti(Ti.Replace, s.bi.transparent, [!1, !1, !1, !1]), Ti.unblended = new Ti(Ti.Replace, s.bi.transparent, [!0, !0, !0, !0]), Ti.alphaBlended = new Ti([1, 771], s.bi.transparent, [!0, !0, !0, !0]);
        const bn = 2305;
        class gi {
          constructor(e, a, o) {
            this.enable = e, this.mode = a, this.frontFace = o
          }
        }
        gi.disabled = new gi(!1, 1029, bn), gi.backCCW = new gi(!0, 1029, bn), gi.frontCCW = new gi(!0, 1028, bn);
        class _i {
          constructor(e, a, o) {
            this.func = e, this.mask = a, this.range = o
          }
        }
        _i.ReadOnly = !1, _i.ReadWrite = !0, _i.disabled = new _i(519, _i.ReadOnly, [0, 1]);
        const Bn = 7680;
        class Li {
          constructor(e, a, o, c, d, g) {
            this.test = e, this.ref = a, this.mask = o, this.fail = c, this.depthFail = d, this.pass = g
          }
        }
        Li.disabled = new Li({
          func: 519,
          mask: 0
        }, 0, 0, Bn, Bn, Bn);
        const On = new WeakMap;

        function qa(h) {
          var e;
          if (On.has(h)) return On.get(h);
          {
            const a = (e = h.getParameter(h.VERSION)) === null || e === void 0 ? void 0 : e.startsWith("WebGL 2.0");
            return On.set(h, a), a
          }
        }
        class Qn {
          get awaitingQuery() {
            return !!this._readbackQueue
          }
          constructor(e) {
            this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e;
            const a = e.context,
              o = a.gl;
            this._texFormat = o.RGBA, this._texType = o.UNSIGNED_BYTE;
            const c = new s.aP;
            c.emplaceBack(-1, -1), c.emplaceBack(2, -1), c.emplaceBack(-1, 2);
            const d = new s.aR;
            d.emplaceBack(0, 1, 2), this._fullscreenTriangle = new Ni(a.createVertexBuffer(c, Oi.members), a.createIndexBuffer(d), s.aQ.simpleSegment(0, 0, c.length, d.length)), this._resultBuffer = new Uint8Array(4), a.activeTexture.set(o.TEXTURE1);
            const g = o.createTexture();
            o.bindTexture(o.TEXTURE_2D, g), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, o.CLAMP_TO_EDGE), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, o.CLAMP_TO_EDGE), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, o.NEAREST), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, o.NEAREST), o.texImage2D(o.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = a.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(g), qa(o) && (this._pbo = o.createBuffer(), o.bindBuffer(o.PIXEL_PACK_BUFFER, this._pbo), o.bufferData(o.PIXEL_PACK_BUFFER, 4, o.STREAM_READ), o.bindBuffer(o.PIXEL_PACK_BUFFER, null))
          }
          destroy() {
            const e = this._cachedRenderContext.context.gl;
            this._fullscreenTriangle.destroy(), this._fbo.destroy(), e.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null
          }
          updateErrorLoop(e, a) {
            const o = this._updateCount;
            return this._readbackQueue ? o >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : o >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e, a), this._updateCount++, this._measuredError
          }
          _bindFramebuffer() {
            const e = this._cachedRenderContext.context,
              a = e.gl;
            e.activeTexture.set(a.TEXTURE1), a.bindTexture(a.TEXTURE_2D, this._fbo.colorAttachment.get()), e.bindFramebuffer.set(this._fbo.framebuffer)
          }
          _renderErrorTexture(e, a) {
            const o = this._cachedRenderContext.context,
              c = o.gl;
            if (this._bindFramebuffer(), o.viewport.set([0, 0, this._texWidth, this._texHeight]), o.clear({
                color: s.bi.transparent
              }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(o, c.TRIANGLES, _i.disabled, Li.disabled, Ti.unblended, gi.disabled, ((d, g) => ({
                u_input: d,
                u_output_expected: g
              }))(e, a), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && qa(c)) {
              c.bindBuffer(c.PIXEL_PACK_BUFFER, this._pbo), c.readBuffer(c.COLOR_ATTACHMENT0), c.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), c.bindBuffer(c.PIXEL_PACK_BUFFER, null);
              const d = c.fenceSync(c.SYNC_GPU_COMMANDS_COMPLETE, 0);
              c.flush(), this._readbackQueue = {
                frameNumberIssued: this._updateCount,
                sync: d
              }
            } else this._readbackQueue = {
              frameNumberIssued: this._updateCount,
              sync: null
            }
          }
          _tryReadback() {
            const e = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && qa(e)) {
              const a = e.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (a === e.WAIT_FAILED) return s.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void(this._lastReadbackFrame = this._updateCount);
              if (a === e.TIMEOUT_EXPIRED) return;
              e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo), e.getBufferSubData(e.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e.bindBuffer(e.PIXEL_PACK_BUFFER, null)
            } else this._bindFramebuffer(), e.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
            this._readbackQueue = null, this._measuredError = Qn._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount
          }
          static _parseRGBA8float(e) {
            let a = 0;
            return a += e[0] / 256, a += e[1] / 65536, a += e[2] / 16777216, e[3] < 127 && (a = -a), a / 128
          }
        }
        const jn = s.a3 / 128;

        function wn(h, e) {
          const a = h.granularity !== void 0 ? Math.max(h.granularity, 1) : 1,
            o = a + (h.generateBorders ? 2 : 0),
            c = a + (h.extendToNorthPole || h.generateBorders ? 1 : 0) + (h.extendToSouthPole || h.generateBorders ? 1 : 0),
            d = o + 1,
            g = c + 1,
            w = h.generateBorders ? -1 : 0,
            S = h.generateBorders || h.extendToNorthPole ? -1 : 0,
            A = a + (h.generateBorders ? 1 : 0),
            E = a + (h.generateBorders || h.extendToSouthPole ? 1 : 0),
            F = d * g,
            R = o * c * 6,
            U = d * g > 65536;
          if (U && e === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
          const Y = U || e === "32bit",
            se = new Int16Array(2 * F);
          let le = 0;
          for (let Pe = S; Pe <= E; Pe++)
            for (let fe = w; fe <= A; fe++) {
              let Me = fe / a * s.a3;
              fe === -1 && (Me = -jn), fe === a + 1 && (Me = s.a3 + jn);
              let Ee = Pe / a * s.a3;
              Pe === -1 && (Ee = h.extendToNorthPole ? s.bk : -jn), Pe === a + 1 && (Ee = h.extendToSouthPole ? s.bl : s.a3 + jn), se[le++] = Me, se[le++] = Ee
            }
          const ce = Y ? new Uint32Array(R) : new Uint16Array(R);
          let ge = 0;
          for (let Pe = 0; Pe < c; Pe++)
            for (let fe = 0; fe < o; fe++) {
              const Me = fe + 1 + Pe * d,
                Ee = fe + (Pe + 1) * d,
                ve = fe + 1 + (Pe + 1) * d;
              ce[ge++] = fe + Pe * d, ce[ge++] = Ee, ce[ge++] = Me, ce[ge++] = Me, ce[ge++] = Ee, ce[ge++] = ve
            }
          return {
            vertices: se.buffer.slice(0),
            indices: ce.buffer.slice(0),
            uses32bitIndices: Y
          }
        }
        const ns = new s.aO({
          fill: new s.bm(128, 2),
          line: new s.bm(512, 0),
          tile: new s.bm(128, 32),
          stencil: new s.bm(128, 1),
          circle: 3
        });
        class qn {
          constructor() {
            this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3
          }
          get name() {
            return "vertical-perspective"
          }
          get transitionState() {
            return 1
          }
          get useSubdivision() {
            return !0
          }
          get shaderVariantName() {
            return "globe"
          }
          get shaderDefine() {
            return "#define GLOBE"
          }
          get shaderPreludeCode() {
            return Ir.projectionGlobe
          }
          get vertexShaderPreludeCode() {
            return Ir.projectionMercator.vertexSource
          }
          get subdivisionGranularity() {
            return ns
          }
          get useGlobeControls() {
            return !0
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy()
          }
          updateGPUdependent(e) {
            this._errorMeasurement || (this._errorMeasurement = new Qn(e));
            const a = s.W(this._errorQueryLatitudeDegrees),
              o = 2 * Math.atan(Math.exp(Math.PI - a * Math.PI * 2)) - .5 * Math.PI,
              c = this._errorMeasurement.updateErrorLoop(a, o),
              d = _e();
            c !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = c, this._errorMeasurementLastChangeTime = d);
            const g = Math.min(Math.max((d - this._errorMeasurementLastChangeTime) / 1e3 / .5, 0), 1);
            this._errorCorrectionUsable = s.bn(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, s.bo(g))
          }
          _getMeshKey(e) {
            return `${e.granularity.toString(36)}_${e.generateBorders?"b":""}${e.extendToNorthPole?"n":""}${e.extendToSouthPole?"s":""}`
          }
          getMeshFromTileID(e, a, o, c, d) {
            const g = (d === "stencil" ? ns.stencil : ns.tile).getGranularityForZoomLevel(a.z);
            return this._getMesh(e, {
              granularity: g,
              generateBorders: o,
              extendToNorthPole: a.y === 0 && c,
              extendToSouthPole: a.y === (1 << a.z) - 1 && c
            })
          }
          _getMesh(e, a) {
            const o = this._getMeshKey(a);
            if (o in this._tileMeshCache) return this._tileMeshCache[o];
            const c = (function(d, g) {
              const w = wn(g, "16bit"),
                S = s.aP.deserialize({
                  arrayBuffer: w.vertices,
                  length: w.vertices.byteLength / 2 / 2
                }),
                A = s.aR.deserialize({
                  arrayBuffer: w.indices,
                  length: w.indices.byteLength / 2 / 3
                });
              return new Ni(d.createVertexBuffer(S, Oi.members), d.createIndexBuffer(A), s.aQ.simpleSegment(0, 0, S.length, A.length))
            })(e, a);
            return this._tileMeshCache[o] = c, c
          }
          recalculate(e) {}
          hasTransition() {
            const e = _e();
            let a = !1;
            return a = a || (e - this._errorMeasurementLastChangeTime) / 1e3 < .7, a = a || this._errorMeasurement && this._errorMeasurement.awaitingQuery, a
          }
          setErrorQueryLatitudeDegrees(e) {
            this._errorQueryLatitudeDegrees = e
          }
        }
        const es = new s.r({
          type: new s.D(s.t.projection.type)
        });
        class ua extends s.E {
          constructor(e) {
            super(), this._transitionable = new s.x(es, void 0), this.setProjection(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new s.G(0)), this._mercatorProjection = new Pi, this._verticalPerspectiveProjection = new qn
          }
          get transitionState() {
            const e = this.properties.get("type");
            if (typeof e == "string" && e === "mercator") return 0;
            if (typeof e == "string" && e === "vertical-perspective") return 1;
            if (e instanceof s.bp) {
              if (e.from === "vertical-perspective" && e.to === "mercator") return 1 - e.transition;
              if (e.from === "mercator" && e.to === "vertical-perspective") return e.transition
            }
            return 1
          }
          get useGlobeRendering() {
            return this.transitionState > 0
          }
          get latitudeErrorCorrectionRadians() {
            return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians
          }
          get currentProjection() {
            return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection
          }
          get name() {
            return "globe"
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity
          }
          get useGlobeControls() {
            return this.transitionState > 0
          }
          destroy() {
            this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy()
          }
          updateGPUdependent(e) {
            this._mercatorProjection.updateGPUdependent(e), this._verticalPerspectiveProjection.updateGPUdependent(e)
          }
          getMeshFromTileID(e, a, o, c, d) {
            return this.currentProjection.getMeshFromTileID(e, a, o, c, d)
          }
          setProjection(e) {
            this._transitionable.setValue("type", (e == null ? void 0 : e.type) || "mercator")
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition() || this.currentProjection.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          setErrorQueryLatitudeDegrees(e) {
            this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e), this._mercatorProjection.setErrorQueryLatitudeDegrees(e)
          }
        }

        function Ma(h) {
          const e = Vn(h.worldSize, h.center.lat);
          return 2 * Math.PI * e
        }

        function fn(h, e, a, o, c) {
          const d = 1 / (1 << c),
            g = e / s.a3 * d + o * d,
            w = s.br((h / s.a3 * d + a * d) * Math.PI * 2 + Math.PI, 2 * Math.PI),
            S = 2 * Math.atan(Math.exp(Math.PI - g * Math.PI * 2)) - .5 * Math.PI,
            A = Math.cos(S),
            E = new Float64Array(3);
          return E[0] = Math.sin(w) * A, E[1] = Math.sin(S), E[2] = Math.cos(w) * A, E
        }

        function ha(h) {
          return (function(e, a) {
            const o = Math.cos(a),
              c = new Float64Array(3);
            return c[0] = Math.sin(e) * o, c[1] = Math.sin(a), c[2] = Math.cos(e) * o, c
          })(h.lng * Math.PI / 180, h.lat * Math.PI / 180)
        }

        function Vn(h, e) {
          return h / (2 * Math.PI) / Math.cos(e * Math.PI / 180)
        }

        function Fs(h) {
          const e = Math.asin(h[1]) / Math.PI * 180,
            a = Math.sqrt(h[0] * h[0] + h[2] * h[2]);
          if (a > 1e-6) {
            const o = h[0] / a,
              c = Math.acos(h[2] / a),
              d = (o > 0 ? c : -c) / Math.PI * 180;
            return new s.U(s.V(d, -180, 180), e)
          }
          return new s.U(0, e)
        }

        function _o(h) {
          return Math.cos(h * Math.PI / 180)
        }

        function Gi(h, e) {
          const a = _o(h),
            o = _o(e);
          return s.ao(o / a)
        }

        function bl(h, e) {
          const a = h.rotate(e.bearingInRadians),
            o = e.zoom + Gi(e.center.lat, 0),
            c = s.bn(1 / _o(e.center.lat), 1 / _o(Math.min(Math.abs(e.center.lat), 60)), s.bq(o, 7, 3, 0, 1)),
            d = 360 / Ma({
              worldSize: e.worldSize,
              center: {
                lat: e.center.lat
              }
            });
          return new s.U(e.center.lng - a.x * d * c, s.ai(e.center.lat + a.y * d, -s.aj, s.aj))
        }

        function zn(h) {
          const e = .5 * h,
            a = Math.sin(e),
            o = Math.cos(e);
          return Math.log(a + o) - Math.log(o - a)
        }

        function qo(h, e, a, o) {
          const c = h.lat + a * o;
          if (Math.abs(a) > 1) {
            const d = (Math.sign(h.lat + a) !== Math.sign(h.lat) ? -Math.abs(h.lat) : Math.abs(h.lat)) * Math.PI / 180,
              g = Math.abs(h.lat + a) * Math.PI / 180,
              w = zn(d + o * (g - d)),
              S = zn(d),
              A = zn(g);
            return new s.U(h.lng + e * ((w - S) / (A - S)), c)
          }
          return new s.U(h.lng + e * o, c)
        }
        class Lh {
          constructor(e) {
            this._cachePrevious = new Map, this._cache = new Map, this._hadAnyChanges = !1, this._boundingVolumeFactory = e
          }
          swapBuffers() {
            if (!this._hadAnyChanges) return;
            const e = this._cachePrevious;
            this._cachePrevious = this._cache, this._cache = e, this._cache.clear(), this._hadAnyChanges = !1
          }
          getTileBoundingVolume(e, a, o, c) {
            const d = `${e.z}_${e.x}_${e.y}_${c!=null&&c.terrain?"t":""}`,
              g = this._cache.get(d);
            if (g) return g;
            const w = this._cachePrevious.get(d);
            if (w) return this._cache.set(d, w), w;
            const S = this._boundingVolumeFactory(e, a, o, c);
            return this._cache.set(d, S), this._hadAnyChanges = !0, S
          }
        }
        class Bs {
          constructor(e, a, o, c) {
            this.min = o, this.max = c, this.points = e, this.planes = a
          }
          static fromAabb(e, a) {
            const o = [];
            for (let c = 0; c < 8; c++) o.push([1 & ~c ? e[0] : a[0], (c >> 1 & 1) == 1 ? a[1] : e[1], (c >> 2 & 1) == 1 ? a[2] : e[2]]);
            return new Bs(o, [
              [-1, 0, 0, a[0]],
              [1, 0, 0, -e[0]],
              [0, -1, 0, a[1]],
              [0, 1, 0, -e[1]],
              [0, 0, -1, a[2]],
              [0, 0, 1, -e[2]]
            ], e, a)
          }
          static fromCenterSizeAngles(e, a, o) {
            const c = s.bu([], o[0], o[1], o[2]),
              d = s.bv([], [a[0], 0, 0], c),
              g = s.bv([], [0, a[1], 0], c),
              w = s.bv([], [0, 0, a[2]], c),
              S = [...e],
              A = [...e];
            for (let F = 0; F < 8; F++)
              for (let R = 0; R < 3; R++) {
                const U = e[R] + d[R] * (1 & ~F ? -1 : 1) + g[R] * ((F >> 1 & 1) == 1 ? 1 : -1) + w[R] * ((F >> 2 & 1) == 1 ? 1 : -1);
                S[R] = Math.min(S[R], U), A[R] = Math.max(A[R], U)
              }
            const E = [];
            for (let F = 0; F < 8; F++) {
              const R = [...e];
              s.aV(R, R, s.aU([], d, 1 & ~F ? -1 : 1)), s.aV(R, R, s.aU([], g, (F >> 1 & 1) == 1 ? 1 : -1)), s.aV(R, R, s.aU([], w, (F >> 2 & 1) == 1 ? 1 : -1)), E.push(R)
            }
            return new Bs(E, [
              [...d, -s.a_(d, E[0])],
              [...g, -s.a_(g, E[0])],
              [...w, -s.a_(w, E[0])],
              [-d[0], -d[1], -d[2], -s.a_(d, E[7])],
              [-g[0], -g[1], -g[2], -s.a_(g, E[7])],
              [-w[0], -w[1], -w[2], -s.a_(w, E[7])]
            ], S, A)
          }
          intersectsFrustum(e) {
            let a = !0;
            const o = this.points.length,
              c = this.planes.length,
              d = e.planes.length,
              g = e.points.length;
            for (let w = 0; w < d; w++) {
              const S = e.planes[w];
              let A = 0;
              for (let E = 0; E < o; E++) {
                const F = this.points[E];
                S[0] * F[0] + S[1] * F[1] + S[2] * F[2] + S[3] >= 0 && A++
              }
              if (A === 0) return 0;
              A < o && (a = !1)
            }
            if (a) return 2;
            for (let w = 0; w < c; w++) {
              const S = this.planes[w];
              let A = 0;
              for (let E = 0; E < g; E++) {
                const F = e.points[E];
                S[0] * F[0] + S[1] * F[1] + S[2] * F[2] + S[3] >= 0 && A++
              }
              if (A === 0) return 0
            }
            return 1
          }
          intersectsPlane(e) {
            const a = this.points.length;
            let o = 0;
            for (let c = 0; c < a; c++) {
              const d = this.points[c];
              e[0] * d[0] + e[1] * d[1] + e[2] * d[2] + e[3] >= 0 && o++
            }
            return o === a ? 2 : o === 0 ? 0 : 1
          }
        }

        function ss(h, e, a) {
          const o = h - e;
          return o < 0 ? -o : Math.max(0, o - a)
        }

        function Bc(h, e, a, o, c) {
          const d = h - a;
          let g;
          return g = d < 0 ? Math.min(-d, 1 + d - c) : d > 1 ? Math.min(Math.max(d - c, 0), 1 - d) : 0, Math.max(g, ss(e, o, c))
        }
        class Fp {
          constructor() {
            this._boundingVolumeCache = new Lh(this._computeTileBoundingVolume)
          }
          prepareNextFrame() {
            this._boundingVolumeCache.swapBuffers()
          }
          distanceToTile2d(e, a, o, c) {
            const d = 1 << o.z,
              g = 1 / d,
              w = o.x / d,
              S = o.y / d;
            let A = 2;
            return A = Math.min(A, Bc(e, a, w, S, g)), A = Math.min(A, Bc(e, a, w + .5, -S - g, g)), A = Math.min(A, Bc(e, a, w + .5, 2 - S - g, g)), A
          }
          getWrap(e, a, o) {
            const c = 1 << a.z,
              d = 1 / c,
              g = a.x / c,
              w = ss(e.x, g, d),
              S = ss(e.x, g - 1, d),
              A = ss(e.x, g + 1, d),
              E = Math.min(w, S, A);
            return E === A ? 1 : E === S ? -1 : 0
          }
          allowVariableZoom(e, a) {
            return Ce(e, a) > 4
          }
          allowWorldCopies() {
            return !1
          }
          getTileBoundingVolume(e, a, o, c) {
            return this._boundingVolumeCache.getTileBoundingVolume(e, a, o, c)
          }
          _computeTileBoundingVolume(e, a, o, c) {
            var d, g;
            let w = 0,
              S = 0;
            if (c != null && c.terrain) {
              const A = new s.a0(e.z, a, e.z, e.x, e.y),
                E = c.terrain.getMinMaxElevation(A);
              w = (d = E.minElevation) !== null && d !== void 0 ? d : Math.min(0, o), S = (g = E.maxElevation) !== null && g !== void 0 ? g : Math.max(0, o)
            }
            if (w /= s.bx, S /= s.bx, w += 1, S += 1, e.z <= 0) return Bs.fromAabb([-S, -S, -S], [S, S, S]);
            if (e.z === 1) return Bs.fromAabb([e.x === 0 ? -S : 0, e.y === 0 ? 0 : -S, -S], [e.x === 0 ? 0 : S, e.y === 0 ? S : 0, S]);
            {
              const A = [fn(0, 0, e.x, e.y, e.z), fn(s.a3, 0, e.x, e.y, e.z), fn(s.a3, s.a3, e.x, e.y, e.z), fn(0, s.a3, e.x, e.y, e.z)],
                E = [];
              for (const st of A) E.push(s.aU([], st, S));
              if (S !== w)
                for (const st of A) E.push(s.aU([], st, w));
              e.y === 0 && E.push([0, 1, 0]), e.y === (1 << e.z) - 1 && E.push([0, -1, 0]);
              const F = [1, 1, 1],
                R = [-1, -1, -1];
              for (const st of E)
                for (let ct = 0; ct < 3; ct++) F[ct] = Math.min(F[ct], st[ct]), R[ct] = Math.max(R[ct], st[ct]);
              const U = fn(s.a3 / 2, s.a3 / 2, e.x, e.y, e.z),
                Y = s.aZ([], [0, 1, 0], U);
              s.aY(Y, Y);
              const se = s.aZ([], U, Y);
              s.aY(se, se);
              const le = s.aZ([], A[2], A[1]);
              s.aY(le, le);
              const ce = s.aZ([], A[0], A[3]);
              s.aY(ce, ce), E.push(s.aU([], U, S)), e.y >= (1 << e.z) / 2 && E.push(s.aU([], fn(s.a3 / 2, 0, e.x, e.y, e.z), S)), e.y < (1 << e.z) / 2 && E.push(s.aU([], fn(s.a3 / 2, s.a3, e.x, e.y, e.z), S));
              const ge = Dh(U, E),
                Pe = Dh(se, E),
                fe = [-U[0], -U[1], -U[2], ge.max],
                Me = [U[0], U[1], U[2], -ge.min],
                Ee = [-se[0], -se[1], -se[2], Pe.max],
                ve = [se[0], se[1], se[2], -Pe.min],
                Oe = [...le, 0],
                lt = [...ce, 0],
                it = [];
              return e.y === 0 ? it.push(s.bw(lt, Oe, fe), s.bw(lt, Oe, Me)) : it.push(s.bw(Ee, Oe, fe), s.bw(Ee, Oe, Me), s.bw(Ee, lt, fe), s.bw(Ee, lt, Me)), e.y === (1 << e.z) - 1 ? it.push(s.bw(lt, Oe, fe), s.bw(lt, Oe, Me)) : it.push(s.bw(ve, Oe, fe), s.bw(ve, Oe, Me), s.bw(ve, lt, fe), s.bw(ve, lt, Me)), new Bs(it, [fe, Me, Ee, ve, Oe, lt], F, R)
            }
          }
        }

        function Dh(h, e) {
          let a = 1 / 0,
            o = -1 / 0;
          for (const c of e) {
            const d = s.a_(h, c);
            a = Math.min(a, d), o = Math.max(o, d)
          }
          return {
            min: a,
            max: o
          }
        }
        class wl {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, a, o) {
            return this._helper.interpolatePadding(e, a, o)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, a) {
            this._helper.resize(e, a)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          setConstrain(e) {
            this._helper.setConstrain(e)
          }
          overrideNearFarZ(e, a) {
            this._helper.overrideNearFarZ(e, a)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get constrain() {
            return this._helper.constrain
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          setTransitionState(e) {}
          constructor(e) {
            this._cachedClippingPlane = s.by(), this._projectionMatrix = s.bc(), this._globeViewProjMatrix32f = s.bb(), this._globeViewProjMatrixNoCorrection = s.bc(), this._globeViewProjMatrixNoCorrectionInverted = s.bc(), this._globeProjMatrixInverted = s.bc(), this._cameraPosition = s.bs(), this._globeLatitudeErrorCorrectionRadians = 0, this.defaultConstrain = (a, o) => {
              const c = s.ai(a.lat, -s.aj, s.aj),
                d = s.ai(+o, this.minZoom + Gi(0, c), this.maxZoom);
              return {
                center: new s.U(a.lng, c),
                zoom: d
              }
            }, this._helper = new Ui({
              calcMatrices: () => {
                this._calcMatrices()
              },
              constrain: (a, o) => this.defaultConstrain(a, o)
            }, e), this._coveringTilesDetailsProvider = new Fp
          }
          clone() {
            const e = new wl;
            return e.apply(this), e
          }
          apply(e, a) {
            this._globeLatitudeErrorCorrectionRadians = a || 0, this._helper.apply(e)
          }
          get projectionMatrix() {
            return this._projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted
          }
          get cameraPosition() {
            const e = s.bs();
            return e[0] = this._cameraPosition[0], e[1] = this._cameraPosition[1], e[2] = this._cameraPosition[2], e
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          getProjectionData(e) {
            const {
              overscaledTileID: a,
              applyGlobeMatrix: o
            } = e, c = this._helper.getMercatorTileCoordinates(a);
            return {
              mainMatrix: this._globeViewProjMatrix32f,
              tileMercatorCoords: c,
              clippingPlane: this._cachedClippingPlane,
              projectionTransition: o ? 1 : 0,
              fallbackMatrix: this._globeViewProjMatrix32f
            }
          }
          _computeClippingPlane(e) {
            const a = this.pitchInRadians,
              o = this.cameraToCenterDistance / e,
              c = Math.sin(a) * o,
              d = Math.cos(a) * o + 1,
              g = 1 / Math.sqrt(c * c + d * d) * 1;
            let w = -c,
              S = d;
            const A = Math.sqrt(w * w + S * S);
            w /= A, S /= A;
            const E = [0, w, S];
            s.bz(E, E, [0, 0, 0], -this.bearingInRadians), s.bA(E, E, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), s.bB(E, E, [0, 0, 0], this.center.lng * Math.PI / 180);
            const F = 1 / s.b0(E);
            return s.aU(E, E, F), [...E, -g * F]
          }
          isLocationOccluded(e) {
            return !this.isSurfacePointVisible(ha(e))
          }
          transformLightDirection(e) {
            const a = this._helper._center.lng * Math.PI / 180,
              o = this._helper._center.lat * Math.PI / 180,
              c = Math.cos(o),
              d = [Math.sin(a) * c, Math.sin(o), Math.cos(a) * c],
              g = [d[2], 0, -d[0]],
              w = [0, 0, 0];
            s.aZ(w, g, d), s.aY(g, g), s.aY(w, w);
            const S = [0, 0, 0];
            return s.aY(S, [g[0] * e[0] + w[0] * e[1] + d[0] * e[2], g[1] * e[0] + w[1] * e[1] + d[1] * e[2], g[2] * e[0] + w[2] * e[1] + d[2] * e[2]]), S
          }
          getPixelScale() {
            return 1 / Math.cos(this._helper._center.lat * Math.PI / 180)
          }
          getCircleRadiusCorrection() {
            return Math.cos(this._helper._center.lat * Math.PI / 180)
          }
          getPitchedTextCorrection(e, a, o) {
            const c = (function(w, S, A) {
                const E = 1 / (1 << A.z);
                return new s.a5(w / s.a3 * E + A.x * E, S / s.a3 * E + A.y * E)
              })(e, a, o.canonical),
              d = (g = c.y, [s.br(c.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - g * Math.PI * 2)) - .5 * Math.PI]);
            var g;
            return this.getCircleRadiusCorrection() / Math.cos(d[1])
          }
          projectTileCoordinates(e, a, o, c) {
            const d = o.canonical,
              g = fn(e, a, d.x, d.y, d.z),
              w = 1 + (c ? c(e, a) : 0) / s.bx,
              S = [g[0] * w, g[1] * w, g[2] * w, 1];
            s.aA(S, S, this._globeViewProjMatrixNoCorrection);
            const A = this._cachedClippingPlane,
              E = A[0] * g[0] + A[1] * g[1] + A[2] * g[2] + A[3] < 0;
            return {
              point: new s.P(S[0] / S[3], S[1] / S[3]),
              signedDistanceFromCamera: S[3],
              isOccluded: E
            }
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const e = Vn(this.worldSize, this.center.lat),
              a = s.bd(),
              o = s.bd();
            this._helper.autoCalculateNearFarZ && (this._helper._nearZ = .5, this._helper._farZ = this.cameraToCenterDistance + 2 * e), s.b7(a, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
            const c = this.centerOffset;
            a[8] = 2 * -c.x / this._helper._width, a[9] = 2 * c.y / this._helper._height, this._projectionMatrix = s.b8(a), this._globeProjMatrixInverted = s.bd(), s.au(this._globeProjMatrixInverted, a), s.N(a, a, [0, 0, -this.cameraToCenterDistance]), s.b9(a, a, this.rollInRadians), s.ba(a, a, -this.pitchInRadians), s.b9(a, a, this.bearingInRadians), s.N(a, a, [0, 0, -e]);
            const d = s.bs();
            d[0] = e, d[1] = e, d[2] = e, s.ba(o, a, this.center.lat * Math.PI / 180), s.bC(o, o, -this.center.lng * Math.PI / 180), s.O(o, o, d), this._globeViewProjMatrixNoCorrection = o, s.ba(a, a, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), s.bC(a, a, -this.center.lng * Math.PI / 180), s.O(a, a, d), this._globeViewProjMatrix32f = new Float32Array(a), this._globeViewProjMatrixNoCorrectionInverted = s.bd(), s.au(this._globeViewProjMatrixNoCorrectionInverted, o);
            const g = s.bs();
            this._cameraPosition = s.bs(), this._cameraPosition[2] = this.cameraToCenterDistance / e, s.bz(this._cameraPosition, this._cameraPosition, g, -this.rollInRadians), s.bA(this._cameraPosition, this._cameraPosition, g, this.pitchInRadians), s.bz(this._cameraPosition, this._cameraPosition, g, -this.bearingInRadians), s.aV(this._cameraPosition, this._cameraPosition, [0, 0, 1]), s.bA(this._cameraPosition, this._cameraPosition, g, -this.center.lat * Math.PI / 180), s.bB(this._cameraPosition, this._cameraPosition, g, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e);
            const w = s.b8(this._globeViewProjMatrixNoCorrectionInverted);
            s.O(w, w, [1, 1, -1]), this._cachedFrustum = Da.fromInvProjectionMatrix(w, 1, 0, this._cachedClippingPlane, !0)
          }
          calculateFogMatrix(e) {
            s.w("calculateFogMatrix is not supported on globe projection.");
            const a = s.bd();
            return s.am(a), a
          }
          getVisibleUnwrappedCoordinates(e) {
            return [new s.b5(0, e)]
          }
          getCameraFrustum() {
            return this._cachedFrustum
          }
          getClippingPlane() {
            return this._cachedClippingPlane
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider
          }
          recalculateZoomAndCenter(e) {
            e && s.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0)
          }
          maxPitchScaleFactor() {
            return 1
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat()
          }
          lngLatToCameraDepth(e, a) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const o = ha(e);
            s.aU(o, o, 1 + a / s.bx);
            const c = s.by();
            return s.aA(c, [o[0], o[1], o[2], 1], this._globeViewProjMatrixNoCorrection), c[2] / c[3]
          }
          populateCache(e) {}
          getBounds() {
            const e = .5 * this.width,
              a = .5 * this.height,
              o = [new s.P(0, 0), new s.P(e, 0), new s.P(this.width, 0), new s.P(this.width, a), new s.P(this.width, this.height), new s.P(e, this.height), new s.P(0, this.height), new s.P(0, a)],
              c = [];
            for (const F of o) c.push(this.unprojectScreenPoint(F));
            let d = 0,
              g = 0,
              w = 0,
              S = 0;
            const A = this.center;
            for (const F of c) {
              const R = s.bD(A.lng, F.lng),
                U = s.bD(A.lat, F.lat);
              R < g && (g = R), R > d && (d = R), U < S && (S = U), U > w && (w = U)
            }
            const E = [A.lng + g, A.lat + S, A.lng + d, A.lat + w];
            return this.isSurfacePointOnScreen([0, 1, 0]) && (E[3] = 90, E[0] = -180, E[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (E[1] = -90, E[0] = -180, E[2] = 180), new wt(E)
          }
          calculateCenterFromCameraLngLatAlt(e, a, o, c) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, a, o, c)
          }
          setLocationAtPoint(e, a) {
            const o = ha(this.unprojectScreenPoint(a)),
              c = ha(e),
              d = s.bs();
            s.bE(d);
            const g = s.bs();
            s.bB(g, o, d, -this.center.lng * Math.PI / 180), s.bA(g, g, d, this.center.lat * Math.PI / 180);
            const w = c[0] * c[0] + c[2] * c[2],
              S = g[0] * g[0];
            if (w < S) return;
            const A = Math.sqrt(w - S),
              E = -A,
              F = s.bF(c[0], c[2], g[0], A),
              R = s.bF(c[0], c[2], g[0], E),
              U = s.bs();
            s.bB(U, c, d, -F);
            const Y = s.bF(U[1], U[2], g[1], g[2]),
              se = s.bs();
            s.bB(se, c, d, -R);
            const le = s.bF(se[1], se[2], g[1], g[2]),
              ce = .5 * Math.PI,
              ge = Y >= -ce && Y <= ce,
              Pe = le >= -ce && le <= ce;
            let fe, Me;
            if (ge && Pe) {
              const lt = this.center.lng * Math.PI / 180,
                it = this.center.lat * Math.PI / 180;
              s.bG(F, lt) + s.bG(Y, it) < s.bG(R, lt) + s.bG(le, it) ? (fe = F, Me = Y) : (fe = R, Me = le)
            } else if (ge) fe = F, Me = Y;
            else {
              if (!Pe) return;
              fe = R, Me = le
            }
            const Ee = fe / Math.PI * 180,
              ve = Me / Math.PI * 180,
              Oe = this.center.lat;
            this.setCenter(new s.U(Ee, s.ai(ve, -90, 90))), this.setZoom(this.zoom + Gi(Oe, this.center.lat))
          }
          locationToScreenPoint(e, a) {
            const o = ha(e);
            if (a) {
              const c = a.getElevationForLngLatZoom(e, this._helper._tileZoom);
              s.aU(o, o, 1 + c / s.bx)
            }
            return this._projectSurfacePointToScreen(o)
          }
          _projectSurfacePointToScreen(e) {
            const a = s.by();
            return s.aA(a, [...e, 1], this._globeViewProjMatrixNoCorrection), a[0] /= a[3], a[1] /= a[3], new s.P((.5 * a[0] + .5) * this.width, (.5 * -a[1] + .5) * this.height)
          }
          screenPointToMercatorCoordinate(e, a) {
            if (a) {
              const o = a.pointCoordinate(e);
              if (o) return o
            }
            return s.a5.fromLngLat(this.unprojectScreenPoint(e))
          }
          screenPointToLocation(e, a) {
            var o;
            return (o = this.screenPointToMercatorCoordinate(e, a)) === null || o === void 0 ? void 0 : o.toLngLat()
          }
          isPointOnMapSurface(e, a) {
            const o = this._cameraPosition,
              c = this.getRayDirectionFromPixel(e);
            return !!this.rayPlanetIntersection(o, c)
          }
          getRayDirectionFromPixel(e) {
            const a = s.by();
            a[0] = e.x / this.width * 2 - 1, a[1] = -1 * (e.y / this.height * 2 - 1), a[2] = 1, a[3] = 1, s.aA(a, a, this._globeViewProjMatrixNoCorrectionInverted), a[0] /= a[3], a[1] /= a[3], a[2] /= a[3];
            const o = s.bs();
            o[0] = a[0] - this._cameraPosition[0], o[1] = a[1] - this._cameraPosition[1], o[2] = a[2] - this._cameraPosition[2];
            const c = s.bs();
            return s.aY(c, o), c
          }
          isSurfacePointVisible(e) {
            const a = this._cachedClippingPlane;
            return a[0] * e[0] + a[1] * e[1] + a[2] * e[2] + a[3] >= 0
          }
          isSurfacePointOnScreen(e) {
            if (!this.isSurfacePointVisible(e)) return !1;
            const a = s.by();
            return s.aA(a, [...e, 1], this._globeViewProjMatrixNoCorrection), a[0] /= a[3], a[1] /= a[3], a[2] /= a[3], a[0] > -1 && a[0] < 1 && a[1] > -1 && a[1] < 1 && a[2] > -1 && a[2] < 1
          }
          rayPlanetIntersection(e, a) {
            const o = s.a_(e, a),
              c = s.bs(),
              d = s.bs();
            s.aU(d, a, o), s.aX(c, e, d);
            const g = 1 - s.a_(c, c);
            if (g < 0) return null;
            const w = s.a_(e, e) - 1,
              S = -o + (o < 0 ? 1 : -1) * Math.sqrt(g),
              A = w / S,
              E = S;
            return {
              tMin: Math.min(A, E),
              tMax: Math.max(A, E)
            }
          }
          unprojectScreenPoint(e) {
            const a = this._cameraPosition,
              o = this.getRayDirectionFromPixel(e),
              c = this.rayPlanetIntersection(a, o);
            if (c) {
              const E = s.bs();
              s.aV(E, a, [o[0] * c.tMin, o[1] * c.tMin, o[2] * c.tMin]);
              const F = s.bs();
              return s.aY(F, E), Fs(F)
            }
            const d = this._cachedClippingPlane,
              g = d[0] * o[0] + d[1] * o[1] + d[2] * o[2],
              w = -s.b4(d, a) / g,
              S = s.bs();
            if (w > 0) s.aV(S, a, [o[0] * w, o[1] * w, o[2] * w]);
            else {
              const E = s.bs();
              s.aV(E, a, [2 * o[0], 2 * o[1], 2 * o[2]]);
              const F = s.b4(this._cachedClippingPlane, E);
              s.aX(S, E, [this._cachedClippingPlane[0] * F, this._cachedClippingPlane[1] * F, this._cachedClippingPlane[2] * F])
            }
            const A = (function(E) {
              const F = s.bs();
              return F[0] = E[0] * -E[3], F[1] = E[1] * -E[3], F[2] = E[2] * -E[3], {
                center: F,
                radius: Math.sqrt(1 - E[3] * E[3])
              }
            })(d);
            return Fs((function(E, F, R) {
              const U = s.bs();
              s.aX(U, R, E);
              const Y = s.bs();
              return s.bt(Y, E, U, F / s.b2(U)), Y
            })(A.center, A.radius, S))
          }
          getMatrixForModel(e, a) {
            const o = s.U.convert(e),
              c = 1 / s.bx,
              d = s.bc();
            return s.bC(d, d, o.lng / 180 * Math.PI), s.ba(d, d, -o.lat / 180 * Math.PI), s.N(d, d, [0, 0, 1 + a / s.bx]), s.ba(d, d, .5 * Math.PI), s.O(d, d, [c, c, c]), d
          }
          getProjectionDataForCustomLayer(e = !0) {
            const a = this.getProjectionData({
              overscaledTileID: new s.a0(0, 0, 0, 0, 0),
              applyGlobeMatrix: e
            });
            return a.tileMercatorCoords = [0, 0, 1, 1], a
          }
          getFastPathSimpleProjectionMatrix(e) {}
        }
        class Tl {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, a, o) {
            return this._helper.interpolatePadding(e, a, o)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, a, o = !0) {
            this._helper.resize(e, a, o)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          setConstrain(e) {
            this._helper.setConstrain(e)
          }
          overrideNearFarZ(e, a) {
            this._helper.overrideNearFarZ(e, a)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          get constrain() {
            return this._helper.constrain
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          get isGlobeRendering() {
            return this._globeness > 0
          }
          setTransitionState(e, a) {
            this._globeness = e, this._globeLatitudeErrorCorrectionRadians = a, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame()
          }
          get currentTransform() {
            return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform
          }
          constructor(e) {
            this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this.defaultConstrain = (a, o) => this.currentTransform.defaultConstrain(a, o), this._helper = new Ui({
              calcMatrices: () => {
                this._calcMatrices()
              },
              constrain: (a, o) => this.defaultConstrain(a, o)
            }, e), this._globeness = 1, this._mercatorTransform = new Sa, this._verticalPerspectiveTransform = new wl
          }
          clone() {
            const e = new Tl;
            return e._globeness = this._globeness, e._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e.apply(this), e
          }
          apply(e) {
            this._helper.apply(e), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians)
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition
          }
          getProjectionData(e) {
            const a = this._mercatorTransform.getProjectionData(e),
              o = this._verticalPerspectiveTransform.getProjectionData(e);
            return {
              mainMatrix: this.isGlobeRendering ? o.mainMatrix : a.mainMatrix,
              clippingPlane: o.clippingPlane,
              tileMercatorCoords: o.tileMercatorCoords,
              projectionTransition: e.applyGlobeMatrix ? this._globeness : 0,
              fallbackMatrix: a.fallbackMatrix
            }
          }
          isLocationOccluded(e) {
            return this.currentTransform.isLocationOccluded(e)
          }
          transformLightDirection(e) {
            return this.currentTransform.transformLightDirection(e)
          }
          getPixelScale() {
            return s.bn(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness)
          }
          getCircleRadiusCorrection() {
            return s.bn(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness)
          }
          getPitchedTextCorrection(e, a, o) {
            const c = this._mercatorTransform.getPitchedTextCorrection(e, a, o),
              d = this._verticalPerspectiveTransform.getPitchedTextCorrection(e, a, o);
            return s.bn(c, d, this._globeness)
          }
          projectTileCoordinates(e, a, o, c) {
            return this.currentTransform.projectTileCoordinates(e, a, o, c)
          }
          _calcMatrices() {
            this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ)
          }
          calculateFogMatrix(e) {
            return this.currentTransform.calculateFogMatrix(e)
          }
          getVisibleUnwrappedCoordinates(e) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(e)
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum()
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane()
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider()
          }
          recalculateZoomAndCenter(e) {
            this._mercatorTransform.recalculateZoomAndCenter(e), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e)
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor()
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat()
          }
          lngLatToCameraDepth(e, a) {
            return this.currentTransform.lngLatToCameraDepth(e, a)
          }
          populateCache(e) {
            this._mercatorTransform.populateCache(e), this._verticalPerspectiveTransform.populateCache(e)
          }
          getBounds() {
            return this.currentTransform.getBounds()
          }
          calculateCenterFromCameraLngLatAlt(e, a, o, c) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, a, o, c)
          }
          setLocationAtPoint(e, a) {
            if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e, a), void this.apply(this._mercatorTransform);
            this._verticalPerspectiveTransform.setLocationAtPoint(e, a), this.apply(this._verticalPerspectiveTransform)
          }
          locationToScreenPoint(e, a) {
            return this.currentTransform.locationToScreenPoint(e, a)
          }
          screenPointToMercatorCoordinate(e, a) {
            return this.currentTransform.screenPointToMercatorCoordinate(e, a)
          }
          screenPointToLocation(e, a) {
            return this.currentTransform.screenPointToLocation(e, a)
          }
          isPointOnMapSurface(e, a) {
            return this.currentTransform.isPointOnMapSurface(e, a)
          }
          getRayDirectionFromPixel(e) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e)
          }
          getMatrixForModel(e, a) {
            return this.currentTransform.getMatrixForModel(e, a)
          }
          getProjectionDataForCustomLayer(e = !0) {
            const a = this._mercatorTransform.getProjectionDataForCustomLayer(e);
            if (!this.isGlobeRendering) return a;
            const o = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e);
            return o.fallbackMatrix = a.mainMatrix, o
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(e)
          }
        }
        class Zn {
          get useGlobeControls() {
            return !0
          }
          handlePanInertia(e, a) {
            const o = bl(e, a);
            return Math.abs(o.lng - a.center.lng) > 180 && (o.lng = a.center.lng + 179.5 * Math.sign(o.lng - a.center.lng)), {
              easingCenter: o,
              easingOffset: new s.P(0, 0)
            }
          }
          handleMapControlsRollPitchBearingZoom(e, a) {
            const o = e.around,
              c = a.screenPointToLocation(o);
            e.bearingDelta && a.setBearing(a.bearing + e.bearingDelta), e.pitchDelta && a.setPitch(a.pitch + e.pitchDelta), e.rollDelta && a.setRoll(a.roll + e.rollDelta);
            const d = a.zoom;
            e.zoomDelta && a.setZoom(a.zoom + e.zoomDelta);
            const g = a.zoom - d;
            if (g === 0) return;
            const w = s.bD(a.center.lng, c.lng),
              S = w / (Math.abs(w / 180) + 1),
              A = s.bD(a.center.lat, c.lat),
              E = a.getRayDirectionFromPixel(o),
              F = a.cameraPosition,
              R = -1 * s.a_(F, E),
              U = s.bs();
            s.aV(U, F, [E[0] * R, E[1] * R, E[2] * R]);
            const Y = s.b0(U) - 1,
              se = Math.exp(.5 * -Math.max(Y - .3, 0)),
              le = Vn(a.worldSize, a.center.lat) / Math.min(a.width, a.height),
              ce = s.bq(le, .9, .5, 1, .25),
              ge = (1 - s.al(-g)) * Math.min(se, ce),
              Pe = a.center.lat,
              fe = a.zoom,
              Me = new s.U(a.center.lng + S * ge, s.ai(a.center.lat + A * ge, -s.aj, s.aj));
            a.setLocationAtPoint(c, o);
            const Ee = a.center,
              ve = s.bq(Math.abs(w), 45, 85, 0, 1),
              Oe = s.bq(le, .75, .35, 0, 1),
              lt = Math.pow(Math.max(ve, Oe), .25),
              it = s.bD(Ee.lng, Me.lng),
              st = s.bD(Ee.lat, Me.lat);
            a.setCenter(new s.U(Ee.lng + it * lt, Ee.lat + st * lt).wrap()), a.setZoom(fe + Gi(Pe, a.center.lat))
          }
          handleMapControlsPan(e, a, o) {
            if (!e.panDelta) return;
            const c = a.center.lat,
              d = a.zoom;
            a.setCenter(bl(e.panDelta, a).wrap()), a.setZoom(d + Gi(c, a.center.lat))
          }
          cameraForBoxAndBearing(e, a, o, c, d) {
            const g = Pa(e, a, o, c, d),
              w = a.left / d.width * 2 - 1,
              S = (d.width - a.right) / d.width * 2 - 1,
              A = a.top / d.height * -2 + 1,
              E = (d.height - a.bottom) / d.height * -2 + 1,
              F = s.bD(o.getWest(), o.getEast()) < 0,
              R = F ? o.getEast() : o.getWest(),
              U = F ? o.getWest() : o.getEast(),
              Y = Math.max(o.getNorth(), o.getSouth()),
              se = Math.min(o.getNorth(), o.getSouth()),
              le = R + .5 * s.bD(R, U),
              ce = Y + .5 * s.bD(Y, se),
              ge = d.clone();
            ge.setCenter(g.center), ge.setBearing(g.bearing), ge.setPitch(0), ge.setRoll(0), ge.setZoom(g.zoom);
            const Pe = ge.modelViewProjectionMatrix,
              fe = [ha(o.getNorthWest()), ha(o.getNorthEast()), ha(o.getSouthWest()), ha(o.getSouthEast()), ha(new s.U(U, ce)), ha(new s.U(R, ce)), ha(new s.U(le, Y)), ha(new s.U(le, se))],
              Me = ha(g.center);
            let Ee = Number.POSITIVE_INFINITY;
            for (const ve of fe) w < 0 && (Ee = Zn.getLesserNonNegativeNonNull(Ee, Zn.solveVectorScale(ve, Me, Pe, "x", w))), S > 0 && (Ee = Zn.getLesserNonNegativeNonNull(Ee, Zn.solveVectorScale(ve, Me, Pe, "x", S))), A > 0 && (Ee = Zn.getLesserNonNegativeNonNull(Ee, Zn.solveVectorScale(ve, Me, Pe, "y", A))), E < 0 && (Ee = Zn.getLesserNonNegativeNonNull(Ee, Zn.solveVectorScale(ve, Me, Pe, "y", E)));
            if (Number.isFinite(Ee) && Ee !== 0) return g.zoom = ge.zoom + s.ao(Ee), g;
            Ki()
          }
          handleJumpToCenterZoom(e, a) {
            const o = e.center.lat,
              c = e.constrain(a.center ? s.U.convert(a.center) : e.center, e.zoom).center;
            e.setCenter(c.wrap());
            const d = a.zoom !== void 0 ? +a.zoom : e.zoom + Gi(o, c.lat);
            e.zoom !== d && e.setZoom(d)
          }
          handleEaseTo(e, a) {
            const o = e.zoom,
              c = e.center,
              d = e.padding,
              g = {
                roll: e.roll,
                pitch: e.pitch,
                bearing: e.bearing
              },
              w = {
                roll: a.roll === void 0 ? e.roll : a.roll,
                pitch: a.pitch === void 0 ? e.pitch : a.pitch,
                bearing: a.bearing === void 0 ? e.bearing : a.bearing
              },
              S = a.zoom !== void 0,
              A = !e.isPaddingEqual(a.padding);
            let E = !1;
            const F = a.center ? s.U.convert(a.center) : c,
              R = e.constrain(F, o).center;
            li(e, R);
            const U = e.clone();
            U.setCenter(R), U.setZoom(S ? +a.zoom : o + Gi(c.lat, F.lat)), U.setBearing(a.bearing);
            const Y = new s.P(s.ai(e.centerPoint.x + a.offsetAsPoint.x, 0, e.width), s.ai(e.centerPoint.y + a.offsetAsPoint.y, 0, e.height));
            U.setLocationAtPoint(R, Y);
            const se = (a.offset && a.offsetAsPoint.mag()) > 0 ? U.center : R,
              le = S ? +a.zoom : o + Gi(c.lat, se.lat),
              ce = o + Gi(c.lat, 0),
              ge = le + Gi(se.lat, 0),
              Pe = s.bD(c.lng, se.lng),
              fe = s.bD(c.lat, se.lat),
              Me = s.al(ge - ce);
            return E = le !== o, {
              easeFunc: Ee => {
                if (s.bh(g, w) || ca({
                    startEulerAngles: g,
                    endEulerAngles: w,
                    tr: e,
                    k: Ee,
                    useSlerp: g.roll != w.roll
                  }), A && e.interpolatePadding(d, a.padding, Ee), a.around) s.w("Easing around a point is not supported under globe projection."), e.setLocationAtPoint(a.around, a.aroundPoint);
                else {
                  const ve = ge > ce ? Math.min(2, Me) : Math.max(.5, Me),
                    Oe = Math.pow(ve, 1 - Ee),
                    lt = qo(c, Pe, fe, Ee * Oe);
                  e.setCenter(lt.wrap())
                }
                if (E) {
                  const ve = s.F.number(ce, ge, Ee) + Gi(0, e.center.lat);
                  e.setZoom(ve)
                }
              },
              isZooming: E,
              elevationCenter: se
            }
          }
          handleFlyTo(e, a) {
            const o = a.zoom !== void 0,
              c = e.center,
              d = e.zoom,
              g = e.padding,
              w = !e.isPaddingEqual(a.padding),
              S = e.constrain(s.U.convert(a.center || a.locationAtOffset), d).center,
              A = o ? +a.zoom : e.zoom + Gi(e.center.lat, S.lat),
              E = e.clone();
            E.setCenter(S), E.setZoom(A), E.setBearing(a.bearing);
            const F = new s.P(s.ai(e.centerPoint.x + a.offsetAsPoint.x, 0, e.width), s.ai(e.centerPoint.y + a.offsetAsPoint.y, 0, e.height));
            E.setLocationAtPoint(S, F);
            const R = E.center;
            li(e, R);
            const U = (function(fe, Me, Ee) {
                const ve = ha(Me),
                  Oe = ha(Ee),
                  lt = s.a_(ve, Oe),
                  it = Math.acos(lt),
                  st = Ma(fe);
                return it / (2 * Math.PI) * st
              })(e, c, R),
              Y = d + Gi(c.lat, 0),
              se = A + Gi(R.lat, 0),
              le = s.al(se - Y);
            let ce;
            if (typeof a.minZoom == "number") {
              const fe = +a.minZoom + Gi(R.lat, 0),
                Me = Math.min(fe, Y, se) + Gi(0, R.lat),
                Ee = e.constrain(R, Me).zoom + Gi(R.lat, 0);
              ce = s.al(Ee - Y)
            }
            const ge = s.bD(c.lng, R.lng),
              Pe = s.bD(c.lat, R.lat);
            return {
              easeFunc: (fe, Me, Ee, ve) => {
                const Oe = qo(c, ge, Pe, Ee);
                w && e.interpolatePadding(g, a.padding, fe);
                const lt = fe === 1 ? R : Oe;
                e.setCenter(lt.wrap());
                const it = Y + s.ao(Me);
                e.setZoom(fe === 1 ? A : it + Gi(0, lt.lat))
              },
              scaleOfZoom: le,
              targetCenter: R,
              scaleOfMinZoom: ce,
              pixelPathLength: U
            }
          }
          static solveVectorScale(e, a, o, c, d) {
            const g = c === "x" ? [o[0], o[4], o[8], o[12]] : [o[1], o[5], o[9], o[13]],
              w = [o[3], o[7], o[11], o[15]],
              S = e[0] * g[0] + e[1] * g[1] + e[2] * g[2],
              A = e[0] * w[0] + e[1] * w[1] + e[2] * w[2],
              E = a[0] * g[0] + a[1] * g[1] + a[2] * g[2],
              F = a[0] * w[0] + a[1] * w[1] + a[2] * w[2];
            return E + d * A === S + d * F || w[3] * (S - E) + g[3] * (F - A) + S * F == E * A ? null : (E + g[3] - d * F - d * w[3]) / (E - S - d * F + d * A)
          }
          static getLesserNonNegativeNonNull(e, a) {
            return a !== null && a >= 0 && a < e ? a : e
          }
        }
        class Vo {
          constructor(e) {
            this._globe = e, this._mercatorCameraHelper = new ja, this._verticalPerspectiveCameraHelper = new Zn
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering
          }
          get currentHelper() {
            return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper
          }
          handlePanInertia(e, a) {
            return this.currentHelper.handlePanInertia(e, a)
          }
          handleMapControlsRollPitchBearingZoom(e, a) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(e, a)
          }
          handleMapControlsPan(e, a, o) {
            this.currentHelper.handleMapControlsPan(e, a, o)
          }
          cameraForBoxAndBearing(e, a, o, c, d) {
            return this.currentHelper.cameraForBoxAndBearing(e, a, o, c, d)
          }
          handleJumpToCenterZoom(e, a) {
            this.currentHelper.handleJumpToCenterZoom(e, a)
          }
          handleEaseTo(e, a) {
            return this.currentHelper.handleEaseTo(e, a)
          }
          handleFlyTo(e, a) {
            return this.currentHelper.handleFlyTo(e, a)
          }
        }
        const vo = (h, e) => s.z(h, e && e.filter((a => a.identifier !== "source.canvas"))),
          Sl = s.bH();
        class Zo extends s.E {
          constructor(e, a = {}) {
            var o, c;
            super(), this._rtlPluginLoaded = () => {
              for (const g in this.tileManagers) {
                const w = this.tileManagers[g].getSource().type;
                w !== "vector" && w !== "geojson" || this.tileManagers[g].reload()
              }
            }, this.map = e, this.dispatcher = new rt(nt(), e._getMapId()), this.dispatcher.registerMessageHandler("GG", ((g, w) => this.getGlyphs(g, w))), this.dispatcher.registerMessageHandler("GI", ((g, w) => this.getImages(g, w))), this.dispatcher.registerMessageHandler("GDA", ((g, w) => this.getDashes(g, w))), this.imageManager = new qe, this.imageManager.setEventedParent(this);
            const d = ((o = e._container) === null || o === void 0 ? void 0 : o.lang) || typeof document < "u" && ((c = document.documentElement) === null || c === void 0 ? void 0 : c.lang) || void 0;
            this.glyphManager = new Vt(e._requestManager, a.localIdeographFontFamily, d), this.lineAtlas = new Dt(256, 512), this.crossTileSymbolIndex = new kr, this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.tileManagers = {}, this.zoomHistory = new s.bI, this._loaded = !1, this._availableImages = [], this._globalState = {}, this._resetUpdates(), this.dispatcher.broadcast("SR", s.bJ()), V().on(sr, this._rtlPluginLoaded), this.on("data", (g => {
              if (g.dataType !== "source" || g.sourceDataType !== "metadata") return;
              const w = this.tileManagers[g.sourceId];
              if (!w) return;
              const S = w.getSource();
              if (S && S.vectorLayerIds)
                for (const A in this._layers) {
                  const E = this._layers[A];
                  E.source === S.id && this._validateLayer(E)
                }
            }))
          }
          setGlobalStateProperty(e, a) {
            var o, c, d;
            this._checkLoaded();
            const g = a === null ? (d = (c = (o = this.stylesheet.state) === null || o === void 0 ? void 0 : o[e]) === null || c === void 0 ? void 0 : c.default) !== null && d !== void 0 ? d : null : a;
            if (s.bK(g, this._globalState[e])) return this;
            this._globalState[e] = g, this._applyGlobalStateChanges([e])
          }
          getGlobalState() {
            return this._globalState
          }
          setGlobalState(e) {
            this._checkLoaded();
            const a = [];
            for (const o in e) !s.bK(this._globalState[o], e[o].default) && (a.push(o), this._globalState[o] = e[o].default);
            this._applyGlobalStateChanges(a)
          }
          _applyGlobalStateChanges(e) {
            if (e.length === 0) return;
            const a = new Set,
              o = {};
            for (const c of e) {
              o[c] = this._globalState[c];
              for (const d in this._layers) {
                const g = this._layers[d],
                  w = g.getLayoutAffectingGlobalStateRefs(),
                  S = g.getPaintAffectingGlobalStateRefs();
                if (w.has(c) && a.add(g.source), S.has(c))
                  for (const {
                      name: A,
                      value: E
                    }
                    of S.get(c)) this._updatePaintProperty(g, A, E)
              }
            }
            this.dispatcher.broadcast("UGS", o);
            for (const c in this.tileManagers) a.has(c) && (this._reloadSource(c), this._changed = !0)
          }
          loadURL(e, a = {}, o) {
            this.fire(new s.l("dataloading", {
              dataType: "style"
            })), a.validate = typeof a.validate != "boolean" || a.validate;
            const c = this.map._requestManager.transformRequest(e, "Style");
            this._loadStyleRequest = new AbortController;
            const d = this._loadStyleRequest;
            s.j(c, this._loadStyleRequest).then((g => {
              this._loadStyleRequest = null, this._load(g.data, a, o)
            })).catch((g => {
              this._loadStyleRequest = null, g && !d.signal.aborted && this.fire(new s.k(g))
            }))
          }
          loadJSON(e, a = {}, o) {
            this.fire(new s.l("dataloading", {
              dataType: "style"
            })), this._frameRequest = new AbortController, oe.frameAsync(this._frameRequest).then((() => {
              this._frameRequest = null, a.validate = a.validate !== !1, this._load(e, a, o)
            })).catch((() => {}))
          }
          loadEmpty() {
            this.fire(new s.l("dataloading", {
              dataType: "style"
            })), this._load(Sl, {
              validate: !1
            })
          }
          _load(e, a, o) {
            var c, d;
            let g = a.transformStyle ? a.transformStyle(o, e) : e;
            if (!a.validate || !vo(this, s.B(g))) {
              g = Object.assign({}, g), this._loaded = !0, this.stylesheet = g;
              for (const w in g.sources) this.addSource(w, g.sources[w], {
                validate: !1
              });
              g.sprite ? this._loadSprite(g.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(g.glyphs), this._createLayers(), this.light = new ot(this.stylesheet.light), this._setProjectionInternal(((c = this.stylesheet.projection) === null || c === void 0 ? void 0 : c.type) || "mercator"), this.sky = new vt(this.stylesheet.sky), this.map.setTerrain((d = this.stylesheet.terrain) !== null && d !== void 0 ? d : null), this.fire(new s.l("data", {
                dataType: "style"
              })), this.fire(new s.l("style.load"))
            }
          }
          _createLayers() {
            var e, a, o;
            const c = s.bL(this.stylesheet.layers);
            this.setGlobalState((e = this.stylesheet.state) !== null && e !== void 0 ? e : null), this.dispatcher.broadcast("SL", c), this._order = c.map((d => d.id)), this._layers = {}, this._serializedLayers = null;
            for (const d of c) {
              const g = s.bM(d, this._globalState);
              if (g.setEventedParent(this, {
                  layer: {
                    id: d.id
                  }
                }), this._layers[d.id] = g, s.bN(g) && this.tileManagers[g.source]) {
                const w = (o = (a = d.paint) === null || a === void 0 ? void 0 : a["raster-fade-duration"]) !== null && o !== void 0 ? o : g.paint.get("raster-fade-duration");
                this.tileManagers[g.source].setRasterFadeDuration(w)
              }
            }
          }
          _loadSprite(e, a = !1, o = void 0) {
            let c;
            this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController, (function(d, g, w, S) {
              return s._(this, void 0, void 0, (function*() {
                const A = De(d),
                  E = w > 1 ? "@2x" : "",
                  F = {},
                  R = {};
                for (const {
                    id: U,
                    url: Y
                  }
                  of A) {
                  const se = g.transformRequest(Ye(Y, E, ".json"), "SpriteJSON");
                  F[U] = s.j(se, S);
                  const le = g.transformRequest(Ye(Y, E, ".png"), "SpriteImage");
                  R[U] = Xe.getImage(le, S)
                }
                return yield Promise.all([...Object.values(F), ...Object.values(R)]), (function(U, Y) {
                  return s._(this, void 0, void 0, (function*() {
                    const se = {};
                    for (const le in U) {
                      se[le] = {};
                      const ce = oe.getImageCanvasContext((yield Y[le]).data),
                        ge = (yield U[le]).data;
                      for (const Pe in ge) {
                        const {
                          width: fe,
                          height: Me,
                          x: Ee,
                          y: ve,
                          sdf: Oe,
                          pixelRatio: lt,
                          stretchX: it,
                          stretchY: st,
                          content: ct,
                          textFitWidth: nr,
                          textFitHeight: lr
                        } = ge[Pe];
                        se[le][Pe] = {
                          data: null,
                          pixelRatio: lt,
                          sdf: Oe,
                          stretchX: it,
                          stretchY: st,
                          content: ct,
                          textFitWidth: nr,
                          textFitHeight: lr,
                          spriteData: {
                            width: fe,
                            height: Me,
                            x: Ee,
                            y: ve,
                            context: ce
                          }
                        }
                      }
                    }
                    return se
                  }))
                })(F, R)
              }))
            })(e, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((d => {
              if (this._spriteRequest = null, d)
                for (const g in d) {
                  this._spritesImagesIds[g] = [];
                  const w = this._spritesImagesIds[g] ? this._spritesImagesIds[g].filter((S => !(S in d))) : [];
                  for (const S of w) this.imageManager.removeImage(S), this._changedImages[S] = !0;
                  for (const S in d[g]) {
                    const A = g === "default" ? S : `${g}:${S}`;
                    this._spritesImagesIds[g].push(A), A in this.imageManager.images ? this.imageManager.updateImage(A, d[g][S], !1) : this.imageManager.addImage(A, d[g][S]), a && (this._changedImages[A] = !0)
                  }
                }
            })).catch((d => {
              this._spriteRequest = null, c = d, this.fire(new s.k(c))
            })).finally((() => {
              this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), a && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", {
                dataType: "style"
              })), o && o(c)
            }))
          }
          _unloadSprite() {
            for (const e of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e), this._changedImages[e] = !0;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", {
              dataType: "style"
            }))
          }
          _validateLayer(e) {
            const a = this.tileManagers[e.source];
            if (!a) return;
            const o = e.sourceLayer;
            if (!o) return;
            const c = a.getSource();
            (c.type === "geojson" || c.vectorLayerIds && c.vectorLayerIds.indexOf(o) === -1) && this.fire(new s.k(new Error(`Source layer "${o}" does not exist on source "${c.id}" as specified by style layer "${e.id}".`)))
          }
          loaded() {
            if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
            for (const e in this.tileManagers)
              if (!this.tileManagers[e].loaded()) return !1;
            return !!this.imageManager.isLoaded()
          }
          _serializeByIds(e, a = !1) {
            const o = this._serializedAllLayers();
            if (!e || e.length === 0) return Object.values(a ? s.bO(o) : o);
            const c = [];
            for (const d of e)
              if (o[d]) {
                const g = a ? s.bO(o[d]) : o[d];
                c.push(g)
              } return c
          }
          _serializedAllLayers() {
            let e = this._serializedLayers;
            if (e) return e;
            e = this._serializedLayers = {};
            const a = Object.keys(this._layers);
            for (const o of a) {
              const c = this._layers[o];
              c.type !== "custom" && (e[o] = c.serialize())
            }
            return e
          }
          hasTransitions() {
            var e, a, o;
            if (!((e = this.light) === null || e === void 0) && e.hasTransition() || !((a = this.sky) === null || a === void 0) && a.hasTransition() || !((o = this.projection) === null || o === void 0) && o.hasTransition()) return !0;
            for (const c in this.tileManagers)
              if (this.tileManagers[c].hasTransition()) return !0;
            for (const c in this._layers)
              if (this._layers[c].hasTransition()) return !0;
            return !1
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.")
          }
          update(e) {
            if (!this._loaded) return;
            const a = this._changed;
            if (a) {
              const c = Object.keys(this._updatedLayers),
                d = Object.keys(this._removedLayers);
              (c.length || d.length) && this._updateWorkerLayers(c, d);
              for (const g in this._updatedSources) {
                const w = this._updatedSources[g];
                if (w === "reload") this._reloadSource(g);
                else {
                  if (w !== "clear") throw new Error(`Invalid action ${w}`);
                  this._clearSource(g)
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const g in this._updatedPaintProps) this._layers[g].updateTransitions(e);
              this.light.updateTransitions(e), this.sky.updateTransitions(e), this._resetUpdates()
            }
            const o = {};
            for (const c in this.tileManagers) {
              const d = this.tileManagers[c];
              o[c] = d.used, d.used = !1
            }
            for (const c of this._order) {
              const d = this._layers[c];
              d.recalculate(e, this._availableImages), !d.isHidden(e.zoom) && d.source && (this.tileManagers[d.source].used = !0)
            }
            for (const c in o) {
              const d = this.tileManagers[c];
              !!o[c] != !!d.used && d.fire(new s.l("data", {
                sourceDataType: "visibility",
                dataType: "source",
                sourceId: c
              }))
            }
            this.light.recalculate(e), this.sky.recalculate(e), this.projection.recalculate(e), this.z = e.zoom, a && this.fire(new s.l("data", {
              dataType: "style"
            }))
          }
          _updateTilesForChangedImages() {
            const e = Object.keys(this._changedImages);
            if (e.length) {
              for (const a in this.tileManagers) this.tileManagers[a].reloadTilesForDependencies(["icons", "patterns"], e);
              this._changedImages = {}
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const e in this.tileManagers) this.tileManagers[e].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = !1
            }
          }
          _updateWorkerLayers(e, a) {
            this.dispatcher.broadcast("UL", {
              layers: this._serializeByIds(e, !1),
              removedIds: a
            })
          }
          _resetUpdates() {
            this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1
          }
          setState(e, a = {}) {
            var o;
            this._checkLoaded();
            const c = this.serialize();
            if (e = a.transformStyle ? a.transformStyle(c, e) : e, ((o = a.validate) === null || o === void 0 || o) && vo(this, s.B(e))) return !1;
            (e = s.bO(e)).layers = s.bL(e.layers);
            const d = s.bP(c, e),
              g = this._getOperationsToPerform(d);
            if (g.unimplemented.length > 0) throw new Error(`Unimplemented: ${g.unimplemented.join(", ")}.`);
            if (g.operations.length === 0) return !1;
            for (const w of g.operations) w();
            return this.stylesheet = e, this._serializedLayers = null, !0
          }
          _getOperationsToPerform(e) {
            const a = [],
              o = [];
            for (const c of e) switch (c.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
              case "setRoll":
                continue;
              case "addLayer":
                a.push((() => this.addLayer.apply(this, c.args)));
                break;
              case "removeLayer":
                a.push((() => this.removeLayer.apply(this, c.args)));
                break;
              case "setPaintProperty":
                a.push((() => this.setPaintProperty.apply(this, c.args)));
                break;
              case "setLayoutProperty":
                a.push((() => this.setLayoutProperty.apply(this, c.args)));
                break;
              case "setFilter":
                a.push((() => this.setFilter.apply(this, c.args)));
                break;
              case "addSource":
                a.push((() => this.addSource.apply(this, c.args)));
                break;
              case "removeSource":
                a.push((() => this.removeSource.apply(this, c.args)));
                break;
              case "setLayerZoomRange":
                a.push((() => this.setLayerZoomRange.apply(this, c.args)));
                break;
              case "setLight":
                a.push((() => this.setLight.apply(this, c.args)));
                break;
              case "setGeoJSONSourceData":
                a.push((() => this.setGeoJSONSourceData.apply(this, c.args)));
                break;
              case "setGlyphs":
                a.push((() => this.setGlyphs.apply(this, c.args)));
                break;
              case "setSprite":
                a.push((() => this.setSprite.apply(this, c.args)));
                break;
              case "setTerrain":
                a.push((() => this.map.setTerrain.apply(this, c.args)));
                break;
              case "setSky":
                a.push((() => this.setSky.apply(this, c.args)));
                break;
              case "setProjection":
                this.setProjection.apply(this, c.args);
                break;
              case "setGlobalState":
                a.push((() => this.setGlobalState.apply(this, c.args)));
                break;
              case "setTransition":
                a.push((() => {}));
                break;
              default:
                o.push(c.command)
            }
            return {
              operations: a,
              unimplemented: o
            }
          }
          addImage(e, a) {
            if (this.getImage(e)) return this.fire(new s.k(new Error(`An image named "${e}" already exists.`)));
            this.imageManager.addImage(e, a), this._afterImageUpdated(e)
          }
          updateImage(e, a) {
            this.imageManager.updateImage(e, a)
          }
          getImage(e) {
            return this.imageManager.getImage(e)
          }
          removeImage(e) {
            if (!this.getImage(e)) return this.fire(new s.k(new Error(`An image named "${e}" does not exist.`)));
            this.imageManager.removeImage(e), this._afterImageUpdated(e)
          }
          _afterImageUpdated(e) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[e] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", {
              dataType: "style"
            }))
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages()
          }
          addSource(e, a, o = {}) {
            if (this._checkLoaded(), this.tileManagers[e] !== void 0) throw new Error(`Source "${e}" already exists.`);
            if (!a.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(a).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(a.type) >= 0 && this._validate(s.B.source, `sources.${e}`, a, null, o)) return;
            this.map && this.map._collectResourceTiming && (a.collectResourceTiming = !0);
            const c = this.tileManagers[e] = new Tt(e, a, this.dispatcher);
            c.style = this, c.setEventedParent(this, (() => ({
              isSourceLoaded: c.loaded(),
              source: c.serialize(),
              sourceId: e
            }))), c.onAdd(this.map), this._changed = !0
          }
          removeSource(e) {
            if (this._checkLoaded(), this.tileManagers[e] === void 0) throw new Error("There is no source with this ID");
            for (const o in this._layers)
              if (this._layers[o].source === e) return this.fire(new s.k(new Error(`Source "${e}" cannot be removed while layer "${o}" is using it.`)));
            const a = this.tileManagers[e];
            delete this.tileManagers[e], delete this._updatedSources[e], a.fire(new s.l("data", {
              sourceDataType: "metadata",
              dataType: "source",
              sourceId: e
            })), a.setEventedParent(null), a.onRemove(this.map), this._changed = !0
          }
          setGeoJSONSourceData(e, a) {
            if (this._checkLoaded(), this.tileManagers[e] === void 0) throw new Error(`There is no source with this ID=${e}`);
            const o = this.tileManagers[e].getSource();
            if (o.type !== "geojson") throw new Error(`geojsonSource.type is ${o.type}, which is !== 'geojson`);
            o.setData(a), this._changed = !0
          }
          getSource(e) {
            return this.tileManagers[e] && this.tileManagers[e].getSource()
          }
          addLayer(e, a, o = {}) {
            this._checkLoaded();
            const c = e.id;
            if (this.getLayer(c)) return void this.fire(new s.k(new Error(`Layer "${c}" already exists on this map.`)));
            let d;
            if (e.type === "custom") {
              if (vo(this, s.bQ(e))) return;
              d = s.bM(e, this._globalState)
            } else {
              if ("source" in e && typeof e.source == "object" && (this.addSource(c, e.source), e = s.bO(e), e = s.e(e, {
                  source: c
                })), this._validate(s.B.layer, `layers.${c}`, e, {
                  arrayIndex: -1
                }, o)) return;
              d = s.bM(e, this._globalState), this._validateLayer(d), d.setEventedParent(this, {
                layer: {
                  id: c
                }
              })
            }
            const g = a ? this._order.indexOf(a) : this._order.length;
            if (a && g === -1) this.fire(new s.k(new Error(`Cannot add layer "${c}" before non-existing layer "${a}".`)));
            else {
              if (this._order.splice(g, 0, c), this._layerOrderChanged = !0, this._layers[c] = d, this._removedLayers[c] && d.source && d.type !== "custom") {
                const w = this._removedLayers[c];
                delete this._removedLayers[c], w.type !== d.type ? this._updatedSources[d.source] = "clear" : (this._updatedSources[d.source] = "reload", this.tileManagers[d.source].pause())
              }
              this._updateLayer(d), d.onAdd && d.onAdd(this.map)
            }
          }
          moveLayer(e, a) {
            if (this._checkLoaded(), this._changed = !0, !this._layers[e]) return void this.fire(new s.k(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
            if (e === a) return;
            const o = this._order.indexOf(e);
            this._order.splice(o, 1);
            const c = a ? this._order.indexOf(a) : this._order.length;
            a && c === -1 ? this.fire(new s.k(new Error(`Cannot move layer "${e}" before non-existing layer "${a}".`))) : (this._order.splice(c, 0, e), this._layerOrderChanged = !0)
          }
          removeLayer(e) {
            this._checkLoaded();
            const a = this._layers[e];
            if (!a) return void this.fire(new s.k(new Error(`Cannot remove non-existing layer "${e}".`)));
            a.setEventedParent(null);
            const o = this._order.indexOf(e);
            this._order.splice(o, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e] = a, delete this._layers[e], this._serializedLayers && delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], a.onRemove && a.onRemove(this.map)
          }
          getLayer(e) {
            return this._layers[e]
          }
          getLayersOrder() {
            return [...this._order]
          }
          hasLayer(e) {
            return e in this._layers
          }
          setLayerZoomRange(e, a, o) {
            this._checkLoaded();
            const c = this.getLayer(e);
            c ? c.minzoom === a && c.maxzoom === o || (a != null && (c.minzoom = a), o != null && (c.maxzoom = o), this._updateLayer(c)) : this.fire(new s.k(new Error(`Cannot set the zoom range of non-existing layer "${e}".`)))
          }
          setFilter(e, a, o = {}) {
            this._checkLoaded();
            const c = this.getLayer(e);
            if (c) {
              if (!s.bK(c.filter, a)) return a == null ? (c.setFilter(void 0), void this._updateLayer(c)) : void(this._validate(s.B.filter, `layers.${c.id}.filter`, a, null, o) || (c.setFilter(s.bO(a)), this._updateLayer(c)))
            } else this.fire(new s.k(new Error(`Cannot filter non-existing layer "${e}".`)))
          }
          getFilter(e) {
            return s.bO(this.getLayer(e).filter)
          }
          setLayoutProperty(e, a, o, c = {}) {
            this._checkLoaded();
            const d = this.getLayer(e);
            d ? s.bK(d.getLayoutProperty(a), o) || (d.setLayoutProperty(a, o, c), this._updateLayer(d)) : this.fire(new s.k(new Error(`Cannot style non-existing layer "${e}".`)))
          }
          getLayoutProperty(e, a) {
            const o = this.getLayer(e);
            if (o) return o.getLayoutProperty(a);
            this.fire(new s.k(new Error(`Cannot get style of non-existing layer "${e}".`)))
          }
          setPaintProperty(e, a, o, c = {}) {
            this._checkLoaded();
            const d = this.getLayer(e);
            d ? s.bK(d.getPaintProperty(a), o) || this._updatePaintProperty(d, a, o, c) : this.fire(new s.k(new Error(`Cannot style non-existing layer "${e}".`)))
          }
          _updatePaintProperty(e, a, o, c = {}) {
            e.setPaintProperty(a, o, c) && this._updateLayer(e), s.bN(e) && a === "raster-fade-duration" && this.tileManagers[e.source].setRasterFadeDuration(o), this._changed = !0, this._updatedPaintProps[e.id] = !0, this._serializedLayers = null
          }
          getPaintProperty(e, a) {
            return this.getLayer(e).getPaintProperty(a)
          }
          setFeatureState(e, a) {
            this._checkLoaded();
            const o = e.source,
              c = e.sourceLayer,
              d = this.tileManagers[o];
            if (d === void 0) return void this.fire(new s.k(new Error(`The source '${o}' does not exist in the map's style.`)));
            const g = d.getSource().type;
            g === "geojson" && c ? this.fire(new s.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : g !== "vector" || c ? (e.id === void 0 && this.fire(new s.k(new Error("The feature id parameter must be provided."))), d.setFeatureState(c, e.id, a)) : this.fire(new s.k(new Error("The sourceLayer parameter must be provided for vector source types.")))
          }
          removeFeatureState(e, a) {
            this._checkLoaded();
            const o = e.source,
              c = this.tileManagers[o];
            if (c === void 0) return void this.fire(new s.k(new Error(`The source '${o}' does not exist in the map's style.`)));
            const d = c.getSource().type,
              g = d === "vector" ? e.sourceLayer : void 0;
            d !== "vector" || g ? a && typeof e.id != "string" && typeof e.id != "number" ? this.fire(new s.k(new Error("A feature id is required to remove its specific state property."))) : c.removeFeatureState(g, e.id, a) : this.fire(new s.k(new Error("The sourceLayer parameter must be provided for vector source types.")))
          }
          getFeatureState(e) {
            this._checkLoaded();
            const a = e.source,
              o = e.sourceLayer,
              c = this.tileManagers[a];
            if (c !== void 0) return c.getSource().type !== "vector" || o ? (e.id === void 0 && this.fire(new s.k(new Error("The feature id parameter must be provided."))), c.getFeatureState(o, e.id)) : void this.fire(new s.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new s.k(new Error(`The source '${a}' does not exist in the map's style.`)))
          }
          getTransition() {
            return s.e({
              duration: 300,
              delay: 0
            }, this.stylesheet && this.stylesheet.transition)
          }
          serialize() {
            if (!this._loaded) return;
            const e = s.bR(this.tileManagers, (d => d.serialize())),
              a = this._serializeByIds(this._order, !0),
              o = this.map.getTerrain() || void 0,
              c = this.stylesheet;
            return s.bS({
              version: c.version,
              name: c.name,
              metadata: c.metadata,
              light: c.light,
              sky: c.sky,
              center: c.center,
              zoom: c.zoom,
              bearing: c.bearing,
              pitch: c.pitch,
              sprite: c.sprite,
              glyphs: c.glyphs,
              transition: c.transition,
              projection: c.projection,
              sources: e,
              layers: a,
              terrain: o
            }, (d => d !== void 0))
          }
          _updateLayer(e) {
            this._updatedLayers[e.id] = !0, e.source && !this._updatedSources[e.source] && this.tileManagers[e.source].getSource().type !== "raster" && (this._updatedSources[e.source] = "reload", this.tileManagers[e.source].pause()), this._serializedLayers = null, this._changed = !0
          }
          _flattenAndSortRenderedFeatures(e) {
            const a = g => this._layers[g].type === "fill-extrusion",
              o = {},
              c = [];
            for (let g = this._order.length - 1; g >= 0; g--) {
              const w = this._order[g];
              if (a(w)) {
                o[w] = g;
                for (const S of e) {
                  const A = S[w];
                  if (A)
                    for (const E of A) c.push(E)
                }
              }
            }
            c.sort(((g, w) => w.intersectionZ - g.intersectionZ));
            const d = [];
            for (let g = this._order.length - 1; g >= 0; g--) {
              const w = this._order[g];
              if (a(w))
                for (let S = c.length - 1; S >= 0; S--) {
                  const A = c[S].feature;
                  if (o[A.layer.id] < g) break;
                  d.push(A), c.pop()
                } else
                  for (const S of e) {
                    const A = S[w];
                    if (A)
                      for (const E of A) d.push(E.feature)
                  }
            }
            return d
          }
          queryRenderedFeatures(e, a, o) {
            a && a.filter && this._validate(s.B.filter, "queryRenderedFeatures.filter", a.filter, null, a);
            const c = {};
            if (a && a.layers) {
              if (!(Array.isArray(a.layers) || a.layers instanceof Set)) return this.fire(new s.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
              for (const A of a.layers) {
                const E = this._layers[A];
                if (!E) return this.fire(new s.k(new Error(`The layer '${A}' does not exist in the map's style and cannot be queried for features.`))), [];
                c[E.source] = !0
              }
            }
            const d = [];
            a.availableImages = this._availableImages;
            const g = this._serializedAllLayers(),
              w = a.layers instanceof Set ? a.layers : Array.isArray(a.layers) ? new Set(a.layers) : null,
              S = Object.assign(Object.assign({}, a), {
                layers: w,
                globalState: this._globalState
              });
            for (const A in this.tileManagers) a.layers && !c[A] || d.push(Ot(this.tileManagers[A], this._layers, g, e, S, o, this.map.terrain ? (E, F, R) => this.map.terrain.getElevation(E, F, R) : void 0));
            return this.placement && d.push((function(A, E, F, R, U, Y, se) {
              const le = {},
                ce = Y.queryRenderedSymbols(R),
                ge = [];
              for (const Pe of Object.keys(ce).map(Number)) ge.push(se[Pe]);
              ge.sort(mr);
              for (const Pe of ge) {
                const fe = Pe.featureIndex.lookupSymbolFeatures(ce[Pe.bucketInstanceId], E, Pe.bucketIndex, Pe.sourceLayerIndex, {
                  filterSpec: U.filter,
                  globalState: U.globalState
                }, U.layers, U.availableImages, A);
                for (const Me in fe) {
                  const Ee = le[Me] = le[Me] || [],
                    ve = fe[Me];
                  ve.sort(((Oe, lt) => {
                    const it = Pe.featureSortOrder;
                    if (it) {
                      const st = it.indexOf(Oe.featureIndex);
                      return it.indexOf(lt.featureIndex) - st
                    }
                    return lt.featureIndex - Oe.featureIndex
                  }));
                  for (const Oe of ve) Ee.push(Oe)
                }
              }
              return (function(Pe, fe, Me) {
                for (const Ee in Pe)
                  for (const ve of Pe[Ee]) At(ve, Me[fe[Ee].source]);
                return Pe
              })(le, A, F)
            })(this._layers, g, this.tileManagers, e, S, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(d)
          }
          querySourceFeatures(e, a) {
            a != null && a.filter && this._validate(s.B.filter, "querySourceFeatures.filter", a.filter, null, a);
            const o = this.tileManagers[e];
            return o ? (function(c, d) {
              const g = c.getRenderableIds().map((A => c.getTileByID(A))),
                w = [],
                S = {};
              for (let A = 0; A < g.length; A++) {
                const E = g[A],
                  F = E.tileID.canonical.key;
                S[F] || (S[F] = !0, E.querySourceFeatures(w, d))
              }
              return w
            })(o, a ? Object.assign(Object.assign({}, a), {
              globalState: this._globalState
            }) : {
              globalState: this._globalState
            }) : []
          }
          getLight() {
            return this.light.getLight()
          }
          setLight(e, a = {}) {
            this._checkLoaded();
            const o = this.light.getLight();
            let c = !1;
            for (const g in e)
              if (!s.bK(e[g], o[g])) {
                c = !0;
                break
              } if (!c) return;
            const d = {
              now: _e(),
              transition: s.e({
                duration: 300,
                delay: 0
              }, this.stylesheet.transition)
            };
            this.light.setLight(e, a), this.light.updateTransitions(d)
          }
          getProjection() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.projection
          }
          setProjection(e) {
            if (this._checkLoaded(), this.projection) {
              if (this.projection.name === e.type) return;
              this.projection.destroy(), delete this.projection
            }
            this.stylesheet.projection = e, this._setProjectionInternal(e.type)
          }
          getSky() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.sky
          }
          setSky(e, a = {}) {
            this._checkLoaded();
            const o = this.getSky();
            let c = !1;
            if (!e && !o) return;
            if (e && !o) c = !0;
            else if (!e && o) c = !0;
            else
              for (const g in e)
                if (!s.bK(e[g], o[g])) {
                  c = !0;
                  break
                } if (!c) return;
            const d = {
              now: _e(),
              transition: s.e({
                duration: 300,
                delay: 0
              }, this.stylesheet.transition)
            };
            this.stylesheet.sky = e, this.sky.setSky(e, a), this.sky.updateTransitions(d)
          }
          _setProjectionInternal(e) {
            const a = (function(o, c) {
              const d = {
                constrain: c
              };
              if (Array.isArray(o)) {
                const g = new ua({
                  type: o
                });
                return {
                  projection: g,
                  transform: new Tl(d),
                  cameraHelper: new Vo(g)
                }
              }
              switch (o) {
                case "mercator":
                  return {
                    projection: new Pi, transform: new Sa(d), cameraHelper: new ja
                  };
                case "globe": {
                  const g = new ua({
                    type: ["interpolate", ["linear"],
                      ["zoom"], 11, "vertical-perspective", 12, "mercator"
                    ]
                  });
                  return {
                    projection: g,
                    transform: new Tl(d),
                    cameraHelper: new Vo(g)
                  }
                }
                case "vertical-perspective":
                  return {
                    projection: new qn, transform: new wl(d), cameraHelper: new Zn
                  };
                default:
                  return s.w(`Unknown projection name: ${o}. Falling back to mercator projection.`), {
                    projection: new Pi,
                    transform: new Sa(d),
                    cameraHelper: new ja
                  }
              }
            })(e, this.map.transformConstrain);
            this.projection = a.projection, this.map.migrateProjection(a.transform, a.cameraHelper);
            for (const o in this.tileManagers) this.tileManagers[o].reload()
          }
          _validate(e, a, o, c, d = {}) {
            return (!d || d.validate !== !1) && vo(this, e.call(s.B, s.e({
              key: a,
              style: this.serialize(),
              value: o,
              styleSpec: s.t
            }, c)))
          }
          _remove(e = !0) {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), V().off(sr, this._rtlPluginLoaded);
            for (const a in this._layers) this._layers[a].setEventedParent(null);
            for (const a in this.tileManagers) {
              const o = this.tileManagers[a];
              o.setEventedParent(null), o.onRemove(this.map)
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), e && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e)
          }
          _clearSource(e) {
            this.tileManagers[e].clearTiles()
          }
          _reloadSource(e) {
            this.tileManagers[e].resume(), this.tileManagers[e].reload()
          }
          _updateSources(e) {
            for (const a in this.tileManagers) this.tileManagers[a].update(e, this.map.terrain)
          }
          _generateCollisionBoxes() {
            for (const e in this.tileManagers) this._reloadSource(e)
          }
          _updatePlacement(e, a, o, c, d = !1) {
            let g = !1,
              w = !1;
            const S = {};
            for (const A of this._order) {
              const E = this._layers[A];
              if (E.type !== "symbol") continue;
              if (!S[E.source]) {
                const R = this.tileManagers[E.source];
                S[E.source] = R.getRenderableIds(!0).map((U => R.getTileByID(U))).sort(((U, Y) => Y.tileID.overscaledZ - U.tileID.overscaledZ || (U.tileID.isLessThan(Y.tileID) ? -1 : 1)))
              }
              const F = this.crossTileSymbolIndex.addLayer(E, S[E.source], e.center.lng);
              g = g || F
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((d = d || this._layerOrderChanged || o === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(_e(), e.zoom)) && (this.pauseablePlacement = new La(e, this.map.terrain, this._order, d, a, o, c, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, S), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(_e()), w = !0), g && this.pauseablePlacement.placement.setStale()), w || g)
              for (const A of this._order) {
                const E = this._layers[A];
                E.type === "symbol" && this.placement.updateLayerOpacities(E, S[E.source])
              }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(_e())
          }
          _releaseSymbolFadeTiles() {
            for (const e in this.tileManagers) this.tileManagers[e].releaseSymbolFadeTiles()
          }
          getImages(e, a) {
            return s._(this, void 0, void 0, (function*() {
              const o = yield this.imageManager.getImages(a.icons);
              this._updateTilesForChangedImages();
              const c = this.tileManagers[a.source];
              return c && c.setDependencies(a.tileID.key, a.type, a.icons), o
            }))
          }
          getGlyphs(e, a) {
            return s._(this, void 0, void 0, (function*() {
              const o = yield this.glyphManager.getGlyphs(a.stacks), c = this.tileManagers[a.source];
              return c && c.setDependencies(a.tileID.key, a.type, [""]), o
            }))
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null
          }
          setGlyphs(e, a = {}) {
            this._checkLoaded(), e && this._validate(s.B.glyphs, "glyphs", e, null, a) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = e, this.glyphManager.entries = {}, this.glyphManager.setURL(e))
          }
          getDashes(e, a) {
            return s._(this, void 0, void 0, (function*() {
              const o = {};
              for (const [c, d] of Object.entries(a.dashes)) o[c] = this.lineAtlas.getDash(d.dasharray, d.round);
              return o
            }))
          }
          addSprite(e, a, o = {}, c) {
            this._checkLoaded();
            const d = [{
                id: e,
                url: a
              }],
              g = [...De(this.stylesheet.sprite), ...d];
            this._validate(s.B.sprite, "sprite", g, null, o) || (this.stylesheet.sprite = g, this._loadSprite(d, !0, c))
          }
          removeSprite(e) {
            this._checkLoaded();
            const a = De(this.stylesheet.sprite);
            if (a.find((o => o.id === e))) {
              if (this._spritesImagesIds[e])
                for (const o of this._spritesImagesIds[e]) this.imageManager.removeImage(o), this._changedImages[o] = !0;
              a.splice(a.findIndex((o => o.id === e)), 1), this.stylesheet.sprite = a.length > 0 ? a : void 0, delete this._spritesImagesIds[e], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", {
                dataType: "style"
              }))
            } else this.fire(new s.k(new Error(`Sprite "${e}" doesn't exists on this map.`)))
          }
          getSprite() {
            return De(this.stylesheet.sprite)
          }
          setSprite(e, a = {}, o) {
            this._checkLoaded(), e && this._validate(s.B.sprite, "sprite", e, null, a) || (this.stylesheet.sprite = e, e ? this._loadSprite(e, !0, o) : (this._unloadSprite(), o && o(null)))
          }
        }
        var Oc = s.aN([{
          name: "a_pos",
          type: "Int16",
          components: 2
        }, {
          name: "a_texture_pos",
          type: "Int16",
          components: 2
        }]);
        class ts {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null
          }
          bind(e, a, o, c, d, g, w, S, A) {
            this.context = e;
            let E = this.boundPaintVertexBuffers.length !== c.length;
            for (let F = 0; !E && F < c.length; F++) this.boundPaintVertexBuffers[F] !== c[F] && (E = !0);
            !this.vao || this.boundProgram !== a || this.boundLayoutVertexBuffer !== o || E || this.boundIndexBuffer !== d || this.boundVertexOffset !== g || this.boundDynamicVertexBuffer !== w || this.boundDynamicVertexBuffer2 !== S || this.boundDynamicVertexBuffer3 !== A ? this.freshBind(a, o, c, d, g, w, S, A) : (e.bindVertexArray.set(this.vao), w && w.bind(), d && d.dynamicDraw && d.bind(), S && S.bind(), A && A.bind())
          }
          freshBind(e, a, o, c, d, g, w, S) {
            const A = e.numAttributes,
              E = this.context,
              F = E.gl;
            this.vao && this.destroy(), this.vao = E.createVertexArray(), E.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = a, this.boundPaintVertexBuffers = o, this.boundIndexBuffer = c, this.boundVertexOffset = d, this.boundDynamicVertexBuffer = g, this.boundDynamicVertexBuffer2 = w, this.boundDynamicVertexBuffer3 = S, a.enableAttributes(F, e);
            for (const R of o) R.enableAttributes(F, e);
            g && g.enableAttributes(F, e), w && w.enableAttributes(F, e), S && S.enableAttributes(F, e), a.bind(), a.setVertexAttribPointers(F, e, d);
            for (const R of o) R.bind(), R.setVertexAttribPointers(F, e, d);
            g && (g.bind(), g.setVertexAttribPointers(F, e, d)), c && c.bind(), w && (w.bind(), w.setVertexAttribPointers(F, e, d)), S && (S.bind(), S.setVertexAttribPointers(F, e, d)), E.currentNumAttributes = A
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null)
          }
        }
        const Bp = (h, e, a, o, c) => ({
            u_texture: 0,
            u_ele_delta: h,
            u_fog_matrix: e,
            u_fog_color: a ? a.properties.get("fog-color") : s.bi.white,
            u_fog_ground_blend: a ? a.properties.get("fog-ground-blend") : 1,
            u_fog_ground_blend_opacity: c ? 0 : a ? a.calculateFogBlendOpacity(o) : 0,
            u_horizon_color: a ? a.properties.get("horizon-color") : s.bi.white,
            u_horizon_fog_blend: a ? a.properties.get("horizon-fog-blend") : 1,
            u_is_globe_mode: c ? 1 : 0
          }),
          jc = {
            mainMatrix: "u_projection_matrix",
            tileMercatorCoords: "u_projection_tile_mercator_coords",
            clippingPlane: "u_projection_clipping_plane",
            projectionTransition: "u_projection_transition",
            fallbackMatrix: "u_projection_fallback_matrix"
          };

        function Ts(h) {
          const e = [];
          for (let a = 0; a < h.length; a++) {
            if (h[a] === null) continue;
            const o = h[a].split(" ");
            e.push(o.pop())
          }
          return e
        }
        class No {
          constructor(e, a, o, c, d, g, w, S, A = []) {
            const E = e.gl;
            this.program = E.createProgram();
            const F = Ts(a.staticAttributes),
              R = o ? o.getBinderAttributes() : [],
              U = F.concat(R),
              Y = Ir.prelude.staticUniforms ? Ts(Ir.prelude.staticUniforms) : [],
              se = w.staticUniforms ? Ts(w.staticUniforms) : [],
              le = a.staticUniforms ? Ts(a.staticUniforms) : [],
              ce = o ? o.getBinderUniforms() : [],
              ge = Y.concat(se).concat(le).concat(ce),
              Pe = [];
            for (const it of ge) Pe.indexOf(it) < 0 && Pe.push(it);
            const fe = o ? o.defines() : [];
            qa(E) && fe.unshift("#version 300 es"), d && fe.push("#define OVERDRAW_INSPECTOR;"), g && fe.push("#define TERRAIN3D;"), S && fe.push(S), A && fe.push(...A);
            let Me = fe.concat(Ir.prelude.fragmentSource, w.fragmentSource, a.fragmentSource).join(`
`),
              Ee = fe.concat(Ir.prelude.vertexSource, w.vertexSource, a.vertexSource).join(`
`);
            qa(E) || (Me = (function(it) {
              return it.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(")
            })(Me), Ee = (function(it) {
              return it.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(")
            })(Ee));
            const ve = E.createShader(E.FRAGMENT_SHADER);
            if (E.isContextLost()) return void(this.failedToCreate = !0);
            if (E.shaderSource(ve, Me), E.compileShader(ve), !E.getShaderParameter(ve, E.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${E.getShaderInfoLog(ve)}`);
            E.attachShader(this.program, ve);
            const Oe = E.createShader(E.VERTEX_SHADER);
            if (E.isContextLost()) return void(this.failedToCreate = !0);
            if (E.shaderSource(Oe, Ee), E.compileShader(Oe), !E.getShaderParameter(Oe, E.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${E.getShaderInfoLog(Oe)}`);
            E.attachShader(this.program, Oe), this.attributes = {};
            const lt = {};
            this.numAttributes = U.length;
            for (let it = 0; it < this.numAttributes; it++) U[it] && (E.bindAttribLocation(this.program, it, U[it]), this.attributes[U[it]] = it);
            if (E.linkProgram(this.program), !E.getProgramParameter(this.program, E.LINK_STATUS)) throw new Error(`Program failed to link: ${E.getProgramInfoLog(this.program)}`);
            E.deleteShader(Oe), E.deleteShader(ve);
            for (let it = 0; it < Pe.length; it++) {
              const st = Pe[it];
              if (st && !lt[st]) {
                const ct = E.getUniformLocation(this.program, st);
                ct && (lt[st] = ct)
              }
            }
            this.fixedUniforms = c(e, lt), this.terrainUniforms = ((it, st) => ({
              u_depth: new s.bT(it, st.u_depth),
              u_terrain: new s.bT(it, st.u_terrain),
              u_terrain_dim: new s.bj(it, st.u_terrain_dim),
              u_terrain_matrix: new s.bV(it, st.u_terrain_matrix),
              u_terrain_unpack: new s.bW(it, st.u_terrain_unpack),
              u_terrain_exaggeration: new s.bj(it, st.u_terrain_exaggeration)
            }))(e, lt), this.projectionUniforms = ((it, st) => ({
              u_projection_matrix: new s.bV(it, st.u_projection_matrix),
              u_projection_tile_mercator_coords: new s.bW(it, st.u_projection_tile_mercator_coords),
              u_projection_clipping_plane: new s.bW(it, st.u_projection_clipping_plane),
              u_projection_transition: new s.bj(it, st.u_projection_transition),
              u_projection_fallback_matrix: new s.bV(it, st.u_projection_fallback_matrix)
            }))(e, lt), this.binderUniforms = o ? o.getUniforms(e, lt) : []
          }
          draw(e, a, o, c, d, g, w, S, A, E, F, R, U, Y, se, le, ce, ge, Pe) {
            const fe = e.gl;
            if (this.failedToCreate) return;
            if (e.program.set(this.program), e.setDepthMode(o), e.setStencilMode(c), e.setColorMode(d), e.setCullFace(g), S) {
              e.activeTexture.set(fe.TEXTURE2), fe.bindTexture(fe.TEXTURE_2D, S.depthTexture), e.activeTexture.set(fe.TEXTURE3), fe.bindTexture(fe.TEXTURE_2D, S.texture);
              for (const Ee in this.terrainUniforms) this.terrainUniforms[Ee].set(S[Ee])
            }
            if (A)
              for (const Ee in A) this.projectionUniforms[jc[Ee]].set(A[Ee]);
            if (w)
              for (const Ee in this.fixedUniforms) this.fixedUniforms[Ee].set(w[Ee]);
            le && le.setUniforms(e, this.binderUniforms, Y, {
              zoom: se
            });
            let Me = 0;
            switch (a) {
              case fe.LINES:
                Me = 2;
                break;
              case fe.TRIANGLES:
                Me = 3;
                break;
              case fe.LINE_STRIP:
                Me = 1
            }
            for (const Ee of U.get()) {
              const ve = Ee.vaos || (Ee.vaos = {});
              (ve[E] || (ve[E] = new ts)).bind(e, this, F, le ? le.getPaintVertexBuffers() : [], R, Ee.vertexOffset, ce, ge, Pe), fe.drawElements(a, Ee.primitiveLength * Me, fe.UNSIGNED_SHORT, Ee.primitiveOffset * Me * 2)
            }
          }
        }

        function Rh(h, e, a) {
          const o = 1 / s.aG(a, 1, e.transform.tileZoom),
            c = Math.pow(2, a.tileID.overscaledZ),
            d = a.tileSize * Math.pow(2, e.transform.tileZoom) / c,
            g = d * (a.tileID.canonical.x + a.tileID.wrap * c),
            w = d * a.tileID.canonical.y;
          return {
            u_image: 0,
            u_texsize: a.imageAtlasTexture.size,
            u_scale: [o, h.fromScale, h.toScale],
            u_fade: h.t,
            u_pixel_coord_upper: [g >> 16, w >> 16],
            u_pixel_coord_lower: [65535 & g, 65535 & w]
          }
        }
        const Uo = (h, e, a, o) => {
            const c = h.style.light,
              d = c.properties.get("position"),
              g = [d.x, d.y, d.z],
              w = s.bZ();
            c.properties.get("anchor") === "viewport" && s.b_(w, h.transform.bearingInRadians), s.b$(g, g, w);
            const S = h.transform.transformLightDirection(g),
              A = c.properties.get("color");
            return {
              u_lightpos: g,
              u_lightpos_globe: S,
              u_lightintensity: c.properties.get("intensity"),
              u_lightcolor: [A.r, A.g, A.b],
              u_vertical_gradient: +e,
              u_opacity: a,
              u_fill_translate: o
            }
          },
          Op = (h, e, a, o, c, d, g) => s.e(Uo(h, e, a, o), Rh(d, h, g), {
            u_height_factor: -Math.pow(2, c.overscaledZ) / g.tileSize / 8
          }),
          Os = (h, e, a, o) => s.e(Rh(e, h, a), {
            u_fill_translate: o
          }),
          jp = (h, e) => ({
            u_world: h,
            u_fill_translate: e
          }),
          Fh = (h, e, a, o, c) => s.e(Os(h, e, a, c), {
            u_world: o
          }),
          qp = (h, e, a, o, c) => {
            const d = h.transform;
            let g, w, S = 0;
            if (a.paint.get("circle-pitch-alignment") === "map") {
              const A = s.aG(e, 1, d.zoom);
              g = !0, w = [A, A], S = A / (s.a3 * Math.pow(2, e.tileID.overscaledZ)) * 2 * Math.PI * c
            } else g = !1, w = d.pixelsToGLUnits;
            return {
              u_camera_to_center_distance: d.cameraToCenterDistance,
              u_scale_with_map: +(a.paint.get("circle-pitch-scale") === "map"),
              u_pitch_with_map: +g,
              u_device_pixel_ratio: h.pixelRatio,
              u_extrude_scale: w,
              u_globe_extrude_scale: S,
              u_translate: o
            }
          },
          Bh = h => ({
            u_pixel_extrude_scale: [1 / h.width, 1 / h.height]
          }),
          qc = h => ({
            u_viewport_size: [h.width, h.height]
          }),
          Vc = (h, e = 1) => ({
            u_color: h,
            u_overlay: 0,
            u_overlay_scale: e
          }),
          Zc = (h, e, a, o) => {
            const c = s.aG(h, 1, e) / (s.a3 * Math.pow(2, h.tileID.overscaledZ)) * 2 * Math.PI * o;
            return {
              u_extrude_scale: s.aG(h, 1, e),
              u_intensity: a,
              u_globe_extrude_scale: c
            }
          },
          Nc = (h, e, a, o) => {
            const c = s.M();
            s.c0(c, 0, h.width, h.height, 0, 0, 1);
            const d = h.context.gl;
            return {
              u_matrix: c,
              u_world: [d.drawingBufferWidth, d.drawingBufferHeight],
              u_image: a,
              u_color_ramp: o,
              u_opacity: e.paint.get("heatmap-opacity")
            }
          },
          Oh = (h, e, a) => {
            const o = a.paint.get("hillshade-accent-color");
            let c;
            switch (a.paint.get("hillshade-method")) {
              case "basic":
                c = 4;
                break;
              case "combined":
                c = 1;
                break;
              case "igor":
                c = 2;
                break;
              case "multidirectional":
                c = 3;
                break;
              default:
                c = 0
            }
            const d = a.getIlluminationProperties();
            for (let g = 0; g < d.directionRadians.length; g++) a.paint.get("hillshade-illumination-anchor") === "viewport" && (d.directionRadians[g] += h.transform.bearingInRadians);
            return {
              u_image: 0,
              u_latrange: jh(0, e.tileID),
              u_exaggeration: a.paint.get("hillshade-exaggeration"),
              u_altitudes: d.altitudeRadians,
              u_azimuths: d.directionRadians,
              u_accent: o,
              u_method: c,
              u_highlights: d.highlightColor,
              u_shadows: d.shadowColor
            }
          },
          js = (h, e) => {
            const a = e.stride,
              o = s.M();
            return s.c0(o, 0, s.a3, -s.a3, 0, 0, 1), s.N(o, o, [0, -s.a3, 0]), {
              u_matrix: o,
              u_image: 1,
              u_dimension: [a, a],
              u_zoom: h.overscaledZ,
              u_unpack: e.getUnpackVector()
            }
          };

        function jh(h, e) {
          const a = Math.pow(2, e.canonical.z),
            o = e.canonical.y;
          return [new s.a5(0, o / a).toLngLat().lat, new s.a5(0, (o + 1) / a).toLngLat().lat]
        }
        const qh = (h, e, a = 0) => ({
            u_image: 0,
            u_unpack: e.getUnpackVector(),
            u_dimension: [e.stride, e.stride],
            u_elevation_stops: 1,
            u_color_stops: 4,
            u_color_ramp_size: a,
            u_opacity: h.paint.get("color-relief-opacity")
          }),
          Ss = (h, e, a, o) => {
            const c = h.transform;
            return {
              u_translation: Uc(h, e, a),
              u_ratio: o / s.aG(e, 1, c.zoom),
              u_device_pixel_ratio: h.pixelRatio,
              u_units_to_pixels: [1 / c.pixelsToGLUnits[0], 1 / c.pixelsToGLUnits[1]]
            }
          },
          Vp = (h, e, a, o, c) => s.e(Ss(h, e, a, o), {
            u_image: 0,
            u_image_height: c
          }),
          Pl = (h, e, a, o, c) => {
            const d = h.transform,
              g = Ml(e, d);
            return {
              u_translation: Uc(h, e, a),
              u_texsize: e.imageAtlasTexture.size,
              u_ratio: o / s.aG(e, 1, d.zoom),
              u_device_pixel_ratio: h.pixelRatio,
              u_image: 0,
              u_scale: [g, c.fromScale, c.toScale],
              u_fade: c.t,
              u_units_to_pixels: [1 / d.pixelsToGLUnits[0], 1 / d.pixelsToGLUnits[1]]
            }
          },
          Zp = (h, e, a, o, c) => {
            const d = Ml(e, h.transform);
            return s.e(Ss(h, e, a, o), {
              u_tileratio: d,
              u_crossfade_from: c.fromScale,
              u_crossfade_to: c.toScale,
              u_image: 0,
              u_mix: c.t,
              u_lineatlas_width: h.lineAtlas.width,
              u_lineatlas_height: h.lineAtlas.height
            })
          },
          Np = (h, e, a, o, c, d) => {
            const g = Ml(e, h.transform);
            return s.e(Ss(h, e, a, o), {
              u_image: 0,
              u_image_height: d,
              u_tileratio: g,
              u_crossfade_from: c.fromScale,
              u_crossfade_to: c.toScale,
              u_image_dash: 1,
              u_mix: c.t,
              u_lineatlas_width: h.lineAtlas.width,
              u_lineatlas_height: h.lineAtlas.height
            })
          };

        function Ml(h, e) {
          return 1 / s.aG(h, 1, e.tileZoom)
        }

        function Uc(h, e, a) {
          return s.aH(h.transform, e, a.paint.get("line-translate"), a.paint.get("line-translate-anchor"))
        }
        const Vh = (h, e, a, o, c) => {
          return {
            u_tl_parent: h,
            u_scale_parent: e,
            u_buffer_scale: 1,
            u_fade_t: a.mix,
            u_opacity: a.opacity * o.paint.get("raster-opacity"),
            u_image0: 0,
            u_image1: 1,
            u_brightness_low: o.paint.get("raster-brightness-min"),
            u_brightness_high: o.paint.get("raster-brightness-max"),
            u_saturation_factor: (g = o.paint.get("raster-saturation"), g > 0 ? 1 - 1 / (1.001 - g) : -g),
            u_contrast_factor: (d = o.paint.get("raster-contrast"), d > 0 ? 1 / (1 - d) : 1 + d),
            u_spin_weights: Gc(o.paint.get("raster-hue-rotate")),
            u_coords_top: [c[0].x, c[0].y, c[1].x, c[1].y],
            u_coords_bottom: [c[3].x, c[3].y, c[2].x, c[2].y]
          };
          var d, g
        };

        function Gc(h) {
          h *= Math.PI / 180;
          const e = Math.sin(h),
            a = Math.cos(h);
          return [(2 * a + 1) / 3, (-Math.sqrt(3) * e - a + 1) / 3, (Math.sqrt(3) * e - a + 1) / 3]
        }
        const Wc = (h, e, a, o, c, d, g, w, S, A, E, F, R) => {
            const U = g.transform;
            return {
              u_is_size_zoom_constant: +(h === "constant" || h === "source"),
              u_is_size_feature_constant: +(h === "constant" || h === "camera"),
              u_size_t: e ? e.uSizeT : 0,
              u_size: e ? e.uSize : 0,
              u_camera_to_center_distance: U.cameraToCenterDistance,
              u_pitch: U.pitch / 360 * 2 * Math.PI,
              u_rotate_symbol: +a,
              u_aspect_ratio: U.width / U.height,
              u_fade_change: g.options.fadeDuration ? g.symbolFadeChange : 1,
              u_label_plane_matrix: w,
              u_coord_matrix: S,
              u_is_text: +E,
              u_pitch_with_map: +o,
              u_is_along_line: c,
              u_is_variable_anchor: d,
              u_texsize: F,
              u_texture: 0,
              u_translation: A,
              u_pitched_scale: R
            }
          },
          Go = (h, e, a, o, c, d, g, w, S, A, E, F, R, U) => {
            const Y = g.transform;
            return s.e(Wc(h, e, a, o, c, d, g, w, S, A, E, F, U), {
              u_gamma_scale: o ? Math.cos(Y.pitch * Math.PI / 180) * Y.cameraToCenterDistance : 1,
              u_device_pixel_ratio: g.pixelRatio,
              u_is_halo: 1
            })
          },
          os = (h, e, a, o, c, d, g, w, S, A, E, F, R) => s.e(Go(h, e, a, o, c, d, g, w, S, A, !0, E, 0, R), {
            u_texsize_icon: F,
            u_texture_icon: 1
          }),
          Hc = (h, e) => ({
            u_opacity: h,
            u_color: e
          }),
          $c = (h, e, a, o, c) => s.e((function(d, g, w, S) {
            const A = w.imageManager.getPattern(d.from.toString()),
              E = w.imageManager.getPattern(d.to.toString()),
              {
                width: F,
                height: R
              } = w.imageManager.getPixelSize(),
              U = Math.pow(2, S.tileID.overscaledZ),
              Y = S.tileSize * Math.pow(2, w.transform.tileZoom) / U,
              se = Y * (S.tileID.canonical.x + S.tileID.wrap * U),
              le = Y * S.tileID.canonical.y;
            return {
              u_image: 0,
              u_pattern_tl_a: A.tl,
              u_pattern_br_a: A.br,
              u_pattern_tl_b: E.tl,
              u_pattern_br_b: E.br,
              u_texsize: [F, R],
              u_mix: g.t,
              u_pattern_size_a: A.displaySize,
              u_pattern_size_b: E.displaySize,
              u_scale_a: g.fromScale,
              u_scale_b: g.toScale,
              u_tile_units_to_pixels: 1 / s.aG(S, 1, w.transform.tileZoom),
              u_pixel_coord_upper: [se >> 16, le >> 16],
              u_pixel_coord_lower: [65535 & se, 65535 & le]
            }
          })(a, c, e, o), {
            u_opacity: h
          }),
          Il = (h, e) => {},
          Zh = {
            fillExtrusion: (h, e) => ({
              u_lightpos: new s.bX(h, e.u_lightpos),
              u_lightpos_globe: new s.bX(h, e.u_lightpos_globe),
              u_lightintensity: new s.bj(h, e.u_lightintensity),
              u_lightcolor: new s.bX(h, e.u_lightcolor),
              u_vertical_gradient: new s.bj(h, e.u_vertical_gradient),
              u_opacity: new s.bj(h, e.u_opacity),
              u_fill_translate: new s.bY(h, e.u_fill_translate)
            }),
            fillExtrusionPattern: (h, e) => ({
              u_lightpos: new s.bX(h, e.u_lightpos),
              u_lightpos_globe: new s.bX(h, e.u_lightpos_globe),
              u_lightintensity: new s.bj(h, e.u_lightintensity),
              u_lightcolor: new s.bX(h, e.u_lightcolor),
              u_vertical_gradient: new s.bj(h, e.u_vertical_gradient),
              u_height_factor: new s.bj(h, e.u_height_factor),
              u_opacity: new s.bj(h, e.u_opacity),
              u_fill_translate: new s.bY(h, e.u_fill_translate),
              u_image: new s.bT(h, e.u_image),
              u_texsize: new s.bY(h, e.u_texsize),
              u_pixel_coord_upper: new s.bY(h, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new s.bY(h, e.u_pixel_coord_lower),
              u_scale: new s.bX(h, e.u_scale),
              u_fade: new s.bj(h, e.u_fade)
            }),
            fill: (h, e) => ({
              u_fill_translate: new s.bY(h, e.u_fill_translate)
            }),
            fillPattern: (h, e) => ({
              u_image: new s.bT(h, e.u_image),
              u_texsize: new s.bY(h, e.u_texsize),
              u_pixel_coord_upper: new s.bY(h, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new s.bY(h, e.u_pixel_coord_lower),
              u_scale: new s.bX(h, e.u_scale),
              u_fade: new s.bj(h, e.u_fade),
              u_fill_translate: new s.bY(h, e.u_fill_translate)
            }),
            fillOutline: (h, e) => ({
              u_world: new s.bY(h, e.u_world),
              u_fill_translate: new s.bY(h, e.u_fill_translate)
            }),
            fillOutlinePattern: (h, e) => ({
              u_world: new s.bY(h, e.u_world),
              u_image: new s.bT(h, e.u_image),
              u_texsize: new s.bY(h, e.u_texsize),
              u_pixel_coord_upper: new s.bY(h, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new s.bY(h, e.u_pixel_coord_lower),
              u_scale: new s.bX(h, e.u_scale),
              u_fade: new s.bj(h, e.u_fade),
              u_fill_translate: new s.bY(h, e.u_fill_translate)
            }),
            circle: (h, e) => ({
              u_camera_to_center_distance: new s.bj(h, e.u_camera_to_center_distance),
              u_scale_with_map: new s.bT(h, e.u_scale_with_map),
              u_pitch_with_map: new s.bT(h, e.u_pitch_with_map),
              u_extrude_scale: new s.bY(h, e.u_extrude_scale),
              u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
              u_globe_extrude_scale: new s.bj(h, e.u_globe_extrude_scale),
              u_translate: new s.bY(h, e.u_translate)
            }),
            collisionBox: (h, e) => ({
              u_pixel_extrude_scale: new s.bY(h, e.u_pixel_extrude_scale)
            }),
            collisionCircle: (h, e) => ({
              u_viewport_size: new s.bY(h, e.u_viewport_size)
            }),
            debug: (h, e) => ({
              u_color: new s.bU(h, e.u_color),
              u_overlay: new s.bT(h, e.u_overlay),
              u_overlay_scale: new s.bj(h, e.u_overlay_scale)
            }),
            depth: Il,
            clippingMask: Il,
            heatmap: (h, e) => ({
              u_extrude_scale: new s.bj(h, e.u_extrude_scale),
              u_intensity: new s.bj(h, e.u_intensity),
              u_globe_extrude_scale: new s.bj(h, e.u_globe_extrude_scale)
            }),
            heatmapTexture: (h, e) => ({
              u_matrix: new s.bV(h, e.u_matrix),
              u_world: new s.bY(h, e.u_world),
              u_image: new s.bT(h, e.u_image),
              u_color_ramp: new s.bT(h, e.u_color_ramp),
              u_opacity: new s.bj(h, e.u_opacity)
            }),
            hillshade: (h, e) => ({
              u_image: new s.bT(h, e.u_image),
              u_latrange: new s.bY(h, e.u_latrange),
              u_exaggeration: new s.bj(h, e.u_exaggeration),
              u_altitudes: new s.c2(h, e.u_altitudes),
              u_azimuths: new s.c2(h, e.u_azimuths),
              u_accent: new s.bU(h, e.u_accent),
              u_method: new s.bT(h, e.u_method),
              u_shadows: new s.c1(h, e.u_shadows),
              u_highlights: new s.c1(h, e.u_highlights)
            }),
            hillshadePrepare: (h, e) => ({
              u_matrix: new s.bV(h, e.u_matrix),
              u_image: new s.bT(h, e.u_image),
              u_dimension: new s.bY(h, e.u_dimension),
              u_zoom: new s.bj(h, e.u_zoom),
              u_unpack: new s.bW(h, e.u_unpack)
            }),
            colorRelief: (h, e) => ({
              u_image: new s.bT(h, e.u_image),
              u_unpack: new s.bW(h, e.u_unpack),
              u_dimension: new s.bY(h, e.u_dimension),
              u_elevation_stops: new s.bT(h, e.u_elevation_stops),
              u_color_stops: new s.bT(h, e.u_color_stops),
              u_color_ramp_size: new s.bT(h, e.u_color_ramp_size),
              u_opacity: new s.bj(h, e.u_opacity)
            }),
            line: (h, e) => ({
              u_translation: new s.bY(h, e.u_translation),
              u_ratio: new s.bj(h, e.u_ratio),
              u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
              u_units_to_pixels: new s.bY(h, e.u_units_to_pixels)
            }),
            lineGradient: (h, e) => ({
              u_translation: new s.bY(h, e.u_translation),
              u_ratio: new s.bj(h, e.u_ratio),
              u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
              u_units_to_pixels: new s.bY(h, e.u_units_to_pixels),
              u_image: new s.bT(h, e.u_image),
              u_image_height: new s.bj(h, e.u_image_height)
            }),
            linePattern: (h, e) => ({
              u_translation: new s.bY(h, e.u_translation),
              u_texsize: new s.bY(h, e.u_texsize),
              u_ratio: new s.bj(h, e.u_ratio),
              u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
              u_image: new s.bT(h, e.u_image),
              u_units_to_pixels: new s.bY(h, e.u_units_to_pixels),
              u_scale: new s.bX(h, e.u_scale),
              u_fade: new s.bj(h, e.u_fade)
            }),
            lineSDF: (h, e) => ({
              u_translation: new s.bY(h, e.u_translation),
              u_ratio: new s.bj(h, e.u_ratio),
              u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
              u_units_to_pixels: new s.bY(h, e.u_units_to_pixels),
              u_image: new s.bT(h, e.u_image),
              u_mix: new s.bj(h, e.u_mix),
              u_tileratio: new s.bj(h, e.u_tileratio),
              u_crossfade_from: new s.bj(h, e.u_crossfade_from),
              u_crossfade_to: new s.bj(h, e.u_crossfade_to),
              u_lineatlas_width: new s.bj(h, e.u_lineatlas_width),
              u_lineatlas_height: new s.bj(h, e.u_lineatlas_height)
            }),
            lineGradientSDF: (h, e) => ({
              u_translation: new s.bY(h, e.u_translation),
              u_ratio: new s.bj(h, e.u_ratio),
              u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
              u_units_to_pixels: new s.bY(h, e.u_units_to_pixels),
              u_image: new s.bT(h, e.u_image),
              u_image_height: new s.bj(h, e.u_image_height),
              u_tileratio: new s.bj(h, e.u_tileratio),
              u_crossfade_from: new s.bj(h, e.u_crossfade_from),
              u_crossfade_to: new s.bj(h, e.u_crossfade_to),
              u_image_dash: new s.bT(h, e.u_image_dash),
              u_mix: new s.bj(h, e.u_mix),
              u_lineatlas_width: new s.bj(h, e.u_lineatlas_width),
              u_lineatlas_height: new s.bj(h, e.u_lineatlas_height)
            }),
            raster: (h, e) => ({
              u_tl_parent: new s.bY(h, e.u_tl_parent),
              u_scale_parent: new s.bj(h, e.u_scale_parent),
              u_buffer_scale: new s.bj(h, e.u_buffer_scale),
              u_fade_t: new s.bj(h, e.u_fade_t),
              u_opacity: new s.bj(h, e.u_opacity),
              u_image0: new s.bT(h, e.u_image0),
              u_image1: new s.bT(h, e.u_image1),
              u_brightness_low: new s.bj(h, e.u_brightness_low),
              u_brightness_high: new s.bj(h, e.u_brightness_high),
              u_saturation_factor: new s.bj(h, e.u_saturation_factor),
              u_contrast_factor: new s.bj(h, e.u_contrast_factor),
              u_spin_weights: new s.bX(h, e.u_spin_weights),
              u_coords_top: new s.bW(h, e.u_coords_top),
              u_coords_bottom: new s.bW(h, e.u_coords_bottom)
            }),
            symbolIcon: (h, e) => ({
              u_is_size_zoom_constant: new s.bT(h, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new s.bT(h, e.u_is_size_feature_constant),
              u_size_t: new s.bj(h, e.u_size_t),
              u_size: new s.bj(h, e.u_size),
              u_camera_to_center_distance: new s.bj(h, e.u_camera_to_center_distance),
              u_pitch: new s.bj(h, e.u_pitch),
              u_rotate_symbol: new s.bT(h, e.u_rotate_symbol),
              u_aspect_ratio: new s.bj(h, e.u_aspect_ratio),
              u_fade_change: new s.bj(h, e.u_fade_change),
              u_label_plane_matrix: new s.bV(h, e.u_label_plane_matrix),
              u_coord_matrix: new s.bV(h, e.u_coord_matrix),
              u_is_text: new s.bT(h, e.u_is_text),
              u_pitch_with_map: new s.bT(h, e.u_pitch_with_map),
              u_is_along_line: new s.bT(h, e.u_is_along_line),
              u_is_variable_anchor: new s.bT(h, e.u_is_variable_anchor),
              u_texsize: new s.bY(h, e.u_texsize),
              u_texture: new s.bT(h, e.u_texture),
              u_translation: new s.bY(h, e.u_translation),
              u_pitched_scale: new s.bj(h, e.u_pitched_scale)
            }),
            symbolSDF: (h, e) => ({
              u_is_size_zoom_constant: new s.bT(h, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new s.bT(h, e.u_is_size_feature_constant),
              u_size_t: new s.bj(h, e.u_size_t),
              u_size: new s.bj(h, e.u_size),
              u_camera_to_center_distance: new s.bj(h, e.u_camera_to_center_distance),
              u_pitch: new s.bj(h, e.u_pitch),
              u_rotate_symbol: new s.bT(h, e.u_rotate_symbol),
              u_aspect_ratio: new s.bj(h, e.u_aspect_ratio),
              u_fade_change: new s.bj(h, e.u_fade_change),
              u_label_plane_matrix: new s.bV(h, e.u_label_plane_matrix),
              u_coord_matrix: new s.bV(h, e.u_coord_matrix),
              u_is_text: new s.bT(h, e.u_is_text),
              u_pitch_with_map: new s.bT(h, e.u_pitch_with_map),
              u_is_along_line: new s.bT(h, e.u_is_along_line),
              u_is_variable_anchor: new s.bT(h, e.u_is_variable_anchor),
              u_texsize: new s.bY(h, e.u_texsize),
              u_texture: new s.bT(h, e.u_texture),
              u_gamma_scale: new s.bj(h, e.u_gamma_scale),
              u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
              u_is_halo: new s.bT(h, e.u_is_halo),
              u_translation: new s.bY(h, e.u_translation),
              u_pitched_scale: new s.bj(h, e.u_pitched_scale)
            }),
            symbolTextAndIcon: (h, e) => ({
              u_is_size_zoom_constant: new s.bT(h, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new s.bT(h, e.u_is_size_feature_constant),
              u_size_t: new s.bj(h, e.u_size_t),
              u_size: new s.bj(h, e.u_size),
              u_camera_to_center_distance: new s.bj(h, e.u_camera_to_center_distance),
              u_pitch: new s.bj(h, e.u_pitch),
              u_rotate_symbol: new s.bT(h, e.u_rotate_symbol),
              u_aspect_ratio: new s.bj(h, e.u_aspect_ratio),
              u_fade_change: new s.bj(h, e.u_fade_change),
              u_label_plane_matrix: new s.bV(h, e.u_label_plane_matrix),
              u_coord_matrix: new s.bV(h, e.u_coord_matrix),
              u_is_text: new s.bT(h, e.u_is_text),
              u_pitch_with_map: new s.bT(h, e.u_pitch_with_map),
              u_is_along_line: new s.bT(h, e.u_is_along_line),
              u_is_variable_anchor: new s.bT(h, e.u_is_variable_anchor),
              u_texsize: new s.bY(h, e.u_texsize),
              u_texsize_icon: new s.bY(h, e.u_texsize_icon),
              u_texture: new s.bT(h, e.u_texture),
              u_texture_icon: new s.bT(h, e.u_texture_icon),
              u_gamma_scale: new s.bj(h, e.u_gamma_scale),
              u_device_pixel_ratio: new s.bj(h, e.u_device_pixel_ratio),
              u_is_halo: new s.bT(h, e.u_is_halo),
              u_translation: new s.bY(h, e.u_translation),
              u_pitched_scale: new s.bj(h, e.u_pitched_scale)
            }),
            background: (h, e) => ({
              u_opacity: new s.bj(h, e.u_opacity),
              u_color: new s.bU(h, e.u_color)
            }),
            backgroundPattern: (h, e) => ({
              u_opacity: new s.bj(h, e.u_opacity),
              u_image: new s.bT(h, e.u_image),
              u_pattern_tl_a: new s.bY(h, e.u_pattern_tl_a),
              u_pattern_br_a: new s.bY(h, e.u_pattern_br_a),
              u_pattern_tl_b: new s.bY(h, e.u_pattern_tl_b),
              u_pattern_br_b: new s.bY(h, e.u_pattern_br_b),
              u_texsize: new s.bY(h, e.u_texsize),
              u_mix: new s.bj(h, e.u_mix),
              u_pattern_size_a: new s.bY(h, e.u_pattern_size_a),
              u_pattern_size_b: new s.bY(h, e.u_pattern_size_b),
              u_scale_a: new s.bj(h, e.u_scale_a),
              u_scale_b: new s.bj(h, e.u_scale_b),
              u_pixel_coord_upper: new s.bY(h, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new s.bY(h, e.u_pixel_coord_lower),
              u_tile_units_to_pixels: new s.bj(h, e.u_tile_units_to_pixels)
            }),
            terrain: (h, e) => ({
              u_texture: new s.bT(h, e.u_texture),
              u_ele_delta: new s.bj(h, e.u_ele_delta),
              u_fog_matrix: new s.bV(h, e.u_fog_matrix),
              u_fog_color: new s.bU(h, e.u_fog_color),
              u_fog_ground_blend: new s.bj(h, e.u_fog_ground_blend),
              u_fog_ground_blend_opacity: new s.bj(h, e.u_fog_ground_blend_opacity),
              u_horizon_color: new s.bU(h, e.u_horizon_color),
              u_horizon_fog_blend: new s.bj(h, e.u_horizon_fog_blend),
              u_is_globe_mode: new s.bj(h, e.u_is_globe_mode)
            }),
            terrainDepth: (h, e) => ({
              u_ele_delta: new s.bj(h, e.u_ele_delta)
            }),
            terrainCoords: (h, e) => ({
              u_texture: new s.bT(h, e.u_texture),
              u_terrain_coords_id: new s.bj(h, e.u_terrain_coords_id),
              u_ele_delta: new s.bj(h, e.u_ele_delta)
            }),
            projectionErrorMeasurement: (h, e) => ({
              u_input: new s.bj(h, e.u_input),
              u_output_expected: new s.bj(h, e.u_output_expected)
            }),
            atmosphere: (h, e) => ({
              u_sun_pos: new s.bX(h, e.u_sun_pos),
              u_atmosphere_blend: new s.bj(h, e.u_atmosphere_blend),
              u_globe_position: new s.bX(h, e.u_globe_position),
              u_globe_radius: new s.bj(h, e.u_globe_radius),
              u_inv_proj_matrix: new s.bV(h, e.u_inv_proj_matrix)
            }),
            sky: (h, e) => ({
              u_sky_color: new s.bU(h, e.u_sky_color),
              u_horizon_color: new s.bU(h, e.u_horizon_color),
              u_horizon: new s.bY(h, e.u_horizon),
              u_horizon_normal: new s.bY(h, e.u_horizon_normal),
              u_sky_horizon_blend: new s.bj(h, e.u_sky_horizon_blend),
              u_sky_blend: new s.bj(h, e.u_sky_blend)
            })
          };
        class Xc {
          constructor(e, a, o) {
            this.context = e;
            const c = e.gl;
            this.buffer = c.createBuffer(), this.dynamicDraw = !!o, this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), c.bufferData(c.ELEMENT_ARRAY_BUFFER, a.arrayBuffer, this.dynamicDraw ? c.DYNAMIC_DRAW : c.STATIC_DRAW), this.dynamicDraw || delete a.arrayBuffer
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer)
          }
          updateData(e) {
            const a = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), a.bufferSubData(a.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer)
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer)
          }
        }
        const qs = {
          Int8: "BYTE",
          Uint8: "UNSIGNED_BYTE",
          Int16: "SHORT",
          Uint16: "UNSIGNED_SHORT",
          Int32: "INT",
          Uint32: "UNSIGNED_INT",
          Float32: "FLOAT"
        };
        class Yc {
          constructor(e, a, o, c) {
            this.length = a.length, this.attributes = o, this.itemSize = a.bytesPerElement, this.dynamicDraw = c, this.context = e;
            const d = e.gl;
            this.buffer = d.createBuffer(), e.bindVertexBuffer.set(this.buffer), d.bufferData(d.ARRAY_BUFFER, a.arrayBuffer, this.dynamicDraw ? d.DYNAMIC_DRAW : d.STATIC_DRAW), this.dynamicDraw || delete a.arrayBuffer
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer)
          }
          updateData(e) {
            if (e.length !== this.length) throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`);
            const a = this.context.gl;
            this.bind(), a.bufferSubData(a.ARRAY_BUFFER, 0, e.arrayBuffer)
          }
          enableAttributes(e, a) {
            for (let o = 0; o < this.attributes.length; o++) {
              const c = a.attributes[this.attributes[o].name];
              c !== void 0 && e.enableVertexAttribArray(c)
            }
          }
          setVertexAttribPointers(e, a, o) {
            for (let c = 0; c < this.attributes.length; c++) {
              const d = this.attributes[c],
                g = a.attributes[d.name];
              g !== void 0 && e.vertexAttribPointer(g, d.components, e[qs[d.type]], !1, this.itemSize, d.offset + this.itemSize * (o || 0))
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer)
          }
        }
        class Wi {
          constructor(e) {
            this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1
          }
          get() {
            return this.current
          }
          set(e) {}
          getDefault() {
            return this.default
          }
          setDefault() {
            this.set(this.default)
          }
        }
        class Up extends Wi {
          getDefault() {
            return s.bi.transparent
          }
          set(e) {
            const a = this.current;
            (e.r !== a.r || e.g !== a.g || e.b !== a.b || e.a !== a.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1)
          }
        }
        class Gp extends Wi {
          getDefault() {
            return 1
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1)
          }
        }
        class Wp extends Wi {
          getDefault() {
            return 0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1)
          }
        }
        class Nh extends Wi {
          getDefault() {
            return [!0, !0, !0, !0]
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || e[2] !== a[2] || e[3] !== a[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1)
          }
        }
        class Hp extends Wi {
          getDefault() {
            return !0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1)
          }
        }
        class Uh extends Wi {
          getDefault() {
            return 255
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1)
          }
        }
        class Cl extends Wi {
          getDefault() {
            return {
              func: this.gl.ALWAYS,
              ref: 0,
              mask: 255
            }
          }
          set(e) {
            const a = this.current;
            (e.func !== a.func || e.ref !== a.ref || e.mask !== a.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1)
          }
        }
        class Al extends Wi {
          getDefault() {
            const e = this.gl;
            return [e.KEEP, e.KEEP, e.KEEP]
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || e[2] !== a[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1)
          }
        }
        class kl extends Wi {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.STENCIL_TEST) : a.disable(a.STENCIL_TEST), this.current = e, this.dirty = !1
          }
        }
        class Kc extends Wi {
          getDefault() {
            return [0, 1]
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1)
          }
        }
        class Vs extends Wi {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.DEPTH_TEST) : a.disable(a.DEPTH_TEST), this.current = e, this.dirty = !1
          }
        }
        class Wo extends Wi {
          getDefault() {
            return this.gl.LESS
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1)
          }
        }
        class yo extends Wi {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.BLEND) : a.disable(a.BLEND), this.current = e, this.dirty = !1
          }
        }
        class Ln extends Wi {
          getDefault() {
            const e = this.gl;
            return [e.ONE, e.ZERO]
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1)
          }
        }
        class Gh extends Wi {
          getDefault() {
            return s.bi.transparent
          }
          set(e) {
            const a = this.current;
            (e.r !== a.r || e.g !== a.g || e.b !== a.b || e.a !== a.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1)
          }
        }
        class Wh extends Wi {
          getDefault() {
            return this.gl.FUNC_ADD
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = !1)
          }
        }
        class Jc extends Wi {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.CULL_FACE) : a.disable(a.CULL_FACE), this.current = e, this.dirty = !1
          }
        }
        class Zs extends Wi {
          getDefault() {
            return this.gl.BACK
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1)
          }
        }
        class El extends Wi {
          getDefault() {
            return this.gl.CCW
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1)
          }
        }
        class zl extends Wi {
          getDefault() {
            return null
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1)
          }
        }
        class Ho extends Wi {
          getDefault() {
            return this.gl.TEXTURE0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1)
          }
        }
        class Ll extends Wi {
          getDefault() {
            const e = this.gl;
            return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight]
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || e[2] !== a[2] || e[3] !== a[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1)
          }
        }
        class Hh extends Wi {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindFramebuffer(a.FRAMEBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class xo extends Wi {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindRenderbuffer(a.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class bo extends Wi {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindTexture(a.TEXTURE_2D, e), this.current = e, this.dirty = !1
          }
        }
        class $h extends Wi {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindBuffer(a.ARRAY_BUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class Qc extends Wi {
          getDefault() {
            return null
          }
          set(e) {
            const a = this.gl;
            a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class Ri extends Wi {
          getDefault() {
            return null
          }
          set(e) {
            var a;
            if (e === this.current && !this.dirty) return;
            const o = this.gl;
            qa(o) ? o.bindVertexArray(e) : (a = o.getExtension("OES_vertex_array_object")) === null || a === void 0 || a.bindVertexArrayOES(e), this.current = e, this.dirty = !1
          }
        }
        class Dl extends Wi {
          getDefault() {
            return 4
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.pixelStorei(a.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1
          }
        }
        class $p extends Wi {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1
          }
        }
        class Xh extends Wi {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1
          }
        }
        class Ns extends Wi {
          constructor(e, a) {
            super(e), this.context = e, this.parent = a
          }
          getDefault() {
            return null
          }
        }
        class Xp extends Ns {
          setDirty() {
            this.dirty = !0
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const a = this.gl;
            a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1
          }
        }
        class Yp extends Ns {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const a = this.gl;
            a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class Yh extends Ns {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const a = this.gl;
            a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        const Kh = "Framebuffer is not complete";
        class eu {
          constructor(e, a, o, c, d) {
            this.context = e, this.width = a, this.height = o;
            const g = e.gl,
              w = this.framebuffer = g.createFramebuffer();
            if (this.colorAttachment = new Xp(e, w), c) this.depthAttachment = d ? new Yh(e, w) : new Yp(e, w);
            else if (d) throw new Error("Stencil cannot be set without depth");
            if (g.checkFramebufferStatus(g.FRAMEBUFFER) !== g.FRAMEBUFFER_COMPLETE) throw new Error(Kh)
          }
          destroy() {
            const e = this.context.gl,
              a = this.colorAttachment.get();
            if (a && e.deleteTexture(a), this.depthAttachment) {
              const o = this.depthAttachment.get();
              o && e.deleteRenderbuffer(o)
            }
            e.deleteFramebuffer(this.framebuffer)
          }
        }
        class Rl {
          constructor(e) {
            var a, o;
            if (this.gl = e, this.clearColor = new Up(this), this.clearDepth = new Gp(this), this.clearStencil = new Wp(this), this.colorMask = new Nh(this), this.depthMask = new Hp(this), this.stencilMask = new Uh(this), this.stencilFunc = new Cl(this), this.stencilOp = new Al(this), this.stencilTest = new kl(this), this.depthRange = new Kc(this), this.depthTest = new Vs(this), this.depthFunc = new Wo(this), this.blend = new yo(this), this.blendFunc = new Ln(this), this.blendColor = new Gh(this), this.blendEquation = new Wh(this), this.cullFace = new Jc(this), this.cullFaceSide = new Zs(this), this.frontFace = new El(this), this.program = new zl(this), this.activeTexture = new Ho(this), this.viewport = new Ll(this), this.bindFramebuffer = new Hh(this), this.bindRenderbuffer = new xo(this), this.bindTexture = new bo(this), this.bindVertexBuffer = new $h(this), this.bindElementBuffer = new Qc(this), this.bindVertexArray = new Ri(this), this.pixelStoreUnpack = new Dl(this), this.pixelStoreUnpackPremultiplyAlpha = new $p(this), this.pixelStoreUnpackFlipY = new Xh(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), qa(e)) {
              this.HALF_FLOAT = e.HALF_FLOAT;
              const c = e.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = (a = e.RGBA16F) !== null && a !== void 0 ? a : c == null ? void 0 : c.RGBA16F_EXT, this.RGB16F = (o = e.RGB16F) !== null && o !== void 0 ? o : c == null ? void 0 : c.RGB16F_EXT, e.getExtension("EXT_color_buffer_float")
            } else {
              e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear");
              const c = e.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = c == null ? void 0 : c.HALF_FLOAT_OES
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault()
          }
          setDirty() {
            this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0
          }
          createIndexBuffer(e, a) {
            return new Xc(this, e, a)
          }
          createVertexBuffer(e, a, o) {
            return new Yc(this, e, a, o)
          }
          createRenderbuffer(e, a, o) {
            const c = this.gl,
              d = c.createRenderbuffer();
            return this.bindRenderbuffer.set(d), c.renderbufferStorage(c.RENDERBUFFER, e, a, o), this.bindRenderbuffer.set(null), d
          }
          createFramebuffer(e, a, o, c) {
            return new eu(this, e, a, o, c)
          }
          clear({
            color: e,
            depth: a,
            stencil: o
          }) {
            const c = this.gl;
            let d = 0;
            e && (d |= c.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), a !== void 0 && (d |= c.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(a), this.depthMask.set(!0)), o !== void 0 && (d |= c.STENCIL_BUFFER_BIT, this.clearStencil.set(o), this.stencilMask.set(255)), c.clear(d)
          }
          setCullFace(e) {
            e.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace))
          }
          setDepthMode(e) {
            e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1)
          }
          setStencilMode(e) {
            e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({
              func: e.test.func,
              ref: e.ref,
              mask: e.test.mask
            })) : this.stencilTest.set(!1)
          }
          setColorMode(e) {
            s.bK(e.blendFunction, Ti.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask)
          }
          createVertexArray() {
            var e;
            return qa(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) === null || e === void 0 ? void 0 : e.createVertexArrayOES()
          }
          deleteVertexArray(e) {
            var a;
            return qa(this.gl) ? this.gl.deleteVertexArray(e) : (a = this.gl.getExtension("OES_vertex_array_object")) === null || a === void 0 ? void 0 : a.deleteVertexArrayOES(e)
          }
          unbindVAO() {
            this.bindVertexArray.set(null)
          }
        }
        let Us;

        function $o(h, e, a, o, c) {
          const d = h.context,
            g = h.transform,
            w = d.gl,
            S = h.useProgram("collisionBox"),
            A = [];
          let E = 0,
            F = 0;
          for (let ce = 0; ce < o.length; ce++) {
            const ge = o[ce],
              Pe = e.getTile(ge).getBucket(a);
            if (!Pe) continue;
            const fe = c ? Pe.textCollisionBox : Pe.iconCollisionBox,
              Me = Pe.collisionCircleArray;
            Me.length > 0 && (A.push({
              circleArray: Me,
              circleOffset: F,
              coord: ge
            }), E += Me.length / 4, F = E), fe && S.draw(d, w.LINES, _i.disabled, Li.disabled, h.colorModeForRenderPass(), gi.disabled, Bh(h.transform), h.style.map.terrain && h.style.map.terrain.getTerrainData(ge), g.getProjectionData({
              overscaledTileID: ge,
              applyGlobeMatrix: !0,
              applyTerrainMatrix: !0
            }), a.id, fe.layoutVertexBuffer, fe.indexBuffer, fe.segments, null, h.transform.zoom, null, null, fe.collisionVertexBuffer)
          }
          if (!c || !A.length) return;
          const R = h.useProgram("collisionCircle"),
            U = new s.c3;
          U.resize(4 * E), U._trim();
          let Y = 0;
          for (const ce of A)
            for (let ge = 0; ge < ce.circleArray.length / 4; ge++) {
              const Pe = 4 * ge,
                fe = ce.circleArray[Pe + 0],
                Me = ce.circleArray[Pe + 1],
                Ee = ce.circleArray[Pe + 2],
                ve = ce.circleArray[Pe + 3];
              U.emplace(Y++, fe, Me, Ee, ve, 0), U.emplace(Y++, fe, Me, Ee, ve, 1), U.emplace(Y++, fe, Me, Ee, ve, 2), U.emplace(Y++, fe, Me, Ee, ve, 3)
            }(!Us || Us.length < 2 * E) && (Us = (function(ce) {
              const ge = 2 * ce,
                Pe = new s.c5;
              Pe.resize(ge), Pe._trim();
              for (let fe = 0; fe < ge; fe++) {
                const Me = 6 * fe;
                Pe.uint16[Me + 0] = 4 * fe + 0, Pe.uint16[Me + 1] = 4 * fe + 1, Pe.uint16[Me + 2] = 4 * fe + 2, Pe.uint16[Me + 3] = 4 * fe + 2, Pe.uint16[Me + 4] = 4 * fe + 3, Pe.uint16[Me + 5] = 4 * fe + 0
              }
              return Pe
            })(E));
          const se = d.createIndexBuffer(Us, !0),
            le = d.createVertexBuffer(U, s.c4.members, !0);
          for (const ce of A) {
            const ge = qc(h.transform);
            R.draw(d, w.TRIANGLES, _i.disabled, Li.disabled, h.colorModeForRenderPass(), gi.disabled, ge, h.style.map.terrain && h.style.map.terrain.getTerrainData(ce.coord), null, a.id, le, se, s.aQ.simpleSegment(0, 2 * ce.circleOffset, ce.circleArray.length, ce.circleArray.length / 2), null, h.transform.zoom, null, null, null)
          }
          le.destroy(), se.destroy()
        }
        const tu = s.am(new Float32Array(16));

        function Jh(h, e, a, o, c, d) {
          const {
            horizontalAlign: g,
            verticalAlign: w
          } = s.aL(h);
          return new s.P((-(g - .5) * e / c + o[0]) * d, (-(w - .5) * a / c + o[1]) * d)
        }

        function Fl(h, e, a, o, c, d) {
          const g = e.tileAnchorPoint.add(new s.P(e.translation[0], e.translation[1]));
          if (e.pitchWithMap) {
            let w = o.mult(d);
            a || (w = w.rotate(-c));
            const S = g.add(w);
            return Je(S.x, S.y, e.pitchedLabelPlaneMatrix, e.getElevation).point
          }
          if (a) {
            const w = Ue(e.tileAnchorPoint.x + 1, e.tileAnchorPoint.y, e).point.sub(h),
              S = Math.atan(w.y / w.x) + (w.x < 0 ? Math.PI : 0);
            return h.add(o.rotate(S))
          }
          return h.add(o)
        }

        function Bl(h, e, a, o, c, d, g, w, S, A, E, F) {
          const R = h.text.placedSymbolArray,
            U = h.text.dynamicLayoutVertexArray,
            Y = h.icon.dynamicLayoutVertexArray,
            se = {};
          U.clear();
          for (let le = 0; le < R.length; le++) {
            const ce = R.get(le),
              ge = ce.hidden || !ce.crossTileID || h.allowVerticalPlacement && !ce.placedOrientation ? null : o[ce.crossTileID];
            if (ge) {
              const Pe = new s.P(ce.anchorX, ce.anchorY),
                fe = {
                  getElevation: F,
                  width: c.width,
                  height: c.height,
                  pitchedLabelPlaneMatrix: d,
                  pitchWithMap: a,
                  transform: c,
                  tileAnchorPoint: Pe,
                  translation: A,
                  unwrappedTileID: E
                },
                Me = a ? Gt(Pe.x, Pe.y, fe) : Ue(Pe.x, Pe.y, fe),
                Ee = tr(c.cameraToCenterDistance, Me.signedDistanceFromCamera);
              let ve = s.at(h.textSizeData, w, ce) * Ee / s.aF;
              a && (ve *= h.tilePixelRatio / g);
              const {
                width: Oe,
                height: lt,
                anchor: it,
                textOffset: st,
                textBoxScale: ct
              } = ge, nr = Jh(it, Oe, lt, st, ct, ve), lr = c.getPitchedTextCorrection(Pe.x + A[0], Pe.y + A[1], E), Bt = Fl(Me.point, fe, e, nr, -c.bearingInRadians, lr), qr = h.allowVerticalPlacement && ce.placedOrientation === s.as.vertical ? Math.PI / 2 : 0;
              for (let yi = 0; yi < ce.numGlyphs; yi++) s.az(U, Bt, qr);
              S && ce.associatedIconIndex >= 0 && (se[ce.associatedIconIndex] = {
                shiftedAnchor: Bt,
                angle: qr
              })
            } else Kr(ce.numGlyphs, U)
          }
          if (S) {
            Y.clear();
            const le = h.icon.placedSymbolArray;
            for (let ce = 0; ce < le.length; ce++) {
              const ge = le.get(ce);
              if (ge.hidden) Kr(ge.numGlyphs, Y);
              else {
                const Pe = se[ce];
                if (Pe)
                  for (let fe = 0; fe < ge.numGlyphs; fe++) s.az(Y, Pe.shiftedAnchor, Pe.angle);
                else Kr(ge.numGlyphs, Y)
              }
            }
            h.icon.dynamicLayoutVertexBuffer.updateData(Y)
          }
          h.text.dynamicLayoutVertexBuffer.updateData(U)
        }

        function Ol(h, e, a) {
          return a.iconsInText && e ? "symbolTextAndIcon" : h ? "symbolSDF" : "symbolIcon"
        }

        function Gs(h, e, a, o, c, d, g, w, S, A, E, F, R) {
          const U = h.context,
            Y = U.gl,
            se = h.transform,
            le = w === "map",
            ce = S === "map",
            ge = w !== "viewport" && a.layout.get("symbol-placement") !== "point",
            Pe = le && !ce && !ge,
            fe = !a.layout.get("symbol-sort-key").isConstant();
          let Me = !1;
          const Ee = h.getDepthModeForSublayer(0, _i.ReadOnly),
            ve = a._unevaluatedLayout.hasValue("text-variable-anchor") || a._unevaluatedLayout.hasValue("text-variable-anchor-offset"),
            Oe = [],
            lt = se.getCircleRadiusCorrection();
          for (const it of o) {
            const st = e.getTile(it),
              ct = st.getBucket(a);
            if (!ct) continue;
            const nr = c ? ct.text : ct.icon;
            if (!nr || !nr.segments.get().length || !nr.hasVisibleVertices) continue;
            const lr = nr.programConfigurations.get(a.id),
              Bt = c || ct.sdfIcons,
              qr = c ? ct.textSizeData : ct.iconSizeData,
              yi = ce || se.pitch !== 0,
              Hi = h.useProgram(Ol(Bt, c, ct), lr),
              Ci = s.ar(qr, se.zoom),
              Qi = h.style.map.terrain && h.style.map.terrain.getTerrainData(it);
            let fa, ta, ka, oa, Va = [0, 0],
              la = null;
            if (c) ta = st.glyphAtlasTexture, ka = Y.LINEAR, fa = st.glyphAtlasTexture.size, ct.iconsInText && (Va = st.imageAtlasTexture.size, la = st.imageAtlasTexture, oa = yi || h.options.rotating || h.options.zooming || qr.kind === "composite" || qr.kind === "camera" ? Y.LINEAR : Y.NEAREST);
            else {
              const Ca = a.layout.get("icon-size").constantOr(0) !== 1 || ct.iconsNeedLinear;
              ta = st.imageAtlasTexture, ka = Bt || h.options.rotating || h.options.zooming || Ca || yi ? Y.LINEAR : Y.NEAREST, fa = st.imageAtlasTexture.size
            }
            const Ia = s.aG(st, 1, h.transform.zoom),
              un = Kt(le, h.transform, Ia),
              Ks = s.M();
            s.au(Ks, un);
            const ps = Cr(ce, le, h.transform, Ia),
              is = s.aH(se, st, d, g),
              Js = se.getProjectionData({
                overscaledTileID: it,
                applyGlobeMatrix: !R,
                applyTerrainMatrix: !0
              }),
              Ao = ve && ct.hasTextData(),
              Qs = a.layout.get("icon-text-fit") !== "none" && Ao && ct.hasIconData();
            if (ge) {
              const Ca = h.style.map.terrain ? (Za, ia) => h.style.map.terrain.getElevation(it, Za, ia) : null,
                ba = a.layout.get("text-rotation-alignment") === "map";
              Tr(ct, h, c, un, Ks, ce, A, ba, it.toUnwrapped(), se.width, se.height, is, Ca)
            }
            const _n = c && ve || Qs,
              hn = ge || _n ? tu : ce ? un : h.transform.clipSpaceToPixelsMatrix,
              fs = Bt && a.paint.get(c ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
            let Ms;
            Ms = Bt ? ct.iconsInText ? os(qr.kind, Ci, Pe, ce, ge, _n, h, hn, ps, is, fa, Va, lt) : Go(qr.kind, Ci, Pe, ce, ge, _n, h, hn, ps, is, c, fa, 0, lt) : Wc(qr.kind, Ci, Pe, ce, ge, _n, h, hn, ps, is, c, fa, lt);
            const nl = {
              program: Hi,
              buffers: nr,
              uniformValues: Ms,
              projectionData: Js,
              atlasTexture: ta,
              atlasTextureIcon: la,
              atlasInterpolation: ka,
              atlasInterpolationIcon: oa,
              isSDF: Bt,
              hasHalo: fs
            };
            if (fe && ct.canOverlap) {
              Me = !0;
              const Ca = nr.segments.get();
              for (const ba of Ca) Oe.push({
                segments: new s.aQ([ba]),
                sortKey: ba.sortKey,
                state: nl,
                terrainData: Qi
              })
            } else Oe.push({
              segments: nr.segments,
              sortKey: 0,
              state: nl,
              terrainData: Qi
            })
          }
          Me && Oe.sort(((it, st) => it.sortKey - st.sortKey));
          for (const it of Oe) {
            const st = it.state;
            if (U.activeTexture.set(Y.TEXTURE0), st.atlasTexture.bind(st.atlasInterpolation, Y.CLAMP_TO_EDGE), st.atlasTextureIcon && (U.activeTexture.set(Y.TEXTURE1), st.atlasTextureIcon && st.atlasTextureIcon.bind(st.atlasInterpolationIcon, Y.CLAMP_TO_EDGE)), st.isSDF) {
              const ct = st.uniformValues;
              st.hasHalo && (ct.u_is_halo = 1, jl(st.buffers, it.segments, a, h, st.program, Ee, E, F, ct, st.projectionData, it.terrainData)), ct.u_is_halo = 0
            }
            jl(st.buffers, it.segments, a, h, st.program, Ee, E, F, st.uniformValues, st.projectionData, it.terrainData)
          }
        }

        function jl(h, e, a, o, c, d, g, w, S, A, E) {
          const F = o.context;
          c.draw(F, F.gl.TRIANGLES, d, g, w, gi.backCCW, S, E, A, a.id, h.layoutVertexBuffer, h.indexBuffer, e, a.paint, o.transform.zoom, h.programConfigurations.get(a.id), h.dynamicLayoutVertexBuffer, h.opacityVertexBuffer)
        }

        function Kp(h, e, a, o, c) {
          const d = h.context,
            g = d.gl,
            w = Li.disabled,
            S = new Ti([g.ONE, g.ONE], s.bi.transparent, [!0, !0, !0, !0]),
            A = e.getBucket(a);
          if (!A) return;
          const E = o.key;
          let F = a.heatmapFbos.get(E);
          F || (F = Qh(d, e.tileSize, e.tileSize), a.heatmapFbos.set(E, F)), d.bindFramebuffer.set(F.framebuffer), d.viewport.set([0, 0, e.tileSize, e.tileSize]), d.clear({
            color: s.bi.transparent
          });
          const R = A.programConfigurations.get(a.id),
            U = h.useProgram("heatmap", R, !c),
            Y = h.transform.getProjectionData({
              overscaledTileID: e.tileID,
              applyGlobeMatrix: !0,
              applyTerrainMatrix: !0
            }),
            se = h.style.map.terrain.getTerrainData(o);
          U.draw(d, g.TRIANGLES, _i.disabled, w, S, gi.disabled, Zc(e, h.transform.zoom, a.paint.get("heatmap-intensity"), 1), se, Y, a.id, A.layoutVertexBuffer, A.indexBuffer, A.segments, a.paint, h.transform.zoom, R)
        }

        function Xo(h, e, a, o, c) {
          const d = h.context,
            g = d.gl,
            w = h.transform;
          d.setColorMode(h.colorModeForRenderPass());
          const S = ru(d, e),
            A = a.key,
            E = e.heatmapFbos.get(A);
          if (!E) return;
          d.activeTexture.set(g.TEXTURE0), g.bindTexture(g.TEXTURE_2D, E.colorAttachment.get()), d.activeTexture.set(g.TEXTURE1), S.bind(g.LINEAR, g.CLAMP_TO_EDGE);
          const F = w.getProjectionData({
            overscaledTileID: a,
            applyTerrainMatrix: c,
            applyGlobeMatrix: !o
          });
          h.useProgram("heatmapTexture").draw(d, g.TRIANGLES, _i.disabled, Li.disabled, h.colorModeForRenderPass(), gi.disabled, Nc(h, e, 0, 1), null, F, e.id, h.rasterBoundsBuffer, h.quadTriangleIndexBuffer, h.rasterBoundsSegments, e.paint, w.zoom), E.destroy(), e.heatmapFbos.delete(A)
        }

        function Qh(h, e, a) {
          var o, c;
          const d = h.gl,
            g = d.createTexture();
          d.bindTexture(d.TEXTURE_2D, g), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_S, d.CLAMP_TO_EDGE), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_T, d.CLAMP_TO_EDGE), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MIN_FILTER, d.LINEAR), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MAG_FILTER, d.LINEAR);
          const w = (o = h.HALF_FLOAT) !== null && o !== void 0 ? o : d.UNSIGNED_BYTE,
            S = (c = h.RGBA16F) !== null && c !== void 0 ? c : d.RGBA;
          d.texImage2D(d.TEXTURE_2D, 0, S, e, a, 0, d.RGBA, w, null);
          const A = h.createFramebuffer(e, a, !1, !1);
          return A.colorAttachment.set(g), A
        }

        function ru(h, e) {
          return e.colorRampTexture || (e.colorRampTexture = new s.T(h, e.colorRamp, h.gl.RGBA)), e.colorRampTexture
        }

        function Yo(h, e, a, o, c, d, g, w) {
          let S = 256;
          if (c.stepInterpolant) {
            const A = e.getSource().maxzoom,
              E = g.canonical.z === A ? Math.ceil(1 << h.transform.maxZoom - g.canonical.z) : 1;
            S = s.ai(s.c7(d.maxLineLength / s.a3 * 1024 * E), 256, a.maxTextureSize)
          }
          return w.gradient = s.c8({
            expression: c.gradientExpression(),
            evaluationKey: "lineProgress",
            resolution: S,
            image: w.gradient || void 0,
            clips: d.lineClipsArray
          }), w.texture ? w.texture.update(w.gradient) : w.texture = new s.T(a, w.gradient, o.RGBA), w.version = c.gradientVersion, w.texture
        }

        function iu(h, e, a, o, c) {
          h.activeTexture.set(e.TEXTURE0), a.imageAtlasTexture.bind(e.LINEAR, e.CLAMP_TO_EDGE), o.updatePaintBuffers(c)
        }

        function ed(h, e, a, o, c, d) {
          (c || h.lineAtlas.dirty) && (e.activeTexture.set(a.TEXTURE0), h.lineAtlas.bind(e)), o.updatePaintBuffers(d)
        }

        function td(h, e, a, o, c, d, g) {
          const w = d.gradients[c.id];
          let S = w.texture;
          c.gradientVersion !== w.version && (S = Yo(h, e, a, o, c, d, g, w)), a.activeTexture.set(o.TEXTURE0), S.bind(c.stepInterpolant ? o.NEAREST : o.LINEAR, o.CLAMP_TO_EDGE)
        }

        function ql(h, e, a, o, c, d, g, w, S) {
          const A = d.gradients[c.id];
          let E = A.texture;
          c.gradientVersion !== A.version && (E = Yo(h, e, a, o, c, d, g, A)), a.activeTexture.set(o.TEXTURE0), E.bind(c.stepInterpolant ? o.NEAREST : o.LINEAR, o.CLAMP_TO_EDGE), a.activeTexture.set(o.TEXTURE1), h.lineAtlas.bind(a), w.updatePaintBuffers(S)
        }

        function Vl(h, e, a, o, c) {
          if (!a || !o || !o.imageAtlas) return;
          const d = o.imageAtlas.patternPositions;
          let g = d[a.to.toString()],
            w = d[a.from.toString()];
          if (!g && w && (g = w), !w && g && (w = g), !g || !w) {
            const S = c.getPaintProperty(e);
            g = d[S], w = d[S]
          }
          g && w && h.setConstantPatternPositions(g, w)
        }

        function rd(h, e, a, o, c, d, g, w) {
          const S = h.context.gl,
            A = "fill-pattern",
            E = a.paint.get(A),
            F = E && E.constantOr(1),
            R = a.getCrossfadeParameters();
          let U, Y, se, le, ce;
          const ge = h.transform,
            Pe = a.paint.get("fill-translate"),
            fe = a.paint.get("fill-translate-anchor");
          g ? (Y = F && !a.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", U = S.LINES) : (Y = F ? "fillPattern" : "fill", U = S.TRIANGLES);
          const Me = E.constantOr(null);
          for (const Ee of o) {
            const ve = e.getTile(Ee);
            if (F && !ve.patternsLoaded()) continue;
            const Oe = ve.getBucket(a);
            if (!Oe) continue;
            const lt = Oe.programConfigurations.get(a.id),
              it = h.useProgram(Y, lt),
              st = h.style.map.terrain && h.style.map.terrain.getTerrainData(Ee);
            F && (h.context.activeTexture.set(S.TEXTURE0), ve.imageAtlasTexture.bind(S.LINEAR, S.CLAMP_TO_EDGE), lt.updatePaintBuffers(R)), Vl(lt, A, Me, ve, a);
            const ct = ge.getProjectionData({
                overscaledTileID: Ee,
                applyGlobeMatrix: !w,
                applyTerrainMatrix: !0
              }),
              nr = s.aH(ge, ve, Pe, fe);
            if (g) {
              le = Oe.indexBuffer2, ce = Oe.segments2;
              const Bt = [S.drawingBufferWidth, S.drawingBufferHeight];
              se = Y === "fillOutlinePattern" && F ? Fh(h, R, ve, Bt, nr) : jp(Bt, nr)
            } else le = Oe.indexBuffer, ce = Oe.segments, se = F ? Os(h, R, ve, nr) : {
              u_fill_translate: nr
            };
            const lr = h.stencilModeForClipping(Ee);
            it.draw(h.context, U, c, lr, d, gi.backCCW, se, st, ct, a.id, Oe.layoutVertexBuffer, le, ce, a.paint, h.transform.zoom, lt)
          }
        }

        function Zl(h, e, a, o, c, d, g, w) {
          const S = h.context,
            A = S.gl,
            E = "fill-extrusion-pattern",
            F = a.paint.get(E),
            R = F.constantOr(1),
            U = a.getCrossfadeParameters(),
            Y = a.paint.get("fill-extrusion-opacity"),
            se = F.constantOr(null),
            le = h.transform;
          for (const ce of o) {
            const ge = e.getTile(ce),
              Pe = ge.getBucket(a);
            if (!Pe) continue;
            const fe = h.style.map.terrain && h.style.map.terrain.getTerrainData(ce),
              Me = Pe.programConfigurations.get(a.id),
              Ee = h.useProgram(R ? "fillExtrusionPattern" : "fillExtrusion", Me);
            R && (h.context.activeTexture.set(A.TEXTURE0), ge.imageAtlasTexture.bind(A.LINEAR, A.CLAMP_TO_EDGE), Me.updatePaintBuffers(U));
            const ve = le.getProjectionData({
              overscaledTileID: ce,
              applyGlobeMatrix: !w,
              applyTerrainMatrix: !0
            });
            Vl(Me, E, se, ge, a);
            const Oe = s.aH(le, ge, a.paint.get("fill-extrusion-translate"), a.paint.get("fill-extrusion-translate-anchor")),
              lt = a.paint.get("fill-extrusion-vertical-gradient"),
              it = R ? Op(h, lt, Y, Oe, ce, U, ge) : Uo(h, lt, Y, Oe);
            Ee.draw(S, S.gl.TRIANGLES, c, d, g, gi.backCCW, it, fe, ve, a.id, Pe.layoutVertexBuffer, Pe.indexBuffer, Pe.segments, a.paint, h.transform.zoom, Me, h.style.map.terrain && Pe.centroidVertexBuffer)
          }
        }

        function da(h, e, a, o, c, d, g, w, S) {
          var A;
          const E = h.style.projection,
            F = h.context,
            R = h.transform,
            U = F.gl,
            Y = [`#define NUM_ILLUMINATION_SOURCES ${a.paint.get("hillshade-highlight-color").values.length}`],
            se = h.useProgram("hillshade", null, !1, Y),
            le = !h.options.moving;
          for (const ce of o) {
            const ge = e.getTile(ce),
              Pe = ge.fbo;
            if (!Pe) continue;
            const fe = E.getMeshFromTileID(F, ce.canonical, w, !0, "raster"),
              Me = (A = h.style.map.terrain) === null || A === void 0 ? void 0 : A.getTerrainData(ce);
            F.activeTexture.set(U.TEXTURE0), U.bindTexture(U.TEXTURE_2D, Pe.colorAttachment.get());
            const Ee = R.getProjectionData({
              overscaledTileID: ce,
              aligned: le,
              applyGlobeMatrix: !S,
              applyTerrainMatrix: !0
            });
            se.draw(F, U.TRIANGLES, d, c[ce.overscaledZ], g, gi.backCCW, Oh(h, ge, a), Me, Ee, a.id, fe.vertexBuffer, fe.indexBuffer, fe.segments)
          }
        }

        function ls(h, e, a, o, c, d, g, w, S) {
          var A;
          const E = h.style.projection,
            F = h.context,
            R = h.transform,
            U = F.gl,
            Y = h.useProgram("colorRelief"),
            se = !h.options.moving;
          let le = !0,
            ce = 0;
          for (const ge of o) {
            const Pe = e.getTile(ge),
              fe = Pe.dem;
            if (le) {
              const it = U.getParameter(U.MAX_TEXTURE_SIZE),
                {
                  elevationTexture: st,
                  colorTexture: ct
                } = a.getColorRampTextures(F, it, fe.getUnpackVector());
              F.activeTexture.set(U.TEXTURE1), st.bind(U.NEAREST, U.CLAMP_TO_EDGE), F.activeTexture.set(U.TEXTURE4), ct.bind(U.LINEAR, U.CLAMP_TO_EDGE), le = !1, ce = st.size[0]
            }
            if (!fe || !fe.data) continue;
            const Me = fe.stride,
              Ee = fe.getPixels();
            if (F.activeTexture.set(U.TEXTURE0), F.pixelStoreUnpackPremultiplyAlpha.set(!1), Pe.demTexture = Pe.demTexture || h.getTileTexture(Me), Pe.demTexture) {
              const it = Pe.demTexture;
              it.update(Ee, {
                premultiply: !1
              }), it.bind(U.LINEAR, U.CLAMP_TO_EDGE)
            } else Pe.demTexture = new s.T(F, Ee, U.RGBA, {
              premultiply: !1
            }), Pe.demTexture.bind(U.LINEAR, U.CLAMP_TO_EDGE);
            const ve = E.getMeshFromTileID(F, ge.canonical, w, !0, "raster"),
              Oe = (A = h.style.map.terrain) === null || A === void 0 ? void 0 : A.getTerrainData(ge),
              lt = R.getProjectionData({
                overscaledTileID: ge,
                aligned: se,
                applyGlobeMatrix: !S,
                applyTerrainMatrix: !0
              });
            Y.draw(F, U.TRIANGLES, d, c[ge.overscaledZ], g, gi.backCCW, qh(a, Pe.dem, ce), Oe, lt, a.id, ve.vertexBuffer, ve.indexBuffer, ve.segments)
          }
        }
        const mn = [new s.P(0, 0), new s.P(s.a3, 0), new s.P(s.a3, s.a3), new s.P(0, s.a3)];

        function wo(h, e, a, o, c, d, g, w, S = !1, A = !1) {
          const E = o[o.length - 1].overscaledZ,
            F = h.context,
            R = F.gl,
            U = h.useProgram("raster"),
            Y = h.transform,
            se = h.style.projection,
            le = h.colorModeForRenderPass(),
            ce = !h.options.moving,
            ge = a.paint.get("raster-opacity"),
            Pe = a.paint.get("raster-resampling"),
            fe = a.paint.get("raster-fade-duration"),
            Me = !!h.style.map.terrain;
          for (const Ee of o) {
            const ve = h.getDepthModeForSublayer(Ee.overscaledZ - E, ge === 1 ? _i.ReadWrite : _i.ReadOnly, R.LESS),
              Oe = e.getTile(Ee),
              lt = Pe === "nearest" ? R.NEAREST : R.LINEAR;
            F.activeTexture.set(R.TEXTURE0), Oe.texture.bind(lt, R.CLAMP_TO_EDGE, R.LINEAR_MIPMAP_NEAREST), F.activeTexture.set(R.TEXTURE1);
            const {
              parentTile: it,
              parentScaleBy: st,
              parentTopLeft: ct,
              fadeValues: nr
            } = Nl(Oe, e, fe, Me);
            Oe.fadeOpacity = nr.tileOpacity, it ? (it.fadeOpacity = nr.parentTileOpacity, it.texture.bind(lt, R.CLAMP_TO_EDGE, R.LINEAR_MIPMAP_NEAREST)) : Oe.texture.bind(lt, R.CLAMP_TO_EDGE, R.LINEAR_MIPMAP_NEAREST), Oe.texture.useMipmap && F.extTextureFilterAnisotropic && h.transform.pitch > 20 && R.texParameterf(R.TEXTURE_2D, F.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, F.extTextureFilterAnisotropicMax);
            const lr = h.style.map.terrain && h.style.map.terrain.getTerrainData(Ee),
              Bt = Y.getProjectionData({
                overscaledTileID: Ee,
                aligned: ce,
                applyGlobeMatrix: !A,
                applyTerrainMatrix: !0
              }),
              qr = Vh(ct, st, nr.fadeMix, a, w),
              yi = se.getMeshFromTileID(F, Ee.canonical, d, g, "raster");
            U.draw(F, R.TRIANGLES, ve, c ? c[Ee.overscaledZ] : Li.disabled, le, S ? gi.frontCCW : gi.backCCW, qr, lr, Bt, a.id, yi.vertexBuffer, yi.indexBuffer, yi.segments)
          }
        }

        function Nl(h, e, a, o) {
          const c = {
            parentTile: null,
            parentScaleBy: 1,
            parentTopLeft: [0, 0],
            fadeValues: {
              tileOpacity: 1,
              parentTileOpacity: 1,
              fadeMix: {
                opacity: 1,
                mix: 0
              }
            }
          };
          if (a === 0 || o) return c;
          if (h.fadingParentID) {
            const d = e.getLoadedTile(h.fadingParentID);
            if (!d) return c;
            const g = Math.pow(2, d.tileID.overscaledZ - h.tileID.overscaledZ),
              w = [h.tileID.canonical.x * g % 1, h.tileID.canonical.y * g % 1],
              S = (function(A, E, F) {
                const R = _e(),
                  U = (R - E.timeAdded) / F,
                  Y = A.fadingDirection === re.Incoming,
                  se = s.ai((R - A.timeAdded) / F, 0, 1),
                  le = s.ai(1 - U, 0, 1),
                  ce = Y ? se : le;
                return {
                  tileOpacity: ce,
                  parentTileOpacity: Y ? le : se,
                  fadeMix: {
                    opacity: 1,
                    mix: 1 - ce
                  }
                }
              })(h, d, a);
            return {
              parentTile: d,
              parentScaleBy: g,
              parentTopLeft: w,
              fadeValues: S
            }
          }
          if (h.selfFading) {
            const d = (function(g, w) {
              const S = (_e() - g.timeAdded) / w,
                A = s.ai(S, 0, 1);
              return {
                tileOpacity: A,
                fadeMix: {
                  opacity: A,
                  mix: 0
                }
              }
            })(h, a);
            return {
              parentTile: null,
              parentScaleBy: 1,
              parentTopLeft: [0, 0],
              fadeValues: d
            }
          }
          return c
        }
        const id = new s.bi(1, 0, 0, 1),
          To = new s.bi(0, 1, 0, 1),
          au = new s.bi(0, 0, 1, 1),
          Ko = new s.bi(1, 0, 1, 1),
          nu = new s.bi(0, 1, 1, 1);

        function su(h, e, a, o) {
          Jo(h, 0, e + a / 2, h.transform.width, a, o)
        }

        function ou(h, e, a, o) {
          Jo(h, e - a / 2, 0, a, h.transform.height, o)
        }

        function Jo(h, e, a, o, c, d) {
          const g = h.context,
            w = g.gl;
          w.enable(w.SCISSOR_TEST), w.scissor(e * h.pixelRatio, a * h.pixelRatio, o * h.pixelRatio, c * h.pixelRatio), g.clear({
            color: d
          }), w.disable(w.SCISSOR_TEST)
        }

        function ad(h, e, a) {
          const o = h.context,
            c = o.gl,
            d = h.useProgram("debug"),
            g = _i.disabled,
            w = Li.disabled,
            S = h.colorModeForRenderPass(),
            A = "$debug",
            E = h.style.map.terrain && h.style.map.terrain.getTerrainData(a);
          o.activeTexture.set(c.TEXTURE0);
          const F = e.getTileByID(a.key).latestRawTileData,
            R = Math.floor((F && F.byteLength || 0) / 1024),
            U = e.getTile(a).tileSize,
            Y = 512 / Math.min(U, 512) * (a.overscaledZ / h.transform.zoom) * .5;
          let se = a.canonical.toString();
          a.overscaledZ !== a.canonical.z && (se += ` => ${a.overscaledZ}`), (function(ce, ge) {
            ce.initDebugOverlayCanvas();
            const Pe = ce.debugOverlayCanvas,
              fe = ce.context.gl,
              Me = ce.debugOverlayCanvas.getContext("2d");
            Me.clearRect(0, 0, Pe.width, Pe.height), Me.shadowColor = "white", Me.shadowBlur = 2, Me.lineWidth = 1.5, Me.strokeStyle = "white", Me.textBaseline = "top", Me.font = "bold 36px Open Sans, sans-serif", Me.fillText(ge, 5, 5), Me.strokeText(ge, 5, 5), ce.debugOverlayTexture.update(Pe), ce.debugOverlayTexture.bind(fe.LINEAR, fe.CLAMP_TO_EDGE)
          })(h, `${se} ${R}kB`);
          const le = h.transform.getProjectionData({
            overscaledTileID: a,
            applyGlobeMatrix: !0,
            applyTerrainMatrix: !0
          });
          d.draw(o, c.TRIANGLES, g, w, Ti.alphaBlended, gi.disabled, Vc(s.bi.transparent, Y), null, le, A, h.debugBuffer, h.quadTriangleIndexBuffer, h.debugSegments), d.draw(o, c.LINE_STRIP, g, w, S, gi.disabled, Vc(s.bi.red), E, le, A, h.debugBuffer, h.tileBorderIndexBuffer, h.debugSegments)
        }

        function lu(h, e, a, o) {
          const {
            isRenderingGlobe: c
          } = o, d = h.context, g = d.gl, w = h.transform, S = h.colorModeForRenderPass(), A = h.getDepthModeFor3D(), E = h.useProgram("terrain");
          d.bindFramebuffer.set(null), d.viewport.set([0, 0, h.width, h.height]);
          for (const F of a) {
            const R = e.getTerrainMesh(F.tileID),
              U = h.renderToTexture.getTexture(F),
              Y = e.getTerrainData(F.tileID);
            d.activeTexture.set(g.TEXTURE0), g.bindTexture(g.TEXTURE_2D, U.texture);
            const se = e.getMeshFrameDelta(w.zoom),
              le = w.calculateFogMatrix(F.tileID.toUnwrapped()),
              ce = Bp(se, le, h.style.sky, w.pitch, c),
              ge = w.getProjectionData({
                overscaledTileID: F.tileID,
                applyTerrainMatrix: !1,
                applyGlobeMatrix: !0
              });
            E.draw(d, g.TRIANGLES, A, Li.disabled, S, gi.backCCW, ce, Y, ge, "terrain", R.vertexBuffer, R.indexBuffer, R.segments)
          }
        }

        function Ps(h, e) {
          if (!e.mesh) {
            const a = new s.aP;
            a.emplaceBack(-1, -1), a.emplaceBack(1, -1), a.emplaceBack(1, 1), a.emplaceBack(-1, 1);
            const o = new s.aR;
            o.emplaceBack(0, 1, 2), o.emplaceBack(0, 2, 3), e.mesh = new Ni(h.createVertexBuffer(a, Oi.members), h.createIndexBuffer(o), s.aQ.simpleSegment(0, 0, a.length, o.length))
          }
          return e.mesh
        }
        class nd {
          constructor(e, a) {
            this.context = new Rl(e), this.transform = a, this._tileTextures = {}, this.terrainFacilitator = {
              dirty: !0,
              matrix: s.am(new Float64Array(16)),
              renderTime: 0
            }, this.setup(), this.numSublayers = Tt.maxUnderzooming + Tt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new kr
          }
          resize(e, a, o) {
            if (this.width = Math.floor(e * o), this.height = Math.floor(a * o), this.pixelRatio = o, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
              for (const c of this.style._order) this.style._layers[c].resize()
          }
          setup() {
            const e = this.context,
              a = new s.aP;
            a.emplaceBack(0, 0), a.emplaceBack(s.a3, 0), a.emplaceBack(0, s.a3), a.emplaceBack(s.a3, s.a3), this.tileExtentBuffer = e.createVertexBuffer(a, Oi.members), this.tileExtentSegments = s.aQ.simpleSegment(0, 0, 4, 2);
            const o = new s.aP;
            o.emplaceBack(0, 0), o.emplaceBack(s.a3, 0), o.emplaceBack(0, s.a3), o.emplaceBack(s.a3, s.a3), this.debugBuffer = e.createVertexBuffer(o, Oi.members), this.debugSegments = s.aQ.simpleSegment(0, 0, 4, 5);
            const c = new s.ca;
            c.emplaceBack(0, 0, 0, 0), c.emplaceBack(s.a3, 0, s.a3, 0), c.emplaceBack(0, s.a3, 0, s.a3), c.emplaceBack(s.a3, s.a3, s.a3, s.a3), this.rasterBoundsBuffer = e.createVertexBuffer(c, Oc.members), this.rasterBoundsSegments = s.aQ.simpleSegment(0, 0, 4, 2);
            const d = new s.aP;
            d.emplaceBack(0, 0), d.emplaceBack(s.a3, 0), d.emplaceBack(0, s.a3), d.emplaceBack(s.a3, s.a3), this.rasterBoundsBufferPosOnly = e.createVertexBuffer(d, Oi.members), this.rasterBoundsSegmentsPosOnly = s.aQ.simpleSegment(0, 0, 4, 5);
            const g = new s.aP;
            g.emplaceBack(0, 0), g.emplaceBack(1, 0), g.emplaceBack(0, 1), g.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(g, Oi.members), this.viewportSegments = s.aQ.simpleSegment(0, 0, 4, 2);
            const w = new s.cb;
            w.emplaceBack(0), w.emplaceBack(1), w.emplaceBack(3), w.emplaceBack(2), w.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(w);
            const S = new s.aR;
            S.emplaceBack(1, 0, 2), S.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(S);
            const A = this.context.gl;
            this.stencilClearMode = new Li({
              func: A.ALWAYS,
              mask: 0
            }, 0, 255, A.ZERO, A.ZERO, A.ZERO), this.tileExtentMesh = new Ni(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments)
          }
          clearStencil() {
            const e = this.context,
              a = e.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const o = s.M();
            s.c0(o, 0, this.width, this.height, 0, 0, 1), s.O(o, o, [a.drawingBufferWidth, a.drawingBufferHeight, 0]);
            const c = {
              mainMatrix: o,
              tileMercatorCoords: [0, 0, 1, 1],
              clippingPlane: [0, 0, 0, 0],
              projectionTransition: 0,
              fallbackMatrix: o
            };
            this.useProgram("clippingMask", null, !0).draw(e, a.TRIANGLES, _i.disabled, this.stencilClearMode, Ti.disabled, gi.disabled, null, null, c, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments)
          }
          _renderTileClippingMasks(e, a, o) {
            if (this.currentStencilSource === e.source || !e.isTileClipped() || !a || !a.length) return;
            this.currentStencilSource = e.source, this.nextStencilID + a.length > 256 && this.clearStencil();
            const c = this.context;
            c.setColorMode(Ti.disabled), c.setDepthMode(_i.disabled);
            const d = {};
            for (const g of a) d[g.key] = this.nextStencilID++;
            this._renderTileMasks(d, a, o, !0), this._renderTileMasks(d, a, o, !1), this._tileClippingMaskIDs = d
          }
          _renderTileMasks(e, a, o, c) {
            const d = this.context,
              g = d.gl,
              w = this.style.projection,
              S = this.transform,
              A = this.useProgram("clippingMask");
            for (const E of a) {
              const F = e[E.key],
                R = this.style.map.terrain && this.style.map.terrain.getTerrainData(E),
                U = w.getMeshFromTileID(this.context, E.canonical, c, !0, "stencil"),
                Y = S.getProjectionData({
                  overscaledTileID: E,
                  applyGlobeMatrix: !o,
                  applyTerrainMatrix: !0
                });
              A.draw(d, g.TRIANGLES, _i.disabled, new Li({
                func: g.ALWAYS,
                mask: 0
              }, F, 255, g.KEEP, g.KEEP, g.REPLACE), Ti.disabled, o ? gi.disabled : gi.backCCW, null, R, Y, "$clipping", U.vertexBuffer, U.indexBuffer, U.segments)
            }
          }
          _renderTilesDepthBuffer() {
            const e = this.context,
              a = e.gl,
              o = this.style.projection,
              c = this.transform,
              d = this.useProgram("depth"),
              g = this.getDepthModeFor3D(),
              w = He(c, {
                tileSize: c.tileSize
              });
            for (const S of w) {
              const A = this.style.map.terrain && this.style.map.terrain.getTerrainData(S),
                E = o.getMeshFromTileID(this.context, S.canonical, !0, !0, "raster"),
                F = c.getProjectionData({
                  overscaledTileID: S,
                  applyGlobeMatrix: !0,
                  applyTerrainMatrix: !0
                });
              d.draw(e, a.TRIANGLES, g, Li.disabled, Ti.disabled, gi.backCCW, null, A, F, "$clipping", E.vertexBuffer, E.indexBuffer, E.segments)
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const e = this.nextStencilID++,
              a = this.context.gl;
            return new Li({
              func: a.NOTEQUAL,
              mask: 255
            }, e, 255, a.KEEP, a.KEEP, a.REPLACE)
          }
          stencilModeForClipping(e) {
            const a = this.context.gl;
            return new Li({
              func: a.EQUAL,
              mask: 255
            }, this._tileClippingMaskIDs[e.key], 0, a.KEEP, a.KEEP, a.REPLACE)
          }
          getStencilConfigForOverlapAndUpdateStencilID(e) {
            const a = this.context.gl,
              o = e.sort(((g, w) => w.overscaledZ - g.overscaledZ)),
              c = o[o.length - 1].overscaledZ,
              d = o[0].overscaledZ - c + 1;
            if (d > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + d > 256 && this.clearStencil();
              const g = {};
              for (let w = 0; w < d; w++) g[w + c] = new Li({
                func: a.GEQUAL,
                mask: 255
              }, w + this.nextStencilID, 255, a.KEEP, a.KEEP, a.REPLACE);
              return this.nextStencilID += d, [g, o]
            }
            return [{
              [c]: Li.disabled
            }, o]
          }
          stencilConfigForOverlapTwoPass(e) {
            const a = this.context.gl,
              o = e.sort(((g, w) => w.overscaledZ - g.overscaledZ)),
              c = o[o.length - 1].overscaledZ,
              d = o[0].overscaledZ - c + 1;
            if (this.clearStencil(), d > 1) {
              const g = {},
                w = {};
              for (let S = 0; S < d; S++) g[S + c] = new Li({
                func: a.GREATER,
                mask: 255
              }, d + 1 + S, 255, a.KEEP, a.KEEP, a.REPLACE), w[S + c] = new Li({
                func: a.GREATER,
                mask: 255
              }, 1 + S, 255, a.KEEP, a.KEEP, a.REPLACE);
              return this.nextStencilID = 2 * d + 1, [g, w, o]
            }
            return this.nextStencilID = 3, [{
              [c]: new Li({
                func: a.GREATER,
                mask: 255
              }, 2, 255, a.KEEP, a.KEEP, a.REPLACE)
            }, {
              [c]: new Li({
                func: a.GREATER,
                mask: 255
              }, 1, 255, a.KEEP, a.KEEP, a.REPLACE)
            }, o]
          }
          colorModeForRenderPass() {
            const e = this.context.gl;
            return this._showOverdrawInspector ? new Ti([e.CONSTANT_COLOR, e.ONE], new s.bi(.125, .125, .125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? Ti.unblended : Ti.alphaBlended
          }
          getDepthModeForSublayer(e, a, o) {
            if (!this.opaquePassEnabledForLayer()) return _i.disabled;
            const c = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
            return new _i(o || this.context.gl.LEQUAL, a, [c, c])
          }
          getDepthModeFor3D() {
            return new _i(this.context.gl.LEQUAL, _i.ReadWrite, this.depthRangeFor3D)
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff
          }
          render(e, a) {
            var o, c;
            this.style = e, this.options = a, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(_e()), this.imageManager.beginFrame();
            const d = this.style._order,
              g = this.style.tileManagers,
              w = {},
              S = {},
              A = {},
              E = {
                isRenderingToTexture: !1,
                isRenderingGlobe: ((o = e.projection) === null || o === void 0 ? void 0 : o.transitionState) > 0
              };
            for (const R in g) {
              const U = g[R];
              U.used && U.prepare(this.context), w[R] = U.getVisibleCoordinates(!1), S[R] = w[R].slice().reverse(), A[R] = U.getVisibleCoordinates(!0).reverse()
            }
            this.opaquePassCutoff = 1 / 0;
            for (let R = 0; R < d.length; R++)
              if (this.style._layers[d[R]].is3D()) {
                this.opaquePassCutoff = R;
                break
              } this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const R of d) {
              const U = this.style._layers[R];
              if (!U.hasOffscreenPass() || U.isHidden(this.transform.zoom)) continue;
              const Y = S[U.source];
              (U.type === "custom" || Y.length) && this.renderLayer(this, g[U.source], U, Y, E)
            }
            if ((c = this.style.projection) === null || c === void 0 || c.updateGPUdependent({
                context: this.context,
                useProgram: R => this.useProgram(R)
              }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({
                color: a.showOverdrawInspector ? s.bi.black : s.bi.transparent,
                depth: 1
              }), this.clearStencil(), this.style.sky && (function(R, U) {
                const Y = R.context,
                  se = Y.gl,
                  le = ((Ee, ve, Oe) => {
                    const lt = Math.cos(ve.rollInRadians),
                      it = Math.sin(ve.rollInRadians),
                      st = Be(ve),
                      ct = ve.getProjectionData({
                        overscaledTileID: null,
                        applyGlobeMatrix: !0,
                        applyTerrainMatrix: !0
                      }).projectionTransition;
                    return {
                      u_sky_color: Ee.properties.get("sky-color"),
                      u_horizon_color: Ee.properties.get("horizon-color"),
                      u_horizon: [(ve.width / 2 - st * it) * Oe, (ve.height / 2 + st * lt) * Oe],
                      u_horizon_normal: [-it, lt],
                      u_sky_horizon_blend: Ee.properties.get("sky-horizon-blend") * ve.height / 2 * Oe,
                      u_sky_blend: ct
                    }
                  })(U, R.style.map.transform, R.pixelRatio),
                  ce = new _i(se.LEQUAL, _i.ReadWrite, [0, 1]),
                  ge = Li.disabled,
                  Pe = R.colorModeForRenderPass(),
                  fe = R.useProgram("sky"),
                  Me = Ps(Y, U);
                fe.draw(Y, se.TRIANGLES, ce, ge, Pe, gi.disabled, le, null, void 0, "sky", Me.vertexBuffer, Me.indexBuffer, Me.segments)
              })(this, this.style.sky), this._showOverdrawInspector = a.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture)
              for (this.renderPass = "opaque", this.currentLayer = d.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                const R = this.style._layers[d[this.currentLayer]],
                  U = g[R.source],
                  Y = w[R.source];
                this._renderTileClippingMasks(R, Y, !1), this.renderLayer(this, U, R, Y, E)
              }
            this.renderPass = "translucent";
            let F = !1;
            for (this.currentLayer = 0; this.currentLayer < d.length; this.currentLayer++) {
              const R = this.style._layers[d[this.currentLayer]],
                U = g[R.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer(R, E)) continue;
              this.opaquePassEnabledForLayer() || F || (F = !0, E.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
              const Y = (R.type === "symbol" ? A : S)[R.source];
              this._renderTileClippingMasks(R, w[R.source], !!this.renderToTexture), this.renderLayer(this, U, R, Y, E)
            }
            if (E.isRenderingGlobe && (function(R, U, Y) {
                const se = R.context,
                  le = se.gl,
                  ce = R.useProgram("atmosphere"),
                  ge = new _i(le.LEQUAL, _i.ReadOnly, [0, 1]),
                  Pe = R.transform,
                  fe = (function(ct, nr) {
                    const lr = ct.properties.get("position"),
                      Bt = [-lr.x, -lr.y, -lr.z],
                      qr = s.am(new Float64Array(16));
                    return ct.properties.get("anchor") === "map" && (s.b9(qr, qr, nr.rollInRadians), s.ba(qr, qr, -nr.pitchInRadians), s.b9(qr, qr, nr.bearingInRadians), s.ba(qr, qr, nr.center.lat * Math.PI / 180), s.bC(qr, qr, -nr.center.lng * Math.PI / 180)), s.c9(Bt, Bt, qr), Bt
                  })(Y, R.transform),
                  Me = Pe.getProjectionData({
                    overscaledTileID: null,
                    applyGlobeMatrix: !0,
                    applyTerrainMatrix: !0
                  }),
                  Ee = U.properties.get("atmosphere-blend") * Me.projectionTransition;
                if (Ee === 0) return;
                const ve = Vn(Pe.worldSize, Pe.center.lat),
                  Oe = Pe.inverseProjectionMatrix,
                  lt = new Float64Array(4);
                lt[3] = 1, s.aA(lt, lt, Pe.modelViewProjectionMatrix), lt[0] /= lt[3], lt[1] /= lt[3], lt[2] /= lt[3], lt[3] = 1, s.aA(lt, lt, Oe), lt[0] /= lt[3], lt[1] /= lt[3], lt[2] /= lt[3], lt[3] = 1;
                const it = ((ct, nr, lr, Bt, qr) => ({
                    u_sun_pos: ct,
                    u_atmosphere_blend: nr,
                    u_globe_position: lr,
                    u_globe_radius: Bt,
                    u_inv_proj_matrix: qr
                  }))(fe, Ee, [lt[0], lt[1], lt[2]], ve, Oe),
                  st = Ps(se, U);
                ce.draw(se, le.TRIANGLES, ge, Li.disabled, Ti.alphaBlended, gi.disabled, it, null, null, "atmosphere", st.vertexBuffer, st.indexBuffer, st.segments)
              })(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
              const R = (function(U, Y) {
                let se = null;
                const le = Object.values(U._layers).flatMap((fe => fe.source && !fe.isHidden(Y) ? [U.tileManagers[fe.source]] : [])),
                  ce = le.filter((fe => fe.getSource().type === "vector")),
                  ge = le.filter((fe => fe.getSource().type !== "vector")),
                  Pe = fe => {
                    (!se || se.getSource().maxzoom < fe.getSource().maxzoom) && (se = fe)
                  };
                return ce.forEach((fe => Pe(fe))), se || ge.forEach((fe => Pe(fe))), se
              })(this.style, this.transform.zoom);
              R && (function(U, Y, se) {
                for (let le = 0; le < se.length; le++) ad(U, Y, se[le])
              })(this, R, R.getVisibleCoordinates())
            }
            this.options.showPadding && (function(R) {
              const U = R.transform.padding;
              su(R, R.transform.height - (U.top || 0), 3, id), su(R, U.bottom || 0, 3, To), ou(R, U.left || 0, 3, au), ou(R, R.transform.width - (U.right || 0), 3, Ko);
              const Y = R.transform.centerPoint;
              (function(se, le, ce, ge) {
                Jo(se, le - 1, ce - 10, 2, 20, ge), Jo(se, le - 10, ce - 1, 20, 2, ge)
              })(R, Y.x, R.transform.height - Y.y, nu)
            })(this), this.context.setDefault()
          }
          maybeDrawDepthAndCoords(e) {
            if (!this.style || !this.style.map || !this.style.map.terrain) return;
            const a = this.terrainFacilitator.matrix,
              o = this.transform.modelViewProjectionMatrix;
            let c = this.terrainFacilitator.dirty;
            c || (c = e ? !s.cc(a, o) : !s.cd(a, o)), c || (c = this.style.map.terrain.tileManager.anyTilesAfterTime(this.terrainFacilitator.renderTime)), c && (s.ce(a, o), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, (function(d, g) {
              const w = d.context,
                S = w.gl,
                A = d.transform,
                E = Ti.unblended,
                F = new _i(S.LEQUAL, _i.ReadWrite, [0, 1]),
                R = g.tileManager.getRenderableTiles(),
                U = d.useProgram("terrainDepth");
              w.bindFramebuffer.set(g.getFramebuffer("depth").framebuffer), w.viewport.set([0, 0, d.width / devicePixelRatio, d.height / devicePixelRatio]), w.clear({
                color: s.bi.transparent,
                depth: 1
              });
              for (const Y of R) {
                const se = g.getTerrainMesh(Y.tileID),
                  le = g.getTerrainData(Y.tileID),
                  ce = A.getProjectionData({
                    overscaledTileID: Y.tileID,
                    applyTerrainMatrix: !1,
                    applyGlobeMatrix: !0
                  }),
                  ge = {
                    u_ele_delta: g.getMeshFrameDelta(A.zoom)
                  };
                U.draw(w, S.TRIANGLES, F, Li.disabled, E, gi.backCCW, ge, le, ce, "terrain", se.vertexBuffer, se.indexBuffer, se.segments)
              }
              w.bindFramebuffer.set(null), w.viewport.set([0, 0, d.width, d.height])
            })(this, this.style.map.terrain), (function(d, g) {
              const w = d.context,
                S = w.gl,
                A = d.transform,
                E = Ti.unblended,
                F = new _i(S.LEQUAL, _i.ReadWrite, [0, 1]),
                R = g.getCoordsTexture(),
                U = g.tileManager.getRenderableTiles(),
                Y = d.useProgram("terrainCoords");
              w.bindFramebuffer.set(g.getFramebuffer("coords").framebuffer), w.viewport.set([0, 0, d.width / devicePixelRatio, d.height / devicePixelRatio]), w.clear({
                color: s.bi.transparent,
                depth: 1
              }), g.coordsIndex = [];
              for (const se of U) {
                const le = g.getTerrainMesh(se.tileID),
                  ce = g.getTerrainData(se.tileID);
                w.activeTexture.set(S.TEXTURE0), S.bindTexture(S.TEXTURE_2D, R.texture);
                const ge = {
                    u_terrain_coords_id: (255 - g.coordsIndex.length) / 255,
                    u_texture: 0,
                    u_ele_delta: g.getMeshFrameDelta(A.zoom)
                  },
                  Pe = A.getProjectionData({
                    overscaledTileID: se.tileID,
                    applyTerrainMatrix: !1,
                    applyGlobeMatrix: !0
                  });
                Y.draw(w, S.TRIANGLES, F, Li.disabled, E, gi.backCCW, ge, ce, Pe, "terrain", le.vertexBuffer, le.indexBuffer, le.segments), g.coordsIndex.push(se.tileID.key)
              }
              w.bindFramebuffer.set(null), w.viewport.set([0, 0, d.width, d.height])
            })(this, this.style.map.terrain))
          }
          renderLayer(e, a, o, c, d) {
            o.isHidden(this.transform.zoom) || (o.type === "background" || o.type === "custom" || (c || []).length) && (this.id = o.id, s.cf(o) ? (function(g, w, S, A, E, F) {
              if (g.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: R
              } = F, U = Li.disabled, Y = g.colorModeForRenderPass();
              (S._unevaluatedLayout.hasValue("text-variable-anchor") || S._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && (function(se, le, ce, ge, Pe, fe, Me, Ee, ve) {
                const Oe = le.transform,
                  lt = le.style.map.terrain,
                  it = Pe === "map",
                  st = fe === "map";
                for (const ct of se) {
                  const nr = ge.getTile(ct),
                    lr = nr.getBucket(ce);
                  if (!lr || !lr.text || !lr.text.segments.get().length) continue;
                  const Bt = s.ar(lr.textSizeData, Oe.zoom),
                    qr = s.aG(nr, 1, le.transform.zoom),
                    yi = Kt(it, le.transform, qr),
                    Hi = ce.layout.get("icon-text-fit") !== "none" && lr.hasIconData();
                  if (Bt) {
                    const Ci = Math.pow(2, Oe.zoom - nr.tileID.overscaledZ),
                      Qi = lt ? (fa, ta) => lt.getElevation(ct, fa, ta) : null;
                    Bl(lr, it, st, ve, Oe, yi, Ci, Bt, Hi, s.aH(Oe, nr, Me, Ee), ct.toUnwrapped(), Qi)
                  }
                }
              })(A, g, S, w, S.layout.get("text-rotation-alignment"), S.layout.get("text-pitch-alignment"), S.paint.get("text-translate"), S.paint.get("text-translate-anchor"), E), S.paint.get("icon-opacity").constantOr(1) !== 0 && Gs(g, w, S, A, !1, S.paint.get("icon-translate"), S.paint.get("icon-translate-anchor"), S.layout.get("icon-rotation-alignment"), S.layout.get("icon-pitch-alignment"), S.layout.get("icon-keep-upright"), U, Y, R), S.paint.get("text-opacity").constantOr(1) !== 0 && Gs(g, w, S, A, !0, S.paint.get("text-translate"), S.paint.get("text-translate-anchor"), S.layout.get("text-rotation-alignment"), S.layout.get("text-pitch-alignment"), S.layout.get("text-keep-upright"), U, Y, R), w.map.showCollisionBoxes && ($o(g, w, S, A, !0), $o(g, w, S, A, !1))
            })(e, a, o, c, this.style.placement.variableOffsets, d) : s.cg(o) ? (function(g, w, S, A, E) {
              if (g.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: F
              } = E, R = S.paint.get("circle-opacity"), U = S.paint.get("circle-stroke-width"), Y = S.paint.get("circle-stroke-opacity"), se = !S.layout.get("circle-sort-key").isConstant();
              if (R.constantOr(1) === 0 && (U.constantOr(1) === 0 || Y.constantOr(1) === 0)) return;
              const le = g.context,
                ce = le.gl,
                ge = g.transform,
                Pe = g.getDepthModeForSublayer(0, _i.ReadOnly),
                fe = Li.disabled,
                Me = g.colorModeForRenderPass(),
                Ee = [],
                ve = ge.getCircleRadiusCorrection();
              for (let Oe = 0; Oe < A.length; Oe++) {
                const lt = A[Oe],
                  it = w.getTile(lt),
                  st = it.getBucket(S);
                if (!st) continue;
                const ct = S.paint.get("circle-translate"),
                  nr = S.paint.get("circle-translate-anchor"),
                  lr = s.aH(ge, it, ct, nr),
                  Bt = st.programConfigurations.get(S.id),
                  qr = g.useProgram("circle", Bt),
                  yi = st.layoutVertexBuffer,
                  Hi = st.indexBuffer,
                  Ci = g.style.map.terrain && g.style.map.terrain.getTerrainData(lt),
                  Qi = {
                    programConfiguration: Bt,
                    program: qr,
                    layoutVertexBuffer: yi,
                    indexBuffer: Hi,
                    uniformValues: qp(g, it, S, lr, ve),
                    terrainData: Ci,
                    projectionData: ge.getProjectionData({
                      overscaledTileID: lt,
                      applyGlobeMatrix: !F,
                      applyTerrainMatrix: !0
                    })
                  };
                if (se) {
                  const fa = st.segments.get();
                  for (const ta of fa) Ee.push({
                    segments: new s.aQ([ta]),
                    sortKey: ta.sortKey,
                    state: Qi
                  })
                } else Ee.push({
                  segments: st.segments,
                  sortKey: 0,
                  state: Qi
                })
              }
              se && Ee.sort(((Oe, lt) => Oe.sortKey - lt.sortKey));
              for (const Oe of Ee) {
                const {
                  programConfiguration: lt,
                  program: it,
                  layoutVertexBuffer: st,
                  indexBuffer: ct,
                  uniformValues: nr,
                  terrainData: lr,
                  projectionData: Bt
                } = Oe.state;
                it.draw(le, ce.TRIANGLES, Pe, fe, Me, gi.backCCW, nr, lr, Bt, S.id, st, ct, Oe.segments, S.paint, g.transform.zoom, lt)
              }
            })(e, a, o, c, d) : s.ch(o) ? (function(g, w, S, A, E) {
              if (S.paint.get("heatmap-opacity") === 0) return;
              const F = g.context,
                {
                  isRenderingToTexture: R,
                  isRenderingGlobe: U
                } = E;
              if (g.style.map.terrain) {
                for (const Y of A) {
                  const se = w.getTile(Y);
                  w.hasRenderableParent(Y) || (g.renderPass === "offscreen" ? Kp(g, se, S, Y, U) : g.renderPass === "translucent" && Xo(g, S, Y, R, U))
                }
                F.viewport.set([0, 0, g.width, g.height])
              } else g.renderPass === "offscreen" ? (function(Y, se, le, ce) {
                const ge = Y.context,
                  Pe = ge.gl,
                  fe = Y.transform,
                  Me = Li.disabled,
                  Ee = new Ti([Pe.ONE, Pe.ONE], s.bi.transparent, [!0, !0, !0, !0]);
                (function(ve, Oe, lt) {
                  const it = ve.gl;
                  ve.activeTexture.set(it.TEXTURE1), ve.viewport.set([0, 0, Oe.width / 4, Oe.height / 4]);
                  let st = lt.heatmapFbos.get(s.c6);
                  st ? (it.bindTexture(it.TEXTURE_2D, st.colorAttachment.get()), ve.bindFramebuffer.set(st.framebuffer)) : (st = Qh(ve, Oe.width / 4, Oe.height / 4), lt.heatmapFbos.set(s.c6, st))
                })(ge, Y, le), ge.clear({
                  color: s.bi.transparent
                });
                for (let ve = 0; ve < ce.length; ve++) {
                  const Oe = ce[ve];
                  if (se.hasRenderableParent(Oe)) continue;
                  const lt = se.getTile(Oe),
                    it = lt.getBucket(le);
                  if (!it) continue;
                  const st = it.programConfigurations.get(le.id),
                    ct = Y.useProgram("heatmap", st),
                    nr = fe.getProjectionData({
                      overscaledTileID: Oe,
                      applyGlobeMatrix: !0,
                      applyTerrainMatrix: !1
                    }),
                    lr = fe.getCircleRadiusCorrection();
                  ct.draw(ge, Pe.TRIANGLES, _i.disabled, Me, Ee, gi.backCCW, Zc(lt, fe.zoom, le.paint.get("heatmap-intensity"), lr), null, nr, le.id, it.layoutVertexBuffer, it.indexBuffer, it.segments, le.paint, fe.zoom, st)
                }
                ge.viewport.set([0, 0, Y.width, Y.height])
              })(g, w, S, A) : g.renderPass === "translucent" && (function(Y, se) {
                const le = Y.context,
                  ce = le.gl;
                le.setColorMode(Y.colorModeForRenderPass());
                const ge = se.heatmapFbos.get(s.c6);
                ge && (le.activeTexture.set(ce.TEXTURE0), ce.bindTexture(ce.TEXTURE_2D, ge.colorAttachment.get()), le.activeTexture.set(ce.TEXTURE1), ru(le, se).bind(ce.LINEAR, ce.CLAMP_TO_EDGE), Y.useProgram("heatmapTexture").draw(le, ce.TRIANGLES, _i.disabled, Li.disabled, Y.colorModeForRenderPass(), gi.disabled, Nc(Y, se, 0, 1), null, null, se.id, Y.viewportBuffer, Y.quadTriangleIndexBuffer, Y.viewportSegments, se.paint, Y.transform.zoom))
              })(g, S)
            })(e, a, o, c, d) : s.ci(o) ? (function(g, w, S, A, E) {
              if (g.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: F
              } = E, R = S.paint.get("line-opacity"), U = S.paint.get("line-width");
              if (R.constantOr(1) === 0 || U.constantOr(1) === 0) return;
              const Y = g.getDepthModeForSublayer(0, _i.ReadOnly),
                se = g.colorModeForRenderPass(),
                le = S.paint.get("line-dasharray"),
                ce = le.constantOr(1),
                ge = S.paint.get("line-pattern"),
                Pe = ge.constantOr(1),
                fe = S.paint.get("line-gradient"),
                Me = S.getCrossfadeParameters();
              let Ee;
              Ee = Pe ? "linePattern" : ce && fe ? "lineGradientSDF" : ce ? "lineSDF" : fe ? "lineGradient" : "line";
              const ve = g.context,
                Oe = ve.gl,
                lt = g.transform;
              let it = !0;
              for (const st of A) {
                const ct = w.getTile(st);
                if (Pe && !ct.patternsLoaded()) continue;
                const nr = ct.getBucket(S);
                if (!nr) continue;
                const lr = nr.programConfigurations.get(S.id),
                  Bt = g.context.program.get(),
                  qr = g.useProgram(Ee, lr),
                  yi = it || qr.program !== Bt,
                  Hi = g.style.map.terrain && g.style.map.terrain.getTerrainData(st),
                  Ci = ge.constantOr(null),
                  Qi = le && le.constantOr(null);
                if (Ci && ct.imageAtlas) {
                  const Va = ct.imageAtlas,
                    la = Va.patternPositions[Ci.to.toString()],
                    Ia = Va.patternPositions[Ci.from.toString()];
                  la && Ia && lr.setConstantPatternPositions(la, Ia)
                } else if (Qi) {
                  const Va = S.layout.get("line-cap") === "round",
                    la = g.lineAtlas.getDash(Qi.to, Va),
                    Ia = g.lineAtlas.getDash(Qi.from, Va);
                  lr.setConstantDashPositions(la, Ia)
                }
                const fa = lt.getProjectionData({
                    overscaledTileID: st,
                    applyGlobeMatrix: !F,
                    applyTerrainMatrix: !0
                  }),
                  ta = lt.getPixelScale();
                let ka;
                Pe ? (ka = Pl(g, ct, S, ta, Me), iu(ve, Oe, ct, lr, Me)) : ce && fe ? (ka = Np(g, ct, S, ta, Me, nr.lineClipsArray.length), ql(g, w, ve, Oe, S, nr, st, lr, Me)) : ce ? (ka = Zp(g, ct, S, ta, Me), ed(g, ve, Oe, lr, yi, Me)) : fe ? (ka = Vp(g, ct, S, ta, nr.lineClipsArray.length), td(g, w, ve, Oe, S, nr, st)) : ka = Ss(g, ct, S, ta);
                const oa = g.stencilModeForClipping(st);
                qr.draw(ve, Oe.TRIANGLES, Y, oa, se, gi.disabled, ka, Hi, fa, S.id, nr.layoutVertexBuffer, nr.indexBuffer, nr.segments, S.paint, g.transform.zoom, lr, nr.layoutVertexBuffer2), it = !1
              }
            })(e, a, o, c, d) : s.cj(o) ? (function(g, w, S, A, E) {
              const F = S.paint.get("fill-color"),
                R = S.paint.get("fill-opacity");
              if (R.constantOr(1) === 0) return;
              const {
                isRenderingToTexture: U
              } = E, Y = g.colorModeForRenderPass(), se = S.paint.get("fill-pattern"), le = g.opaquePassEnabledForLayer() && !se.constantOr(1) && F.constantOr(s.bi.transparent).a === 1 && R.constantOr(0) === 1 ? "opaque" : "translucent";
              if (g.renderPass === le) {
                const ce = g.getDepthModeForSublayer(1, g.renderPass === "opaque" ? _i.ReadWrite : _i.ReadOnly);
                rd(g, w, S, A, ce, Y, !1, U)
              }
              if (g.renderPass === "translucent" && S.paint.get("fill-antialias")) {
                const ce = g.getDepthModeForSublayer(S.getPaintProperty("fill-outline-color") ? 2 : 0, _i.ReadOnly);
                rd(g, w, S, A, ce, Y, !0, U)
              }
            })(e, a, o, c, d) : s.ck(o) ? (function(g, w, S, A, E) {
              const F = S.paint.get("fill-extrusion-opacity");
              if (F === 0) return;
              const {
                isRenderingToTexture: R
              } = E;
              if (g.renderPass === "translucent") {
                const U = new _i(g.context.gl.LEQUAL, _i.ReadWrite, g.depthRangeFor3D);
                if (F !== 1 || S.paint.get("fill-extrusion-pattern").constantOr(1)) Zl(g, w, S, A, U, Li.disabled, Ti.disabled, R), Zl(g, w, S, A, U, g.stencilModeFor3D(), g.colorModeForRenderPass(), R);
                else {
                  const Y = g.colorModeForRenderPass();
                  Zl(g, w, S, A, U, Li.disabled, Y, R)
                }
              }
            })(e, a, o, c, d) : s.cl(o) ? (function(g, w, S, A, E) {
              if (g.renderPass !== "offscreen" && g.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: F
              } = E, R = g.context, U = g.style.projection.useSubdivision, Y = g.getDepthModeForSublayer(0, _i.ReadOnly), se = g.colorModeForRenderPass();
              if (g.renderPass === "offscreen")(function(le, ce, ge, Pe, fe, Me, Ee) {
                const ve = le.context,
                  Oe = ve.gl;
                for (const lt of ge) {
                  const it = ce.getTile(lt),
                    st = it.dem;
                  if (!st || !st.data || !it.needsHillshadePrepare) continue;
                  const ct = st.dim,
                    nr = st.stride,
                    lr = st.getPixels();
                  if (ve.activeTexture.set(Oe.TEXTURE1), ve.pixelStoreUnpackPremultiplyAlpha.set(!1), it.demTexture = it.demTexture || le.getTileTexture(nr), it.demTexture) {
                    const qr = it.demTexture;
                    qr.update(lr, {
                      premultiply: !1
                    }), qr.bind(Oe.NEAREST, Oe.CLAMP_TO_EDGE)
                  } else it.demTexture = new s.T(ve, lr, Oe.RGBA, {
                    premultiply: !1
                  }), it.demTexture.bind(Oe.NEAREST, Oe.CLAMP_TO_EDGE);
                  ve.activeTexture.set(Oe.TEXTURE0);
                  let Bt = it.fbo;
                  if (!Bt) {
                    const qr = new s.T(ve, {
                      width: ct,
                      height: ct,
                      data: null
                    }, Oe.RGBA);
                    qr.bind(Oe.LINEAR, Oe.CLAMP_TO_EDGE), Bt = it.fbo = ve.createFramebuffer(ct, ct, !0, !1), Bt.colorAttachment.set(qr.texture)
                  }
                  ve.bindFramebuffer.set(Bt.framebuffer), ve.viewport.set([0, 0, ct, ct]), le.useProgram("hillshadePrepare").draw(ve, Oe.TRIANGLES, fe, Me, Ee, gi.disabled, js(it.tileID, st), null, null, Pe.id, le.rasterBoundsBuffer, le.quadTriangleIndexBuffer, le.rasterBoundsSegments), it.needsHillshadePrepare = !1
                }
              })(g, w, A, S, Y, Li.disabled, se), R.viewport.set([0, 0, g.width, g.height]);
              else if (g.renderPass === "translucent")
                if (U) {
                  const [le, ce, ge] = g.stencilConfigForOverlapTwoPass(A);
                  da(g, w, S, ge, le, Y, se, !1, F), da(g, w, S, ge, ce, Y, se, !0, F)
                } else {
                  const [le, ce] = g.getStencilConfigForOverlapAndUpdateStencilID(A);
                  da(g, w, S, ce, le, Y, se, !1, F)
                }
            })(e, a, o, c, d) : s.cm(o) ? (function(g, w, S, A, E) {
              if (g.renderPass !== "translucent" || !A.length) return;
              const {
                isRenderingToTexture: F
              } = E, R = g.style.projection.useSubdivision, U = g.getDepthModeForSublayer(0, _i.ReadOnly), Y = g.colorModeForRenderPass();
              if (R) {
                const [se, le, ce] = g.stencilConfigForOverlapTwoPass(A);
                ls(g, w, S, ce, se, U, Y, !1, F), ls(g, w, S, ce, le, U, Y, !0, F)
              } else {
                const [se, le] = g.getStencilConfigForOverlapAndUpdateStencilID(A);
                ls(g, w, S, le, se, U, Y, !1, F)
              }
            })(e, a, o, c, d) : s.bN(o) ? (function(g, w, S, A, E) {
              if (g.renderPass !== "translucent" || S.paint.get("raster-opacity") === 0 || !A.length) return;
              const {
                isRenderingToTexture: F
              } = E, R = w.getSource(), U = g.style.projection.useSubdivision;
              if (R instanceof wr) wo(g, w, S, A, null, !1, !1, R.tileCoords, R.flippedWindingOrder, F);
              else if (U) {
                const [Y, se, le] = g.stencilConfigForOverlapTwoPass(A);
                wo(g, w, S, le, Y, !1, !0, mn, !1, F), wo(g, w, S, le, se, !0, !0, mn, !1, F)
              } else {
                const [Y, se] = g.getStencilConfigForOverlapAndUpdateStencilID(A);
                wo(g, w, S, se, Y, !1, !0, mn, !1, F)
              }
            })(e, a, o, c, d) : s.cn(o) ? (function(g, w, S, A, E) {
              const F = S.paint.get("background-color"),
                R = S.paint.get("background-opacity");
              if (R === 0) return;
              const {
                isRenderingToTexture: U
              } = E, Y = g.context, se = Y.gl, le = g.style.projection, ce = g.transform, ge = ce.tileSize, Pe = S.paint.get("background-pattern");
              if (g.isPatternMissing(Pe)) return;
              const fe = !Pe && F.a === 1 && R === 1 && g.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (g.renderPass !== fe) return;
              const Me = Li.disabled,
                Ee = g.getDepthModeForSublayer(0, fe === "opaque" ? _i.ReadWrite : _i.ReadOnly),
                ve = g.colorModeForRenderPass(),
                Oe = g.useProgram(Pe ? "backgroundPattern" : "background"),
                lt = A || He(ce, {
                  tileSize: ge,
                  terrain: g.style.map.terrain
                });
              Pe && (Y.activeTexture.set(se.TEXTURE0), g.imageManager.bind(g.context));
              const it = S.getCrossfadeParameters();
              for (const st of lt) {
                const ct = ce.getProjectionData({
                    overscaledTileID: st,
                    applyGlobeMatrix: !U,
                    applyTerrainMatrix: !0
                  }),
                  nr = Pe ? $c(R, g, Pe, {
                    tileID: st,
                    tileSize: ge
                  }, it) : Hc(R, F),
                  lr = g.style.map.terrain && g.style.map.terrain.getTerrainData(st),
                  Bt = le.getMeshFromTileID(Y, st.canonical, !1, !0, "raster");
                Oe.draw(Y, se.TRIANGLES, Ee, Me, ve, gi.backCCW, nr, lr, ct, S.id, Bt.vertexBuffer, Bt.indexBuffer, Bt.segments)
              }
            })(e, 0, o, c, d) : s.co(o) && (function(g, w, S, A) {
              const {
                isRenderingGlobe: E
              } = A, F = g.context, R = S.implementation, U = g.style.projection, Y = g.transform, se = Y.getProjectionDataForCustomLayer(E), le = {
                farZ: Y.farZ,
                nearZ: Y.nearZ,
                fov: Y.fov * Math.PI / 180,
                modelViewProjectionMatrix: Y.modelViewProjectionMatrix,
                projectionMatrix: Y.projectionMatrix,
                shaderData: {
                  variantName: U.shaderVariantName,
                  vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${U.shaderPreludeCode.vertexSource}`,
                  define: U.shaderDefine
                },
                defaultProjectionData: se
              }, ce = R.renderingMode ? R.renderingMode : "2d";
              if (g.renderPass === "offscreen") {
                const ge = R.prerender;
                ge && (g.setCustomLayerDefaults(), F.setColorMode(g.colorModeForRenderPass()), ge.call(R, F.gl, le), F.setDirty(), g.setBaseState())
              } else if (g.renderPass === "translucent") {
                g.setCustomLayerDefaults(), F.setColorMode(g.colorModeForRenderPass()), F.setStencilMode(Li.disabled);
                const ge = ce === "3d" ? g.getDepthModeFor3D() : g.getDepthModeForSublayer(0, _i.ReadOnly);
                F.setDepthMode(ge), R.render(F.gl, le), F.setDirty(), g.setBaseState(), F.bindFramebuffer.set(null)
              }
            })(e, 0, o, d))
          }
          saveTileTexture(e) {
            const a = this._tileTextures[e.size[0]];
            a ? a.push(e) : this._tileTextures[e.size[0]] = [e]
          }
          getTileTexture(e) {
            const a = this._tileTextures[e];
            return a && a.length > 0 ? a.pop() : null
          }
          isPatternMissing(e) {
            if (!e) return !1;
            if (!e.from || !e.to) return !0;
            const a = this.imageManager.getPattern(e.from.toString()),
              o = this.imageManager.getPattern(e.to.toString());
            return !a || !o
          }
          useProgram(e, a, o = !1, c = []) {
            this.cache = this.cache || {};
            const d = !!this.style.map.terrain,
              g = this.style.projection,
              w = o ? Ir.projectionMercator : g.shaderPreludeCode,
              S = o ? Ei : g.shaderDefine,
              A = e + (a ? a.cacheKey : "") + `/${o?Si:g.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (d ? "/terrain" : "") + (c ? `/${c.join("/")}` : "");
            return this.cache[A] || (this.cache[A] = new No(this.context, Ir[e], a, Zh[e], this._showOverdrawInspector, d, w, S, c)), this.cache[A]
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault()
          }
          setBaseState() {
            const e = this.context.gl;
            this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD)
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new s.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA))
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy()
          }
          overLimit() {
            const {
              drawingBufferWidth: e,
              drawingBufferHeight: a
            } = this.context.gl;
            return this.width !== e || this.height !== a
          }
        }

        function cu(h, e) {
          let a, o = !1,
            c = null,
            d = null;
          const g = () => {
            c = null, o && (h.apply(d, a), c = setTimeout(g, e), o = !1)
          };
          return (...w) => (o = !0, d = this, a = w, c || g(), c)
        }
        class uu {
          constructor(e) {
            this._getCurrentHash = () => {
              const a = window.location.hash.replace("#", "");
              if (this._hashName) {
                let o;
                return a.split("&").map((c => c.split("="))).forEach((c => {
                  c[0] === this._hashName && (o = c)
                })), (o && o[1] || "").split("/")
              }
              return a.split("/")
            }, this._onHashChange = () => {
              const a = this._getCurrentHash();
              if (!this._isValidHash(a)) return !1;
              const o = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(a[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({
                center: [+a[2], +a[1]],
                zoom: +a[0],
                bearing: o,
                pitch: +(a[4] || 0)
              }), !0
            }, this._updateHashUnthrottled = () => {
              const a = window.location.href.replace(/(#.*)?$/, this.getHashString());
              window.history.replaceState(window.history.state, null, a)
            }, this._removeHash = () => {
              const a = this._getCurrentHash();
              if (a.length === 0) return;
              const o = a.join("/");
              let c = o;
              c.split("&").length > 0 && (c = c.split("&")[0]), this._hashName && (c = `${this._hashName}=${o}`);
              let d = window.location.hash.replace(c, "");
              d.startsWith("#&") ? d = d.slice(0, 1) + d.slice(2) : d === "#" && (d = "");
              let g = window.location.href.replace(/(#.+)?$/, d);
              g = g.replace("&&", "&"), window.history.replaceState(window.history.state, null, g)
            }, this._updateHash = cu(this._updateHashUnthrottled, 300), this._hashName = e && encodeURIComponent(e)
          }
          addTo(e) {
            return this._map = e, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this
          }
          getHashString(e) {
            const a = this._map.getCenter(),
              o = Math.round(100 * this._map.getZoom()) / 100,
              c = Math.ceil((o * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10),
              d = Math.pow(10, c),
              g = Math.round(a.lng * d) / d,
              w = Math.round(a.lat * d) / d,
              S = this._map.getBearing(),
              A = this._map.getPitch();
            let E = "";
            if (E += e ? `/${g}/${w}/${o}` : `${o}/${w}/${g}`, (S || A) && (E += "/" + Math.round(10 * S) / 10), A && (E += `/${Math.round(A)}`), this._hashName) {
              const F = this._hashName;
              let R = !1;
              const U = window.location.hash.slice(1).split("&").map((Y => {
                const se = Y.split("=")[0];
                return se === F ? (R = !0, `${se}=${E}`) : Y
              })).filter((Y => Y));
              return R || U.push(`${F}=${E}`), `#${U.join("&")}`
            }
            return `#${E}`
          }
          _isValidHash(e) {
            if (e.length < 3 || e.some(isNaN)) return !1;
            try {
              new s.U(+e[2], +e[1])
            } catch {
              return !1
            }
            const a = +e[0],
              o = +(e[3] || 0),
              c = +(e[4] || 0);
            return a >= this._map.getMinZoom() && a <= this._map.getMaxZoom() && o >= -180 && o <= 180 && c >= this._map.getMinPitch() && c <= this._map.getMaxPitch()
          }
        }
        const So = {
            linearity: .3,
            easing: s.cp(0, 0, .3, 1)
          },
          sd = s.e({
            deceleration: 2500,
            maxSpeed: 1400
          }, So),
          od = s.e({
            deceleration: 20,
            maxSpeed: 1400
          }, So),
          ld = s.e({
            deceleration: 1e3,
            maxSpeed: 360
          }, So),
          cd = s.e({
            deceleration: 1e3,
            maxSpeed: 90
          }, So),
          Ul = s.e({
            deceleration: 1e3,
            maxSpeed: 360
          }, So);
        class ud {
          constructor(e) {
            this._map = e, this.clear()
          }
          clear() {
            this._inertiaBuffer = []
          }
          record(e) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({
              time: _e(),
              settings: e
            })
          }
          _drainInertiaBuffer() {
            const e = this._inertiaBuffer,
              a = _e();
            for (; e.length > 0 && a - e[0].time > 160;) e.shift()
          }
          _onMoveEnd(e) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const a = {
              zoom: 0,
              bearing: 0,
              pitch: 0,
              roll: 0,
              pan: new s.P(0, 0),
              pinchAround: void 0,
              around: void 0
            };
            for (const {
                settings: d
              }
              of this._inertiaBuffer) a.zoom += d.zoomDelta || 0, a.bearing += d.bearingDelta || 0, a.pitch += d.pitchDelta || 0, a.roll += d.rollDelta || 0, d.panDelta && a.pan._add(d.panDelta), d.around && (a.around = d.around), d.pinchAround && (a.pinchAround = d.pinchAround);
            const o = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time,
              c = {};
            if (a.pan.mag()) {
              const d = ln(a.pan.mag(), o, s.e({}, sd, e || {})),
                g = a.pan.mult(d.amount / a.pan.mag()),
                w = this._map.cameraHelper.handlePanInertia(g, this._map.transform);
              c.center = w.easingCenter, c.offset = w.easingOffset, an(c, d)
            }
            if (a.zoom) {
              const d = ln(a.zoom, o, od);
              c.zoom = this._map.transform.zoom + d.amount, an(c, d)
            }
            if (a.bearing) {
              const d = ln(a.bearing, o, ld);
              c.bearing = this._map.transform.bearing + s.ai(d.amount, -179, 179), an(c, d)
            }
            if (a.pitch) {
              const d = ln(a.pitch, o, cd);
              c.pitch = this._map.transform.pitch + d.amount, an(c, d)
            }
            if (a.roll) {
              const d = ln(a.roll, o, Ul);
              c.roll = this._map.transform.roll + s.ai(d.amount, -179, 179), an(c, d)
            }
            if (c.zoom || c.bearing) {
              const d = a.pinchAround === void 0 ? a.around : a.pinchAround;
              c.around = d ? this._map.unproject(d) : this._map.getCenter()
            }
            return this.clear(), s.e(c, {
              noMoveStart: !0
            })
          }
        }

        function an(h, e) {
          (!h.duration || h.duration < e.duration) && (h.duration = e.duration, h.easing = e.easing)
        }

        function ln(h, e, a) {
          const {
            maxSpeed: o,
            linearity: c,
            deceleration: d
          } = a, g = s.ai(h * c / (e / 1e3), -o, o), w = Math.abs(g) / (d * c);
          return {
            easing: a.easing,
            duration: 1e3 * w,
            amount: g * (w / 2)
          }
        }
        class gn extends s.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, a, o, c = {}) {
            o = o instanceof MouseEvent ? o : new MouseEvent(e, o);
            const d = Z.mousePos(a.getCanvas(), o),
              g = a.unproject(d);
            super(e, s.e({
              point: d,
              lngLat: g,
              originalEvent: o
            }, c)), this._defaultPrevented = !1, this.target = a
          }
        }
        class cn extends s.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, a, o) {
            const c = e === "touchend" ? o.changedTouches : o.touches,
              d = Z.touchPos(a.getCanvasContainer(), c),
              g = d.map((S => a.unproject(S))),
              w = d.reduce(((S, A, E, F) => S.add(A.div(F.length))), new s.P(0, 0));
            super(e, {
              points: d,
              point: w,
              lngLats: g,
              lngLat: a.unproject(w),
              originalEvent: o
            }), this._defaultPrevented = !1
          }
        }
        class hd extends s.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, a, o) {
            super(e, {
              originalEvent: o
            }), this._defaultPrevented = !1
          }
        }
        class Po {
          constructor(e, a) {
            this._map = e, this._clickTolerance = a.clickTolerance
          }
          reset() {
            delete this._mousedownPos
          }
          wheel(e) {
            return this._firePreventable(new hd(e.type, this._map, e))
          }
          mousedown(e, a) {
            return this._mousedownPos = a, this._firePreventable(new gn(e.type, this._map, e))
          }
          mouseup(e) {
            this._map.fire(new gn(e.type, this._map, e))
          }
          click(e, a) {
            this._mousedownPos && this._mousedownPos.dist(a) >= this._clickTolerance || this._map.fire(new gn(e.type, this._map, e))
          }
          dblclick(e) {
            return this._firePreventable(new gn(e.type, this._map, e))
          }
          mouseover(e) {
            this._map.fire(new gn(e.type, this._map, e))
          }
          mouseout(e) {
            this._map.fire(new gn(e.type, this._map, e))
          }
          touchstart(e) {
            return this._firePreventable(new cn(e.type, this._map, e))
          }
          touchmove(e) {
            this._map.fire(new cn(e.type, this._map, e))
          }
          touchend(e) {
            this._map.fire(new cn(e.type, this._map, e))
          }
          touchcancel(e) {
            this._map.fire(new cn(e.type, this._map, e))
          }
          _firePreventable(e) {
            if (this._map.fire(e), e.defaultPrevented) return {}
          }
          isEnabled() {
            return !0
          }
          isActive() {
            return !1
          }
          enable() {}
          disable() {}
        }
        class Jp {
          constructor(e) {
            this._map = e
          }
          reset() {
            this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent
          }
          mousemove(e) {
            this._map.fire(new gn(e.type, this._map, e))
          }
          mousedown() {
            this._delayContextMenu = !0, this._ignoreContextMenu = !1
          }
          mouseup() {
            this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new gn("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent)
          }
          contextmenu(e) {
            this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new gn(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault()
          }
          isEnabled() {
            return !0
          }
          isActive() {
            return !1
          }
          enable() {}
          disable() {}
        }
        class Qo {
          constructor(e) {
            this._map = e
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform
          }
          get center() {
            return {
              lng: this.transform.center.lng,
              lat: this.transform.center.lat
            }
          }
          get zoom() {
            return this.transform.zoom
          }
          get pitch() {
            return this.transform.pitch
          }
          get bearing() {
            return this.transform.bearing
          }
          unproject(e) {
            return this.transform.screenPointToLocation(s.P.convert(e), this._map.terrain)
          }
        }
        class dd {
          constructor(e, a) {
            this._map = e, this._tr = new Qo(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = a.clickTolerance || 1
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active
          }
          enable() {
            this.isEnabled() || (this._enabled = !0)
          }
          disable() {
            this.isEnabled() && (this._enabled = !1)
          }
          mousedown(e, a) {
            this.isEnabled() && e.shiftKey && e.button === 0 && (Z.disableDrag(), this._startPos = this._lastPos = a, this._active = !0)
          }
          mousemoveWindow(e, a) {
            if (!this._active) return;
            const o = a;
            if (this._lastPos.equals(o) || !this._box && o.dist(this._startPos) < this._clickTolerance) return;
            const c = this._startPos;
            this._lastPos = o, this._box || (this._box = Z.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e));
            const d = Math.min(c.x, o.x),
              g = Math.max(c.x, o.x),
              w = Math.min(c.y, o.y),
              S = Math.max(c.y, o.y);
            Z.setTransform(this._box, `translate(${d}px,${w}px)`), this._box.style.width = g - d + "px", this._box.style.height = S - w + "px"
          }
          mouseupWindow(e, a) {
            if (!this._active || e.button !== 0) return;
            const o = this._startPos,
              c = a;
            if (this.reset(), Z.suppressClick(), o.x !== c.x || o.y !== c.y) return this._map.fire(new s.l("boxzoomend", {
              originalEvent: e
            })), {
              cameraAnimation: d => d.fitScreenCoordinates(o, c, this._tr.bearing, {
                linear: !0
              })
            };
            this._fireEvent("boxzoomcancel", e)
          }
          keydown(e) {
            this._active && e.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e))
          }
          reset() {
            this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (Z.remove(this._box), this._box = null), Z.enableDrag(), delete this._startPos, delete this._lastPos
          }
          _fireEvent(e, a) {
            return this._map.fire(new s.l(e, {
              originalEvent: a
            }))
          }
        }

        function hu(h, e) {
          if (h.length !== e.length) throw new Error(`The number of touches and points are not equal - touches ${h.length}, points ${e.length}`);
          const a = {};
          for (let o = 0; o < h.length; o++) a[h[o].identifier] = e[o];
          return a
        }
        class pd {
          constructor(e) {
            this.reset(), this.numTouches = e.numTouches
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1
          }
          touchstart(e, a, o) {
            (this.centroid || o.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = e.timeStamp), o.length === this.numTouches && (this.centroid = (function(c) {
              const d = new s.P(0, 0);
              for (const g of c) d._add(g);
              return d.div(c.length)
            })(a), this.touches = hu(o, a)))
          }
          touchmove(e, a, o) {
            if (this.aborted || !this.centroid) return;
            const c = hu(o, a);
            for (const d in this.touches) {
              const g = c[d];
              (!g || g.dist(this.touches[d]) > 30) && (this.aborted = !0)
            }
          }
          touchend(e, a, o) {
            if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), o.length === 0) {
              const c = !this.aborted && this.centroid;
              if (this.reset(), c) return c
            }
          }
        }
        class Ws {
          constructor(e) {
            this.singleTap = new pd(e), this.numTaps = e.numTaps, this.reset()
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset()
          }
          touchstart(e, a, o) {
            this.singleTap.touchstart(e, a, o)
          }
          touchmove(e, a, o) {
            this.singleTap.touchmove(e, a, o)
          }
          touchend(e, a, o) {
            const c = this.singleTap.touchend(e, a, o);
            if (c) {
              const d = e.timeStamp - this.lastTime < 500,
                g = !this.lastTap || this.lastTap.dist(c) < 30;
              if (d && g || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = c, this.count === this.numTaps) return this.reset(), c
            }
          }
        }
        class cs {
          constructor(e) {
            this._tr = new Qo(e), this._zoomIn = new Ws({
              numTouches: 1,
              numTaps: 2
            }), this._zoomOut = new Ws({
              numTouches: 2,
              numTaps: 1
            }), this.reset()
          }
          reset() {
            this._active = !1, this._zoomIn.reset(), this._zoomOut.reset()
          }
          touchstart(e, a, o) {
            this._zoomIn.touchstart(e, a, o), this._zoomOut.touchstart(e, a, o)
          }
          touchmove(e, a, o) {
            this._zoomIn.touchmove(e, a, o), this._zoomOut.touchmove(e, a, o)
          }
          touchend(e, a, o) {
            const c = this._zoomIn.touchend(e, a, o),
              d = this._zoomOut.touchend(e, a, o),
              g = this._tr;
            return c ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), {
              cameraAnimation: w => w.easeTo({
                duration: 300,
                zoom: g.zoom + 1,
                around: g.unproject(c)
              }, {
                originalEvent: e
              })
            }) : d ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), {
              cameraAnimation: w => w.easeTo({
                duration: 300,
                zoom: g.zoom - 1,
                around: g.unproject(d)
              }, {
                originalEvent: e
              })
            }) : void 0
          }
          touchcancel() {
            this.reset()
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class Mr {
          constructor(e) {
            this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset()
          }
          reset(e) {
            this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(e)
          }
          _move(...e) {
            const a = this._moveFunction(...e);
            if (a.bearingDelta || a.pitchDelta || a.rollDelta || a.around || a.panDelta) return this._active = !0, a
          }
          dragStart(e, a) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = Array.isArray(a) ? a[0] : a, this._activateOnStart && this._lastPoint && (this._active = !0))
          }
          dragMove(e, a) {
            if (!this.isEnabled()) return;
            const o = this._lastPoint;
            if (!o) return;
            if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) return void this.reset(e);
            const c = Array.isArray(a) ? a[0] : a;
            return !this._moved && c.dist(o) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = c, this._move(o, c))
          }
          dragEnd(e) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && Z.suppressClick(), this.reset(e))
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
          getClickTolerance() {
            return this._clickTolerance
          }
        }
        const fd = 0,
          du = 2,
          md = {
            [fd]: 1,
            [du]: 2
          };
        class us {
          constructor(e) {
            this._correctEvent = e.checkCorrectEvent
          }
          startMove(e) {
            const a = Z.mouseButton(e);
            this._eventButton = a
          }
          endMove(e) {
            delete this._eventButton
          }
          isValidStartEvent(e) {
            return this._correctEvent(e)
          }
          isValidMoveEvent(e) {
            return !(function(a, o) {
              const c = md[o];
              return a.buttons === void 0 || (a.buttons & c) !== c
            })(e, this._eventButton)
          }
          isValidEndEvent(e) {
            return Z.mouseButton(e) === this._eventButton
          }
        }
        class el {
          constructor() {
            this._firstTouch = void 0
          }
          _isOneFingerTouch(e) {
            return e.targetTouches.length === 1
          }
          _isSameTouchEvent(e) {
            return e.targetTouches[0].identifier === this._firstTouch
          }
          startMove(e) {
            this._firstTouch = e.targetTouches[0].identifier
          }
          endMove(e) {
            delete this._firstTouch
          }
          isValidStartEvent(e) {
            return this._isOneFingerTouch(e)
          }
          isValidMoveEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e)
          }
          isValidEndEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e)
          }
        }
        class pu {
          constructor(e = new us({
            checkCorrectEvent: () => !0
          }), a = new el) {
            this.mouseMoveStateManager = e, this.oneFingerTouchMoveStateManager = a
          }
          _executeRelevantHandler(e, a, o) {
            return e instanceof MouseEvent ? a(e) : typeof TouchEvent < "u" && e instanceof TouchEvent ? o(e) : void 0
          }
          startMove(e) {
            this._executeRelevantHandler(e, (a => this.mouseMoveStateManager.startMove(a)), (a => this.oneFingerTouchMoveStateManager.startMove(a)))
          }
          endMove(e) {
            this._executeRelevantHandler(e, (a => this.mouseMoveStateManager.endMove(a)), (a => this.oneFingerTouchMoveStateManager.endMove(a)))
          }
          isValidStartEvent(e) {
            return this._executeRelevantHandler(e, (a => this.mouseMoveStateManager.isValidStartEvent(a)), (a => this.oneFingerTouchMoveStateManager.isValidStartEvent(a)))
          }
          isValidMoveEvent(e) {
            return this._executeRelevantHandler(e, (a => this.mouseMoveStateManager.isValidMoveEvent(a)), (a => this.oneFingerTouchMoveStateManager.isValidMoveEvent(a)))
          }
          isValidEndEvent(e) {
            return this._executeRelevantHandler(e, (a => this.mouseMoveStateManager.isValidEndEvent(a)), (a => this.oneFingerTouchMoveStateManager.isValidEndEvent(a)))
          }
        }
        const Di = h => {
          h.mousedown = h.dragStart, h.mousemoveWindow = h.dragMove, h.mouseup = h.dragEnd, h.contextmenu = e => {
            e.preventDefault()
          }
        };
        class fu {
          constructor(e, a) {
            this._clickTolerance = e.clickTolerance || 1, this._map = a, this.reset()
          }
          reset() {
            this._active = !1, this._touches = {}, this._sum = new s.P(0, 0)
          }
          _shouldBePrevented(e) {
            return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1)
          }
          touchstart(e, a, o) {
            return this._calculateTransform(e, a, o)
          }
          touchmove(e, a, o) {
            if (this._active) {
              if (!this._shouldBePrevented(o.length)) return e.preventDefault(), this._calculateTransform(e, a, o);
              this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e)
            }
          }
          touchend(e, a, o) {
            this._calculateTransform(e, a, o), this._active && this._shouldBePrevented(o.length) && this.reset()
          }
          touchcancel() {
            this.reset()
          }
          _calculateTransform(e, a, o) {
            o.length > 0 && (this._active = !0);
            const c = hu(o, a),
              d = new s.P(0, 0),
              g = new s.P(0, 0);
            let w = 0;
            for (const A in c) {
              const E = c[A],
                F = this._touches[A];
              F && (d._add(E), g._add(E.sub(F)), w++, c[A] = E)
            }
            if (this._touches = c, this._shouldBePrevented(w) || !g.mag()) return;
            const S = g.div(w);
            return this._sum._add(S), this._sum.mag() < this._clickTolerance ? void 0 : {
              around: d.div(w),
              panDelta: S
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class mu {
          constructor() {
            this.reset()
          }
          reset() {
            this._active = !1, delete this._firstTwoTouches
          }
          touchstart(e, a, o) {
            this._firstTwoTouches || o.length < 2 || (this._firstTwoTouches = [o[0].identifier, o[1].identifier], this._start([a[0], a[1]]))
          }
          touchmove(e, a, o) {
            if (!this._firstTwoTouches) return;
            e.preventDefault();
            const [c, d] = this._firstTwoTouches, g = Mo(o, a, c), w = Mo(o, a, d);
            if (!g || !w) return;
            const S = this._aroundCenter ? null : g.add(w).div(2);
            return this._move([g, w], S, e)
          }
          touchend(e, a, o) {
            if (!this._firstTwoTouches) return;
            const [c, d] = this._firstTwoTouches, g = Mo(o, a, c), w = Mo(o, a, d);
            g && w || (this._active && Z.suppressClick(), this.reset())
          }
          touchcancel() {
            this.reset()
          }
          enable(e) {
            this._enabled = !0, this._aroundCenter = !!e && e.around === "center"
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active
          }
        }

        function Mo(h, e, a) {
          for (let o = 0; o < h.length; o++)
            if (h[o].identifier === a) return e[o]
        }

        function gd(h, e) {
          return Math.log(h / e) / Math.LN2
        }
        class _d extends mu {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance
          }
          _start(e) {
            this._startDistance = this._distance = e[0].dist(e[1])
          }
          _move(e, a) {
            const o = this._distance;
            if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(gd(this._distance, this._startDistance)) < .1)) return this._active = !0, {
              zoomDelta: gd(this._distance, o),
              pinchAround: a
            }
          }
        }

        function gu(h, e) {
          return 180 * h.angleWith(e) / Math.PI
        }
        class Gl extends mu {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector
          }
          _start(e) {
            this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1])
          }
          _move(e, a, o) {
            const c = this._vector;
            if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, {
              bearingDelta: gu(this._vector, c),
              pinchAround: a
            }
          }
          _isBelowThreshold(e) {
            this._minDiameter = Math.min(this._minDiameter, e.mag());
            const a = 25 / (Math.PI * this._minDiameter) * 360,
              o = gu(e, this._startVector);
            return Math.abs(o) < a
          }
        }

        function Wl(h) {
          return Math.abs(h.y) > Math.abs(h.x)
        }
        class vd extends mu {
          constructor(e) {
            super(), this._currentTouchCount = 0, this._map = e
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints
          }
          touchstart(e, a, o) {
            super.touchstart(e, a, o), this._currentTouchCount = o.length
          }
          _start(e) {
            this._lastPoints = e, Wl(e[0].sub(e[1])) && (this._valid = !1)
          }
          _move(e, a, o) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
            const c = e[0].sub(this._lastPoints[0]),
              d = e[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(c, d, o.timeStamp), this._valid ? (this._lastPoints = e, this._active = !0, {
              pitchDelta: (c.y + d.y) / 2 * -.5
            }) : void 0
          }
          gestureBeginsVertically(e, a, o) {
            if (this._valid !== void 0) return this._valid;
            const c = e.mag() >= 2,
              d = a.mag() >= 2;
            if (!c && !d) return;
            if (!c || !d) return this._firstMove === void 0 && (this._firstMove = o), o - this._firstMove < 100 && void 0;
            const g = e.y > 0 == a.y > 0;
            return Wl(e) && Wl(a) && g
          }
        }
        const yd = {
          panStep: 100,
          bearingStep: 15,
          pitchStep: 10
        };
        class xd {
          constructor(e) {
            this._tr = new Qo(e);
            const a = yd;
            this._panStep = a.panStep, this._bearingStep = a.bearingStep, this._pitchStep = a.pitchStep, this._rotationDisabled = !1
          }
          reset() {
            this._active = !1
          }
          keydown(e) {
            if (e.altKey || e.ctrlKey || e.metaKey) return;
            let a = 0,
              o = 0,
              c = 0,
              d = 0,
              g = 0;
            switch (e.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                a = 1;
                break;
              case 189:
              case 109:
              case 173:
                a = -1;
                break;
              case 37:
                e.shiftKey ? o = -1 : (e.preventDefault(), d = -1);
                break;
              case 39:
                e.shiftKey ? o = 1 : (e.preventDefault(), d = 1);
                break;
              case 38:
                e.shiftKey ? c = 1 : (e.preventDefault(), g = -1);
                break;
              case 40:
                e.shiftKey ? c = -1 : (e.preventDefault(), g = 1);
                break;
              default:
                return
            }
            return this._rotationDisabled && (o = 0, c = 0), {
              cameraAnimation: w => {
                const S = this._tr;
                w.easeTo({
                  duration: 300,
                  easeId: "keyboardHandler",
                  easing: Qp,
                  zoom: a ? Math.round(S.zoom) + a * (e.shiftKey ? 2 : 1) : S.zoom,
                  bearing: S.bearing + o * this._bearingStep,
                  pitch: S.pitch + c * this._pitchStep,
                  offset: [-d * this._panStep, -g * this._panStep],
                  center: S.center
                }, {
                  originalEvent: e
                })
              }
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
          disableRotation() {
            this._rotationDisabled = !0
          }
          enableRotation() {
            this._rotationDisabled = !1
          }
        }

        function Qp(h) {
          return h * (2 - h)
        }
        const hs = 4.000244140625,
          Ji = 1 / 450;
        class bd {
          constructor(e, a) {
            this._onTimeout = o => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(o)
            }, this._map = e, this._tr = new Qo(e), this._triggerRenderFrame = a, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = Ji
          }
          setZoomRate(e) {
            this._defaultZoomRate = e
          }
          setWheelZoomRate(e) {
            this._wheelZoomRate = e
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active || this._finishTimeout !== void 0
          }
          isZooming() {
            return !!this._zooming
          }
          enable(e) {
            this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && e.around === "center")
          }
          disable() {
            this.isEnabled() && (this._enabled = !1)
          }
          _shouldBePrevented(e) {
            return !!this._map.cooperativeGestures.isEnabled() && !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e))
          }
          wheel(e) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(e)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e);
            let a = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;
            const o = _e(),
              c = o - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = o, a !== 0 && a % hs == 0 ? this._type = "wheel" : a !== 0 && Math.abs(a) < 4 ? this._type = "trackpad" : c > 400 ? (this._type = null, this._lastValue = a, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(c * a) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, a += this._lastValue)), e.shiftKey && a && (a /= 4), this._type && (this._lastWheelEvent = e, this._delta -= a, this._active || this._start(e)), e.preventDefault()
          }
          _start(e) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const a = Z.mousePos(this._map.getCanvas(), e),
              o = this._tr;
            this._aroundPoint = this._aroundCenter ? o.transform.locationToScreenPoint(s.U.convert(o.center)) : a, this._frameId || (this._frameId = !0, this._triggerRenderFrame())
          }
          renderFrame() {
            if (!this._frameId || (this._frameId = null, !this.isActive())) return;
            const e = this._tr.transform;
            if (typeof this._lastExpectedZoom == "number") {
              const w = e.zoom - this._lastExpectedZoom;
              typeof this._startZoom == "number" && (this._startZoom += w), typeof this._targetZoom == "number" && (this._targetZoom += w)
            }
            if (this._delta !== 0) {
              const w = this._type === "wheel" && Math.abs(this._delta) > hs ? this._wheelZoomRate : this._defaultZoomRate;
              let S = 2 / (1 + Math.exp(-Math.abs(this._delta * w)));
              this._delta < 0 && S !== 0 && (S = 1 / S);
              const A = typeof this._targetZoom != "number" ? e.scale : s.al(this._targetZoom);
              this._targetZoom = e.constrain(e.getCameraLngLat(), s.ao(A * S)).zoom, this._type === "wheel" && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0
            }
            const a = typeof this._targetZoom != "number" ? e.zoom : this._targetZoom,
              o = this._startZoom,
              c = this._easing;
            let d, g = !1;
            if (this._type === "wheel" && o && c) {
              const w = _e() - this._lastWheelEventTime,
                S = Math.min((w + 5) / 200, 1),
                A = c(S);
              d = s.F.number(o, a, A), S < 1 ? this._frameId || (this._frameId = !0) : g = !0
            } else d = a, g = !0;
            return this._active = !0, g && (this._active = !1, this._finishTimeout = setTimeout((() => {
              this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout
            }), 200)), this._lastExpectedZoom = d, {
              noInertia: !0,
              needsRenderFrame: !g,
              zoomDelta: d - e.zoom,
              around: this._aroundPoint,
              originalEvent: this._lastWheelEvent
            }
          }
          _smoothOutEasing(e) {
            let a = s.cr;
            if (this._prevEase) {
              const o = this._prevEase,
                c = (_e() - o.start) / o.duration,
                d = o.easing(c + .01) - o.easing(c),
                g = .27 / Math.sqrt(d * d + 1e-4) * .01,
                w = Math.sqrt(.0729 - g * g);
              a = s.cp(g, w, .25, 1)
            }
            return this._prevEase = {
              start: _e(),
              duration: e,
              easing: a
            }, a
          }
          reset() {
            this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout)
          }
        }
        class tl {
          constructor(e, a) {
            this._clickZoom = e, this._tapZoom = a
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable()
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable()
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled()
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive()
          }
        }
        class _u {
          constructor(e) {
            this._tr = new Qo(e), this.reset()
          }
          reset() {
            this._active = !1
          }
          dblclick(e, a) {
            return e.preventDefault(), {
              cameraAnimation: o => {
                o.easeTo({
                  duration: 300,
                  zoom: this._tr.zoom + (e.shiftKey ? -1 : 1),
                  around: this._tr.unproject(a)
                }, {
                  originalEvent: e
                })
              }
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class wd {
          constructor() {
            this._tap = new Ws({
              numTouches: 1,
              numTaps: 1
            }), this.reset()
          }
          reset() {
            this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset()
          }
          touchstart(e, a, o) {
            if (!this._swipePoint)
              if (this._tapTime) {
                const c = a[0],
                  d = e.timeStamp - this._tapTime < 500,
                  g = this._tapPoint.dist(c) < 30;
                d && g ? o.length > 0 && (this._swipePoint = c, this._swipeTouch = o[0].identifier) : this.reset()
              } else this._tap.touchstart(e, a, o)
          }
          touchmove(e, a, o) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (o[0].identifier !== this._swipeTouch) return;
                const c = a[0],
                  d = c.y - this._swipePoint.y;
                return this._swipePoint = c, e.preventDefault(), this._active = !0, {
                  zoomDelta: d / 128
                }
              }
            } else this._tap.touchmove(e, a, o)
          }
          touchend(e, a, o) {
            if (this._tapTime) this._swipePoint && o.length === 0 && this.reset();
            else {
              const c = this._tap.touchend(e, a, o);
              c && (this._tapTime = e.timeStamp, this._tapPoint = c)
            }
          }
          touchcancel() {
            this.reset()
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class vu {
          constructor(e, a, o) {
            this._el = e, this._mousePan = a, this._touchPan = o
          }
          enable(e) {
            this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan")
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan")
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled()
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive()
          }
        }
        class yu {
          constructor(e, a, o, c) {
            this._pitchWithRotate = e.pitchWithRotate, this._rollEnabled = e.rollEnabled, this._mouseRotate = a, this._mousePitch = o, this._mouseRoll = c
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable()
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable()
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled())
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive()
          }
        }
        class Td {
          constructor(e, a, o, c) {
            this._el = e, this._touchZoom = a, this._touchRotate = o, this._tapDragZoom = c, this._rotationDisabled = !1, this._enabled = !0
          }
          enable(e) {
            this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate")
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate")
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled()
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive()
          }
          disableRotation() {
            this._rotationDisabled = !0, this._touchRotate.disable()
          }
          enableRotation() {
            this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable()
          }
        }
        class Nn {
          constructor(e, a) {
            this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = e, this._options = a, this._enabled = !1
          }
          isActive() {
            return !1
          }
          reset() {}
          _setupUI() {
            if (this._container) return;
            const e = this._map.getCanvasContainer();
            e.classList.add("maplibregl-cooperative-gestures"), this._container = Z.create("div", "maplibregl-cooperative-gesture-screen", e);
            let a = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            this._bypassKey === "metaKey" && (a = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const o = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"),
              c = document.createElement("div");
            c.className = "maplibregl-desktop-message", c.textContent = a, this._container.appendChild(c);
            const d = document.createElement("div");
            d.className = "maplibregl-mobile-message", d.textContent = o, this._container.appendChild(d), this._container.setAttribute("aria-hidden", "true")
          }
          _destroyUI() {
            this._container && (Z.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container
          }
          enable() {
            this._setupUI(), this._enabled = !0
          }
          disable() {
            this._enabled = !1, this._destroyUI()
          }
          isEnabled() {
            return this._enabled
          }
          isBypassed(e) {
            return e[this._bypassKey]
          }
          notifyGestureBlocked(e, a) {
            this._enabled && (this._map.fire(new s.l("cooperativegestureprevented", {
              gestureType: e,
              originalEvent: a
            })), this._container.classList.add("maplibregl-show"), setTimeout((() => {
              this._container.classList.remove("maplibregl-show")
            }), 100))
          }
        }
        const Hs = h => h.zoom || h.drag || h.roll || h.pitch || h.rotate;
        class $r extends s.l {}

        function si(h) {
          return h.panDelta && h.panDelta.mag() || h.zoomDelta || h.bearingDelta || h.pitchDelta || h.rollDelta
        }
        class rl {
          constructor(e, a) {
            this.handleWindowEvent = c => {
              this.handleEvent(c, `${c.type}Window`)
            }, this.handleEvent = (c, d) => {
              if (c.type === "blur") return void this.stop(!0);
              this._updatingCamera = !0;
              const g = c.type === "renderFrame" ? void 0 : c,
                w = {
                  needsRenderFrame: !1
                },
                S = {},
                A = {};
              for (const {
                  handlerName: R,
                  handler: U,
                  allowed: Y
                }
                of this._handlers) {
                if (!U.isEnabled()) continue;
                let se;
                if (this._blockedByActive(A, Y, R)) U.reset();
                else if (U[d || c.type]) {
                  if (s.cs(c, d || c.type)) {
                    const le = Z.mousePos(this._map.getCanvas(), c);
                    se = U[d || c.type](c, le)
                  } else if (s.ct(c, d || c.type)) {
                    const le = this._getMapTouches(c.touches),
                      ce = Z.touchPos(this._map.getCanvas(), le);
                    se = U[d || c.type](c, ce, le)
                  } else s.cu(d || c.type) || (se = U[d || c.type](c));
                  this.mergeHandlerResult(w, S, se, R, g), se && se.needsRenderFrame && this._triggerRenderFrame()
                }(se || U.isActive()) && (A[R] = U)
              }
              const E = {};
              for (const R in this._previousActiveHandlers) A[R] || (E[R] = g);
              this._previousActiveHandlers = A, (Object.keys(E).length || si(w)) && (this._changes.push([w, S, E]), this._triggerRenderFrame()), (Object.keys(A).length || si(w)) && this._map._stop(!0), this._updatingCamera = !1;
              const {
                cameraAnimation: F
              } = w;
              F && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], F(this._map))
            }, this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new ud(e), this._bearingSnap = a.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(a);
            const o = this._el;
            this._listeners = [
              [o, "touchstart", {
                passive: !0
              }],
              [o, "touchmove", {
                passive: !1
              }],
              [o, "touchend", void 0],
              [o, "touchcancel", void 0],
              [o, "mousedown", void 0],
              [o, "mousemove", void 0],
              [o, "mouseup", void 0],
              [document, "mousemove", {
                capture: !0
              }],
              [document, "mouseup", void 0],
              [o, "mouseover", void 0],
              [o, "mouseout", void 0],
              [o, "dblclick", void 0],
              [o, "click", void 0],
              [o, "keydown", {
                capture: !1
              }],
              [o, "keyup", void 0],
              [o, "wheel", {
                passive: !1
              }],
              [o, "contextmenu", void 0],
              [window, "blur", void 0]
            ];
            for (const [c, d, g] of this._listeners) Z.addEventListener(c, d, c === document ? this.handleWindowEvent : this.handleEvent, g)
          }
          destroy() {
            for (const [e, a, o] of this._listeners) Z.removeEventListener(e, a, e === document ? this.handleWindowEvent : this.handleEvent, o)
          }
          _addDefaultHandlers(e) {
            const a = this._map,
              o = a.getCanvasContainer();
            this._add("mapEvent", new Po(a, e));
            const c = a.boxZoom = new dd(a, e);
            this._add("boxZoom", c), e.interactive && e.boxZoom && c.enable();
            const d = a.cooperativeGestures = new Nn(a, e.cooperativeGestures);
            this._add("cooperativeGestures", d), e.cooperativeGestures && d.enable();
            const g = new cs(a),
              w = new _u(a);
            a.doubleClickZoom = new tl(w, g), this._add("tapZoom", g), this._add("clickZoom", w), e.interactive && e.doubleClickZoom && a.doubleClickZoom.enable();
            const S = new wd;
            this._add("tapDragZoom", S);
            const A = a.touchPitch = new vd(a);
            this._add("touchPitch", A), e.interactive && e.touchPitch && a.touchPitch.enable(e.touchPitch);
            const E = () => a.project(a.getCenter()),
              F = (function({
                enable: fe,
                clickTolerance: Me,
                aroundCenter: Ee = !0,
                minPixelCenterThreshold: ve = 100,
                rotateDegreesPerPixelMoved: Oe = .8
              }, lt) {
                const it = new us({
                  checkCorrectEvent: st => Z.mouseButton(st) === 0 && st.ctrlKey || Z.mouseButton(st) === 2 && !st.ctrlKey
                });
                return new Mr({
                  clickTolerance: Me,
                  move: (st, ct) => {
                    const nr = lt();
                    if (Ee && Math.abs(nr.y - st.y) > ve) return {
                      bearingDelta: s.cq(new s.P(st.x, ct.y), ct, nr)
                    };
                    let lr = (ct.x - st.x) * Oe;
                    return Ee && ct.y < nr.y && (lr = -lr), {
                      bearingDelta: lr
                    }
                  },
                  moveStateManager: it,
                  enable: fe,
                  assignEvents: Di
                })
              })(e, E),
              R = (function({
                enable: fe,
                clickTolerance: Me,
                pitchDegreesPerPixelMoved: Ee = -.5
              }) {
                const ve = new us({
                  checkCorrectEvent: Oe => Z.mouseButton(Oe) === 0 && Oe.ctrlKey || Z.mouseButton(Oe) === 2
                });
                return new Mr({
                  clickTolerance: Me,
                  move: (Oe, lt) => ({
                    pitchDelta: (lt.y - Oe.y) * Ee
                  }),
                  moveStateManager: ve,
                  enable: fe,
                  assignEvents: Di
                })
              })(e),
              U = (function({
                enable: fe,
                clickTolerance: Me,
                rollDegreesPerPixelMoved: Ee = .3
              }, ve) {
                const Oe = new us({
                  checkCorrectEvent: lt => Z.mouseButton(lt) === 2 && lt.ctrlKey
                });
                return new Mr({
                  clickTolerance: Me,
                  move: (lt, it) => {
                    const st = ve();
                    let ct = (it.x - lt.x) * Ee;
                    return it.y < st.y && (ct = -ct), {
                      rollDelta: ct
                    }
                  },
                  moveStateManager: Oe,
                  enable: fe,
                  assignEvents: Di
                })
              })(e, E);
            a.dragRotate = new yu(e, F, R, U), this._add("mouseRotate", F, ["mousePitch"]), this._add("mousePitch", R, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", U, ["mousePitch"]), e.interactive && e.dragRotate && a.dragRotate.enable();
            const Y = (function({
                enable: fe,
                clickTolerance: Me
              }) {
                const Ee = new us({
                  checkCorrectEvent: ve => Z.mouseButton(ve) === 0 && !ve.ctrlKey
                });
                return new Mr({
                  clickTolerance: Me,
                  move: (ve, Oe) => ({
                    around: Oe,
                    panDelta: Oe.sub(ve)
                  }),
                  activateOnStart: !0,
                  moveStateManager: Ee,
                  enable: fe,
                  assignEvents: Di
                })
              })(e),
              se = new fu(e, a);
            a.dragPan = new vu(o, Y, se), this._add("mousePan", Y), this._add("touchPan", se, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && a.dragPan.enable(e.dragPan);
            const le = new Gl,
              ce = new _d;
            a.touchZoomRotate = new Td(o, ce, le, S), this._add("touchRotate", le, ["touchPan", "touchZoom"]), this._add("touchZoom", ce, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && a.touchZoomRotate.enable(e.touchZoomRotate), this._add("blockableMapEvent", new Jp(a));
            const ge = a.scrollZoom = new bd(a, (() => this._triggerRenderFrame()));
            this._add("scrollZoom", ge, ["mousePan"]), e.interactive && e.scrollZoom && a.scrollZoom.enable(e.scrollZoom);
            const Pe = a.keyboard = new xd(a);
            this._add("keyboard", Pe), e.interactive && e.keyboard && a.keyboard.enable()
          }
          _add(e, a, o) {
            this._handlers.push({
              handlerName: e,
              handler: a,
              allowed: o
            }), this._handlersById[e] = a
          }
          stop(e) {
            if (!this._updatingCamera) {
              for (const {
                  handler: a
                }
                of this._handlers) a.reset();
              this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = []
            }
          }
          isActive() {
            for (const {
                handler: e
              }
              of this._handlers)
              if (e.isActive()) return !0;
            return !1
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming()
          }
          isRotating() {
            return !!this._eventsInProgress.rotate
          }
          isMoving() {
            return !!Hs(this._eventsInProgress) || this.isZooming()
          }
          _blockedByActive(e, a, o) {
            for (const c in e)
              if (c !== o && (!a || a.indexOf(c) < 0)) return !0;
            return !1
          }
          _getMapTouches(e) {
            const a = [];
            for (const o of e) this._el.contains(o.target) && a.push(o);
            return a
          }
          mergeHandlerResult(e, a, o, c, d) {
            if (!o) return;
            s.e(e, o);
            const g = {
              handlerName: c,
              originalEvent: o.originalEvent || d
            };
            o.zoomDelta !== void 0 && (a.zoom = g), o.panDelta !== void 0 && (a.drag = g), o.rollDelta !== void 0 && (a.roll = g), o.pitchDelta !== void 0 && (a.pitch = g), o.bearingDelta !== void 0 && (a.rotate = g)
          }
          _applyChanges() {
            const e = {},
              a = {},
              o = {};
            for (const [c, d, g] of this._changes) c.panDelta && (e.panDelta = (e.panDelta || new s.P(0, 0))._add(c.panDelta)), c.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + c.zoomDelta), c.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + c.bearingDelta), c.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + c.pitchDelta), c.rollDelta && (e.rollDelta = (e.rollDelta || 0) + c.rollDelta), c.around !== void 0 && (e.around = c.around), c.pinchAround !== void 0 && (e.pinchAround = c.pinchAround), c.noInertia && (e.noInertia = c.noInertia), s.e(a, d), s.e(o, g);
            this._updateMapTransform(e, a, o), this._changes = []
          }
          _updateMapTransform(e, a, o) {
            const c = this._map,
              d = c._getTransformForUpdate(),
              g = c.terrain;
            if (!(si(e) || g && this._terrainMovement)) return this._fireEvents(a, o, !0);
            c._stop(!0);
            let {
              panDelta: w,
              zoomDelta: S,
              bearingDelta: A,
              pitchDelta: E,
              rollDelta: F,
              around: R,
              pinchAround: U
            } = e;
            U !== void 0 && (R = U), R = R || c.transform.centerPoint, g && !d.isPointOnMapSurface(R) && (R = d.centerPoint);
            const Y = {
              panDelta: w,
              zoomDelta: S,
              rollDelta: F,
              pitchDelta: E,
              bearingDelta: A,
              around: R
            };
            this._map.cameraHelper.useGlobeControls && !d.isPointOnMapSurface(R) && (R = d.centerPoint);
            const se = R.distSqr(d.centerPoint) < .01 ? d.center : d.screenPointToLocation(w ? R.sub(w) : R);
            this._handleMapControls({
              terrain: g,
              tr: d,
              deltasForHelper: Y,
              preZoomAroundLoc: se,
              combinedEventsInProgress: a,
              panDelta: w
            }), c._applyUpdatedTransform(d), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(a, o, !0)
          }
          _handleMapControls({
            terrain: e,
            tr: a,
            deltasForHelper: o,
            preZoomAroundLoc: c,
            combinedEventsInProgress: d,
            panDelta: g
          }) {
            const w = this._map.cameraHelper;
            if (w.handleMapControlsRollPitchBearingZoom(o, a), e) return w.useGlobeControls ? (this._terrainMovement || !d.drag && !d.zoom || (this._terrainMovement = !0, this._map._elevationFreeze = !0), void w.handleMapControlsPan(o, a, c)) : this._terrainMovement || !d.drag && !d.zoom ? void(d.drag && this._terrainMovement && g ? a.setCenter(a.screenPointToLocation(a.centerPoint.sub(g))) : w.handleMapControlsPan(o, a, c)) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, void w.handleMapControlsPan(o, a, c));
            w.handleMapControlsPan(o, a, c)
          }
          _fireEvents(e, a, o) {
            const c = Hs(this._eventsInProgress),
              d = Hs(e),
              g = {};
            for (const F in e) {
              const {
                originalEvent: R
              } = e[F];
              this._eventsInProgress[F] || (g[`${F}start`] = R), this._eventsInProgress[F] = e[F]
            }!c && d && this._fireEvent("movestart", d.originalEvent);
            for (const F in g) this._fireEvent(F, g[F]);
            d && this._fireEvent("move", d.originalEvent);
            for (const F in e) {
              const {
                originalEvent: R
              } = e[F];
              this._fireEvent(F, R)
            }
            const w = {};
            let S;
            for (const F in this._eventsInProgress) {
              const {
                handlerName: R,
                originalEvent: U
              } = this._eventsInProgress[F];
              this._handlersById[R].isActive() || (delete this._eventsInProgress[F], S = a[R] || U, w[`${F}end`] = S)
            }
            for (const F in w) this._fireEvent(F, w[F]);
            const A = Hs(this._eventsInProgress),
              E = (c || d) && !A;
            if (E && this._terrainMovement) {
              this._map._elevationFreeze = !1, this._terrainMovement = !1;
              const F = this._map._getTransformForUpdate();
              this._map.getCenterClampedToGround() && F.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(F)
            }
            if (o && E) {
              this._updatingCamera = !0;
              const F = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),
                R = U => U !== 0 && -this._bearingSnap < U && U < this._bearingSnap;
              !F || !F.essential && oe.prefersReducedMotion ? (this._map.fire(new s.l("moveend", {
                originalEvent: S
              })), R(this._map.getBearing()) && this._map.resetNorth()) : (R(F.bearing || this._map.getBearing()) && (F.bearing = 0), F.freezeElevation = !0, this._map.easeTo(F, {
                originalEvent: S
              })), this._updatingCamera = !1
            }
          }
          _fireEvent(e, a) {
            this._map.fire(new s.l(e, a ? {
              originalEvent: a
            } : {}))
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e => {
              delete this._frameId, this.handleEvent(new $r("renderFrame", {
                timeStamp: e
              })), this._applyChanges()
            }))
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame())
          }
        }
        class Sd extends s.E {
          constructor(e, a, o) {
            super(), this._renderFrameCallback = () => {
              const c = Math.min((_e() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(c)), c < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop()
            }, this._moving = !1, this._zooming = !1, this.transform = e, this._bearingSnap = o.bearingSnap, this.cameraHelper = a, this.on("moveend", (() => {
              delete this._requestedCameraState
            }))
          }
          migrateProjection(e, a) {
            e.apply(this.transform), this.transform = e, this.cameraHelper = a
          }
          getCenter() {
            return new s.U(this.transform.center.lng, this.transform.center.lat)
          }
          setCenter(e, a) {
            return this.jumpTo({
              center: e
            }, a)
          }
          getCenterElevation() {
            return this.transform.elevation
          }
          setCenterElevation(e, a) {
            return this.jumpTo({
              elevation: e
            }, a), this
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround
          }
          setCenterClampedToGround(e) {
            this._centerClampedToGround = e
          }
          panBy(e, a, o) {
            return e = s.P.convert(e).mult(-1), this.panTo(this.transform.center, s.e({
              offset: e
            }, a), o)
          }
          panTo(e, a, o) {
            return this.easeTo(s.e({
              center: e
            }, a), o)
          }
          getZoom() {
            return this.transform.zoom
          }
          setZoom(e, a) {
            return this.jumpTo({
              zoom: e
            }, a), this
          }
          zoomTo(e, a, o) {
            return this.easeTo(s.e({
              zoom: e
            }, a), o)
          }
          zoomIn(e, a) {
            return this.zoomTo(this.getZoom() + 1, e, a), this
          }
          zoomOut(e, a) {
            return this.zoomTo(this.getZoom() - 1, e, a), this
          }
          getVerticalFieldOfView() {
            return this.transform.fov
          }
          setVerticalFieldOfView(e, a) {
            return e != this.transform.fov && (this.transform.setFov(e), this.fire(new s.l("movestart", a)).fire(new s.l("move", a)).fire(new s.l("moveend", a))), this
          }
          getBearing() {
            return this.transform.bearing
          }
          setBearing(e, a) {
            return this.jumpTo({
              bearing: e
            }, a), this
          }
          getPadding() {
            return this.transform.padding
          }
          setPadding(e, a) {
            return this.jumpTo({
              padding: e
            }, a), this
          }
          rotateTo(e, a, o) {
            return this.easeTo(s.e({
              bearing: e
            }, a), o)
          }
          resetNorth(e, a) {
            return this.rotateTo(0, s.e({
              duration: 1e3
            }, e), a), this
          }
          resetNorthPitch(e, a) {
            return this.easeTo(s.e({
              bearing: 0,
              pitch: 0,
              roll: 0,
              duration: 1e3
            }, e), a), this
          }
          snapToNorth(e, a) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, a) : this
          }
          getPitch() {
            return this.transform.pitch
          }
          setPitch(e, a) {
            return this.jumpTo({
              pitch: e
            }, a), this
          }
          getRoll() {
            return this.transform.roll
          }
          setRoll(e, a) {
            return this.jumpTo({
              roll: e
            }, a), this
          }
          cameraForBounds(e, a) {
            e = wt.convert(e).adjustAntiMeridian();
            const o = a && a.bearing || 0;
            return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), o, a)
          }
          _cameraForBoxAndBearing(e, a, o, c) {
            const d = {
              top: 0,
              bottom: 0,
              right: 0,
              left: 0
            };
            if (typeof(c = s.e({
                padding: d,
                offset: [0, 0],
                maxZoom: this.transform.maxZoom
              }, c)).padding == "number") {
              const A = c.padding;
              c.padding = {
                top: A,
                bottom: A,
                right: A,
                left: A
              }
            }
            const g = s.e(d, c.padding);
            c.padding = g;
            const w = this.transform,
              S = new wt(e, a);
            return this.cameraHelper.cameraForBoxAndBearing(c, g, S, o, w)
          }
          fitBounds(e, a, o) {
            return this._fitInternal(this.cameraForBounds(e, a), a, o)
          }
          fitScreenCoordinates(e, a, o, c, d) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(s.P.convert(e)), this.transform.screenPointToLocation(s.P.convert(a)), o, c), c, d)
          }
          _fitInternal(e, a, o) {
            return e ? (delete(a = s.e(e, a)).padding, a.linear ? this.easeTo(a, o) : this.flyTo(a, o)) : this
          }
          jumpTo(e, a) {
            this.stop();
            const o = this._getTransformForUpdate();
            let c = !1,
              d = !1,
              g = !1;
            const w = o.zoom;
            this.cameraHelper.handleJumpToCenterZoom(o, e);
            const S = o.zoom !== w;
            return "elevation" in e && o.elevation !== +e.elevation && o.setElevation(+e.elevation), "bearing" in e && o.bearing !== +e.bearing && (c = !0, o.setBearing(+e.bearing)), "pitch" in e && o.pitch !== +e.pitch && (d = !0, o.setPitch(+e.pitch)), "roll" in e && o.roll !== +e.roll && (g = !0, o.setRoll(+e.roll)), e.padding == null || o.isPaddingEqual(e.padding) || o.setPadding(e.padding), this._applyUpdatedTransform(o), this.fire(new s.l("movestart", a)).fire(new s.l("move", a)), S && this.fire(new s.l("zoomstart", a)).fire(new s.l("zoom", a)).fire(new s.l("zoomend", a)), c && this.fire(new s.l("rotatestart", a)).fire(new s.l("rotate", a)).fire(new s.l("rotateend", a)), d && this.fire(new s.l("pitchstart", a)).fire(new s.l("pitch", a)).fire(new s.l("pitchend", a)), g && this.fire(new s.l("rollstart", a)).fire(new s.l("roll", a)).fire(new s.l("rollend", a)), this.fire(new s.l("moveend", a))
          }
          calculateCameraOptionsFromTo(e, a, o, c = 0) {
            const d = s.a5.fromLngLat(e, a),
              g = s.a5.fromLngLat(o, c),
              w = g.x - d.x,
              S = g.y - d.y,
              A = g.z - d.z,
              E = Math.hypot(w, S, A);
            if (E === 0) throw new Error("Can't calculate camera options with same From and To");
            const F = Math.hypot(w, S),
              R = s.ao(this.transform.cameraToCenterDistance / E / this.transform.tileSize),
              U = 180 * Math.atan2(w, -S) / Math.PI;
            let Y = 180 * Math.acos(F / E) / Math.PI;
            return Y = A < 0 ? 90 - Y : 90 + Y, {
              center: g.toLngLat(),
              elevation: c,
              zoom: R,
              pitch: Y,
              bearing: U
            }
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(e, a, o, c, d) {
            const g = this.transform.calculateCenterFromCameraLngLatAlt(e, a, o, c);
            return {
              center: g.center,
              elevation: g.elevation,
              zoom: g.zoom,
              bearing: o,
              pitch: c,
              roll: d
            }
          }
          easeTo(e, a) {
            this._stop(!1, e.easeId), ((e = s.e({
              offset: [0, 0],
              duration: 500,
              easing: s.cr
            }, e)).animate === !1 || !e.essential && oe.prefersReducedMotion) && (e.duration = 0);
            const o = this._getTransformForUpdate(),
              c = this.getBearing(),
              d = o.pitch,
              g = o.roll,
              w = "bearing" in e ? this._normalizeBearing(e.bearing, c) : c,
              S = "pitch" in e ? +e.pitch : d,
              A = "roll" in e ? this._normalizeBearing(e.roll, g) : g,
              E = "padding" in e ? e.padding : o.padding,
              F = s.P.convert(e.offset);
            let R, U;
            e.around && (R = s.U.convert(e.around), U = o.locationToScreenPoint(R));
            const Y = {
                moving: this._moving,
                zooming: this._zooming,
                rotating: this._rotating,
                pitching: this._pitching,
                rolling: this._rolling
              },
              se = this.cameraHelper.handleEaseTo(o, {
                bearing: w,
                pitch: S,
                roll: A,
                padding: E,
                around: R,
                aroundPoint: U,
                offsetAsPoint: F,
                offset: e.offset,
                zoom: e.zoom,
                center: e.center
              });
            return this._rotating = this._rotating || c !== w, this._pitching = this._pitching || S !== d, this._rolling = this._rolling || A !== g, this._padding = !o.isPaddingEqual(E), this._zooming = this._zooming || se.isZooming, this._easeId = e.easeId, this._prepareEase(a, e.noMoveStart, Y), this.terrain && this._prepareElevation(se.elevationCenter), this._ease((le => {
              se.easeFunc(le), this.terrain && !e.freezeElevation && this._updateElevation(le), this._applyUpdatedTransform(o), this._fireMoveEvents(a)
            }), (le => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(a, le)
            }), e), this
          }
          _prepareEase(e, a, o = {}) {
            this._moving = !0, a || o.moving || this.fire(new s.l("movestart", e)), this._zooming && !o.zooming && this.fire(new s.l("zoomstart", e)), this._rotating && !o.rotating && this.fire(new s.l("rotatestart", e)), this._pitching && !o.pitching && this.fire(new s.l("pitchstart", e)), this._rolling && !o.rolling && this.fire(new s.l("rollstart", e))
          }
          _prepareElevation(e) {
            this._elevationCenter = e, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom), this._elevationFreeze = !0
          }
          _updateElevation(e) {
            this._elevationStart !== void 0 && this._elevationCenter !== void 0 || this._prepareElevation(this.transform.center), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
            const a = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (e < 1 && a !== this._elevationTarget) {
              const o = this._elevationTarget - this._elevationStart;
              this._elevationStart += e * (o - (a - (o * e + this._elevationStart)) / (1 - e)), this._elevationTarget = a
            }
            this.transform.setElevation(s.F.number(this._elevationStart, this._elevationTarget, e))
          }
          _finalizeElevation() {
            this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain)
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform
          }
          _elevateCameraIfInsideTerrain(e) {
            if (!this.terrain && e.elevation >= 0 && e.pitch <= 90) return {};
            const a = e.getCameraLngLat(),
              o = e.getCameraAltitude(),
              c = this.terrain ? this.terrain.getElevationForLngLatZoom(a, e.zoom) : 0;
            if (o < c) {
              const d = this.calculateCameraOptionsFromTo(a, c, e.center, e.elevation);
              return {
                pitch: d.pitch,
                zoom: d.zoom
              }
            }
            return {}
          }
          _applyUpdatedTransform(e) {
            const a = [];
            if (a.push((c => this._elevateCameraIfInsideTerrain(c))), this.transformCameraUpdate && a.push((c => this.transformCameraUpdate(c))), !a.length) return;
            const o = e.clone();
            for (const c of a) {
              const d = o.clone(),
                {
                  center: g,
                  zoom: w,
                  roll: S,
                  pitch: A,
                  bearing: E,
                  elevation: F
                } = c(d);
              g && d.setCenter(g), F !== void 0 && d.setElevation(F), w !== void 0 && d.setZoom(w), S !== void 0 && d.setRoll(S), A !== void 0 && d.setPitch(A), E !== void 0 && d.setBearing(E), o.apply(d)
            }
            this.transform.apply(o)
          }
          _fireMoveEvents(e) {
            this.fire(new s.l("move", e)), this._zooming && this.fire(new s.l("zoom", e)), this._rotating && this.fire(new s.l("rotate", e)), this._pitching && this.fire(new s.l("pitch", e)), this._rolling && this.fire(new s.l("roll", e))
          }
          _afterEase(e, a) {
            if (this._easeId && a && this._easeId === a) return;
            delete this._easeId;
            const o = this._zooming,
              c = this._rotating,
              d = this._pitching,
              g = this._rolling;
            this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, o && this.fire(new s.l("zoomend", e)), c && this.fire(new s.l("rotateend", e)), d && this.fire(new s.l("pitchend", e)), g && this.fire(new s.l("rollend", e)), this.fire(new s.l("moveend", e))
          }
          flyTo(e, a) {
            if (!e.essential && oe.prefersReducedMotion) {
              const ct = s.S(e, ["center", "zoom", "bearing", "pitch", "roll", "elevation", "padding"]);
              return this.jumpTo(ct, a)
            }
            this.stop(), e = s.e({
              offset: [0, 0],
              speed: 1.2,
              curve: 1.42,
              easing: s.cr
            }, e);
            const o = this._getTransformForUpdate(),
              c = o.bearing,
              d = o.pitch,
              g = o.roll,
              w = o.padding,
              S = "bearing" in e ? this._normalizeBearing(e.bearing, c) : c,
              A = "pitch" in e ? +e.pitch : d,
              E = "roll" in e ? this._normalizeBearing(e.roll, g) : g,
              F = "padding" in e ? e.padding : o.padding,
              R = s.P.convert(e.offset);
            let U = o.centerPoint.add(R);
            const Y = o.screenPointToLocation(U),
              se = this.cameraHelper.handleFlyTo(o, {
                bearing: S,
                pitch: A,
                roll: E,
                padding: F,
                locationAtOffset: Y,
                offsetAsPoint: R,
                center: e.center,
                minZoom: e.minZoom,
                zoom: e.zoom
              });
            let le = e.curve;
            const ce = Math.max(o.width, o.height),
              ge = ce / se.scaleOfZoom,
              Pe = se.pixelPathLength;
            typeof se.scaleOfMinZoom == "number" && (le = Math.sqrt(ce / se.scaleOfMinZoom / Pe * 2));
            const fe = le * le;

            function Me(ct) {
              const nr = (ge * ge - ce * ce + (ct ? -1 : 1) * fe * fe * Pe * Pe) / (2 * (ct ? ge : ce) * fe * Pe);
              return Math.log(Math.sqrt(nr * nr + 1) - nr)
            }

            function Ee(ct) {
              return (Math.exp(ct) - Math.exp(-ct)) / 2
            }

            function ve(ct) {
              return (Math.exp(ct) + Math.exp(-ct)) / 2
            }
            const Oe = Me(!1);
            let lt = function(ct) {
                return ve(Oe) / ve(Oe + le * ct)
              },
              it = function(ct) {
                return ce * ((ve(Oe) * (Ee(nr = Oe + le * ct) / ve(nr)) - Ee(Oe)) / fe) / Pe;
                var nr
              },
              st = (Me(!0) - Oe) / le;
            if (Math.abs(Pe) < 2e-6 || !isFinite(st)) {
              if (Math.abs(ce - ge) < 1e-6) return this.easeTo(e, a);
              const ct = ge < ce ? -1 : 1;
              st = Math.abs(Math.log(ge / ce)) / le, it = () => 0, lt = nr => Math.exp(ct * le * nr)
            }
            return e.duration = "duration" in e ? +e.duration : 1e3 * st / ("screenSpeed" in e ? +e.screenSpeed / le : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = !0, this._rotating = c !== S, this._pitching = A !== d, this._rolling = E !== g, this._padding = !o.isPaddingEqual(F), this._prepareEase(a, !1), this.terrain && this._prepareElevation(se.targetCenter), this._ease((ct => {
              const nr = ct * st,
                lr = 1 / lt(nr),
                Bt = it(nr);
              this._rotating && o.setBearing(s.F.number(c, S, ct)), this._pitching && o.setPitch(s.F.number(d, A, ct)), this._rolling && o.setRoll(s.F.number(g, E, ct)), this._padding && (o.interpolatePadding(w, F, ct), U = o.centerPoint.add(R)), se.easeFunc(ct, lr, Bt, U), this.terrain && !e.freezeElevation && this._updateElevation(ct), this._applyUpdatedTransform(o), this._fireMoveEvents(a)
            }), (() => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(a)
            }), e), this
          }
          isEasing() {
            return !!this._easeFrameId
          }
          stop() {
            return this._stop()
          }
          _stop(e, a) {
            var o;
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const c = this._onEaseEnd;
              delete this._onEaseEnd, c.call(this, a)
            }
            return e || (o = this.handlers) === null || o === void 0 || o.stop(!1), this
          }
          _ease(e, a, o) {
            o.animate === !1 || o.duration === 0 ? (e(1), a()) : (this._easeStart = _e(), this._easeOptions = o, this._onEaseFrame = e, this._onEaseEnd = a, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback))
          }
          _normalizeBearing(e, a) {
            e = s.V(e, -180, 180);
            const o = Math.abs(e - a);
            return Math.abs(e - 360 - a) < o && (e -= 360), Math.abs(e + 360 - a) < o && (e += 360), e
          }
          queryTerrainElevation(e) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(s.U.convert(e), this.transform.tileZoom) : null
          }
        }
        const il = {
          compact: !0,
          customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>'
        };
        class nn {
          constructor(e = il) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")))
            }, this._updateData = a => {
              !a || a.sourceDataType !== "metadata" && a.sourceDataType !== "visibility" && a.dataType !== "style" && a.type !== "terrain" || this._updateAttributions()
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"))
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show")
            }, this.options = e
          }
          getDefaultPosition() {
            return "bottom-right"
          }
          onAdd(e) {
            return this._map = e, this._compact = this.options.compact, this._container = Z.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = Z.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = Z.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container
          }
          onRemove() {
            Z.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0
          }
          _setElementTitle(e, a) {
            const o = this._map._getUIString(`AttributionControl.${a}`);
            e.title = o, e.setAttribute("aria-label", o)
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let e = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map((c => typeof c != "string" ? "" : c))) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const c = this._map.style.stylesheet;
              this.styleOwner = c.owner, this.styleId = c.id
            }
            const a = this._map.style.tileManagers;
            for (const c in a) {
              const d = a[c];
              if (d.used || d.usedForTerrain) {
                const g = d.getSource();
                g.attribution && e.indexOf(g.attribution) < 0 && e.push(g.attribution)
              }
            }
            e = e.filter((c => String(c).trim())), e.sort(((c, d) => c.length - d.length)), e = e.filter(((c, d) => {
              for (let g = d + 1; g < e.length; g++)
                if (e[g].indexOf(c) >= 0) return !1;
              return !0
            }));
            const o = e.join(" | ");
            o !== this._attribHTML && (this._attribHTML = o, e.length ? (this._innerContainer.innerHTML = Z.sanitize(o), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null)
          }
        }
        class xu {
          constructor(e = {}) {
            this._updateCompact = () => {
              const a = this._container.children;
              if (a.length) {
                const o = a[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && o.classList.add("maplibregl-compact") : o.classList.remove("maplibregl-compact")
              }
            }, this.options = e
          }
          getDefaultPosition() {
            return "bottom-left"
          }
          onAdd(e) {
            this._map = e, this._compact = this.options && this.options.compact, this._container = Z.create("div", "maplibregl-ctrl");
            const a = Z.create("a", "maplibregl-ctrl-logo");
            return a.target = "_blank", a.rel = "noopener nofollow", a.href = "https://maplibre.org/", a.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), a.setAttribute("rel", "noopener nofollow"), this._container.appendChild(a), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container
          }
          onRemove() {
            Z.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0
          }
        }
        class Un {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1
          }
          add(e) {
            const a = ++this._id;
            return this._queue.push({
              callback: e,
              id: a,
              cancelled: !1
            }), a
          }
          remove(e) {
            const a = this._currentlyRunning,
              o = a ? this._queue.concat(a) : this._queue;
            for (const c of o)
              if (c.id === e) return void(c.cancelled = !0)
          }
          run(e = 0) {
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const a = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const o of a)
              if (!o.cancelled && (o.callback(e), this._cleared)) break;
            this._cleared = !1, this._currentlyRunning = !1
          }
          clear() {
            this._currentlyRunning && (this._cleared = !0), this._queue = []
          }
        }
        var Pd = s.aN([{
          name: "a_pos3d",
          type: "Int16",
          components: 3
        }]);
        class ef extends s.E {
          constructor(e) {
            super(), this._lastTilesetChange = _e(), this.tileManager = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e._source.tileSize * 2 ** this.deltaZoom, e.usedForTerrain = !0, e.tileSize = this.tileSize
          }
          destruct() {
            this.tileManager.usedForTerrain = !1, this.tileManager.tileSize = null
          }
          getSource() {
            return this.tileManager._source
          }
          update(e, a) {
            this.tileManager.update(e, a), this._renderableTilesKeys = [];
            const o = {};
            for (const c of He(e, {
                tileSize: this.tileSize,
                minzoom: this.minzoom,
                maxzoom: this.maxzoom,
                reparseOverscaled: !1,
                terrain: a,
                calculateTileZoom: this.tileManager._source.calculateTileZoom
              })) o[c.key] = !0, this._renderableTilesKeys.push(c.key), this._tiles[c.key] || (c.terrainRttPosMatrix32f = new Float64Array(16), s.c0(c.terrainRttPosMatrix32f, 0, s.a3, s.a3, 0, 0, 1), this._tiles[c.key] = new Q(c, this.tileSize), this._lastTilesetChange = _e());
            for (const c in this._tiles) o[c] || delete this._tiles[c]
          }
          freeRtt(e) {
            for (const a in this._tiles) {
              const o = this._tiles[a];
              (!e || o.tileID.equals(e) || o.tileID.isChildOf(e) || e.isChildOf(o.tileID)) && (o.rtt = [])
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map((e => this.getTileByID(e)))
          }
          getTileByID(e) {
            return this._tiles[e]
          }
          getTerrainCoords(e, a) {
            return a ? this._getTerrainCoordsForTileRanges(e, a) : this._getTerrainCoordsForRegularTile(e)
          }
          _getTerrainCoordsForRegularTile(e) {
            const a = {};
            for (const o of this._renderableTilesKeys) {
              const c = this._tiles[o].tileID,
                d = e.clone(),
                g = s.bd();
              if (c.canonical.equals(e.canonical)) s.c0(g, 0, s.a3, s.a3, 0, 0, 1);
              else if (c.canonical.isChildOf(e.canonical)) {
                const w = c.canonical.z - e.canonical.z,
                  S = c.canonical.x - (c.canonical.x >> w << w),
                  A = c.canonical.y - (c.canonical.y >> w << w),
                  E = s.a3 >> w;
                s.c0(g, 0, E, E, 0, 0, 1), s.N(g, g, [-S * E, -A * E, 0])
              } else {
                if (!e.canonical.isChildOf(c.canonical)) continue;
                {
                  const w = e.canonical.z - c.canonical.z,
                    S = e.canonical.x - (e.canonical.x >> w << w),
                    A = e.canonical.y - (e.canonical.y >> w << w),
                    E = s.a3 >> w;
                  s.c0(g, 0, s.a3, s.a3, 0, 0, 1), s.N(g, g, [S * E, A * E, 0]), s.O(g, g, [1 / 2 ** w, 1 / 2 ** w, 0])
                }
              }
              d.terrainRttPosMatrix32f = new Float32Array(g), a[o] = d
            }
            return a
          }
          _getTerrainCoordsForTileRanges(e, a) {
            const o = {};
            for (const c of this._renderableTilesKeys) {
              const d = this._tiles[c].tileID;
              if (!this._isWithinTileRanges(d, a)) continue;
              const g = e.clone(),
                w = s.bd();
              if (d.canonical.z === e.canonical.z) {
                const S = e.canonical.x - d.canonical.x,
                  A = e.canonical.y - d.canonical.y;
                s.c0(w, 0, s.a3, s.a3, 0, 0, 1), s.N(w, w, [S * s.a3, A * s.a3, 0])
              } else if (d.canonical.z > e.canonical.z) {
                const S = d.canonical.z - e.canonical.z,
                  A = d.canonical.x - (d.canonical.x >> S << S),
                  E = d.canonical.y - (d.canonical.y >> S << S),
                  F = e.canonical.x - (d.canonical.x >> S),
                  R = e.canonical.y - (d.canonical.y >> S),
                  U = s.a3 >> S;
                s.c0(w, 0, U, U, 0, 0, 1), s.N(w, w, [-A * U + F * s.a3, -E * U + R * s.a3, 0])
              } else {
                const S = e.canonical.z - d.canonical.z,
                  A = e.canonical.x - (e.canonical.x >> S << S),
                  E = e.canonical.y - (e.canonical.y >> S << S),
                  F = (e.canonical.x >> S) - d.canonical.x,
                  R = (e.canonical.y >> S) - d.canonical.y,
                  U = s.a3 << S;
                s.c0(w, 0, U, U, 0, 0, 1), s.N(w, w, [A * s.a3 + F * U, E * s.a3 + R * U, 0])
              }
              g.terrainRttPosMatrix32f = new Float32Array(w), o[c] = g
            }
            return o
          }
          getSourceTile(e, a) {
            const o = this.tileManager._source;
            let c = e.overscaledZ - this.deltaZoom;
            if (c > o.maxzoom && (c = o.maxzoom), c < o.minzoom) return null;
            this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(c).key);
            let d = this.tileManager.getTileByID(this._sourceTileCache[e.key]);
            if ((!d || !d.dem) && a)
              for (; c >= o.minzoom && (!d || !d.dem);) d = this.tileManager.getTileByID(e.scaledTo(c--).key);
            return d
          }
          anyTilesAfterTime(e = Date.now()) {
            return this._lastTilesetChange >= e
          }
          _isWithinTileRanges(e, a) {
            return a[e.canonical.z] && e.canonical.x >= a[e.canonical.z].minTileX && e.canonical.x <= a[e.canonical.z].maxTileX && e.canonical.y >= a[e.canonical.z].minTileY && e.canonical.y <= a[e.canonical.z].maxTileY
          }
        }
        class tf {
          constructor(e, a, o) {
            this._meshCache = {}, this.painter = e, this.tileManager = new ef(a), this.options = o, this.exaggeration = typeof o.exaggeration == "number" ? o.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024
          }
          getDEMElevation(e, a, o, c = s.a3) {
            var d;
            if (!(a >= 0 && a < c && o >= 0 && o < c)) return 0;
            const g = this.getTerrainData(e),
              w = (d = g.tile) === null || d === void 0 ? void 0 : d.dem;
            if (!w) return 0;
            const S = s.cv([], [a / c * s.a3, o / c * s.a3], g.u_terrain_matrix),
              A = [S[0] * w.dim, S[1] * w.dim],
              E = Math.floor(A[0]),
              F = Math.floor(A[1]),
              R = A[0] - E,
              U = A[1] - F;
            return w.get(E, F) * (1 - R) * (1 - U) + w.get(E + 1, F) * R * (1 - U) + w.get(E, F + 1) * (1 - R) * U + w.get(E + 1, F + 1) * R * U
          }
          getElevationForLngLatZoom(e, a) {
            if (!s.cw(a, e.wrap())) return 0;
            const {
              tileID: o,
              mercatorX: c,
              mercatorY: d
            } = this._getOverscaledTileIDFromLngLatZoom(e, a);
            return this.getElevation(o, c % s.a3, d % s.a3, s.a3)
          }
          getElevation(e, a, o, c = s.a3) {
            return this.getDEMElevation(e, a, o, c) * this.exaggeration
          }
          getTerrainData(e) {
            if (!this._emptyDemTexture) {
              const c = this.painter.context,
                d = new s.R({
                  width: 1,
                  height: 1
                }, new Uint8Array(4));
              this._emptyDepthTexture = new s.T(c, d, c.gl.RGBA, {
                premultiply: !1
              }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new s.T(c, new s.R({
                width: 1,
                height: 1
              }), c.gl.RGBA, {
                premultiply: !1
              }), this._emptyDemTexture.bind(c.gl.NEAREST, c.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = s.am([])
            }
            const a = this.tileManager.getSourceTile(e, !0);
            if (a && a.dem && (!a.demTexture || a.needsTerrainPrepare)) {
              const c = this.painter.context;
              a.demTexture = this.painter.getTileTexture(a.dem.stride), a.demTexture ? a.demTexture.update(a.dem.getPixels(), {
                premultiply: !1
              }) : a.demTexture = new s.T(c, a.dem.getPixels(), c.gl.RGBA, {
                premultiply: !1
              }), a.demTexture.bind(c.gl.NEAREST, c.gl.CLAMP_TO_EDGE), a.needsTerrainPrepare = !1
            }
            const o = a && a + a.tileID.key + e.key;
            if (o && !this._demMatrixCache[o]) {
              const c = this.tileManager.getSource().maxzoom;
              let d = e.canonical.z - a.tileID.canonical.z;
              e.overscaledZ > e.canonical.z && (e.canonical.z >= c ? d = e.canonical.z - c : s.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const g = e.canonical.x - (e.canonical.x >> d << d),
                w = e.canonical.y - (e.canonical.y >> d << d),
                S = s.cx(new Float64Array(16), [1 / (s.a3 << d), 1 / (s.a3 << d), 0]);
              s.N(S, S, [g * s.a3, w * s.a3, 0]), this._demMatrixCache[e.key] = {
                matrix: S,
                coord: e
              }
            }
            return {
              u_depth: 2,
              u_terrain: 3,
              u_terrain_dim: a && a.dem && a.dem.dim || 1,
              u_terrain_matrix: o ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix,
              u_terrain_unpack: a && a.dem && a.dem.getUnpackVector() || this._emptyDemUnpack,
              u_terrain_exaggeration: this.exaggeration,
              texture: (a && a.demTexture || this._emptyDemTexture).texture,
              depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture,
              tile: a
            }
          }
          getFramebuffer(e) {
            const a = this.painter,
              o = a.width / devicePixelRatio,
              c = a.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === o && this._fbo.height === c || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new s.T(a.context, {
              width: o,
              height: c,
              data: null
            }, a.context.gl.RGBA, {
              premultiply: !1
            }), this._fboCoordsTexture.bind(a.context.gl.NEAREST, a.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new s.T(a.context, {
              width: o,
              height: c,
              data: null
            }, a.context.gl.RGBA, {
              premultiply: !1
            }), this._fboDepthTexture.bind(a.context.gl.NEAREST, a.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = a.context.createFramebuffer(o, c, !0, !1), this._fbo.depthAttachment.set(a.context.createRenderbuffer(a.context.gl.DEPTH_COMPONENT16, o, c))), this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo
          }
          getCoordsTexture() {
            const e = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const a = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let d = 0, g = 0; d < this._coordsTextureSize; d++)
              for (let w = 0; w < this._coordsTextureSize; w++, g += 4) a[g + 0] = 255 & w, a[g + 1] = 255 & d, a[g + 2] = w >> 8 << 4 | d >> 8, a[g + 3] = 0;
            const o = new s.R({
                width: this._coordsTextureSize,
                height: this._coordsTextureSize
              }, new Uint8Array(a.buffer)),
              c = new s.T(e, o, e.gl.RGBA, {
                premultiply: !1
              });
            return c.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = c, c
          }
          pointCoordinate(e) {
            this.painter.maybeDrawDepthAndCoords(!0);
            const a = new Uint8Array(4),
              o = this.painter.context,
              c = o.gl,
              d = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio),
              g = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio),
              w = Math.round(this.painter.height / devicePixelRatio);
            o.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), c.readPixels(d, w - g - 1, 1, 1, c.RGBA, c.UNSIGNED_BYTE, a), o.bindFramebuffer.set(null);
            const S = a[0] + (a[2] >> 4 << 8),
              A = a[1] + ((15 & a[2]) << 8),
              E = this.coordsIndex[255 - a[3]],
              F = E && this.tileManager.getTileByID(E);
            if (!F) return null;
            const R = this._coordsTextureSize,
              U = (1 << F.tileID.canonical.z) * R;
            return new s.a5((F.tileID.canonical.x * R + S) / U + F.tileID.wrap, (F.tileID.canonical.y * R + A) / U, this.getElevation(F.tileID, S, A, R))
          }
          depthAtPoint(e) {
            const a = new Uint8Array(4),
              o = this.painter.context,
              c = o.gl;
            return o.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), c.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, c.RGBA, c.UNSIGNED_BYTE, a), o.bindFramebuffer.set(null), (a[0] / 16777216 + a[1] / 65536 + a[2] / 256 + a[3]) / 256
          }
          getTerrainMesh(e) {
            var a;
            const o = ((a = this.painter.style.projection) === null || a === void 0 ? void 0 : a.transitionState) > 0,
              c = o && e.canonical.y === 0,
              d = o && e.canonical.y === (1 << e.canonical.z) - 1,
              g = `m_${c?"n":""}_${d?"s":""}`;
            if (this._meshCache[g]) return this._meshCache[g];
            const w = this.painter.context,
              S = new s.cy,
              A = new s.aR,
              E = this.meshSize,
              F = s.a3 / E,
              R = E * E;
            for (let ve = 0; ve <= E; ve++)
              for (let Oe = 0; Oe <= E; Oe++) S.emplaceBack(Oe * F, ve * F, 0);
            for (let ve = 0; ve < R; ve += E + 1)
              for (let Oe = 0; Oe < E; Oe++) A.emplaceBack(Oe + ve, E + Oe + ve + 1, E + Oe + ve + 2), A.emplaceBack(Oe + ve, E + Oe + ve + 2, Oe + ve + 1);
            const U = S.length,
              Y = U + (E + 1),
              se = (E + 1) * E,
              le = c ? s.bk : 0,
              ce = c ? 0 : 1,
              ge = d ? s.bl : s.a3,
              Pe = d ? 0 : 1;
            for (let ve = 0; ve <= E; ve++) S.emplaceBack(ve * F, le, ce);
            for (let ve = 0; ve <= E; ve++) S.emplaceBack(ve * F, ge, Pe);
            for (let ve = 0; ve < E; ve++) A.emplaceBack(se + ve, Y + ve, Y + ve + 1), A.emplaceBack(se + ve, Y + ve + 1, se + ve + 1), A.emplaceBack(0 + ve, U + ve + 1, U + ve), A.emplaceBack(0 + ve, 0 + ve + 1, U + ve + 1);
            const fe = S.length,
              Me = fe + 2 * (E + 1);
            for (const ve of [0, 1])
              for (let Oe = 0; Oe <= E; Oe++)
                for (const lt of [0, 1]) S.emplaceBack(ve * s.a3, Oe * F, lt);
            for (let ve = 0; ve < 2 * E; ve += 2) A.emplaceBack(fe + ve, fe + ve + 1, fe + ve + 3), A.emplaceBack(fe + ve, fe + ve + 3, fe + ve + 2), A.emplaceBack(Me + ve, Me + ve + 3, Me + ve + 1), A.emplaceBack(Me + ve, Me + ve + 2, Me + ve + 3);
            const Ee = new Ni(w.createVertexBuffer(S, Pd.members), w.createIndexBuffer(A), s.aQ.simpleSegment(0, 0, S.length, A.length));
            return this._meshCache[g] = Ee, Ee
          }
          getMeshFrameDelta(e) {
            return 2 * Math.PI * s.bx / Math.pow(2, Math.max(e, 0)) / 5
          }
          getMinTileElevationForLngLatZoom(e, a) {
            var o;
            const {
              tileID: c
            } = this._getOverscaledTileIDFromLngLatZoom(e, a);
            return (o = this.getMinMaxElevation(c).minElevation) !== null && o !== void 0 ? o : 0
          }
          getMinMaxElevation(e) {
            const a = this.getTerrainData(e).tile,
              o = {
                minElevation: null,
                maxElevation: null
              };
            return a && a.dem && (o.minElevation = a.dem.min * this.exaggeration, o.maxElevation = a.dem.max * this.exaggeration), o
          }
          _getOverscaledTileIDFromLngLatZoom(e, a) {
            const o = s.a5.fromLngLat(e.wrap()),
              c = (1 << a) * s.a3,
              d = o.x * c,
              g = o.y * c,
              w = Math.floor(d / s.a3),
              S = Math.floor(g / s.a3);
            return {
              tileID: new s.a0(a, 0, a, w, S),
              mercatorX: d,
              mercatorY: g
            }
          }
        }
        class rf {
          constructor(e, a, o) {
            this._context = e, this._size = a, this._tileSize = o, this._objects = [], this._recentlyUsed = [], this._stamp = 0
          }
          destruct() {
            for (const e of this._objects) e.texture.destroy(), e.fbo.destroy()
          }
          _createObject(e) {
            const a = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0),
              o = new s.T(this._context, {
                width: this._tileSize,
                height: this._tileSize,
                data: null
              }, this._context.gl.RGBA);
            return o.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), a.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), a.colorAttachment.set(o.texture), {
              id: e,
              fbo: a,
              texture: o,
              stamp: -1,
              inUse: !1
            }
          }
          getObjectForId(e) {
            return this._objects[e]
          }
          useObject(e) {
            e.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter((a => e.id !== a)), this._recentlyUsed.push(e.id)
          }
          stampObject(e) {
            e.stamp = ++this._stamp
          }
          getOrCreateFreeObject() {
            for (const a of this._recentlyUsed)
              if (!this._objects[a].inUse) return this._objects[a];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const e = this._createObject(this._objects.length);
            return this._objects.push(e), e
          }
          freeObject(e) {
            e.inUse = !1
          }
          freeAllObjects() {
            for (const e of this._objects) this.freeObject(e)
          }
          isFull() {
            return !(this._objects.length < this._size) && this._objects.some((e => !e.inUse)) === !1
          }
        }
        const rs = {
          background: !0,
          fill: !0,
          line: !0,
          raster: !0,
          hillshade: !0,
          "color-relief": !0
        };
        class pa {
          constructor(e, a) {
            this.painter = e, this.terrain = a, this.pool = new rf(e.context, 30, a.tileManager.tileSize * a.qualityFactor)
          }
          destruct() {
            this.pool.destruct()
          }
          getTexture(e) {
            return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture
          }
          prepareForRender(e, a) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.tileManager.getRenderableTiles(), this._renderableLayerIds = e._order.filter((o => !e._layers[o].isHidden(a))), this._coordsAscending = {};
            for (const o in e.tileManagers) {
              this._coordsAscending[o] = {};
              const c = e.tileManagers[o].getVisibleCoordinates(),
                d = e.tileManagers[o].getSource(),
                g = d instanceof wr ? d.terrainTileRanges : null;
              for (const w of c) {
                const S = this.terrain.tileManager.getTerrainCoords(w, g);
                for (const A in S) this._coordsAscending[o][A] || (this._coordsAscending[o][A] = []), this._coordsAscending[o][A].push(S[A])
              }
            }
            this._coordsAscendingStr = {};
            for (const o of e._order) {
              const c = e._layers[o],
                d = c.source;
              if (rs[c.type] && !this._coordsAscendingStr[d]) {
                this._coordsAscendingStr[d] = {};
                for (const g in this._coordsAscending[d]) this._coordsAscendingStr[d][g] = this._coordsAscending[d][g].map((w => w.key)).sort().join()
              }
            }
            for (const o of this._renderableTiles)
              for (const c in this._coordsAscendingStr) {
                const d = this._coordsAscendingStr[c][o.tileID.key];
                d && d !== o.rttCoords[c] && (o.rtt = [])
              }
          }
          renderLayer(e, a) {
            if (e.isHidden(this.painter.transform.zoom)) return !1;
            const o = Object.assign(Object.assign({}, a), {
                isRenderingToTexture: !0
              }),
              c = e.type,
              d = this.painter,
              g = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
            if (rs[c] && (this._prevType && rs[this._prevType] || this._stacks.push([]), this._prevType = c, this._stacks[this._stacks.length - 1].push(e.id), !g)) return !0;
            if (rs[this._prevType] || rs[c] && g) {
              this._prevType = c;
              const w = this._stacks.length - 1,
                S = this._stacks[w] || [];
              for (const A of this._renderableTiles) {
                if (this.pool.isFull() && (lu(this.painter, this.terrain, this._rttTiles, o), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(A), A.rtt[w]) {
                  const F = this.pool.getObjectForId(A.rtt[w].id);
                  if (F.stamp === A.rtt[w].stamp) {
                    this.pool.useObject(F);
                    continue
                  }
                }
                const E = this.pool.getOrCreateFreeObject();
                this.pool.useObject(E), this.pool.stampObject(E), A.rtt[w] = {
                  id: E.id,
                  stamp: E.stamp
                }, d.context.bindFramebuffer.set(E.fbo.framebuffer), d.context.clear({
                  color: s.bi.transparent,
                  stencil: 0
                }), d.currentStencilSource = void 0;
                for (let F = 0; F < S.length; F++) {
                  const R = d.style._layers[S[F]],
                    U = R.source ? this._coordsAscending[R.source][A.tileID.key] : [A.tileID];
                  d.context.viewport.set([0, 0, E.fbo.width, E.fbo.height]), d._renderTileClippingMasks(R, U, !0), d.renderLayer(d, d.style.tileManagers[R.source], R, U, o), R.source && (A.rttCoords[R.source] = this._coordsAscendingStr[R.source][A.tileID.key])
                }
              }
              return lu(this.painter, this.terrain, this._rttTiles, o), this._rttTiles = [], this.pool.freeAllObjects(), rs[c]
            }
            return !1
          }
        }
        const xa = {
            "AttributionControl.ToggleAttribution": "Toggle attribution",
            "AttributionControl.MapFeedback": "Map feedback",
            "FullscreenControl.Enter": "Enter fullscreen",
            "FullscreenControl.Exit": "Exit fullscreen",
            "GeolocateControl.FindMyLocation": "Find my location",
            "GeolocateControl.LocationNotAvailable": "Location not available",
            "LogoControl.Title": "MapLibre logo",
            "Map.Title": "Map",
            "Marker.Title": "Map marker",
            "NavigationControl.ResetBearing": "Reset bearing to north",
            "NavigationControl.ZoomIn": "Zoom in",
            "NavigationControl.ZoomOut": "Zoom out",
            "Popup.Close": "Close popup",
            "ScaleControl.Feet": "ft",
            "ScaleControl.Meters": "m",
            "ScaleControl.Kilometers": "km",
            "ScaleControl.Miles": "mi",
            "ScaleControl.NauticalMiles": "nm",
            "GlobeControl.Enable": "Enable globe",
            "GlobeControl.Disable": "Disable globe",
            "TerrainControl.Enable": "Enable terrain",
            "TerrainControl.Disable": "Disable terrain",
            "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map",
            "CooperativeGesturesHandler.MacHelpText": "Use  + scroll to zoom the map",
            "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map"
          },
          Md = B,
          Io = {
            hash: !1,
            interactive: !0,
            bearingSnap: 7,
            attributionControl: il,
            maplibreLogo: !1,
            refreshExpiredTiles: !0,
            canvasContextAttributes: {
              antialias: !1,
              preserveDrawingBuffer: !1,
              powerPreference: "high-performance",
              failIfMajorPerformanceCaveat: !1,
              desynchronized: !1,
              contextType: void 0
            },
            scrollZoom: !0,
            minZoom: -2,
            maxZoom: 22,
            minPitch: 0,
            maxPitch: 60,
            boxZoom: !0,
            dragRotate: !0,
            dragPan: !0,
            keyboard: !0,
            doubleClickZoom: !0,
            touchZoomRotate: !0,
            touchPitch: !0,
            cooperativeGestures: !1,
            trackResize: !0,
            center: [0, 0],
            elevation: 0,
            zoom: 0,
            bearing: 0,
            pitch: 0,
            roll: 0,
            renderWorldCopies: !0,
            maxTileCacheSize: null,
            maxTileCacheZoomLevels: s.a.MAX_TILE_CACHE_ZOOM_LEVELS,
            transformRequest: null,
            transformCameraUpdate: null,
            transformConstrain: null,
            fadeDuration: 300,
            crossSourceCollisions: !0,
            clickTolerance: 3,
            localIdeographFontFamily: "sans-serif",
            pitchWithRotate: !0,
            rollEnabled: !1,
            validateStyle: !0,
            maxCanvasSize: [4096, 4096],
            cancelPendingTileRequestsWhileZooming: !0,
            centerClampedToGround: !0
          },
          Hl = {
            showCompass: !0,
            showZoom: !0,
            visualizePitch: !1,
            visualizeRoll: !0
          };
        class bu {
          constructor(e, a, o = !1) {
            this.mousedown = d => {
              this.startMove(d, Z.mousePos(this.element, d)), Z.addEventListener(window, "mousemove", this.mousemove), Z.addEventListener(window, "mouseup", this.mouseup)
            }, this.mousemove = d => {
              this.move(d, Z.mousePos(this.element, d))
            }, this.mouseup = d => {
              this._rotatePitchHandler.dragEnd(d), this.offTemp()
            }, this.touchstart = d => {
              d.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = Z.touchPos(this.element, d.targetTouches)[0], this.startMove(d, this._startPos), Z.addEventListener(window, "touchmove", this.touchmove, {
                passive: !1
              }), Z.addEventListener(window, "touchend", this.touchend))
            }, this.touchmove = d => {
              d.targetTouches.length !== 1 ? this.reset() : (this._lastPos = Z.touchPos(this.element, d.targetTouches)[0], this.move(d, this._lastPos))
            }, this.touchend = d => {
              d.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp()
            }, this.reset = () => {
              this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp()
            }, this._clickTolerance = 10, this.element = a;
            const c = new pu;
            this._rotatePitchHandler = new Mr({
              clickTolerance: 3,
              move: (d, g) => {
                const w = a.getBoundingClientRect(),
                  S = new s.P((w.bottom - w.top) / 2, (w.right - w.left) / 2);
                return {
                  bearingDelta: s.cq(new s.P(d.x, g.y), g, S),
                  pitchDelta: o ? -.5 * (g.y - d.y) : void 0
                }
              },
              moveStateManager: c,
              enable: !0,
              assignEvents: () => {}
            }), this.map = e, Z.addEventListener(a, "mousedown", this.mousedown), Z.addEventListener(a, "touchstart", this.touchstart, {
              passive: !1
            }), Z.addEventListener(a, "touchcancel", this.reset)
          }
          startMove(e, a) {
            this._rotatePitchHandler.dragStart(e, a), Z.disableDrag()
          }
          move(e, a) {
            const o = this.map,
              {
                bearingDelta: c,
                pitchDelta: d
              } = this._rotatePitchHandler.dragMove(e, a) || {};
            c && o.setBearing(o.getBearing() + c), d && o.setPitch(o.getPitch() + d)
          }
          off() {
            const e = this.element;
            Z.removeEventListener(e, "mousedown", this.mousedown), Z.removeEventListener(e, "touchstart", this.touchstart, {
              passive: !1
            }), Z.removeEventListener(window, "touchmove", this.touchmove, {
              passive: !1
            }), Z.removeEventListener(window, "touchend", this.touchend), Z.removeEventListener(e, "touchcancel", this.reset), this.offTemp()
          }
          offTemp() {
            Z.enableDrag(), Z.removeEventListener(window, "mousemove", this.mousemove), Z.removeEventListener(window, "mouseup", this.mouseup), Z.removeEventListener(window, "touchmove", this.touchmove, {
              passive: !1
            }), Z.removeEventListener(window, "touchend", this.touchend)
          }
        }
        let ds;

        function $l(h, e, a, o = !1) {
          if (o || !a.getCoveringTilesDetailsProvider().allowWorldCopies()) return h == null ? void 0 : h.wrap();
          const c = new s.U(h.lng, h.lat);
          if (h = new s.U(h.lng, h.lat), e) {
            const d = new s.U(h.lng - 360, h.lat),
              g = new s.U(h.lng + 360, h.lat),
              w = a.locationToScreenPoint(h).distSqr(e);
            a.locationToScreenPoint(d).distSqr(e) < w ? h = d : a.locationToScreenPoint(g).distSqr(e) < w && (h = g)
          }
          for (; Math.abs(h.lng - a.center.lng) > 180;) {
            const d = a.locationToScreenPoint(h);
            if (d.x >= 0 && d.y >= 0 && d.x <= a.width && d.y <= a.height) break;
            h.lng > a.center.lng ? h.lng -= 360 : h.lng += 360
          }
          return h.lng !== c.lng && a.isPointOnMapSurface(a.locationToScreenPoint(h)) ? h : c
        }
        const $s = {
          center: "translate(-50%,-50%)",
          top: "translate(-50%,0)",
          "top-left": "translate(0,0)",
          "top-right": "translate(-100%,0)",
          bottom: "translate(-50%,-100%)",
          "bottom-left": "translate(0,-100%)",
          "bottom-right": "translate(-100%,-100%)",
          left: "translate(0,-50%)",
          right: "translate(-100%,-50%)"
        };

        function Xl(h, e, a) {
          const o = h.classList;
          for (const c in $s) o.remove(`maplibregl-${a}-anchor-${c}`);
          o.add(`maplibregl-${a}-anchor-${e}`)
        }
        class al extends s.E {
          constructor(e) {
            if (super(), this._onKeyPress = a => {
                const o = a.code,
                  c = a.charCode || a.keyCode;
                o !== "Space" && o !== "Enter" && c !== 32 && c !== 13 || this.togglePopup()
              }, this._onMapClick = a => {
                const o = a.originalEvent.target,
                  c = this._element;
                this._popup && (o === c || c.contains(o)) && this.togglePopup()
              }, this._update = a => {
                if (!this._map) return;
                const o = this._map.loaded() && !this._map.isMoving();
                ((a == null ? void 0 : a.type) === "terrain" || (a == null ? void 0 : a.type) === "render" && !o) && this._map.once("render", this._update), this._lngLat = $l(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
                let c = "";
                this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? c = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (c = `rotateZ(${this._rotation-this._map.getBearing()}deg)`);
                let d = "";
                this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? d = "rotateX(0deg)" : this._pitchAlignment === "map" && (d = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || a && a.type !== "moveend" || (this._pos = this._pos.round()), Z.setTransform(this._element, `${$s[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${d} ${c}`), oe.frameAsync(new AbortController).then((() => {
                  this._updateOpacity(a && a.type === "moveend")
                })).catch((() => {}))
              }, this._onMove = a => {
                if (!this._isDragging) {
                  const o = this._clickTolerance || this._map._clickTolerance;
                  this._isDragging = a.point.dist(this._pointerdownPos) >= o
                }
                this._isDragging && (this._pos = a.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new s.l("dragstart"))), this.fire(new s.l("drag")))
              }, this._onUp = () => {
                this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new s.l("dragend")), this._state = "inactive"
              }, this._addDragHandler = a => {
                this._element.contains(a.originalEvent.target) && (a.preventDefault(), this._positionDelta = a.point.sub(this._pos).add(this._offset), this._pointerdownPos = a.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp))
              }, this._anchor = e && e.anchor || "center", this._color = e && e.color || "#3FB1CE", this._scale = e && e.scale || 1, this._draggable = e && e.draggable || !1, this._clickTolerance = e && e.clickTolerance || 0, this._subpixelPositioning = e && e.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = e && e.rotation || 0, this._rotationAlignment = e && e.rotationAlignment || "auto", this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment !== "auto" ? e.pitchAlignment : this._rotationAlignment, this.setOpacity(e == null ? void 0 : e.opacity, e == null ? void 0 : e.opacityWhenCovered), e && e.element) this._element = e.element, this._offset = s.P.convert(e && e.offset || [0, 0]);
            else {
              this._defaultMarker = !0, this._element = Z.create("div");
              const a = Z.createNS("http://www.w3.org/2000/svg", "svg"),
                o = 41,
                c = 27;
              a.setAttributeNS(null, "display", "block"), a.setAttributeNS(null, "height", `${o}px`), a.setAttributeNS(null, "width", `${c}px`), a.setAttributeNS(null, "viewBox", `0 0 ${c} ${o}`);
              const d = Z.createNS("http://www.w3.org/2000/svg", "g");
              d.setAttributeNS(null, "stroke", "none"), d.setAttributeNS(null, "stroke-width", "1"), d.setAttributeNS(null, "fill", "none"), d.setAttributeNS(null, "fill-rule", "evenodd");
              const g = Z.createNS("http://www.w3.org/2000/svg", "g");
              g.setAttributeNS(null, "fill-rule", "nonzero");
              const w = Z.createNS("http://www.w3.org/2000/svg", "g");
              w.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), w.setAttributeNS(null, "fill", "#000000");
              const S = [{
                rx: "10.5",
                ry: "5.25002273"
              }, {
                rx: "10.5",
                ry: "5.25002273"
              }, {
                rx: "9.5",
                ry: "4.77275007"
              }, {
                rx: "8.5",
                ry: "4.29549936"
              }, {
                rx: "7.5",
                ry: "3.81822308"
              }, {
                rx: "6.5",
                ry: "3.34094679"
              }, {
                rx: "5.5",
                ry: "2.86367051"
              }, {
                rx: "4.5",
                ry: "2.38636864"
              }];
              for (const ce of S) {
                const ge = Z.createNS("http://www.w3.org/2000/svg", "ellipse");
                ge.setAttributeNS(null, "opacity", "0.04"), ge.setAttributeNS(null, "cx", "10.5"), ge.setAttributeNS(null, "cy", "5.80029008"), ge.setAttributeNS(null, "rx", ce.rx), ge.setAttributeNS(null, "ry", ce.ry), w.appendChild(ge)
              }
              const A = Z.createNS("http://www.w3.org/2000/svg", "g");
              A.setAttributeNS(null, "fill", this._color);
              const E = Z.createNS("http://www.w3.org/2000/svg", "path");
              E.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), A.appendChild(E);
              const F = Z.createNS("http://www.w3.org/2000/svg", "g");
              F.setAttributeNS(null, "opacity", "0.25"), F.setAttributeNS(null, "fill", "#000000");
              const R = Z.createNS("http://www.w3.org/2000/svg", "path");
              R.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), F.appendChild(R);
              const U = Z.createNS("http://www.w3.org/2000/svg", "g");
              U.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), U.setAttributeNS(null, "fill", "#FFFFFF");
              const Y = Z.createNS("http://www.w3.org/2000/svg", "g");
              Y.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const se = Z.createNS("http://www.w3.org/2000/svg", "circle");
              se.setAttributeNS(null, "fill", "#000000"), se.setAttributeNS(null, "opacity", "0.25"), se.setAttributeNS(null, "cx", "5.5"), se.setAttributeNS(null, "cy", "5.5"), se.setAttributeNS(null, "r", "5.4999962");
              const le = Z.createNS("http://www.w3.org/2000/svg", "circle");
              le.setAttributeNS(null, "fill", "#FFFFFF"), le.setAttributeNS(null, "cx", "5.5"), le.setAttributeNS(null, "cy", "5.5"), le.setAttributeNS(null, "r", "5.4999962"), Y.appendChild(se), Y.appendChild(le), g.appendChild(w), g.appendChild(A), g.appendChild(F), g.appendChild(U), g.appendChild(Y), a.appendChild(g), a.setAttributeNS(null, "height", o * this._scale + "px"), a.setAttributeNS(null, "width", c * this._scale + "px"), this._element.appendChild(a), this._offset = s.P.convert(e && e.offset || [0, -14])
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (a => {
                a.preventDefault()
              })), this._element.addEventListener("mousedown", (a => {
                a.preventDefault()
              })), Xl(this._element, this._anchor, "marker"), e && e.className)
              for (const a of e.className.split(" ")) this._element.classList.add(a);
            this._popup = null
          }
          addTo(e) {
            return this.remove(), this._map = e, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e._getUIString("Marker.Title")), this._element.hasAttribute("role") || this._element.setAttribute("role", "button"), e.getCanvasContainer().appendChild(this._element), e.on("move", this._update), e.on("moveend", this._update), e.on("terrain", this._update), e.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), Z.remove(this._element), this._popup && this._popup.remove(), this
          }
          getLngLat() {
            return this._lngLat
          }
          setLngLat(e) {
            return this._lngLat = s.U.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this
          }
          getElement() {
            return this._element
          }
          setPopup(e) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
              if (!("offset" in e.options)) {
                const c = Math.abs(13.5) / Math.SQRT2;
                e.options.offset = this._defaultMarker ? {
                  top: [0, 0],
                  "top-left": [0, 0],
                  "top-right": [0, 0],
                  bottom: [0, -38.1],
                  "bottom-left": [c, -1 * (38.1 - 13.5 + c)],
                  "bottom-right": [-c, -1 * (38.1 - 13.5 + c)],
                  left: [13.5, -1 * (38.1 - 13.5)],
                  right: [-13.5, -1 * (38.1 - 13.5)]
                } : this._offset
              }
              this._popup = e, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress)
            }
            return this
          }
          setSubpixelPositioning(e) {
            return this._subpixelPositioning = e, this
          }
          getPopup() {
            return this._popup
          }
          togglePopup() {
            const e = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : e ? (e.isOpen() ? e.remove() : (e.setLngLat(this._lngLat), e.addTo(this._map)), this) : this
          }
          _updateOpacity(e = !1) {
            var a, o;
            const c = (a = this._map) === null || a === void 0 ? void 0 : a.terrain,
              d = this._map.transform.isLocationOccluded(this._lngLat);
            if (!c || d) {
              const U = d ? this._opacityWhenCovered : this._opacity;
              return void(this._element.style.opacity !== U && (this._element.style.opacity = U))
            }
            if (e) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout((() => {
                this._opacityTimeout = null
              }), 100)
            }
            const g = this._map,
              w = g.terrain.depthAtPoint(this._pos),
              S = g.terrain.getElevationForLngLatZoom(this._lngLat, g.transform.tileZoom);
            if (g.transform.lngLatToCameraDepth(this._lngLat, S) - w < .006) return void(this._element.style.opacity = this._opacity);
            const A = -this._offset.y / g.transform.pixelsPerMeter,
              E = Math.sin(g.getPitch() * Math.PI / 180) * A,
              F = g.terrain.depthAtPoint(new s.P(this._pos.x, this._pos.y - this._offset.y)),
              R = g.transform.lngLatToCameraDepth(this._lngLat, S + E) - F > .006;
            !((o = this._popup) === null || o === void 0) && o.isOpen() && R && this._popup.remove(), this._element.style.opacity = R ? this._opacityWhenCovered : this._opacity
          }
          getOffset() {
            return this._offset
          }
          setOffset(e) {
            return this._offset = s.P.convert(e), this._update(), this
          }
          addClassName(e) {
            this._element.classList.add(e)
          }
          removeClassName(e) {
            this._element.classList.remove(e)
          }
          toggleClassName(e) {
            return this._element.classList.toggle(e)
          }
          setDraggable(e) {
            return this._draggable = !!e, this._map && (e ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this
          }
          isDraggable() {
            return this._draggable
          }
          setRotation(e) {
            return this._rotation = e || 0, this._update(), this
          }
          getRotation() {
            return this._rotation
          }
          setRotationAlignment(e) {
            return this._rotationAlignment = e || "auto", this._update(), this
          }
          getRotationAlignment() {
            return this._rotationAlignment
          }
          setPitchAlignment(e) {
            return this._pitchAlignment = e && e !== "auto" ? e : this._rotationAlignment, this._update(), this
          }
          getPitchAlignment() {
            return this._pitchAlignment
          }
          setOpacity(e, a) {
            return (this._opacity === void 0 || e === void 0 && a === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), e !== void 0 && (this._opacity = e), a !== void 0 && (this._opacityWhenCovered = a), this._map && this._updateOpacity(!0), this
          }
        }
        const wu = {
          positionOptions: {
            enableHighAccuracy: !1,
            maximumAge: 0,
            timeout: 6e3
          },
          fitBoundsOptions: {
            maxZoom: 15
          },
          trackUserLocation: !1,
          showAccuracyCircle: !0,
          showUserLocation: !0
        };
        let Co = 0,
          Xs = !1;
        const Tu = {
          maxWidth: 100,
          unit: "metric"
        };

        function Yl(h, e, a) {
          const o = a && a.maxWidth || 100,
            c = h._container.clientHeight / 2,
            d = h._container.clientWidth / 2,
            g = h.unproject([d - o / 2, c]),
            w = h.unproject([d + o / 2, c]),
            S = Math.round(h.project(w).x - h.project(g).x),
            A = Math.min(o, S, h._container.clientWidth),
            E = g.distanceTo(w);
          if (a && a.unit === "imperial") {
            const F = 3.2808 * E;
            F > 5280 ? Ys(e, A, F / 5280, h._getUIString("ScaleControl.Miles")) : Ys(e, A, F, h._getUIString("ScaleControl.Feet"))
          } else a && a.unit === "nautical" ? Ys(e, A, E / 1852, h._getUIString("ScaleControl.NauticalMiles")) : E >= 1e3 ? Ys(e, A, E / 1e3, h._getUIString("ScaleControl.Kilometers")) : Ys(e, A, E, h._getUIString("ScaleControl.Meters"))
        }

        function Ys(h, e, a, o) {
          const c = (function(d) {
            const g = Math.pow(10, `${Math.floor(d)}`.length - 1);
            let w = d / g;
            return w = w >= 10 ? 10 : w >= 5 ? 5 : w >= 3 ? 3 : w >= 2 ? 2 : w >= 1 ? 1 : (function(S) {
              const A = Math.pow(10, Math.ceil(-Math.log(S) / Math.LN10));
              return Math.round(S * A) / A
            })(w), g * w
          })(a);
          h.style.width = e * (c / a) + "px", h.innerHTML = `${c}&nbsp;${o}`
        }
        const Su = {
            closeButton: !0,
            closeOnClick: !0,
            focusAfterOpen: !0,
            className: "",
            maxWidth: "240px",
            subpixelPositioning: !1,
            locationOccludedOpacity: void 0
          },
          Kl = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");

        function Jl(h) {
          if (h) {
            if (typeof h == "number") {
              const e = Math.round(Math.abs(h) / Math.SQRT2);
              return {
                center: new s.P(0, 0),
                top: new s.P(0, h),
                "top-left": new s.P(e, e),
                "top-right": new s.P(-e, e),
                bottom: new s.P(0, -h),
                "bottom-left": new s.P(e, -e),
                "bottom-right": new s.P(-e, -e),
                left: new s.P(h, 0),
                right: new s.P(-h, 0)
              }
            }
            if (h instanceof s.P || Array.isArray(h)) {
              const e = s.P.convert(h);
              return {
                center: e,
                top: e,
                "top-left": e,
                "top-right": e,
                bottom: e,
                "bottom-left": e,
                "bottom-right": e,
                left: e,
                right: e
              }
            }
            return {
              center: s.P.convert(h.center || [0, 0]),
              top: s.P.convert(h.top || [0, 0]),
              "top-left": s.P.convert(h["top-left"] || [0, 0]),
              "top-right": s.P.convert(h["top-right"] || [0, 0]),
              bottom: s.P.convert(h.bottom || [0, 0]),
              "bottom-left": s.P.convert(h["bottom-left"] || [0, 0]),
              "bottom-right": s.P.convert(h["bottom-right"] || [0, 0]),
              left: s.P.convert(h.left || [0, 0]),
              right: s.P.convert(h.right || [0, 0])
            }
          }
          return Jl(new s.P(0, 0))
        }
        const Pu = B;
        T.AJAXError = s.cC, T.Event = s.l, T.Evented = s.E, T.LngLat = s.U, T.MercatorCoordinate = s.a5, T.Point = s.P, T.addProtocol = s.cD, T.config = s.a, T.removeProtocol = s.cE, T.AttributionControl = nn, T.BoxZoomHandler = dd, T.CanvasSource = Gr, T.CooperativeGesturesHandler = Nn, T.DoubleClickZoomHandler = tl, T.DragPanHandler = vu, T.DragRotateHandler = yu, T.EdgeInsets = di, T.FullscreenControl = class extends s.E {
          constructor(h = {}) {
            super(), this._onFullscreenChange = () => {
              var e;
              let a = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; !((e = a == null ? void 0 : a.shadowRoot) === null || e === void 0) && e.fullscreenElement;) a = a.shadowRoot.fullscreenElement;
              a === this._container !== this._fullscreen && this._handleFullscreenChange()
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen()
            }, this._fullscreen = !1, h && h.container && (h.container instanceof HTMLElement ? this._container = h.container : s.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange")
          }
          onAdd(h) {
            return this._map = h, this._container || (this._container = this._map.getContainer()), this._controlContainer = Z.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer
          }
          onRemove() {
            Z.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange)
          }
          _setupUI() {
            const h = this._fullscreenButton = Z.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            Z.create("span", "maplibregl-ctrl-icon", h).setAttribute("aria-hidden", "true"), h.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange)
          }
          _updateTitle() {
            const h = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", h), this._fullscreenButton.title = h
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter")
          }
          _isFullscreen() {
            return this._fullscreen
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new s.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new s.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable())
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen()
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen()
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize()
          }
        }, T.GeoJSONSource = jr, T.GeolocateControl = class extends s.E {
          constructor(h) {
            super(), this._onSuccess = e => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new s.l("outofmaxbounds", e)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`)
                }
                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new s.l("geolocate", e)), this._finish()
              }
            }, this._updateCamera = e => {
              const a = new s.U(e.coords.longitude, e.coords.latitude),
                o = e.coords.accuracy,
                c = this._map.getBearing(),
                d = s.e({
                  bearing: c
                }, this.options.fitBoundsOptions),
                g = wt.fromLngLat(a, o);
              this._map.fitBounds(g, d, {
                geolocateSource: !0
              })
            }, this._updateMarker = e => {
              if (e) {
                const a = new s.U(e.coords.longitude, e.coords.latitude);
                this._accuracyCircleMarker.setLngLat(a).addTo(this._map), this._userLocationDotMarker.setLngLat(a).addTo(this._map), this._accuracy = e.coords.accuracy, this._updateCircleRadiusIfNeeded()
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove()
            }, this._onUpdate = () => {
              this._updateCircleRadiusIfNeeded()
            }, this._onError = e => {
              if (this._map) {
                if (e.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                  const a = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a), this._geolocationWatchID !== void 0 && this._clearWatch()
                } else {
                  if (e.code === 3 && Xs) return;
                  this._setErrorState()
                }
                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new s.l("error", e)), this._finish()
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0
            }, this._setupUI = () => {
              this._map && (this._container.addEventListener("contextmenu", (e => e.preventDefault())), this._geolocateButton = Z.create("button", "maplibregl-ctrl-geolocate", this._container), Z.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0)
            }, this._finishSetupUI = e => {
              if (this._map) {
                if (e === !1) {
                  s.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const a = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = !0, this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a)
                } else {
                  const a = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.disabled = !1, this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a)
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = Z.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new al({
                  element: this._dotElement
                }), this._circleElement = Z.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new al({
                  element: this._circleElement,
                  pitchAlignment: "map"
                }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onUpdate), this._map.on("move", this._onUpdate), this._map.on("rotate", this._onUpdate), this._map.on("pitch", this._onUpdate)), this._geolocateButton.addEventListener("click", (() => this.trigger())), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (a => {
                  const o = (a == null ? void 0 : a[0]) instanceof ResizeObserverEntry;
                  a.geolocateSource || this._watchState !== "ACTIVE_LOCK" || o || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new s.l("trackuserlocationend")), this.fire(new s.l("userlocationlostfocus")))
                }))
              }
            }, this.options = s.e({}, wu, h)
          }
          onAdd(h) {
            return this._map = h, this._container = Z.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), (function() {
              return s._(this, arguments, void 0, (function*(e = !1) {
                if (ds !== void 0 && !e) return ds;
                if (window.navigator.permissions === void 0) return ds = !!window.navigator.geolocation, ds;
                try {
                  ds = (yield window.navigator.permissions.query({
                    name: "geolocation"
                  })).state !== "denied"
                } catch {
                  ds = !!window.navigator.geolocation
                }
                return ds
              }))
            })().then((e => this._finishSetupUI(e))), this._container
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), Z.remove(this._container), this._map.off("zoom", this._onUpdate), this._map.off("move", this._onUpdate), this._map.off("rotate", this._onUpdate), this._map.off("pitch", this._onUpdate), this._map = void 0, Co = 0, Xs = !1
          }
          _isOutOfMapMaxBounds(h) {
            const e = this._map.getMaxBounds(),
              a = h.coords;
            return e && (a.longitude < e.getWest() || a.longitude > e.getEast() || a.latitude < e.getSouth() || a.latitude > e.getNorth())
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
              case "OFF":
              case void 0:
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`)
            }
          }
          _updateCircleRadiusIfNeeded() {
            const h = this._userLocationDotMarker.getLngLat();
            if (!(this.options.showUserLocation && this.options.showAccuracyCircle && this._accuracy && h)) return;
            const e = this._map.project(h),
              a = this._map.unproject([e.x + 100, e.y]),
              o = h.distanceTo(a) / 100,
              c = 2 * this._accuracy / o;
            this._circleElement.style.width = `${c.toFixed(2)}px`, this._circleElement.style.height = `${c.toFixed(2)}px`
          }
          trigger() {
            if (!this._setup) return s.w("Geolocate control triggered before added to a map"), !1;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new s.l("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  Co--, Xs = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new s.l("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new s.l("trackuserlocationstart")), this.fire(new s.l("userlocationfocus"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`)
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`)
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let h;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Co++, Co > 1 ? (h = {
                  maximumAge: 6e5,
                  timeout: 0
                }, Xs = !0) : (h = this.options.positionOptions, Xs = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, h)
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return !0
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null)
          }
        }, T.GlobeControl = class {
          constructor() {
            this._toggleProjection = () => {
              var h;
              const e = (h = this._map.getProjection()) === null || h === void 0 ? void 0 : h.type;
              this._map.setProjection(e !== "mercator" && e ? {
                type: "mercator"
              } : {
                type: "globe"
              }), this._updateGlobeIcon()
            }, this._updateGlobeIcon = () => {
              var h;
              this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((h = this._map.getProjection()) === null || h === void 0 ? void 0 : h.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"))
            }
          }
          onAdd(h) {
            return this._map = h, this._container = Z.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = Z.create("button", "maplibregl-ctrl-globe", this._container), Z.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container
          }
          onRemove() {
            Z.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0
          }
        }, T.Hash = uu, T.ImageSource = wr, T.KeyboardHandler = xd, T.LngLatBounds = wt, T.LogoControl = xu, T.Map = class extends Sd {
          constructor(h) {
            var e, a;
            s.cz.mark(s.cA.create);
            const o = Object.assign(Object.assign(Object.assign({}, Io), h), {
              canvasContextAttributes: Object.assign(Object.assign({}, Io.canvasContextAttributes), h.canvasContextAttributes)
            });
            if (o.minZoom != null && o.maxZoom != null && o.minZoom > o.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (o.minPitch != null && o.maxPitch != null && o.minPitch > o.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (o.minPitch != null && o.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (o.maxPitch != null && o.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
            const c = new Sa,
              d = new ja;
            if (o.minZoom !== void 0 && c.setMinZoom(o.minZoom), o.maxZoom !== void 0 && c.setMaxZoom(o.maxZoom), o.minPitch !== void 0 && c.setMinPitch(o.minPitch), o.maxPitch !== void 0 && c.setMaxPitch(o.maxPitch), o.renderWorldCopies !== void 0 && c.setRenderWorldCopies(o.renderWorldCopies), o.transformConstrain !== null && c.setConstrain(o.transformConstrain), super(c, d, {
                bearingSnap: o.bearingSnap
              }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new Un, this._controls = [], this._mapId = s.ab(), this._contextLost = w => {
                w.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new s.l("webglcontextlost", {
                  originalEvent: w
                }))
              }, this._contextRestored = w => {
                this._setupPainter(), this.resize(), this._update(), this.fire(new s.l("webglcontextrestored", {
                  originalEvent: w
                }))
              }, this._onMapScroll = w => {
                if (w.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1
              }, this._onWindowOnline = () => {
                this._update()
              }, this._interactive = o.interactive, this._maxTileCacheSize = o.maxTileCacheSize, this._maxTileCacheZoomLevels = o.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, o.canvasContextAttributes), this._trackResize = o.trackResize === !0, this._bearingSnap = o.bearingSnap, this._centerClampedToGround = o.centerClampedToGround, this._refreshExpiredTiles = o.refreshExpiredTiles === !0, this._fadeDuration = o.fadeDuration, this._crossSourceCollisions = o.crossSourceCollisions === !0, this._collectResourceTiming = o.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, xa), o.locale), this._clickTolerance = o.clickTolerance, this._overridePixelRatio = o.pixelRatio, this._maxCanvasSize = o.maxCanvasSize, this.transformCameraUpdate = o.transformCameraUpdate, this.transformConstrain = o.transformConstrain, this.cancelPendingTileRequestsWhileZooming = o.cancelPendingTileRequestsWhileZooming === !0, this._imageQueueHandle = Xe.addThrottleControl((() => this.isMoving())), this._requestManager = new Ae(o.transformRequest), typeof o.container == "string") {
              if (this._container = document.getElementById(o.container), !this._container) throw new Error(`Container '${o.container}' not found.`)
            } else {
              if (!(o.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = o.container
            }
            if (o.maxBounds && this.setMaxBounds(o.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", (() => this._update(!1))), this.on("moveend", (() => this._update(!1))), this.on("zoom", (() => this._update(!0))), this.on("terrain", (() => {
                this.painter.terrainFacilitator.dirty = !0, this._update(!0)
              })), this.once("idle", (() => {
                this._idleTriggered = !0
              })), typeof window < "u") {
              addEventListener("online", this._onWindowOnline, !1);
              let w = !1;
              const S = cu((A => {
                this._trackResize && !this._removed && (this.resize(A), this.redraw())
              }), 50);
              this._resizeObserver = new ResizeObserver((A => {
                w ? S(A) : w = !0
              })), this._resizeObserver.observe(this._container)
            }
            this.handlers = new rl(this, o), this._hash = o.hash && new uu(typeof o.hash == "string" && o.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({
              center: o.center,
              elevation: o.elevation,
              zoom: o.zoom,
              bearing: o.bearing,
              pitch: o.pitch,
              roll: o.roll
            }), o.bounds && (this.resize(), this.fitBounds(o.bounds, s.e({}, o.fitBoundsOptions, {
              duration: 0
            }))));
            const g = typeof o.style == "string" || ((a = (e = o.style) === null || e === void 0 ? void 0 : e.projection) === null || a === void 0 ? void 0 : a.type) !== "globe";
            this.resize(null, g), this._localIdeographFontFamily = o.localIdeographFontFamily, this._validateStyle = o.validateStyle, o.style && this.setStyle(o.style, {
              localIdeographFontFamily: o.localIdeographFontFamily
            }), o.attributionControl && this.addControl(new nn(typeof o.attributionControl == "boolean" ? void 0 : o.attributionControl)), o.maplibreLogo && this.addControl(new xu, o.logoPosition), this.on("style.load", (() => {
              if (g || this._resizeTransform(), this.transform.unmodified) {
                const w = s.S(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                this.jumpTo(w)
              }
            })), this.on("data", (w => {
              this._update(w.dataType === "style"), this.fire(new s.l(`${w.dataType}data`, w))
            })), this.on("dataloading", (w => {
              this.fire(new s.l(`${w.dataType}dataloading`, w))
            })), this.on("dataabort", (w => {
              this.fire(new s.l("sourcedataabort", w))
            }))
          }
          _getMapId() {
            return this._mapId
          }
          setGlobalStateProperty(h, e) {
            return this.style.setGlobalStateProperty(h, e), this._update(!0)
          }
          getGlobalState() {
            return this.style.getGlobalState()
          }
          addControl(h, e) {
            if (e === void 0 && (e = h.getDefaultPosition ? h.getDefaultPosition() : "top-right"), !h || !h.onAdd) return this.fire(new s.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const a = h.onAdd(this);
            this._controls.push(h);
            const o = this._controlPositions[e];
            return e.indexOf("bottom") !== -1 ? o.insertBefore(a, o.firstChild) : o.appendChild(a), this
          }
          removeControl(h) {
            if (!h || !h.onRemove) return this.fire(new s.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const e = this._controls.indexOf(h);
            return e > -1 && this._controls.splice(e, 1), h.onRemove(this), this
          }
          hasControl(h) {
            return this._controls.indexOf(h) > -1
          }
          coveringTiles(h) {
            return He(this.transform, h)
          }
          calculateCameraOptionsFromTo(h, e, a, o) {
            return o == null && this.terrain && (o = this.terrain.getElevationForLngLatZoom(a, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(h, e, a, o)
          }
          resize(h, e = !0) {
            const [a, o] = this._containerDimensions(), c = this._getClampedPixelRatio(a, o);
            if (this._resizeCanvas(a, o, c), this.painter.resize(a, o, c), this.painter.overLimit()) {
              const g = this.painter.context.gl;
              this._maxCanvasSize = [g.drawingBufferWidth, g.drawingBufferHeight];
              const w = this._getClampedPixelRatio(a, o);
              this._resizeCanvas(a, o, w), this.painter.resize(a, o, w)
            }
            this._resizeTransform(e);
            const d = !this._moving;
            return d && (this.stop(), this.fire(new s.l("movestart", h)).fire(new s.l("move", h))), this.fire(new s.l("resize", h)), d && this.fire(new s.l("moveend", h)), this
          }
          _resizeTransform(h = !0) {
            var e;
            const [a, o] = this._containerDimensions();
            this.transform.resize(a, o, h), (e = this._requestedCameraState) === null || e === void 0 || e.resize(a, o, h)
          }
          _getClampedPixelRatio(h, e) {
            const {
              0: a,
              1: o
            } = this._maxCanvasSize, c = this.getPixelRatio(), d = h * c, g = e * c;
            return Math.min(d > a ? a / d : 1, g > o ? o / g : 1) * c
          }
          getPixelRatio() {
            var h;
            return (h = this._overridePixelRatio) !== null && h !== void 0 ? h : devicePixelRatio
          }
          setPixelRatio(h) {
            this._overridePixelRatio = h, this.resize()
          }
          getBounds() {
            return this.transform.getBounds()
          }
          getMaxBounds() {
            return this.transform.getMaxBounds()
          }
          setMaxBounds(h) {
            return this.transform.setMaxBounds(wt.convert(h)), this._update()
          }
          setMinZoom(h) {
            if ((h = h ?? -2) >= -2 && h <= this.transform.maxZoom) return this.transform.setMinZoom(h), this._update(), this.getZoom() < h && this.setZoom(h), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive")
          }
          getMinZoom() {
            return this.transform.minZoom
          }
          setMaxZoom(h) {
            if ((h = h ?? 22) >= this.transform.minZoom) return this.transform.setMaxZoom(h), this._update(), this.getZoom() > h && this.setZoom(h), this;
            throw new Error("maxZoom must be greater than the current minZoom")
          }
          getMaxZoom() {
            return this.transform.maxZoom
          }
          setMinPitch(h) {
            if ((h = h ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (h >= 0 && h <= this.transform.maxPitch) return this.transform.setMinPitch(h), this._update(), this.getPitch() < h && this.setPitch(h), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive")
          }
          getMinPitch() {
            return this.transform.minPitch
          }
          setMaxPitch(h) {
            if ((h = h ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180");
            if (h >= this.transform.minPitch) return this.transform.setMaxPitch(h), this._update(), this.getPitch() > h && this.setPitch(h), this;
            throw new Error("maxPitch must be greater than the current minPitch")
          }
          getMaxPitch() {
            return this.transform.maxPitch
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies
          }
          setRenderWorldCopies(h) {
            return this.transform.setRenderWorldCopies(h), this._update()
          }
          setTransformConstrain(h) {
            return this.transform.setConstrain(h), this._update()
          }
          project(h) {
            return this.transform.locationToScreenPoint(s.U.convert(h), this.style && this.terrain)
          }
          unproject(h) {
            return this.transform.screenPointToLocation(s.P.convert(h), this.terrain)
          }
          isMoving() {
            var h;
            return this._moving || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isMoving())
          }
          isZooming() {
            var h;
            return this._zooming || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isZooming())
          }
          isRotating() {
            var h;
            return this._rotating || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isRotating())
          }
          _createDelegatedListener(h, e, a) {
            if (h === "mouseenter" || h === "mouseover") {
              let o = !1;
              return {
                layers: e,
                listener: a,
                delegates: {
                  mousemove: d => {
                    const g = e.filter((S => this.getLayer(S))),
                      w = g.length !== 0 ? this.queryRenderedFeatures(d.point, {
                        layers: g
                      }) : [];
                    w.length ? o || (o = !0, a.call(this, new gn(h, this, d.originalEvent, {
                      features: w
                    }))) : o = !1
                  },
                  mouseout: () => {
                    o = !1
                  }
                }
              }
            }
            if (h === "mouseleave" || h === "mouseout") {
              let o = !1;
              return {
                layers: e,
                listener: a,
                delegates: {
                  mousemove: g => {
                    const w = e.filter((S => this.getLayer(S)));
                    (w.length !== 0 ? this.queryRenderedFeatures(g.point, {
                      layers: w
                    }) : []).length ? o = !0 : o && (o = !1, a.call(this, new gn(h, this, g.originalEvent)))
                  },
                  mouseout: g => {
                    o && (o = !1, a.call(this, new gn(h, this, g.originalEvent)))
                  }
                }
              }
            } {
              const o = c => {
                const d = e.filter((w => this.getLayer(w))),
                  g = d.length !== 0 ? this.queryRenderedFeatures(c.point, {
                    layers: d
                  }) : [];
                g.length && (c.features = g, a.call(this, c), delete c.features)
              };
              return {
                layers: e,
                listener: a,
                delegates: {
                  [h]: o
                }
              }
            }
          }
          _saveDelegatedListener(h, e) {
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[h] = this._delegatedListeners[h] || [], this._delegatedListeners[h].push(e)
          }
          _removeDelegatedListener(h, e, a) {
            if (!this._delegatedListeners || !this._delegatedListeners[h]) return;
            const o = this._delegatedListeners[h];
            for (let c = 0; c < o.length; c++) {
              const d = o[c];
              if (d.listener === a && d.layers.length === e.length && d.layers.every((g => e.includes(g)))) {
                for (const g in d.delegates) this.off(g, d.delegates[g]);
                return void o.splice(c, 1)
              }
            }
          }
          on(h, e, a) {
            if (a === void 0) return super.on(h, e);
            const o = typeof e == "string" ? [e] : e,
              c = this._createDelegatedListener(h, o, a);
            this._saveDelegatedListener(h, c);
            for (const d in c.delegates) this.on(d, c.delegates[d]);
            return {
              unsubscribe: () => {
                this._removeDelegatedListener(h, o, a)
              }
            }
          }
          once(h, e, a) {
            if (a === void 0) return super.once(h, e);
            const o = typeof e == "string" ? [e] : e,
              c = this._createDelegatedListener(h, o, a);
            for (const d in c.delegates) {
              const g = c.delegates[d];
              c.delegates[d] = (...w) => {
                this._removeDelegatedListener(h, o, a), g(...w)
              }
            }
            this._saveDelegatedListener(h, c);
            for (const d in c.delegates) this.once(d, c.delegates[d]);
            return this
          }
          off(h, e, a) {
            return a === void 0 ? super.off(h, e) : (this._removeDelegatedListener(h, typeof e == "string" ? [e] : e, a), this)
          }
          queryRenderedFeatures(h, e) {
            if (!this.style) return [];
            let a;
            const o = h instanceof s.P || Array.isArray(h),
              c = o ? h : [
                [0, 0],
                [this.transform.width, this.transform.height]
              ];
            if (e = e || (o ? {} : h) || {}, c instanceof s.P || typeof c[0] == "number") a = [s.P.convert(c)];
            else {
              const d = s.P.convert(c[0]),
                g = s.P.convert(c[1]);
              a = [d, new s.P(g.x, d.y), g, new s.P(d.x, g.y), d]
            }
            return this.style.queryRenderedFeatures(a, e, this.transform)
          }
          querySourceFeatures(h, e) {
            return this.style.querySourceFeatures(h, e)
          }
          setStyle(h, e) {
            return (e = s.e({}, {
              localIdeographFontFamily: this._localIdeographFontFamily,
              validate: this._validateStyle
            }, e)).diff !== !1 && e.localIdeographFontFamily === this._localIdeographFontFamily && this.style && h ? (this._diffStyle(h, e), this) : (this._localIdeographFontFamily = e.localIdeographFontFamily, this._updateStyle(h, e))
          }
          setTransformRequest(h) {
            return this._requestManager.setTransformRequest(h), this
          }
          _getUIString(h) {
            const e = this._locale[h];
            if (e == null) throw new Error(`Missing UI string '${h}'`);
            return e
          }
          _updateStyle(h, e) {
            var a, o;
            if (e.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", (() => this._updateStyle(h, e)));
            const c = this.style && e.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!h)), h ? (this.style = new Zo(this, e || {}), this.style.setEventedParent(this, {
              style: this.style
            }), typeof h == "string" ? this.style.loadURL(h, e, c) : this.style.loadJSON(h, e, c), this) : ((o = (a = this.style) === null || a === void 0 ? void 0 : a.projection) === null || o === void 0 || o.destroy(), delete this.style, this)
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new Zo(this, {}), this.style.setEventedParent(this, {
              style: this.style
            }), this.style.loadEmpty())
          }
          _diffStyle(h, e) {
            if (typeof h == "string") {
              const a = this._requestManager.transformRequest(h, "Style");
              s.j(a, new AbortController).then((o => {
                this._updateDiff(o.data, e)
              })).catch((o => {
                o && this.fire(new s.k(o))
              }))
            } else typeof h == "object" && this._updateDiff(h, e)
          }
          _updateDiff(h, e) {
            try {
              this.style.setState(h, e) && this._update(!0)
            } catch (a) {
              s.w(`Unable to perform style diff: ${a.message||a.error||a}.  Rebuilding the style from scratch.`), this._updateStyle(h, e)
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize()
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : s.w("There is no style added to the map.")
          }
          addSource(h, e) {
            return this._lazyInitEmptyStyle(), this.style.addSource(h, e), this._update(!0)
          }
          isSourceLoaded(h) {
            const e = this.style && this.style.tileManagers[h];
            if (e !== void 0) return e.loaded();
            this.fire(new s.k(new Error(`There is no tile manager with ID '${h}'`)))
          }
          setTerrain(h) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), h) {
              const e = this.style.tileManagers[h.source];
              if (!e) throw new Error(`cannot load terrain, because there exists no source with ID: ${h.source}`);
              this.terrain === null && e.reload();
              for (const a in this.style._layers) {
                const o = this.style._layers[a];
                o.type === "hillshade" && o.source === h.source && s.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), o.type === "color-relief" && o.source === h.source && s.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.")
              }
              this.terrain = new tf(this.painter, e, h), this.painter.renderToTexture = new pa(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = a => {
                var o;
                a.dataType === "style" ? this.terrain.tileManager.freeRtt() : a.dataType === "source" && a.tile && (a.sourceId !== h.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), ((o = a.source) === null || o === void 0 ? void 0 : o.type) === "image" ? this.terrain.tileManager.freeRtt() : this.terrain.tileManager.freeRtt(a.tile.tileID))
              }, this.style.on("data", this._terrainDataCallback)
            } else this.terrain && this.terrain.tileManager.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
            return this.fire(new s.l("terrain", {
              terrain: h
            })), this
          }
          getTerrain() {
            var h, e;
            return (e = (h = this.terrain) === null || h === void 0 ? void 0 : h.options) !== null && e !== void 0 ? e : null
          }
          areTilesLoaded() {
            const h = this.style && this.style.tileManagers;
            for (const e in h) {
              const a = h[e]._tiles;
              for (const o in a) {
                const c = a[o];
                if (c.state !== "loaded" && c.state !== "errored") return !1
              }
            }
            return !0
          }
          removeSource(h) {
            return this.style.removeSource(h), this._update(!0)
          }
          getSource(h) {
            return this.style.getSource(h)
          }
          setSourceTileLodParams(h, e, a) {
            if (a) {
              const o = this.getSource(a);
              if (!o) throw new Error(`There is no source with ID "${a}", cannot set LOD parameters`);
              o.calculateTileZoom = Ze(Math.max(1, h), Math.max(1, e))
            } else
              for (const o in this.style.tileManagers) this.style.tileManagers[o].getSource().calculateTileZoom = Ze(Math.max(1, h), Math.max(1, e));
            return this._update(!0), this
          }
          refreshTiles(h, e) {
            const a = this.style.tileManagers[h];
            if (!a) throw new Error(`There is no tile manager with ID "${h}", cannot refresh tile`);
            e === void 0 ? a.reload(!0) : a.refreshTiles(e.map((o => new s.a8(o.z, o.x, o.y))))
          }
          addImage(h, e, a = {}) {
            const {
              pixelRatio: o = 1,
              sdf: c = !1,
              stretchX: d,
              stretchY: g,
              content: w,
              textFitWidth: S,
              textFitHeight: A
            } = a;
            if (this._lazyInitEmptyStyle(), !(e instanceof HTMLImageElement || s.b(e))) {
              if (e.width === void 0 || e.height === void 0) return this.fire(new s.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const {
                  width: E,
                  height: F,
                  data: R
                } = e, U = e;
                return this.style.addImage(h, {
                  data: new s.R({
                    width: E,
                    height: F
                  }, new Uint8Array(R)),
                  pixelRatio: o,
                  stretchX: d,
                  stretchY: g,
                  content: w,
                  textFitWidth: S,
                  textFitHeight: A,
                  sdf: c,
                  version: 0,
                  userImage: U
                }), U.onAdd && U.onAdd(this, h), this
              }
            } {
              const {
                width: E,
                height: F,
                data: R
              } = oe.getImageData(e);
              this.style.addImage(h, {
                data: new s.R({
                  width: E,
                  height: F
                }, R),
                pixelRatio: o,
                stretchX: d,
                stretchY: g,
                content: w,
                textFitWidth: S,
                textFitHeight: A,
                sdf: c,
                version: 0
              })
            }
          }
          updateImage(h, e) {
            const a = this.style.getImage(h);
            if (!a) return this.fire(new s.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const o = e instanceof HTMLImageElement || s.b(e) ? oe.getImageData(e) : e,
              {
                width: c,
                height: d,
                data: g
              } = o;
            if (c === void 0 || d === void 0) return this.fire(new s.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (c !== a.data.width || d !== a.data.height) return this.fire(new s.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const w = !(e instanceof HTMLImageElement || s.b(e));
            return a.data.replace(g, w), this.style.updateImage(h, a), this
          }
          getImage(h) {
            return this.style.getImage(h)
          }
          hasImage(h) {
            return h ? !!this.style.getImage(h) : (this.fire(new s.k(new Error("Missing required image id"))), !1)
          }
          removeImage(h) {
            this.style.removeImage(h)
          }
          loadImage(h) {
            return Xe.getImage(this._requestManager.transformRequest(h, "Image"), new AbortController)
          }
          listImages() {
            return this.style.listImages()
          }
          addLayer(h, e) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(h, e), this._update(!0)
          }
          moveLayer(h, e) {
            return this.style.moveLayer(h, e), this._update(!0)
          }
          removeLayer(h) {
            return this.style.removeLayer(h), this._update(!0)
          }
          getLayer(h) {
            return this.style.getLayer(h)
          }
          getLayersOrder() {
            return this.style.getLayersOrder()
          }
          setLayerZoomRange(h, e, a) {
            return this.style.setLayerZoomRange(h, e, a), this._update(!0)
          }
          setFilter(h, e, a = {}) {
            return this.style.setFilter(h, e, a), this._update(!0)
          }
          getFilter(h) {
            return this.style.getFilter(h)
          }
          setPaintProperty(h, e, a, o = {}) {
            return this.style.setPaintProperty(h, e, a, o), this._update(!0)
          }
          getPaintProperty(h, e) {
            return this.style.getPaintProperty(h, e)
          }
          setLayoutProperty(h, e, a, o = {}) {
            return this.style.setLayoutProperty(h, e, a, o), this._update(!0)
          }
          getLayoutProperty(h, e) {
            return this.style.getLayoutProperty(h, e)
          }
          setGlyphs(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(h, e), this._update(!0)
          }
          getGlyphs() {
            return this.style.getGlyphsUrl()
          }
          addSprite(h, e, a = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(h, e, a, (o => {
              o || this._update(!0)
            })), this
          }
          removeSprite(h) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(h), this._update(!0)
          }
          getSprite() {
            return this.style.getSprite()
          }
          setSprite(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(h, e, (a => {
              a || this._update(!0)
            })), this
          }
          setLight(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(h, e), this._update(!0)
          }
          getLight() {
            return this.style.getLight()
          }
          setSky(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSky(h, e), this._update(!0)
          }
          getSky() {
            return this.style.getSky()
          }
          setFeatureState(h, e) {
            return this.style.setFeatureState(h, e), this._update()
          }
          removeFeatureState(h, e) {
            return this.style.removeFeatureState(h, e), this._update()
          }
          getFeatureState(h) {
            return this.style.getFeatureState(h)
          }
          getContainer() {
            return this._container
          }
          getCanvasContainer() {
            return this._canvasContainer
          }
          getCanvas() {
            return this._canvas
          }
          _containerDimensions() {
            let h = 0,
              e = 0;
            return this._container && (h = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [h, e]
          }
          _setupContainer() {
            const h = this._container;
            h.classList.add("maplibregl-map");
            const e = this._canvasContainer = Z.create("div", "maplibregl-canvas-container", h);
            this._interactive && e.classList.add("maplibregl-interactive"), this._canvas = Z.create("canvas", "maplibregl-canvas", e), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
            const a = this._containerDimensions(),
              o = this._getClampedPixelRatio(a[0], a[1]);
            this._resizeCanvas(a[0], a[1], o);
            const c = this._controlContainer = Z.create("div", "maplibregl-control-container", h),
              d = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((g => {
              d[g] = Z.create("div", `maplibregl-ctrl-${g} `, c)
            })), this._container.addEventListener("scroll", this._onMapScroll, !1)
          }
          _resizeCanvas(h, e, a) {
            this._canvas.width = Math.floor(a * h), this._canvas.height = Math.floor(a * e), this._canvas.style.width = `${h}px`, this._canvas.style.height = `${e}px`
          }
          _setupPainter() {
            const h = Object.assign(Object.assign({}, this._canvasContextAttributes), {
              alpha: !0,
              depth: !0,
              stencil: !0,
              premultipliedAlpha: !0
            });
            let e = null;
            this._canvas.addEventListener("webglcontextcreationerror", (o => {
              e = {
                requestedAttributes: h
              }, o && (e.statusMessage = o.statusMessage, e.type = o.type)
            }), {
              once: !0
            });
            let a = null;
            if (a = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, h) : this._canvas.getContext("webgl2", h) || this._canvas.getContext("webgl", h), !a) {
              const o = "Failed to initialize WebGL";
              throw e ? (e.message = o, new Error(JSON.stringify(e))) : new Error(o)
            }
            this.painter = new nd(a, this.transform), Ie.testSupport(a)
          }
          migrateProjection(h, e) {
            super.migrateProjection(h, e), this.painter.transform = h, this.fire(new s.l("projectiontransition", {
              newProjection: this.style.projection.name
            }))
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded()
          }
          _update(h) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || h, this._sourcesDirty = !0, this.triggerRepaint(), this) : this
          }
          _requestRenderFrame(h) {
            return this._update(), this._renderTaskQueue.add(h)
          }
          _cancelRenderFrame(h) {
            this._renderTaskQueue.remove(h)
          }
          _render(h) {
            var e, a, o, c, d;
            const g = this._idleTriggered ? this._fadeDuration : 0,
              w = ((e = this.style.projection) === null || e === void 0 ? void 0 : e.transitionState) > 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(h), this._removed) return;
            let S = !1;
            if (this.style && this._styleDirty) {
              this._styleDirty = !1;
              const F = this.transform.zoom,
                R = _e();
              this.style.zoomHistory.update(F, R);
              const U = new s.G(F, {
                  now: R,
                  fadeDuration: g,
                  zoomHistory: this.style.zoomHistory,
                  transition: this.style.getTransition()
                }),
                Y = U.crossFadingFactor();
              Y === 1 && Y === this._crossFadingFactor || (S = !0, this._crossFadingFactor = Y), this.style.update(U)
            }
            const A = ((a = this.style.projection) === null || a === void 0 ? void 0 : a.transitionState) > 0 !== w;
            (o = this.style.projection) === null || o === void 0 || o.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((c = this.style.projection) === null || c === void 0 ? void 0 : c.transitionState, (d = this.style.projection) === null || d === void 0 ? void 0 : d.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || A) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.tileManager.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, g, this._crossSourceCollisions, A), this.painter.render(this.style, {
              showTileBoundaries: this.showTileBoundaries,
              showOverdrawInspector: this._showOverdrawInspector,
              rotating: this.isRotating(),
              zooming: this.isZooming(),
              moving: this.isMoving(),
              fadeDuration: g,
              showPadding: this.showPadding
            }), this.fire(new s.l("render")), this.loaded() && !this._loaded && (this._loaded = !0, s.cz.mark(s.cA.load), this.fire(new s.l("load"))), this.style && (this.style.hasTransitions() || S) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const E = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return E || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new s.l("idle")), !this._loaded || this._fullyLoaded || E || (this._fullyLoaded = !0, s.cz.mark(s.cA.fullLoad)), this
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this
          }
          remove() {
            var h;
            this._hash && this._hash.remove();
            for (const a of this._controls) a.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), Xe.removeThrottleControl(this._imageQueueHandle), (h = this._resizeObserver) === null || h === void 0 || h.disconnect();
            const e = this.painter.context.gl.getExtension("WEBGL_lose_context");
            e != null && e.loseContext && e.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), Z.remove(this._canvasContainer), Z.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), s.cz.clearMetrics(), this._removed = !0, this.fire(new s.l("remove"))
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController, oe.frame(this._frameRequest, (h => {
              s.cz.frame(h), this._frameRequest = null;
              try {
                this._render(h)
              } catch (e) {
                if (!s.cB(e) && !(function(a) {
                    return a.message === Kh
                  })(e)) throw e
              }
            }), (() => {})))
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries
          }
          set showTileBoundaries(h) {
            this._showTileBoundaries !== h && (this._showTileBoundaries = h, this._update())
          }
          get showPadding() {
            return !!this._showPadding
          }
          set showPadding(h) {
            this._showPadding !== h && (this._showPadding = h, this._update())
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes
          }
          set showCollisionBoxes(h) {
            this._showCollisionBoxes !== h && (this._showCollisionBoxes = h, h ? this.style._generateCollisionBoxes() : this._update())
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector
          }
          set showOverdrawInspector(h) {
            this._showOverdrawInspector !== h && (this._showOverdrawInspector = h, this._update())
          }
          get repaint() {
            return !!this._repaint
          }
          set repaint(h) {
            this._repaint !== h && (this._repaint = h, this.triggerRepaint())
          }
          get vertices() {
            return !!this._vertices
          }
          set vertices(h) {
            this._vertices = h, this._update()
          }
          get version() {
            return Md
          }
          getCameraTargetElevation() {
            return this.transform.elevation
          }
          getProjection() {
            return this.style.getProjection()
          }
          setProjection(h) {
            return this._lazyInitEmptyStyle(), this.style.setProjection(h), this._update(!0)
          }
        }, T.MapMouseEvent = gn, T.MapTouchEvent = cn, T.MapWheelEvent = hd, T.Marker = al, T.NavigationControl = class {
          constructor(h) {
            this._updateZoomButtons = () => {
              const e = this._map.getZoom(),
                a = e === this._map.getMaxZoom(),
                o = e === this._map.getMinZoom();
              this._zoomInButton.disabled = a, this._zoomOutButton.disabled = o, this._zoomInButton.setAttribute("aria-disabled", a.toString()), this._zoomOutButton.setAttribute("aria-disabled", o.toString())
            }, this._rotateCompassArrow = () => {
              this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1/Math.pow(Math.cos(this._map.transform.pitchInRadians),.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1/Math.pow(Math.cos(this._map.transform.pitchInRadians),.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing-this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`
            }, this._setButtonTitle = (e, a) => {
              const o = this._map._getUIString(`NavigationControl.${a}`);
              e.title = o, e.setAttribute("aria-label", o)
            }, this.options = s.e({}, Hl, h), this._container = Z.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (e => e.preventDefault())), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (e => this._map.zoomIn({}, {
              originalEvent: e
            }))), Z.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (e => this._map.zoomOut({}, {
              originalEvent: e
            }))), Z.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (e => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, {
                originalEvent: e
              }) : this._map.resetNorth({}, {
                originalEvent: e
              })
            })), this._compassIcon = Z.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"))
          }
          onAdd(h) {
            return this._map = h, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new bu(this._map, this._compass, this.options.visualizePitch)), this._container
          }
          onRemove() {
            Z.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map
          }
          _createButton(h, e) {
            const a = Z.create("button", h, this._container);
            return a.type = "button", a.addEventListener("click", e), a
          }
        }, T.Popup = class extends s.E {
          constructor(h) {
            super(), this._updateOpacity = () => {
              this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "")
            }, this.remove = () => (this._content && Z.remove(this._content), this._container && (Z.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new s.l("close"))), this), this._onMouseUp = e => {
              this._update(e.point)
            }, this._onMouseMove = e => {
              this._update(e.point)
            }, this._onDrag = e => {
              this._update(e.point)
            }, this._update = e => {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = Z.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = Z.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className)
                  for (const g of this.options.className.split(" ")) this._container.classList.add(g);
                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer")
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = $l(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !e) return;
              const a = this._flatPos = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && e ? e : this._map.transform.locationToScreenPoint(this._lngLat));
              let o = this.options.anchor;
              const c = Jl(this.options.offset);
              if (!o) {
                const g = this._container.offsetWidth,
                  w = this._container.offsetHeight;
                let S;
                S = a.y + c.bottom.y < w ? ["top"] : a.y > this._map.transform.height - w ? ["bottom"] : [], a.x < g / 2 ? S.push("left") : a.x > this._map.transform.width - g / 2 && S.push("right"), o = S.length === 0 ? "bottom" : S.join("-")
              }
              let d = a.add(c[o]);
              this.options.subpixelPositioning || (d = d.round()), Z.setTransform(this._container, `${$s[o]} translate(${d.x}px,${d.y}px)`), Xl(this._container, o, "popup"), this._updateOpacity()
            }, this._onClose = () => {
              this.remove()
            }, this.options = s.e(Object.create(Su), h)
          }
          addTo(h) {
            return this._map && this.remove(), this._map = h, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new s.l("open")), this
          }
          isOpen() {
            return !!this._map
          }
          getLngLat() {
            return this._lngLat
          }
          setLngLat(h) {
            return this._lngLat = s.U.convert(h), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this
          }
          trackPointer() {
            return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this
          }
          getElement() {
            return this._container
          }
          setText(h) {
            return this.setDOMContent(document.createTextNode(h))
          }
          setHTML(h) {
            const e = document.createDocumentFragment(),
              a = document.createElement("body");
            let o;
            for (a.innerHTML = h; o = a.firstChild, o;) e.appendChild(o);
            return this.setDOMContent(e)
          }
          getMaxWidth() {
            var h;
            return (h = this._container) === null || h === void 0 ? void 0 : h.style.maxWidth
          }
          setMaxWidth(h) {
            return this.options.maxWidth = h, this._update(), this
          }
          setDOMContent(h) {
            if (this._content)
              for (; this._content.hasChildNodes();) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = Z.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(h), this._createCloseButton(), this._update(), this._focusFirstElement(), this
          }
          addClassName(h) {
            return this._container && this._container.classList.add(h), this
          }
          removeClassName(h) {
            return this._container && this._container.classList.remove(h), this
          }
          setOffset(h) {
            return this.options.offset = h, this._update(), this
          }
          toggleClassName(h) {
            if (this._container) return this._container.classList.toggle(h)
          }
          setSubpixelPositioning(h) {
            this.options.subpixelPositioning = h
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = Z.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose))
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const h = this._container.querySelector(Kl);
            h && h.focus()
          }
        }, T.RasterDEMTileSource = ur, T.RasterTileSource = ut, T.ScaleControl = class {
          constructor(h) {
            this._onMove = () => {
              Yl(this._map, this._container, this.options)
            }, this.setUnit = e => {
              this.options.unit = e, Yl(this._map, this._container, this.options)
            }, this.options = Object.assign(Object.assign({}, Tu), h)
          }
          getDefaultPosition() {
            return "bottom-left"
          }
          onAdd(h) {
            return this._map = h, this._container = Z.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", h.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container
          }
          onRemove() {
            Z.remove(this._container), this._map.off("move", this._onMove), this._map = void 0
          }
        }, T.ScrollZoomHandler = bd, T.Style = Zo, T.TerrainControl = class {
          constructor(h) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon()
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"))
            }, this.options = h
          }
          onAdd(h) {
            return this._map = h, this._container = Z.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = Z.create("button", "maplibregl-ctrl-terrain", this._container), Z.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container
          }
          onRemove() {
            Z.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0
          }
        }, T.TwoFingersTouchPitchHandler = vd, T.TwoFingersTouchRotateHandler = Gl, T.TwoFingersTouchZoomHandler = _d, T.TwoFingersTouchZoomRotateHandler = Td, T.VectorTileSource = Ut, T.VideoSource = Nr, T.addSourceType = (h, e) => s._(void 0, void 0, void 0, (function*() {
          if (Wr(h)) throw new Error(`A source type called "${h}" already exists.`);
          ((a, o) => {
            er[a] = o
          })(h, e)
        })), T.clearPrewarmedResources = function() {
          const h = Xt;
          h && (h.isPreloaded() && h.numActive() === 1 ? (h.release(Rt), Xt = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"))
        }, T.createTileMesh = wn, T.getMaxParallelImageRequests = function() {
          return s.a.MAX_PARALLEL_IMAGE_REQUESTS
        }, T.getRTLTextPluginStatus = function() {
          return V().getRTLTextPluginStatus()
        }, T.getVersion = function() {
          return Pu
        }, T.getWorkerCount = function() {
          return $t.workerCount
        }, T.getWorkerUrl = function() {
          return s.a.WORKER_URL
        }, T.importScriptInWorkers = function(h) {
          return Zt().broadcast("IS", h)
        }, T.isTimeFrozen = function() {
          return me.isFrozen()
        }, T.now = _e, T.prewarm = function() {
          nt().acquire(Rt)
        }, T.restoreNow = function() {
          me.restoreNow()
        }, T.setMaxParallelImageRequests = function(h) {
          s.a.MAX_PARALLEL_IMAGE_REQUESTS = h
        }, T.setNow = function(h) {
          me.setNow(h)
        }, T.setRTLTextPlugin = function(h, e) {
          return V().setRTLTextPlugin(h, e)
        }, T.setWorkerCount = function(h) {
          $t.workerCount = h
        }, T.setWorkerUrl = function(h) {
          s.a.WORKER_URL = h
        }
      }));
      var z = v;
      return z
    }))
  })(sp)), sp.exports
}
var E3 = k3();
const Yd = C3(E3);
class Sv {
  constructor(u) {
    fi(this, "gm");
    fi(this, "markers", new Map);
    fi(this, "canvases", new Map);
    fi(this, "canvasSize");
    fi(this, "canvasOpacity", .8);
    this.input = u, this.gm = new kn(this.input.tileSize);
    const v = z0(u.img);
    this.canvasSize = Math.ceil(2e3 / v)
  }
  place([u, v]) {
    const b = this.gm.latLonToPixelsFloor(u, v, this.input.zoom),
      k = this.getMarkerId(b),
      z = this.gm.latLonToPixelBoundsLatLon(u, v, this.input.zoom),
      T = this.input.map;
    if (this.input.markerFn && !this.markers.has(k)) {
      const $ = this.input.markerFn();
      $.setLngLat({
        lat: z.min[0],
        lng: (z.max[1] + z.min[1]) / 2
      }).addTo(T), this.markers.set(k, $)
    }
    const {
      key: s,
      pos: B,
      innerPos: W
    } = this.getCanvasPos(b);
    let ee = this.canvases.get(s);
    if (!ee) {
      const $ = this.canvasSize,
        oe = B.x * $,
        me = B.y * $,
        _e = oe + $ - 1,
        Z = me + $ - 1,
        Ie = this.gm.pixelsToLatLon(oe, Z + 1, this.input.zoom),
        we = this.gm.pixelsToLatLon(_e + 1, me, this.input.zoom);
      ee = new z3({
        id: `${this.input.id}-${s}`,
        img: this.input.img,
        canvasSize: this.canvasSize,
        coordinates: rg({
          min: Ie,
          max: we
        }),
        layerPaint: {
          "raster-resampling": "nearest",
          "raster-opacity": this.canvasOpacity
        }
      }), ee.addTo(this.input.map), this.canvases.set(s, ee)
    }
    ee.place(W.x, W.y)
  }
  clear() {
    const u = this.input.map;
    for (const v of this.canvases.values()) v.removeFrom(u), v.removeDOM();
    this.canvases.clear();
    for (const v of this.markers.values()) v.remove();
    this.markers.clear()
  }
  clearAndPlace(u) {
    this.clear(), this.place(u)
  }
  remove([u, v]) {
    let b = !1;
    const k = this.gm.latLonToPixelsFloor(u, v, this.input.zoom),
      {
        key: z,
        innerPos: T
      } = this.getCanvasPos(k),
      s = this.canvases.get(z);
    s && (b = s.remove(T.x, T.y), s.annotationsCount() === 0 && (this.canvases.delete(z), s.removeFrom(this.input.map), s.removeDOM()));
    const B = this.getMarkerId(k),
      W = this.markers.get(B);
    return W == null || W.remove(), this.markers.delete(B), b
  }
  setCanvasOpacity(u) {
    this.canvasOpacity = u;
    for (const v of this.canvases.values()) v.setOpacity(u)
  }
  getMarkerId([u, v]) {
    return `${this.input.id}:${u},${v}`
  }
  getCanvasPos([u, v]) {
    const b = {
        x: Math.floor(u / this.canvasSize),
        y: Math.floor(v / this.canvasSize)
      },
      k = {
        x: u % this.canvasSize,
        y: v % this.canvasSize
      },
      z = `${b.x},${b.y}`;
    return {
      pos: b,
      innerPos: k,
      key: z
    }
  }
}
class z3 {
  constructor(u) {
    fi(this, "annotations", new Set);
    fi(this, "canvas");
    fi(this, "imgSize");
    fi(this, "maps", new Set);
    fi(this, "pendingRepaint", !1);
    this.input = u, this.imgSize = z0(u.img), this.canvas = document.createElement("canvas"), this.canvas.width = this.input.canvasSize * this.imgSize, this.canvas.height = this.input.canvasSize * this.imgSize
  }
  place(u, v) {
    const b = this.getPixelKey(u, v);
    if (this.annotations.has(b)) return !1;
    const k = this.canvas.getContext("2d");
    if (k) {
      const z = u * this.imgSize,
        T = v * this.imgSize;
      k.drawImage(this.input.img, z, T)
    }
    return this.annotations.add(b), this.triggerRepaint(), !0
  }
  remove(u, v) {
    const b = this.getPixelKey(u, v);
    if (!this.annotations.has(b)) return !1;
    const k = this.canvas.getContext("2d");
    if (k) {
      const z = u * this.imgSize,
        T = v * this.imgSize;
      k.clearRect(z, T, this.imgSize, this.imgSize)
    }
    return this.annotations.delete(b), this.triggerRepaint(), !0
  }
  addTo(u) {
    const v = this.input.id;
    u.getSource(v) || u.addSource(v, {
      type: "canvas",
      canvas: this.canvas,
      coordinates: this.input.coordinates,
      animate: !1
    }), u.getLayer(v) || u.addLayer({
      id: v,
      type: "raster",
      source: v,
      paint: this.input.layerPaint
    }), this.maps.add(u)
  }
  removeFrom(u) {
    const {
      id: v
    } = this.input;
    u.getLayer(v) && u.removeLayer(v), u.getSource(v) && u.removeSource(v), this.maps.delete(u)
  }
  removeDOM() {
    this.canvas.remove()
  }
  annotationsCount() {
    return this.annotations.size
  }
  setOpacity(u) {
    for (const v of this.maps.values()) v.setPaintProperty(this.input.id, "raster-opacity", u)
  }
  getPixelKey(u, v) {
    return `${u},${v}`
  }
  triggerRepaint() {
    this.pendingRepaint || (this.pendingRepaint = !0, requestAnimationFrame(() => {
      for (const u of this.maps.values()) {
        const v = u.getSource(this.input.id);
        v.play(), u.once("render", () => {
          v.pause(), this.pendingRepaint = !1
        })
      }
    }))
  }
}

function z0(y) {
  return Math.max(y.naturalWidth, y.naturalHeight)
}

function L3() {
  return window.matchMedia("(display-mode: standalone)").matches || "standalone" in window.navigator && window.navigator.standalone === !0
}

function D3(y) {
  const u = {
      opaque: !0
    },
    v = y.searchParams.get("lat"),
    b = y.searchParams.get("lng");
  v && b && (u.pos = {
    lat: parseFloat(v),
    lng: parseFloat(b)
  });
  const k = y.searchParams.get("zoom");
  k && (u.zoom = parseFloat(k));
  const z = y.searchParams.get("season");
  z && (u.season = parseInt(z));
  const T = y.searchParams.get("opaque");
  return T && (u.opaque = T !== "0"), y.searchParams.get("select") && (u.select = !0), y.searchParams.get("twitch-migration") && (u.twitchMigration = !0), u.newUser = !!y.searchParams.get("new-user"), u.discordLinked = !!y.searchParams.get("discord-linked"), u.alliance = !!y.searchParams.get("alliance"), u
}

function R3(y, u) {
  return y = new URL(y), u.pos !== void 0 && (y.searchParams.set("lat", u.pos.lat.toString()), y.searchParams.set("lng", u.pos.lng.toString())), u.zoom !== void 0 && y.searchParams.set("zoom", u.zoom.toString()), u.season !== void 0 && y.searchParams.set("season", u.season.toString()), u.opaque !== void 0 && y.searchParams.set("opaque", u.opaque ? "1" : "0"), u.newUser !== void 0 && y.searchParams.set("new-user", u.newUser ? "1" : "0"), u.alliance !== void 0 && y.searchParams.set("alliance", u.alliance ? "1" : "0"), u.select && y.searchParams.set("alliance", "1"), y
}
var lm = function() {
  return lm = Object.assign || function(u) {
    for (var v, b = 1, k = arguments.length; b < k; b++) {
      v = arguments[b];
      for (var z in v) Object.prototype.hasOwnProperty.call(v, z) && (u[z] = v[z])
    }
    return u
  }, lm.apply(this, arguments)
};

function Ds(y, u, v, b) {
  function k(z) {
    return z instanceof v ? z : new v(function(T) {
      T(z)
    })
  }
  return new(v || (v = Promise))(function(z, T) {
    function s(ee) {
      try {
        W(b.next(ee))
      } catch ($) {
        T($)
      }
    }

    function B(ee) {
      try {
        W(b.throw(ee))
      } catch ($) {
        T($)
      }
    }

    function W(ee) {
      ee.done ? z(ee.value) : k(ee.value).then(s, B)
    }
    W((b = b.apply(y, u || [])).next())
  })
}

function Rs(y, u) {
  var v = {
      label: 0,
      sent: function() {
        if (z[0] & 1) throw z[1];
        return z[1]
      },
      trys: [],
      ops: []
    },
    b, k, z, T = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
  return T.next = s(0), T.throw = s(1), T.return = s(2), typeof Symbol == "function" && (T[Symbol.iterator] = function() {
    return this
  }), T;

  function s(W) {
    return function(ee) {
      return B([W, ee])
    }
  }

  function B(W) {
    if (b) throw new TypeError("Generator is already executing.");
    for (; T && (T = 0, W[0] && (v = 0)), v;) try {
      if (b = 1, k && (z = W[0] & 2 ? k.return : W[0] ? k.throw || ((z = k.return) && z.call(k), 0) : k.next) && !(z = z.call(k, W[1])).done) return z;
      switch (k = 0, z && (W = [W[0] & 2, z.value]), W[0]) {
        case 0:
        case 1:
          z = W;
          break;
        case 4:
          return v.label++, {
            value: W[1],
            done: !1
          };
        case 5:
          v.label++, k = W[1], W = [0];
          continue;
        case 7:
          W = v.ops.pop(), v.trys.pop();
          continue;
        default:
          if (z = v.trys, !(z = z.length > 0 && z[z.length - 1]) && (W[0] === 6 || W[0] === 2)) {
            v = 0;
            continue
          }
          if (W[0] === 3 && (!z || W[1] > z[0] && W[1] < z[3])) {
            v.label = W[1];
            break
          }
          if (W[0] === 6 && v.label < z[1]) {
            v.label = z[1], z = W;
            break
          }
          if (z && v.label < z[2]) {
            v.label = z[2], v.ops.push(W);
            break
          }
          z[2] && v.ops.pop(), v.trys.pop();
          continue
      }
      W = u.call(y, v)
    } catch (ee) {
      W = [6, ee], k = 0
    } finally {
      b = z = 0
    }
    if (W[0] & 5) throw W[1];
    return {
      value: W[0] ? W[1] : void 0,
      done: !0
    }
  }
}

function L0(y, u, v) {
  if (v || arguments.length === 2)
    for (var b = 0, k = u.length, z; b < k; b++)(z || !(b in u)) && (z || (z = Array.prototype.slice.call(u, 0, b)), z[b] = u[b]);
  return y.concat(z || Array.prototype.slice.call(u))
}
var D0 = "4.6.2";

function xp(y, u) {
  return new Promise(function(v) {
    return setTimeout(v, y, u)
  })
}

function F3() {
  return new Promise(function(y) {
    var u = new MessageChannel;
    u.port1.onmessage = function() {
      return y()
    }, u.port2.postMessage(null)
  })
}

function B3(y, u) {
  u === void 0 && (u = 1 / 0);
  var v = window.requestIdleCallback;
  return v ? new Promise(function(b) {
    return v.call(window, function() {
      return b()
    }, {
      timeout: u
    })
  }) : xp(Math.min(y, u))
}

function R0(y) {
  return !!y && typeof y.then == "function"
}

function Pv(y, u) {
  try {
    var v = y();
    R0(v) ? v.then(function(b) {
      return u(!0, b)
    }, function(b) {
      return u(!1, b)
    }) : u(!0, v)
  } catch (b) {
    u(!1, b)
  }
}

function Mv(y, u, v) {
  return v === void 0 && (v = 16), Ds(this, void 0, void 0, function() {
    var b, k, z, T;
    return Rs(this, function(s) {
      switch (s.label) {
        case 0:
          b = Array(y.length), k = Date.now(), z = 0, s.label = 1;
        case 1:
          return z < y.length ? (b[z] = u(y[z], z), T = Date.now(), T >= k + v ? (k = T, [4, F3()]) : [3, 3]) : [3, 4];
        case 2:
          s.sent(), s.label = 3;
        case 3:
          return ++z, [3, 1];
        case 4:
          return [2, b]
      }
    })
  })
}

function Yu(y) {
  return y.then(void 0, function() {}), y
}

function O3(y, u) {
  for (var v = 0, b = y.length; v < b; ++v)
    if (y[v] === u) return !0;
  return !1
}

function j3(y, u) {
  return !O3(y, u)
}

function ag(y) {
  return parseInt(y)
}

function xs(y) {
  return parseFloat(y)
}

function so(y, u) {
  return typeof y == "number" && isNaN(y) ? u : y
}

function En(y) {
  return y.reduce(function(u, v) {
    return u + (v ? 1 : 0)
  }, 0)
}

function F0(y, u) {
  if (u === void 0 && (u = 1), Math.abs(u) >= 1) return Math.round(y / u) * u;
  var v = 1 / u;
  return Math.round(y * v) / v
}

function q3(y) {
  for (var u, v, b = "Unexpected syntax '".concat(y, "'"), k = /^\s*([a-z-]*)(.*)$/i.exec(y), z = k[1] || void 0, T = {}, s = /([.:#][\w-]+|\[.+?\])/gi, B = function(oe, me) {
      T[oe] = T[oe] || [], T[oe].push(me)
    };;) {
    var W = s.exec(k[2]);
    if (!W) break;
    var ee = W[0];
    switch (ee[0]) {
      case ".":
        B("class", ee.slice(1));
        break;
      case "#":
        B("id", ee.slice(1));
        break;
      case "[": {
        var $ = /^\[([\w-]+)([~|^$*]?=("(.*?)"|([\w-]+)))?(\s+[is])?\]$/.exec(ee);
        if ($) B($[1], (v = (u = $[4]) !== null && u !== void 0 ? u : $[5]) !== null && v !== void 0 ? v : "");
        else throw new Error(b);
        break
      }
      default:
        throw new Error(b)
    }
  }
  return [z, T]
}

function V3(y) {
  for (var u = new Uint8Array(y.length), v = 0; v < y.length; v++) {
    var b = y.charCodeAt(v);
    if (b > 127) return new TextEncoder().encode(y);
    u[v] = b
  }
  return u
}

function Do(y, u) {
  var v = y[0] >>> 16,
    b = y[0] & 65535,
    k = y[1] >>> 16,
    z = y[1] & 65535,
    T = u[0] >>> 16,
    s = u[0] & 65535,
    B = u[1] >>> 16,
    W = u[1] & 65535,
    ee = 0,
    $ = 0,
    oe = 0,
    me = 0;
  me += z + W, oe += me >>> 16, me &= 65535, oe += k + B, $ += oe >>> 16, oe &= 65535, $ += b + s, ee += $ >>> 16, $ &= 65535, ee += v + T, ee &= 65535, y[0] = ee << 16 | $, y[1] = oe << 16 | me
}

function as(y, u) {
  var v = y[0] >>> 16,
    b = y[0] & 65535,
    k = y[1] >>> 16,
    z = y[1] & 65535,
    T = u[0] >>> 16,
    s = u[0] & 65535,
    B = u[1] >>> 16,
    W = u[1] & 65535,
    ee = 0,
    $ = 0,
    oe = 0,
    me = 0;
  me += z * W, oe += me >>> 16, me &= 65535, oe += k * W, $ += oe >>> 16, oe &= 65535, oe += z * B, $ += oe >>> 16, oe &= 65535, $ += b * W, ee += $ >>> 16, $ &= 65535, $ += k * B, ee += $ >>> 16, $ &= 65535, $ += z * s, ee += $ >>> 16, $ &= 65535, ee += v * W + b * B + k * s + z * T, ee &= 65535, y[0] = ee << 16 | $, y[1] = oe << 16 | me
}

function _c(y, u) {
  var v = y[0];
  u %= 64, u === 32 ? (y[0] = y[1], y[1] = v) : u < 32 ? (y[0] = v << u | y[1] >>> 32 - u, y[1] = y[1] << u | v >>> 32 - u) : (u -= 32, y[0] = y[1] << u | v >>> 32 - u, y[1] = v << u | y[1] >>> 32 - u)
}

function Yn(y, u) {
  u %= 64, u !== 0 && (u < 32 ? (y[0] = y[1] >>> 32 - u, y[1] = y[1] << u) : (y[0] = y[1] << u - 32, y[1] = 0))
}

function wa(y, u) {
  y[0] ^= u[0], y[1] ^= u[1]
}
var Z3 = [4283543511, 3981806797],
  N3 = [3301882366, 444984403];

function Iv(y) {
  var u = [0, y[0] >>> 1];
  wa(y, u), as(y, Z3), u[1] = y[0] >>> 1, wa(y, u), as(y, N3), u[1] = y[0] >>> 1, wa(y, u)
}
var Kd = [2277735313, 289559509],
  Jd = [1291169091, 658871167],
  Cv = [0, 5],
  U3 = [0, 1390208809],
  G3 = [0, 944331445];

function W3(y, u) {
  var v = V3(y);
  u = u || 0;
  var b = [0, v.length],
    k = b[1] % 16,
    z = b[1] - k,
    T = [0, u],
    s = [0, u],
    B = [0, 0],
    W = [0, 0],
    ee;
  for (ee = 0; ee < z; ee = ee + 16) B[0] = v[ee + 4] | v[ee + 5] << 8 | v[ee + 6] << 16 | v[ee + 7] << 24, B[1] = v[ee] | v[ee + 1] << 8 | v[ee + 2] << 16 | v[ee + 3] << 24, W[0] = v[ee + 12] | v[ee + 13] << 8 | v[ee + 14] << 16 | v[ee + 15] << 24, W[1] = v[ee + 8] | v[ee + 9] << 8 | v[ee + 10] << 16 | v[ee + 11] << 24, as(B, Kd), _c(B, 31), as(B, Jd), wa(T, B), _c(T, 27), Do(T, s), as(T, Cv), Do(T, U3), as(W, Jd), _c(W, 33), as(W, Kd), wa(s, W), _c(s, 31), Do(s, T), as(s, Cv), Do(s, G3);
  B[0] = 0, B[1] = 0, W[0] = 0, W[1] = 0;
  var $ = [0, 0];
  switch (k) {
    case 15:
      $[1] = v[ee + 14], Yn($, 48), wa(W, $);
    case 14:
      $[1] = v[ee + 13], Yn($, 40), wa(W, $);
    case 13:
      $[1] = v[ee + 12], Yn($, 32), wa(W, $);
    case 12:
      $[1] = v[ee + 11], Yn($, 24), wa(W, $);
    case 11:
      $[1] = v[ee + 10], Yn($, 16), wa(W, $);
    case 10:
      $[1] = v[ee + 9], Yn($, 8), wa(W, $);
    case 9:
      $[1] = v[ee + 8], wa(W, $), as(W, Jd), _c(W, 33), as(W, Kd), wa(s, W);
    case 8:
      $[1] = v[ee + 7], Yn($, 56), wa(B, $);
    case 7:
      $[1] = v[ee + 6], Yn($, 48), wa(B, $);
    case 6:
      $[1] = v[ee + 5], Yn($, 40), wa(B, $);
    case 5:
      $[1] = v[ee + 4], Yn($, 32), wa(B, $);
    case 4:
      $[1] = v[ee + 3], Yn($, 24), wa(B, $);
    case 3:
      $[1] = v[ee + 2], Yn($, 16), wa(B, $);
    case 2:
      $[1] = v[ee + 1], Yn($, 8), wa(B, $);
    case 1:
      $[1] = v[ee], wa(B, $), as(B, Kd), _c(B, 31), as(B, Jd), wa(T, B)
  }
  return wa(T, b), wa(s, b), Do(T, s), Do(s, T), Iv(T), Iv(s), Do(T, s), Do(s, T), ("00000000" + (T[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (T[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (s[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (s[1] >>> 0).toString(16)).slice(-8)
}

function H3(y) {
  var u;
  return lm({
    name: y.name,
    message: y.message,
    stack: (u = y.stack) === null || u === void 0 ? void 0 : u.split(`
`)
  }, y)
}

function $3(y) {
  return /^function\s.*?\{\s*\[native code]\s*}$/.test(String(y))
}

function X3(y) {
  return typeof y != "function"
}

function Y3(y, u) {
  var v = Yu(new Promise(function(b) {
    var k = Date.now();
    Pv(y.bind(null, u), function() {
      for (var z = [], T = 0; T < arguments.length; T++) z[T] = arguments[T];
      var s = Date.now() - k;
      if (!z[0]) return b(function() {
        return {
          error: z[1],
          duration: s
        }
      });
      var B = z[1];
      if (X3(B)) return b(function() {
        return {
          value: B,
          duration: s
        }
      });
      b(function() {
        return new Promise(function(W) {
          var ee = Date.now();
          Pv(B, function() {
            for (var $ = [], oe = 0; oe < arguments.length; oe++) $[oe] = arguments[oe];
            var me = s + Date.now() - ee;
            if (!$[0]) return W({
              error: $[1],
              duration: me
            });
            W({
              value: $[1],
              duration: me
            })
          })
        })
      })
    })
  }));
  return function() {
    return v.then(function(k) {
      return k()
    })
  }
}

function K3(y, u, v, b) {
  var k = Object.keys(y).filter(function(T) {
      return j3(v, T)
    }),
    z = Yu(Mv(k, function(T) {
      return Y3(y[T], u)
    }, b));
  return function() {
    return Ds(this, void 0, void 0, function() {
      var s, B, W, ee, $;
      return Rs(this, function(oe) {
        switch (oe.label) {
          case 0:
            return [4, z];
          case 1:
            return s = oe.sent(), [4, Mv(s, function(me) {
              return Yu(me())
            }, b)];
          case 2:
            return B = oe.sent(), [4, Promise.all(B)];
          case 3:
            for (W = oe.sent(), ee = {}, $ = 0; $ < k.length; ++$) ee[k[$]] = W[$];
            return [2, ee]
        }
      })
    })
  }
}

function B0() {
  var y = window,
    u = navigator;
  return En(["MSCSSMatrix" in y, "msSetImmediate" in y, "msIndexedDB" in y, "msMaxTouchPoints" in u, "msPointerEnabled" in u]) >= 4
}

function J3() {
  var y = window,
    u = navigator;
  return En(["msWriteProfilerMark" in y, "MSStream" in y, "msLaunchUri" in u, "msSaveBlob" in u]) >= 3 && !B0()
}

function Ah() {
  var y = window,
    u = navigator;
  return En(["webkitPersistentStorage" in u, "webkitTemporaryStorage" in u, (u.vendor || "").indexOf("Google") === 0, "webkitResolveLocalFileSystemURL" in y, "BatteryManager" in y, "webkitMediaStream" in y, "webkitSpeechGrammar" in y]) >= 5
}

function ws() {
  var y = window,
    u = navigator;
  return En(["ApplePayError" in y, "CSSPrimitiveValue" in y, "Counter" in y, u.vendor.indexOf("Apple") === 0, "RGBColor" in y, "WebKitMediaKeys" in y]) >= 4
}

function ng() {
  var y = window,
    u = y.HTMLElement,
    v = y.Document;
  return En(["safari" in y, !("ongestureend" in y), !("TouchEvent" in y), !("orientation" in y), u && !("autocapitalize" in u.prototype), v && "pointerLockElement" in v.prototype]) >= 4
}

function kh() {
  var y = window;
  return $3(y.print) && String(y.browser) === "[object WebPageNamespace]"
}

function O0() {
  var y, u, v = window;
  return En(["buildID" in navigator, "MozAppearance" in ((u = (y = document.documentElement) === null || y === void 0 ? void 0 : y.style) !== null && u !== void 0 ? u : {}), "onmozfullscreenchange" in v, "mozInnerScreenX" in v, "CSSMozDocumentRule" in v, "CanvasCaptureMediaStream" in v]) >= 4
}

function Q3() {
  var y = window;
  return En([!("MediaSettingsRange" in y), "RTCEncodedAudioFrame" in y, "" + y.Intl == "[object Intl]", "" + y.Reflect == "[object Reflect]"]) >= 3
}

function eT() {
  var y = window,
    u = y.URLPattern;
  return En(["union" in Set.prototype, "Iterator" in y, u && "hasRegExpGroups" in u.prototype, "RGB8" in WebGLRenderingContext.prototype]) >= 3
}

function tT() {
  var y = window;
  return En(["DOMRectList" in y, "RTCPeerConnectionIceEvent" in y, "SVGGeometryElement" in y, "ontransitioncancel" in y]) >= 3
}

function Eh() {
  var y = window,
    u = navigator,
    v = y.CSS,
    b = y.HTMLButtonElement;
  return En([!("getStorageUpdates" in u), b && "popover" in b.prototype, "CSSCounterStyleRule" in y, v.supports("font-size-adjust: ex-height 0.5"), v.supports("text-transform: full-width")]) >= 4
}

function rT() {
  if (navigator.platform === "iPad") return !0;
  var y = screen,
    u = y.width / y.height;
  return En(["MediaSource" in window, !!Element.prototype.webkitRequestFullscreen, u > .65 && u < 1.53]) >= 2
}

function iT() {
  var y = document;
  return y.fullscreenElement || y.msFullscreenElement || y.mozFullScreenElement || y.webkitFullscreenElement || null
}

function aT() {
  var y = document;
  return (y.exitFullscreen || y.msExitFullscreen || y.mozCancelFullScreen || y.webkitExitFullscreen).call(y)
}

function sg() {
  var y = Ah(),
    u = O0(),
    v = window,
    b = navigator,
    k = "connection";
  return y ? En([!("SharedWorker" in v), b[k] && "ontypechange" in b[k], !("sinkId" in new Audio)]) >= 2 : u ? En(["onorientationchange" in v, "orientation" in v, /android/i.test(b.appVersion)]) >= 2 : !1
}

function nT() {
  var y = navigator,
    u = window,
    v = Audio.prototype,
    b = u.visualViewport;
  return En(["srLatency" in v, "srChannelCount" in v, "devicePosture" in y, b && "segments" in b, "getTextInformation" in Image.prototype]) >= 3
}

function sT() {
  return cT() ? -4 : oT()
}

function oT() {
  var y = window,
    u = y.OfflineAudioContext || y.webkitOfflineAudioContext;
  if (!u) return -2;
  if (lT()) return -1;
  var v = 4500,
    b = 5e3,
    k = new u(1, b, 44100),
    z = k.createOscillator();
  z.type = "triangle", z.frequency.value = 1e4;
  var T = k.createDynamicsCompressor();
  T.threshold.value = -50, T.knee.value = 40, T.ratio.value = 12, T.attack.value = 0, T.release.value = .25, z.connect(T), T.connect(k.destination), z.start(0);
  var s = uT(k),
    B = s[0],
    W = s[1],
    ee = Yu(B.then(function($) {
      return hT($.getChannelData(0).subarray(v))
    }, function($) {
      if ($.name === "timeout" || $.name === "suspended") return -3;
      throw $
    }));
  return function() {
    return W(), ee
  }
}

function lT() {
  return ws() && !ng() && !tT()
}

function cT() {
  return ws() && Eh() && kh() || Ah() && nT() && eT()
}

function uT(y) {
  var u = 3,
    v = 500,
    b = 500,
    k = 5e3,
    z = function() {},
    T = new Promise(function(s, B) {
      var W = !1,
        ee = 0,
        $ = 0;
      y.oncomplete = function(_e) {
        return s(_e.renderedBuffer)
      };
      var oe = function() {
          setTimeout(function() {
            return B(Av("timeout"))
          }, Math.min(b, $ + k - Date.now()))
        },
        me = function() {
          try {
            var _e = y.startRendering();
            switch (R0(_e) && Yu(_e), y.state) {
              case "running":
                $ = Date.now(), W && oe();
                break;
              case "suspended":
                document.hidden || ee++, W && ee >= u ? B(Av("suspended")) : setTimeout(me, v);
                break
            }
          } catch (Z) {
            B(Z)
          }
        };
      me(), z = function() {
        W || (W = !0, $ > 0 && oe())
      }
    });
  return [T, z]
}

function hT(y) {
  for (var u = 0, v = 0; v < y.length; ++v) u += Math.abs(y[v]);
  return u
}

function Av(y) {
  var u = new Error(y);
  return u.name = y, u
}

function j0(y, u, v) {
  var b, k, z;
  return v === void 0 && (v = 50), Ds(this, void 0, void 0, function() {
    var T, s;
    return Rs(this, function(B) {
      switch (B.label) {
        case 0:
          T = document, B.label = 1;
        case 1:
          return T.body ? [3, 3] : [4, xp(v)];
        case 2:
          return B.sent(), [3, 1];
        case 3:
          s = T.createElement("iframe"), B.label = 4;
        case 4:
          return B.trys.push([4, , 10, 11]), [4, new Promise(function(W, ee) {
            var $ = !1,
              oe = function() {
                $ = !0, W()
              },
              me = function(Ie) {
                $ = !0, ee(Ie)
              };
            s.onload = oe, s.onerror = me;
            var _e = s.style;
            _e.setProperty("display", "block", "important"), _e.position = "absolute", _e.top = "0", _e.left = "0", _e.visibility = "hidden", u && "srcdoc" in s ? s.srcdoc = u : s.src = "about:blank", T.body.appendChild(s);
            var Z = function() {
              var Ie, we;
              $ || (((we = (Ie = s.contentWindow) === null || Ie === void 0 ? void 0 : Ie.document) === null || we === void 0 ? void 0 : we.readyState) === "complete" ? oe() : setTimeout(Z, 10))
            };
            Z()
          })];
        case 5:
          B.sent(), B.label = 6;
        case 6:
          return !((k = (b = s.contentWindow) === null || b === void 0 ? void 0 : b.document) === null || k === void 0) && k.body ? [3, 8] : [4, xp(v)];
        case 7:
          return B.sent(), [3, 6];
        case 8:
          return [4, y(s, s.contentWindow)];
        case 9:
          return [2, B.sent()];
        case 10:
          return (z = s.parentNode) === null || z === void 0 || z.removeChild(s), [7];
        case 11:
          return [2]
      }
    })
  })
}

function dT(y) {
  for (var u = q3(y), v = u[0], b = u[1], k = document.createElement(v ?? "div"), z = 0, T = Object.keys(b); z < T.length; z++) {
    var s = T[z],
      B = b[s].join(" ");
    s === "style" ? pT(k.style, B) : k.setAttribute(s, B)
  }
  return k
}

function pT(y, u) {
  for (var v = 0, b = u.split(";"); v < b.length; v++) {
    var k = b[v],
      z = /^\s*([\w-]+)\s*:\s*(.+?)(\s*!([\w-]+))?\s*$/.exec(k);
    if (z) {
      var T = z[1],
        s = z[2],
        B = z[4];
      y.setProperty(T, s, B || "")
    }
  }
}

function fT() {
  for (var y = window;;) {
    var u = y.parent;
    if (!u || u === y) return !1;
    try {
      if (u.location.origin !== y.location.origin) return !0
    } catch (v) {
      if (v instanceof Error && v.name === "SecurityError") return !0;
      throw v
    }
    y = u
  }
}
var mT = "mmMwWLliI0O&1",
  gT = "48px",
  vc = ["monospace", "sans-serif", "serif"],
  kv = ["sans-serif-thin", "ARNO PRO", "Agency FB", "Arabic Typesetting", "Arial Unicode MS", "AvantGarde Bk BT", "BankGothic Md BT", "Batang", "Bitstream Vera Sans Mono", "Calibri", "Century", "Century Gothic", "Clarendon", "EUROSTILE", "Franklin Gothic", "Futura Bk BT", "Futura Md BT", "GOTHAM", "Gill Sans", "HELV", "Haettenschweiler", "Helvetica Neue", "Humanst521 BT", "Leelawadee", "Letter Gothic", "Levenim MT", "Lucida Bright", "Lucida Sans", "Menlo", "MS Mincho", "MS Outlook", "MS Reference Specialty", "MS UI Gothic", "MT Extra", "MYRIAD PRO", "Marlett", "Meiryo UI", "Microsoft Uighur", "Minion Pro", "Monotype Corsiva", "PMingLiU", "Pristina", "SCRIPTINA", "Segoe UI Light", "Serifa", "SimHei", "Small Fonts", "Staccato222 BT", "TRAJAN PRO", "Univers CE 55 Medium", "Vrinda", "ZWAdobeF"];

function _T() {
  var y = this;
  return j0(function(u, v) {
    var b = v.document;
    return Ds(y, void 0, void 0, function() {
      var k, z, T, s, B, W, ee, $, oe, me, _e, Z;
      return Rs(this, function(Ie) {
        for (k = b.body, k.style.fontSize = gT, z = b.createElement("div"), z.style.setProperty("visibility", "hidden", "important"), T = {}, s = {}, B = function(we) {
            var Fe = b.createElement("span"),
              xe = Fe.style;
            return xe.position = "absolute", xe.top = "0", xe.left = "0", xe.fontFamily = we, Fe.textContent = mT, z.appendChild(Fe), Fe
          }, W = function(we, Fe) {
            return B("'".concat(we, "',").concat(Fe))
          }, ee = function() {
            return vc.map(B)
          }, $ = function() {
            for (var we = {}, Fe = function(Xe) {
                we[Xe] = vc.map(function(Ae) {
                  return W(Xe, Ae)
                })
              }, xe = 0, $e = kv; xe < $e.length; xe++) {
              var et = $e[xe];
              Fe(et)
            }
            return we
          }, oe = function(we) {
            return vc.some(function(Fe, xe) {
              return we[xe].offsetWidth !== T[Fe] || we[xe].offsetHeight !== s[Fe]
            })
          }, me = ee(), _e = $(), k.appendChild(z), Z = 0; Z < vc.length; Z++) T[vc[Z]] = me[Z].offsetWidth, s[vc[Z]] = me[Z].offsetHeight;
        return [2, kv.filter(function(we) {
          return oe(_e[we])
        })]
      })
    })
  })
}

function vT() {
  var y = navigator.plugins;
  if (y) {
    for (var u = [], v = 0; v < y.length; ++v) {
      var b = y[v];
      if (b) {
        for (var k = [], z = 0; z < b.length; ++z) {
          var T = b[z];
          k.push({
            type: T.type,
            suffixes: T.suffixes
          })
        }
        u.push({
          name: b.name,
          description: b.description,
          mimeTypes: k
        })
      }
    }
    return u
  }
}

function yT() {
  return xT(IT())
}

function xT(y) {
  var u, v = !1,
    b, k, z = bT(),
    T = z[0],
    s = z[1];
  return wT(T, s) ? (v = TT(s), y ? b = k = "skipped" : (u = ST(T, s), b = u[0], k = u[1])) : b = k = "unsupported", {
    winding: v,
    geometry: b,
    text: k
  }
}

function bT() {
  var y = document.createElement("canvas");
  return y.width = 1, y.height = 1, [y, y.getContext("2d")]
}

function wT(y, u) {
  return !!(u && y.toDataURL)
}

function TT(y) {
  return y.rect(0, 0, 10, 10), y.rect(2, 2, 6, 6), !y.isPointInPath(5, 5, "evenodd")
}

function ST(y, u) {
  PT(y, u);
  var v = Gf(y),
    b = Gf(y);
  if (v !== b) return ["unstable", "unstable"];
  MT(y, u);
  var k = Gf(y);
  return [k, v]
}

function PT(y, u) {
  y.width = 240, y.height = 60, u.textBaseline = "alphabetic", u.fillStyle = "#f60", u.fillRect(100, 1, 62, 20), u.fillStyle = "#069", u.font = '11pt "Times New Roman"';
  var v = "Cwm fjordbank gly ".concat("");
  u.fillText(v, 2, 15), u.fillStyle = "rgba(102, 204, 0, 0.2)", u.font = "18pt Arial", u.fillText(v, 4, 45)
}

function MT(y, u) {
  y.width = 122, y.height = 110, u.globalCompositeOperation = "multiply";
  for (var v = 0, b = [
      ["#f2f", 40, 40],
      ["#2ff", 80, 40],
      ["#ff2", 60, 80]
    ]; v < b.length; v++) {
    var k = b[v],
      z = k[0],
      T = k[1],
      s = k[2];
    u.fillStyle = z, u.beginPath(), u.arc(T, s, 40, 0, Math.PI * 2, !0), u.closePath(), u.fill()
  }
  u.fillStyle = "#f9c", u.arc(60, 60, 60, 0, Math.PI * 2, !0), u.arc(60, 60, 20, 0, Math.PI * 2, !0), u.fill("evenodd")
}

function Gf(y) {
  return y.toDataURL()
}

function IT() {
  return ws() && Eh() && kh()
}

function CT() {
  var y = navigator,
    u = 0,
    v;
  y.maxTouchPoints !== void 0 ? u = ag(y.maxTouchPoints) : y.msMaxTouchPoints !== void 0 && (u = y.msMaxTouchPoints);
  try {
    document.createEvent("TouchEvent"), v = !0
  } catch {
    v = !1
  }
  var b = "ontouchstart" in window;
  return {
    maxTouchPoints: u,
    touchEvent: v,
    touchStart: b
  }
}

function AT() {
  return navigator.oscpu
}

function kT() {
  var y = navigator,
    u = [],
    v = y.language || y.userLanguage || y.browserLanguage || y.systemLanguage;
  if (v !== void 0 && u.push([v]), Array.isArray(y.languages)) Ah() && Q3() || u.push(y.languages);
  else if (typeof y.languages == "string") {
    var b = y.languages;
    b && u.push(b.split(","))
  }
  return u
}

function ET() {
  return window.screen.colorDepth
}

function zT() {
  return so(xs(navigator.deviceMemory), void 0)
}

function LT() {
  if (!(ws() && Eh() && kh())) return DT()
}

function DT() {
  var y = screen,
    u = function(b) {
      return so(ag(b), null)
    },
    v = [u(y.width), u(y.height)];
  return v.sort().reverse(), v
}
var RT = 2500,
  FT = 10,
  op, Wf;

function BT() {
  if (Wf === void 0) {
    var y = function() {
      var u = cm();
      um(u) ? Wf = setTimeout(y, RT) : (op = u, Wf = void 0)
    };
    y()
  }
}

function OT() {
  var y = this;
  return BT(),
    function() {
      return Ds(y, void 0, void 0, function() {
        var u;
        return Rs(this, function(v) {
          switch (v.label) {
            case 0:
              return u = cm(), um(u) ? op ? [2, L0([], op, !0)] : iT() ? [4, aT()] : [3, 2] : [3, 2];
            case 1:
              v.sent(), u = cm(), v.label = 2;
            case 2:
              return um(u) || (op = u), [2, u]
          }
        })
      })
    }
}

function jT() {
  var y = this;
  if (ws() && Eh() && kh()) return function() {
    return Promise.resolve(void 0)
  };
  var u = OT();
  return function() {
    return Ds(y, void 0, void 0, function() {
      var v, b;
      return Rs(this, function(k) {
        switch (k.label) {
          case 0:
            return [4, u()];
          case 1:
            return v = k.sent(), b = function(z) {
              return z === null ? null : F0(z, FT)
            }, [2, [b(v[0]), b(v[1]), b(v[2]), b(v[3])]]
        }
      })
    })
  }
}

function cm() {
  var y = screen;
  return [so(xs(y.availTop), null), so(xs(y.width) - xs(y.availWidth) - so(xs(y.availLeft), 0), null), so(xs(y.height) - xs(y.availHeight) - so(xs(y.availTop), 0), null), so(xs(y.availLeft), null)]
}

function um(y) {
  for (var u = 0; u < 4; ++u)
    if (y[u]) return !1;
  return !0
}

function qT() {
  return so(ag(navigator.hardwareConcurrency), void 0)
}

function VT() {
  var y, u = (y = window.Intl) === null || y === void 0 ? void 0 : y.DateTimeFormat;
  if (u) {
    var v = new u().resolvedOptions().timeZone;
    if (v) return v
  }
  var b = -ZT();
  return "UTC".concat(b >= 0 ? "+" : "").concat(b)
}

function ZT() {
  var y = new Date().getFullYear();
  return Math.max(xs(new Date(y, 0, 1).getTimezoneOffset()), xs(new Date(y, 6, 1).getTimezoneOffset()))
}

function NT() {
  try {
    return !!window.sessionStorage
  } catch {
    return !0
  }
}

function UT() {
  try {
    return !!window.localStorage
  } catch {
    return !0
  }
}

function GT() {
  if (!(B0() || J3())) try {
    return !!window.indexedDB
  } catch {
    return !0
  }
}

function WT() {
  return !!window.openDatabase
}

function HT() {
  return navigator.cpuClass
}

function $T() {
  var y = navigator.platform;
  return y === "MacIntel" && ws() && !ng() ? rT() ? "iPad" : "iPhone" : y
}

function XT() {
  return navigator.vendor || ""
}

function YT() {
  for (var y = [], u = 0, v = ["chrome", "safari", "__crWeb", "__gCrWeb", "yandex", "__yb", "__ybro", "__firefox__", "__edgeTrackingPreventionStatistics", "webkit", "oprt", "samsungAr", "ucweb", "UCShellJava", "puffinDevice"]; u < v.length; u++) {
    var b = v[u],
      k = window[b];
    k && typeof k == "object" && y.push(b)
  }
  return y.sort()
}

function KT() {
  var y = document;
  try {
    y.cookie = "cookietest=1; SameSite=Strict;";
    var u = y.cookie.indexOf("cookietest=") !== -1;
    return y.cookie = "cookietest=1; SameSite=Strict; expires=Thu, 01-Jan-1970 00:00:01 GMT", u
  } catch {
    return !1
  }
}

function JT() {
  var y = atob;
  return {
    abpIndo: ["#Iklan-Melayang", "#Kolom-Iklan-728", "#SidebarIklan-wrapper", '[title="ALIENBOLA" i]', y("I0JveC1CYW5uZXItYWRz")],
    abpvn: [".quangcao", "#mobileCatfish", y("LmNsb3NlLWFkcw=="), '[id^="bn_bottom_fixed_"]', "#pmadv"],
    adBlockFinland: [".mainostila", y("LnNwb25zb3JpdA=="), ".ylamainos", y("YVtocmVmKj0iL2NsaWNrdGhyZ2guYXNwPyJd"), y("YVtocmVmXj0iaHR0cHM6Ly9hcHAucmVhZHBlYWsuY29tL2FkcyJd")],
    adBlockPersian: ["#navbar_notice_50", ".kadr", 'TABLE[width="140px"]', "#divAgahi", y("YVtocmVmXj0iaHR0cDovL2cxLnYuZndtcm0ubmV0L2FkLyJd")],
    adBlockWarningRemoval: ["#adblock-honeypot", ".adblocker-root", ".wp_adblock_detect", y("LmhlYWRlci1ibG9ja2VkLWFk"), y("I2FkX2Jsb2NrZXI=")],
    adGuardAnnoyances: [".hs-sosyal", "#cookieconsentdiv", 'div[class^="app_gdpr"]', ".as-oil", '[data-cypress="soft-push-notification-modal"]'],
    adGuardBase: [".BetterJsPopOverlay", y("I2FkXzMwMFgyNTA="), y("I2Jhbm5lcmZsb2F0MjI="), y("I2NhbXBhaWduLWJhbm5lcg=="), y("I0FkLUNvbnRlbnQ=")],
    adGuardChinese: [y("LlppX2FkX2FfSA=="), y("YVtocmVmKj0iLmh0aGJldDM0LmNvbSJd"), "#widget-quan", y("YVtocmVmKj0iLzg0OTkyMDIwLnh5eiJd"), y("YVtocmVmKj0iLjE5NTZobC5jb20vIl0=")],
    adGuardFrench: ["#pavePub", y("LmFkLWRlc2t0b3AtcmVjdGFuZ2xl"), ".mobile_adhesion", ".widgetadv", y("LmFkc19iYW4=")],
    adGuardGerman: ['aside[data-portal-id="leaderboard"]'],
    adGuardJapanese: ["#kauli_yad_1", y("YVtocmVmXj0iaHR0cDovL2FkMi50cmFmZmljZ2F0ZS5uZXQvIl0="), y("Ll9wb3BJbl9pbmZpbml0ZV9hZA=="), y("LmFkZ29vZ2xl"), y("Ll9faXNib29zdFJldHVybkFk")],
    adGuardMobile: [y("YW1wLWF1dG8tYWRz"), y("LmFtcF9hZA=="), 'amp-embed[type="24smi"]', "#mgid_iframe1", y("I2FkX2ludmlld19hcmVh")],
    adGuardRussian: [y("YVtocmVmXj0iaHR0cHM6Ly9hZC5sZXRtZWFkcy5jb20vIl0="), y("LnJlY2xhbWE="), 'div[id^="smi2adblock"]', y("ZGl2W2lkXj0iQWRGb3hfYmFubmVyXyJd"), "#psyduckpockeball"],
    adGuardSocial: [y("YVtocmVmXj0iLy93d3cuc3R1bWJsZXVwb24uY29tL3N1Ym1pdD91cmw9Il0="), y("YVtocmVmXj0iLy90ZWxlZ3JhbS5tZS9zaGFyZS91cmw/Il0="), ".etsy-tweet", "#inlineShare", ".popup-social"],
    adGuardSpanishPortuguese: ["#barraPublicidade", "#Publicidade", "#publiEspecial", "#queTooltip", ".cnt-publi"],
    adGuardTrackingProtection: ["#qoo-counter", y("YVtocmVmXj0iaHR0cDovL2NsaWNrLmhvdGxvZy5ydS8iXQ=="), y("YVtocmVmXj0iaHR0cDovL2hpdGNvdW50ZXIucnUvdG9wL3N0YXQucGhwIl0="), y("YVtocmVmXj0iaHR0cDovL3RvcC5tYWlsLnJ1L2p1bXAiXQ=="), "#top100counter"],
    adGuardTurkish: ["#backkapat", y("I3Jla2xhbWk="), y("YVtocmVmXj0iaHR0cDovL2Fkc2Vydi5vbnRlay5jb20udHIvIl0="), y("YVtocmVmXj0iaHR0cDovL2l6bGVuemkuY29tL2NhbXBhaWduLyJd"), y("YVtocmVmXj0iaHR0cDovL3d3dy5pbnN0YWxsYWRzLm5ldC8iXQ==")],
    bulgarian: [y("dGQjZnJlZW5ldF90YWJsZV9hZHM="), "#ea_intext_div", ".lapni-pop-over", "#xenium_hot_offers"],
    easyList: [".yb-floorad", y("LndpZGdldF9wb19hZHNfd2lkZ2V0"), y("LnRyYWZmaWNqdW5reS1hZA=="), ".textad_headline", y("LnNwb25zb3JlZC10ZXh0LWxpbmtz")],
    easyListChina: [y("LmFwcGd1aWRlLXdyYXBbb25jbGljayo9ImJjZWJvcy5jb20iXQ=="), y("LmZyb250cGFnZUFkdk0="), "#taotaole", "#aafoot.top_box", ".cfa_popup"],
    easyListCookie: [".ezmob-footer", ".cc-CookieWarning", "[data-cookie-number]", y("LmF3LWNvb2tpZS1iYW5uZXI="), ".sygnal24-gdpr-modal-wrap"],
    easyListCzechSlovak: ["#onlajny-stickers", y("I3Jla2xhbW5pLWJveA=="), y("LnJla2xhbWEtbWVnYWJvYXJk"), ".sklik", y("W2lkXj0ic2tsaWtSZWtsYW1hIl0=")],
    easyListDutch: [y("I2FkdmVydGVudGll"), y("I3ZpcEFkbWFya3RCYW5uZXJCbG9jaw=="), ".adstekst", y("YVtocmVmXj0iaHR0cHM6Ly94bHR1YmUubmwvY2xpY2svIl0="), "#semilo-lrectangle"],
    easyListGermany: ["#SSpotIMPopSlider", y("LnNwb25zb3JsaW5rZ3J1ZW4="), y("I3dlcmJ1bmdza3k="), y("I3Jla2xhbWUtcmVjaHRzLW1pdHRl"), y("YVtocmVmXj0iaHR0cHM6Ly9iZDc0Mi5jb20vIl0=")],
    easyListItaly: [y("LmJveF9hZHZfYW5udW5jaQ=="), ".sb-box-pubbliredazionale", y("YVtocmVmXj0iaHR0cDovL2FmZmlsaWF6aW9uaWFkcy5zbmFpLml0LyJd"), y("YVtocmVmXj0iaHR0cHM6Ly9hZHNlcnZlci5odG1sLml0LyJd"), y("YVtocmVmXj0iaHR0cHM6Ly9hZmZpbGlhemlvbmlhZHMuc25haS5pdC8iXQ==")],
    easyListLithuania: [y("LnJla2xhbW9zX3RhcnBhcw=="), y("LnJla2xhbW9zX251b3JvZG9z"), y("aW1nW2FsdD0iUmVrbGFtaW5pcyBza3lkZWxpcyJd"), y("aW1nW2FsdD0iRGVkaWt1b3RpLmx0IHNlcnZlcmlhaSJd"), y("aW1nW2FsdD0iSG9zdGluZ2FzIFNlcnZlcmlhaS5sdCJd")],
    estonian: [y("QVtocmVmKj0iaHR0cDovL3BheTRyZXN1bHRzMjQuZXUiXQ==")],
    fanboyAnnoyances: ["#ac-lre-player", ".navigate-to-top", "#subscribe_popup", ".newsletter_holder", "#back-top"],
    fanboyAntiFacebook: [".util-bar-module-firefly-visible"],
    fanboyEnhancedTrackers: [".open.pushModal", "#issuem-leaky-paywall-articles-zero-remaining-nag", "#sovrn_container", 'div[class$="-hide"][zoompage-fontsize][style="display: block;"]', ".BlockNag__Card"],
    fanboySocial: ["#FollowUs", "#meteored_share", "#social_follow", ".article-sharer", ".community__social-desc"],
    frellwitSwedish: [y("YVtocmVmKj0iY2FzaW5vcHJvLnNlIl1bdGFyZ2V0PSJfYmxhbmsiXQ=="), y("YVtocmVmKj0iZG9rdG9yLXNlLm9uZWxpbmsubWUiXQ=="), "article.category-samarbete", y("ZGl2LmhvbGlkQWRz"), "ul.adsmodern"],
    greekAdBlock: [y("QVtocmVmKj0iYWRtYW4ub3RlbmV0LmdyL2NsaWNrPyJd"), y("QVtocmVmKj0iaHR0cDovL2F4aWFiYW5uZXJzLmV4b2R1cy5nci8iXQ=="), y("QVtocmVmKj0iaHR0cDovL2ludGVyYWN0aXZlLmZvcnRobmV0LmdyL2NsaWNrPyJd"), "DIV.agores300", "TABLE.advright"],
    hungarian: ["#cemp_doboz", ".optimonk-iframe-container", y("LmFkX19tYWlu"), y("W2NsYXNzKj0iR29vZ2xlQWRzIl0="), "#hirdetesek_box"],
    iDontCareAboutCookies: ['.alert-info[data-block-track*="CookieNotice"]', ".ModuleTemplateCookieIndicator", ".o--cookies--container", "#cookies-policy-sticky", "#stickyCookieBar"],
    icelandicAbp: [y("QVtocmVmXj0iL2ZyYW1ld29yay9yZXNvdXJjZXMvZm9ybXMvYWRzLmFzcHgiXQ==")],
    latvian: [y("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiAxMjBweDsgaGVpZ2h0OiA0MHB4OyBvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7Il0="), y("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiA4OHB4OyBoZWlnaHQ6IDMxcHg7IG92ZXJmbG93OiBoaWRkZW47IHBvc2l0aW9uOiByZWxhdGl2ZTsiXQ==")],
    listKr: [y("YVtocmVmKj0iLy9hZC5wbGFuYnBsdXMuY28ua3IvIl0="), y("I2xpdmVyZUFkV3JhcHBlcg=="), y("YVtocmVmKj0iLy9hZHYuaW1hZHJlcC5jby5rci8iXQ=="), y("aW5zLmZhc3R2aWV3LWFk"), ".revenue_unit_item.dable"],
    listeAr: [y("LmdlbWluaUxCMUFk"), ".right-and-left-sponsers", y("YVtocmVmKj0iLmFmbGFtLmluZm8iXQ=="), y("YVtocmVmKj0iYm9vcmFxLm9yZyJd"), y("YVtocmVmKj0iZHViaXp6bGUuY29tL2FyLz91dG1fc291cmNlPSJd")],
    listeFr: [y("YVtocmVmXj0iaHR0cDovL3Byb21vLnZhZG9yLmNvbS8iXQ=="), y("I2FkY29udGFpbmVyX3JlY2hlcmNoZQ=="), y("YVtocmVmKj0id2Vib3JhbWEuZnIvZmNnaS1iaW4vIl0="), ".site-pub-interstitiel", 'div[id^="crt-"][data-criteo-id]'],
    officialPolish: ["#ceneo-placeholder-ceneo-12", y("W2hyZWZePSJodHRwczovL2FmZi5zZW5kaHViLnBsLyJd"), y("YVtocmVmXj0iaHR0cDovL2Fkdm1hbmFnZXIudGVjaGZ1bi5wbC9yZWRpcmVjdC8iXQ=="), y("YVtocmVmXj0iaHR0cDovL3d3dy50cml6ZXIucGwvP3V0bV9zb3VyY2UiXQ=="), y("ZGl2I3NrYXBpZWNfYWQ=")],
    ro: [y("YVtocmVmXj0iLy9hZmZ0cmsuYWx0ZXgucm8vQ291bnRlci9DbGljayJd"), y("YVtocmVmXj0iaHR0cHM6Ly9ibGFja2ZyaWRheXNhbGVzLnJvL3Ryay9zaG9wLyJd"), y("YVtocmVmXj0iaHR0cHM6Ly9ldmVudC4ycGVyZm9ybWFudC5jb20vZXZlbnRzL2NsaWNrIl0="), y("YVtocmVmXj0iaHR0cHM6Ly9sLnByb2ZpdHNoYXJlLnJvLyJd"), 'a[href^="/url/"]'],
    ruAd: [y("YVtocmVmKj0iLy9mZWJyYXJlLnJ1LyJd"), y("YVtocmVmKj0iLy91dGltZy5ydS8iXQ=="), y("YVtocmVmKj0iOi8vY2hpa2lkaWtpLnJ1Il0="), "#pgeldiz", ".yandex-rtb-block"],
    thaiAds: ["a[href*=macau-uta-popup]", y("I2Fkcy1nb29nbGUtbWlkZGxlX3JlY3RhbmdsZS1ncm91cA=="), y("LmFkczMwMHM="), ".bumq", ".img-kosana"],
    webAnnoyancesUltralist: ["#mod-social-share-2", "#social-tools", y("LmN0cGwtZnVsbGJhbm5lcg=="), ".zergnet-recommend", ".yt.btn-link.btn-md.btn"]
  }
}

function QT(y) {
  var u = y === void 0 ? {} : y,
    v = u.debug;
  return Ds(this, void 0, void 0, function() {
    var b, k, z, T, s, B;
    return Rs(this, function(W) {
      switch (W.label) {
        case 0:
          return eS() ? (b = JT(), k = Object.keys(b), z = (B = []).concat.apply(B, k.map(function(ee) {
            return b[ee]
          })), [4, tS(z)]) : [2, void 0];
        case 1:
          return T = W.sent(), v && rS(b, T), s = k.filter(function(ee) {
            var $ = b[ee],
              oe = En($.map(function(me) {
                return T[me]
              }));
            return oe > $.length * .6
          }), s.sort(), [2, s]
      }
    })
  })
}

function eS() {
  return ws() || sg()
}

function tS(y) {
  var u;
  return Ds(this, void 0, void 0, function() {
    var v, b, k, z, B, T, s, B;
    return Rs(this, function(W) {
      switch (W.label) {
        case 0:
          for (v = document, b = v.createElement("div"), k = new Array(y.length), z = {}, Ev(b), B = 0; B < y.length; ++B) T = dT(y[B]), T.tagName === "DIALOG" && T.show(), s = v.createElement("div"), Ev(s), s.appendChild(T), b.appendChild(s), k[B] = T;
          W.label = 1;
        case 1:
          return v.body ? [3, 3] : [4, xp(50)];
        case 2:
          return W.sent(), [3, 1];
        case 3:
          v.body.appendChild(b);
          try {
            for (B = 0; B < y.length; ++B) k[B].offsetParent || (z[y[B]] = !0)
          } finally {
            (u = b.parentNode) === null || u === void 0 || u.removeChild(b)
          }
          return [2, z]
      }
    })
  })
}

function Ev(y) {
  y.style.setProperty("visibility", "hidden", "important"), y.style.setProperty("display", "block", "important")
}

function rS(y, u) {
  for (var v = "DOM blockers debug:\n```", b = 0, k = Object.keys(y); b < k.length; b++) {
    var z = k[b];
    v += `
`.concat(z, ":");
    for (var T = 0, s = y[z]; T < s.length; T++) {
      var B = s[T];
      v += `
  `.concat(u[B] ? "" : "", " ").concat(B)
    }
  }
  console.log("".concat(v, "\n```"))
}

function iS() {
  for (var y = 0, u = ["rec2020", "p3", "srgb"]; y < u.length; y++) {
    var v = u[y];
    if (matchMedia("(color-gamut: ".concat(v, ")")).matches) return v
  }
}

function aS() {
  if (zv("inverted")) return !0;
  if (zv("none")) return !1
}

function zv(y) {
  return matchMedia("(inverted-colors: ".concat(y, ")")).matches
}

function nS() {
  if (Lv("active")) return !0;
  if (Lv("none")) return !1
}

function Lv(y) {
  return matchMedia("(forced-colors: ".concat(y, ")")).matches
}
var sS = 100;

function oS() {
  if (matchMedia("(min-monochrome: 0)").matches) {
    for (var y = 0; y <= sS; ++y)
      if (matchMedia("(max-monochrome: ".concat(y, ")")).matches) return y;
    throw new Error("Too high value")
  }
}

function lS() {
  if (yc("no-preference")) return 0;
  if (yc("high") || yc("more")) return 1;
  if (yc("low") || yc("less")) return -1;
  if (yc("forced")) return 10
}

function yc(y) {
  return matchMedia("(prefers-contrast: ".concat(y, ")")).matches
}

function cS() {
  if (Dv("reduce")) return !0;
  if (Dv("no-preference")) return !1
}

function Dv(y) {
  return matchMedia("(prefers-reduced-motion: ".concat(y, ")")).matches
}

function uS() {
  if (Rv("reduce")) return !0;
  if (Rv("no-preference")) return !1
}

function Rv(y) {
  return matchMedia("(prefers-reduced-transparency: ".concat(y, ")")).matches
}

function hS() {
  if (Fv("high")) return !0;
  if (Fv("standard")) return !1
}

function Fv(y) {
  return matchMedia("(dynamic-range: ".concat(y, ")")).matches
}
var ea = Math,
  In = function() {
    return 0
  };

function dS() {
  var y = ea.acos || In,
    u = ea.acosh || In,
    v = ea.asin || In,
    b = ea.asinh || In,
    k = ea.atanh || In,
    z = ea.atan || In,
    T = ea.sin || In,
    s = ea.sinh || In,
    B = ea.cos || In,
    W = ea.cosh || In,
    ee = ea.tan || In,
    $ = ea.tanh || In,
    oe = ea.exp || In,
    me = ea.expm1 || In,
    _e = ea.log1p || In,
    Z = function(De) {
      return ea.pow(ea.PI, De)
    },
    Ie = function(De) {
      return ea.log(De + ea.sqrt(De * De - 1))
    },
    we = function(De) {
      return ea.log(De + ea.sqrt(De * De + 1))
    },
    Fe = function(De) {
      return ea.log((1 + De) / (1 - De)) / 2
    },
    xe = function(De) {
      return ea.exp(De) - 1 / ea.exp(De) / 2
    },
    $e = function(De) {
      return (ea.exp(De) + 1 / ea.exp(De)) / 2
    },
    et = function(De) {
      return ea.exp(De) - 1
    },
    Xe = function(De) {
      return (ea.exp(2 * De) - 1) / (ea.exp(2 * De) + 1)
    },
    Ae = function(De) {
      return ea.log(1 + De)
    };
  return {
    acos: y(.12312423423423424),
    acosh: u(1e308),
    acoshPf: Ie(1e154),
    asin: v(.12312423423423424),
    asinh: b(1),
    asinhPf: we(1),
    atanh: k(.5),
    atanhPf: Fe(.5),
    atan: z(.5),
    sin: T(-1e300),
    sinh: s(1),
    sinhPf: xe(1),
    cos: B(10.000000000123),
    cosh: W(1),
    coshPf: $e(1),
    tan: ee(-1e300),
    tanh: $(1),
    tanhPf: Xe(1),
    exp: oe(1),
    expm1: me(1),
    expm1Pf: et(1),
    log1p: _e(10),
    log1pPf: Ae(10),
    powPI: Z(-100)
  }
}
var pS = "mmMwWLliI0fiflO&1",
  Hf = {
    default: [],
    apple: [{
      font: "-apple-system-body"
    }],
    serif: [{
      fontFamily: "serif"
    }],
    sans: [{
      fontFamily: "sans-serif"
    }],
    mono: [{
      fontFamily: "monospace"
    }],
    min: [{
      fontSize: "1px"
    }],
    system: [{
      fontFamily: "system-ui"
    }]
  };

function fS() {
  return mS(function(y, u) {
    for (var v = {}, b = {}, k = 0, z = Object.keys(Hf); k < z.length; k++) {
      var T = z[k],
        s = Hf[T],
        B = s[0],
        W = B === void 0 ? {} : B,
        ee = s[1],
        $ = ee === void 0 ? pS : ee,
        oe = y.createElement("span");
      oe.textContent = $, oe.style.whiteSpace = "nowrap";
      for (var me = 0, _e = Object.keys(W); me < _e.length; me++) {
        var Z = _e[me],
          Ie = W[Z];
        Ie !== void 0 && (oe.style[Z] = Ie)
      }
      v[T] = oe, u.append(y.createElement("br"), oe)
    }
    for (var we = 0, Fe = Object.keys(Hf); we < Fe.length; we++) {
      var T = Fe[we];
      b[T] = v[T].getBoundingClientRect().width
    }
    return b
  })
}

function mS(y, u) {
  return u === void 0 && (u = 4e3), j0(function(v, b) {
    var k = b.document,
      z = k.body,
      T = z.style;
    T.width = "".concat(u, "px"), T.webkitTextSizeAdjust = T.textSizeAdjust = "none", Ah() ? z.style.zoom = "".concat(1 / b.devicePixelRatio) : ws() && (z.style.zoom = "reset");
    var s = k.createElement("div");
    return s.textContent = L0([], Array(u / 20 << 0), !0).map(function() {
      return "word"
    }).join(" "), z.appendChild(s), y(k, z)
  }, '<!doctype html><html><head><meta name="viewport" content="width=device-width, initial-scale=1">')
}

function gS() {
  return navigator.pdfViewerEnabled
}

function _S() {
  var y = new Float32Array(1),
    u = new Uint8Array(y.buffer);
  return y[0] = 1 / 0, y[0] = y[0] - y[0], u[3]
}

function vS() {
  var y = window.ApplePaySession;
  if (typeof(y == null ? void 0 : y.canMakePayments) != "function") return -1;
  if (yS()) return -3;
  try {
    return y.canMakePayments() ? 1 : 0
  } catch (u) {
    return xS(u)
  }
}
var yS = fT;

function xS(y) {
  if (y instanceof Error && y.name === "InvalidAccessError" && /\bfrom\b.*\binsecure\b/i.test(y.message)) return -2;
  throw y
}

function bS() {
  var y, u = document.createElement("a"),
    v = (y = u.attributionSourceId) !== null && y !== void 0 ? y : u.attributionsourceid;
  return v === void 0 ? void 0 : String(v)
}
var q0 = -1,
  V0 = -2,
  wS = new Set([10752, 2849, 2884, 2885, 2886, 2928, 2929, 2930, 2931, 2932, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2978, 3024, 3042, 3088, 3089, 3106, 3107, 32773, 32777, 32777, 32823, 32824, 32936, 32937, 32938, 32939, 32968, 32969, 32970, 32971, 3317, 33170, 3333, 3379, 3386, 33901, 33902, 34016, 34024, 34076, 3408, 3410, 3411, 3412, 3413, 3414, 3415, 34467, 34816, 34817, 34818, 34819, 34877, 34921, 34930, 35660, 35661, 35724, 35738, 35739, 36003, 36004, 36005, 36347, 36348, 36349, 37440, 37441, 37443, 7936, 7937, 7938]),
  TS = new Set([34047, 35723, 36063, 34852, 34853, 34854, 34229, 36392, 36795, 38449]),
  SS = ["FRAGMENT_SHADER", "VERTEX_SHADER"],
  PS = ["LOW_FLOAT", "MEDIUM_FLOAT", "HIGH_FLOAT", "LOW_INT", "MEDIUM_INT", "HIGH_INT"],
  Z0 = "WEBGL_debug_renderer_info",
  MS = "WEBGL_polygon_mode";

function IS(y) {
  var u, v, b, k, z, T, s = y.cache,
    B = N0(s);
  if (!B) return q0;
  if (!G0(B)) return V0;
  var W = U0() ? null : B.getExtension(Z0);
  return {
    version: ((u = B.getParameter(B.VERSION)) === null || u === void 0 ? void 0 : u.toString()) || "",
    vendor: ((v = B.getParameter(B.VENDOR)) === null || v === void 0 ? void 0 : v.toString()) || "",
    vendorUnmasked: W ? (b = B.getParameter(W.UNMASKED_VENDOR_WEBGL)) === null || b === void 0 ? void 0 : b.toString() : "",
    renderer: ((k = B.getParameter(B.RENDERER)) === null || k === void 0 ? void 0 : k.toString()) || "",
    rendererUnmasked: W ? (z = B.getParameter(W.UNMASKED_RENDERER_WEBGL)) === null || z === void 0 ? void 0 : z.toString() : "",
    shadingLanguageVersion: ((T = B.getParameter(B.SHADING_LANGUAGE_VERSION)) === null || T === void 0 ? void 0 : T.toString()) || ""
  }
}

function CS(y) {
  var u = y.cache,
    v = N0(u);
  if (!v) return q0;
  if (!G0(v)) return V0;
  var b = v.getSupportedExtensions(),
    k = v.getContextAttributes(),
    z = [],
    T = [],
    s = [],
    B = [],
    W = [];
  if (k)
    for (var ee = 0, $ = Object.keys(k); ee < $.length; ee++) {
      var oe = $[ee];
      T.push("".concat(oe, "=").concat(k[oe]))
    }
  for (var me = Bv(v), _e = 0, Z = me; _e < Z.length; _e++) {
    var Ie = Z[_e],
      we = v[Ie];
    s.push("".concat(Ie, "=").concat(we).concat(wS.has(we) ? "=".concat(v.getParameter(we)) : ""))
  }
  if (b)
    for (var Fe = 0, xe = b; Fe < xe.length; Fe++) {
      var $e = xe[Fe];
      if (!($e === Z0 && U0() || $e === MS && ES())) {
        var et = v.getExtension($e);
        if (!et) {
          z.push($e);
          continue
        }
        for (var Xe = 0, Ae = Bv(et); Xe < Ae.length; Xe++) {
          var Ie = Ae[Xe],
            we = et[Ie];
          B.push("".concat(Ie, "=").concat(we).concat(TS.has(we) ? "=".concat(v.getParameter(we)) : ""))
        }
      }
    }
  for (var De = 0, Ye = SS; De < Ye.length; De++)
    for (var Le = Ye[De], qe = 0, _t = PS; qe < _t.length; qe++) {
      var Qe = _t[qe],
        Ge = AS(v, Le, Qe);
      W.push("".concat(Le, ".").concat(Qe, "=").concat(Ge.join(",")))
    }
  return B.sort(), s.sort(), {
    contextAttributes: T,
    parameters: s,
    shaderPrecisions: W,
    extensions: b,
    extensionParameters: B,
    unsupportedExtensions: z
  }
}

function N0(y) {
  if (y.webgl) return y.webgl.context;
  var u = document.createElement("canvas"),
    v;
  u.addEventListener("webglCreateContextError", function() {
    return v = void 0
  });
  for (var b = 0, k = ["webgl", "experimental-webgl"]; b < k.length; b++) {
    var z = k[b];
    try {
      v = u.getContext(z)
    } catch {}
    if (v) break
  }
  return y.webgl = {
    context: v
  }, v
}

function AS(y, u, v) {
  var b = y.getShaderPrecisionFormat(y[u], y[v]);
  return b ? [b.rangeMin, b.rangeMax, b.precision] : []
}

function Bv(y) {
  var u = Object.keys(y.__proto__);
  return u.filter(kS)
}

function kS(y) {
  return typeof y == "string" && !y.match(/[^A-Z0-9_x]/)
}

function U0() {
  return O0()
}

function ES() {
  return Ah() || ws()
}

function G0(y) {
  return typeof y.getParameter == "function"
}

function zS() {
  var y = sg() || ws();
  if (!y) return -2;
  if (!window.AudioContext) return -1;
  var u = new AudioContext().baseLatency;
  return u == null ? -1 : isFinite(u) ? u : -3
}

function LS() {
  if (!window.Intl) return -1;
  var y = window.Intl.DateTimeFormat;
  if (!y) return -2;
  var u = y().resolvedOptions().locale;
  return !u && u !== "" ? -3 : u
}
var DS = {
  fonts: _T,
  domBlockers: QT,
  fontPreferences: fS,
  audio: sT,
  screenFrame: jT,
  canvas: yT,
  osCpu: AT,
  languages: kT,
  colorDepth: ET,
  deviceMemory: zT,
  screenResolution: LT,
  hardwareConcurrency: qT,
  timezone: VT,
  sessionStorage: NT,
  localStorage: UT,
  indexedDB: GT,
  openDatabase: WT,
  cpuClass: HT,
  platform: $T,
  plugins: vT,
  touchSupport: CT,
  vendor: XT,
  vendorFlavors: YT,
  cookiesEnabled: KT,
  colorGamut: iS,
  invertedColors: aS,
  forcedColors: nS,
  monochrome: oS,
  contrast: lS,
  reducedMotion: cS,
  reducedTransparency: uS,
  hdr: hS,
  math: dS,
  pdfViewerEnabled: gS,
  architecture: _S,
  applePay: vS,
  privateClickMeasurement: bS,
  audioBaseLatency: zS,
  dateTimeLocale: LS,
  webGlBasics: IS,
  webGlExtensions: CS
};

function RS(y) {
  return K3(DS, y, [])
}
var FS = "$ if upgrade to Pro: https://fpjs.dev/pro";

function BS(y) {
  var u = OS(y),
    v = jS(u);
  return {
    score: u,
    comment: FS.replace(/\$/g, "".concat(v))
  }
}

function OS(y) {
  if (sg()) return .4;
  if (ws()) return ng() && !(Eh() && kh()) ? .5 : .3;
  var u = "value" in y.platform ? y.platform.value : "";
  return /^Win/.test(u) ? .6 : /^Mac/.test(u) ? .5 : .7
}

function jS(y) {
  return F0(.99 + .01 * y, 1e-4)
}

function qS(y) {
  for (var u = "", v = 0, b = Object.keys(y).sort(); v < b.length; v++) {
    var k = b[v],
      z = y[k],
      T = "error" in z ? "error" : JSON.stringify(z.value);
    u += "".concat(u ? "|" : "").concat(k.replace(/([:|\\])/g, "\\$1"), ":").concat(T)
  }
  return u
}

function W0(y) {
  return JSON.stringify(y, function(u, v) {
    return v instanceof Error ? H3(v) : v
  }, 2)
}

function H0(y) {
  return W3(qS(y))
}

function VS(y) {
  var u, v = BS(y);
  return {
    get visitorId() {
      return u === void 0 && (u = H0(this.components)), u
    },
    set visitorId(b) {
      u = b
    },
    confidence: v,
    components: y,
    version: D0
  }
}

function ZS(y) {
  return y === void 0 && (y = 50), B3(y, y * 2)
}

function NS(y, u) {
  var v = Date.now();
  return {
    get: function(b) {
      return Ds(this, void 0, void 0, function() {
        var k, z, T;
        return Rs(this, function(s) {
          switch (s.label) {
            case 0:
              return k = Date.now(), [4, y()];
            case 1:
              return z = s.sent(), T = VS(z), (u || b != null && b.debug) && console.log("Copy the text below to get the debug data:\n\n```\nversion: ".concat(T.version, `
userAgent: `).concat(navigator.userAgent, `
timeBetweenLoadAndGet: `).concat(k - v, `
visitorId: `).concat(T.visitorId, `
components: `).concat(W0(z), "\n```")), [2, T]
          }
        })
      })
    }
  }
}

function US() {
  if (!(window.__fpjs_d_m || Math.random() >= .001)) try {
    var y = new XMLHttpRequest;
    y.open("get", "https://m1.openfpcdn.io/fingerprintjs/v".concat(D0, "/npm-monitoring"), !0), y.send()
  } catch (u) {
    console.error(u)
  }
}

function GS(y) {
  var u;
  return y === void 0 && (y = {}), Ds(this, void 0, void 0, function() {
    var v, b, k;
    return Rs(this, function(z) {
      switch (z.label) {
        case 0:
          return (!((u = y.monitoring) !== null && u !== void 0) || u) && US(), v = y.delayFallback, b = y.debug, [4, ZS(v)];
        case 1:
          return z.sent(), k = RS({
            cache: {},
            debug: b
          }), [2, NS(k, b)]
      }
    })
  })
}
var $0 = {
  load: GS,
  hashComponents: H0,
  componentsToDebugString: W0
};
let $f = null,
  bp;
async function WS() {
  return $f || ($f = $0.load()), $f
}
async function og() {
  return bp || HS().then(y => y.visitorId)
}
async function HS() {
  const u = await (await WS()).get(),
    {
      languages: v,
      dateTimeLocale: b,
      ...k
    } = u.components;
  return bp = $0.hashComponents(k), {
    visitorId: bp,
    components: k
  }
}
var $S = Xr('<svg><path d="M240-120q-45 0-89-22t-71-58q26 0 53-20.5t27-59.5q0-50 35-85t85-35q50 0 85 35t35 85q0 66-47 113t-113 47Zm230-240L360-470l358-358q11-11 27.5-11.5T774-828l54 54q12 12 12 28t-12 28L470-360Z"></path></svg>');

function yl(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = $S();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}

function lp(y) {
  const u = document.createElement("img");
  return u.src = y, new Promise((v, b) => {
    u.addEventListener("load", () => {
      v(u)
    }), u.addEventListener("error", k => {
      b(k)
    })
  })
}

function X0(y) {
  const u = document.createElement("canvas");
  u.width = y.naturalWidth, u.height = y.naturalHeight;
  const v = u.getContext("2d");
  return v == null || v.drawImage(y, 0, 0), u
}
var XS = he('<button type="button"></button>'),
  YS = he('<div class="overlay pointer-events-auto svelte-rxq6cp"><canvas></canvas> <div class="overlay-border svelte-rxq6cp"></div> <!></div>'),
  KS = he('<div><!> <p class="text-base font-medium">Drop an image or click the button below to select a file</p> <input type="file" accept="image/*" class="hidden" id="auto-paint-file"/> <label for="auto-paint-file" class="btn btn-primary btn-sm">Upload image</label></div>'),
  JS = he("<option> </option>"),
  QS = he('<span class="loading loading-spinner loading-sm"></span> Processing', 1),
  eP = he('<button class="btn btn-primary"><!></button>'),
  tP = he('<span class="loading loading-spinner loading-sm"></span> Sending', 1),
  rP = he('<button class="btn btn-primary"><!></button>'),
  iP = he('<div class="rounded-box bg-success/10 text-success px-3 py-2 text-sm"> </div>'),
  aP = he('<div class="mt-4 grid gap-4 md:grid-cols-2"><div class="space-y-2"><div class="rounded-box bg-base-200/60 p-3 text-sm"><p class="font-semibold"> </p> <p class="text-base-content/70"> </p></div> <div class="flex items-center gap-2"><label class="text-base-content/70 text-sm">Opacity</label> <input type="range" min="20" max="100"/></div> <div class="space-y-1"><label class="flex items-center gap-2 text-sm font-medium"><input type="checkbox" class="checkbox checkbox-primary checkbox-sm"/> <span>Dithering (Floyd-Steinberg)</span></label> <p class="text-base-content/70 text-xs">Makes color transitions smoother.</p></div> <div class="space-y-1"><label class="flex items-center gap-2 text-sm font-medium"><input type="checkbox" class="checkbox checkbox-primary checkbox-sm"/> <span>Paint transparent pixels</span></label> <p class="text-base-content/70 text-xs">Clears pixels using palette index 0.</p></div> <div class="space-y-1"><label class="flex flex-col gap-1 text-sm font-medium">Color metric <select class="select select-bordered select-sm w-full max-w-xs"></select></label></div></div> <div class="space-y-2 text-sm"><p class="text-base-content/70">1. Set image position by draging it.<br/> 2. Click on <strong>Generate Preview</strong> to convert the colors.<br/> 3. Confirm to paint the canvas.</p> <button class="btn btn-sm btn-outline">Change image</button> <div class="flex flex-wrap gap-2"><button class="btn btn-sm btn-outline">Flip horizontal</button> <button class="btn btn-sm btn-outline">Flip vertical</button></div> <label class="flex items-center gap-2 text-sm font-medium"><span class="whitespace-nowrap">Paint as user ID:</span> <input class="input input-bordered input-xs min-w-0 flex-1" type="number" placeholder="User ID"/></label></div></div> <div class="mt-4 flex flex-wrap items-center gap-3"><!> <button class="btn btn-ghost">Cancelar</button> <!></div>', 1),
  nP = he(`<div class="pointer-events-none absolute inset-0 z-40 select-none"><!></div> <div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-2xl sm:-translate-x-1/2"><div class="rounded-t-box bg-base-100 border-base-300 border-t p-4 shadow-xl"><div class="flex items-center justify-between gap-2"><div><h2 class="flex items-center gap-2 text-lg font-semibold"><!> Auto Painter</h2> <p class="text-base-content/70 text-sm">Drag the image to the desired position. Use the anchors to change it's size.</p></div> <button class="btn btn-circle btn-sm" title="Fechar"><!></button></div> <!></div></div>`, 1);

function sP(y, u) {
  var Ze;
  ri(u, !1);
  const v = 2e3,
    b = 256,
    k = "admin-auto-painter-opacity",
    z = "admin-auto-painter-dithering",
    T = "admin-auto-painter-transparent";
  let s = rr(u, "map", 8),
    B = rr(u, "tileSize", 8),
    W = rr(u, "tileZoom", 8),
    ee = rr(u, "season", 8),
    $ = rr(u, "refreshPixelArt", 8),
    oe = rr(u, "onclose", 8),
    me = en(new kn(B())),
    _e = en(((Ze = Lt.data) == null ? void 0 : Ze.id) ?? 0),
    Z = en("upload"),
    Ie = en(!1),
    we = en(!1),
    Fe = en(!1),
    xe = en(null),
    $e = en(""),
    et = en(null),
    Xe = en(null),
    Ae = en(null),
    De = en({
      pixels: 0,
      width: 0,
      height: 0,
      tiles: 0
    }),
    Ye = [],
    Le = en(null),
    qe = en(null),
    _t = en(1),
    Qe = en(!1),
    Ge = en(!1),
    ft = en("lab");
  const Vt = [{
    value: "lab",
    label: "Perceptual (CIELAB E94)"
  }, {
    value: "compuphase",
    label: "Weighted RGB (CompuPhase)"
  }];
  let Et = en(!1),
    Pt = null;
  const ot = ["nw", "n", "ne", "e", "se", "s", "sw", "w"],
    Ht = new Set(["nw", "ne", "se", "sw"]);

  function vt(ne) {
    return Ht.has(ne)
  }

  function Dt(ne, Ce, He) {
    return Math.min(Math.max(ne, Ce), He)
  }

  function Rt(ne) {
    const Ce = Math.max(ne.north, ne.south),
      He = Math.min(ne.north, ne.south),
      ht = Math.min(ne.west, ne.east),
      Tt = Math.max(ne.west, ne.east);
    return {
      north: Dt(Ce, -85, 85),
      south: Dt(He, -85, 85),
      west: Dt(ht, -180, 180),
      east: Dt(Tt, -180, 180)
    }
  }

  function $t(ne) {
    H(et, Rt(ne)), H(Ie, !1), H(Le, null), Ye = [], H(De, {
      pixels: 0,
      width: 0,
      height: 0,
      tiles: 0
    }), pr(), Xt(), cr()
  }

  function pr() {
    if (!m(et)) {
      H(Ae, null);
      return
    }
    const [ne, Ce] = m(me).latLonToPixels(m(et).north, m(et).west, W()), [He, ht] = m(me).latLonToPixels(m(et).south, m(et).east, W()), Tt = Math.min(ne, He), dt = Math.max(ne, He), St = Math.min(Ce, ht), jt = Math.max(Ce, ht), je = Math.max(1, Math.ceil(dt - Tt)), yt = Math.max(1, Math.ceil(jt - St));
    H(Ae, {
      px0: Tt,
      py0: St,
      width: je,
      height: yt
    })
  }

  function Xt() {
    if (!m(et)) {
      H(Xe, null);
      return
    }
    const ne = s().project({
        lat: m(et).north,
        lng: m(et).west
      }),
      Ce = s().project({
        lat: m(et).south,
        lng: m(et).east
      }),
      He = Math.min(ne.x, Ce.x),
      ht = Math.min(ne.y, Ce.y),
      Tt = Math.abs(Ce.x - ne.x),
      dt = Math.abs(Ce.y - ne.y);
    H(Xe, {
      left: He,
      top: ht,
      width: Tt,
      height: dt
    })
  }

  function or() {
    H(Z, "upload"), H(xe, null), H($e, ""), H(et, null), H(Ae, null), H(Xe, null), H(Ie, !1), Ye = [], H(Le, null), H(De, {
      pixels: 0,
      width: 0,
      height: 0,
      tiles: 0
    })
  }

  function nt() {
    if (!m(xe)) return;
    const ne = s().getCenter(),
      [Ce, He] = m(me).latLonToPixels(ne.lat, ne.lng, W()),
      ht = Math.min(1, b / m(xe).width),
      Tt = Math.max(8, Math.round(m(xe).width * ht)),
      dt = Math.max(8, Math.round(m(xe).height * ht)),
      St = Ce - Tt / 2,
      jt = Ce + Tt / 2,
      je = He - dt / 2,
      yt = He + dt / 2,
      [Kt, Cr] = m(me).pixelsToLatLon(St, je, W()),
      [fr, Je] = m(me).pixelsToLatLon(jt, yt, W());
    $t({
      north: Kt,
      south: fr,
      west: Cr,
      east: Je
    }), cr()
  }
  async function rt(ne) {
    try {
      or();
      const Ce = URL.createObjectURL(ne),
        He = await lp(Ce);
      URL.revokeObjectURL(Ce), H(xe, X0(He)), H($e, ne.name), H(Z, "place"), nt()
    } catch (Ce) {
      console.error(Ce), Nt.error("Failed to load image. Try again.")
    }
  }

  function Zt(ne) {
    var ht;
    const Ce = ne.target,
      He = (ht = Ce.files) == null ? void 0 : ht[0];
    He && rt(He), Ce.value = ""
  }

  function Jt(ne) {
    ne.preventDefault(), H(Et, !0)
  }

  function Ot(ne) {
    ne.preventDefault(), H(Et, !1)
  }

  function mr(ne) {
    var He, ht;
    ne.preventDefault(), H(Et, !1);
    const Ce = (ht = (He = ne.dataTransfer) == null ? void 0 : He.files) == null ? void 0 : ht[0];
    Ce && rt(Ce)
  }

  function At(ne) {
    const Ce = s().getCanvas().getBoundingClientRect(),
      He = [ne.clientX - Ce.left, ne.clientY - Ce.top],
      ht = s().unproject(He);
    return {
      lat: ht.lat,
      lon: ht.lng
    }
  }

  function Mt(ne, Ce, He) {
    if (!m(xe)) return Ce;
    const ht = m(xe).width / Math.max(m(xe).height, 1);
    if (!isFinite(ht) || ht <= 0) return Ce;
    const Tt = ne.includes("n") ? He.south : He.north,
      dt = ne.includes("w") ? He.east : He.west,
      St = ne.includes("n") ? Ce.north : Ce.south,
      jt = ne.includes("w") ? Ce.west : Ce.east,
      [je, yt] = m(me).latLonToPixels(Tt, dt, W()),
      [Kt, Cr] = m(me).latLonToPixels(St, jt, W());
    let fr = Kt - je,
      Je = Cr - yt,
      tr = Math.sign(fr) || (ne.includes("w") ? -1 : 1),
      Yt = Math.sign(Je) || (ne.includes("n") ? -1 : 1),
      Tr = Math.abs(fr),
      Dr = Math.abs(Je);
    if (Tr === 0 && Dr === 0) return Ce;
    const Jr = Dr * ht,
      yr = Tr / ht;
    Jr > Tr ? Tr = Jr : Dr = yr;
    const qt = je + tr * Tr,
      bt = yt + Yt * Dr,
      [Ue, xt] = m(me).pixelsToLatLon(qt, bt, W());
    return ne.includes("n") ? Ce.north = Ue : Ce.south = Ue, ne.includes("w") ? Ce.west = xt : Ce.east = xt, Ce
  }

  function wt(ne) {
    if (!m(et)) return;
    ne.preventDefault();
    const {
      lat: Ce,
      lon: He
    } = At(ne);
    Pt = {
      type: "move",
      startLat: Ce,
      startLon: He,
      startBounds: {
        ...m(et)
      }
    }, ut()
  }

  function It(ne, Ce) {
    m(et) && (ne.preventDefault(), ne.stopPropagation(), Pt = {
      type: "resize",
      handle: Ce,
      startBounds: {
        ...m(et)
      }
    }, ut())
  }

  function Ut(ne) {
    s().scrollZoom.isEnabled() && (ne.preventDefault(), s().getCanvasContainer().dispatchEvent(new WheelEvent("wheel", {
      deltaX: ne.deltaX,
      deltaY: ne.deltaY,
      deltaZ: ne.deltaZ,
      deltaMode: ne.deltaMode,
      clientX: ne.clientX,
      clientY: ne.clientY,
      screenX: ne.screenX,
      screenY: ne.screenY,
      ctrlKey: ne.ctrlKey,
      shiftKey: ne.shiftKey,
      altKey: ne.altKey,
      metaKey: ne.metaKey,
      bubbles: !0,
      cancelable: !0
    })))
  }

  function ut() {
    s().dragPan.disable(), window.addEventListener("pointermove", br), window.addEventListener("pointerup", ur)
  }

  function ur() {
    window.removeEventListener("pointermove", br), window.removeEventListener("pointerup", ur), s().dragPan.enable(), Pt = null
  }

  function br(ne) {
    if (!Pt || !Pt.startBounds) return;
    const {
      startBounds: Ce
    } = Pt;
    if (Pt.type === "move") {
      const {
        lat: St,
        lon: jt
      } = At(ne), je = St - Pt.startLat, yt = jt - Pt.startLon;
      $t({
        north: Ce.north + je,
        south: Ce.south + je,
        west: Ce.west + yt,
        east: Ce.east + yt
      });
      return
    }
    const {
      handle: He
    } = Pt, {
      lat: ht,
      lon: Tt
    } = At(ne);
    let dt = {
      ...Ce
    };
    He.includes("n") && (dt.north = ht), He.includes("s") && (dt.south = ht), He.includes("w") && (dt.west = Tt), He.includes("e") && (dt.east = Tt), vt(He) && (dt = Mt(He, dt, Ce)), $t(dt)
  }

  function cr() {
    if (!m(qe) || !m(Ae) || !m(xe) || m(Ie)) return;
    wr().drawImage(m(xe), 0, 0, m(Ae).width, m(Ae).height)
  }

  function jr(ne, Ce) {
    if (!m(xe)) return;
    const He = document.createElement("canvas");
    He.width = m(xe).width, He.height = m(xe).height;
    const ht = He.getContext("2d");
    if (!ht) throw new Error("Canvas context not available");
    ht.imageSmoothingEnabled = !1;
    const Tt = ne ? -1 : 1,
      dt = Ce ? -1 : 1,
      St = ne ? m(xe).width : 0,
      jt = Ce ? m(xe).height : 0;
    if (ht.setTransform(Tt, 0, 0, dt, St, jt), ht.drawImage(m(xe), 0, 0), H(xe, He), m(Ie)) {
      de();
      return
    }
    cr()
  }

  function wr() {
    if (!m(qe) || !m(Ae)) throw new Error("Canvas not ready");
    sv(qe, m(qe).width = m(Ae).width), sv(qe, m(qe).height = m(Ae).height);
    const ne = m(qe).getContext("2d", {
      willReadFrequently: !0
    });
    if (!ne) throw new Error("Canvas context not available");
    return ne.imageSmoothingEnabled = !1, ne.clearRect(0, 0, m(qe).width, m(qe).height), ne
  }

  function Nr() {
    if (!m(qe) || !m(Ae) || !m(Le) || !m(Ie)) return;
    wr().putImageData(m(Le), 0, 0)
  }
  async function Gr() {
    if (!(!m(Ae) || !m(xe))) {
      if (m(Ae).width > v || m(Ae).height > v) {
        Nt.error(`The selected area is too big (${m(Ae).width}${m(Ae).height}).`);
        return
      }
      H(we, !0);
      try {
        const ne = er();
        if (!ne || ne.pixels.length === 0) {
          Nt.error("Faile to convert into valid game_pixels");
          return
        }
        H(Le, ne.imageData), Ye = ne.pixels, H(De, ne.stats), H(Ie, !0), Nr()
      } catch (ne) {
        console.error(ne), Nt.error("Failed to generate preview.")
      } finally {
        H(we, !1)
      }
    }
  }

  function er() {
    if (!m(Ae) || !m(xe)) return;
    const ne = document.createElement("canvas");
    ne.width = m(Ae).width, ne.height = m(Ae).height;
    const Ce = ne.getContext("2d", {
      willReadFrequently: !0
    });
    if (!Ce) throw new Error("Context is null.");
    Ce.imageSmoothingEnabled = !1, Ce.drawImage(m(xe), 0, 0, m(Ae).width, m(Ae).height);
    const He = m(Ae).width,
      ht = m(Ae).height,
      Tt = Ce.getImageData(0, 0, He, ht),
      dt = Tt.data,
      St = [],
      jt = new Set,
      je = m(Qe);
    let yt = null,
      Kt = null;
    if (je) {
      const Cr = He * 3;
      yt = new Float32Array(Cr), Kt = new Float32Array(Cr)
    }
    for (let Cr = 0; Cr < ht; Cr++) {
      if (je && yt && Kt) {
        const fr = yt;
        yt = Kt, Kt = fr, Kt.fill(0)
      }
      for (let fr = 0; fr < He; fr++) {
        const Je = (Cr * He + fr) * 4;
        if (dt[Je + 3] < 16) {
          if (dt[Je + 3] = 0, !m(Ge)) continue;
          const dr = 0,
            ar = _p(dr);
          dt[Je] = ar.r, dt[Je + 1] = ar.g, dt[Je + 2] = ar.b;
          const Ar = m(Ae).px0 + fr + .5,
            Kr = m(Ae).py0 + Cr + .5,
            {
              tile: Rr,
              pixel: Or
            } = m(me).pixelsToTileLocal(Ar, Kr),
            Fr = {
              tile: [Rr[0], Rr[1]],
              pixel: [Or[0], Or[1]],
              season: ee(),
              colorIdx: dr,
              color: ar
            },
            ti = `${Rr[0]}:${Rr[1]}`;
          jt.add(ti), St.push(Fr);
          continue
        }
        let Yt = dt[Je],
          Tr = dt[Je + 1],
          Dr = dt[Je + 2];
        if (je && yt) {
          const dr = fr * 3;
          Yt = Dt(Math.round(Yt + yt[dr]), 0, 255), Tr = Dt(Math.round(Tr + yt[dr + 1]), 0, 255), Dr = Dt(Math.round(Dr + yt[dr + 2]), 0, 255)
        }
        const Jr = o0({
            r: Yt,
            g: Tr,
            b: Dr
          }, m(ft)),
          yr = _p(Jr);
        if (dt[Je] = yr.r, dt[Je + 1] = yr.g, dt[Je + 2] = yr.b, dt[Je + 3] = yr.a, je && yt && Kt) {
          const dr = Yt - yr.r,
            ar = Tr - yr.g,
            Ar = Dr - yr.b,
            Kr = (Rr, Or, Fr) => {
              Rr[Or] += dr * Fr, Rr[Or + 1] += ar * Fr, Rr[Or + 2] += Ar * Fr
            };
          if (fr + 1 < He) {
            const Rr = (fr + 1) * 3;
            Kr(yt, Rr, 7 / 16)
          }
          if (Cr + 1 < ht) {
            if (fr > 0) {
              const Or = (fr - 1) * 3;
              Kr(Kt, Or, 3 / 16)
            }
            const Rr = fr * 3;
            if (Kr(Kt, Rr, 5 / 16), fr + 1 < He) {
              const Or = (fr + 1) * 3;
              Kr(Kt, Or, 1 / 16)
            }
          }
        }
        const qt = m(Ae).px0 + fr + .5,
          bt = m(Ae).py0 + Cr + .5,
          {
            tile: Ue,
            pixel: xt
          } = m(me).pixelsToTileLocal(qt, bt),
          Gt = {
            tile: [Ue[0], Ue[1]],
            pixel: [xt[0], xt[1]],
            season: ee(),
            colorIdx: Jr,
            color: yr
          },
          kt = `${Ue[0]}:${Ue[1]}`;
        jt.add(kt), St.push(Gt)
      }
    }
    return {
      pixels: St,
      imageData: Tt,
      stats: {
        pixels: St.length,
        width: He,
        height: ht,
        tiles: jt.size
      }
    }
  }
  async function Wr() {
    if (!(!m(Ie) || Ye.length === 0)) {
      H(Fe, !0);
      try {
        ya.droppletAndPlop.play();
        const ne = await og(),
          Ce = Ye.map(({
            color: He,
            ...ht
          }) => ht);
        await ui.adminAutoPainterPaint(Ce, ne, m(_e)), await Zm(Ye), $()(), Lt.refresh(), Nt.success("Art painted successfully."), sr()
      } catch (ne) {
        console.error(ne), Nt.error(ne.message ?? "Failed to paint art.")
      } finally {
        H(Fe, !1)
      }
    }
  }

  function sr() {
    or(), oe()()
  }

  function de() {
    H(Ie, !1), H(Le, null), Ye = [], H(De, {
      pixels: 0,
      width: 0,
      height: 0,
      tiles: 0
    }), cr()
  }
  $a(() => {
    const ne = () => Xt();
    return s().on("move", ne), s().on("zoom", ne), s().on("resize", ne), () => {
      s().off("move", ne), s().off("zoom", ne), s().off("resize", ne)
    }
  }), w1(() => {
    or()
  }), Nf(() => z1(B()), () => {
    H(me, new kn(B()))
  }), Nf(() => (m(qe), m(Ae), m(xe), m(Ie), m(Z)), () => {
    m(qe) && m(Ae) && m(xe) && !m(Ie) && m(Z) === "place" && cr()
  }), Nf(() => (m(qe), m(Ae), m(Le), m(Ie)), () => {
    m(qe) && m(Ae) && m(Le) && m(Ie) && Nr()
  }), E1(), Um();
  var j = nP();
  Mi("keydown", Oo, ne => {
    ne.key === "Escape" && sr()
  }), Mi("dragover", Oo, v3(Jt)), Mi("drop", Oo, mr), Mi("dragleave", Oo, Ot);
  var V = Ct(j),
    X = I(V);
  {
    var re = ne => {
      var Ce = YS(),
        He = I(Ce);
      let ht;
      Rn(He, St => H(qe, St), () => m(qe));
      var Tt = D(He, 2),
        dt = D(Tt, 2);
      na(dt, 1, () => ot, St => St, (St, jt) => {
        var je = XS();
        Re(yt => {
          Vr(je, 1, `handle handle-${m(jt)}`, "svelte-rxq6cp"), Qt(je, "aria-label", yt)
        }, [() => (m(jt), Cn(() => `Redimensionar (${m(jt).toUpperCase()})`))]), Mi("pointerdown", je, yt => It(yt, m(jt))), q(St, je)
      }), P(Ce), Re(() => {
        uo(Ce, (m(Xe), m(_t), Cn(() => `left:${m(Xe).left}px;top:${m(Xe).top}px;width:${m(Xe).width}px;height:${m(Xe).height}px;opacity:${m(_t)};`))), ht = Vr(He, 1, "h-full w-full svelte-rxq6cp", null, ht, {
          pixelated: m(Ie)
        })
      }), Mi("pointerdown", He, wt), Mi("pointerdown", Tt, wt), Mi("wheel", Ce, Ut), q(ne, Ce)
    };
    Se(X, ne => {
      m(et) && m(Xe) && ne(re)
    })
  }
  P(V);
  var Q = D(V, 2),
    ue = I(Q),
    Te = I(ue),
    be = I(Te),
    ze = I(be),
    We = I(ze);
  yl(We, {
    class: "size-5"
  }), vi(), P(ze), vi(2), P(be);
  var Be = D(be, 2),
    ae = I(Be);
  Ls(ae, {
    class: "size-4"
  }), P(Be), P(Te);
  var J = D(Te, 2);
  {
    var Ve = ne => {
        var Ce = KS(),
          He = I(Ce);
        tb(He, {
          class: "text-base-content/70 size-10"
        });
        var ht = D(He, 4);
        vi(2), P(Ce), Re(() => Vr(Ce, 1, `rounded-box mt-4 flex flex-col items-center justify-center gap-3 border border-dashed p-6 text-center transition ${m(Et)?"border-primary bg-primary/10":"border-base-300"}`, "svelte-rxq6cp")), Mi("change", ht, Zt), q(ne, Ce)
      },
      tt = ne => {
        var Ce = Sr(),
          He = Ct(Ce);
        {
          var ht = Tt => {
            var dt = aP(),
              St = Ct(dt),
              jt = I(St),
              je = I(jt),
              yt = I(je),
              Kt = I(yt, !0);
            P(yt);
            var Cr = D(yt, 2),
              fr = I(Cr);
            P(Cr), P(je);
            var Je = D(je, 2),
              tr = I(Je);
            Qt(tr, "for", k);
            var Yt = D(tr, 2);
            Xa(Yt), Qt(Yt, "id", k), P(Je);
            var Tr = D(Je, 2),
              Dr = I(Tr);
            Qt(Dr, "for", z);
            var Jr = I(Dr);
            Xa(Jr), Qt(Jr, "id", z), vi(2), P(Dr), vi(2), P(Tr);
            var yr = D(Tr, 2),
              qt = I(yr);
            Qt(qt, "for", T);
            var bt = I(qt);
            Xa(bt), Qt(bt, "id", T), vi(2), P(qt), vi(2), P(yr);
            var Ue = D(yr, 2),
              xt = I(Ue),
              Gt = D(I(xt));
            Re(() => {
              m(ft), L1(() => {
                m(Ie)
              })
            }), na(Gt, 5, () => Vt, Lc, (ki, wi) => {
              var Vi = JS(),
                Yi = I(Vi, !0);
              P(Vi);
              var pt = {};
              Re(() => {
                te(Yi, (m(wi), Cn(() => m(wi).label))), pt !== (pt = (m(wi), Cn(() => m(wi).value))) && (Vi.value = (Vi.__value = (m(wi), Cn(() => m(wi).value))) ?? "")
              }), q(ki, Vi)
            }), P(Gt), P(xt), P(Ue), P(jt);
            var kt = D(jt, 2),
              dr = D(I(kt), 2),
              ar = D(dr, 2),
              Ar = I(ar),
              Kr = D(Ar, 2);
            P(ar);
            var Rr = D(ar, 2),
              Or = D(I(Rr), 2);
            Xa(Or), P(Rr), P(kt), P(St);
            var Fr = D(St, 2),
              ti = I(Fr);
            {
              var Ai = ki => {
                  var wi = eP(),
                    Vi = I(wi);
                  {
                    var Yi = Ft => {
                        var zr = QS();
                        vi(), q(Ft, zr)
                      },
                      pt = Ft => {
                        var zr = Ba("Generate Preview");
                        q(Ft, zr)
                      };
                    Se(Vi, Ft => {
                      m(we) ? Ft(Yi) : Ft(pt, !1)
                    })
                  }
                  P(wi), Re(() => wi.disabled = m(we)), Mi("click", wi, Gr), q(ki, wi)
                },
                bi = ki => {
                  var wi = rP(),
                    Vi = I(wi);
                  {
                    var Yi = Ft => {
                        var zr = tP();
                        vi(), q(Ft, zr)
                      },
                      pt = Ft => {
                        var zr = Ba("Confirm painting");
                        q(Ft, zr)
                      };
                    Se(Vi, Ft => {
                      m(Fe) ? Ft(Yi) : Ft(pt, !1)
                    })
                  }
                  P(wi), Re(() => wi.disabled = m(Fe)), Mi("click", wi, Wr), q(ki, wi)
                };
              Se(ti, ki => {
                m(Ie) ? ki(bi, !1) : ki(Ai)
              })
            }
            var Yr = D(ti, 2),
              Zr = D(Yr, 2);
            {
              var Ii = ki => {
                var wi = iP(),
                  Vi = I(wi);
                P(wi), Re(Yi => te(Vi, `Ready to paint ${Yi??""} pixels.`), [() => (m(De), Cn(() => m(De).pixels.toLocaleString(navigator.language)))]), q(ki, wi)
              };
              Se(Zr, ki => {
                m(Ie) && ki(Ii)
              })
            }
            P(Fr), Re(() => {
              te(Kt, m($e)), te(fr, `Target size: ${m(Ae),Cn(()=>m(Ae).width)??""}  ${m(Ae),Cn(()=>m(Ae).height)??""} pixels`), Vm(Yt, m(_t) * 100)
            }), Mi("input", Yt, ki => {
              const wi = ki.target;
              H(_t, Number(wi.value) / 100)
            }), gp(Jr, () => m(Qe), ki => H(Qe, ki)), Mi("change", Jr, () => {
              m(Ie) && de()
            }), gp(bt, () => m(Ge), ki => H(Ge, ki)), Mi("change", bt, () => {
              m(Ie) && de()
            }), j1(Gt, () => m(ft), ki => H(ft, ki)), Mi("change", Gt, () => {
              m(Ie) && de()
            }), Mi("click", dr, () => H(Z, "upload")), Mi("click", Ar, () => jr(!0, !1)), Mi("click", Kr, () => jr(!1, !0)), vl(Or, () => m(_e), ki => H(_e, ki)), Mi("click", Yr, sr), q(Tt, dt)
          };
          Se(He, Tt => {
            m(et) && m(Ae) && Tt(ht)
          }, !0)
        }
        q(ne, Ce)
      };
    Se(J, ne => {
      m(Z) === "upload" ? ne(Ve) : ne(tt, !1)
    })
  }
  P(ue), P(Q), Mi("click", Be, sr), q(y, j), ii()
}
const cp = _a({
  shouldReload: !0
});
var oP = he('<dialog class="modal" closeby="any"><div class="modal-box max-w-2xl"><h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form><div class="mb-4 mt-2"><!></div> <div class="flex w-full justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-primary"> </button></div></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function lP(y, u) {
  ri(u, !0);
  let v = rr(u, "ref", 15),
    b = Ke(!1),
    k = Ke(_a(u.description)),
    z = Ke(void 0);
  var T = oP(),
    s = I(T),
    B = I(s),
    W = I(B, !0);
  P(B);
  var ee = D(B, 2),
    $ = I(ee),
    oe = I($);
  {
    let Fe = mt(() => c0());
    l0(oe, {
      class: "h-24 rounded-lg",
      get placeholder() {
        return m(Fe)
      },
      max: 512,
      get value() {
        return m(k)
      },
      set value(xe) {
        H(k, xe, !0)
      },
      get validate() {
        return m(z)
      },
      set validate(xe) {
        H(z, xe, !0)
      }
    })
  }
  P($);
  var me = D($, 2),
    _e = I(me);
  _e.__click = () => {
    var Fe;
    (Fe = v()) == null || Fe.close()
  };
  var Z = I(_e, !0);
  P(_e);
  var Ie = D(_e, 2),
    we = I(Ie, !0);
  P(Ie), P(me), P(ee), P(s), vi(2), P(T), Rn(T, Fe => v(Fe), () => v()), Re((Fe, xe, $e) => {
    te(W, Fe), _e.disabled = m(b), te(Z, xe), Ie.disabled = m(b), te(we, $e)
  }, [() => sb(), () => Rc(), () => ob()]), Mi("submit", ee, async () => {
    var Fe, xe, $e;
    try {
      if (!((Fe = m(z)) != null && Fe())) return;
      H(b, !0), u.description !== m(k) && await ui.updateAllianceDescription(m(k)), await ((xe = u.onsuccess) == null ? void 0 : xe.call(u, m(k))), ($e = v()) == null || $e.close()
    } catch (et) {
      Nt.error(et.message)
    } finally {
      H(b, !1)
    }
  }), q(y, T), ii()
}
$i(["click"]);
var cP = he('<span class="loading loading-spinner loading-md center-absolute absolute"></span>'),
  uP = he('<dialog class="modal" closedby="any"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2"></button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <span class="text-base-content/80 text-sm"> </span> <div class="relative mt-4"><div><input class="text-base-content/80 min-w-10 grow text-sm font-medium" readonly=""/> <div class="h-10"><button> </button></div></div> <!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function hP(y, u) {
  ri(u, !0);
  let v = rr(u, "open", 15),
    b = Ke(""),
    k = Ke(!1);
  const z = mt(() => ga.url.origin + `/join?id=${m(b)}`);
  oi(() => {
    v() && ui.getAllianceInvites().then(Xe => {
      H(b, Xe[0], !0)
    }).catch(Xe => {
      Nt.error(Xe.message)
    })
  });
  var T = uP(),
    s = I(T),
    B = D(I(s), 2),
    W = I(B, !0);
  P(B);
  var ee = D(B, 2),
    $ = I(ee, !0);
  P(ee);
  var oe = D(ee, 2),
    me = I(oe);
  let _e;
  var Z = I(me);
  Xa(Z);
  var Ie = D(Z, 2),
    we = I(Ie);
  let Fe;
  we.__click = () => {
    navigator.clipboard.writeText(m(z).toString()), H(k, !0), setTimeout(() => {
      H(k, !1)
    }, 1e3)
  };
  var xe = I(we, !0);
  P(we), P(Ie), P(me);
  var $e = D(me, 2);
  {
    var et = Xe => {
      var Ae = cP();
      q(Xe, Ae)
    };
    Se($e, Xe => {
      m(b) || Xe(et)
    })
  }
  P(oe), P(s), vi(2), P(T), Ya(T, () => Xe => {
    oi(() => {
      v() ? Xe.show() : Xe.close()
    })
  }), Re((Xe, Ae, De, Ye) => {
    te(W, Xe), te($, Ae), _e = Vr(me, 1, "border-base-content/20 rounded-field relative flex w-full items-center gap-1 border-2 py-1.5 pl-4 pr-2.5", null, _e, {
      invisible: !m(b)
    }), Vm(Z, De), Fe = Vr(we, 1, "btn btn-primary", null, Fe, {
      "btn-success": m(k)
    }), te(xe, Ye)
  }, [() => lb(), () => cb(), () => m(z).toString(), () => m(k) ? Wm() : nm()]), Mi("close", T, () => v(!1)), q(y, T), ii()
}
$i(["click"]);
var dP = Xr('<svg><path d="M216.856 16.597A208.502 208.502 0 0 0 164.042 0c-2.275 4.113-4.933 9.645-6.766 14.046-19.692-2.961-39.203-2.961-58.533 0-1.832-4.4-4.55-9.933-6.846-14.046a207.809 207.809 0 0 0-52.855 16.638C5.618 67.147-3.443 116.4 1.087 164.956c22.169 16.555 43.653 26.612 64.775 33.193A161.094 161.094 0 0 0 79.735 175.3a136.413 136.413 0 0 1-21.846-10.632 108.636 108.636 0 0 0 5.356-4.237c42.122 19.702 87.89 19.702 129.51 0a131.66 131.66 0 0 0 5.355 4.237 136.07 136.07 0 0 1-21.886 10.653c4.006 8.02 8.638 15.67 13.873 22.848 21.142-6.58 42.646-16.637 64.815-33.213 5.316-56.288-9.08-105.09-38.056-148.36ZM85.474 135.095c-12.645 0-23.015-11.805-23.015-26.18s10.149-26.2 23.015-26.2c12.867 0 23.236 11.804 23.015 26.2.02 14.375-10.148 26.18-23.015 26.18Zm85.051 0c-12.645 0-23.014-11.805-23.014-26.18s10.148-26.2 23.014-26.2c12.867 0 23.236 11.804 23.015 26.2 0 14.375-10.148 26.18-23.015 26.18Z" fill="#5865F2"></path></svg>');

function hm(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = dP();
  Lr(b, () => ({
    viewBox: "0 0 256 199",
    width: "256",
    height: "199",
    xmlns: "http://www.w3.org/2000/svg",
    preserveAspectRatio: "xMidYMid",
    ...v
  })), q(y, b)
}
var pP = he('<span class="text-success">(Verified)</span>'),
  fP = he('<a target="_blank" rel="noreferer" aria-label="Discord"><!></a>'),
  mP = he("<button><!></button>"),
  gP = he('<span class="tooltip h-4"><div class="tooltip-content"><span> </span> <!></div> <!></span>');

function zh(y, u) {
  ri(u, !0);
  const v = !!u.id;
  var b = gP(),
    k = I(b),
    z = I(k),
    T = I(z);
  P(z);
  var s = D(z, 2);
  {
    var B = oe => {
      var me = pP();
      q(oe, me)
    };
    Se(s, oe => {
      v && oe(B)
    })
  }
  P(k);
  var W = D(k, 2);
  {
    var ee = oe => {
        var me = fP(),
          _e = I(me);
        hm(_e, {
          class: "size-4 opacity-70"
        }), P(me), Re(Z => Qt(me, "href", Z), [() => `https://discord.com/users/${encodeURIComponent(u.id)}`]), q(oe, me)
      },
      $ = oe => {
        var me = mP();
        me.__click = async () => {
          await navigator.clipboard.writeText(u.username), Nt.info(ub())
        };
        var _e = I(me);
        hm(_e, {
          class: "size-4 opacity-70"
        }), P(me), q(oe, me)
      };
    Se(W, oe => {
      v ? oe(ee) : oe($, !1)
    })
  }
  P(b), Re(() => te(T, `Discord: ${u.username??""}`)), q(y, b), ii()
}
$i(["click"]);
var _P = he('<input type="radio" class="tab max-[380px]:px-3"/>'),
  vP = he('<div class="tabs tabs-border w-max font-medium"></div>');

function lg(y, u) {
  ri(u, !0);
  const v = [];
  let b = rr(u, "value", 15, "today"),
    k = [{
      value: "today",
      label: kp()
    }, {
      value: "week",
      label: hb()
    }, {
      value: "month",
      label: db()
    }, {
      value: "all-time",
      label: pb()
    }];
  var z = vP();
  na(z, 21, () => k, T => T.value, (T, s) => {
    var B = _P();
    Xa(B);
    var W;
    Re(() => {
      Qt(B, "aria-label", m(s).label), W !== (W = m(s).value) && (B.value = (B.__value = m(s).value) ?? "")
    }), Nm(v, [], B, () => (m(s).value, b()), b), q(T, B)
  }), P(z), q(y, z), ii()
}
const yP = typeof window < "u" ? window : void 0;

function xP(y) {
  let u = y.activeElement;
  for (; u != null && u.shadowRoot;) {
    const v = u.shadowRoot.activeElement;
    if (v === u) break;
    u = v
  }
  return u
}
var Mc, th, e0;
let bP = (e0 = class {
  constructor(u = {}) {
    xi(this, Mc);
    xi(this, th);
    const {
      window: v = yP,
      document: b = v == null ? void 0 : v.document
    } = u;
    v !== void 0 && (Mn(this, Mc, b), Mn(this, th, r0(k => {
      const z = fp(v, "focusin", k),
        T = fp(v, "focusout", k);
      return () => {
        z(), T()
      }
    })))
  }
  get current() {
    var u;
    return (u = ir(this, th)) == null || u.call(this), ir(this, Mc) ? xP(ir(this, Mc)) : null
  }
}, Mc = new WeakMap, th = new WeakMap, e0);
new bP;

function wP(y) {
  return typeof y == "function"
}

function TP(y, u) {
  if (wP(y)) {
    const b = y();
    return b === void 0 ? u : b
  }
  return y === void 0 ? u : y
}

function SP(y, u) {
  let v = Ke(null);
  const b = mt(() => TP(u, 250));

  function k(...z) {
    if (m(v)) m(v).timeout && clearTimeout(m(v).timeout);
    else {
      let T, s;
      const B = new Promise((W, ee) => {
        T = W, s = ee
      });
      H(v, {
        timeout: null,
        runner: null,
        promise: B,
        resolve: T,
        reject: s
      }, !0)
    }
    return m(v).runner = async () => {
      if (!m(v)) return;
      const T = m(v);
      H(v, null);
      try {
        T.resolve(await y.apply(this, z))
      } catch (s) {
        T.reject(s)
      }
    }, m(v).timeout = setTimeout(m(v).runner, m(b)), m(v).promise
  }
  return k.cancel = async () => {
    (!m(v) || m(v).timeout === null) && (await new Promise(z => setTimeout(z, 0)), !m(v) || m(v).timeout === null) || (clearTimeout(m(v).timeout), m(v).reject("Cancelled"), H(v, null))
  }, k.runScheduledNow = async () => {
    var z, T;
    (!m(v) || !m(v).timeout) && (await new Promise(s => setTimeout(s, 0)), !m(v) || !m(v).timeout) || (clearTimeout(m(v).timeout), m(v).timeout = null, await ((T = (z = m(v)).runner) == null ? void 0 : T.call(z)))
  }, Object.defineProperty(k, "pending", {
    enumerable: !0,
    get() {
      var z;
      return !!((z = m(v)) != null && z.timeout)
    }
  }), k
}

function PP(y, u) {
  switch (y) {
    case "post":
      oi(u);
      break;
    case "pre":
      jm(u);
      break
  }
}

function Y0(y, u, v, b = {}) {
  const {
    lazy: k = !1
  } = b;
  let z = !k,
    T = Array.isArray(y) ? [] : void 0;
  PP(u, () => {
    const s = Array.isArray(y) ? y.map(W => W()) : y();
    if (!z) {
      z = !0, T = s;
      return
    }
    const B = Cn(() => v(s, T));
    return T = s, B
  })
}

function ho(y, u, v) {
  Y0(y, "post", u, v)
}

function MP(y, u, v) {
  Y0(y, "pre", u, v)
}
ho.pre = MP;

function IP() {}
var gl, Fo;
class CP {
  constructor(u, v = 250) {
    xi(this, gl, Ke());
    xi(this, Fo);
    H(ir(this, gl), u(), !0), this.cancel = this.cancel.bind(this), this.setImmediately = this.setImmediately.bind(this), this.updateImmediately = this.updateImmediately.bind(this), Mn(this, Fo, SP(() => {
      H(ir(this, gl), u(), !0)
    }, v)), ho(u, () => {
      ir(this, Fo).call(this).catch(IP)
    })
  }
  get current() {
    return m(ir(this, gl))
  }
  get pending() {
    return ir(this, Fo).pending
  }
  cancel() {
    ir(this, Fo).cancel()
  }
  updateImmediately() {
    return ir(this, Fo).runScheduledNow()
  }
  setImmediately(u) {
    this.cancel(), H(ir(this, gl), u, !0)
  }
}
gl = new WeakMap, Fo = new WeakMap;
var AP = he('<span class="loading loading-spinner loading-lg mt-18 mx-auto flex items-center"></span>'),
  kP = he('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  EP = he('<span class="font-flag tooltip ml-0.5"> </span>'),
  zP = he("<button><!></button>"),
  LP = he('<tr><td class="text-base-content/80 font-medium max-[400px]:hidden"> </td><td><div class="flex items-center gap-2"><!> <span> <span class="ml-0.5"> </span></span> <!> <!></div></td><td class="text-base-content/80 relative text-center font-medium"> <!></td></tr>'),
  DP = he('<table class="table"><thead class="text-base-content/80"><tr><th class="max-[400px]:hidden"></th><th> </th><th class="text-center max-sm:px-1"> </th></tr></thead><tbody></tbody></table>'),
  RP = he('<div><!> <div class="mt-4"><!></div></div>');

function FP(y, u) {
  ri(u, !0);
  let v = rr(u, "reload", 15),
    b = Ke(!0),
    k = Ke([]),
    z = Ke(0),
    T = Ke("today"),
    s = {};
  v(B);

  function B() {
    const Z = m(T);
    ui.allianceLeaderboard(Z).then(Ie => {
      H(k, Ie), s = {
        [Z]: Ie
      }, H(b, !1)
    }).catch(Ie => {
      Nt.error(Ie.message)
    })
  }
  ho(() => [m(T)], () => {
    const Z = m(T),
      Ie = s[Z];
    if (Ie) {
      H(k, Ie), H(b, !1);
      return
    }
    H(b, !0), ui.allianceLeaderboard(Z).then(we => {
      H(k, we), s[Z] = we, H(b, !1)
    }).catch(we => {
      Nt.error(we.message)
    })
  });
  var W = RP(),
    ee = I(W);
  lg(ee, {
    get value() {
      return m(T)
    },
    set value(Z) {
      H(T, Z, !0)
    }
  });
  var $ = D(ee, 2),
    oe = I($);
  {
    var me = Z => {
        var Ie = AP();
        q(Z, Ie)
      },
      _e = Z => {
        var Ie = Sr(),
          we = Ct(Ie);
        {
          var Fe = $e => {
              var et = kP(),
                Xe = I(et),
                Ae = D(Xe);
              {
                var De = Le => {
                    var qe = Ba();
                    Re(_t => te(qe, _t), [() => kp().toLowerCase()]), q(Le, qe)
                  },
                  Ye = Le => {
                    var qe = Sr(),
                      _t = Ct(qe);
                    {
                      var Qe = ft => {
                          var Vt = Ba();
                          Re(Et => te(Vt, Et), [() => $m()]), q(ft, Vt)
                        },
                        Ge = ft => {
                          var Vt = Sr(),
                            Et = Ct(Vt);
                          {
                            var Pt = ot => {
                              var Ht = Ba();
                              Re(vt => te(Ht, vt), [() => Xm()]), q(ot, Ht)
                            };
                            Se(Et, ot => {
                              m(T) === "month" && ot(Pt)
                            }, !0)
                          }
                          q(ft, Vt)
                        };
                      Se(_t, ft => {
                        m(T) === "week" ? ft(Qe) : ft(Ge, !1)
                      }, !0)
                    }
                    q(Le, qe)
                  };
                Se(Ae, Le => {
                  m(T) === "today" ? Le(De) : Le(Ye, !1)
                })
              }
              P(et), Re(Le => te(Xe, `${Le??""} `), [() => Hm()]), q($e, et)
            },
            xe = $e => {
              var et = DP(),
                Xe = I(et),
                Ae = I(Xe),
                De = D(I(Ae)),
                Ye = I(De, !0);
              P(De);
              var Le = D(De),
                qe = I(Le, !0);
              P(Le), P(Ae), P(Xe);
              var _t = D(Xe);
              na(_t, 31, () => m(k), Qe => Qe.userId, (Qe, Ge, ft) => {
                const Vt = mt(() => {
                  var wt;
                  return ((wt = Lt.data) == null ? void 0 : wt.id) === m(Ge).userId
                });
                var Et = LP();
                let Pt;
                var ot = I(Et),
                  Ht = I(ot, !0);
                P(ot);
                var vt = D(ot),
                  Dt = I(vt),
                  Rt = I(Dt);
                Dn(Rt, {
                  class: "size-10 border",
                  get userId() {
                    return m(Ge).userId
                  },
                  get pictureUrl() {
                    return m(Ge).picture
                  }
                });
                var $t = D(Rt, 2),
                  pr = I($t),
                  Xt = D(pr),
                  or = I(Xt);
                P(Xt), P($t);
                var nt = D($t, 2);
                {
                  var rt = wt => {
                    const It = mt(() => zs(m(Ge).equippedFlag));
                    var Ut = EP(),
                      ut = I(Ut, !0);
                    P(Ut), Re(() => {
                      Qt(Ut, "data-tip", m(It).name), te(ut, m(It).flag)
                    }), q(wt, Ut)
                  };
                  Se(nt, wt => {
                    m(Ge).equippedFlag && wt(rt)
                  })
                }
                var Zt = D(nt, 2);
                {
                  var Jt = wt => {
                    zh(wt, {
                      get username() {
                        return m(Ge).discord
                      },
                      get id() {
                        return m(Ge).discordId
                      }
                    })
                  };
                  Se(Zt, wt => {
                    m(Ge).discord && wt(Jt)
                  })
                }
                P(Dt), P(vt);
                var Ot = D(vt),
                  mr = I(Ot),
                  At = D(mr);
                {
                  var Mt = wt => {
                    var It = zP();
                    let Ut;
                    It.__click = () => {
                      u.onlastpixelclick({
                        lat: m(Ge).lastLatitude ?? 0,
                        lng: m(Ge).lastLongitude ?? 0
                      })
                    };
                    var ut = I(It);
                    Lp(ut, {
                      class: "size-4"
                    }), P(It), Re(ur => {
                      Ut = Vr(It, 1, "btn btn-sm btn-ghost -translate-y-1/2! absolute -right-2 top-1/2 sm:right-4", null, Ut, {
                        tooltip: m(z) > 640
                      }), Qt(It, "data-tip", ur)
                    }, [() => W5()]), q(wt, It)
                  };
                  Se(At, wt => {
                    m(Ge).lastLatitude && m(Ge).lastLongitude && wt(Mt)
                  })
                }
                P(Ot), P(Et), Re((wt, It) => {
                  var Ut;
                  Pt = Vr(Et, 1, "", null, Pt, {
                    "bg-base-200": m(Vt)
                  }), te(Ht, m(ft) + 1), Vr($t, 1, `font-semibold ${wt??""} flex gap-1`), te(pr, `${(m(Vt)?((Ut=Lt.data)==null?void 0:Ut.name)??m(Ge).name:m(Ge).name)??""} `), te(or, `#${m(Ge).userId??""}`), te(mr, `${It??""} `)
                }, [() => tn(m(Ge).userId), () => m(Ge).pixelsPainted.toLocaleString(navigator.language)]), fl(Et, () => ml, () => ({
                  duration: 200
                })), q(Qe, Et)
              }), P(_t), P(et), Re((Qe, Ge) => {
                te(Ye, Qe), te(qe, Ge)
              }, [() => Km(), () => Gm()]), q($e, et)
            };
          Se(we, $e => {
            m(k).length === 0 ? $e(Fe) : $e(xe, !1)
          }, !0)
        }
        q(Z, Ie)
      };
    Se(oe, Z => {
      m(b) ? Z(me) : Z(_e, !1)
    })
  }
  P($), P(W), Ch("innerWidth", Z => H(z, Z, !0)), q(y, W), ii()
}
$i(["click"]);
var BP = Xr('<svg><path d="M480-160q-33 0-56.5-23.5T400-240q0-33 23.5-56.5T480-320q33 0 56.5 23.5T560-240q0 33-23.5 56.5T480-160Zm0-240q-33 0-56.5-23.5T400-480q0-33 23.5-56.5T480-560q33 0 56.5 23.5T560-480q0 33-23.5 56.5T480-400Zm0-240q-33 0-56.5-23.5T400-720q0-33 23.5-56.5T480-800q33 0 56.5 23.5T560-720q0 33-23.5 56.5T480-640Z"></path></svg>');

function cg(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = BP();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var OP = he('<div class="badge badge-primary badge-sm badge-soft">ADMIN</div>'),
  jP = he('<li><button class="btn btn-ghost"> </button></li> <li><button class="btn btn-ghost btn-error not-hover:text-error"> </button></li>', 1),
  qP = he('<li><button class="btn btn-ghost text-base-content/80"> </button></li>'),
  VP = he('<tr><td class="w-full"><div class="flex items-center gap-2"><!> <span> </span> <!></div></td><td class="px-0"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-ghost"><!></div> <ul class="dropdown-content menu bg-base-100 rounded-box z-1 border-base-200 right-0 w-44 translate-y-1 gap-1 border p-2 shadow-sm"><!></ul></div></td></tr>'),
  ZP = he('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'),
  NP = he('<tr><td class="w-full"><div class="flex items-center gap-2"><!> <span> </span></div></td><td class="px-0"><button class="btn btn-error"> </button></td></tr>'),
  UP = he('<div class="text-base-content/80 mt-4 flex justify-center"> </div>'),
  GP = he('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'),
  WP = he('<div><section class="mt-2 flex items-center gap-1"><button class="btn btn-ghost btn-circle"><!></button> <h2 class="text-xl font-semibold"> </h2></section> <div class="tabs tabs-border mt-2"><input type="radio" name="members_tabs" class="tab" checked/> <div class="tab-content py-4"><table class="table"><tbody></tbody></table> <!></div> <input type="radio" name="members_tabs" class="tab"/> <div class="tab-content py-4"><table class="table"><tbody></tbody></table> <!> <!></div></div></div>');

function HP(y, u) {
  ri(u, !0);
  let v = _a({
      data: [],
      page: 0,
      hasNextPage: !0,
      loading: !1
    }),
    b = _a({
      data: [],
      page: 0,
      hasNextPage: !0,
      loading: !1
    });
  var k = WP(),
    z = I(k),
    T = I(z);
  T.__click = () => u.onclickback();
  var s = I(T);
  w0(s, {
    class: "size-5"
  }), P(T);
  var B = D(T, 2),
    W = I(B, !0);
  P(B), P(z);
  var ee = D(z, 2),
    $ = I(ee);
  Xa($);
  var oe = D($, 2),
    me = I(oe),
    _e = I(me);
  na(_e, 21, () => v.data, Ye => Ye.id, (Ye, Le, qe) => {
    const _t = mt(() => {
      var rt;
      return ((rt = Lt.data) == null ? void 0 : rt.id) === m(Le).id
    });
    var Qe = VP(),
      Ge = I(Qe),
      ft = I(Ge),
      Vt = I(ft);
    Dn(Vt, {
      class: "size-10 border",
      get userId() {
        return m(Le).id
      },
      get pictureUrl() {
        return m(Le).picture
      }
    });
    var Et = D(Vt, 2),
      Pt = I(Et);
    P(Et);
    var ot = D(Et, 2);
    {
      var Ht = rt => {
        var Zt = OP();
        q(rt, Zt)
      };
      Se(ot, rt => {
        m(Le).role === "admin" && rt(Ht)
      })
    }
    P(ft), P(Ge);
    var vt = D(Ge),
      Dt = I(vt),
      Rt = I(Dt),
      $t = I(Rt);
    cg($t, {
      class: "size-4"
    }), P(Rt);
    var pr = D(Rt, 2),
      Xt = I(pr);
    {
      var or = rt => {
          var Zt = jP(),
            Jt = Ct(Zt),
            Ot = I(Jt);
          Ot.__click = async () => {
            try {
              m(Le).loading = !0, await ui.giveAllianceAdmin(m(Le).id), m(Le).role = "admin"
            } catch {
              Nt.error(fb())
            } finally {
              m(Le).loading = !1
            }
          };
          var mr = I(Ot, !0);
          P(Ot), P(Jt);
          var At = D(Jt, 2),
            Mt = I(At);
          Mt.__click = async () => {
            try {
              m(Le).loading = !0, await ui.banAllianceUser(m(Le).id), v.data = v.data.filter(It => It.id !== m(Le).id)
            } catch {
              Nt.error(mb())
            } finally {
              m(Le).loading = !1
            }
          };
          var wt = I(Mt, !0);
          P(Mt), P(At), Re((It, Ut) => {
            Ot.disabled = m(Le).loading, te(mr, It), Mt.disabled = m(Le).loading, te(wt, Ut)
          }, [() => gb(), () => u0()]), q(rt, Zt)
        },
        nt = rt => {
          var Zt = qP(),
            Jt = I(Zt);
          Jt.disabled = !0;
          var Ot = I(Jt, !0);
          P(Jt), P(Zt), Re(mr => te(Ot, mr), [() => _b()]), q(rt, Zt)
        };
      Se(Xt, rt => {
        m(Le).role === "member" ? rt(or) : rt(nt, !1)
      })
    }
    P(pr), P(Dt), P(vt), P(Qe), Re(rt => {
      var Zt;
      Vr(Et, 1, `font-semibold ${rt??""}`), te(Pt, `${(m(_t)?((Zt=Lt.data)==null?void 0:Zt.name)??m(Le).name:m(Le).name)??""} #${m(Le).id??""}`)
    }, [() => tn(m(Le).id)]), q(Ye, Qe)
  }), P(_e), P(me);
  var Z = D(me, 2);
  {
    var Ie = Ye => {
      var Le = Sr(),
        qe = Ct(Le);
      Ec(qe, () => v.page, _t => {
        var Qe = ZP();
        Ya(Qe, () => Ge => {
          const ft = new IntersectionObserver(Vt => {
            Vt[0].isIntersecting && !v.loading && (v.loading = !0, ui.getAllianceMembers(v.page).then(Et => {
              v.data = [...v.data, ...Et.data], v.hasNextPage = Et.hasNext, v.page++
            }).catch(Et => {
              Nt.error(Et.message)
            }).finally(() => {
              v.loading = !1
            }))
          });
          return ft.observe(Ge), () => {
            ft.disconnect()
          }
        }), q(_t, Qe)
      }), q(Ye, Le)
    };
    Se(Z, Ye => {
      v.hasNextPage && Ye(Ie)
    })
  }
  P(oe);
  var we = D(oe, 2),
    Fe = D(we, 2),
    xe = I(Fe),
    $e = I(xe);
  na($e, 21, () => b.data, Ye => Ye.id, (Ye, Le, qe) => {
    var _t = NP(),
      Qe = I(_t),
      Ge = I(Qe),
      ft = I(Ge);
    Dn(ft, {
      class: "size-10 border",
      get userId() {
        return m(Le).id
      },
      get pictureUrl() {
        return m(Le).picture
      }
    });
    var Vt = D(ft, 2),
      Et = I(Vt);
    P(Vt), P(Ge), P(Qe);
    var Pt = D(Qe),
      ot = I(Pt);
    ot.__click = () => {
      ui.unbanAllianceUser(m(Le).id).then(() => {
        b.data = b.data.filter(vt => vt.id !== m(Le).id)
      }).catch(vt => Nt.error(vt.message)).finally(() => {
        m(Le).loading = !1
      })
    };
    var Ht = I(ot, !0);
    P(ot), P(Pt), P(_t), Re((vt, Dt) => {
      Vr(Vt, 1, `font-semibold ${vt??""}`), te(Et, `${m(Le).name??""} #${m(Le).id??""}`), ot.disabled = m(Le).loading, te(Ht, Dt)
    }, [() => tn(m(Le).id), () => $5()]), q(Ye, _t)
  }), P($e), P(xe);
  var et = D(xe, 2);
  {
    var Xe = Ye => {
      var Le = UP(),
        qe = I(Le, !0);
      P(Le), Re(_t => te(qe, _t), [() => vb()]), q(Ye, Le)
    };
    Se(et, Ye => {
      !b.hasNextPage && b.data.length === 0 && Ye(Xe)
    })
  }
  var Ae = D(et, 2);
  {
    var De = Ye => {
      var Le = Sr(),
        qe = Ct(Le);
      Ec(qe, () => b.page, _t => {
        var Qe = GP();
        Ya(Qe, () => Ge => {
          const ft = new IntersectionObserver(Vt => {
            Vt[0].isIntersecting && !b.loading && (b.loading = !0, ui.getAllianceBannedMembers(b.page).then(Et => {
              b.data = [...b.data, ...Et.data], b.hasNextPage = Et.hasNext, b.page++
            }).catch(Et => {
              Nt.error(Et.message)
            }).finally(() => {
              b.loading = !1
            }))
          });
          return ft.observe(Ge), () => {
            ft.disconnect()
          }
        }), q(_t, Qe)
      }), q(Ye, Le)
    };
    Se(Ae, Ye => {
      b.hasNextPage && Ye(De)
    })
  }
  P(Fe), P(ee), P(k), Re((Ye, Le, qe) => {
    te(W, Ye), Qt($, "aria-label", Le), Qt(we, "aria-label", qe)
  }, [() => b0(), () => X5(), () => Jm()]), q(y, k), ii()
}
$i(["click"]);
var $P = he('<span class="label"> </span>'),
  XP = he('<span class="hidden px-1 text-[10px] peer-focus:block"> </span>'),
  YP = he('<p class="text-error ml-3 text-sm"> </p>'),
  KP = he('<div><label><!> <input class="peer" type="text"/> <!></label> <!></div>');

function dm(y, u) {
  ri(u, !0);
  let v = rr(u, "value", 15),
    b = rr(u, "validate", 15),
    k = Ke("");
  const z = mt(() => {
    var we;
    return ((we = v()) == null ? void 0 : we.length) ?? 0
  });
  b(T);

  function T() {
    return u.min !== void 0 && m(z) < u.min ? (H(k, m(z) === 0 ? "Required" : `Min. characters: ${u.min}`, !0), !1) : u.max !== void 0 && m(z) > u.max ? (H(k, `Max. characters: ${u.max}`), !1) : !0
  }
  oi(() => {
    var we;
    u.max !== void 0 && m(z) > u.max && v((we = v()) == null ? void 0 : we.substring(0, u.max))
  });
  var s = KP(),
    B = I(s);
  let W;
  var ee = I(B);
  {
    var $ = we => {
      var Fe = $P(),
        xe = I(Fe, !0);
      P(Fe), Re(() => te(xe, u.label)), q(we, Fe)
    };
    Se(ee, we => {
      u.label && we($)
    })
  }
  var oe = D(ee, 2);
  Xa(oe);
  var me = D(oe, 2);
  {
    var _e = we => {
      var Fe = XP(),
        xe = I(Fe, !0);
      P(Fe), Re(() => te(xe, u.max - m(z))), q(we, Fe)
    };
    Se(me, we => {
      u.max !== void 0 && we(_e)
    })
  }
  P(B);
  var Z = D(B, 2);
  {
    var Ie = we => {
      var Fe = YP(),
        xe = I(Fe, !0);
      P(Fe), Re(() => te(xe, m(k))), q(we, Fe)
    };
    Se(Z, we => {
      m(k) && we(Ie)
    })
  }
  P(s), Re(() => {
    W = Vr(B, 1, "input w-full", null, W, {
      "input-error": !!m(k)
    }), Qt(oe, "placeholder", u.placeholder), Qt(oe, "maxlength", u.max)
  }), vl(oe, v), q(y, s), ii()
}
var JP = he('<dialog class="modal" closedby="any"><div class="modal-box"><h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form><div class="my-4"><!></div> <div class="flex w-full justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-primary"> </button></div></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function QP(y, u) {
  ri(u, !0);
  let v = rr(u, "ref", 15),
    b = Ke(!1),
    k = Ke(""),
    z = Ke(void 0);
  var T = JP(),
    s = I(T),
    B = I(s),
    W = I(B, !0);
  P(B);
  var ee = D(B, 2),
    $ = I(ee),
    oe = I($);
  {
    let Fe = mt(() => im()),
      xe = mt(() => bb());
    dm(oe, {
      get label() {
        return m(Fe)
      },
      get placeholder() {
        return m(xe)
      },
      min: 1,
      max: 16,
      get value() {
        return m(k)
      },
      set value($e) {
        H(k, $e, !0)
      },
      get validate() {
        return m(z)
      },
      set validate($e) {
        H(z, $e, !0)
      }
    })
  }
  P($);
  var me = D($, 2),
    _e = I(me);
  _e.__click = () => {
    var Fe;
    (Fe = v()) == null || Fe.close()
  };
  var Z = I(_e, !0);
  P(_e);
  var Ie = D(_e, 2),
    we = I(Ie, !0);
  P(Ie), P(me), P(ee), P(s), vi(2), P(T), Rn(T, Fe => v(Fe), () => v()), Re((Fe, xe, $e) => {
    te(W, Fe), _e.disabled = m(b), te(Z, xe), Ie.disabled = m(b), te(we, $e)
  }, [() => yb(), () => Rc(), () => xb()]), Mi("submit", ee, async () => {
    var Fe, xe;
    try {
      if (!((Fe = m(z)) != null && Fe())) return;
      H(b, !0);
      const {
        id: $e
      } = await ui.createAlliance(m(k));
      await u.onsuccess($e), (xe = v()) == null || xe.close()
    } catch ($e) {
      Nt.error($e.message)
    } finally {
      H(b, !1)
    }
  }), q(y, T), ii()
}
$i(["click"]);
var e4 = Xr('<svg><path d="M360-440h80v-110h80v110h80v-190l-120-80-120 80v190ZM480-80Q319-217 239.5-334.5T160-552q0-150 96.5-239T480-880q127 0 223.5 89T800-552q0 100-79.5 217.5T480-80Z"></path></svg>');

function t4(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = e4();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var r4 = Xr('<svg><path d="M160-160q-33 0-56.5-23.5T80-240v-480q0-33 23.5-56.5T160-800h640q33 0 56.5 23.5T880-720v480q0 33-23.5 56.5T800-160H160Zm320-280L160-640v400h640v-400L480-440Zm0-80 320-200H160l320 200ZM160-640v-80 480-400Z"></path></svg>');

function i4(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = r4();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var a4 = Xr('<svg><path d="M720-400v-120H600v-80h120v-120h80v120h120v80H800v120h-80Zm-360-80q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM40-160v-112q0-34 17.5-62.5T104-378q62-31 126-46.5T360-440q66 0 130 15.5T616-378q29 15 46.5 43.5T680-272v112H40Z"></path></svg>');

function n4(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = a4();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var s4 = Xr('<svg><path d="M480-480q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM160-160v-112q0-34 17.5-62.5T224-378q62-31 126-46.5T480-440q66 0 130 15.5T736-378q29 15 46.5 43.5T800-272v112H160Z"></path></svg>');

function Dp(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = s4();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}

function o4(y, u = "_blank") {
  return y.replaceAll(/https?:\/\/[^\s]+/g, v => `<a href="${v}"${u?` target="${u}"`:""}>${v}</a>`)
}
var l4 = he('<div class="flex h-full items-center justify-center"><span class="loading loading-spinner loading-xl"></span></div>'),
  c4 = he('<div class="tooltip"><button class="btn"><!></button></div>'),
  u4 = he('<button class="text-base-content/50 translate-y-0.5 p-1"><!></button>'),
  h4 = he('<section class="text-base-content/80 highlight-link"><!> <!></section>'),
  d4 = he('<span class="font-semibold"> </span>'),
  p4 = he('<button class="text-primary font-semibold underline"> </button>'),
  f4 = he('<span class="text-primary underline"> </span>'),
  m4 = he('<span class="text-primary underline"> </span>'),
  g4 = he('<button class="text-base-content/80 p-1"><!></button>'),
  _4 = he('<div class="flex items-center gap-1"><!> <span> <button class="font-semibold"><!></button></span> <!></div>'),
  v4 = he('<section class="flex items-center justify-between"><h2 class="text-xl font-semibold sm:text-3xl"> </h2> <div class="flex items-center gap-1"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-ghost"><!></div> <ul class="dropdown-content menu bg-base-100 rounded-box z-1 border-base-200 right-0 w-44 translate-y-1 border p-2 shadow-sm"><li><button class="btn btn-soft btn-error"> </button></li></ul></div> <!></div></section> <!> <section class="mt-3"><div class="flex items-center gap-1"><!> <span> <span class="font-semibold"> </span></span></div> <div class="flex items-center gap-1"><!> <span> <!></span></div> <!></section> <section class="mt-6"><h3 class="text-lg font-semibold"> </h3> <div class="mt-1 pb-2"><!></div></section> <!> <!>', 1),
  y4 = he('<div class="flex h-[90%] flex-col items-center justify-center gap-3"><span class="text-base-content/80"> </span> <span class="mt-8 flex items-center gap-2 text-xl font-semibold"><!> </span> <div class="flex w-full justify-center"><div class="divider w-full max-w-sm"> </div></div> <button class="btn btn-xl btn-soft mb-6"><!> </button></div> <!>', 1),
  x4 = he('<div class="h-full"><!></div>');

function b4(y, u) {
  ri(u, !0);
  let v = Ke(void 0),
    b = Ke(!0),
    k = Ke(void 0),
    z = Ke(!1),
    T = Ke(void 0),
    s = Ke(!1),
    B = Ke(!1),
    W = Ke(() => {});
  ho(() => u.open, () => {
    u.open && cp.shouldReload && ee()
  }), $a(() => {
    const Z = setInterval(() => {
      cp.shouldReload = !0
    }, 1e4);
    return () => {
      clearTimeout(Z)
    }
  });
  async function ee() {
    try {
      H(v, await ui.getAlliance(), !0), m(v) && m(W)(), H(b, !1), cp.shouldReload = !1
    } catch (Z) {
      Nt.error(Z.message)
    }
  }
  var $ = x4(),
    oe = I($);
  {
    var me = Z => {
        var Ie = l4();
        q(Z, Ie)
      },
      _e = Z => {
        var Ie = Sr(),
          we = Ct(Ie);
        {
          var Fe = $e => {
              HP($e, {
                onclickback: () => H(B, !1)
              })
            },
            xe = $e => {
              var et = Sr(),
                Xe = Ct(et);
              {
                var Ae = Ye => {
                    var Le = v4(),
                      qe = Ct(Le),
                      _t = I(qe),
                      Qe = I(_t, !0);
                    P(_t);
                    var Ge = D(_t, 2),
                      ft = I(Ge),
                      Vt = I(ft),
                      Et = I(Vt);
                    cg(Et, {
                      class: "size-4"
                    }), P(Vt);
                    var Pt = D(Vt, 2),
                      ot = I(Pt),
                      Ht = I(ot);
                    Ht.__click = async () => {
                      try {
                        H(z, !0), await ui.leaveAlliance(), H(b, !0), await ee()
                      } catch (sr) {
                        Nt.error(sr.message)
                      } finally {
                        H(z, !1)
                      }
                    };
                    var vt = I(Ht, !0);
                    P(Ht), P(ot), P(Pt), P(ft);
                    var Dt = D(ft, 2);
                    {
                      var Rt = sr => {
                        var de = c4(),
                          j = I(de);
                        j.__click = () => {
                          H(s, !0)
                        };
                        var V = I(j);
                        n4(V, {
                          class: "size-4"
                        }), P(j), P(de), Re(X => Qt(de, "data-tip", X), [() => Ib()]), q(sr, de)
                      };
                      Se(Dt, sr => {
                        m(v).role == "admin" && sr(Rt)
                      })
                    }
                    P(Ge), P(qe);
                    var $t = D(qe, 2);
                    {
                      var pr = sr => {
                        var de = h4(),
                          j = I(de);
                        Ap(j, () => o4(m(v).description || c0()));
                        var V = D(j, 2);
                        {
                          var X = re => {
                            var Q = u4();
                            Q.__click = () => {
                              var Te;
                              (Te = m(T)) == null || Te.show()
                            };
                            var ue = I(Q);
                            sm(ue, {
                              class: "size-4"
                            }), P(Q), q(re, Q)
                          };
                          Se(V, re => {
                            m(v).role === "admin" && re(X)
                          })
                        }
                        P(de), q(sr, de)
                      };
                      Se($t, sr => {
                        (m(v).description || m(v).role === "admin") && sr(pr)
                      })
                    }
                    var Xt = D($t, 2),
                      or = I(Xt),
                      nt = I(or);
                    yl(nt, {
                      class: "inline size-4"
                    });
                    var rt = D(nt, 2),
                      Zt = I(rt),
                      Jt = D(Zt),
                      Ot = I(Jt, !0);
                    P(Jt), P(rt), P(or);
                    var mr = D(or, 2),
                      At = I(mr);
                    Dp(At, {
                      class: "inline size-4"
                    });
                    var Mt = D(At, 2),
                      wt = I(Mt),
                      It = D(wt);
                    {
                      var Ut = sr => {
                          var de = d4(),
                            j = I(de, !0);
                          P(de), Re(V => te(j, V), [() => m(v).members.toLocaleString(navigator.language)]), q(sr, de)
                        },
                        ut = sr => {
                          var de = p4();
                          de.__click = () => H(B, !0);
                          var j = I(de, !0);
                          P(de), Re(V => te(j, V), [() => m(v).members.toLocaleString(navigator.language)]), q(sr, de)
                        };
                      Se(It, sr => {
                        m(v).role === "member" ? sr(Ut) : sr(ut, !1)
                      })
                    }
                    P(Mt), P(mr);
                    var ur = D(mr, 2);
                    {
                      var br = sr => {
                        var de = _4(),
                          j = I(de);
                        t4(j, {
                          class: "inline size-4"
                        });
                        var V = D(j, 2),
                          X = I(V),
                          re = D(X);
                        re.__click = () => {
                          var We;
                          (We = m(v)) != null && We.hq ? u.onhqclick({
                            lat: m(v).hq.latitude,
                            lng: m(v).hq.longitude
                          }) : u.onhqchange()
                        };
                        var Q = I(re);
                        {
                          var ue = We => {
                              var Be = f4(),
                                ae = I(Be);
                              P(Be), Re((J, Ve) => te(ae, `${J??""}, ${Ve??""}`), [() => m(v).hq.latitude.toFixed(3), () => m(v).hq.longitude.toFixed(3)]), q(We, Be)
                            },
                            Te = We => {
                              var Be = m4(),
                                ae = I(Be, !0);
                              P(Be), Re(J => te(ae, J), [() => Ab()]), q(We, Be)
                            };
                          Se(Q, We => {
                            m(v).hq ? We(ue) : We(Te, !1)
                          })
                        }
                        P(re), P(V);
                        var be = D(V, 2);
                        {
                          var ze = We => {
                            var Be = g4();
                            Be.__click = function(...J) {
                              var Ve;
                              (Ve = u.onhqchange) == null || Ve.apply(this, J)
                            };
                            var ae = I(Be);
                            sm(ae, {
                              class: "text-base-content/50 size-4"
                            }), P(Be), q(We, Be)
                          };
                          Se(be, We => {
                            m(v).role === "admin" && We(ze)
                          })
                        }
                        P(de), Re(We => te(X, `${We??""}: `), [() => Cb()]), q(sr, de)
                      };
                      Se(ur, sr => {
                        (m(v).hq || m(v).role === "admin") && sr(br)
                      })
                    }
                    P(Xt);
                    var cr = D(Xt, 2),
                      jr = I(cr),
                      wr = I(jr, !0);
                    P(jr);
                    var Nr = D(jr, 2),
                      Gr = I(Nr);
                    FP(Gr, {
                      get allianceId() {
                        return m(v).id
                      },
                      get onlastpixelclick() {
                        return u.onlastpixelclick
                      },
                      get reload() {
                        return m(W)
                      },
                      set reload(sr) {
                        H(W, sr, !0)
                      }
                    }), P(Nr), P(cr);
                    var er = D(cr, 2);
                    lP(er, {
                      get description() {
                        return m(v).description
                      },
                      onsuccess: async sr => {
                        m(v) && (m(v).description = sr)
                      },
                      get ref() {
                        return m(T)
                      },
                      set ref(sr) {
                        H(T, sr, !0)
                      }
                    });
                    var Wr = D(er, 2);
                    hP(Wr, {
                      get open() {
                        return m(s)
                      },
                      set open(sr) {
                        H(s, sr, !0)
                      }
                    }), Re((sr, de, j, V, X) => {
                      te(Qe, m(v).name), Ht.disabled = m(z), te(vt, sr), te(Zt, `${de??""}: `), te(Ot, j), te(wt, `${V??""}: `), te(wr, X)
                    }, [() => wb(), () => Gm(), () => m(v).pixelsPainted.toLocaleString(navigator.language), () => b0(), () => eg()]), q(Ye, Le)
                  },
                  De = Ye => {
                    var Le = y4(),
                      qe = Ct(Le),
                      _t = I(qe),
                      Qe = I(_t);
                    P(_t);
                    var Ge = D(_t, 2),
                      ft = I(Ge);
                    i4(ft, {
                      class: "size-5"
                    });
                    var Vt = D(ft, 1, !0);
                    P(Ge);
                    var Et = D(Ge, 2),
                      Pt = I(Et),
                      ot = I(Pt, !0);
                    P(Pt), P(Et);
                    var Ht = D(Et, 2);
                    Ht.__click = () => {
                      var $t;
                      ($t = m(k)) == null || $t.show()
                    };
                    var vt = I(Ht);
                    a0(vt, {
                      class: "size-6"
                    });
                    var Dt = D(vt);
                    P(Ht), P(qe);
                    var Rt = D(qe, 2);
                    QP(Rt, {
                      onsuccess: ee,
                      get ref() {
                        return m(k)
                      },
                      set ref($t) {
                        H(k, $t, !0)
                      }
                    }), Re(($t, pr, Xt, or) => {
                      te(Qe, `${$t??""}:`), te(Vt, pr), te(ot, Xt), te(Dt, ` ${or??""}`)
                    }, [() => Tb(), () => Sb(), () => Pb(), () => Mb()]), q(Ye, Le)
                  };
                Se(Xe, Ye => {
                  m(v) ? Ye(Ae) : Ye(De, !1)
                }, !0)
              }
              q($e, et)
            };
          Se(we, $e => {
            m(B) ? $e(Fe) : $e(xe, !1)
          }, !0)
        }
        q(Z, Ie)
      };
    Se(oe, Z => {
      m(b) ? Z(me) : Z(_e, !1)
    })
  }
  P($), q(y, $), ii()
}
$i(["click"]);
var w4 = Xr('<svg><path d="M40-160v-160q0-34 23.5-57t56.5-23h131q20 0 38 10t29 27q29 39 71.5 61t90.5 22q49 0 91.5-22t70.5-61q13-17 30.5-27t36.5-10h131q34 0 57 23t23 57v160H640v-91q-35 25-75.5 38T480-200q-43 0-84-13.5T320-252v92H40Zm440-160q-38 0-72-17.5T351-386q-17-25-42.5-39.5T253-440q22-37 93-58.5T480-520q63 0 134 21.5t93 58.5q-29 0-55 14.5T609-386q-22 32-56 49t-73 17ZM160-440q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T280-560q0 50-34.5 85T160-440Zm640 0q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T920-560q0 50-34.5 85T800-440ZM480-560q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T600-680q0 50-34.5 85T480-560Z"></path></svg>');

function Rp(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = w4();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var T4 = he('<dialog class="modal" closedby="any"><div class="modal-box sm:h-11/12 flex max-w-3xl flex-col max-sm:size-full max-sm:rounded-none max-sm:px-3 max-sm:py-5"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2"></button></form> <div class="flex items-center gap-1.5"><!> <h3 class="text-lg font-bold max-sm:text-xl"> </h3></div> <div class="mt-1 grow"><!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function S4(y, u) {
  ri(u, !0);
  let v = rr(u, "open", 15);
  var b = T4(),
    k = I(b),
    z = D(I(k), 2),
    T = I(z);
  Rp(T, {
    class: "size-5 max-sm:size-6"
  });
  var s = D(T, 2),
    B = I(s, !0);
  P(s), P(z);
  var W = D(z, 2),
    ee = I(W);
  b4(ee, {
    get open() {
      return v()
    },
    get onhqchange() {
      return u.onhqchange
    },
    get onhqclick() {
      return u.onhqclick
    },
    get onlastpixelclick() {
      return u.onlastpixelclick
    }
  }), P(W), P(k), vi(2), P(b), Ya(b, () => $ => {
    oi(() => {
      v() ? ($.show(), ga.url.searchParams.get("alliance") && (ga.url.searchParams.delete("alliance"), mp(ga.url.toString()))) : $.close()
    })
  }), Re($ => te(B, $), [() => zp()]), Mi("close", b, () => v(!1)), pn(2, W, () => Kn, () => ({
    duration: 300
  })), q(y, b), ii()
}

function P4(y, u, v) {
  return new Promise((b, k) => {
    y.once("render", () => {
      const z = y.getCanvas().toDataURL(),
        T = document.createElement("img");
      T.src = z, T.onload = () => {
        const s = document.createElement("canvas");
        s.width = T.width, s.height = T.height;
        const B = s.getContext("2d");
        if (B) {
          B.drawImage(T, 0, 0);
          const [W, ee, $, oe] = B.getImageData(u, v, 1, 1).data;
          b([W, ee, $, oe])
        } else k(new Error("Could not get 2d context from canvas"));
        T.remove(), s.remove()
      }
    }), y.triggerRepaint()
  })
}

function wp(y, u) {
  return new Promise((v, b) => {
    y.once("render", () => {
      const k = y.getCanvas();
      let z = k;
      if (u != null && u.maxWidth || u != null && u.maxHeight) {
        const T = k.width,
          s = k.height,
          B = (u == null ? void 0 : u.maxWidth) ?? T,
          W = (u == null ? void 0 : u.maxHeight) ?? s;
        z = document.createElement("canvas");
        const ee = Math.min(B / T, W / s);
        z.width = Math.floor(T * ee), z.height = Math.floor(s * ee);
        const $ = z.getContext("2d");
        $ && $.drawImage(k, 0, 0, z.width, z.height)
      }
      try {
        z.toBlob(T => {
          T && v(T)
        }, (u == null ? void 0 : u.type) ?? "image/png", (u == null ? void 0 : u.quality) ?? 1)
      } catch (T) {
        b(T)
      } finally {
        z !== k && z.remove()
      }
    })
  })
}
var M4 = Xr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm40-80h480L570-480 450-320l-90-120-120 160Zm-40 80v-560 560Z"></path></svg>');

function I4(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = M4();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var C4 = Xr('<svg><path d="M680-80q-50 0-85-35t-35-85q0-6 3-28L282-392q-16 15-37 23.5t-45 8.5q-50 0-85-35t-35-85q0-50 35-85t85-35q24 0 45 8.5t37 23.5l281-164q-2-7-2.5-13.5T560-760q0-50 35-85t85-35q50 0 85 35t35 85q0 50-35 85t-85 35q-24 0-45-8.5T598-672L317-508q2 7 2.5 13.5t.5 14.5q0 8-.5 14.5T317-452l281 164q16-15 37-23.5t45-8.5q50 0 85 35t35 85q0 50-35 85t-85 35Z"></path></svg>');

function K0(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = C4();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
const wc = {
  hour: 3600 * 1e3,
  min: 60 * 1e3,
  sec: 1e3
};

function J0(y) {
  const u = Math.floor(y / wc.hour);
  y -= u * wc.hour;
  const v = Math.floor(y / wc.min);
  y -= v * wc.min;
  const k = Math.floor(y / wc.sec).toString().padStart(2, "0");
  return u > 0 ? `${u}:${v.toString().padStart(2,"0")}:${k}` : `${v}:${k}`
}

function A4(y) {
  const u = y.getFullYear(),
    v = String(y.getMonth() + 1).padStart(2, "0"),
    b = String(y.getDate()).padStart(2, "0"),
    k = String(y.getHours()).padStart(2, "0"),
    z = String(y.getMinutes()).padStart(2, "0"),
    T = String(y.getSeconds()).padStart(2, "0");
  return `${u}-${v}-${b} ${k}:${z}:${T}`
}
var k4 = he('<div class="text-base-content/80 mt-2 text-xs"><span class="font-semibold"> </span> </div>'),
  E4 = he('<img class="border-base-content/20 border" alt="Screenshot"/>'),
  z4 = he('<div class="flex w-full items-center justify-center"><span class="loading loading-spinner"></span></div>'),
  L4 = he('<div><h3 class="mb-1 mt-4 flex items-center gap-1 text-xl font-semibold"><!> </h3> <!> <div class="mt-3 flex items-end justify-end gap-2"><button class="btn"><!> </button> <a class="btn btn-primary"><!> </a></div></div>'),
  D4 = he('<dialog class="modal" closedby="any"><div class="modal-box max-h-11/12"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2"></button></form> <h3 class="flex items-center gap-1.5 text-xl font-bold"><!> </h3> <div class="border-base-content/20 rounded-field mt-3 flex w-full items-center gap-1 border-2 py-1.5 pl-4 pr-2.5"><input class="text-base-content/80 min-w-10 grow text-sm font-medium" readonly=""/> <div class="h-10"><button> </button></div></div> <!> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function R4(y, u) {
  ri(u, !0);
  let v = rr(u, "open", 15),
    b = Ke(!1),
    k = Ke(null),
    z = Ke("");
  const T = mt(() => {
    const Xe = new URL(u.url.toString()),
      Ae = Xe.searchParams.get("lat"),
      De = Xe.searchParams.get("lng");
    if (Ae && De) return {
      lat: parseFloat(Ae),
      lng: parseFloat(De)
    }
  });
  oi(() => {
    v() ? (u.hideHover(), setTimeout(async () => {
      wp(u.map).then(Xe => {
        H(k, Xe, !0), H(z, URL.createObjectURL(m(k)), !0)
      }).finally(() => {
        u.showHover()
      })
    }, 500)) : m(z) && (URL.revokeObjectURL(m(z)), H(k, null), H(z, ""))
  });
  var s = D4(),
    B = I(s),
    W = D(I(B), 2),
    ee = I(W);
  K0(ee, {
    class: "size-5"
  });
  var $ = D(ee);
  P(W);
  var oe = D(W, 2),
    me = I(oe);
  Xa(me);
  var _e = D(me, 2),
    Z = I(_e);
  let Ie;
  Z.__click = () => {
    navigator.clipboard.writeText(u.url.toString()), H(b, !0), setTimeout(() => {
      H(b, !1)
    }, 1e3)
  };
  var we = I(Z, !0);
  P(Z), P(_e), P(oe);
  var Fe = D(oe, 2);
  {
    var xe = Xe => {
      var Ae = k4(),
        De = I(Ae),
        Ye = I(De);
      P(De);
      var Le = D(De);
      P(Ae), Re(qe => {
        te(Ye, `${qe??""}:`), te(Le, ` ${m(T).lat??""}, ${m(T).lng??""}`)
      }, [() => h0()]), q(Xe, Ae)
    };
    Se(Fe, Xe => {
      m(T) && Xe(xe)
    })
  }
  var $e = D(Fe, 2);
  {
    var et = Xe => {
      const Ae = mt(() => {
        var Dt;
        return (Dt = u.map) == null ? void 0 : Dt.getCanvas()
      });
      var De = L4(),
        Ye = I(De),
        Le = I(Ye);
      I4(Le, {
        class: "inline size-5"
      });
      var qe = D(Le);
      P(Ye);
      var _t = D(Ye, 2);
      {
        var Qe = Dt => {
            var Rt = E4();
            Re(() => {
              Qt(Rt, "src", m(z)), Qt(Rt, "width", m(Ae).width), Qt(Rt, "height", m(Ae).height)
            }), q(Dt, Rt)
          },
          Ge = Dt => {
            var Rt = z4();
            Re(() => uo(Rt, `aspect-ratio: ${m(Ae).width/m(Ae).height}`)), q(Dt, Rt)
          };
        Se(_t, Dt => {
          m(z) ? Dt(Qe) : Dt(Ge, !1)
        })
      }
      var ft = D(_t, 2),
        Vt = I(ft);
      Vt.__click = async () => {
        m(k) && (await navigator.clipboard.write([new ClipboardItem({
          "image/png": m(k)
        })]), Nt.info(Eb()))
      };
      var Et = I(Vt);
      tg(Et, {
        class: "size-5"
      });
      var Pt = D(Et);
      P(Vt);
      var ot = D(Vt, 2),
        Ht = I(ot);
      Qm(Ht, {
        class: "size-5"
      });
      var vt = D(Ht);
      P(ot), P(ft), P(De), Re((Dt, Rt, $t, pr) => {
        te(qe, ` ${Dt??""}`), te(Pt, ` ${Rt??""}`), Qt(ot, "href", m(z)), Qt(ot, "download", `wplace_${$t??""}.png`), te(vt, ` ${pr??""}`)
      }, [() => zb(), () => nm(), () => A4(new Date).replaceAll(" ", "_").replaceAll(":", "-"), () => Lb()]), pn(2, De, () => Kn, () => ({
        duration: 300
      })), q(Xe, De)
    };
    Se($e, Xe => {
      v() && Xe(et)
    })
  }
  P(B), vi(2), P(s), Ya(s, () => Xe => {
    oi(() => {
      v() ? Xe.show() : Xe.close()
    })
  }), Re((Xe, Ae, De) => {
    te($, ` ${Xe??""}`), Vm(me, Ae), Ie = Vr(Z, 1, "btn btn-primary", null, Ie, {
      "btn-success": m(b)
    }), te(we, De)
  }, [() => kb(), () => u.url.toString(), () => m(b) ? Wm() : nm()]), Mi("close", s, () => v(!1)), q(y, s), ii()
}
$i(["click"]);
$i(["click"]);
$i(["click"]);
var F4 = Xr('<svg><path d="m576-160-56-56 104-104-104-104 56-56 104 104 104-104 56 56-104 104 104 104-56 56-104-104-104 104Zm79-360L513-662l56-56 85 85 170-170 56 57-225 226ZM80-280v-80h360v80H80Zm0-320v-80h360v80H80Z"></path></svg>');

function B4(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = F4();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var O4 = he('<li class="bg-base-200 border-base-content/10 rounded-xl border-2 p-3"> </li>'),
  j4 = he('<div><div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold"> <span class="badge badge-sm badge-error badge-soft ml-1"> </span></h3></div> <div class="text-sm sm:text-base"><ul class="my-3 flex flex-col gap-2 font-medium"></ul> <p class="text-base-content/80 mt-2 text-sm"> </p> <p class="text-base-content/80 mt-0.5 text-sm"> <a class="link" href="/terms/code-of-conduct" target="_blank"> </a>.</p></div></div>');

function Q0(y, u) {
  ri(u, !1);
  const v = [jb(), qb(), Vb(), Zb(), Nb(), Ub(), Gb()];
  Um();
  var b = j4(),
    k = I(b),
    z = I(k);
  B4(z, {
    class: "size-5"
  });
  var T = D(z, 2),
    s = I(T),
    B = D(s),
    W = I(B, !0);
  P(B), P(T), P(k);
  var ee = D(k, 2),
    $ = I(ee);
  na($, 5, () => v, Lc, (Fe, xe) => {
    var $e = O4(),
      et = I($e, !0);
    P($e), Re(() => te(et, m(xe))), q(Fe, $e)
  }), P($);
  var oe = D($, 2),
    me = I(oe, !0);
  P(oe);
  var _e = D(oe, 2),
    Z = I(_e),
    Ie = D(Z),
    we = I(Ie, !0);
  P(Ie), vi(), P(_e), P(ee), P(b), Re((Fe, xe, $e, et, Xe) => {
    te(s, `${Fe??""} `), te(W, xe), te(me, $e), te(Z, `${et??""} `), te(we, Xe)
  }, [() => Db(), () => Rb(), () => Fb(), () => Bb(), () => Ob()]), q(y, b), ii()
}
var q4 = he('<dialog class="modal" closedby="any"><div class="modal-box max-h-11/12"><section class="mb-6 flex justify-center"><h2 class="font-pixel flex flex-col justify-center"><span class="text-center text-2xl"> </span> <!></h2></section> <section class="my-2"><!></section> <form class="mt-6 flex justify-center" method="dialog"><button class="btn btn-primary sm:btn-lg"> </button></form></div></dialog>');

function V4(y, u) {
  ri(u, !0);
  let v = rr(u, "open", 15);
  var b = q4(),
    k = I(b),
    z = I(k),
    T = I(z),
    s = I(T),
    B = I(s, !0);
  P(s);
  var W = D(s, 2);
  T0(W, {
    hasText: !0,
    size: "medium"
  }), P(T), P(z);
  var ee = D(z, 2),
    $ = I(ee);
  Q0($, {}), P(ee);
  var oe = D(ee, 2),
    me = I(oe);
  me.__click = () => {
    ga.url.searchParams.delete("new-user"), mp(ga.url.toString())
  };
  var _e = I(me, !0);
  P(me), P(oe), P(k), P(b), Ya(b, () => Z => {
    oi(() => {
      v() ? Z.show() : Z.close()
    })
  }), Re((Z, Ie) => {
    te(B, Z), te(_e, Ie)
  }, [() => Wb(), () => Hb()]), Mi("close", b, () => v(!1)), q(y, b), ii()
}
$i(["click"]);

function Z4() {
  const y = navigator.userAgent,
    u = navigator.vendor;
  return /Chrome/.test(y) && /Google Inc/.test(u) ? "Chrome" : /Safari/.test(y) && /Apple Computer/.test(u) ? "Safari" : /Firefox/.test(y) ? "Firefox" : /Edge/.test(y) ? "Edge" : /Opera|OPR/.test(y) ? "Opera" : "Unknown"
}
var N4 = Xr('<svg><path d="M358.939 44C384.805 44 405.773 64.9683 405.773 90.834C405.773 116.7 384.805 137.668 358.939 137.668C335.282 137.668 315.725 120.127 312.558 97.3418C311.882 97.5076 311.068 97.7132 310.139 97.9658C307.227 98.7577 303.219 99.9781 298.844 101.688C289.898 105.186 280.227 110.425 274.75 117.568C269.021 125.042 265.37 135.158 263.158 143.737C262.067 147.97 261.355 151.71 260.917 154.385C260.789 155.166 260.687 155.855 260.604 156.437C304.314 157.147 344.347 169.064 375.81 188.514C386.896 180.117 400.712 175.135 415.691 175.135C452.208 175.135 481.811 204.738 481.811 241.254C481.81 267.527 466.485 290.221 444.287 300.885C441.861 377.201 358.696 438.508 256.456 438.508C154.451 438.508 71.4321 377.482 68.6426 301.409C45.8419 290.978 30.0001 267.967 30 241.254C30 204.738 59.6021 175.135 96.1182 175.135C111.321 175.135 125.325 180.267 136.494 188.892C167.617 169.488 207.216 157.484 250.507 156.473C250.517 156.392 250.528 156.307 250.539 156.218C250.646 155.398 250.811 154.224 251.049 152.771C251.524 149.867 252.293 145.823 253.475 141.24C255.808 132.188 259.872 120.54 266.814 111.484C274.011 102.098 285.828 96.04 295.202 92.375C299.987 90.5044 304.348 89.1775 307.514 88.3164C309.099 87.8852 310.394 87.568 311.302 87.3574C311.69 87.2673 312.009 87.1968 312.249 87.1445C314.13 63.0035 334.316 44.0001 358.939 44ZM255.905 334.922C234.07 334.922 213.107 336.328 193.621 338.913C190.267 341.144 188.408 343.008 187.698 344.95C187.085 346.63 187.361 348.283 188.093 350.118C200.137 369.374 217.021 383.431 236.377 389.255C237.939 389.694 239.551 390.118 241.216 390.527C246.165 391.641 251.258 392.225 256.456 392.225C283.556 392.224 307.779 376.436 323.849 351.639C325.103 348.78 325.526 346.501 324.943 344.546C324.28 342.322 322.364 340.66 319.327 339.067C299.52 336.385 278.166 334.922 255.905 334.922ZM167.196 240.151C148.634 240.151 133.586 257.42 133.586 278.721C133.586 300.022 148.634 317.29 167.196 317.29C185.759 317.29 200.806 300.022 200.806 278.721C200.806 257.42 185.759 240.152 167.196 240.151ZM343.512 240.151C324.949 240.152 309.901 257.42 309.901 278.721C309.901 300.022 324.949 317.29 343.512 317.29C362.074 317.29 377.122 300.022 377.122 278.721C377.122 257.42 362.074 240.151 343.512 240.151Z"></path></svg>');

function U4(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = N4();
  Lr(b, () => ({
    viewBox: "0 0 512 512",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...v
  })), q(y, b)
}
var G4 = Xr('<svg><path d="M216.856 16.597A208.502 208.502 0 0 0 164.042 0c-2.275 4.113-4.933 9.645-6.766 14.046-19.692-2.961-39.203-2.961-58.533 0-1.832-4.4-4.55-9.933-6.846-14.046a207.809 207.809 0 0 0-52.855 16.638C5.618 67.147-3.443 116.4 1.087 164.956c22.169 16.555 43.653 26.612 64.775 33.193A161.094 161.094 0 0 0 79.735 175.3a136.413 136.413 0 0 1-21.846-10.632 108.636 108.636 0 0 0 5.356-4.237c42.122 19.702 87.89 19.702 129.51 0a131.66 131.66 0 0 0 5.355 4.237 136.07 136.07 0 0 1-21.886 10.653c4.006 8.02 8.638 15.67 13.873 22.848 21.142-6.58 42.646-16.637 64.815-33.213 5.316-56.288-9.08-105.09-38.056-148.36ZM85.474 135.095c-12.645 0-23.015-11.805-23.015-26.18s10.149-26.2 23.015-26.2c12.867 0 23.236 11.804 23.015 26.2.02 14.375-10.148 26.18-23.015 26.18Zm85.051 0c-12.645 0-23.014-11.805-23.014-26.18s10.148-26.2 23.014-26.2c12.867 0 23.236 11.804 23.015 26.2 0 14.375-10.148 26.18-23.015 26.18Z"></path></svg>');

function pm(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = G4();
  Lr(b, () => ({
    viewBox: "0 0 256 199",
    width: "256",
    height: "199",
    xmlns: "http://www.w3.org/2000/svg",
    preserveAspectRatio: "xMidYMid",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var W4 = Xr('<svg><path d="M128 23.064c34.177 0 38.225.13 51.722.745 12.48.57 19.258 2.655 23.769 4.408 5.974 2.322 10.238 5.096 14.717 9.575 4.48 4.479 7.253 8.743 9.575 14.717 1.753 4.511 3.838 11.289 4.408 23.768.615 13.498.745 17.546.745 51.723 0 34.178-.13 38.226-.745 51.723-.57 12.48-2.655 19.257-4.408 23.768-2.322 5.974-5.096 10.239-9.575 14.718-4.479 4.479-8.743 7.253-14.717 9.574-4.511 1.753-11.289 3.839-23.769 4.408-13.495.616-17.543.746-51.722.746-34.18 0-38.228-.13-51.723-.746-12.48-.57-19.257-2.655-23.768-4.408-5.974-2.321-10.239-5.095-14.718-9.574-4.479-4.48-7.253-8.744-9.574-14.718-1.753-4.51-3.839-11.288-4.408-23.768-.616-13.497-.746-17.545-.746-51.723 0-34.177.13-38.225.746-51.722.57-12.48 2.655-19.258 4.408-23.769 2.321-5.974 5.095-10.238 9.574-14.717 4.48-4.48 8.744-7.253 14.718-9.575 4.51-1.753 11.288-3.838 23.768-4.408 13.497-.615 17.545-.745 51.723-.745M128 0C93.237 0 88.878.147 75.226.77c-13.625.622-22.93 2.786-31.071 5.95-8.418 3.271-15.556 7.648-22.672 14.764C14.367 28.6 9.991 35.738 6.72 44.155 3.555 52.297 1.392 61.602.77 75.226.147 88.878 0 93.237 0 128c0 34.763.147 39.122.77 52.774.622 13.625 2.785 22.93 5.95 31.071 3.27 8.417 7.647 15.556 14.763 22.672 7.116 7.116 14.254 11.492 22.672 14.763 8.142 3.165 17.446 5.328 31.07 5.95 13.653.623 18.012.77 52.775.77s39.122-.147 52.774-.77c13.624-.622 22.929-2.785 31.07-5.95 8.418-3.27 15.556-7.647 22.672-14.763 7.116-7.116 11.493-14.254 14.764-22.672 3.164-8.142 5.328-17.446 5.95-31.07.623-13.653.77-18.012.77-52.775s-.147-39.122-.77-52.774c-.622-13.624-2.786-22.929-5.95-31.07-3.271-8.418-7.648-15.556-14.764-22.672C227.4 14.368 220.262 9.99 211.845 6.72c-8.142-3.164-17.447-5.328-31.071-5.95C167.122.147 162.763 0 128 0Zm0 62.27C91.698 62.27 62.27 91.7 62.27 128c0 36.302 29.428 65.73 65.73 65.73 36.301 0 65.73-29.428 65.73-65.73 0-36.301-29.429-65.73-65.73-65.73Zm0 108.397c-23.564 0-42.667-19.103-42.667-42.667S104.436 85.333 128 85.333s42.667 19.103 42.667 42.667-19.103 42.667-42.667 42.667Zm83.686-110.994c0 8.484-6.876 15.36-15.36 15.36-8.483 0-15.36-6.876-15.36-15.36 0-8.483 6.877-15.36 15.36-15.36 8.484 0 15.36 6.877 15.36 15.36Z"></path></svg>');

function H4(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = W4();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "currentColor",
    preserveAspectRatio: "xMidYMid",
    viewBox: "0 0 260 260",
    ...v
  })), q(y, b)
}
var $4 = Xr('<svg><path d="M240-640h360v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85h-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640Zm0 480h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM240-160v-400 400Z"></path></svg>');

function Tp(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = $4();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var X4 = Xr(`<svg><path d="M12.75 2c.39 0 .708.316.75.704a5.735 5.735 0 0 0 
  4.112 4.751c.257.077.523.127.801.149.394.028.713.35.713.744v2.289a.75.75 
  0 0 1-.826.746 8.89 8.89 0 0 1-3.546-1.239v6.43a5.465 5.465 0 
  1 1-5.465-5.465c.388 0 .765.042 1.128.122a.75.75 0 0 
  1 .593.732v2.289a.75.75 0 0 1-.979.715 1.549 1.549 0 0 
  0-.482-.077 1.962 1.962 0 1 0 1.962 1.962V2.75a.75.75 0 0 1 
  .75-.75h1.239Z"></path></svg>`);

function Y4(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = X4();
  Lr(b, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-label": "Tiktok",
    ...v
  })), q(y, b)
}
var K4 = Xr(`<svg><path d="M23.498 6.186a2.986 2.986 0 0 0-2.103-2.115C19.505 
    3.5 12 3.5 12 3.5s-7.505 0-9.395.571a2.986 2.986 0 0 0-2.103 
    2.115C0 8.082 0 12 0 12s0 3.918.502 5.814a2.986 2.986 0 0 0 
    2.103 2.115C4.495 20.5 12 20.5 12 20.5s7.505 0 9.395-.571a2.986 
    2.986 0 0 0 2.103-2.115C24 15.918 24 12 24 12s0-3.918-.502-5.814zM9.75 
    15.021v-6.042L15.5 12l-5.75 3.021z"></path></svg>`);

function J4(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = K4();
  Lr(b, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-label": "YouTube",
    ...v
  })), q(y, b)
}
var Q4 = he(' <a class="link" href="https://help.constructiononline.com/en/scheduling-webgl-and-hardware-acceleration">link</a>', 1),
  eM = he('<span class="link cursor-auto">chrome://settings/system</span>.', 1),
  tM = he('<span class="link cursor-auto">edge://settings/system/manageSystem</span>.', 1),
  rM = he(' <kbd class="kbd kbd-sm h-fit px-3"> </kbd> <!>', 1),
  iM = he('<div class="flex h-full flex-col gap-5"><section class="mb-2 flex flex-col items-center justify-center gap-2"><!> <div class="text-center text-sm max-sm:mt-1"> <a class="link" href="https://maplibre.org/" target="_blank">MapLibre</a> | <a class="link" href="https://openfreemap.org/" target="_blank">OpenFreeMap</a> <a class="link" href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a></div> <div class="w-full text-center text-sm"><p><a href="https://discord.gg/wplacelive" target="_blank" class="text-nowrap"><!> <span class="link">Discord</span></a> <span class="mx-0.5">|</span> <a href="https://www.reddit.com/r/WplaceLive/" target="_blank" class="text-nowrap"><!> <span class="link">Reddit</span></a> <span class="mx-0.5">|</span> <a href="https://www.instagram.com/wplace.live/" target="_blank" class="text-nowrap"><!> <span class="link">Instagram</span></a> <span class="mx-0.5">|</span> <a href="https://www.youtube.com/@WplaceLive" target="_blank" class="text-nowrap"><!> <span class="link">Youtube</span></a> <span class="mx-0.5">|</span> <a href="https://www.tiktok.com/@wplace5" target="_blank" class="text-nowrap"><!> <span class="link">Tiktok</span></a></p></div></section> <section><h3 class="text-lg font-semibold"> </h3> <iframe class="mt-1 aspect-video w-full bg-black" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe></section> <section><h3 class="text-lg font-semibold"> </h3> <p class="not-touchscreen:hidden text-sm"> <button class="btn btn-square shadow-md"><!></button> </p> <p class="touchscreen:hidden text-sm"> <span class="kbd kbd-xs text-base-content rounded-md"> </span> </p></section> <section><h3 class="text-lg font-semibold"> </h3> <p class="text-sm"><!></p></section> <section><!></section> <div class="grow"></div> <section class="text-base-content/80 w-full text-center text-sm max-sm:pb-4"><span>Email: <a class="link" href="mailto:contact@wplace.live">contact@wplace.live</a></span>  <a class="link" target="_blank"> </a>  <a class="link" target="_blank"> </a>  <a class="link" target="_blank"> </a>  <a class="link" href="https://forms.gle/EVG7A1ZoSyJWAjX96" target="_blank"> </a>  <a class="link" href="https://forms.gle/uinGA5Gj4SpPYa2R6" target="_blank"> </a></section></div>'),
  aM = he('<dialog class="modal" closedby="any"><div class="modal-box sm:max-h-11/12 max-sm:size-full max-sm:rounded-none max-sm:px-4 sm:max-w-5xl"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2"></button></form> <!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>');

function nM(y, u) {
  ri(u, !0);
  let v = rr(u, "open", 15);
  const b = Z4();
  var k = aM(),
    z = I(k),
    T = D(I(z), 2);
  {
    var s = $ => {
      var oe = iM(),
        me = I(oe),
        _e = I(me);
      T0(_e, {
        hasText: !0,
        size: "medium"
      });
      var Z = D(_e, 2),
        Ie = I(Z),
        we = D(Ie, 4);
      vi(), P(Z);
      var Fe = D(Z, 2),
        xe = I(Fe),
        $e = I(xe),
        et = I($e);
      pm(et, {
        class: "text-base-content mr-0.5 inline size-4"
      }), vi(2), P($e);
      var Xe = D($e, 4),
        Ae = I(Xe);
      U4(Ae, {
        class: "size-4.5 mr-0.5 inline"
      }), vi(2), P(Xe);
      var De = D(Xe, 4),
        Ye = I(De);
      H4(Ye, {
        class: "mr-0.5 inline size-3.5"
      }), vi(2), P(De);
      var Le = D(De, 4),
        qe = I(Le);
      J4(qe, {
        class: "mr-0.5 inline size-3.5"
      }), vi(2), P(Le);
      var _t = D(Le, 4),
        Qe = I(_t);
      Y4(Qe, {
        class: "mr-0.5 inline size-3.5"
      }), vi(2), P(_t), P(xe), P(Fe), P(me);
      var Ge = D(me, 2),
        ft = I(Ge),
        Vt = I(ft, !0);
      P(ft);
      var Et = D(ft, 2);
      P(Ge);
      var Pt = D(Ge, 2),
        ot = I(Pt),
        Ht = I(ot, !0);
      P(ot);
      var vt = D(ot, 2),
        Dt = I(vt),
        Rt = D(Dt),
        $t = I(Rt);
      Tp($t, {
        class: "size-5"
      }), P(Rt);
      var pr = D(Rt);
      P(vt);
      var Xt = D(vt, 2),
        or = I(Xt),
        nt = D(or),
        rt = I(nt, !0);
      P(nt);
      var Zt = D(nt);
      P(Xt), P(Pt);
      var Jt = D(Pt, 2),
        Ot = I(Jt),
        mr = I(Ot, !0);
      P(Ot);
      var At = D(Ot, 2),
        Mt = I(At);
      {
        var wt = j => {
            var V = Q4(),
              X = Ct(V);
            vi(), Re(re => te(X, `${re??""}: `), [() => l2()]), q(j, V)
          },
          It = j => {
            var V = rM(),
              X = Ct(V),
              re = D(X),
              Q = I(re, !0);
            P(re);
            var ue = D(re),
              Te = D(ue);
            {
              var be = We => {
                  var Be = eM();
                  vi(), q(We, Be)
                },
                ze = We => {
                  var Be = Sr(),
                    ae = Ct(Be);
                  {
                    var J = Ve => {
                      var tt = tM();
                      vi(), q(Ve, tt)
                    };
                    Se(ae, Ve => {
                      b === "Edge" && Ve(J)
                    }, !0)
                  }
                  q(We, Be)
                };
              Se(Te, We => {
                b === "Chrome" ? We(be) : We(ze, !1)
              })
            }
            Re((We, Be, ae) => {
              te(X, `${We??""} `), te(Q, Be), te(ue, ` ${ae??""} `)
            }, [() => c2(), () => u2(), () => h2()]), q(j, V)
          };
        Se(Mt, j => {
          b !== "Chrome" && b !== "Edge" ? j(wt) : j(It, !1)
        })
      }
      P(At), P(Jt);
      var Ut = D(Jt, 2),
        ut = I(Ut);
      Q0(ut, {}), P(Ut);
      var ur = D(Ut, 4),
        br = D(I(ur), 2),
        cr = I(br, !0);
      P(br);
      var jr = D(br, 2),
        wr = I(jr, !0);
      P(jr);
      var Nr = D(jr, 2),
        Gr = I(Nr, !0);
      P(Nr);
      var er = D(Nr, 2),
        Wr = I(er, !0);
      P(er);
      var sr = D(er, 2),
        de = I(sr, !0);
      P(sr), P(ur), P(oe), Re((j, V, X, re, Q, ue, Te, be, ze, We, Be, ae, J, Ve, tt, Ze, ne) => {
        te(Ie, `${j??""} `), te(we, ` 
						${V??""} `), te(Vt, X), Qt(Et, "src", An.language === "pt" ? "https://www.youtube.com/embed/AcE85QM4iPQ?si=wbeZD8vxOzvlB_Z9" : "https://www.youtube.com/embed/xOXtd-WzRxA?si=fHz8Z6ecXGYrDhkN"), te(Ht, re), te(Dt, `${Q??""} `), te(pr, ` ${ue??""}`), te(or, `${Te??""} `), te(rt, be), te(Zt, ` ${ze??""}`), te(mr, We), Qt(br, "href", Be), te(cr, ae), Qt(jr, "href", `${ga.url.origin??""}/terms/privacy`), te(wr, J), Qt(Nr, "href", Ve), te(Gr, tt), te(Wr, Ze), te(de, ne)
      }, [() => $b(), () => Xb(), () => Yb(), () => Kb(), () => Jb(), () => Qb(), () => e2(), () => t2(), () => r2(), () => i2(), Q5, () => a2(), () => n2(), S0, () => d0(), () => s2(), () => o2()]), pn(2, oe, () => Kn, () => ({
        duration: 300
      })), q($, oe)
    };
    Se(T, $ => {
      v() && $(s)
    })
  }
  P(z);
  var B = D(z, 2),
    W = I(B),
    ee = I(W, !0);
  P(W), P(B), P(k), Ya(k, () => $ => {
    oi(() => {
      v() ? $.show() : $.close()
    })
  }), Re($ => te(ee, $), [() => co()]), Mi("close", k, () => v(!1)), q(y, k), ii()
}

function sM(y) {
  return y !== null && typeof y == "object"
}
const oM = ["string", "number", "bigint", "boolean"];

function fm(y) {
  return y == null || oM.includes(typeof y) ? !0 : Array.isArray(y) ? y.every(u => fm(u)) : typeof y == "object" ? Object.getPrototypeOf(y) === Object.prototype : !1
}
const mm = Symbol("box"),
  lM = Symbol("is-writable");

function qi(y, u) {
  const v = mt(y);
  return u ? {
    [mm]: !0,
    [lM]: !0,
    get current() {
      return m(v)
    },
    set current(b) {
      u(b)
    }
  } : {
    [mm]: !0,
    get current() {
      return y()
    }
  }
}

function cM(y) {
  return sM(y) && mm in y
}

function uM(...y) {
  return function(u) {
    var v;
    for (const b of y)
      if (b) {
        if (u.defaultPrevented) return;
        typeof b == "function" ? b.call(this, u) : (v = b.current) == null || v.call(this, u)
      }
  }
}
var Ov = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g,
  hM = /\n/g,
  dM = /^\s*/,
  pM = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/,
  fM = /^:\s*/,
  mM = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/,
  gM = /^[;\s]*/,
  _M = /^\s+|\s+$/g,
  vM = `
`,
  jv = "/",
  qv = "*",
  dl = "",
  yM = "comment",
  xM = "declaration";

function bM(y, u) {
  if (typeof y != "string") throw new TypeError("First argument must be a string");
  if (!y) return [];
  u = u || {};
  var v = 1,
    b = 1;

  function k(_e) {
    var Z = _e.match(hM);
    Z && (v += Z.length);
    var Ie = _e.lastIndexOf(vM);
    b = ~Ie ? _e.length - Ie : b + _e.length
  }

  function z() {
    var _e = {
      line: v,
      column: b
    };
    return function(Z) {
      return Z.position = new T(_e), W(), Z
    }
  }

  function T(_e) {
    this.start = _e, this.end = {
      line: v,
      column: b
    }, this.source = u.source
  }
  T.prototype.content = y;

  function s(_e) {
    var Z = new Error(u.source + ":" + v + ":" + b + ": " + _e);
    if (Z.reason = _e, Z.filename = u.source, Z.line = v, Z.column = b, Z.source = y, !u.silent) throw Z
  }

  function B(_e) {
    var Z = _e.exec(y);
    if (Z) {
      var Ie = Z[0];
      return k(Ie), y = y.slice(Ie.length), Z
    }
  }

  function W() {
    B(dM)
  }

  function ee(_e) {
    var Z;
    for (_e = _e || []; Z = $();) Z !== !1 && _e.push(Z);
    return _e
  }

  function $() {
    var _e = z();
    if (!(jv != y.charAt(0) || qv != y.charAt(1))) {
      for (var Z = 2; dl != y.charAt(Z) && (qv != y.charAt(Z) || jv != y.charAt(Z + 1));) ++Z;
      if (Z += 2, dl === y.charAt(Z - 1)) return s("End of comment missing");
      var Ie = y.slice(2, Z - 2);
      return b += 2, k(Ie), y = y.slice(Z), b += 2, _e({
        type: yM,
        comment: Ie
      })
    }
  }

  function oe() {
    var _e = z(),
      Z = B(pM);
    if (Z) {
      if ($(), !B(fM)) return s("property missing ':'");
      var Ie = B(mM),
        we = _e({
          type: xM,
          property: Vv(Z[0].replace(Ov, dl)),
          value: Ie ? Vv(Ie[0].replace(Ov, dl)) : dl
        });
      return B(gM), we
    }
  }

  function me() {
    var _e = [];
    ee(_e);
    for (var Z; Z = oe();) Z !== !1 && (_e.push(Z), ee(_e));
    return _e
  }
  return W(), me()
}

function Vv(y) {
  return y ? y.replace(_M, dl) : dl
}

function wM(y, u) {
  let v = null;
  if (!y || typeof y != "string") return v;
  const b = bM(y),
    k = typeof u == "function";
  return b.forEach(z => {
    if (z.type !== "declaration") return;
    const {
      property: T,
      value: s
    } = z;
    k ? u(T, s, z) : s && (v = v || {}, v[T] = s)
  }), v
}
const TM = /\d/,
  SM = ["-", "_", "/", "."];

function PM(y = "") {
  if (!TM.test(y)) return y !== y.toLowerCase()
}

function MM(y) {
  const u = [];
  let v = "",
    b, k;
  for (const z of y) {
    const T = SM.includes(z);
    if (T === !0) {
      u.push(v), v = "", b = void 0;
      continue
    }
    const s = PM(z);
    if (k === !1) {
      if (b === !1 && s === !0) {
        u.push(v), v = z, b = s;
        continue
      }
      if (b === !0 && s === !1 && v.length > 1) {
        const B = v.at(-1);
        u.push(v.slice(0, Math.max(0, v.length - 1))), v = B + z, b = s;
        continue
      }
    }
    v += z, b = s, k = T
  }
  return u.push(v), u
}

function ey(y) {
  return y ? MM(y).map(u => CM(u)).join("") : ""
}

function IM(y) {
  return AM(ey(y || ""))
}

function CM(y) {
  return y ? y[0].toUpperCase() + y.slice(1) : ""
}

function AM(y) {
  return y ? y[0].toLowerCase() + y.slice(1) : ""
}

function Qd(y) {
  if (!y) return {};
  const u = {};

  function v(b, k) {
    if (b.startsWith("-moz-") || b.startsWith("-webkit-") || b.startsWith("-ms-") || b.startsWith("-o-")) {
      u[ey(b)] = k;
      return
    }
    if (b.startsWith("--")) {
      u[b] = k;
      return
    }
    u[IM(b)] = k
  }
  return wM(y, v), u
}

function kM(...y) {
  return (...u) => {
    for (const v of y) typeof v == "function" && v(...u)
  }
}

function EM(y, u) {
  const v = RegExp(y, "g");
  return b => {
    if (typeof b != "string") throw new TypeError(`expected an argument of type string, but got ${typeof b}`);
    return b.match(v) ? b.replace(v, u) : b
  }
}
const zM = EM(/[A-Z]/, y => `-${y.toLowerCase()}`);

function LM(y) {
  if (!y || typeof y != "object" || Array.isArray(y)) throw new TypeError(`expected an argument of type object, but got ${typeof y}`);
  return Object.keys(y).map(u => `${zM(u)}: ${y[u]};`).join(`
`)
}

function ty(y = {}) {
  return LM(y).replace(`
`, " ")
}
const DM = ["onabort", "onanimationcancel", "onanimationend", "onanimationiteration", "onanimationstart", "onauxclick", "onbeforeinput", "onbeforetoggle", "onblur", "oncancel", "oncanplay", "oncanplaythrough", "onchange", "onclick", "onclose", "oncompositionend", "oncompositionstart", "oncompositionupdate", "oncontextlost", "oncontextmenu", "oncontextrestored", "oncopy", "oncuechange", "oncut", "ondblclick", "ondrag", "ondragend", "ondragenter", "ondragleave", "ondragover", "ondragstart", "ondrop", "ondurationchange", "onemptied", "onended", "onerror", "onfocus", "onfocusin", "onfocusout", "onformdata", "ongotpointercapture", "oninput", "oninvalid", "onkeydown", "onkeypress", "onkeyup", "onload", "onloadeddata", "onloadedmetadata", "onloadstart", "onlostpointercapture", "onmousedown", "onmouseenter", "onmouseleave", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onpaste", "onpause", "onplay", "onplaying", "onpointercancel", "onpointerdown", "onpointerenter", "onpointerleave", "onpointermove", "onpointerout", "onpointerover", "onpointerup", "onprogress", "onratechange", "onreset", "onresize", "onscroll", "onscrollend", "onsecuritypolicyviolation", "onseeked", "onseeking", "onselect", "onselectionchange", "onselectstart", "onslotchange", "onstalled", "onsubmit", "onsuspend", "ontimeupdate", "ontoggle", "ontouchcancel", "ontouchend", "ontouchmove", "ontouchstart", "ontransitioncancel", "ontransitionend", "ontransitionrun", "ontransitionstart", "onvolumechange", "onwaiting", "onwebkitanimationend", "onwebkitanimationiteration", "onwebkitanimationstart", "onwebkittransitionend", "onwheel"],
  RM = new Set(DM);

function FM(y) {
  return RM.has(y)
}

function fo(...y) {
  const u = {
    ...y[0]
  };
  for (let v = 1; v < y.length; v++) {
    const b = y[v];
    if (b) {
      for (const k of Object.keys(b)) {
        const z = u[k],
          T = b[k],
          s = typeof z == "function",
          B = typeof T == "function";
        if (s && FM(k)) {
          const W = z,
            ee = T;
          u[k] = uM(W, ee)
        } else if (s && B) u[k] = kM(z, T);
        else if (k === "class") {
          const W = fm(z),
            ee = fm(T);
          W && ee ? u[k] = rp(z, T) : W ? u[k] = rp(z) : ee && (u[k] = rp(T))
        } else if (k === "style") {
          const W = typeof z == "object",
            ee = typeof T == "object",
            $ = typeof z == "string",
            oe = typeof T == "string";
          if (W && ee) u[k] = {
            ...z,
            ...T
          };
          else if (W && oe) {
            const me = Qd(T);
            u[k] = {
              ...z,
              ...me
            }
          } else if ($ && ee) {
            const me = Qd(z);
            u[k] = {
              ...me,
              ...T
            }
          } else if ($ && oe) {
            const me = Qd(z),
              _e = Qd(T);
            u[k] = {
              ...me,
              ..._e
            }
          } else W ? u[k] = z : ee ? u[k] = T : $ ? u[k] = z : oe && (u[k] = T)
        } else u[k] = T !== void 0 ? T : z
      }
      for (const k of Object.getOwnPropertySymbols(b)) {
        const z = u[k],
          T = b[k];
        u[k] = T !== void 0 ? T : z
      }
    }
  }
  return typeof u.style == "object" && (u.style = ty(u.style).replaceAll(`
`, " ")), u.hidden === !1 && (u.hidden = void 0, delete u.hidden), u.disabled === !1 && (u.disabled = void 0, delete u.disabled), u
}
const ry = {
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  borderWidth: "0",
  transform: "translateX(-100%)"
};
ty(ry);
const BM = typeof window < "u" ? window : void 0;

function OM(y) {
  let u = y.activeElement;
  for (; u != null && u.shadowRoot;) {
    const v = u.shadowRoot.activeElement;
    if (v === u) break;
    u = v
  }
  return u
}
var Ic, rh;
class jM {
  constructor(u = {}) {
    xi(this, Ic);
    xi(this, rh);
    const {
      window: v = BM,
      document: b = v == null ? void 0 : v.document
    } = u;
    v !== void 0 && (Mn(this, Ic, b), Mn(this, rh, r0(k => {
      const z = fp(v, "focusin", k),
        T = fp(v, "focusout", k);
      return () => {
        z(), T()
      }
    })))
  }
  get current() {
    var u;
    return (u = ir(this, rh)) == null || u.call(this), ir(this, Ic) ? OM(ir(this, Ic)) : null
  }
}
Ic = new WeakMap, rh = new WeakMap;
new jM;
var ih, lo;
class ug {
  constructor(u) {
    xi(this, ih);
    xi(this, lo);
    Mn(this, ih, u), Mn(this, lo, Symbol(u))
  }
  get key() {
    return ir(this, lo)
  }
  exists() {
    return D1(ir(this, lo))
  }
  get() {
    const u = ov(ir(this, lo));
    if (u === void 0) throw new Error(`Context "${ir(this,ih)}" not found`);
    return u
  }
  getOr(u) {
    const v = ov(ir(this, lo));
    return v === void 0 ? u : v
  }
  set(u) {
    return R1(ir(this, lo), u)
  }
}
ih = new WeakMap, lo = new WeakMap;

function qM(y, u) {
  switch (y) {
    case "post":
      oi(u);
      break;
    case "pre":
      jm(u);
      break
  }
}

function iy(y, u, v, b = {}) {
  const {
    lazy: k = !1
  } = b;
  let z = !k,
    T = Array.isArray(y) ? [] : void 0;
  qM(u, () => {
    const s = Array.isArray(y) ? y.map(W => W()) : y();
    if (!z) {
      z = !0, T = s;
      return
    }
    const B = Cn(() => v(s, T));
    return T = s, B
  })
}

function zc(y, u, v) {
  iy(y, "post", u, v)
}

function VM(y, u, v) {
  iy(y, "pre", u, v)
}
zc.pre = VM;

function ZM(y, u) {
  return setTimeout(u, y)
}

function xc(y) {
  qm().then(y)
}

function mo(y, u) {
  return {
    [_3()]: v => cM(y) ? (y.current = v, Cn(() => u == null ? void 0 : u(v)), () => {
      "isConnected" in v && v.isConnected || (y.current = null, u == null || u(null))
    }) : (y(v), Cn(() => u == null ? void 0 : u(v)), () => {
      "isConnected" in v && v.isConnected || (y(null), u == null || u(null))
    })
  }
}

function gm(y) {
  return y ? "true" : "false"
}

function Zv(y) {
  return y ? "" : void 0
}
var Cc, ah;
class NM {
  constructor(u) {
    xi(this, Cc);
    xi(this, ah);
    fi(this, "attrs");
    Mn(this, Cc, u.getVariant ? u.getVariant() : null), Mn(this, ah, ir(this, Cc) ? `data-${ir(this,Cc)}-` : `data-${u.component}-`), this.getAttr = this.getAttr.bind(this), this.selector = this.selector.bind(this), this.attrs = Object.fromEntries(u.parts.map(v => [v, this.getAttr(v)]))
  }
  getAttr(u, v) {
    return v ? `data-${v}-${u}` : `${ir(this,ah)}${u}`
  }
  selector(u, v) {
    return `[${this.getAttr(u,v)}]`
  }
}
Cc = new WeakMap, ah = new WeakMap;

function UM(y) {
  const u = new NM(y);
  return {
    ...u.attrs,
    selector: u.selector,
    getAttr: u.getAttr
  }
}
const GM = "ArrowDown",
  WM = "ArrowLeft",
  HM = "ArrowRight",
  $M = "ArrowUp",
  XM = "End",
  YM = "Enter",
  KM = "Home",
  JM = "p",
  QM = "n",
  eI = "j",
  tI = "k",
  rI = "h",
  iI = "l";

function _m() {}

function go(y, u) {
  return `bits-${y}`
}

function aI(y) {
  if (!y) return null;
  for (const u of y.childNodes)
    if (u.nodeType !== Node.COMMENT_NODE) return u;
  return null
}
globalThis.bitsIdCounter ?? (globalThis.bitsIdCounter = {
  current: 0
});

function nI(y = "bits") {
  return globalThis.bitsIdCounter.current++, `${y}-${globalThis.bitsIdCounter.current}`
}

function sI(y, u) {
  let v = y.nextElementSibling;
  for (; v;) {
    if (v.matches(u)) return v;
    v = v.nextElementSibling
  }
}

function oI(y, u) {
  let v = y.previousElementSibling;
  for (; v;) {
    if (v.matches(u)) return v;
    v = v.previousElementSibling
  }
}

function ay(y) {
  if (typeof CSS < "u" && typeof CSS.escape == "function") return CSS.escape(y);
  const u = y.length;
  let v = -1,
    b, k = "";
  const z = y.charCodeAt(0);
  if (u === 1 && z === 45) return "\\" + y;
  for (; ++v < u;) {
    if (b = y.charCodeAt(v), b === 0) {
      k += "";
      continue
    }
    if (b >= 1 && b <= 31 || b === 127 || v === 0 && b >= 48 && b <= 57 || v === 1 && b >= 48 && b <= 57 && z === 45) {
      k += "\\" + b.toString(16) + " ";
      continue
    }
    if (b >= 128 || b === 45 || b === 95 || b >= 48 && b <= 57 || b >= 65 && b <= 90 || b >= 97 && b <= 122) {
      k += y.charAt(v);
      continue
    }
    k += "\\" + y.charAt(v)
  }
  return k
}
const pl = "data-value",
  Fn = UM({
    component: "command",
    parts: ["root", "list", "input", "separator", "loading", "empty", "group", "group-items", "group-heading", "item", "viewport", "input-label"]
  }),
  bc = Fn.selector("group"),
  Xf = Fn.selector("group-items"),
  Nv = Fn.selector("group-heading"),
  ny = Fn.selector("item"),
  Yf = `${Fn.selector("item")}:not([aria-disabled="true"])`,
  xl = new ug("Command.Root"),
  lI = new ug("Command.List"),
  Ku = new ug("Command.Group"),
  Uv = {
    search: "",
    value: "",
    filtered: {
      count: 0,
      items: new Map,
      groups: new Set
    }
  };
var Ac, kc, nh, sh, oh, lh, ch, uh, Ur, sy, up, ym, hp, dp, pp, Ro, oy, ly, xm, Gu, bm, wm, cy, Wu, Tm, Sm, uy, Hu, $u, hh;
const mg = class mg {
  constructor(u) {
    xi(this, Ur);
    fi(this, "opts");
    fi(this, "attachment");
    xi(this, Ac, !1);
    xi(this, kc, !0);
    fi(this, "sortAfterTick", !1);
    fi(this, "sortAndFilterAfterTick", !1);
    fi(this, "allItems", new Set);
    fi(this, "allGroups", new Map);
    fi(this, "allIds", new Map);
    xi(this, nh, Ke(0));
    xi(this, sh, Ke(null));
    xi(this, oh, Ke(null));
    xi(this, lh, Ke(null));
    xi(this, ch, Ke(Uv));
    xi(this, uh, Ke(_a(Uv)));
    xi(this, hh, mt(() => ({
      id: this.opts.id.current,
      role: "application",
      [Fn.root]: "",
      tabindex: -1,
      onkeydown: this.onkeydown,
      ...this.attachment
    })));
    this.opts = u, this.attachment = mo(this.opts.ref);
    const v = {
      ...this._commandState,
      value: this.opts.value.current ?? ""
    };
    this._commandState = v, this.commandState = v, this.onkeydown = this.onkeydown.bind(this)
  }
  static create(u) {
    return xl.set(new mg(u))
  }
  get key() {
    return m(ir(this, nh))
  }
  set key(u) {
    H(ir(this, nh), u, !0)
  }
  get viewportNode() {
    return m(ir(this, sh))
  }
  set viewportNode(u) {
    H(ir(this, sh), u, !0)
  }
  get inputNode() {
    return m(ir(this, oh))
  }
  set inputNode(u) {
    H(ir(this, oh), u, !0)
  }
  get labelNode() {
    return m(ir(this, lh))
  }
  set labelNode(u) {
    H(ir(this, lh), u, !0)
  }
  get commandState() {
    return m(ir(this, ch))
  }
  set commandState(u) {
    H(ir(this, ch), u)
  }
  get _commandState() {
    return m(ir(this, uh))
  }
  set _commandState(u) {
    H(ir(this, uh), u, !0)
  }
  setState(u, v, b) {
    Object.is(this._commandState[u], v) || (this._commandState[u] = v, u === "search" ? (ni(this, Ur, pp).call(this), ni(this, Ur, hp).call(this)) : u === "value" && (b || ni(this, Ur, oy).call(this)), ni(this, Ur, up).call(this))
  }
  setValue(u, v) {
    u !== this.opts.value.current && u === "" && xc(() => {
      this.key++
    }), this.setState("value", u, v), this.opts.value.current = u
  }
  getValidItems() {
    const u = this.opts.ref.current;
    return u ? Array.from(u.querySelectorAll(Yf)).filter(b => !!b) : []
  }
  getVisibleItems() {
    const u = this.opts.ref.current;
    return u ? Array.from(u.querySelectorAll(ny)).filter(b => !!b) : []
  }
  get itemsGrid() {
    var s, B, W, ee;
    if (!this.isGrid) return [];
    const u = this.opts.columns.current ?? 1,
      v = this.getVisibleItems(),
      b = [
        []
      ];
    let k = (s = v[0]) == null ? void 0 : s.getAttribute("data-group"),
      z = 0,
      T = 0;
    for (let $ = 0; $ < v.length; $++) {
      const oe = v[$],
        me = oe == null ? void 0 : oe.getAttribute("data-group");
      k !== me ? (k = me, z = 1, T++, b.push([{
        index: $,
        firstRowOfGroup: !0,
        ref: oe
      }])) : (z++, z > u && (T++, z = 1, b.push([])), (ee = b[T]) == null || ee.push({
        index: $,
        firstRowOfGroup: ((W = (B = b[T]) == null ? void 0 : B[0]) == null ? void 0 : W.firstRowOfGroup) ?? $ === 0,
        ref: oe
      }))
    }
    return b
  }
  updateSelectedToIndex(u) {
    const v = this.getValidItems()[u];
    v && this.setValue(v.getAttribute(pl) ?? "")
  }
  updateSelectedByItem(u) {
    const v = ni(this, Ur, Ro).call(this),
      b = this.getValidItems(),
      k = b.findIndex(T => T === v);
    let z = b[k + u];
    this.opts.loop.current && (z = k + u < 0 ? b[b.length - 1] : k + u === b.length ? b[0] : b[k + u]), z && this.setValue(z.getAttribute(pl) ?? "")
  }
  updateSelectedByGroup(u) {
    const v = ni(this, Ur, Ro).call(this);
    let b = v == null ? void 0 : v.closest(bc),
      k;
    for (; b && !k;) b = u > 0 ? sI(b, bc) : oI(b, bc), k = b == null ? void 0 : b.querySelector(Yf);
    k ? this.setValue(k.getAttribute(pl) ?? "") : this.updateSelectedByItem(u)
  }
  registerValue(u, v) {
    var b;
    return u && u === ((b = this.allIds.get(u)) == null ? void 0 : b.value) || this.allIds.set(u, {
      value: u,
      keywords: v
    }), this._commandState.filtered.items.set(u, ni(this, Ur, ym).call(this, u, v)), this.sortAfterTick || (this.sortAfterTick = !0, xc(() => {
      ni(this, Ur, hp).call(this), this.sortAfterTick = !1
    })), () => {
      this.allIds.delete(u)
    }
  }
  registerItem(u, v) {
    return this.allItems.add(u), v && (this.allGroups.has(v) ? this.allGroups.get(v).add(u) : this.allGroups.set(v, new Set([u]))), this.sortAndFilterAfterTick || (this.sortAndFilterAfterTick = !0, xc(() => {
      ni(this, Ur, pp).call(this), ni(this, Ur, hp).call(this), this.sortAndFilterAfterTick = !1
    })), ni(this, Ur, up).call(this), () => {
      const b = ni(this, Ur, Ro).call(this);
      this.allItems.delete(u), this.commandState.filtered.items.delete(u), ni(this, Ur, pp).call(this), (b == null ? void 0 : b.getAttribute("id")) === u && ni(this, Ur, dp).call(this), ni(this, Ur, up).call(this)
    }
  }
  registerGroup(u) {
    return this.allGroups.has(u) || this.allGroups.set(u, new Set), () => {
      this.allIds.delete(u), this.allGroups.delete(u)
    }
  }
  get isGrid() {
    return this.opts.columns.current !== null
  }
  onkeydown(u) {
    const v = this.opts.vimBindings.current && u.ctrlKey;
    switch (u.key) {
      case QM:
      case eI: {
        v && (this.isGrid ? ni(this, Ur, bm).call(this, u) : ni(this, Ur, Gu).call(this, u));
        break
      }
      case iI: {
        v && this.isGrid && ni(this, Ur, Gu).call(this, u);
        break
      }
      case GM:
        this.isGrid ? ni(this, Ur, bm).call(this, u) : ni(this, Ur, Gu).call(this, u);
        break;
      case HM:
        if (!this.isGrid) break;
        ni(this, Ur, Gu).call(this, u);
        break;
      case JM:
      case tI: {
        v && (this.isGrid ? ni(this, Ur, Sm).call(this, u) : ni(this, Ur, $u).call(this, u));
        break
      }
      case rI: {
        v && this.isGrid && ni(this, Ur, $u).call(this, u);
        break
      }
      case $M:
        this.isGrid ? ni(this, Ur, Sm).call(this, u) : ni(this, Ur, $u).call(this, u);
        break;
      case WM:
        if (!this.isGrid) break;
        ni(this, Ur, $u).call(this, u);
        break;
      case KM:
        u.preventDefault(), this.updateSelectedToIndex(0);
        break;
      case XM:
        u.preventDefault(), ni(this, Ur, xm).call(this);
        break;
      case YM:
        if (!u.isComposing && u.keyCode !== 229) {
          u.preventDefault();
          const b = ni(this, Ur, Ro).call(this);
          b && (b == null || b.click())
        }
    }
  }
  get props() {
    return m(ir(this, hh))
  }
  set props(u) {
    H(ir(this, hh), u)
  }
};
Ac = new WeakMap, kc = new WeakMap, nh = new WeakMap, sh = new WeakMap, oh = new WeakMap, lh = new WeakMap, ch = new WeakMap, uh = new WeakMap, Ur = new WeakSet, sy = function() {
  return g3(this._commandState)
}, up = function() {
  ir(this, Ac) || (Mn(this, Ac, !0), xc(() => {
    var b, k;
    Mn(this, Ac, !1);
    const u = ni(this, Ur, sy).call(this);
    !Object.is(this.commandState, u) && (this.commandState = u, (k = (b = this.opts.onStateChange) == null ? void 0 : b.current) == null || k.call(b, u))
  }))
}, ym = function(u, v) {
  const b = this.opts.filter.current ?? py;
  return u ? b(u, this._commandState.search, v) : 0
}, hp = function() {
  var T;
  if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
    (!this._commandState.value || !ir(this, kc)) && ni(this, Ur, dp).call(this);
    return
  }
  const u = this._commandState.filtered.items,
    v = [];
  for (const s of this._commandState.filtered.groups) {
    const B = this.allGroups.get(s);
    let W = 0;
    if (!B) {
      v.push([s, W]);
      continue
    }
    for (const ee of B) {
      const $ = u.get(ee);
      W = Math.max($ ?? 0, W)
    }
    v.push([s, W])
  }
  const b = this.viewportNode,
    k = this.getValidItems().sort((s, B) => {
      const W = s.getAttribute("data-value"),
        ee = B.getAttribute("data-value"),
        $ = u.get(W) ?? 0;
      return (u.get(ee) ?? 0) - $
    });
  for (const s of k) {
    const B = s.closest(Xf);
    if (B) {
      const W = s.parentElement === B ? s : s.closest(`${Xf} > *`);
      W && B.appendChild(W)
    } else {
      const W = s.parentElement === b ? s : s.closest(`${Xf} > *`);
      W && (b == null || b.appendChild(W))
    }
  }
  const z = v.sort((s, B) => B[1] - s[1]);
  for (const s of z) {
    const B = b == null ? void 0 : b.querySelector(`${bc}[${pl}="${ay(s[0])}"]`);
    (T = B == null ? void 0 : B.parentElement) == null || T.appendChild(B)
  }
  ni(this, Ur, dp).call(this)
}, dp = function() {
  xc(() => {
    const u = this.getValidItems().find(k => k.getAttribute("aria-disabled") !== "true"),
      v = u == null ? void 0 : u.getAttribute(pl),
      b = ir(this, kc) && this.opts.disableInitialScroll.current;
    this.setValue(v ?? "", b), Mn(this, kc, !1)
  })
}, pp = function() {
  var v, b;
  if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
    this._commandState.filtered.count = this.allItems.size;
    return
  }
  this._commandState.filtered.groups = new Set;
  let u = 0;
  for (const k of this.allItems) {
    const z = ((v = this.allIds.get(k)) == null ? void 0 : v.value) ?? "",
      T = ((b = this.allIds.get(k)) == null ? void 0 : b.keywords) ?? [],
      s = ni(this, Ur, ym).call(this, z, T);
    this._commandState.filtered.items.set(k, s), s > 0 && u++
  }
  for (const [k, z] of this.allGroups)
    for (const T of z) {
      const s = this._commandState.filtered.items.get(T);
      if (s && s > 0) {
        this._commandState.filtered.groups.add(k);
        break
      }
    }
  this._commandState.filtered.count = u
}, Ro = function() {
  const u = this.opts.ref.current;
  if (!u) return;
  const v = u.querySelector(`${Yf}[data-selected]`);
  if (v) return v
}, oy = function() {
  xc(() => {
    var b, k, z, T, s;
    const u = ni(this, Ur, Ro).call(this);
    if (!u) return;
    const v = (b = u.parentElement) == null ? void 0 : b.parentElement;
    if (v) {
      if (this.isGrid) {
        const B = ni(this, Ur, ly).call(this, u);
        if (u.scrollIntoView({
            block: "nearest"
          }), B) {
          const W = (k = u == null ? void 0 : u.closest(bc)) == null ? void 0 : k.querySelector(Nv);
          W == null || W.scrollIntoView({
            block: "nearest"
          });
          return
        }
      } else {
        const B = aI(v);
        if (B && ((z = B.dataset) == null ? void 0 : z.value) === ((T = u.dataset) == null ? void 0 : T.value)) {
          const W = (s = u == null ? void 0 : u.closest(bc)) == null ? void 0 : s.querySelector(Nv);
          W == null || W.scrollIntoView({
            block: "nearest"
          });
          return
        }
      }
      u.scrollIntoView({
        block: "nearest"
      })
    }
  })
}, ly = function(u) {
  const v = this.itemsGrid;
  if (v.length === 0) return !1;
  for (let b = 0; b < v.length; b++) {
    const k = v[b];
    if (k !== void 0)
      for (let z = 0; z < k.length; z++) {
        const T = k[z];
        if (!(T === void 0 || T.ref !== u)) return T.firstRowOfGroup
      }
  }
  return !1
}, xm = function() {
  return this.updateSelectedToIndex(this.getValidItems().length - 1)
}, Gu = function(u) {
  u.preventDefault(), u.metaKey ? ni(this, Ur, xm).call(this) : u.altKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(1)
}, bm = function(u) {
  this.opts.columns.current !== null && (u.preventDefault(), u.metaKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(ni(this, Ur, cy).call(this, u)))
}, wm = function(u, v) {
  if (v.length === 0) return null;
  for (let b = 0; b < v.length; b++) {
    const k = v[b];
    if (k !== void 0)
      for (let z = 0; z < k.length; z++) {
        const T = k[z];
        if (!(T === void 0 || T.ref !== u)) return {
          columnIndex: z,
          rowIndex: b
        }
      }
  }
  return null
}, cy = function(u) {
  const v = this.itemsGrid,
    b = ni(this, Ur, Ro).call(this);
  if (!b) return 0;
  const k = ni(this, Ur, wm).call(this, b, v);
  if (!k) return 0;
  let z = null;
  const T = u.altKey ? 1 : 0;
  if (u.altKey && k.rowIndex === v.length - 2 && !this.opts.loop.current) z = ni(this, Ur, Wu).call(this, {
    start: v.length - 1,
    end: v.length,
    expectedColumnIndex: k.columnIndex,
    grid: v
  });
  else if (k.rowIndex === v.length - 1) {
    if (!this.opts.loop.current) return 0;
    z = ni(this, Ur, Wu).call(this, {
      start: 0 + T,
      end: k.rowIndex,
      expectedColumnIndex: k.columnIndex,
      grid: v
    })
  } else z = ni(this, Ur, Wu).call(this, {
    start: k.rowIndex + 1 + T,
    end: v.length,
    expectedColumnIndex: k.columnIndex,
    grid: v
  }), z === null && this.opts.loop.current && (z = ni(this, Ur, Wu).call(this, {
    start: 0,
    end: k.rowIndex,
    expectedColumnIndex: k.columnIndex,
    grid: v
  }));
  return ni(this, Ur, Tm).call(this, b, z)
}, Wu = function({
  start: u,
  end: v,
  grid: b,
  expectedColumnIndex: k
}) {
  var T;
  let z = null;
  for (let s = u; s < v; s++) {
    const B = b[s];
    if (z = ((T = B[k]) == null ? void 0 : T.ref) ?? null, z !== null && ep(z)) {
      z = null;
      continue
    }
    if (z === null)
      for (let W = B.length - 1; W >= 0; W--) {
        const ee = B[B.length - 1];
        if (!(ee === void 0 || ep(ee.ref))) {
          z = ee.ref;
          break
        }
      }
    break
  }
  return z
}, Tm = function(u, v) {
  if (v === null) return 0;
  const b = this.getValidItems(),
    k = b.findIndex(T => T === u);
  return b.findIndex(T => T === v) - k
}, Sm = function(u) {
  this.opts.columns.current !== null && (u.preventDefault(), u.metaKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(ni(this, Ur, uy).call(this, u)))
}, uy = function(u) {
  const v = this.itemsGrid,
    b = ni(this, Ur, Ro).call(this);
  if (b === void 0) return 0;
  const k = ni(this, Ur, wm).call(this, b, v);
  if (k === null) return 0;
  let z = null;
  const T = u.altKey ? 1 : 0;
  if (u.altKey && k.rowIndex === 1 && this.opts.loop.current === !1) z = ni(this, Ur, Hu).call(this, {
    start: 0,
    end: 0,
    expectedColumnIndex: k.columnIndex,
    grid: v
  });
  else if (k.rowIndex === 0) {
    if (this.opts.loop.current === !1) return 0;
    z = ni(this, Ur, Hu).call(this, {
      start: v.length - 1 - T,
      end: k.rowIndex + 1,
      expectedColumnIndex: k.columnIndex,
      grid: v
    })
  } else z = ni(this, Ur, Hu).call(this, {
    start: k.rowIndex - 1 - T,
    end: 0,
    expectedColumnIndex: k.columnIndex,
    grid: v
  }), z === null && this.opts.loop.current && (z = ni(this, Ur, Hu).call(this, {
    start: v.length - 1,
    end: k.rowIndex + 1,
    expectedColumnIndex: k.columnIndex,
    grid: v
  }));
  return ni(this, Ur, Tm).call(this, b, z)
}, Hu = function({
  start: u,
  end: v,
  grid: b,
  expectedColumnIndex: k
}) {
  var T;
  let z = null;
  for (let s = u; s >= v; s--) {
    const B = b[s];
    if (B !== void 0) {
      if (z = ((T = B[k]) == null ? void 0 : T.ref) ?? null, z !== null && ep(z)) {
        z = null;
        continue
      }
      if (z === null)
        for (let W = B.length - 1; W >= 0; W--) {
          const ee = B[B.length - 1];
          if (!(ee === void 0 || ep(ee.ref))) {
            z = ee.ref;
            break
          }
        }
      break
    }
  }
  return z
}, $u = function(u) {
  u.preventDefault(), u.metaKey ? this.updateSelectedToIndex(0) : u.altKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(-1)
}, hh = new WeakMap;
let vm = mg;

function ep(y) {
  return y.getAttribute("aria-disabled") === "true"
}
var dh, ph, fh;
const gg = class gg {
  constructor(u, v) {
    fi(this, "opts");
    fi(this, "root");
    fi(this, "attachment");
    xi(this, dh, mt(() => this.root._commandState.filtered.count === 0 && ir(this, ph) === !1 || this.opts.forceMount.current));
    xi(this, ph, !0);
    xi(this, fh, mt(() => ({
      id: this.opts.id.current,
      role: "presentation",
      [Fn.empty]: "",
      ...this.attachment
    })));
    this.opts = u, this.root = v, this.attachment = mo(this.opts.ref), jm(() => {
      Mn(this, ph, !1)
    })
  }
  static create(u) {
    return new gg(u, xl.get())
  }
  get shouldRender() {
    return m(ir(this, dh))
  }
  set shouldRender(u) {
    H(ir(this, dh), u)
  }
  get props() {
    return m(ir(this, fh))
  }
  set props(u) {
    H(ir(this, fh), u)
  }
};
dh = new WeakMap, ph = new WeakMap, fh = new WeakMap;
let Pm = gg;
var mh, gh, _h, vh;
const _g = class _g {
  constructor(u, v) {
    fi(this, "opts");
    fi(this, "root");
    fi(this, "attachment");
    xi(this, mh, mt(() => this.opts.forceMount.current || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search ? !0 : this.root._commandState.filtered.groups.has(this.trueValue)));
    xi(this, gh, Ke(null));
    xi(this, _h, Ke(""));
    xi(this, vh, mt(() => ({
      id: this.opts.id.current,
      role: "presentation",
      hidden: this.shouldRender ? void 0 : !0,
      "data-value": this.trueValue,
      [Fn.group]: "",
      ...this.attachment
    })));
    this.opts = u, this.root = v, this.attachment = mo(this.opts.ref), this.trueValue = u.value.current ?? u.id.current, zc(() => this.trueValue, () => this.root.registerGroup(this.trueValue)), oi(() => this.opts.value.current ? (this.trueValue = this.opts.value.current, this.root.registerValue(this.opts.value.current)) : this.headingNode && this.headingNode.textContent ? (this.trueValue = this.headingNode.textContent.trim().toLowerCase(), this.root.registerValue(this.trueValue)) : (this.trueValue = `-----${this.opts.id.current}`, this.root.registerValue(this.trueValue)))
  }
  static create(u) {
    return Ku.set(new _g(u, xl.get()))
  }
  get shouldRender() {
    return m(ir(this, mh))
  }
  set shouldRender(u) {
    H(ir(this, mh), u)
  }
  get headingNode() {
    return m(ir(this, gh))
  }
  set headingNode(u) {
    H(ir(this, gh), u, !0)
  }
  get trueValue() {
    return m(ir(this, _h))
  }
  set trueValue(u) {
    H(ir(this, _h), u, !0)
  }
  get props() {
    return m(ir(this, vh))
  }
  set props(u) {
    H(ir(this, vh), u)
  }
};
mh = new WeakMap, gh = new WeakMap, _h = new WeakMap, vh = new WeakMap;
let Mm = _g;
var yh;
const vg = class vg {
  constructor(u, v) {
    fi(this, "opts");
    fi(this, "group");
    fi(this, "attachment");
    xi(this, yh, mt(() => ({
      id: this.opts.id.current,
      [Fn["group-heading"]]: "",
      ...this.attachment
    })));
    this.opts = u, this.group = v, this.attachment = mo(this.opts.ref, b => this.group.headingNode = b)
  }
  static create(u) {
    return new vg(u, Ku.get())
  }
  get props() {
    return m(ir(this, yh))
  }
  set props(u) {
    H(ir(this, yh), u)
  }
};
yh = new WeakMap;
let Im = vg;
var xh;
const yg = class yg {
  constructor(u, v) {
    fi(this, "opts");
    fi(this, "group");
    fi(this, "attachment");
    xi(this, xh, mt(() => {
      var u;
      return {
        id: this.opts.id.current,
        role: "group",
        [Fn["group-items"]]: "",
        "aria-labelledby": ((u = this.group.headingNode) == null ? void 0 : u.id) ?? void 0,
        ...this.attachment
      }
    }));
    this.opts = u, this.group = v, this.attachment = mo(this.opts.ref)
  }
  static create(u) {
    return new yg(u, Ku.get())
  }
  get props() {
    return m(ir(this, xh))
  }
  set props(u) {
    H(ir(this, xh), u)
  }
};
xh = new WeakMap;
let Cm = yg;
var Pp, bh;
const xg = class xg {
  constructor(u, v) {
    fi(this, "opts");
    fi(this, "root");
    fi(this, "attachment");
    xi(this, Pp, mt(() => {
      var v;
      const u = (v = this.root.viewportNode) == null ? void 0 : v.querySelector(`${ny}[${pl}="${ay(this.root.opts.value.current)}"]`);
      if (u != null) return u.getAttribute("id") ?? void 0
    }));
    xi(this, bh, mt(() => {
      var u, v;
      return {
        id: this.opts.id.current,
        type: "text",
        [Fn.input]: "",
        autocomplete: "off",
        autocorrect: "off",
        spellcheck: !1,
        "aria-autocomplete": "list",
        role: "combobox",
        "aria-expanded": gm(!0),
        "aria-controls": ((u = this.root.viewportNode) == null ? void 0 : u.id) ?? void 0,
        "aria-labelledby": ((v = this.root.labelNode) == null ? void 0 : v.id) ?? void 0,
        "aria-activedescendant": m(ir(this, Pp)),
        ...this.attachment
      }
    }));
    this.opts = u, this.root = v, this.attachment = mo(this.opts.ref, b => this.root.inputNode = b), zc(() => this.opts.ref.current, () => {
      const b = this.opts.ref.current;
      b && this.opts.autofocus.current && ZM(10, () => b.focus())
    }), zc(() => this.opts.value.current, () => {
      this.root.commandState.search !== this.opts.value.current && this.root.setState("search", this.opts.value.current)
    })
  }
  static create(u) {
    return new xg(u, xl.get())
  }
  get props() {
    return m(ir(this, bh))
  }
  set props(u) {
    H(ir(this, bh), u)
  }
};
Pp = new WeakMap, bh = new WeakMap;
let Am = xg;
var Bo, Mp, wh, Th, Sh, _l, hy, Em, Ph;
const bg = class bg {
  constructor(u, v) {
    xi(this, _l);
    fi(this, "opts");
    fi(this, "root");
    fi(this, "attachment");
    xi(this, Bo, null);
    xi(this, Mp, mt(() => {
      var u;
      return this.opts.forceMount.current || ((u = ir(this, Bo)) == null ? void 0 : u.opts.forceMount.current) === !0
    }));
    xi(this, wh, mt(() => {
      if (this.opts.ref.current, m(ir(this, Mp)) || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search) return !0;
      const u = this.root.commandState.filtered.items.get(this.trueValue);
      return u === void 0 ? !1 : u > 0
    }));
    xi(this, Th, mt(() => this.root.opts.value.current === this.trueValue && this.trueValue !== ""));
    xi(this, Sh, Ke(""));
    xi(this, Ph, mt(() => {
      var u;
      return {
        id: this.opts.id.current,
        "aria-disabled": gm(this.opts.disabled.current),
        "aria-selected": gm(this.isSelected),
        "data-disabled": Zv(this.opts.disabled.current),
        "data-selected": Zv(this.isSelected),
        "data-value": this.trueValue,
        "data-group": (u = ir(this, Bo)) == null ? void 0 : u.trueValue,
        [Fn.item]: "",
        role: "option",
        onpointermove: this.onpointermove,
        onclick: this.onclick,
        ...this.attachment
      }
    }));
    this.opts = u, this.root = v, Mn(this, Bo, Ku.getOr(null)), this.trueValue = u.value.current, this.attachment = mo(this.opts.ref), zc([() => this.trueValue, () => {
      var b;
      return (b = ir(this, Bo)) == null ? void 0 : b.trueValue
    }, () => this.opts.forceMount.current], () => {
      var b;
      if (!(this.opts.forceMount.current || !this.trueValue)) return this.root.registerItem(this.trueValue, (b = ir(this, Bo)) == null ? void 0 : b.trueValue)
    }), zc([() => this.opts.value.current, () => this.opts.ref.current], () => {
      var b, k;
      this.opts.value.current ? this.trueValue = this.opts.value.current : (b = this.opts.ref.current) != null && b.textContent && (this.trueValue = this.opts.ref.current.textContent.trim()), this.trueValue && (this.root.registerValue(this.trueValue, u.keywords.current.map(z => z.trim())), (k = this.opts.ref.current) == null || k.setAttribute(pl, this.trueValue))
    }), this.onclick = this.onclick.bind(this), this.onpointermove = this.onpointermove.bind(this)
  }
  static create(u) {
    const v = Ku.getOr(null);
    return new bg({
      ...u,
      group: v
    }, xl.get())
  }
  get shouldRender() {
    return m(ir(this, wh))
  }
  set shouldRender(u) {
    H(ir(this, wh), u)
  }
  get isSelected() {
    return m(ir(this, Th))
  }
  set isSelected(u) {
    H(ir(this, Th), u)
  }
  get trueValue() {
    return m(ir(this, Sh))
  }
  set trueValue(u) {
    H(ir(this, Sh), u, !0)
  }
  onpointermove(u) {
    this.opts.disabled.current || this.root.opts.disablePointerSelection.current || ni(this, _l, Em).call(this)
  }
  onclick(u) {
    this.opts.disabled.current || ni(this, _l, hy).call(this)
  }
  get props() {
    return m(ir(this, Ph))
  }
  set props(u) {
    H(ir(this, Ph), u)
  }
};
Bo = new WeakMap, Mp = new WeakMap, wh = new WeakMap, Th = new WeakMap, Sh = new WeakMap, _l = new WeakSet, hy = function() {
  var u;
  this.opts.disabled.current || (ni(this, _l, Em).call(this), (u = this.opts.onSelect) == null || u.current())
}, Em = function() {
  this.opts.disabled.current || this.root.setValue(this.trueValue, !0)
}, Ph = new WeakMap;
let km = bg;
var Mh;
const wg = class wg {
  constructor(u, v) {
    fi(this, "opts");
    fi(this, "root");
    fi(this, "attachment");
    xi(this, Mh, mt(() => ({
      id: this.opts.id.current,
      role: "listbox",
      "aria-label": this.opts.ariaLabel.current,
      [Fn.list]: "",
      ...this.attachment
    })));
    this.opts = u, this.root = v, this.attachment = mo(this.opts.ref)
  }
  static create(u) {
    return lI.set(new wg(u, xl.get()))
  }
  get props() {
    return m(ir(this, Mh))
  }
  set props(u) {
    H(ir(this, Mh), u)
  }
};
Mh = new WeakMap;
let zm = wg;
var Ih;
const Tg = class Tg {
  constructor(u, v) {
    fi(this, "opts");
    fi(this, "root");
    fi(this, "attachment");
    xi(this, Ih, mt(() => {
      var u;
      return {
        id: this.opts.id.current,
        [Fn["input-label"]]: "",
        for: (u = this.opts.for) == null ? void 0 : u.current,
        style: ry,
        ...this.attachment
      }
    }));
    this.opts = u, this.root = v, this.attachment = mo(this.opts.ref, b => this.root.labelNode = b)
  }
  static create(u) {
    return new Tg(u, xl.get())
  }
  get props() {
    return m(ir(this, Ih))
  }
  set props(u) {
    H(ir(this, Ih), u)
  }
};
Ih = new WeakMap;
let Lm = Tg;
var cI = he("<label><!></label>");

function uI(y, u) {
  const v = po();
  ri(u, !0);
  let b = rr(u, "id", 19, () => go(v)),
    k = rr(u, "ref", 15, null),
    z = Er(u, ["$$slots", "$$events", "$$legacy", "id", "ref", "children"]);
  const T = Lm.create({
      id: qi(() => b()),
      ref: qi(() => k(), ee => k(ee))
    }),
    s = mt(() => fo(z, T.props));
  var B = cI();
  Lr(B, () => ({
    ...m(s)
  }));
  var W = I(B);
  Oa(W, () => u.children ?? Jn), P(B), q(y, B), ii()
}
var hI = he("<!> <!>", 1),
  dI = he("<div><!> <!></div>");

function pI(y, u) {
  const v = po();
  ri(u, !0);
  const b = Qe => {
    uI(Qe, {
      children: (Ge, ft) => {
        vi();
        var Vt = Ba();
        Re(() => te(Vt, oe())), q(Ge, Vt)
      },
      $$slots: {
        default: !0
      }
    })
  };
  let k = rr(u, "id", 19, () => go(v)),
    z = rr(u, "ref", 15, null),
    T = rr(u, "value", 15, ""),
    s = rr(u, "onValueChange", 3, _m),
    B = rr(u, "onStateChange", 3, _m),
    W = rr(u, "loop", 3, !1),
    ee = rr(u, "shouldFilter", 3, !0),
    $ = rr(u, "filter", 3, py),
    oe = rr(u, "label", 3, ""),
    me = rr(u, "vimBindings", 3, !0),
    _e = rr(u, "disablePointerSelection", 3, !1),
    Z = rr(u, "disableInitialScroll", 3, !1),
    Ie = rr(u, "columns", 3, null),
    we = Er(u, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "onValueChange", "onStateChange", "loop", "shouldFilter", "filter", "label", "vimBindings", "disablePointerSelection", "disableInitialScroll", "columns", "children", "child"]);
  const Fe = vm.create({
      id: qi(() => k()),
      ref: qi(() => z(), Qe => z(Qe)),
      filter: qi(() => $()),
      shouldFilter: qi(() => ee()),
      loop: qi(() => W()),
      value: qi(() => T(), Qe => {
        T() !== Qe && (T(Qe), s()(Qe))
      }),
      vimBindings: qi(() => me()),
      disablePointerSelection: qi(() => _e()),
      disableInitialScroll: qi(() => Z()),
      onStateChange: qi(() => B()),
      columns: qi(() => Ie())
    }),
    xe = Qe => Fe.updateSelectedToIndex(Qe),
    $e = Qe => Fe.updateSelectedByGroup(Qe),
    et = Qe => Fe.updateSelectedByItem(Qe),
    Xe = () => Fe.getValidItems(),
    Ae = mt(() => fo(we, Fe.props));
  var De = {
      updateSelectedToIndex: xe,
      updateSelectedByGroup: $e,
      updateSelectedByItem: et,
      getValidItems: Xe
    },
    Ye = Sr(),
    Le = Ct(Ye);
  {
    var qe = Qe => {
        var Ge = hI(),
          ft = Ct(Ge);
        b(ft);
        var Vt = D(ft, 2);
        Oa(Vt, () => u.child, () => ({
          props: m(Ae)
        })), q(Qe, Ge)
      },
      _t = Qe => {
        var Ge = dI();
        Lr(Ge, () => ({
          ...m(Ae)
        }));
        var ft = I(Ge);
        b(ft);
        var Vt = D(ft, 2);
        Oa(Vt, () => u.children ?? Jn), P(Ge), q(Qe, Ge)
      };
    Se(Le, Qe => {
      u.child ? Qe(qe) : Qe(_t, !1)
    })
  }
  return q(y, Ye), ii(De)
}
var fI = he("<div><!></div>");

function mI(y, u) {
  const v = po();
  ri(u, !0);
  let b = rr(u, "id", 19, () => go(v)),
    k = rr(u, "ref", 15, null),
    z = rr(u, "forceMount", 3, !1),
    T = Er(u, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child", "forceMount"]);
  const s = Pm.create({
      id: qi(() => b()),
      ref: qi(() => k(), oe => k(oe)),
      forceMount: qi(() => z())
    }),
    B = mt(() => fo(s.props, T));
  var W = Sr(),
    ee = Ct(W);
  {
    var $ = oe => {
      var me = Sr(),
        _e = Ct(me);
      {
        var Z = we => {
            var Fe = Sr(),
              xe = Ct(Fe);
            Oa(xe, () => u.child, () => ({
              props: m(B)
            })), q(we, Fe)
          },
          Ie = we => {
            var Fe = fI();
            Lr(Fe, () => ({
              ...m(B)
            }));
            var xe = I(Fe);
            Oa(xe, () => u.children ?? Jn), P(Fe), q(we, Fe)
          };
        Se(_e, we => {
          u.child ? we(Z) : we(Ie, !1)
        })
      }
      q(oe, me)
    };
    Se(ee, oe => {
      s.shouldRender && oe($)
    })
  }
  q(y, W), ii()
}
var gI = he("<div><!></div>");

function _I(y, u) {
  const v = po();
  ri(u, !0);
  let b = rr(u, "id", 19, () => go(v)),
    k = rr(u, "ref", 15, null),
    z = rr(u, "value", 3, ""),
    T = rr(u, "forceMount", 3, !1),
    s = Er(u, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "forceMount", "children", "child"]);
  const B = Mm.create({
      id: qi(() => b()),
      ref: qi(() => k(), _e => k(_e)),
      forceMount: qi(() => T()),
      value: qi(() => z())
    }),
    W = mt(() => fo(s, B.props));
  var ee = Sr(),
    $ = Ct(ee);
  {
    var oe = _e => {
        var Z = Sr(),
          Ie = Ct(Z);
        Oa(Ie, () => u.child, () => ({
          props: m(W)
        })), q(_e, Z)
      },
      me = _e => {
        var Z = gI();
        Lr(Z, () => ({
          ...m(W)
        }));
        var Ie = I(Z);
        Oa(Ie, () => u.children ?? Jn), P(Z), q(_e, Z)
      };
    Se($, _e => {
      u.child ? _e(oe) : _e(me, !1)
    })
  }
  q(y, ee), ii()
}
var vI = he("<div><!></div>");

function yI(y, u) {
  const v = po();
  ri(u, !0);
  let b = rr(u, "id", 19, () => go(v)),
    k = rr(u, "ref", 15, null),
    z = Er(u, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child"]);
  const T = Im.create({
      id: qi(() => b()),
      ref: qi(() => k(), oe => k(oe))
    }),
    s = mt(() => fo(z, T.props));
  var B = Sr(),
    W = Ct(B);
  {
    var ee = oe => {
        var me = Sr(),
          _e = Ct(me);
        Oa(_e, () => u.child, () => ({
          props: m(s)
        })), q(oe, me)
      },
      $ = oe => {
        var me = vI();
        Lr(me, () => ({
          ...m(s)
        }));
        var _e = I(me);
        Oa(_e, () => u.children ?? Jn), P(me), q(oe, me)
      };
    Se(W, oe => {
      u.child ? oe(ee) : oe($, !1)
    })
  }
  q(y, B), ii()
}
var xI = he("<div><!></div>"),
  bI = he('<div style="display: contents;"><!></div>');

function wI(y, u) {
  const v = po();
  ri(u, !0);
  let b = rr(u, "id", 19, () => go(v)),
    k = rr(u, "ref", 15, null),
    z = Er(u, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child"]);
  const T = Cm.create({
      id: qi(() => b()),
      ref: qi(() => k(), oe => k(oe))
    }),
    s = mt(() => fo(z, T.props));
  var B = bI(),
    W = I(B);
  {
    var ee = oe => {
        var me = Sr(),
          _e = Ct(me);
        Oa(_e, () => u.child, () => ({
          props: m(s)
        })), q(oe, me)
      },
      $ = oe => {
        var me = xI();
        Lr(me, () => ({
          ...m(s)
        }));
        var _e = I(me);
        Oa(_e, () => u.children ?? Jn), P(me), q(oe, me)
      };
    Se(W, oe => {
      u.child ? oe(ee) : oe($, !1)
    })
  }
  P(B), q(y, B), ii()
}
var TI = he("<input/>");

function SI(y, u) {
  const v = po();
  ri(u, !0);
  let b = rr(u, "value", 15, ""),
    k = rr(u, "autofocus", 3, !1),
    z = rr(u, "id", 19, () => go(v)),
    T = rr(u, "ref", 15, null),
    s = Er(u, ["$$slots", "$$events", "$$legacy", "value", "autofocus", "id", "ref", "child"]);
  const B = Am.create({
      id: qi(() => z()),
      ref: qi(() => T(), _e => T(_e)),
      value: qi(() => b(), _e => {
        b(_e)
      }),
      autofocus: qi(() => k() ?? !1)
    }),
    W = mt(() => fo(s, B.props));
  var ee = Sr(),
    $ = Ct(ee);
  {
    var oe = _e => {
        var Z = Sr(),
          Ie = Ct(Z);
        Oa(Ie, () => u.child, () => ({
          props: m(W)
        })), q(_e, Z)
      },
      me = _e => {
        var Z = TI();
        Lr(Z, () => ({
          ...m(W)
        }), void 0, void 0, void 0, void 0, !0), vl(Z, b), q(_e, Z)
      };
    Se($, _e => {
      u.child ? _e(oe) : _e(me, !1)
    })
  }
  q(y, ee), ii()
}
var PI = he("<div><!></div>"),
  MI = he('<div style="display: contents;" data-item-wrapper=""><!></div>');

function II(y, u) {
  const v = po();
  ri(u, !0);
  let b = rr(u, "id", 19, () => go(v)),
    k = rr(u, "ref", 15, null),
    z = rr(u, "value", 3, ""),
    T = rr(u, "disabled", 3, !1),
    s = rr(u, "onSelect", 3, _m),
    B = rr(u, "forceMount", 3, !1),
    W = rr(u, "keywords", 19, () => []),
    ee = Er(u, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "disabled", "children", "child", "onSelect", "forceMount", "keywords"]);
  const $ = km.create({
      id: qi(() => b()),
      ref: qi(() => k(), Z => k(Z)),
      value: qi(() => z()),
      disabled: qi(() => T()),
      onSelect: qi(() => s()),
      forceMount: qi(() => B()),
      keywords: qi(() => W())
    }),
    oe = mt(() => fo(ee, $.props));
  var me = Sr(),
    _e = Ct(me);
  Ec(_e, () => $.root.key, Z => {
    var Ie = MI(),
      we = I(Ie);
    {
      var Fe = xe => {
        var $e = Sr(),
          et = Ct($e);
        {
          var Xe = De => {
              var Ye = Sr(),
                Le = Ct(Ye);
              Oa(Le, () => u.child, () => ({
                props: m(oe)
              })), q(De, Ye)
            },
            Ae = De => {
              var Ye = PI();
              Lr(Ye, () => ({
                ...m(oe)
              }));
              var Le = I(Ye);
              Oa(Le, () => u.children ?? Jn), P(Ye), q(De, Ye)
            };
          Se(et, De => {
            u.child ? De(Xe) : De(Ae, !1)
          })
        }
        q(xe, $e)
      };
      Se(we, xe => {
        $.shouldRender && xe(Fe)
      })
    }
    P(Ie), Re(() => Qt(Ie, "data-value", $.trueValue)), q(Z, Ie)
  }), q(y, me), ii()
}
var CI = he("<div><!></div>");

function AI(y, u) {
  const v = po();
  ri(u, !0);
  let b = rr(u, "id", 19, () => go(v)),
    k = rr(u, "ref", 15, null),
    z = Er(u, ["$$slots", "$$events", "$$legacy", "id", "ref", "child", "children", "aria-label"]);
  const T = zm.create({
      id: qi(() => b()),
      ref: qi(() => k(), ee => k(ee)),
      ariaLabel: qi(() => u["aria-label"] ?? "Suggestions...")
    }),
    s = mt(() => fo(z, T.props));
  var B = Sr(),
    W = Ct(B);
  Ec(W, () => T.root._commandState.search === "", ee => {
    var $ = Sr(),
      oe = Ct($);
    {
      var me = Z => {
          var Ie = Sr(),
            we = Ct(Ie);
          Oa(we, () => u.child, () => ({
            props: m(s)
          })), q(Z, Ie)
        },
        _e = Z => {
          var Ie = CI();
          Lr(Ie, () => ({
            ...m(s)
          }));
          var we = I(Ie);
          Oa(we, () => u.children ?? Jn), P(Ie), q(Z, Ie)
        };
      Se(oe, Z => {
        u.child ? Z(me) : Z(_e, !1)
      })
    }
    q(ee, $)
  }), q(y, B), ii()
}
const Gv = 1,
  kI = .9,
  EI = .8,
  zI = .17,
  Kf = .1,
  Jf = .999,
  LI = .9999,
  DI = .99,
  RI = /[\\/_+.#"@[({&]/,
  FI = /[\\/_+.#"@[({&]/g,
  BI = /[\s-]/,
  dy = /[\s-]/g;

function Dm(y, u, v, b, k, z, T) {
  if (z === u.length) return k === y.length ? Gv : DI;
  const s = `${k},${z}`;
  if (T[s] !== void 0) return T[s];
  const B = b.charAt(z);
  let W = v.indexOf(B, k),
    ee = 0,
    $, oe, me, _e;
  for (; W >= 0;) $ = Dm(y, u, v, b, W + 1, z + 1, T), $ > ee && (W === k ? $ *= Gv : RI.test(y.charAt(W - 1)) ? ($ *= EI, me = y.slice(k, W - 1).match(FI), me && k > 0 && ($ *= Jf ** me.length)) : BI.test(y.charAt(W - 1)) ? ($ *= kI, _e = y.slice(k, W - 1).match(dy), _e && k > 0 && ($ *= Jf ** _e.length)) : ($ *= zI, k > 0 && ($ *= Jf ** (W - k))), y.charAt(W) !== u.charAt(z) && ($ *= LI)), ($ < Kf && v.charAt(W - 1) === b.charAt(z + 1) || b.charAt(z + 1) === b.charAt(z) && v.charAt(W - 1) !== b.charAt(z)) && (oe = Dm(y, u, v, b, W + 1, z + 2, T), oe * Kf > $ && ($ = oe * Kf)), $ > ee && (ee = $), W = v.indexOf(B, W + 1);
  return T[s] = ee, ee
}

function Wv(y) {
  return y.toLowerCase().replace(dy, " ")
}

function py(y, u, v) {
  return y = v && v.length > 0 ? `${`${y} ${v==null?void 0:v.join(" ")}`}` : y, Dm(y, u, Wv(y), Wv(u), 0, 0, {})
}

function Fc(...y) {
  return G5(rp(y))
}

function OI(y, u) {
  ri(u, !0);
  let v = rr(u, "ref", 15, null),
    b = rr(u, "value", 15, ""),
    k = Er(u, ["$$slots", "$$events", "$$legacy", "ref", "value", "class"]);
  var z = Sr(),
    T = Ct(z);
  {
    let s = mt(() => Fc("bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md", u.class));
    yn(T, () => pI, (B, W) => {
      W(B, Dc({
        "data-slot": "command",
        get class() {
          return m(s)
        }
      }, () => k, {
        get value() {
          return b()
        },
        set value(ee) {
          b(ee)
        },
        get ref() {
          return v()
        },
        set ref(ee) {
          v(ee)
        }
      }))
    })
  }
  q(y, z), ii()
}

function jI(y, u) {
  ri(u, !0);
  let v = rr(u, "ref", 15, null),
    b = Er(u, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var k = Sr(),
    z = Ct(k);
  {
    let T = mt(() => Fc("py-6 text-center text-sm", u.class));
    yn(z, () => mI, (s, B) => {
      B(s, Dc({
        "data-slot": "command-empty",
        get class() {
          return m(T)
        }
      }, () => b, {
        get ref() {
          return v()
        },
        set ref(W) {
          v(W)
        }
      }))
    })
  }
  q(y, k), ii()
}
var qI = he("<!> <!>", 1);

function VI(y, u) {
  ri(u, !0);
  let v = rr(u, "ref", 15, null),
    b = Er(u, ["$$slots", "$$events", "$$legacy", "ref", "class", "children", "heading", "value"]);
  var k = Sr(),
    z = Ct(k);
  {
    let T = mt(() => Fc("text-foreground overflow-hidden p-1", u.class)),
      s = mt(() => u.value ?? u.heading ?? `----${nI()}`);
    yn(z, () => _I, (B, W) => {
      W(B, Dc({
        "data-slot": "command-group",
        get class() {
          return m(T)
        },
        get value() {
          return m(s)
        }
      }, () => b, {
        get ref() {
          return v()
        },
        set ref(ee) {
          v(ee)
        },
        children: (ee, $) => {
          var oe = qI(),
            me = Ct(oe);
          {
            var _e = Ie => {
              var we = Sr(),
                Fe = Ct(we);
              yn(Fe, () => yI, (xe, $e) => {
                $e(xe, {
                  class: "text-muted-foreground px-2 py-1.5 text-xs font-medium",
                  children: (et, Xe) => {
                    vi();
                    var Ae = Ba();
                    Re(() => te(Ae, u.heading)), q(et, Ae)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              }), q(Ie, we)
            };
            Se(me, Ie => {
              u.heading && Ie(_e)
            })
          }
          var Z = D(me, 2);
          yn(Z, () => wI, (Ie, we) => {
            we(Ie, {
              get children() {
                return u.children
              }
            })
          }), q(ee, oe)
        },
        $$slots: {
          default: !0
        }
      }))
    })
  }
  q(y, k), ii()
}

function ZI(y, u) {
  ri(u, !0);
  let v = rr(u, "ref", 15, null),
    b = Er(u, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var k = Sr(),
    z = Ct(k);
  {
    let T = mt(() => Fc("aria-selected:bg-base-300 aria-selected:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", u.class));
    yn(z, () => II, (s, B) => {
      B(s, Dc({
        "data-slot": "command-item",
        get class() {
          return m(T)
        }
      }, () => b, {
        get ref() {
          return v()
        },
        set ref(W) {
          v(W)
        }
      }))
    })
  }
  q(y, k), ii()
}
var NI = he('<div class="border-base-content/10 flex h-9 items-center gap-2 border-b px-3" data-slot="command-input-wrapper"><!> <!></div>');

function UI(y, u) {
  ri(u, !0);
  let v = rr(u, "ref", 15, null),
    b = rr(u, "value", 15, ""),
    k = Er(u, ["$$slots", "$$events", "$$legacy", "ref", "class", "value"]);
  var z = NI(),
    T = I(z);
  J1(T, {
    class: "size-5 opacity-50"
  });
  var s = D(T, 2);
  {
    let B = mt(() => Fc("placeholder:text-muted-foreground outline-hidden flex h-10 w-full rounded-md bg-transparent py-3 text-sm disabled:cursor-not-allowed disabled:opacity-50", u.class));
    yn(s, () => SI, (W, ee) => {
      ee(W, Dc({
        "data-slot": "command-input",
        get class() {
          return m(B)
        }
      }, () => k, {
        get ref() {
          return v()
        },
        set ref($) {
          v($)
        },
        get value() {
          return b()
        },
        set value($) {
          b($)
        }
      }))
    })
  }
  P(z), q(y, z), ii()
}

function GI(y, u) {
  ri(u, !0);
  let v = rr(u, "ref", 15, null),
    b = Er(u, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var k = Sr(),
    z = Ct(k);
  {
    let T = mt(() => Fc("max-h-[300px] scroll-py-1 overflow-y-auto overflow-x-hidden", u.class));
    yn(z, () => AI, (s, B) => {
      B(s, Dc({
        "data-slot": "command-list",
        get class() {
          return m(T)
        }
      }, () => b, {
        get ref() {
          return v()
        },
        set ref(W) {
          v(W)
        }
      }))
    })
  }
  q(y, k), ii()
}
var WI = Xr('<svg><path d="M480-80 240-320l57-57 183 183 183-183 57 57L480-80ZM298-584l-58-56 240-240 240 240-58 56-182-182-182 182Z"></path></svg>');

function HI(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = WI();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var $I = he("<span> </span> <!>", 1),
  XI = he('<span class="font-flag ml-0.5"> </span> ', 1),
  YI = he('<span class="flex gap-1.5"><span class="font-flag"> </span> </span>'),
  KI = he("<!> <!>", 1),
  JI = he("<!> <!>", 1),
  QI = he('<button class="btn btn-xs btn-circle btn-ghost"><!></button>'),
  e6 = he('<div class="flex items-center"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-sm max-w-74 text-base-content/80 m-1"><!></div> <div><!></div></div> <!></div>');

function Hv(y, u) {
  ri(u, !0);
  let v = rr(u, "countryId", 15, 0),
    b = rr(u, "dropdownDirection", 3, "right"),
    k = Ke(null),
    z = Ke(null),
    T = Ke("");

  function s() {
    qm().then(() => {
      var xe;
      (xe = document.activeElement) == null || xe.blur(), H(T, "")
    })
  }
  var B = e6(),
    W = I(B),
    ee = I(W),
    $ = I(ee);
  {
    var oe = xe => {
        var $e = $I(),
          et = Ct($e),
          Xe = I(et, !0);
        P(et);
        var Ae = D(et, 2);
        HI(Ae, {
          class: "size-3.5"
        }), Re(De => te(Xe, De), [() => Ym()]), q(xe, $e)
      },
      me = xe => {
        const $e = mt(() => zs(v()));
        var et = XI(),
          Xe = Ct(et),
          Ae = I(Xe, !0);
        P(Xe);
        var De = D(Xe);
        Re(() => {
          te(Ae, m($e).flag), te(De, ` ${m($e).name??""}`)
        }), q(xe, et)
      };
    Se($, xe => {
      v() === 0 ? xe(oe) : xe(me, !1)
    })
  }
  P(ee);
  var _e = D(ee, 2);
  let Z;
  var Ie = I(_e);
  yn(Ie, () => OI, (xe, $e) => {
    $e(xe, {
      children: (et, Xe) => {
        var Ae = JI(),
          De = Ct(Ae);
        yn(De, () => UI, (Le, qe) => {
          qe(Le, {
            placeholder: "Country",
            get ref() {
              return m(k)
            },
            set ref(_t) {
              H(k, _t)
            },
            get value() {
              return m(T)
            },
            set value(_t) {
              H(T, _t, !0)
            }
          })
        });
        var Ye = D(De, 2);
        yn(Ye, () => GI, (Le, qe) => {
          qe(Le, {
            children: (_t, Qe) => {
              var Ge = KI(),
                ft = Ct(Ge);
              yn(ft, () => jI, (Et, Pt) => {
                Pt(Et, {
                  children: (ot, Ht) => {
                    vi();
                    var vt = Ba();
                    Re(Dt => te(vt, Dt), [() => d2()]), q(ot, vt)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              });
              var Vt = D(ft, 2);
              yn(Vt, () => VI, (Et, Pt) => {
                Pt(Et, {
                  children: (ot, Ht) => {
                    var vt = Sr(),
                      Dt = Ct(vt);
                    na(Dt, 17, () => xn.countries, Rt => Rt.id, (Rt, $t) => {
                      var pr = Sr(),
                        Xt = Ct(pr);
                      yn(Xt, () => ZI, (or, nt) => {
                        nt(or, {
                          get value() {
                            return m($t).name
                          },
                          onSelect: () => {
                            v(m($t).id), s()
                          },
                          children: (rt, Zt) => {
                            var Jt = YI(),
                              Ot = I(Jt),
                              mr = I(Ot, !0);
                            P(Ot);
                            var At = D(Ot);
                            P(Jt), Re(() => {
                              te(mr, m($t).flag), te(At, ` ${m($t).name??""}`)
                            }), q(rt, Jt)
                          },
                          $$slots: {
                            default: !0
                          }
                        })
                      }), q(Rt, pr)
                    }), q(ot, vt)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              }), q(_t, Ge)
            },
            $$slots: {
              default: !0
            }
          })
        }), q(et, Ae)
      },
      $$slots: {
        default: !0
      }
    })
  }), P(_e), P(W);
  var we = D(W, 2);
  {
    var Fe = xe => {
      var $e = QI();
      $e.__click = () => {
        v(0)
      };
      var et = I($e);
      Ls(et, {
        class: "size-3.5"
      }), P($e), q(xe, $e)
    };
    Se(we, xe => {
      v() != 0 && xe(Fe)
    })
  }
  P(B), Rn(B, xe => H(z, xe), () => m(z)), Re(() => Z = Vr(_e, 1, "dropdown-content menu bg-base-100 rounded-box z-1 border-base-content/10 w-52 rounded-lg border py-1 shadow-sm", null, Z, {
    "right-1": b() === "left"
  })), Mi("focus", ee, () => {
    m(k).focus()
  }), q(y, B), ii()
}
$i(["click"]);
var t6 = Xr('<svg><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-7-.5-14.5T799-507q-5 29-27 48t-52 19h-80q-33 0-56.5-23.5T560-520v-40H400v-80q0-33 23.5-56.5T480-720h40q0-23 12.5-40.5T563-789q-20-5-40.5-8t-42.5-3q-134 0-227 93t-93 227h200q66 0 113 47t47 113v40H400v110q20 5 39.5 7.5T480-160Z"></path></svg>');

function fy(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = t6();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var r6 = Xr('<svg><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Z"></path></svg>'),
  i6 = Xr('<svg><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"></path></svg>');

function Ju(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy", "filled"]);
  var b = Sr(),
    k = Ct(b);
  {
    var z = s => {
        var B = r6();
        Lr(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...v
        })), q(s, B)
      },
      T = s => {
        var B = i6();
        Lr(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...v
        })), q(s, B)
      };
    Se(k, s => {
      u.filled ? s(z) : s(T, !1)
    })
  }
  q(y, b)
}
var a6 = he('<label class="tab grow font-semibold max-sm:h-10"><input type="radio" class="tab grow"/> <!> </label>'),
  n6 = he('<div class="mb-2"><!></div>'),
  s6 = he('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  o6 = he('<tr><td class="text-base-content/80 text-center font-medium max-sm:hidden"> </td><td><span class="font-flag tooltip mr-1 text-base sm:text-lg"> </span> <span> <span class="ml-0.5"> </span></span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td><td class="px-1 text-center"><button class="btn btn-sm"> </button></td></tr>'),
  l6 = he('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th class="max-sm:hidden"></th><th> </th><th class="text-center"> <br class="sm:hidden"/> <span class="tooltip max-sm:hidden"><!></span></th><th class="px-1"></th></tr></thead><tbody></tbody></table>'),
  c6 = he('<tr><td class="text-base-content/80 text-center font-medium"> </td><td><span class="font-flag tooltip mr-1 text-base sm:text-lg"> </span> <span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  u6 = he('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th> </th><th class="text-center"> <br class="sm:hidden"/> <span class="tooltip before:-translate-x-1/4 max-sm:hidden"><!></span></th></tr></thead><tbody></tbody></table>'),
  h6 = he('<span class="font-flag tooltip ml-0.5"> </span>'),
  d6 = he("<span> </span>"),
  p6 = he('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="max-sm:px-1"><div class="flex items-center gap-2"><!> <div class="items-center gap-2 sm:flex"><span> <span class="ml-0.5"> </span></span> <!> <!> <!></div></div></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  f6 = he('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  m6 = he('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="h-14 max-sm:px-1"><span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  g6 = he('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  _6 = he('<div class="h-screen pt-20"><div class="flex justify-center"><span class="loading loading-spinner"></span></div></div>'),
  v6 = he('<div class="tabs tabs-box max-sm:tabs-xs"></div> <div class="my-4 flex items-center justify-between"><!> <!></div> <!> <!>', 1);

function y6(y, u) {
  ri(u, !0);
  const v = [];
  let b = Ke(1e3);
  const k = mt(() => m(b) <= 640);
  let z = Ke("today"),
    T = {
      regions: {
        label: f2(),
        icon: Lp
      },
      countries: {
        label: p2(),
        icon: fy
      },
      players: {
        label: p0(),
        icon: Dp
      },
      alliances: {
        label: P0(),
        icon: Rp
      }
    },
    s = Ke("regions"),
    B = Ke(0),
    W = _a({
      players: {},
      alliances: {},
      regions: {},
      countries: {}
    }),
    ee = mt(() => {
      var Ae, De, Ye;
      return m(s) === "regions" ? (De = (Ae = W[m(s)][m(B)]) == null ? void 0 : Ae[m(z)]) == null ? void 0 : De.entries : (Ye = W[m(s)][m(z)]) == null ? void 0 : Ye.entries
    });
  const $ = 5 * 1e3;
  oi(() => {
    var Le;
    if (!u.open) return;
    const Ae = m(z),
      De = m(s),
      Ye = m(B);
    De === "players" && (!W[De][Ae] || Date.now() - W[De][Ae].time > $) ? ui.leaderboardPlayers(Ae).then(qe => {
      W[De][Ae] = {
        time: Date.now(),
        entries: qe
      }
    }).catch(qe => Nt.error(qe.message)) : De === "alliances" && (!W[De][Ae] || Date.now() - W[De][Ae].time > $) ? ui.leaderboardAlliances(Ae).then(qe => {
      W[De][Ae] = {
        time: Date.now(),
        entries: qe
      }
    }).catch(qe => Nt.error(qe.message)) : De === "countries" && (!W[De][Ae] || Date.now() - W[De][Ae].time > $) ? ui.leaderboardCountries(Ae).then(qe => {
      W[De][Ae] = {
        time: Date.now(),
        entries: qe
      }
    }).catch(qe => Nt.error(qe.message)) : De === "regions" && (!((Le = W[De][Ye]) != null && Le[Ae]) || Date.now() - W[De][Ye][Ae].time > $) && ui.leaderboardRegions(Ae, Ye).then(qe => {
      W[De][Ye] || (W[De][Ye] = {}), W[De][Ye][Ae] = {
        time: Date.now(),
        entries: qe
      }
    }).catch(qe => Nt.error(qe.message))
  });
  var oe = v6(),
    me = Ct(oe);
  na(me, 21, () => Object.entries(T), ([Ae, {
    label: De,
    icon: Ye
  }]) => Ae, (Ae, De) => {
    var Ye = mt(() => t0(m(De), 2));
    let Le = () => m(Ye)[0],
      qe = () => m(Ye)[1].label,
      _t = () => m(Ye)[1].icon;
    const Qe = mt(_t);
    var Ge = a6(),
      ft = I(Ge);
    Xa(ft);
    var Vt, Et = D(ft, 2);
    yn(Et, () => m(Qe), (ot, Ht) => {
      Ht(ot, {
        get this() {
          return _t()
        },
        class: "mr-1 size-5 max-sm:hidden"
      })
    });
    var Pt = D(Et);
    P(Ge), Re(() => {
      Qt(ft, "aria-label", qe()), Vt !== (Vt = Le()) && (ft.value = (ft.__value = Le()) ?? ""), te(Pt, ` ${qe()??""}`)
    }), Nm(v, [], ft, () => (Le(), m(s)), ot => H(s, ot)), q(Ae, Ge)
  }), P(me);
  var _e = D(me, 2),
    Z = I(_e);
  lg(Z, {
    get value() {
      return m(z)
    },
    set value(Ae) {
      H(z, Ae, !0)
    }
  });
  var Ie = D(Z, 2);
  {
    var we = Ae => {
      Hv(Ae, {
        dropdownDirection: "left",
        get countryId() {
          return m(B)
        },
        set countryId(De) {
          H(B, De, !0)
        }
      })
    };
    Se(Ie, Ae => {
      m(s) === "regions" && !m(k) && Ae(we)
    })
  }
  P(_e);
  var Fe = D(_e, 2);
  {
    var xe = Ae => {
      var De = n6(),
        Ye = I(De);
      Hv(Ye, {
        get countryId() {
          return m(B)
        },
        set countryId(Le) {
          H(B, Le, !0)
        }
      }), P(De), q(Ae, De)
    };
    Se(Fe, Ae => {
      m(s) === "regions" && m(k) && Ae(xe)
    })
  }
  var $e = D(Fe, 2);
  {
    var et = Ae => {
        var De = s6(),
          Ye = I(De),
          Le = D(Ye);
        {
          var qe = Qe => {
              var Ge = Ba();
              Re(ft => te(Ge, ft), [() => kp().toLowerCase()]), q(Qe, Ge)
            },
            _t = Qe => {
              var Ge = Sr(),
                ft = Ct(Ge);
              {
                var Vt = Pt => {
                    var ot = Ba();
                    Re(Ht => te(ot, Ht), [() => $m()]), q(Pt, ot)
                  },
                  Et = Pt => {
                    var ot = Sr(),
                      Ht = Ct(ot);
                    {
                      var vt = Dt => {
                        var Rt = Ba();
                        Re($t => te(Rt, $t), [() => Xm()]), q(Dt, Rt)
                      };
                      Se(Ht, Dt => {
                        m(z) === "month" && Dt(vt)
                      }, !0)
                    }
                    q(Pt, ot)
                  };
                Se(ft, Pt => {
                  m(z) === "week" ? Pt(Vt) : Pt(Et, !1)
                }, !0)
              }
              q(Qe, Ge)
            };
          Se(Le, Qe => {
            m(z) === "today" ? Qe(qe) : Qe(_t, !1)
          })
        }
        P(De), Re(Qe => te(Ye, `${Qe??""} `), [() => Hm()]), q(Ae, De)
      },
      Xe = Ae => {
        var De = Sr(),
          Ye = Ct(De);
        {
          var Le = _t => {
              var Qe = Sr(),
                Ge = Ct(Qe);
              {
                var ft = Et => {
                    const Pt = mt(() => m(ee));
                    var ot = l6(),
                      Ht = I(ot),
                      vt = I(Ht),
                      Dt = D(I(vt)),
                      Rt = I(Dt, !0);
                    P(Dt);
                    var $t = D(Dt),
                      pr = I($t),
                      Xt = D(pr, 2),
                      or = D(Xt),
                      nt = I(or);
                    Ju(nt, {
                      class: "text-base-content/50 mb-0.5 ml-1 inline size-4"
                    }), P(or), P($t), vi(), P(vt), P(Ht);
                    var rt = D(Ht);
                    na(rt, 31, () => m(Pt), Zt => Zt.id, (Zt, Jt, Ot) => {
                      const mr = mt(() => zs(m(Jt).countryId));
                      var At = o6(),
                        Mt = I(At),
                        wt = I(Mt, !0);
                      P(Mt);
                      var It = D(Mt),
                        Ut = I(It),
                        ut = I(Ut, !0);
                      P(Ut);
                      var ur = D(Ut, 2),
                        br = I(ur),
                        cr = D(br),
                        jr = I(cr);
                      P(cr), P(ur), P(It);
                      var wr = D(It),
                        Nr = I(wr, !0);
                      P(wr);
                      var Gr = D(wr),
                        er = I(Gr);
                      er.__click = () => {
                        u.onvisitclick({
                          lat: m(Jt).lastLatitude,
                          lng: m(Jt).lastLongitude
                        })
                      };
                      var Wr = I(er, !0);
                      P(er), P(Gr), P(At), Re((sr, de, j) => {
                        te(wt, m(Ot) + 1), Qt(Ut, "data-tip", m(mr).name), te(ut, m(mr).flag), Vr(ur, 1, `font-semibold ${sr??""}`), te(br, `${m(Jt).name??""} `), te(jr, `#${m(Jt).number??""}`), te(Nr, de), te(Wr, j)
                      }, [() => tn(m(Jt).cityId), () => m(Jt).pixelsPainted.toLocaleString(navigator.language), () => H5()]), fl(At, () => ml, () => ({
                        duration: 200
                      })), q(Zt, At)
                    }), P(rt), P(ot), Re((Zt, Jt, Ot, mr) => {
                      te(Rt, Zt), te(pr, `${Jt??""} `), te(Xt, `${Ot??""} `), Qt(or, "data-tip", mr)
                    }, [() => m2(), () => Sc(), () => Pc().toLowerCase(), () => g2()]), q(Et, ot)
                  },
                  Vt = Et => {
                    var Pt = Sr(),
                      ot = Ct(Pt);
                    {
                      var Ht = Dt => {
                          var Rt = u6(),
                            $t = I(Rt),
                            pr = I($t),
                            Xt = D(I(pr)),
                            or = I(Xt, !0);
                          P(Xt);
                          var nt = D(Xt),
                            rt = I(nt),
                            Zt = D(rt, 2),
                            Jt = D(Zt),
                            Ot = I(Jt);
                          Ju(Ot, {
                            class: "text-base-content/50 mb-0.5 ml-1 inline size-4"
                          }), P(Jt), P(nt), P(pr), P($t);
                          var mr = D($t);
                          na(mr, 31, () => m(ee), At => At.id, (At, Mt, wt) => {
                            const It = mt(() => zs(m(Mt).id) ?? {
                              name: `Pais ID: ${m(Mt).id}`,
                              flag: "",
                              code: "XX"
                            });
                            var Ut = c6(),
                              ut = I(Ut),
                              ur = I(ut, !0);
                            P(ut);
                            var br = D(ut),
                              cr = I(br),
                              jr = I(cr, !0);
                            P(cr);
                            var wr = D(cr, 2),
                              Nr = I(wr, !0);
                            P(wr), P(br);
                            var Gr = D(br),
                              er = I(Gr, !0);
                            P(Gr), P(Ut), Re((Wr, sr) => {
                              te(ur, m(wt) + 1), Qt(cr, "data-tip", m(It).name), te(jr, m(It).flag), Vr(wr, 1, `font-semibold ${Wr??""}`), te(Nr, m(It).name), te(er, sr)
                            }, [() => tn(m(Mt).id), () => m(Mt).pixelsPainted.toLocaleString(navigator.language)]), fl(Ut, () => ml, () => ({
                              duration: 200
                            })), q(At, Ut)
                          }), P(mr), P(Rt), Re((At, Mt, wt, It) => {
                            te(or, At), te(rt, `${Mt??""} `), te(Zt, `${wt??""} `), Qt(Jt, "data-tip", It)
                          }, [() => Ym(), () => Sc(), () => Pc().toLowerCase(), () => _2()]), q(Dt, Rt)
                        },
                        vt = Dt => {
                          var Rt = Sr(),
                            $t = Ct(Rt);
                          {
                            var pr = or => {
                                const nt = mt(() => m(ee));
                                var rt = f6(),
                                  Zt = I(rt),
                                  Jt = I(Zt),
                                  Ot = D(I(Jt)),
                                  mr = I(Ot, !0);
                                P(Ot);
                                var At = D(Ot),
                                  Mt = I(At),
                                  wt = D(Mt, 2, !0);
                                P(At), P(Jt), P(Zt);
                                var It = D(Zt);
                                na(It, 31, () => m(nt), Ut => Ut.id, (Ut, ut, ur) => {
                                  const br = mt(() => {
                                    var ae;
                                    return ((ae = Lt.data) == null ? void 0 : ae.id) === m(ut).id
                                  });
                                  var cr = p6();
                                  let jr;
                                  var wr = I(cr),
                                    Nr = I(wr, !0);
                                  P(wr);
                                  var Gr = D(wr),
                                    er = I(Gr),
                                    Wr = I(er);
                                  Dn(Wr, {
                                    class: "size-8 border sm:size-10",
                                    get userId() {
                                      return m(ut).id
                                    },
                                    get pictureUrl() {
                                      return m(ut).picture
                                    },
                                    get borderUrl() {
                                      return m(ut).frameUrl
                                    }
                                  });
                                  var sr = D(Wr, 2),
                                    de = I(sr),
                                    j = I(de),
                                    V = D(j),
                                    X = I(V);
                                  P(V), P(de);
                                  var re = D(de, 2);
                                  {
                                    var Q = ae => {
                                      const J = mt(() => zs(m(ut).equippedFlag));
                                      var Ve = Sr(),
                                        tt = Ct(Ve);
                                      {
                                        var Ze = ne => {
                                          var Ce = h6(),
                                            He = I(Ce, !0);
                                          P(Ce), Re(() => {
                                            Qt(Ce, "data-tip", m(J).name), te(He, m(J).flag)
                                          }), q(ne, Ce)
                                        };
                                        Se(tt, ne => {
                                          m(J) && ne(Ze)
                                        })
                                      }
                                      q(ae, Ve)
                                    };
                                    Se(re, ae => {
                                      m(ut).equippedFlag && ae(Q)
                                    })
                                  }
                                  var ue = D(re, 2);
                                  {
                                    var Te = ae => {
                                      zh(ae, {
                                        get username() {
                                          return m(ut).discord
                                        },
                                        get id() {
                                          return m(ut).discordId
                                        }
                                      })
                                    };
                                    Se(ue, ae => {
                                      m(ut).discord && ae(Te)
                                    })
                                  }
                                  var be = D(ue, 2);
                                  {
                                    var ze = ae => {
                                      var J = d6(),
                                        Ve = I(J, !0);
                                      P(J), Re((tt, Ze) => {
                                        Vr(J, 1, `badge badge-sm ml-0.5 border-0 ${tt??""} ${Ze??""}`), te(Ve, m(ut).allianceName)
                                      }, [() => Cp(m(ut).allianceId), () => tn(m(ut).allianceId)]), q(ae, J)
                                    };
                                    Se(be, ae => {
                                      "allianceName" in m(ut) && m(ut).allianceName && ae(ze)
                                    })
                                  }
                                  P(sr), P(er), P(Gr);
                                  var We = D(Gr),
                                    Be = I(We, !0);
                                  P(We), P(cr), Re((ae, J) => {
                                    jr = Vr(cr, 1, "", null, jr, {
                                      "bg-base-200": m(br)
                                    }), te(Nr, m(ur) + 1), Vr(de, 1, `font-semibold max-sm:ml-2 ${ae??""} flex gap-1`), te(j, `${m(ut).name??""} `), te(X, `#${m(ut).id??""}`), te(Be, J)
                                  }, [() => tn(m(ut).id), () => m(ut).pixelsPainted.toLocaleString(navigator.language)]), fl(cr, () => ml, () => ({
                                    duration: 200
                                  })), q(Ut, cr)
                                }), P(It), P(rt), Re((Ut, ut, ur) => {
                                  te(mr, Ut), te(Mt, `${ut??""} `), te(wt, ur)
                                }, [() => Km(), () => Sc(), () => Pc().toLowerCase()]), q(or, rt)
                              },
                              Xt = or => {
                                var nt = Sr(),
                                  rt = Ct(nt);
                                {
                                  var Zt = Jt => {
                                    var Ot = g6(),
                                      mr = I(Ot),
                                      At = I(mr),
                                      Mt = D(I(At)),
                                      wt = I(Mt, !0);
                                    P(Mt);
                                    var It = D(Mt),
                                      Ut = I(It),
                                      ut = D(Ut, 2, !0);
                                    P(It), P(At), P(mr);
                                    var ur = D(mr);
                                    na(ur, 31, () => m(ee), br => br.id, (br, cr, jr) => {
                                      const wr = mt(() => {
                                        var re;
                                        return ((re = Lt.data) == null ? void 0 : re.allianceId) === m(cr).id
                                      });
                                      var Nr = m6();
                                      let Gr;
                                      var er = I(Nr),
                                        Wr = I(er, !0);
                                      P(er);
                                      var sr = D(er),
                                        de = I(sr),
                                        j = I(de, !0);
                                      P(de), P(sr);
                                      var V = D(sr),
                                        X = I(V, !0);
                                      P(V), P(Nr), Re((re, Q) => {
                                        Gr = Vr(Nr, 1, "", null, Gr, {
                                          "bg-base-200": m(wr)
                                        }), te(Wr, m(jr) + 1), Vr(de, 1, `font-semibold ${re??""}`), te(j, m(cr).name), te(X, Q)
                                      }, [() => tn(m(cr).id), () => m(cr).pixelsPainted.toLocaleString(navigator.language)]), fl(Nr, () => ml, () => ({
                                        duration: 200
                                      })), q(br, Nr)
                                    }), P(ur), P(Ot), Re((br, cr, jr) => {
                                      te(wt, br), te(Ut, `${cr??""} `), te(ut, jr)
                                    }, [() => zp(), () => Sc(), () => Pc().toLowerCase()]), q(Jt, Ot)
                                  };
                                  Se(rt, Jt => {
                                    m(s) === "alliances" && Jt(Zt)
                                  }, !0)
                                }
                                q(or, nt)
                              };
                            Se($t, or => {
                              m(s) === "players" ? or(pr) : or(Xt, !1)
                            }, !0)
                          }
                          q(Dt, Rt)
                        };
                      Se(ot, Dt => {
                        m(s) === "countries" ? Dt(Ht) : Dt(vt, !1)
                      }, !0)
                    }
                    q(Et, Pt)
                  };
                Se(Ge, Et => {
                  m(s) === "regions" ? Et(ft) : Et(Vt, !1)
                })
              }
              q(_t, Qe)
            },
            qe = _t => {
              var Qe = _6();
              q(_t, Qe)
            };
          Se(Ye, _t => {
            m(ee) ? _t(Le) : _t(qe, !1)
          }, !0)
        }
        q(Ae, De)
      };
    Se($e, Ae => {
      m(ee) && m(ee).length === 0 ? Ae(et) : Ae(Xe, !1)
    })
  }
  Ch("innerWidth", Ae => H(b, Ae, !0)), q(y, oe), ii()
}
$i(["click"]);
var x6 = Xr('<svg><path d="M160-200h160v-320H160v320Zm240 0h160v-560H400v560Zm240 0h160v-240H640v240ZM80-120v-480h240v-240h320v320h240v400H80Z"></path></svg>');

function my(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = x6();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var b6 = he('<dialog class="modal" closedby="any"><div class="modal-box h-11/12 max-w-3xl max-sm:size-full max-sm:rounded-none max-sm:px-3 max-sm:py-5 sm:overflow-x-hidden"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2"></button></form> <div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold"> </h3></div> <div class="mt-4"><!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function w6(y, u) {
  ri(u, !0);
  let v = rr(u, "open", 15);
  var b = b6(),
    k = I(b),
    z = D(I(k), 2),
    T = I(z);
  my(T, {
    class: "size-6"
  });
  var s = D(T, 2),
    B = I(s, !0);
  P(s), P(z);
  var W = D(z, 2),
    ee = I(W);
  y6(ee, {
    get onvisitclick() {
      return u.onvisitclick
    },
    get open() {
      return v()
    }
  }), P(W), P(k), vi(2), P(b), Ya(b, () => $ => {
    oi(() => {
      v() ? $.show() : $.close()
    })
  }), Re($ => te(B, $), [() => eg()]), Mi("close", b, () => v(!1)), q(y, b), ii()
}
var T6 = he("<div><!></div>"),
  S6 = he('<dialog class="modal" closedby="any"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2"></button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function P6(y, u) {
  ri(u, !0);
  let v = rr(u, "open", 15);
  var b = S6(),
    k = I(b),
    z = D(I(k), 2);
  {
    var T = s => {
      var B = T6(),
        W = I(B);
      t3(W, {}), P(B), pn(2, B, () => Kn, () => ({
        duration: 300
      })), q(s, B)
    };
    Se(z, s => {
      v() && s(T)
    })
  }
  P(k), vi(2), P(b), Ya(b, () => s => {
    oi(() => {
      v() ? s.show() : s.close()
    })
  }), Mi("close", b, () => v(!1)), q(y, b), ii()
}
var M6 = he("<p>You don't have charges to paint. <br/> </p>");

function I6(y, u) {
  ri(u, !1), Um();
  var v = M6(),
    b = D(I(v), 2);
  P(v), Re(k => te(b, ` Next charge in ${k??""}`), [() => J0(Lt.cooldown ?? 0)]), q(y, v), ii()
}
var C6 = he('<form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2"></button></form>'),
  A6 = he('<form method="dialog" class="modal-backdrop"><button> </button></form>'),
  k6 = he('<dialog closedby="any"><div><!> <!></div> <!></dialog>');

function hg(y, u) {
  ri(u, !0);
  let v = rr(u, "open", 15),
    b = rr(u, "hasBackdrop", 3, !0),
    k = rr(u, "hasCloseButton", 3, !0);
  var z = k6(),
    T = I(z),
    s = I(T);
  {
    var B = oe => {
      var me = C6();
      q(oe, me)
    };
    Se(s, oe => {
      k() && oe(B)
    })
  }
  var W = D(s, 2);
  Oa(W, () => u.children ?? Jn), P(T);
  var ee = D(T, 2);
  {
    var $ = oe => {
      var me = A6(),
        _e = I(me),
        Z = I(_e, !0);
      P(_e), P(me), Re(Ie => te(Z, Ie), [() => co()]), q(oe, me)
    };
    Se(ee, oe => {
      b() && oe($)
    })
  }
  P(z), Ya(z, () => oe => {
    oi(() => {
      v() ? oe.show() : oe.close()
    })
  }), Re(() => {
    Vr(z, 1, `modal ${u.dialogClass??""}`), Vr(T, 1, `modal-box ${u.modalBoxClass??""}`)
  }), Mi("close", z, () => v(!1)), q(y, z), ii()
}
var E6 = he('<div class="flex h-full flex-col gap-4"><span class="text-xl font-semibold"> </span> <span class="whitespace-pre-line"><!></span> <button class="btn btn-primary mx-auto w-max px-10"> </button></div>');

function z6(y, u) {
  ri(u, !0);
  let v = rr(u, "open", 15),
    b = rr(u, "buttonText", 3, "OK");
  hg(y, {
    dialogClass: "!bg-black/80",
    modalBoxClass: "max-h-11/12",
    get open() {
      return v()
    },
    set open(k) {
      v(k)
    },
    children: (k, z) => {
      var T = E6(),
        s = I(T),
        B = I(s, !0);
      P(s);
      var W = D(s, 2),
        ee = I(W);
      Oa(ee, () => u.message), P(W);
      var $ = D(W, 2);
      $.__click = () => {
        v(!1)
      };
      var oe = I($, !0);
      P($), P(T), Re(() => {
        te(B, u.title), te(oe, b())
      }), q(k, T)
    },
    $$slots: {
      default: !0
    }
  }), ii()
}
$i(["click"]);

function L6(y) {
  const u = new Date;
  return y.getDate() === u.getDate() && y.getMonth() === u.getMonth() && y.getFullYear() === u.getFullYear() ? y.toLocaleTimeString(navigator.language, {
    timeStyle: "short"
  }) : y.toLocaleDateString(navigator.language, {
    dateStyle: "medium"
  })
}
var D6 = he('<span class="size-2 rounded-full bg-red-400"></span>'),
  R6 = he('<button class="hover:bg-base-content/10 flex gap-3 px-6 py-3"><div class="bg-primary/30 flex size-10 min-h-10 min-w-10 items-center justify-center rounded-full"><!></div> <div class="grow text-sm"><div class="flex items-baseline justify-between"><h3 class="font-semibold"> </h3> <div class="text-base-content/80 flex items-center gap-1.5 text-xs"><span> </span> <!></div></div> <p class="mt-0.5 text-left"> </p></div></button>');

function $v(y, u) {
  ri(u, !0);
  let v = rr(u, "read", 15);
  var b = R6();
  b.__click = () => {
    v(!0), u.onclick()
  };
  var k = I(b),
    z = I(k);
  Oa(z, () => u.icon), P(k);
  var T = D(k, 2),
    s = I(T),
    B = I(s),
    W = I(B, !0);
  P(B);
  var ee = D(B, 2),
    $ = I(ee),
    oe = I($, !0);
  P($);
  var me = D($, 2);
  {
    var _e = we => {
      var Fe = D6();
      q(we, Fe)
    };
    Se(me, we => {
      v() || we(_e)
    })
  }
  P(ee), P(s);
  var Z = D(s, 2),
    Ie = I(Z, !0);
  P(Z), P(T), P(b), Re(we => {
    te(W, u.title), te(oe, we), te(Ie, u.message)
  }, [() => L6(u.createdAt)]), q(y, b), ii()
}
$i(["click"]);
var F6 = Xr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h168q13-36 43.5-58t68.5-22q38 0 68.5 22t43.5 58h168q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm80-80h280v-80H280v80Zm0-160h400v-80H280v80Zm0-160h400v-80H280v80Zm200-190q13 0 21.5-8.5T510-820q0-13-8.5-21.5T480-850q-13 0-21.5 8.5T450-820q0 13 8.5 21.5T480-790ZM200-200v-560 560Z"></path></svg>');

function Xv(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = F6();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var B6 = he('<button class="btn btn-sm btn-ghost"> </button>'),
  O6 = he('<p class="text-base-content/80 mt-4 text-center text-sm"> </p>'),
  j6 = he("<!> <!>", 1),
  q6 = he('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'),
  V6 = he('<div class="flex items-center justify-between gap-2 px-6"><h3 class="text-xl font-bold"> </h3> <!></div> <section class="mt-4"><!> <!></section>', 1),
  Z6 = he("<p> </p>"),
  N6 = he("<!> <!>", 1);

function U6(y, u) {
  ri(u, !0);
  let v = rr(u, "open", 15),
    b = Ke(!1),
    k = Ke(void 0),
    z = Ke(void 0),
    T = Ke(!1),
    s = Ke(""),
    B = Ke("");
  var W = N6(),
    ee = Ct(W);
  hg(ee, {
    modalBoxClass: "h-11/12 max-h-11/12 px-0",
    get open() {
      return v()
    },
    set open(oe) {
      v(oe)
    },
    children: (oe, me) => {
      var _e = V6(),
        Z = Ct(_e),
        Ie = I(Z),
        we = I(Ie, !0);
      P(Ie);
      var Fe = D(Ie, 2);
      {
        var xe = Ye => {
          var Le = B6();
          Le.__click = async () => {
            if (ui.postNotificationMarkReadAll(), Lt.notificiationCount = 0, m(k))
              for (const _t of m(k)) _t.read = !0
          };
          var qe = I(Le, !0);
          P(Le), Re(_t => te(qe, _t), [() => v2()]), q(Ye, Le)
        };
        Se(Fe, Ye => {
          Lt.notificiationCount !== 0 && Ye(xe)
        })
      }
      P(Z);
      var $e = D(Z, 2),
        et = I($e);
      {
        var Xe = Ye => {
          var Le = j6(),
            qe = Ct(Le);
          na(qe, 17, () => m(k), Ge => Ge.id, (Ge, ft, Vt) => {
            var Et = Sr(),
              Pt = Ct(Et);
            {
              var ot = vt => {
                  {
                    const Dt = Xt => {
                      Xv(Xt, {
                        class: "size-5"
                      })
                    };
                    let Rt = mt(() => uv()),
                      $t = mt(() => hv()),
                      pr = mt(() => new Date(m(ft).createdAt));
                    $v(vt, {
                      get title() {
                        return m(Rt)
                      },
                      get message() {
                        return m($t)
                      },
                      get createdAt() {
                        return m(pr)
                      },
                      onclick: () => {
                        H(s, uv(), !0), H(B, `${hv()} ${y2()}`), H(T, !0)
                      },
                      get read() {
                        return m(ft).read
                      },
                      set read(Xt) {
                        m(ft).read = Xt
                      },
                      icon: Dt,
                      $$slots: {
                        icon: !0
                      }
                    })
                  }
                },
                Ht = vt => {
                  var Dt = Sr(),
                    Rt = Ct(Dt);
                  {
                    var $t = pr => {
                      {
                        const Xt = Zt => {
                          Xv(Zt, {
                            class: "size-5"
                          })
                        };
                        let or = mt(() => dv()),
                          nt = mt(() => {
                            var Zt;
                            return (Zt = m(ft).data) != null && Zt.approved ? pv() : mv()
                          }),
                          rt = mt(() => new Date(m(ft).createdAt));
                        $v(pr, {
                          get title() {
                            return m(or)
                          },
                          get message() {
                            return m(nt)
                          },
                          get createdAt() {
                            return m(rt)
                          },
                          onclick: () => {
                            var Zt;
                            H(s, dv(), !0), H(B, (Zt = m(ft).data) != null && Zt.approved ? `${pv()}

${fv()}` : `${mv()}

${fv()}`, !0), H(T, !0)
                          },
                          get read() {
                            return m(ft).read
                          },
                          set read(Zt) {
                            m(ft).read = Zt
                          },
                          icon: Xt,
                          $$slots: {
                            icon: !0
                          }
                        })
                      }
                    };
                    Se(Rt, pr => {
                      m(ft).type === "appeal_feedback" && pr($t)
                    }, !0)
                  }
                  q(vt, Dt)
                };
              Se(Pt, vt => {
                m(ft).type === "report_feedback" ? vt(ot) : vt(Ht, !1)
              })
            }
            q(Ge, Et)
          });
          var _t = D(qe, 2);
          {
            var Qe = Ge => {
              var ft = O6(),
                Vt = I(ft, !0);
              P(ft), Re(Et => te(Vt, Et), [() => x2()]), q(Ge, ft)
            };
            Se(_t, Ge => {
              m(k).length === 0 && !m(b) && Ge(Qe)
            })
          }
          q(Ye, Le)
        };
        Se(et, Ye => {
          m(k) && Ye(Xe)
        })
      }
      var Ae = D(et, 2);
      {
        var De = Ye => {
          var Le = q6();
          Ya(Le, () => qe => {
            const _t = new IntersectionObserver(Qe => {
              Qe[0].isIntersecting && !m(b) && (H(b, !0), ui.getNotificationPage(m(z)).then(Ge => {
                H(k, [...m(k) ?? [], ...Ge.notifications], !0), H(z, Ge.nextCursor, !0);
                const ft = Ge.notifications.filter(Vt => !Vt.read).map(Vt => Vt.id);
                ft.length > 0 && (ui.postNotificationMarkRead(ft), Lt.notificiationCount !== void 0 && (Lt.notificiationCount = Math.max(0, Lt.notificiationCount - ft.length)))
              }).catch(Ge => {
                Nt.error(Ge.message)
              }).finally(() => {
                H(b, !1)
              }))
            });
            return _t.observe(qe), () => {
              _t.disconnect()
            }
          }), q(Ye, Le)
        };
        Se(Ae, Ye => {
          v() && (m(k) === void 0 || m(z) !== void 0) && Ye(De)
        })
      }
      P($e), Re(Ye => te(we, Ye), [() => f0()]), q(oe, _e)
    },
    $$slots: {
      default: !0
    }
  });
  var $ = D(ee, 2);
  z6($, {
    get title() {
      return m(s)
    },
    get open() {
      return m(T)
    },
    set open(me) {
      H(T, me, !0)
    },
    message: me => {
      var _e = Z6(),
        Z = I(_e, !0);
      P(_e), Re(() => te(Z, m(B))), q(me, _e)
    },
    $$slots: {
      message: !0
    }
  }), q(y, W), ii()
}
$i(["click"]);
var G6 = he("<canvas></canvas>");

function gy(y, u) {
  ri(u, !0);
  let v = rr(u, "width", 15, 0),
    b = Er(u, ["$$slots", "$$events", "$$legacy", "value", "fontSize", "color", "weight", "mono", "width"]),
    k = mt(() => Math.ceil(u.fontSize)),
    z = Ke(null);
  const T = window.devicePixelRatio ?? 1,
    s = '"Geist", ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"',
    B = '"Geist Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  oi(() => {
    const ee = m(z).getContext("2d");
    ee.textBaseline = "top", ee.font = `${u.weight??"normal"} ${u.fontSize}px ${u.mono?B:s}`, ee.fillStyle = u.color ?? "#394e6a", ee.setTransform(T, 0, 0, T, 0, 0), ee.clearRect(0, 0, v(), m(k)), ee.fillText(u.value, 0, 0);
    const $ = ee.measureText(u.value);
    v(Math.ceil($.actualBoundingBoxRight)), H(k, $.actualBoundingBoxDescent)
  });
  var W = G6();
  Lr(W, () => ({
    width: v() * T,
    height: m(k) * T,
    style: `width: ${v()??""}px; height: ${m(k)??""}px`,
    ...b
  })), Rn(W, ee => H(z, ee), () => m(z)), q(y, W), ii()
}
var W6 = he('<span class="w-7 text-xs"> </span>'),
  H6 = he('<span class="flex items-center gap-1 sm:mt-px"><span><!></span> <!></span>'),
  $6 = he('<span class="loading loading-spinner center-absolute absolute"></span>'),
  X6 = he('<button><div class="flex items-center gap-1.5"><!> <div class="flex items-center gap-2 whitespace-nowrap"> <!></div></div> <!></button>');

function _y(y, u) {
  ri(u, !0);
  let v = Er(u, ["$$slots", "$$events", "$$legacy", "loading", "charges", "maxWidth"]),
    b = Ke(0),
    k = Ke(null),
    z = Ke(void 0);
  ho(() => [u.loading, u.maxWidth], () => {
    H(z, void 0), requestAnimationFrame(() => {
      const Z = m(k).offsetWidth;
      !u.loading && u.maxWidth !== void 0 && Z + 20 > u.maxWidth ? H(z, 16 * (u.maxWidth / Z) * .8) : H(z, void 0)
    })
  });
  var T = X6();
  Lr(T, () => ({
    ...v,
    class: `btn btn-primary btn-lg sm:btn-xl relative ${u.class??""}`,
    style: `max-width: ${u.maxWidth?`${u.maxWidth}px`:"none"}
	${m(z)?`;font-size: ${m(z)}px`:""}`
  }));
  var s = I(T),
    B = I(s);
  yl(B, {
    class: "size-6"
  });
  var W = D(B, 2),
    ee = I(W),
    $ = D(ee);
  {
    var oe = Z => {
      const Ie = mt(() => `${Math.floor(u.charges)}/${Lt.data.charges.max}`);
      var we = H6(),
        Fe = I(we),
        xe = I(Fe);
      {
        let Xe = mt(() => m(z) ?? 16),
          Ae = mt(() => u.disabled ? "#394e6a33" : "#ffffff");
        gy(xe, {
          weight: 600,
          get fontSize() {
            return m(Xe)
          },
          get value() {
            return m(Ie)
          },
          get color() {
            return m(Ae)
          },
          get width() {
            return m(b)
          },
          set width(De) {
            H(b, De, !0)
          }
        })
      }
      P(Fe);
      var $e = D(Fe, 2);
      {
        var et = Xe => {
          var Ae = W6(),
            De = I(Ae);
          P(Ae), Re(Ye => te(De, `(${Ye??""})`), [() => J0(Lt.cooldown)]), q(Xe, Ae)
        };
        Se($e, Xe => {
          u.charges < Lt.data.charges.max && Lt.cooldown !== void 0 && Xe(et)
        })
      }
      P(we), Re(Xe => uo(Fe, `width: ${Xe??""}px`), [() => (Math.floor(m(b) / 5) + 1) * 5]), q(Z, we)
    };
    Se($, Z => {
      u.charges !== void 0 && Lt.data && Z(oe)
    })
  }
  P(W), P(s), Rn(s, Z => H(k, Z), () => m(k));
  var me = D(s, 2);
  {
    var _e = Z => {
      var Ie = $6();
      q(Z, Ie)
    };
    Se(me, Z => {
      u.loading && Z(_e)
    })
  }
  P(T), Re(Z => te(ee, `${Z??""} `), [() => m0()]), q(y, T), ii()
}
const Y6 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAABVQTFRFAAAASkKEenHEta7xWmmLi5y0v8vc+SuCVQAAAAF0Uk5TAEDm2GYAAAA/SURBVHjaXcjBDcAwDMNAUW28/8hF0MCIzN9RV7aVfuxp+IGPe+AdPQRpFaRrgcNrn/Bb4LAE4W5aNb3TXUofoSgBYpzN5I4AAAAASUVORK5CYII=",
  K6 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAFxJREFUeNq107EJACAMRFEHyxSu4jbuZ+0IyhUS4ZDogYEr3++Svp+ZDUzGrRTMIwKmiIApImCKiBgbOXOEcRxQsQcW7rVKeA9gj5gD2D3mgC/GcQSLMEdO+/qtE+/GV5duYCOPAAAAAElFTkSuQmCC",
  J6 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAAXNSR0IArs4c6QAAAAJ0Uk5TAAB2k804AAAAKklEQVR42mOAAhsbCA3n//9vQ74ApqE2QIAgwIqBykFaICwMAQwt9HEpAIf2Me1Ro5Q9AAAAAElFTkSuQmCC",
  Q6 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAABVJREFUeNpjYGA48x8DYwoB1Q0RlQDDCVmniJ241gAAAABJRU5ErkJggg==";
class eC {
  constructor(u) {
    fi(this, "gm");
    fi(this, "opacity", 1);
    fi(this, "id", `paint-preview-${Math.random()}`);
    fi(this, "tiles", new Map);
    this.input = u, this.gm = new kn(this.input.tileSize)
  }
  place([u, v], b) {
    const {
      tile: k,
      pixel: z
    } = this.gm.latLonToTileAndPixel(u, v, this.input.tileZoom), T = this.getTileKey(k[0], k[1]);
    let s = this.tiles.get(T);
    if (!s) {
      const B = this.gm.tileBoundsLatLon(k[0], k[1], this.input.tileZoom),
        W = rg(B, !0),
        ee = new tC({
          coordinates: W,
          id: `${this.id}-${T}`,
          layerPaint: {
            "raster-opacity": this.opacity,
            "raster-resampling": "nearest"
          },
          tileSize: this.input.tileSize,
          beforeLayerId: this.input.beforeLayerId
        });
      ee.addTo(this.input.map), this.tiles.set(T, ee), s = ee
    }
    s.place(z[0], this.input.tileSize - z[1] - 1, b)
  }
  clear() {
    const u = this.input.map;
    for (const v of this.tiles.values()) v.removeFrom(u), v.removeDOM();
    this.tiles.clear()
  }
  clearAndPlace(u, v) {
    this.clear(), this.place(u, v)
  }
  remove([u, v]) {
    const {
      tile: b,
      pixel: k
    } = this.gm.latLonToTileAndPixel(u, v, this.input.tileZoom), z = this.getTileKey(b[0], b[1]), T = this.tiles.get(z);
    T && T.remove(k[0], this.input.tileSize - k[1] - 1)
  }
  setCanvasOpacity(u) {
    this.opacity = u;
    for (const v of this.tiles.values()) v.setOpacity(u)
  }
  getTileKey(u, v) {
    return `${u},${v}`
  }
}
class tC {
  constructor(u) {
    fi(this, "canvas");
    fi(this, "maps", new Set);
    this.input = u;
    const v = this.input.tileSize;
    this.canvas = document.createElement("canvas"), this.canvas.width = v, this.canvas.height = v
  }
  place(u, v, b) {
    var T;
    const k = ((T = xn.colors) == null ? void 0 : T[b]) ?? xn.colors[0],
      z = this.canvas.getContext("2d");
    if (z) {
      const s = z.createImageData(1, 1),
        [B, W, ee] = k.rgb,
        $ = b === 0 ? 0 : 255;
      s.data[0] = B, s.data[1] = W, s.data[2] = ee, s.data[3] = $, z.putImageData(s, u, v)
    }
  }
  remove(u, v) {
    const b = this.canvas.getContext("2d");
    b && b.clearRect(u, v, 1, 1)
  }
  addTo(u) {
    const v = this.input.id;
    u.getSource(v) || u.addSource(v, {
      type: "canvas",
      canvas: this.canvas,
      coordinates: this.input.coordinates
    }), u.getLayer(v) || (u.addLayer({
      id: v,
      type: "raster",
      source: v,
      paint: this.input.layerPaint
    }), this.input.beforeLayerId && u.moveLayer(v, this.input.beforeLayerId)), this.maps.add(u)
  }
  removeFrom(u) {
    const {
      id: v
    } = this.input;
    u.getLayer(v) && u.removeLayer(v), u.getSource(v) && u.removeSource(v), this.maps.delete(u)
  }
  removeDOM() {
    this.canvas.remove()
  }
  setOpacity(u) {
    for (const v of this.maps.values()) v.setPaintProperty(this.input.id, "raster-opacity", u)
  }
}
var rC = Xr('<svg><path d="M5 21C4.45 21 3.97917 20.8042 3.5875 20.4125C3.19583 20.0208 3 19.55 3 19V15H5V19H9V21H5ZM15 21V19H19V15H21V19C21 19.55 20.8042 20.0208 20.4125 20.4125C20.0208 20.8042 19.55 21 19 21H15ZM3 9V5C3 4.45 3.19583 3.97917 3.5875 3.5875C3.97917 3.19583 4.45 3 5 3H9V5H5V9H3ZM19 9V5H15V3H19C19.55 3 20.0208 3.19583 20.4125 3.5875C20.8042 3.97917 21 4.45 21 5V9H19Z"></path></svg>');

function iC(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = rC();
  Lr(b, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...v
  })), q(y, b)
}
var aC = Xr('<svg><path d="M5 19H9V21H5C4.45 21 3.97956 20.8038 3.58789 20.4121C3.19622 20.0204 3 19.55 3 19V15H5V19ZM20.6768 20.0908C20.6015 20.2031 20.5138 20.3105 20.4121 20.4121C20.0204 20.8038 19.55 21 19 21H15V19H19V18.4141L20.6768 20.0908ZM21 17.5859L19 15.5859V15H21V17.5859ZM5.58594 5H5V9H3V5C3 4.45 3.19622 3.97956 3.58789 3.58789C3.68947 3.48631 3.79597 3.3975 3.9082 3.32227L5.58594 5ZM19 3C19.55 3 20.0204 3.19622 20.4121 3.58789C20.8038 3.97956 21 4.45 21 5V9H19V5H15V3H19ZM9 5H8.41406L6.41406 3H9V5Z"></path><rect x="1" y="2.41422" width="2" height="29" transform="rotate(-45 1 2.41422)"></rect></svg>');

function nC(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = aC();
  Lr(b, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...v
  })), q(y, b)
}
var sC = he("<div><!></div>");

function Tc(y, u) {
  ri(u, !0);
  var v = sC(),
    b = I(v);
  Oa(b, () => u.children ?? Jn), P(v), Re(() => Vr(v, 1, `bg-base-100/60 border-base-content/20 -top-15 pointer-events-none absolute left-1/2 line-clamp-1 flex w-max -translate-x-1/2 select-none items-center gap-1 rounded-full border-2 px-3 py-1.5 ${u.class??""}`)), q(y, v), ii()
}
var oC = he('<div class="confetti svelte-av71ki"></div>'),
  lC = he("<div></div>");

function dg(y, u) {
  ri(u, !0);
  const v = rr(u, "size", 3, 10),
    b = rr(u, "x", 19, () => [-.5, .5]),
    k = rr(u, "y", 19, () => [.25, 1]),
    z = rr(u, "duration", 3, 2e3),
    T = rr(u, "infinite", 3, !1),
    s = rr(u, "delay", 19, () => [0, 50]),
    B = rr(u, "colorRange", 19, () => [0, 360]),
    W = rr(u, "colorArray", 19, () => []),
    ee = rr(u, "amount", 3, 50),
    $ = rr(u, "iterationCount", 3, 1),
    oe = rr(u, "fallDistance", 3, "100px"),
    me = rr(u, "rounded", 3, !1),
    _e = rr(u, "cone", 3, !1),
    Z = rr(u, "noGravity", 3, !1),
    Ie = rr(u, "xSpread", 3, .15),
    we = rr(u, "destroyOnComplete", 3, !0),
    Fe = rr(u, "disableForReducedMotion", 3, !1);
  let xe = Ke(!1);
  $a(() => {
    !we() || T() || typeof $() == "string" || setTimeout(() => H(xe, !0), (z() + s()[1]) * $())
  });

  function $e(Ye, Le) {
    return Math.random() * (Le - Ye) + Ye
  }

  function et() {
    return W().length ? W()[Math.round(Math.random() * (W().length - 1))] : `hsl(${Math.round($e(B()[0],B()[1]))}, 75%, 50%)`
  }
  var Xe = Sr(),
    Ae = Ct(Xe);
  {
    var De = Ye => {
      var Le = lC();
      let qe;
      na(Le, 21, () => ({
        length: ee()
      }), Lc, (_t, Qe) => {
        var Ge = oC();
        Re((ft, Vt, Et, Pt, ot, Ht, vt, Dt, Rt, $t, pr) => uo(Ge, `
        --color: ${ft??""};
        --skew: ${Vt??""}deg,${Et??""}deg;
        --rotation-xyz: ${Pt??""}, ${ot??""}, ${Ht??""};
        --rotation-deg: ${vt??""}deg;
        --translate-y-multiplier: ${Dt??""};
        --translate-x-multiplier: ${Rt??""};
        --scale: ${$t??""};
        --transition-delay: ${pr??""}ms;
        --transition-duration: ${T()?`calc(${z()}ms * var(--scale))`:`${z()}ms`};`), [et, () => $e(-45, 45), () => $e(-45, 45), () => $e(-10, 10), () => $e(-10, 10), () => $e(-10, 10), () => $e(0, 360), () => $e(k()[0], k()[1]), () => $e(b()[0], b()[1]), () => .1 * $e(2, 10), () => $e(s()[0], s()[1])]), q(_t, Ge)
      }), P(Le), Re(() => {
        qe = Vr(Le, 1, "confetti-holder svelte-av71ki", null, qe, {
          rounded: me(),
          cone: _e(),
          "no-gravity": Z(),
          "reduced-motion": Fe()
        }), uo(Le, `
    --fall-distance: ${oe()??""};
    --size: ${v()??""}px;
    --x-spread: ${1-Ie()};
    --transition-iteration-count: ${(T()?"infinite":$())??""};`)
      }), q(Ye, Le)
    };
    Se(Ae, Ye => {
      m(xe) || Ye(De)
    })
  }
  q(y, Xe), ii()
}
var cC = he('<span class="loading loading-spinner center-absolute absolute"></span>'),
  uC = he('<!> <span class="text-sm">Droplets</span>', 1),
  hC = he('<!> Unlocked <span class="center-absolute absolute"><!></span>', 1),
  dC = he('<div class="flex flex-col gap-4"><section><div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold">Unlock</h3> <div class="ml-auto mr-4"><!></div></div> <p class="text-base-content/80 mt-1 text-sm">Permanently unlock the color</p></section> <div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><div class="border-base-content/20 size-32 rounded-2xl border-4"></div></div> <p class="mt-4 text-center text-2xl font-bold"> </p> <div class="flex w-max flex-col"><div><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <!></button></div> <button class="btn relative mt-3 h-10">Close</button></div></div></div>'),
  pC = he('<dialog class="modal bg-black/80!" closedby="any"><div class="modal-box max-h-11/12 w-11/12 max-w-md"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2"></button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function fC(y, u) {
  ri(u, !0);
  let v = rr(u, "open", 15);
  const b = mt(() => xn.colors[u.colorIdx]),
    k = mt(() => {
      var me;
      return ((me = Lt.data) == null ? void 0 : me.droplets) ?? 0
    });
  let z = Ke(!1);
  const T = mt(() => (m(z), Lt.hasColor(u.colorIdx))),
    s = 100,
    B = xn.products[s];
  var W = pC(),
    ee = I(W),
    $ = D(I(ee), 2);
  {
    var oe = me => {
      var _e = dC(),
        Z = I(_e),
        Ie = I(Z),
        we = I(Ie);
      Tp(we, {
        class: "size-6"
      });
      var Fe = D(we, 4),
        xe = I(Fe);
      n0(xe, {
        get value() {
          return m(k)
        }
      }), P(Fe), P(Ie), vi(2), P(Z);
      var $e = D(Z, 2),
        et = I($e),
        Xe = I(et);
      P(et);
      var Ae = D(et, 2),
        De = I(Ae, !0);
      P(Ae);
      var Ye = D(Ae, 2),
        Le = I(Ye);
      let qe;
      var _t = I(Le);
      _t.__click = async () => {
        try {
          H(z, !0), await ui.purchase({
            id: s,
            amount: 1,
            variant: u.colorIdx
          }), await Lt.refresh(), ya.notification1.play()
        } catch (ot) {
          Nt.error(ot.message)
        } finally {
          H(z, !1)
        }
      };
      var Qe = I(_t);
      {
        var Ge = ot => {
          var Ht = cC();
          q(ot, Ht)
        };
        Se(Qe, ot => {
          m(z) && ot(Ge)
        })
      }
      var ft = D(Qe, 2);
      {
        var Vt = ot => {
            var Ht = uC(),
              vt = Ct(Ht);
            Ip(vt, {
              class: "size-5"
            });
            var Dt = D(vt);
            vi(), Re(Rt => te(Dt, ` ${Rt??""} `), [() => B.price.toLocaleString(navigator.language)]), q(ot, Ht)
          },
          Et = ot => {
            var Ht = hC(),
              vt = Ct(Ht);
            Tp(vt, {
              class: "size-5"
            });
            var Dt = D(vt, 2),
              Rt = I(Dt);
            dg(Rt, {}), P(Dt), q(ot, Ht)
          };
        Se(ft, ot => {
          m(T) ? ot(Et, !1) : ot(Vt)
        })
      }
      P(_t), P(Le);
      var Pt = D(Le, 2);
      Pt.__click = () => v(!1), P(Ye), P($e), P(_e), Re(ot => {
        uo(Xe, `background: rgb(${m(b).rgb[0]} ${m(b).rgb[1]} ${m(b).rgb[2]})`), Qt(Xe, "aria-label", m(b).name), te(De, m(b).name), Qt(Le, "data-tip", ot), qe = Vr(Le, 1, "", null, qe, {
          tooltip: !m(T) && m(k) < B.price
        }), _t.disabled = m(k) < B.price || m(z) || m(T)
      }, [() => Ep()]), q(me, _e)
    };
    Se($, me => {
      Lt.data && me(oe)
    })
  }
  P(ee), vi(2), P(W), Ya(W, () => me => {
    oi(() => {
      v() ? me.show() : me.close()
    })
  }), Mi("close", W, () => v(!1)), q(y, W), ii()
}
$i(["click"]);
var mC = Xr('<svg><path d="M120-120v-190l358-358-58-56 58-56 76 76 124-124q5-5 12.5-8t15.5-3q8 0 15 3t13 8l94 94q5 6 8 13t3 15q0 8-3 15.5t-8 12.5L705-555l76 78-57 57-56-58-358 358H120Zm80-80h78l332-334-76-76-334 332v78Zm447-410 96-96-37-37-96 96 37 37Zm0 0-37-37 37 37Z"></path></svg>');

function Yv(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = mC();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var gC = Xr('<svg><path d="m247-904 57-56 343 343q23 23 23 57t-23 57L457-313q-23 23-57 23t-57-23L153-503q-23-23-23-57t23-57l190-191-96-96Zm153 153L209-560h382L400-751Zm360 471q-33 0-56.5-23.5T680-360q0-21 12.5-45t27.5-45q9-12 19-25t21-25q11 12 21 25t19 25q15 21 27.5 45t12.5 45q0 33-23.5 56.5T760-280ZM80 0v-160h800V0H80Z"></path></svg>');

function vy(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = gC();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var _C = Xr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm240-400v80h80v-80h-80Zm-160 0v80h80v-80h-80Zm80 80v80h80v-80h-80Zm160 0v80h80v-80h-80Zm-320 0v80h80v-80h-80Zm400-80v80h80v80h80v-80h-80v-80h-80ZM280-360v80h-80v80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h-80v80h-80v-80h-80v80h-80v-80h-80Zm480-160v80-80Zm0 160v80-80Z"></path></svg>'),
  vC = Xr('<svg><path d="M440-440v-80h80v80h-80Zm-80 80v-80h80v80h-80Zm160 0v-80h80v80h-80Zm80-80v-80h80v80h-80Zm-320 0v-80h80v80h-80Zm-80 320q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm80-80h80v-80h-80v80Zm160 0h80v-80h-80v80Zm320 0v-80 80Zm-560-80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h80v-320H200v320h80v80h-80v80Zm0 80v-560 560Zm560-240v80-80ZM600-280v80h80v-80h-80Z"></path></svg>');

function yy(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy", "filled"]);
  var b = Sr(),
    k = Ct(b);
  {
    var z = s => {
        var B = _C();
        Lr(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...v
        })), q(s, B)
      },
      T = s => {
        var B = vC();
        Lr(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...v
        })), q(s, B)
      };
    Se(k, s => {
      u.filled ? s(z) : s(T, !1)
    })
  }
  q(y, b)
}
var yC = Xr('<svg><path d="M240-80q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640h40v-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240Zm0-80h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM360-640h240v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85v80ZM240-160v-400 400Z"></path></svg>');

function Rm(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = yC();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var xC = Xr('<svg><path d="M396-200q-97 0-166.5-63T160-420q0-94 69.5-157T396-640h252L544-744l56-56 200 200-200 200-56-56 104-104H396q-63 0-109.5 40T240-420q0 60 46.5 100T396-280h284v80H396Z"></path></svg>');

function bC(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = xC();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var wC = Xr('<svg><path d="M419-80q-28 0-52.5-12T325-126L107-403l19-20q20-21 48-25t52 11l74 45v-328q0-17 11.5-28.5T340-760q17 0 29 11.5t12 28.5v472l-97-60 104 133q6 7 14 11t17 4h221q33 0 56.5-23.5T720-240v-160q0-17-11.5-28.5T680-440H461v-80h219q50 0 85 35t35 85v160q0 66-47 113T640-80H419ZM167-620q-13-22-20-47.5t-7-52.5q0-83 58.5-141.5T340-920q83 0 141.5 58.5T540-720q0 27-7 52.5T513-620l-69-40q8-14 12-28.5t4-31.5q0-50-35-85t-85-35q-50 0-85 35t-35 85q0 17 4 31.5t12 28.5l-69 40Zm335 280Z"></path></svg>');

function xy(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = wC();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var TC = Xr('<svg><path d="M280-200v-80h284q63 0 109.5-40T720-420q0-60-46.5-100T564-560H312l104 104-56 56-200-200 200-200 56 56-104 104h252q97 0 166.5 63T800-420q0 94-69.5 157T564-200H280Z"></path></svg>');

function SC(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = TC();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var PC = he("<!> ", 1),
  MC = he("<!> ", 1),
  IC = he("<!> ", 1),
  CC = he('<!><b> </b> <span class="touchscreen:hidden"> <span class="kbd kbd-xs text-base-content rounded-md"> </span></span> ', 1),
  AC = he("<!> ", 1),
  kC = he('<!> <span class="bg-base-100 translate-1/2 absolute bottom-0 right-0 flex size-5 items-center justify-center rounded-full max-sm:hidden"><!></span>', 1),
  EC = he("<div><button><!></button></div>"),
  zC = he('<div class="relative px-3"><!> <div class="flex items-center gap-1.5"><button class="btn btn-circle btn-sm btn-soft"><!></button> <div class="flex grow items-center gap-1.5"><h2 class="sm:min-w-38 select-none text-xl"> <!></h2> <div class="tooltip ml-1 sm:ml-2"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">I</kbd></div> <button><!></button></div> <div class="tooltip max-sm:hidden"><button title="Toggle art opacity"><!></button></div> <div class="tooltip ml-1 sm:ml-2"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">Ctrl+Z</kbd></div> <button title="Undo"><!></button></div> <div class="tooltip ml-1 sm:ml-2"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">Ctrl+Y</kbd></div> <button title="Redo"><!></button></div></div> <button class="btn btn-circle btn-sm"><!></button></div> <div class="mb-4 mt-3"><div></div></div> <div class="relative h-12 sm:h-14"><button class="btn btn-lg btn-square sm:btn-xl absolute bottom-0 left-0 shadow-md"><!></button> <div class="absolute bottom-0 left-1/2 -translate-x-1/2"><!></div> <div class="absolute bottom-0 right-0"><div class="tooltip ml-auto"><div class="tooltip-content not-touchscreen:-translate-x-[10%]"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">E</kbd></div> <button><!></button></div></div></div></div> <!>', 1);

function LC(y, u) {
  var qt, bt;
  ri(u, !0);
  let v = rr(u, "screenLocked", 15),
    b = rr(u, "opaquePixelArt", 15);
  const k = mt(() => new kn(u.tileSize));
  let z = Ke(1),
    T = Ke("pencil");
  const s = new Map,
    B = new Map;
  let W = Ke(0),
    ee = Ke(!1),
    $ = Ke(!0),
    oe = mt(() => Lt.charges ?? 0),
    me = mt(() => m(oe) - m(W)),
    _e = Ke(!1),
    Z = !1,
    Ie = Ke(!1);
  const we = mt(() => m(T) === "pencil"),
    Fe = mt(() => m(T) === "eraser"),
    xe = mt(() => m(T) === "colorpicker");
  let $e = Ke(!1),
    et = Ke(0),
    Xe = Ke(void 0),
    Ae = Ke(void 0);
  const De = [1, 2, 3, 32, 4, 5, 6, 33, 7, 34, 35, 8, 9, 10, 11, 37, 38, 39, 40, 41, 42, 12, 13, 14, 15, 16, 17, 43, 20, 44, 18, 19, 45, 46, 21, 22, 47, 48, 49, 23, 24, 25, 26, 27, 28, 53, 54, 55, 29, 30, 50, 56, 57, 36, 51, 31, 52, 61, 62, 63, 58, 59, 60, 0].map(Ue => ({
      ...xn.colors[Ue],
      idx: Ue,
      label: bv[Ue]()
    })),
    Ye = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0].map(Ue => ({
      ...xn.colors[Ue],
      idx: Ue,
      label: bv[Ue]()
    }));
  let Le = Ke(!1);
  const qe = mt(() => m(Le) ? De : Ye),
    _t = "show-all-colors";
  $a(() => {
    H(Le, localStorage.getItem(_t) === "true")
  }), oi(() => {
    localStorage.setItem(_t, m(Le) ? "true" : "false")
  });
  const Qe = "selected-color";
  $a(() => {
    const Ue = Number(localStorage.getItem(Qe));
    !isNaN(Ue) && Ue < xn.colors.length && Ue > 0 && H(z, Ue, !0)
  }), oi(() => {
    localStorage.setItem(Qe, m(z).toString())
  });
  const Ge = new eC({
    map: u.map,
    tileSize: u.tileSize,
    tileZoom: u.tileZoom,
    beforeLayerId: u.hoverLayerId
  });
  oi(() => {
    const Ue = b() ? 1 : 0;
    Ge.setCanvasOpacity(Ue)
  }), oi(() => {
    b() ? tm() : vt([...s.values()])
  });
  let ft = !1;
  $a(() => {
    no(u.map.getCenter(), u.map.getZoom());
    const Ue = u.map.on("click", Yr => {
      var Ii;
      u.zoom < u.tileZoom + 2 && ((Ii = Lt.data) == null ? void 0 : Ii.role) === "user" && u.map.easeTo({
        center: Yr.lngLat,
        zoom: 17
      });
      const Zr = [Yr.lngLat.lat, Yr.lngLat.lng];
      m(we) ? (Et([Zr], m(z)), Ot.finishAction()) : m(Fe) ? (Pt([Zr]), Ot.finishAction()) : m(xe) && ot(Zr, Yr.point), H(_e, !0)
    });

    function xt(Yr, Zr) {
      const Ii = m(k).latLonToPixels(Yr.lat, Yr.lng, u.tileZoom),
        ki = Zr ? m(k).latLonToPixels(Zr.lat, Zr.lng, u.tileZoom) : Ii;
      return rb(Ii, ki).map(Vi => m(k).pixelsToLatLon(Vi[0] + .5, Vi[1] + .5, u.tileZoom))
    }

    function Gt(Yr, Zr) {
      const Ii = xt(Yr, Zr);
      m(we) ? Et(Ii, m(z)) : m(Fe) && Pt(Ii), H(_e, !0)
    }
    let kt;

    function dr(Yr) {
      const Zr = u.map.unproject([Yr.clientX, Yr.clientY]);
      if (m(Ie)) {
        const Ii = xt(Zr, kt);
        Pt(Ii)
      }(ft || Z) && Gt(Zr, kt), kt = Zr
    }
    window.addEventListener("mousemove", dr);
    let ar = !1;
    const Ar = u.map.on("touchstart", Yr => {
        if (Yr.points.length == 2) {
          v(!1), pr(), ar = !0, setTimeout(() => ar = !1, 150);
          return
        }
        v() && setTimeout(() => {
          !ar && Gt(Yr.lngLat)
        }, 150), kt = Yr.lngLat
      }),
      Kr = u.map.on("touchend", () => {
        Ot.finishAction()
      }),
      Rr = u.map.on("touchmove", Yr => {
        v() && Gt(Yr.lngLat, kt), kt = Yr.lngLat
      }),
      Or = Yr => {
        Yr.code === "Space" && (ft || kt && Gt(kt), ft = !0, Yr.preventDefault())
      };
    document.addEventListener("keydown", Or);
    const Fr = Yr => {
      Yr.code === "Space" && (ft = !1, Vt = !1, Ot.finishAction(), m(W) === 0 && m(Fe) && H(T, "pencil"))
    };
    document.addEventListener("keyup", Fr);

    function ti(Yr) {
      if (Yr.button === 2) {
        H(Ie, !0);
        const Ii = u.map.unproject([Yr.clientX, Yr.clientY]);
        Pt([
          [Ii.lat, Ii.lng]
        ])
      }
    }
    document.addEventListener("mousedown", ti);

    function Ai(Yr) {
      Yr.button === 2 && H(Ie, !1)
    }
    document.addEventListener("mouseup", Ai);
    const bi = Yr => {
      switch (Yr.code) {
        case "KeyE":
          m(W) > 0 && (m(Fe) ? H(T, "pencil") : H(T, "eraser"));
          return;
        case "KeyI":
          H(T, "colorpicker");
          return
      }
    };
    return document.addEventListener("keypress", bi), () => {
      Rr.unsubscribe(), Ar.unsubscribe(), Kr.unsubscribe(), Ue.unsubscribe(), document.removeEventListener("mousemove", dr), document.removeEventListener("keydown", Or), document.removeEventListener("keyup", Fr), document.removeEventListener("keypress", bi), document.removeEventListener("mousedown", ti), document.removeEventListener("mouseup", Ai), Dt()
    }
  });
  let Vt = !1;

  function Et(Ue, xt, Gt = !0) {
    let kt = !1;
    const dr = xt === 0;
    for (let ar of Ue) {
      const [Ar, Kr] = ar, Rr = _p(xt), {
        tile: Or,
        pixel: Fr
      } = m(k).latLonToTileAndPixel(Ar, Kr, u.tileZoom), ti = {
        color: Rr,
        tile: Or,
        pixel: Fr,
        season: u.season,
        colorIdx: xt
      }, Ai = Uf(ti), bi = s.get(Ai), Yr = m(oe) - s.size;
      if (!bi && Yr < 1) {
        if (Vt && (ft || v())) continue;
        Vt = !0, Nt.info(b2());
        continue
      }
      if (!(bi && bi.colorIdx === xt) && (ya.plop.play(), kt || u.hidePixelHover(), s.set(Ai, ti), Ge.place(ar, xt), u.crosshair.place(ar), kt = !0, dr && B.set(Ai, ti), Gt)) {
        const Zr = {
            type: "paint",
            latLons: [ar],
            colorIdx: xt
          },
          Ii = bi ? {
            type: "paint",
            latLons: [ar],
            colorIdx: bi.colorIdx
          } : {
            type: "erase",
            latLons: [ar]
          };
        Ot.saveAction(Zr, Ii)
      }
    }
    H(W, s.size, !0), kt && !b() ? vt([...s.values()]) : kt && b() && dr && vt([...B.values()])
  }

  function Pt(Ue, xt = !0) {
    let Gt = !1,
      kt = !1;
    for (let dr of Ue) {
      const [ar, Ar] = dr, {
        tile: Kr,
        pixel: Rr
      } = m(k).latLonToTileAndPixel(ar, Ar, u.tileZoom), Or = Uf({
        tile: Kr,
        pixel: Rr,
        season: u.season
      }), Fr = s.get(Or);
      Fr && (ya.plop.play(), u.hidePixelHover(), s.delete(Or), B.delete(Or), Ge.remove([ar, Ar]), u.crosshair.remove(dr), Gt = !0, Fr.colorIdx === 0 && (kt = !0), xt && Ot.saveAction({
        type: "erase",
        latLons: [dr]
      }, {
        type: "paint",
        latLons: [dr],
        colorIdx: Fr.colorIdx
      })), s.size === 0 && !(ft || Z || v()) && H(T, "pencil")
    }
    H(W, s.size, !0), Gt && !b() ? vt([...s.values()]) : Gt && b() && kt && vt([...B.values()])
  }

  function ot(Ue, xt) {
    const {
      tile: Gt,
      pixel: kt
    } = m(k).latLonToTileAndPixel(Ue[0], Ue[1], u.tileZoom), dr = Uf({
      tile: Gt,
      pixel: kt,
      season: u.season
    }), ar = s.get(dr);
    if (ar) {
      Xt(ar.colorIdx), requestAnimationFrame(() => {
        var Or;
        (Or = document.getElementById(`color-${ar.colorIdx}`)) == null || Or.focus()
      });
      return
    }
    const Ar = window.devicePixelRatio,
      Kr = Math.floor(xt.x * Ar),
      Rr = Math.floor(xt.y * Ar);
    u.hidePixelHover(), P4(u.map, Kr, Rr).then(([Or, Fr, ti]) => {
      const Ai = o0({
        r: Or,
        g: Fr,
        b: ti
      });
      Xt(Ai), requestAnimationFrame(() => {
        var bi;
        (bi = document.getElementById(`color-${Ai}`)) == null || bi.focus()
      })
    })
  }
  ho(() => m(z), () => {
    u.clickedLatLon && !m(_e) && (m(z) === void 0 && H(z, 1), Et([u.clickedLatLon], m(z)))
  }), oi(() => {
    const Ue = m($) ? .8 : 0;
    u.crosshair.setCanvasOpacity(Ue)
  });
  let Ht = Ke(16.5);
  oi(() => {
    if (m(Xe) && m(Ae) && u.clickedLatLon) {
      const Ue = u.map.getZoom();
      if (Ue < m(Ht)) {
        const [xt, Gt] = u.clickedLatLon, kt = m(k).latLonToPixelBoundsLatLon(xt, Gt, u.tileZoom), dr = ig(kt), ar = m(Xe) - m(Ae).clientHeight, Ar = m(Xe) / 2 - ar / 2;
        u.map.flyTo({
          center: {
            lat: dr[0],
            lng: dr[1]
          },
          zoom: 17.5,
          offset: Ue > 11 ? [0, -Ar] : [0, 0]
        })
      }
      H(Ht, u.tileZoom, !0)
    }
  }), $a(() => {
    const Ue = () => {
      !document.hidden && (b() ? vt([...B.values()]) : vt([...s.values()]))
    };
    return document.addEventListener("visibilitychange", Ue), () => document.removeEventListener("visibilitychange", Ue)
  }), oi(() => {
    switch (m(T)) {
      case "pencil":
        u.map.getCanvas().style.cursor = `url('${J6}') 8 8, default`, u.map.setPaintProperty(u.hoverLayerId, "raster-opacity", .4);
        return;
      case "colorpicker":
        u.map.getCanvas().style.cursor = `url('${Y6}') 0 16, default`, u.map.setPaintProperty(u.hoverLayerId, "raster-opacity", 0);
        return;
      case "eraser":
        u.map.getCanvas().style.cursor = `url('${K6}') 2 14, default`, u.map.setPaintProperty(u.hoverLayerId, "raster-opacity", .4);
        return
    }
  }), oi(() => {
    v() ? $t() : pr()
  });
  async function vt(Ue) {
    await K1(Ue), u.refreshPixelArt()
  }
  async function Dt() {
    await tm(), Ge.clear(), u.refreshPixelArt(), u.crosshair.clear()
  }
  async function Rt() {
    await Dt(), pr(), u.map.getCanvas().style.cursor = "default", u.map.setPaintProperty(u.hoverLayerId, "raster-opacity", .4), Ot.clear(), u.onclose()
  }

  function $t() {
    u.map.dragPan.disable(), u.map.touchZoomRotate.disable(), document.documentElement.style.overscrollBehavior = "none"
  }

  function pr() {
    u.map.dragPan.enable(), u.map.touchZoomRotate.enable(), document.documentElement.style.overscrollBehavior = ""
  }

  function Xt(Ue) {
    return Ue >= 32 && H(Le, !0), Lt.hasColor(Ue) ? (ya.smallDropplet.play(), H(z, Ue, !0), H(T, "pencil"), !0) : (ya.smallDropplet.play(), H($e, !0), H(et, Ue, !0), !1)
  }
  q1(Ue => {
    Ue.type === "leave" && m(W) > 0 && Ue.cancel()
  });
  const or = "show-paint-more-than-one-pixel-msg";
  let nt = Ke(!1);
  $a(() => {
    var Ue;
    H(nt, !localStorage.getItem(or) && (((Ue = Lt.data) == null ? void 0 : Ue.pixelsPainted) ?? 0) < 100, !0)
  }), oi(() => {
    m(W) > 1 && (H(nt, !1), localStorage.setItem(or, "false"))
  });
  const rt = "lp";
  $a(() => {
    var xt;
    const Ue = localStorage.getItem(rt);
    if (Ue) try {
      const Gt = JSON.parse(atob(Ue)),
        kt = (Gt == null ? void 0 : Gt.time) ?? 0,
        dr = 60 * 1e3;
      (Gt == null ? void 0 : Gt.userId) !== ((xt = Lt.data) == null ? void 0 : xt.id) && Date.now() - kt < 30 * dr && !y3 && (Nt.error(w2()), Rt())
    } catch (Gt) {
      console.error(Gt)
    }
  });

  function Zt() {
    var xt;
    const Ue = btoa(JSON.stringify({
      userId: (xt = Lt.data) == null ? void 0 : xt.id,
      time: Date.now()
    }));
    localStorage.setItem(rt, Ue)
  }
  class Jt {
    constructor() {
      fi(this, "history", []);
      fi(this, "actionInProgress", !1);
      fi(this, "historyIdx", -1);
      xi(this, qt, Ke(!1));
      xi(this, bt, Ke(!1))
    }
    get canUndo() {
      return m(ir(this, qt))
    }
    set canUndo(xt) {
      H(ir(this, qt), xt, !0)
    }
    get canRedo() {
      return m(ir(this, bt))
    }
    set canRedo(xt) {
      H(ir(this, bt), xt, !0)
    }
    undo() {
      if (this.historyIdx < 0) return;
      const xt = this.history[this.historyIdx];
      if (xt) {
        const Gt = this.mergeActions(xt.undo);
        for (const kt of Gt) this.applyAction(kt)
      }
      this.historyIdx--, this.refreshCanUndoRedo()
    }
    redo() {
      if (this.historyIdx >= this.history.length - 1) return;
      this.historyIdx++;
      const xt = this.history[this.historyIdx];
      if (xt) {
        const Gt = this.mergeActions(xt.redo);
        for (const kt of Gt) this.applyAction(kt)
      }
      this.refreshCanUndoRedo()
    }
    saveAction(xt, Gt) {
      this.actionInProgress || (this.historyIdx < this.history.length - 1 && (this.history = this.history.slice(0, this.historyIdx + 1)), this.actionInProgress = !0, this.historyIdx++, this.history.push({
        redo: [],
        undo: []
      }));
      const kt = this.history[this.historyIdx];
      kt && (kt.redo.push(xt), kt.undo.push(Gt))
    }
    finishAction() {
      this.actionInProgress = !1, this.refreshCanUndoRedo()
    }
    clear() {
      this.history = [], this.actionInProgress = !1, this.historyIdx = -1, this.refreshCanUndoRedo()
    }
    mergeActions(xt) {
      const Gt = {
          type: "erase",
          latLons: []
        },
        kt = new Map;
      for (const ar of xt)
        if (ar.type === "erase") Gt.latLons.push(...ar.latLons);
        else {
          const Ar = kt.get(ar.colorIdx);
          Ar ? Ar.latLons.push(...ar.latLons) : kt.set(ar.colorIdx, {
            type: "paint",
            colorIdx: ar.colorIdx,
            latLons: [...ar.latLons]
          })
        } const dr = [];
      if (Gt.latLons.length > 0 && dr.push(Gt), kt.size > 0)
        for (const ar of kt.values()) dr.push(ar);
      return dr
    }
    applyAction(xt) {
      switch (xt.type) {
        case "paint":
          Et(xt.latLons, xt.colorIdx, !1);
          break;
        case "erase":
          Pt(xt.latLons, !1);
          break
      }
    }
    refreshCanUndoRedo() {
      this.canUndo = this.historyIdx >= 0, this.canRedo = this.historyIdx < this.history.length - 1
    }
  }
  qt = new WeakMap, bt = new WeakMap;
  const Ot = new Jt;
  var mr = zC();
  Mi("keypress", Oo, Ue => {
    switch (Ue.code) {
      case "KeyZ":
        (Ue.ctrlKey || Ue.metaKey) && (Ue.shiftKey ? Ot.redo() : Ot.undo());
        break;
      case "KeyY":
        (Ue.ctrlKey || Ue.metaKey) && Ot.redo()
    }
  });
  var At = Ct(mr),
    Mt = I(At);
  {
    var wt = Ue => {
        Tc(Ue, {
          children: (xt, Gt) => {
            var kt = PC(),
              dr = Ct(kt);
            vy(dr, {
              class: "inline size-5"
            });
            var ar = D(dr);
            Re(Ar => te(ar, ` ${Ar??""}`), [() => I2()]), q(xt, kt)
          },
          $$slots: {
            default: !0
          }
        })
      },
      It = Ue => {
        var xt = Sr(),
          Gt = Ct(xt);
        {
          var kt = ar => {
              Tc(ar, {
                class: "not-touchscreen:hidden",
                children: (Ar, Kr) => {
                  var Rr = MC(),
                    Or = Ct(Rr);
                  rm(Or, {
                    class: "inline size-5"
                  });
                  var Fr = D(Or);
                  Re(ti => te(Fr, ` ${ti??""}`), [() => C2()]), q(Ar, Rr)
                },
                $$slots: {
                  default: !0
                }
              })
            },
            dr = ar => {
              var Ar = Sr(),
                Kr = Ct(Ar);
              {
                var Rr = Fr => {
                    Tc(Fr, {
                      class: "not-touchscreen:hidden",
                      children: (ti, Ai) => {
                        var bi = IC(),
                          Yr = Ct(bi);
                        Yv(Yr, {
                          class: "inline size-5"
                        });
                        var Zr = D(Yr, 1, !0);
                        Re(Ii => te(Zr, Ii), [() => A2()]), q(ti, bi)
                      },
                      $$slots: {
                        default: !0
                      }
                    })
                  },
                  Or = Fr => {
                    var ti = Sr(),
                      Ai = Ct(ti);
                    {
                      var bi = Zr => {
                          Tc(Zr, {
                            class: "touchscreen:hidden",
                            children: (Ii, ki) => {
                              var wi = CC(),
                                Vi = Ct(wi);
                              xy(Vi, {
                                class: "inline size-5"
                              });
                              var Yi = D(Vi),
                                pt = I(Yi, !0);
                              P(Yi);
                              var Ft = D(Yi, 2),
                                zr = I(Ft),
                                Bi = D(zr),
                                Zi = I(Bi, !0);
                              P(Bi), P(Ft);
                              var Ta = D(Ft);
                              Re((Xi, ji, La, Br) => {
                                te(pt, Xi), te(zr, `${ji??""} `), te(Zi, La), te(Ta, ` ${Br??""}`)
                              }, [() => k2(), () => E2(), () => z2(), () => L2()]), q(Ii, wi)
                            },
                            $$slots: {
                              default: !0
                            }
                          })
                        },
                        Yr = Zr => {
                          var Ii = Sr(),
                            ki = Ct(Ii);
                          {
                            var wi = Vi => {
                              Tc(Vi, {
                                class: "bg-warning text-warning-content animate-bounce",
                                children: (Yi, pt) => {
                                  var Ft = AC(),
                                    zr = Ct(Ft);
                                  yl(zr, {
                                    class: "inline size-5"
                                  });
                                  var Bi = D(zr);
                                  Re(Zi => te(Bi, ` ${Zi??""}`), [() => D2()]), q(Yi, Ft)
                                },
                                $$slots: {
                                  default: !0
                                }
                              })
                            };
                            Se(ki, Vi => {
                              m(nt) && Vi(wi)
                            }, !0)
                          }
                          q(Zr, Ii)
                        };
                      Se(Ai, Zr => {
                        m(we) && m(W) === 0 ? Zr(bi) : Zr(Yr, !1)
                      }, !0)
                    }
                    q(Fr, ti)
                  };
                Se(Kr, Fr => {
                  m(xe) ? Fr(Rr) : Fr(Or, !1)
                }, !0)
              }
              q(ar, Ar)
            };
          Se(Gt, ar => {
            m(Fe) ? ar(kt) : ar(dr, !1)
          }, !0)
        }
        q(Ue, xt)
      };
    Se(Mt, Ue => {
      m(Fe) && m(W) === 0 ? Ue(wt) : Ue(It, !1)
    })
  }
  var Ut = D(Mt, 2),
    ut = I(Ut);
  ut.__click = () => H($, !m($));
  var ur = I(ut);
  {
    var br = Ue => {
        iC(Ue, {
          class: "size-4"
        })
      },
      cr = Ue => {
        nC(Ue, {
          class: "size-4"
        })
      };
    Se(ur, Ue => {
      m($) ? Ue(br) : Ue(cr, !1)
    })
  }
  P(ut);
  var jr = D(ut, 2),
    wr = I(jr),
    Nr = I(wr),
    Gr = D(Nr);
  gy(Gr, {
    class: "inline",
    fontSize: 14,
    get value() {
      return `(${m(W)??""})`
    },
    mono: !0
  }), P(wr);
  var er = D(wr, 2),
    Wr = I(er),
    sr = I(Wr);
  vi(), P(Wr);
  var de = D(Wr, 2);
  de.__click = () => {
    H(T, "colorpicker")
  };
  var j = I(de);
  Yv(j, {
    class: "size-4.5"
  }), P(de), P(er);
  var V = D(er, 2),
    X = I(V);
  let re;
  X.__click = () => {
    b(!b())
  };
  var Q = I(X);
  {
    let Ue = mt(() => !b());
    yy(Q, {
      class: "size-4.5",
      get filled() {
        return m(Ue)
      }
    })
  }
  P(X), P(V);
  var ue = D(V, 2),
    Te = I(ue),
    be = I(Te);
  vi(), P(Te);
  var ze = D(Te, 2);
  let We;
  ze.__click = () => {
    Ot.undo()
  };
  var Be = I(ze);
  SC(Be, {
    class: "size-4.5"
  }), P(ze), P(ue);
  var ae = D(ue, 2),
    J = I(ae),
    Ve = I(J);
  vi(), P(J);
  var tt = D(J, 2);
  let Ze;
  tt.__click = () => {
    Ot.redo()
  };
  var ne = I(tt);
  bC(ne, {
    class: "size-4.5"
  }), P(tt), P(ae), P(jr);
  var Ce = D(jr, 2);
  Ce.__click = () => {
    ya.smallPlop.play(), Rt()
  };
  var He = I(Ce);
  Ls(He, {
    class: "size-4"
  }), P(Ce), P(Ut);
  var ht = D(Ut, 2),
    Tt = I(ht);
  na(Tt, 23, () => m(qe), Ue => Ue.idx, (Ue, xt, Gt) => {
    const kt = mt(() => {
        const [ti, Ai, bi] = m(xt).rgb;
        return {
          r: ti,
          g: Ai,
          b: bi
        }
      }),
      dr = mt(() => m(z) === m(xt).idx && m(we)),
      ar = mt(() => m(xt).idx === 0),
      Ar = mt(() => Lt.hasColor(m(xt).idx));
    var Kr = EC(),
      Rr = I(Kr);
    Rr.__click = () => {
      Xt(m(xt).idx)
    };
    var Or = I(Rr);
    {
      var Fr = ti => {
        var Ai = kC(),
          bi = Ct(Ai);
        Rm(bi, {
          class: "center-absolute absolute size-4 opacity-30 sm:hidden sm:size-6"
        });
        var Yr = D(bi, 2),
          Zr = I(Yr);
        Rm(Zr, {
          class: "text-base-content/80 size-4"
        }), P(Yr), q(ti, Ai)
      };
      Se(Or, ti => {
        m(Ar) || ti(Fr)
      })
    }
    P(Rr), P(Kr), Re(() => {
      Vr(Kr, 1, jo({
        tooltip: !0,
        "max-sm:h-6": m(Le),
        "max-sm:before:translate-x-1/4": m(Gt) % 8 === 0 && m(xt).label.length > 7,
        "max-sm:before:-translate-x-1/4": (m(Gt) - 7) % 8 === 0 && m(xt).label.length > 7,
        "max-xl:before:translate-x-1/4": m(Gt) % 16 === 0 && m(xt).label.length > 7,
        "max-xl:before:-translate-x-1/4": (m(Gt) - 15) % 16 === 0 && m(xt).label.length > 7,
        "xl:before:translate-x-1/4": m(Le) && m(Gt) % 32 === 0 && m(xt).label.length > 7,
        "xl:before:-translate-x-1/4": m(Le) && (m(Gt) - 31) % 32 === 0 && m(xt).label.length > 7
      })), Qt(Kr, "data-tip", m(xt).label), Vr(Rr, 1, jo({
        "btn relative aspect-square w-full rounded-xl": !0,
        "border-primary ring-primary ring-2": m(dr),
        "border-base-300": !m(dr) && m(ar),
        "border-base-content/20": !m(dr) && !m(ar),
        "max-sm:h-6 max-sm:rounded-md": m(Le)
      })), uo(Rr, m(ar) ? `background-image: url(${Q6}); background-size: cover; image-rendering: pixelated;` : `background: rgb(${m(kt).r} ${m(kt).g} ${m(kt).b})`), Qt(Rr, "aria-label", m(xt).label), Qt(Rr, "id", `color-${m(xt).idx??""}`)
    }), Mi("focus", Rr, () => {
      m(Ar) && (H(z, m(xt).idx, !0), H(T, "pencil"))
    }), q(Ue, Kr)
  }), P(Tt), P(ht);
  var dt = D(ht, 2),
    St = I(dt);
  St.__click = () => {
    H(Le, !m(Le))
  };
  var jt = I(St);
  {
    var je = Ue => {
        Q1(Ue, {
          class: "size-5"
        })
      },
      yt = Ue => {
        eb(Ue, {
          class: "size-5"
        })
      };
    Se(jt, Ue => {
      m(Le) ? Ue(je) : Ue(yt, !1)
    })
  }
  P(St);
  var Kt = D(St, 2),
    Cr = I(Kt);
  {
    let Ue = mt(() => m(W) > 100 ? "animate-pulse" : ""),
      xt = mt(() => m(W) === 0 || m(ee) || m(me) < 0);
    _y(Cr, {
      get class() {
        return m(Ue)
      },
      get charges() {
        return m(me)
      },
      get disabled() {
        return m(xt)
      },
      get loading() {
        return m(ee)
      },
      onclick: async () => {
        ya.droppletAndPlop.play();
        const Gt = [...s.values()];
        H(ee, !0);
        try {
          const kt = await og();
          await ui.paint(Gt, kt), await Zm(Gt), Zt(), Lt.refresh(), cp.shouldReload = !0, await Rt()
        } catch (kt) {
          Nt.error(`${kt.message}`, {
            duration: 7e3
          })
        } finally {
          H(ee, !1)
        }
      }
    })
  }
  P(Kt);
  var fr = D(Kt, 2),
    Je = I(fr),
    tr = I(Je),
    Yt = I(tr);
  vi(), P(tr);
  var Tr = D(tr, 2);
  let Dr;
  Tr.__click = () => {
    H(T, m(T) === "eraser" ? "pencil" : "eraser", !0)
  };
  var Jr = I(Tr);
  rm(Jr, {
    class: "size-5",
    get filled() {
      return m(Fe)
    }
  }), P(Tr), P(Je), P(fr), P(dt), P(At), Rn(At, Ue => H(Ae, Ue), () => m(Ae));
  var yr = D(At, 2);
  fC(yr, {
    get colorIdx() {
      return m(et)
    },
    get open() {
      return m($e)
    },
    set open(Ue) {
      H($e, Ue, !0)
    }
  }), Re((Ue, xt, Gt, kt, dr, ar) => {
    te(Nr, `${Ue??""} `), te(sr, `${xt??""} `), Vr(de, 1, jo({
      "btn btn-circle btn-sm": !0,
      "btn-ghost": !m(xe),
      "btn-primary": m(xe)
    })), Qt(V, "data-tip", Gt), re = Vr(X, 1, "btn btn-sm btn-circle btn-ghost text-base-content/80", null, re, {
      "text-primary": !b()
    }), te(be, `${kt??""} `), We = Vr(ze, 1, "btn btn-sm btn-circle btn-ghost text-base-content/80", null, We, {
      "opacity-50": !Ot.canUndo
    }), ze.disabled = !Ot.canUndo, te(Ve, `${dr??""} `), Ze = Vr(tt, 1, "btn btn-sm btn-circle btn-ghost text-base-content/80", null, Ze, {
      "opacity-50": !Ot.canRedo
    }), tt.disabled = !Ot.canRedo, Vr(Tt, 1, jo({
      "md:grid-cols-16 min-[100rem]:grid-cols-32 grid grid-cols-8": !0,
      "xl:grid-cols-32 sm:grid-cols-16 gap-0.5 sm:gap-1": m(Le),
      "gap-1": !m(Le)
    })), te(Yt, `${ar??""} `), Dr = Vr(Tr, 1, "btn btn-lg btn-square sm:btn-xl shadow-md", null, Dr, {
      "btn-primary": m(Fe)
    }), Tr.disabled = m(W) === 0
  }, [() => T2(), () => S2(), () => g0(), () => P2(), () => M2(), () => r3()]), Ch("innerHeight", Ue => H(Xe, Ue, !0)), q(y, mr), ii()
}
$i(["click"]);
var DC = he('<dialog class="modal"><div class="modal-box max-h-11/12"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2"></button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form class="mt-3 w-full"><p class="whitespace-pre-wrap"><!></p> <div class="mt-4"><!></div> <div class="mt-2 flex justify-end gap-2"><button class="btn btn-soft tooltip" type="button"> </button> <button class="btn btn-primary" type="submit"> </button></div></form></div></dialog>');

function RC(y, u) {
  ri(u, !0);
  let v = rr(u, "open", 15),
    b = Ke(!1),
    k = Ke("");
  var z = DC(),
    T = I(z),
    s = D(I(T), 2),
    B = I(s, !0);
  P(s);
  var W = D(s, 2),
    ee = I(W),
    $ = I(ee);
  Ap($, () => R2()), P(ee);
  var oe = D(ee, 2),
    me = I(oe);
  {
    let xe = mt(() => q2()),
      $e = mt(() => V2());
    l0(me, {
      get label() {
        return m(xe)
      },
      get placeholder() {
        return m($e)
      },
      min: 1,
      max: 2056,
      class: "h-32",
      get disabled() {
        return m(b)
      },
      get value() {
        return m(k)
      },
      set value(et) {
        H(k, et, !0)
      }
    })
  }
  P(oe);
  var _e = D(oe, 2),
    Z = I(_e);
  Z.__click = () => {
    v(!1)
  };
  var Ie = I(Z, !0);
  P(Z);
  var we = D(Z, 2),
    Fe = I(we, !0);
  P(we), P(_e), P(W), P(T), P(z), Ya(z, () => xe => {
    oi(() => {
      v() ? xe.show() : xe.close()
    })
  }), Re((xe, $e, et) => {
    te(B, xe), Z.disabled = m(b), te(Ie, $e), we.disabled = m(b) || m(k).length <= 1, te(Fe, et)
  }, [() => u.userData.banned ? n3() : F2(), () => co(), () => B2()]), Mi("close", z, () => v(!1)), Mi("submit", W, async () => {
    try {
      if (H(b, !0), await ui.submitBanAppeal(m(k)) === 208) {
        Nt.error(O2());
        return
      }
      Nt.success(j2()), v(!1)
    } catch (xe) {
      Nt.error(xe.message, {
        duration: 5e3
      })
    } finally {
      H(b, !1)
    }
  }), q(y, z), ii()
}
$i(["click"]);
var FC = he("<span> </span>");

function Kv(y, u) {
  ri(u, !0);
  var v = FC(),
    b = I(v, !0);
  P(v), Re(() => {
    Vr(v, 1, `size-4 items-center justify-center rounded-full bg-red-500 font-semibold text-red-50 ${u.count<10?"text-xs":"text-[10px]"} ${u.class??""}`), te(b, u.count < 10 ? u.count : "9+")
  }), q(y, v), ii()
}
var BC = he('<p class="text-error mt-1 text-sm"> </p>'),
  OC = he('<span class="loading loading-spinner center-absolute absolute"></span>'),
  jC = he('<dialog class="modal bg-black/80!"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2"></button></form> <div class="flex items-center gap-2"><!> <h3 class="text-lg font-bold"> </h3></div> <p class="mt-4"><b> </b> </p> <p class="mt-2"> </p> <div class="rounded-box border-base-content/20 mt-6 w-full border py-1.5 text-center"> </div> <input class="input input-bordered mt-2 w-full" type="text"/> <!> <div class="mt-6 flex justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-error relative"> <!></button></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>');

function qC(y, u) {
  ri(u, !0);
  let v = rr(u, "open", 15),
    b = Ke(""),
    k = Ke(null),
    z = Ke(!1),
    T = mt(() => {
      var Pt;
      return ((Pt = Lt.data) == null ? void 0 : Pt.name) ?? ""
    });
  oi(() => {
    v() || (H(b, ""), H(k, null))
  });
  var s = jC(),
    B = I(s),
    W = D(I(B), 2),
    ee = I(W);
  Y5(ee, {
    class: "text-error size-5"
  });
  var $ = D(ee, 2),
    oe = I($, !0);
  P($), P(W);
  var me = D(W, 2),
    _e = I(me),
    Z = I(_e, !0);
  P(_e);
  var Ie = D(_e);
  P(me);
  var we = D(me, 2),
    Fe = I(we);
  P(we);
  var xe = D(we, 2),
    $e = I(xe, !0);
  P(xe);
  var et = D(xe, 2);
  Xa(et);
  var Xe = D(et, 2);
  {
    var Ae = Pt => {
      var ot = BC(),
        Ht = I(ot, !0);
      P(ot), Re(() => te(Ht, m(k))), q(Pt, ot)
    };
    Se(Xe, Pt => {
      m(k) && Pt(Ae)
    })
  }
  var De = D(Xe, 2),
    Ye = I(De);
  Ye.__click = () => {
    v(!1)
  };
  var Le = I(Ye, !0);
  P(Ye);
  var qe = D(Ye, 2);
  qe.__click = async () => {
    if (m(b) !== m(T)) {
      H(k, Z1(), !0);
      return
    }
    try {
      H(z, !0), await ui.deleteMe(m(T)), Nt.warning(Z2()), await Lt.logout(), v(!1)
    } catch (Pt) {
      Nt.error(Pt.message)
    } finally {
      H(z, !1)
    }
  };
  var _t = I(qe),
    Qe = D(_t);
  {
    var Ge = Pt => {
      var ot = OC();
      q(Pt, ot)
    };
    Se(Qe, Pt => {
      m(z) && Pt(Ge)
    })
  }
  P(qe), P(De), P(B);
  var ft = D(B, 2),
    Vt = I(ft),
    Et = I(Vt, !0);
  P(Vt), P(ft), P(s), Ya(s, () => Pt => {
    oi(() => {
      v() ? Pt.show() : Pt.close()
    })
  }), Re((Pt, ot, Ht, vt, Dt, Rt, $t, pr, Xt) => {
    te(oe, Pt), te(Z, ot), te(Ie, ` ${Ht??""}`), te(Fe, `${vt??""} ${Dt??""}`), te($e, m(T)), Qt(et, "placeholder", Rt), te(Le, $t), qe.disabled = m(z), te(_t, `${pr??""} `), te(Et, Xt)
  }, [() => am(), () => N2(), () => U2(), () => G2(), () => W2(), () => H2(), () => Rc(), () => am(), () => co()]), Mi("close", s, () => v(!1)), vl(et, () => m(b), Pt => H(b, Pt)), q(y, s), ii()
}
$i(["click"]);
var VC = he('<p class="text-base-content/80 text-sm"> </p>'),
  ZC = he('<span class="loading loading-spinner center-absolute absolute"></span>'),
  NC = he('<h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <p class="mt-4"> </p> <!> <div class="mt-4 flex justify-end gap-2"><form method="dialog"><button class="btn btn-soft"> </button></form> <button> <!></button></div>', 1);

function UC(y, u) {
  ri(u, !0);
  let v = rr(u, "open", 15),
    b = rr(u, "type", 3, "confirmation"),
    k = rr(u, "buttonText", 19, () => M0()),
    z = Ke(!1);
  hg(y, {
    dialogClass: "!bg-black/80",
    get open() {
      return v()
    },
    set open(T) {
      v(T)
    },
    children: (T, s) => {
      var B = NC(),
        W = Ct(B),
        ee = I(W, !0);
      P(W);
      var $ = D(W, 2),
        oe = I($, !0);
      P($);
      var me = D($, 2);
      {
        var _e = De => {
          var Ye = VC(),
            Le = I(Ye, !0);
          P(Ye), Re(() => te(Le, u.subDescription)), q(De, Ye)
        };
        Se(me, De => {
          u.subDescription && De(_e)
        })
      }
      var Z = D(me, 2),
        Ie = I(Z),
        we = I(Ie),
        Fe = I(we, !0);
      P(we), P(Ie);
      var xe = D(Ie, 2);
      let $e;
      xe.__click = async () => {
        try {
          H(z, !0), v(await u.onConfirm())
        } finally {
          H(z, !1)
        }
      };
      var et = I(xe),
        Xe = D(et);
      {
        var Ae = De => {
          var Ye = ZC();
          q(De, Ye)
        };
        Se(Xe, De => {
          m(z) && De(Ae)
        })
      }
      P(xe), P(Z), Re(De => {
        te(ee, u.title), te(oe, u.description), te(Fe, De), $e = Vr(xe, 1, "btn relative", null, $e, {
          "btn-error": b() === "warning",
          "btn-primary": b() === "confirmation"
        }), xe.disabled = m(z), te(et, `${k()??""} `)
      }, [() => Rc()]), q(T, B)
    },
    $$slots: {
      default: !0
    }
  }), ii()
}
$i(["click"]);

function GC(y, u) {
  ri(u, !0);
  let v = rr(u, "open", 15);
  {
    let b = mt(() => v0()),
      k = mt(() => $2()),
      z = mt(() => X2());
    UC(y, {
      type: "warning",
      get title() {
        return m(b)
      },
      get description() {
        return m(k)
      },
      get subDescription() {
        return m(z)
      },
      onConfirm: async () => {
        try {
          return await ui.deleteSessions(), Nt.success(D5()), await Lt.logout(), !0
        } catch {
          return Nt.error(R5()), !1
        }
      },
      get open() {
        return v()
      },
      set open(T) {
        v(T)
      }
    })
  }
  ii()
}
var WC = he('<div class="mt-1 flex w-full justify-center"><span class="badge badge-primary badge-sm"> </span></div>'),
  HC = he('<div class="mt-1 flex w-full justify-center"><span class="badge badge-primary badge-sm"> </span></div>'),
  $C = he('<button type="button"><div class="flex flex-1 flex-col items-center justify-center gap-1"><div class="relative"><div class="relative flex size-16 items-center justify-center overflow-hidden rounded-full"><img class="pointer-events-none absolute inset-0 rounded-full object-cover"/></div></div></div> <div class="mt-1 flex w-full flex-col items-center text-center"><span class="line-clamp-1 w-full text-xs font-medium"> </span> <span class="text-base-content/70 mt-0.5 w-full text-[11px]"> </span></div> <!></button>'),
  XC = he('<div class="flex gap-2"><div class="bg-base-200 aspect-square rounded-lg p-4"><div class="relative"><!></div></div> <div class="bg-base-200 flex flex-col items-center justify-center gap-4 rounded-lg p-2"><div class="relative"><!></div> <div class="relative"><!></div></div></div>'),
  YC = he('<span class="loading loading-spinner"></span>'),
  KC = he('<dialog class="modal"><div class="modal-box max-h-11/12 max-w-2xl"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2"></button></form> <h3 class="text-lg font-bold"> </h3> <p class="text-base-content/80 mb-3 text-sm"> </p> <div class="grid grow grid-cols-1 gap-4 sm:grid-cols-[1fr_auto]"><section class="overflow-y-auto"><h4 class="text-base-content/80 mb-2 text-sm font-semibold"> </h4> <div class="grid grid-cols-2 gap-3 sm:grid-cols-3"><button type="button"><div class="flex flex-1 flex-col items-center justify-center gap-1"><div class="text-base-content/60 border-base-content/60 flex size-16 items-center justify-center rounded-full border text-xs font-semibold"> </div></div> <div class="mt-1 flex w-full flex-col items-center text-center"><span class="line-clamp-1 w-full text-xs font-medium"> </span> <span class="text-base-content/70 mt-0.5 w-full text-[11px]"> </span></div> <!></button> <!></div> <h4 class="text-base-content/80 mb-2 mt-4 text-sm font-semibold"> </h4> <span class="text-base-content/70 text-xs"> </span> <p class="sm:pt-10"></p></section> <section class="flex flex-col justify-between"><div><h4 class="text-base-content/80 mb-2 text-sm font-semibold"> </h4> <!></div> <div class="mt-4 flex justify-end"><button type="button" class="btn mr-2"> </button> <button type="button" class="btn btn-primary"><!></button></div></section></div></div></dialog>');

function JC(y, u) {
  ri(u, !0);
  let v = rr(u, "open", 15),
    b = Ke(_a([]));
  const k = _a(Lt.data);
  let z = Ke(!1),
    T = Ke(null);
  oi(() => {
    k && k.equippedFrameId !== void 0 && m(T) === null && H(T, k.equippedFrameId || 0, !0)
  });

  function s(Mt) {
    m(z) || H(T, Mt, !0)
  }
  async function B() {
    if (!(m(z) || m(T) === null)) {
      H(z, !0);
      try {
        await ui.postEquipUserFrame(m(T)), await Lt.refresh(), Nt.success(aw())
      } catch {
        Nt.error(nw())
      } finally {
        H(z, !1)
      }
    }
  }

  function W(Mt) {
    if (Mt === null || Mt === 0) return !1;
    const wt = m(b).find(It => It.id === Mt);
    return wt ? !!wt.value && wt.value > 0 : !1
  }
  $a(async () => {
    try {
      H(b, await ui.getUserFrames(), !0), H(T, k.equippedFrameId || 0, !0)
    } catch {
      Nt.error(s3())
    }
  });
  var ee = KC(),
    $ = I(ee),
    oe = I($),
    me = I(oe);
  me.__click = () => {
    v(!1)
  }, P(oe);
  var _e = D(oe, 2),
    Z = I(_e, !0);
  P(_e);
  var Ie = D(_e, 2),
    we = I(Ie, !0);
  P(Ie);
  var Fe = D(Ie, 2),
    xe = I(Fe),
    $e = I(xe),
    et = I($e, !0);
  P($e);
  var Xe = D($e, 2),
    Ae = I(Xe);
  Ae.__click = () => s(0);
  var De = I(Ae),
    Ye = I(De),
    Le = I(Ye, !0);
  P(Ye), P(De);
  var qe = D(De, 2),
    _t = I(qe),
    Qe = I(_t, !0);
  P(_t);
  var Ge = D(_t, 2),
    ft = I(Ge, !0);
  P(Ge), P(qe);
  var Vt = D(qe, 2);
  {
    var Et = Mt => {
      var wt = WC(),
        It = I(wt),
        Ut = I(It, !0);
      P(It), P(wt), Re(ut => te(Ut, ut), [() => gv()]), q(Mt, wt)
    };
    Se(Vt, Mt => {
      m(T) === 0 && Mt(Et)
    })
  }
  P(Ae);
  var Pt = D(Ae, 2);
  na(Pt, 17, () => m(b), Mt => Mt.id, (Mt, wt) => {
    var It = $C();
    It.__click = () => s(m(wt).id);
    var Ut = I(It),
      ut = I(Ut),
      ur = I(ut),
      br = I(ur);
    P(ur), P(ut), P(Ut);
    var cr = D(Ut, 2),
      jr = I(cr),
      wr = I(jr, !0);
    P(jr);
    var Nr = D(jr, 2),
      Gr = I(Nr, !0);
    P(Nr), P(cr);
    var er = D(cr, 2);
    {
      var Wr = sr => {
        var de = HC(),
          j = I(de),
          V = I(j, !0);
        P(j), P(de), Re(X => te(V, X), [() => gv()]), q(sr, de)
      };
      Se(er, sr => {
        m(T) === m(wt).id && sr(Wr)
      })
    }
    P(It), Re(() => {
      Vr(It, 1, `bg-base-200/80 hover:bg-base-300 group flex h-40 flex-col items-center justify-between rounded-lg p-3 text-xs
									transition disabled:opacity-50
									${m(T)===m(wt).id?" border-primary bg-primary/10":""}`), It.disabled = m(z), Qt(br, "src", m(wt).imageUrl), Qt(br, "alt", m(wt).name), te(wr, m(wt).name), te(Gr, m(wt).description)
    }), q(Mt, It)
  }), P(Xe);
  var ot = D(Xe, 2),
    Ht = I(ot, !0);
  P(ot);
  var vt = D(ot, 2),
    Dt = I(vt, !0);
  P(vt), vi(2), P(xe);
  var Rt = D(xe, 2),
    $t = I(Rt),
    pr = I($t),
    Xt = I(pr, !0);
  P(pr);
  var or = D(pr, 2);
  Ec(or, () => m(T), Mt => {
    const wt = mt(() => m(b).find(Gr => Gr.id === m(T)));
    var It = XC(),
      Ut = I(It),
      ut = I(Ut),
      ur = I(ut);
    {
      let Gr = mt(() => {
        var er;
        return (er = m(wt)) == null ? void 0 : er.imageUrl
      });
      Dn(ur, {
        class: "size-20",
        get userId() {
          return k.id
        },
        get pictureUrl() {
          return k.picture
        },
        get borderUrl() {
          return m(Gr)
        }
      })
    }
    P(ut), P(Ut);
    var br = D(Ut, 2),
      cr = I(br),
      jr = I(cr);
    {
      let Gr = mt(() => {
        var er;
        return (er = m(wt)) == null ? void 0 : er.imageUrl
      });
      Dn(jr, {
        class: "size-10",
        get userId() {
          return k.id
        },
        get pictureUrl() {
          return k.picture
        },
        get borderUrl() {
          return m(Gr)
        }
      })
    }
    P(cr);
    var wr = D(cr, 2),
      Nr = I(wr);
    {
      let Gr = mt(() => {
        var er;
        return (er = m(wt)) == null ? void 0 : er.imageUrl
      });
      Dn(Nr, {
        class: "size-5",
        get userId() {
          return k.id
        },
        get pictureUrl() {
          return k.picture
        },
        get borderUrl() {
          return m(Gr)
        }
      })
    }
    P(wr), P(br), P(It), q(Mt, It)
  }), P($t);
  var nt = D($t, 2),
    rt = I(nt);
  rt.__click = () => {
    v(!1)
  };
  var Zt = I(rt, !0);
  P(rt);
  var Jt = D(rt, 2);
  Jt.__click = B;
  var Ot = I(Jt);
  {
    var mr = Mt => {
        var wt = YC();
        q(Mt, wt)
      },
      At = Mt => {
        var wt = Sr(),
          It = Ct(wt);
        {
          var Ut = ur => {
              var br = Ba();
              Re(cr => te(br, cr), [() => sw()]), q(ur, br)
            },
            ut = ur => {
              var br = Ba();
              Re(cr => te(br, cr), [() => y0()]), q(ur, br)
            };
          Se(It, ur => {
            W(m(T)) ? ur(Ut) : ur(ut, !1)
          }, !0)
        }
        q(Mt, wt)
      };
    Se(Ot, Mt => {
      m(z) ? Mt(mr) : Mt(At, !1)
    })
  }
  P(Jt), P(nt), P(Rt), P(Fe), P($), P(ee), Ya(ee, () => Mt => {
    oi(() => {
      v() ? Mt.showModal() : Mt.close()
    })
  }), Re((Mt, wt, It, Ut, ut, ur, br, cr, jr, wr) => {
    te(Z, Mt), te(we, wt), te(et, It), Vr(Ae, 1, `bg-base-200/80 hover:bg-base-300 group flex h-40 flex-col items-center justify-between rounded-lg p-3 text-xs
								transition disabled:opacity-50
								${m(T)===0?" border-primary bg-primary/10":""}`), Ae.disabled = m(z), te(Le, Ut), te(Qe, ut), te(ft, ur), te(Ht, br), te(Dt, cr), te(Xt, jr), rt.disabled = m(z), te(Zt, wr), Jt.disabled = m(z) || m(T) === null
  }, [() => Y2(), () => K2(), () => J2(), () => Q2(), () => ew(), () => tw(), () => rw(), () => iw(), () => i3(), () => Rc()]), Mi("close", ee, () => v(!1)), q(y, ee), ii()
}
$i(["click"]);
var QC = he('<img alt="Frame equipado" class="h-30 w-30 pointer-events-none absolute inset-0 select-none"/>'),
  eA = he('<span class="center-absolute loading loading-spinner absolute"></span>'),
  tA = he('<button type="button" class="relative hover:brightness-95 disabled:opacity-50"><!> <!></button>'),
  rA = he('<span class="center-absolute loading loading-spinner absolute"></span>'),
  iA = he('<button type="button" class="relative hover:brightness-95 disabled:opacity-50"><!> <!></button>'),
  aA = he('<div><div class="text-base-content/80 text-sm"> </div> <div class="mt-2 grid grid-cols-3 gap-2"><!> <!></div></div>'),
  nA = he('<a class="btn border-0 bg-[#5865F2] text-white"><!> </a>'),
  sA = he('<button class="btn btn-error btn-soft"><!> </button>'),
  oA = he('<dialog class="modal" closedby="any"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2"></button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form class="mt-3 w-full"><div class="flex flex-col gap-6 sm:flex-row"><div class="sm:min-w-34 flex items-center justify-center gap-6 sm:flex-col sm:gap-3"><div class="relative flex w-max items-center gap-2"><div class="relative w-max"><!> <!> <a class="tooltip btn btn-circle tooltip-right absolute -bottom-1 -right-1 max-sm:overflow-x-hidden" href="/profile-picture"><!></a></div> <button type="button" class="tooltip btn btn-circle btn-soft tooltip-bottom absolute -bottom-1 -left-1 before:translate-x-1/3"><span class="text-lg"></span></button></div> <!></div> <div class="flex w-full flex-col gap-3"><div class="tooltip tooltip-bottom"><!></div> <!> <label class="label whitespace-pre-line text-sm"><input class="checkbox checkbox-xs" type="checkbox"/> </label></div></div> <div class="col mt-4 flex flex-wrap justify-between gap-2"><div class="dropdown dropdown-top max-sm:dropdown-top col ml-1 mt-4 flex gap-2"><button tabindex="0" class="btn btn-sm btn-soft"> </button> <ul class="dropdown-content menu bg-base-100 z-1 mb-1 w-max gap-0.5 rounded-xl p-2.5 font-medium shadow-sm"><li><button type="button" class="text-error py-2"> </button></li> <li><button type="button" class="text-error py-2"> </button></li></ul></div> <div class="col mt-4 flex gap-2"><button class="btn btn-soft" type="button"> </button> <button class="btn btn-primary" type="submit"> </button></div></div></form></div></dialog> <!> <!> <!>', 1);

function lA(y, u) {
  ri(u, !0);
  let v = rr(u, "open", 15),
    b = Ke(_a(u.userData.name)),
    k = Ke(_a(u.userData.discord)),
    z = Ke(_a(u.userData.showLastPixel)),
    T = Ke(!1),
    s = Ke(void 0),
    B = Ke(!1),
    W = Ke(!1);
  const ee = N1("2025-09_discord_linking");
  let $ = Ke(!!u.userData.discordId),
    oe = Ke(!1),
    me = Ke(void 0),
    _e = Ke(void 0);
  oi(() => {
    H(b, u.userData.name, !0), H(z, u.userData.showLastPixel, !0)
  }), oi(() => {
    v() && !m(s) && ui.getMyProfilePictures().then(er => {
      H(s, er, !0)
    }).catch(er => {
      Nt.error(er.message)
    })
  });
  let Z = Ke(!1);
  async function Ie(er) {
    try {
      H(Z, !0), await ui.changeProfilePicture(er), await Lt.refresh()
    } finally {
      H(Z, !1)
    }
  }
  var we = oA(),
    Fe = Ct(we),
    xe = I(Fe),
    $e = D(I(xe), 2),
    et = I($e, !0);
  P($e);
  var Xe = D($e, 2),
    Ae = I(Xe),
    De = I(Ae),
    Ye = I(De),
    Le = I(Ye),
    qe = I(Le);
  Dn(qe, {
    class: "h-30 w-30 relative",
    get userId() {
      return u.userData.id
    },
    get pictureUrl() {
      return u.userData.picture
    }
  });
  var _t = D(qe, 2);
  {
    var Qe = er => {
      var Wr = QC();
      Re(() => Qt(Wr, "src", u.userData.equippedFrameUrl)), q(er, Wr)
    };
    Se(_t, er => {
      u.userData.equippedFrameUrl && er(Qe)
    })
  }
  var Ge = D(_t, 2),
    ft = I(Ge);
  a0(ft, {
    class: "size-5"
  }), P(Ge), P(Le);
  var Vt = D(Le, 2);
  Vt.__click = () => {
    H(oe, !0)
  }, P(Ye);
  var Et = D(Ye, 2);
  {
    var Pt = er => {
      var Wr = aA(),
        sr = I(Wr),
        de = I(sr, !0);
      P(sr);
      var j = D(sr, 2),
        V = I(j);
      {
        var X = Q => {
          var ue = tA();
          ue.__click = () => {
            Ie()
          };
          var Te = I(ue);
          Dn(Te, {
            class: "size-10 border",
            get userId() {
              return u.userData.id
            }
          });
          var be = D(Te, 2);
          {
            var ze = We => {
              var Be = eA();
              q(We, Be)
            };
            Se(be, We => {
              m(Z) && We(ze)
            })
          }
          P(ue), Re(() => ue.disabled = m(Z)), q(Q, ue)
        };
        Se(V, Q => {
          u.userData.picture && Q(X)
        })
      }
      var re = D(V, 2);
      na(re, 17, () => m(s), Q => Q.id, (Q, ue) => {
        var Te = Sr(),
          be = Ct(Te);
        {
          var ze = We => {
            var Be = iA();
            Be.__click = () => {
              Ie(m(ue).id)
            };
            var ae = I(Be);
            Dn(ae, {
              class: "size-10 border",
              get userId() {
                return u.userData.id
              },
              get pictureUrl() {
                return m(ue).url
              }
            });
            var J = D(ae, 2);
            {
              var Ve = tt => {
                var Ze = rA();
                q(tt, Ze)
              };
              Se(J, tt => {
                m(Z) && tt(Ve)
              })
            }
            P(Be), Re(() => Be.disabled = m(Z)), q(We, Be)
          };
          Se(be, We => {
            u.userData.picture !== m(ue).url && We(ze)
          })
        }
        q(Q, Te)
      }), P(j), P(Wr), Re(Q => te(de, Q), [() => pw()]), q(er, Wr)
    };
    Se(Et, er => {
      var Wr;
      (Wr = m(s)) != null && Wr.length && er(Pt)
    })
  }
  P(De);
  var ot = D(De, 2),
    Ht = I(ot),
    vt = I(Ht);
  {
    let er = mt(() => im()),
      Wr = mt(() => im());
    dm(vt, {
      get label() {
        return m(er)
      },
      get placeholder() {
        return m(Wr)
      },
      min: 1,
      max: 16,
      get value() {
        return m(b)
      },
      set value(sr) {
        H(b, sr, !0)
      },
      get validate() {
        return m(me)
      },
      set validate(sr) {
        H(me, sr, !0)
      }
    })
  }
  P(Ht);
  var Dt = D(Ht, 2);
  {
    var Rt = er => {
        var Wr = Sr(),
          sr = Ct(Wr);
        {
          var de = V => {
              var X = nA(),
                re = I(X);
              pm(re, {
                class: "size-4.5"
              });
              var Q = D(re);
              P(X), Re((ue, Te) => {
                Qt(X, "href", ue), te(Q, ` ${Te??""}`)
              }, [() => U1("/discord/authorize"), () => mw()]), q(V, X)
            },
            j = V => {
              var X = sA();
              X.__click = async () => {
                try {
                  H(T, !0), await ui.unlinkDiscord(), Lt.refresh(), Nt.success(gw()), H($, !1)
                } catch (ue) {
                  Nt.error(ue.message, {
                    duration: 5e3
                  })
                } finally {
                  H(T, !1)
                }
              };
              var re = I(X);
              pm(re, {
                class: "size-4.5"
              });
              var Q = D(re);
              P(X), Re(ue => {
                X.disabled = m(T), te(Q, ` ${ue??""}`)
              }, [() => {
                var ue;
                return _w({
                  username: ((ue = u.userData) == null ? void 0 : ue.discord) ?? ""
                })
              }]), q(V, X)
            };
          Se(sr, V => {
            m($) ? V(j, !1) : V(de)
          })
        }
        q(er, Wr)
      },
      $t = er => {
        {
          let Wr = mt(() => fw());
          dm(er, {
            label: "Discord",
            get placeholder() {
              return m(Wr)
            },
            max: 32,
            get value() {
              return m(k)
            },
            set value(sr) {
              H(k, sr, !0)
            },
            get validate() {
              return m(_e)
            },
            set validate(sr) {
              H(_e, sr, !0)
            }
          })
        }
      };
    Se(Dt, er => {
      ee ? er(Rt) : er($t, !1)
    })
  }
  var pr = D(Dt, 2),
    Xt = I(pr);
  Xa(Xt);
  var or = D(Xt);
  P(pr), P(ot), P(Ae);
  var nt = D(Ae, 2),
    rt = I(nt),
    Zt = I(rt),
    Jt = I(Zt, !0);
  P(Zt);
  var Ot = D(Zt, 2),
    mr = I(Ot),
    At = I(mr);
  At.__click = () => {
    H(W, !0)
  };
  var Mt = I(At, !0);
  P(At), P(mr);
  var wt = D(mr, 2),
    It = I(wt);
  It.__click = () => {
    H(B, !0)
  };
  var Ut = I(It, !0);
  P(It), P(wt), P(Ot), P(rt);
  var ut = D(rt, 2),
    ur = I(ut);
  ur.__click = () => {
    v(!1)
  };
  var br = I(ur, !0);
  P(ur);
  var cr = D(ur, 2),
    jr = I(cr, !0);
  P(cr), P(ut), P(nt), P(Xe), P(xe), P(Fe), Ya(Fe, () => er => {
    oi(() => {
      v() ? er.showModal() : er.close()
    })
  });
  var wr = D(Fe, 2);
  qC(wr, {
    get open() {
      return m(B)
    },
    set open(er) {
      H(B, er, !0)
    }
  });
  var Nr = D(wr, 2);
  GC(Nr, {
    get open() {
      return m(W)
    },
    set open(er) {
      H(W, er, !0)
    }
  });
  var Gr = D(Nr, 2);
  JC(Gr, {
    get open() {
      return m(oe)
    },
    set open(er) {
      H(oe, er, !0)
    }
  }), Re((er, Wr, sr, de, j, V, X, re, Q, ue) => {
    te(et, er), Qt(Ge, "data-tip", Wr), Qt(Vt, "data-tip", sr), Qt(Ht, "data-tip", de), te(or, ` ${j??""}`), te(Jt, V), te(Mt, X), te(Ut, re), ur.disabled = m(T), te(br, Q), cr.disabled = m(T), te(jr, ue)
  }, [() => ow(), () => a3(), () => lw(), () => cw(), () => uw(), () => hw(), () => v0(), () => am(), () => co(), () => y0()]), Mi("close", Fe, () => v(!1)), Mi("submit", Xe, async () => {
    var er;
    try {
      if (!((er = m(me)) != null && er())) return;
      H(T, !0), await ui.updateMe({
        name: m(b),
        showLastPixel: m(z)
      }), Lt.refresh(), Nt.success(dw()), v(!1)
    } catch (Wr) {
      Nt.error(Wr.message, {
        duration: 5e3
      })
    } finally {
      H(T, !1)
    }
  }), gp(Xt, () => m(z), er => H(z, er)), q(y, we), ii()
}
$i(["click"]);
var cA = Xr('<svg><path d="M440-160v-487L216-423l-56-57 320-320 320 320-56 57-224-224v487h-80Z"></path></svg>');

function uA(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = cA();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var hA = Xr('<svg><path d="M480-120q-150 0-255-105T120-480q0-150 105-255t255-105q14 0 27.5 1t26.5 3q-41 29-65.5 75.5T444-660q0 90 63 153t153 63q55 0 101-24.5t75-65.5q2 13 3 26.5t1 27.5q0 150-105 255T480-120Zm0-80q88 0 158-48.5T740-375q-20 5-40 8t-40 3q-123 0-209.5-86.5T364-660q0-20 3-40t8-40q-78 32-126.5 102T200-480q0 116 82 198t198 82Zm-10-270Z"></path></svg>');

function dA(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = hA();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var pA = Xr('<svg><path d="M480-360q50 0 85-35t35-85q0-50-35-85t-85-35q-50 0-85 35t-35 85q0 50 35 85t85 35Zm0 80q-83 0-141.5-58.5T280-480q0-83 58.5-141.5T480-680q83 0 141.5 58.5T680-480q0 83-58.5 141.5T480-280ZM200-440H40v-80h160v80Zm720 0H760v-80h160v80ZM440-760v-160h80v160h-80Zm0 720v-160h80v160h-80ZM256-650l-101-97 57-59 96 100-52 56Zm492 496-97-101 53-55 101 97-57 59Zm-98-550 97-101 59 57-100 96-56-52ZM154-212l101-97 55 53-97 101-59-57Zm326-268Z"></path></svg>');

function fA(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = pA();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var mA = Xr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h280v80H200v560h280v80H200Zm440-160-55-58 102-102H360v-80h327L585-622l55-58 200 200-200 200Z"></path></svg>');

function Jv(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = mA();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var gA = Xr('<svg><path d="M160-200v-80h80v-280q0-83 50-147.5T420-792v-28q0-25 17.5-42.5T480-880q25 0 42.5 17.5T540-820v28q80 20 130 84.5T720-560v280h80v80H160Zm320-300Zm0 420q-33 0-56.5-23.5T400-160h160q0 33-23.5 56.5T480-80ZM320-280h320v-280q0-66-47-113t-113-47q-66 0-113 47t-47 113v280Z"></path></svg>');

function _A(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = gA();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var vA = Xr('<svg><path d="M240-80q-50 0-85-35t-35-85v-120h120v-560l60 60 60-60 60 60 60-60 60 60 60-60 60 60 60-60 60 60 60-60v680q0 50-35 85t-85 35H240Zm480-80q17 0 28.5-11.5T760-200v-560H320v440h360v120q0 17 11.5 28.5T720-160ZM360-600v-80h240v80H360Zm0 120v-80h240v80H360Zm320-120q-17 0-28.5-11.5T640-640q0-17 11.5-28.5T680-680q17 0 28.5 11.5T720-640q0 17-11.5 28.5T680-600Zm0 120q-17 0-28.5-11.5T640-520q0-17 11.5-28.5T680-560q17 0 28.5 11.5T720-520q0 17-11.5 28.5T680-480ZM240-160h360v-80H200v40q0 17 11.5 28.5T240-160Zm-40 0v-80 80Z"></path></svg>');

function yA(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = vA();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var xA = Xr('<svg><defs><radialGradient id="snoo-radial-gragient" cx="169.75" cy="92.19" r="50.98" fx="169.75" fy="92.19" gradientTransform="matrix(1 0 0 .87 0 11.64)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#feffff"></stop><stop offset=".4" stop-color="#feffff"></stop><stop offset=".51" stop-color="#f9fcfc"></stop><stop offset=".62" stop-color="#edf3f5"></stop><stop offset=".7" stop-color="#dee9ec"></stop><stop offset=".72" stop-color="#d8e4e8"></stop><stop offset=".76" stop-color="#ccd8df"></stop><stop offset=".8" stop-color="#c8d5dd"></stop><stop offset=".83" stop-color="#ccd6de"></stop><stop offset=".85" stop-color="#d8dbe2"></stop><stop offset=".88" stop-color="#ede3e9"></stop><stop offset=".9" stop-color="#ffebef"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-2" cx="47.31" r="50.98" fx="47.31"></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-3" cx="109.61" cy="85.59" r="153.78" fx="109.61" fy="85.59" gradientTransform="matrix(1 0 0 .7 0 25.56)"></radialGradient><radialGradient id="snoo-radial-gragient-4" cx="-6.01" cy="64.68" r="12.85" fx="-6.01" fy="64.68" gradientTransform="matrix(1.07 0 0 1.55 81.08 27.26)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#f60"></stop><stop offset=".5" stop-color="#ff4500"></stop><stop offset=".7" stop-color="#fc4301"></stop><stop offset=".82" stop-color="#f43f07"></stop><stop offset=".92" stop-color="#e53812"></stop><stop offset="1" stop-color="#d4301f"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient-4" id="snoo-radial-gragient-5" cx="-73.55" cy="64.68" r="12.85" fx="-73.55" fy="64.68" gradientTransform="matrix(-1.07 0 0 1.55 62.87 27.26)"></radialGradient><radialGradient id="snoo-radial-gragient-6" cx="107.93" cy="166.96" r="45.3" fx="107.93" fy="166.96" gradientTransform="matrix(1 0 0 .66 0 57.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#172e35"></stop><stop offset=".29" stop-color="#0e1c21"></stop><stop offset=".73" stop-color="#030708"></stop><stop offset="1"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-7" cx="147.88" cy="32.94" r="39.77" fx="147.88" fy="32.94" gradientTransform="matrix(1 0 0 .98 0 .54)"></radialGradient><radialGradient id="snoo-radial-gragient-8" cx="131.31" cy="73.08" r="32.6" fx="131.31" fy="73.08" gradientUnits="userSpaceOnUse"><stop offset=".48" stop-color="#7a9299"></stop><stop offset=".67" stop-color="#172e35"></stop><stop offset=".75"></stop><stop offset=".82" stop-color="#172e35"></stop></radialGradient></defs><path fill="#ff4500" stroke-width="0" d="M108 0C48.35 0 0 48.35 0 108c0 29.82 12.09 56.82 31.63 76.37l-20.57 20.57C6.98 209.02 9.87 216 15.64 216H108c59.65 0 108-48.35 108-108S167.65 0 108 0Z"></path><circle cx="169.22" cy="106.98" r="25.22" fill="url(#snoo-radial-gragient)" stroke-width="0"></circle><circle cx="46.78" cy="106.98" r="25.22" fill="url(#snoo-radial-gragient-2)" stroke-width="0"></circle><ellipse cx="108.06" cy="128.64" fill="url(#snoo-radial-gragient-3)" stroke-width="0" rx="72" ry="54"></ellipse><path fill="url(#snoo-radial-gragient-4)" stroke-width="0" d="M86.78 123.48c-.42 9.08-6.49 12.38-13.56 12.38s-12.46-4.93-12.04-14.01c.42-9.08 6.49-15.02 13.56-15.02s12.46 7.58 12.04 16.66Z"></path><path fill="url(#snoo-radial-gragient-5)" stroke-width="0" d="M129.35 123.48c.42 9.08 6.49 12.38 13.56 12.38s12.46-4.93 12.04-14.01c-.42-9.08-6.49-15.02-13.56-15.02s-12.46 7.58-12.04 16.66Z"></path><ellipse cx="79.63" cy="116.37" class="snoo-cls-11 svelte-14mu38d" rx="2.8" ry="3.05"></ellipse><ellipse cx="146.21" cy="116.37" class="snoo-cls-11 svelte-14mu38d" rx="2.8" ry="3.05"></ellipse><path fill="url(#snoo-radial-gragient-6)" stroke-width="0" d="M108.06 142.92c-8.76 0-17.16.43-24.92 1.22-1.33.13-2.17 1.51-1.65 2.74 4.35 10.39 14.61 17.69 26.57 17.69s22.23-7.3 26.57-17.69c.52-1.23-.33-2.61-1.65-2.74-7.77-.79-16.16-1.22-24.92-1.22Z"></path><circle cx="147.49" cy="49.43" r="17.87" fill="url(#snoo-radial-gragient-7)" stroke-width="0"></circle><path fill="url(#snoo-radial-gragient-8)" stroke-width="0" d="M107.8 76.92c-2.14 0-3.87-.89-3.87-2.27 0-16.01 13.03-29.04 29.04-29.04 2.14 0 3.87 1.73 3.87 3.87s-1.73 3.87-3.87 3.87c-11.74 0-21.29 9.55-21.29 21.29 0 1.38-1.73 2.27-3.87 2.27Z"></path><path fill="#842123" stroke-width="0" d="M62.82 122.65c.39-8.56 6.08-14.16 12.69-14.16 6.26 0 11.1 6.39 11.28 14.33.17-8.88-5.13-15.99-12.05-15.99s-13.14 6.05-13.56 15.2c-.42 9.15 4.97 13.83 12.04 13.83h.52c-6.44-.16-11.3-4.79-10.91-13.2Zm90.48 0c-.39-8.56-6.08-14.16-12.69-14.16-6.26 0-11.1 6.39-11.28 14.33-.17-8.88 5.13-15.99 12.05-15.99 7.07 0 13.14 6.05 13.56 15.2.42 9.15-4.97 13.83-12.04 13.83h-.52c6.44-.16 11.3-4.79 10.91-13.2Z"></path></svg>');

function bA(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = xA();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink",
    viewBox: "0 0 216 216",
    ...v
  }), void 0, void 0, void 0, "svelte-14mu38d"), q(y, b)
}
var wA = Xr('<svg><path d="M480-280q17 0 28.5-11.5T520-320q0-17-11.5-28.5T480-360q-17 0-28.5 11.5T440-320q0 17 11.5 28.5T480-280Zm-40-160h80v-240h-80v240ZM330-120 120-330v-300l210-210h300l210 210v300L630-120H330Zm34-80h232l164-164v-232L596-760H364L200-596v232l164 164Zm116-280Z"></path></svg>');

function Fm(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = wA();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var TA = Xr('<svg><path d="M480-440q-59 0-99.5-40.5T340-580q0-59 40.5-99.5T480-720q59 0 99.5 40.5T620-580q0 59-40.5 99.5T480-440Zm0-80q26 0 43-17t17-43q0-26-17-43t-43-17q-26 0-43 17t-17 43q0 26 17 43t43 17Zm0 440q-139-35-229.5-159.5T160-516v-244l320-120 320 120v244q0 152-90.5 276.5T480-80Zm0-400Zm0-315-240 90v189q0 54 15 105t41 96q42-21 88-33t96-12q50 0 96 12t88 33q26-45 41-96t15-105v-189l-240-90Zm0 515q-36 0-70 8t-65 22q29 30 63 52t72 34q38-12 72-34t63-52q-31-14-65-22t-70-8Z"></path></svg>');

function tp(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = TA();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var SA = Xr('<svg><path d="m476-80 182-480h84L924-80h-84l-43-122H603L560-80h-84ZM160-200l-56-56 202-202q-35-35-63.5-80T190-640h84q20 39 40 68t48 58q33-33 68.5-92.5T484-720H40v-80h280v-80h80v80h280v80H564q-21 72-63 148t-83 116l96 98-30 82-122-125-202 201Zm468-72h144l-72-204-72 204Z"></path></svg>');

function PA(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = SA();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var MA = Xr('<svg><path d="M480-320q75 0 127.5-52.5T660-500q0-75-52.5-127.5T480-680q-75 0-127.5 52.5T300-500q0 75 52.5 127.5T480-320Zm0-72q-45 0-76.5-31.5T372-500q0-45 31.5-76.5T480-608q45 0 76.5 31.5T588-500q0 45-31.5 76.5T480-392Zm0 192q-146 0-266-81.5T40-500q54-137 174-218.5T480-800q146 0 266 81.5T920-500q-54 137-174 218.5T480-200Zm0-300Zm0 220q113 0 207.5-59.5T832-500q-50-101-144.5-160.5T480-720q-113 0-207.5 59.5T128-500q50 101 144.5 160.5T480-280Z"></path></svg>');

function IA(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = MA();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var CA = Xr('<svg><path d="m644-428-58-58q9-47-27-88t-93-32l-58-58q17-8 34.5-12t37.5-4q75 0 127.5 52.5T660-500q0 20-4 37.5T644-428Zm128 126-58-56q38-29 67.5-63.5T832-500q-50-101-143.5-160.5T480-720q-29 0-57 4t-55 12l-62-62q41-17 84-25.5t90-8.5q151 0 269 83.5T920-500q-23 59-60.5 109.5T772-302Zm20 246L624-222q-35 11-70.5 16.5T480-200q-151 0-269-83.5T40-500q21-53 53-98.5t73-81.5L56-792l56-56 736 736-56 56ZM222-624q-29 26-53 57t-41 67q50 101 143.5 160.5T480-280q20 0 39-2.5t39-5.5l-36-38q-11 3-21 4.5t-21 1.5q-75 0-127.5-52.5T300-500q0-11 1.5-21t4.5-21l-84-82Zm319 93Zm-151 75Z"></path></svg>');

function by(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = CA();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var AA = Xr('<svg><path d="M792-56 671-177q-25 16-53 27.5T560-131v-82q14-5 27.5-10t25.5-12L480-368v208L280-360H120v-240h128L56-792l56-56 736 736-56 56Zm-8-232-58-58q17-31 25.5-65t8.5-70q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 53-14.5 102T784-288ZM650-422l-90-90v-130q47 22 73.5 66t26.5 96q0 15-2.5 29.5T650-422ZM480-592 376-696l104-104v208Zm-80 238v-94l-72-72H200v80h114l86 86Zm-36-130Z"></path></svg>');

function kA(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = AA();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var EA = Xr('<svg><path d="M560-131v-82q90-26 145-100t55-168q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 127-78 224.5T560-131ZM120-360v-240h160l200-200v640L280-360H120Zm440 40v-322q47 22 73.5 66t26.5 96q0 51-26.5 94.5T560-320ZM400-606l-86 86H200v80h114l86 86v-252ZM300-480Z"></path></svg>');

function zA(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = EA();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var LA = he('<img alt="Frame equipado" class="pointer-events-none absolute inset-0 -bottom-1 -right-1 select-none"/>'),
  DA = he('<span class="tooltip font-flag ml-0.5"> </span>'),
  RA = he('<div class="mt-1"><!></div>'),
  FA = he('<p class="w-full"> <!></p>'),
  BA = he('<p class="w-full"><!></p>'),
  OA = he('<div class=" flex items-center gap-2"><!> <!> <button class="btn btn-error btn-sm"><!> </button></div>'),
  jA = he('<span class="center-absolute loading loading-spinner loading-xs absolute"></span>'),
  qA = he("<li><button><!> </button></li>"),
  VA = he('<div class="tooltip"><button class="btn btn-sm btn-circle"><!></button></div>'),
  ZA = he('<button class="btn btn-sm btn-circle tooltip"><!></button>'),
  NA = he('<button class="btn pwa:hidden w-full sm:hidden"><!> </button>'),
  UA = he('<a class="btn w-full" target="_blank"><!> </a>'),
  GA = he('<a class="btn w-full" target="_blank"><!> </a>'),
  WA = he('<a class="btn w-full" target="_blank"><!> </a>'),
  HA = he('<a class="btn w-full" target="_blank"><!> </a>'),
  $A = he('<form class="w-full" method="POST"><button class="btn w-full"><!> </button></form> <a class="btn w-full" target="_blank"><!> </a>', 1),
  XA = he('<div class="dropdown"><div tabindex="0" role="button"><!> <!></div> <div class="dropdown-content menu bg-base-100 rounded-box border-base-300 z-1 right-1 w-[min(100vw-24px,400px)] translate-y-2 border p-4 shadow-md" tabindex="-1"><button class="btn btn-ghost btn-circle absolute right-2 top-2"><!></button> <section class="flex gap-2"><div class="relative"><!> <!> <button class="btn btn-circle btn-sm absolute -bottom-1 -right-1"><!></button></div> <div><div class="flex items-center gap-1.5 pr-8 text-lg font-medium"><h3 class="line-clamp-1 text-ellipsis text-lg"> </h3> <span> </span> <!> <!></div> <div class="flex items-center gap-1"><!> <span> <span class="text-primary font-semibold"> </span></span></div> <div class="flex items-center gap-1"><!> <span class="text-secondary"><span class="font-semibold"> </span> <button class="tooltip"><!></button></span></div></div></section> <section class="mt-3 flex flex-col gap-2"><!> <div class="mb-1 flex items-center justify-between"><h3 class="text-lg font-semibold"> </h3> <div class="flex items-center gap-2"><div class="dropdown dropdown-end"><div tabindex="0" role="button" class="btn btn-sm btn-circle tooltip"><!></div> <ul tabindex="0" class="dropdown-content menu bg-base-100 z-1 max-h-[50svh] w-max flex-nowrap overflow-y-auto rounded-xl p-2 shadow-sm"></ul></div> <div class="tooltip"><button class="btn btn-sm btn-circle"><!></button></div> <!> <!> <button class="btn btn-sm btn-circle tooltip relative before:-left-1/2"><!> <!></button></div></div>  <!> <!> <!> <!> <!> <a class="btn w-full" href="http://discord.gg/wplacelive" target="_blank"><!> </a> <a class="btn w-full" href="https://www.reddit.com/r/WplaceLive/" target="_blank"><!> </a> <!> <button class="btn"><!> </button></section></div></div> <!>', 1);

function YA(y, u) {
  var _e;
  ri(u, !0);
  let v = Ke(!1),
    b = Ke(!1),
    k = Ke(!0);

  function z() {
    var Z;
    (Z = document.activeElement) == null || Z.blur()
  }
  const T = [{
    label: " English",
    key: "en"
  }, {
    label: " Portugus",
    key: "pt"
  }, ...(_e = u.user.data) != null && _e.role && u.user.data.role !== "user" ? [{
    label: " ",
    key: "ch"
  }, {
    label: " Deutsch",
    key: "de"
  }, {
    label: " Espaol",
    key: "es"
  }, {
    label: " Franais",
    key: "fr"
  }, {
    label: " Italiano",
    key: "it"
  }, {
    label: " ",
    key: "jp"
  }, {
    label: " Polski",
    key: "pl"
  }, {
    label: " ",
    key: "ru"
  }, {
    label: " ",
    key: "uk"
  }, {
    label: " Ting Vit",
    key: "vi"
  }] : []];
  let s = Ke(""),
    B = Ke(void 0);
  const W = mt(() => !!u.user.timeoutUntil);
  let ee = Ke("");
  $a(async () => {
    if (u.user.data || await u.user.refresh(), u.user.hasAnyPermission(za.dashboard.summary)) {
      H(ee, `${ga.url.origin}/dashboard/summary`);
      return
    }
    if (u.user.hasAnyPermission(za.dashboard.team)) {
      H(ee, `${ga.url.origin}/dashboard/team`);
      return
    }
    if (u.user.hasAnyPermission(za.dashboard.users)) {
      H(ee, `${ga.url.origin}/dashboard/users`);
      return
    }
    if (u.user.hasAnyPermission(za.dashboard.permissions)) {
      H(ee, `${ga.url.origin}/dashboard/permissions`);
      return
    }
    if (u.user.hasAnyPermission(za.dashboard.alliances)) {
      H(ee, `${ga.url.origin}/dashboard/alliances`);
      return
    }
    if (u.user.hasAnyPermission(za.dashboard.auditLogs)) {
      H(ee, `${ga.url.origin}/dashboard/audit-logs`);
      return
    }
    if (u.user.hasAnyPermission(za.dashboard.banWaves)) {
      H(ee, `${ga.url.origin}/dashboard/ban-waves`);
      return
    }
  });
  var $ = Sr(),
    oe = Ct($);
  {
    var me = Z => {
      var Ie = XA(),
        we = Ct(Ie),
        Fe = I(we);
      let xe;
      var $e = I(Fe);
      s0($e, {
        get userId() {
          return u.user.data.id
        },
        get level() {
          return u.user.data.level
        },
        get pictureUrl() {
          return u.user.data.picture
        }
      });
      var et = D($e, 2);
      {
        var Xe = qt => {
          Kv(qt, {
            class: "absolute -right-0.5 -top-0.5",
            get count() {
              return u.user.notificiationCount
            }
          })
        };
        Se(et, qt => {
          u.user.notificiationCount && qt(Xe)
        })
      }
      P(Fe);
      var Ae = D(Fe, 2),
        De = I(Ae);
      De.__click = z;
      var Ye = I(De);
      Ls(Ye, {
        class: "size-5"
      }), P(De);
      var Le = D(De, 2),
        qe = I(Le),
        _t = I(qe);
      Dn(_t, {
        get userId() {
          return u.user.data.id
        },
        get pictureUrl() {
          return u.user.data.picture
        },
        get isSuspended() {
          return m(W)
        }
      });
      var Qe = D(_t, 2);
      {
        var Ge = qt => {
          var bt = LA();
          Re(() => Qt(bt, "src", u.user.data.equippedFrameUrl)), q(qt, bt)
        };
        Se(Qe, qt => {
          u.user.data.equippedFrameUrl && qt(Ge)
        })
      }
      var ft = D(Qe, 2);
      ft.__click = () => {
        H(v, !0)
      };
      var Vt = I(ft);
      sm(Vt, {
        class: "size-4"
      }), P(ft), P(qe);
      var Et = D(qe, 2),
        Pt = I(Et),
        ot = I(Pt),
        Ht = I(ot, !0);
      P(ot);
      var vt = D(ot, 2),
        Dt = I(vt);
      P(vt);
      var Rt = D(vt, 2);
      {
        var $t = qt => {
          const bt = mt(() => zs(u.user.data.equippedFlag));
          var Ue = DA(),
            xt = I(Ue, !0);
          P(Ue), Re(() => {
            Qt(Ue, "data-tip", m(bt).name), te(xt, m(bt).flag)
          }), q(qt, Ue)
        };
        Se(Rt, qt => {
          u.user.data.equippedFlag && qt($t)
        })
      }
      var pr = D(Rt, 2);
      {
        var Xt = qt => {
          var bt = RA(),
            Ue = I(bt);
          zh(Ue, {
            get username() {
              return u.user.data.discord
            },
            get id() {
              return u.user.data.discordId
            }
          }), P(bt), q(qt, bt)
        };
        Se(pr, qt => {
          u.user.data.discord && qt(Xt)
        })
      }
      P(Pt);
      var or = D(Pt, 2),
        nt = I(or);
      yl(nt, {
        class: "inline size-4"
      });
      var rt = D(nt, 2),
        Zt = I(rt),
        Jt = D(Zt),
        Ot = I(Jt, !0);
      P(Jt), P(rt), P(or);
      var mr = D(or, 2),
        At = I(mr);
      uA(At, {
        class: "inline size-4"
      });
      var Mt = D(At, 2),
        wt = I(Mt),
        It = I(wt);
      P(wt);
      var Ut = D(wt),
        ut = D(Ut),
        ur = I(ut);
      Ju(ur, {
        class: "mb-0.5 inline size-4 opacity-50"
      }), P(ut), P(Mt), P(mr), P(Et), P(Le);
      var br = D(Le, 2),
        cr = I(br);
      {
        var jr = qt => {
          var bt = OA(),
            Ue = I(bt);
          Fm(Ue, {
            class: "size-6 text-red-500"
          });
          var xt = D(Ue, 2);
          {
            var Gt = Kr => {
                var Rr = FA(),
                  Or = I(Rr),
                  Fr = D(Or);
                {
                  var ti = bi => {
                      var Yr = Ba();
                      Re(Zr => te(Yr, `(${Zr??""})`), [() => _v({
                        reason: G1()
                      })]), q(bi, Yr)
                    },
                    Ai = bi => {
                      var Yr = Sr(),
                        Zr = Ct(Yr);
                      {
                        var Ii = ki => {
                          var wi = Ba();
                          Re(Vi => te(wi, `(${Vi??""})`), [() => _v({
                            reason: H1()
                          })]), q(ki, wi)
                        };
                        Se(Zr, ki => {
                          u.user.data.suspensionReason === "multi-accounting" && ki(Ii)
                        }, !0)
                      }
                      q(bi, Yr)
                    };
                  Se(Fr, bi => {
                    u.user.data.suspensionReason === "bot" ? bi(ti) : bi(Ai, !1)
                  })
                }
                P(Rr), Re(bi => te(Or, `${bi??""} `), [() => Rw()]), q(Kr, Rr)
              },
              kt = Kr => {
                var Rr = Sr(),
                  Or = Ct(Rr);
                {
                  var Fr = ti => {
                    var Ai = BA(),
                      bi = I(Ai);
                    Ap(bi, () => W1({
                      until: `<span class="text-secondary font-medium text-nowrap">${u.user.timeoutUntil.toLocaleString(navigator.language)}</span>`
                    })), P(Ai), q(ti, Ai)
                  };
                  Se(Or, ti => {
                    u.user.timeoutUntil && ti(Fr)
                  }, !0)
                }
                q(Kr, Rr)
              };
            Se(xt, Kr => {
              u.user.data.timeoutUntil && new Date(u.user.data.timeoutUntil).getTime() >= Date.now() + 31536e6 ? Kr(Gt) : Kr(kt, !1)
            })
          }
          var dr = D(xt, 2);
          dr.__click = Kr => {
            var Rr;
            (Rr = u.onbanappeal) == null || Rr.call(u)
          };
          var ar = I(dr);
          Fm(ar, {
            class: "size-5 text-red-500"
          });
          var Ar = D(ar, 1, !0);
          P(dr), P(bt), Re(Kr => te(Ar, Kr), [() => Mw()]), q(qt, bt)
        };
        Se(cr, qt => {
          m(W) && qt(jr)
        })
      }
      var wr = D(cr, 2),
        Nr = I(wr),
        Gr = I(Nr, !0);
      P(Nr);
      var er = D(Nr, 2),
        Wr = I(er),
        sr = I(Wr),
        de = I(sr);
      PA(de, {
        class: "size-4"
      }), P(sr);
      var j = D(sr, 2);
      na(j, 21, () => T, Lc, (qt, bt) => {
        const Ue = mt(() => m(s) === m(bt).key),
          xt = mt(() => e3() === m(bt).key);
        var Gt = qA(),
          kt = I(Gt);
        let dr;
        kt.__click = () => {
          localStorage.setItem(ab, m(bt).key), H(s, m(bt).key, !0), location.reload()
        };
        var ar = I(kt);
        {
          var Ar = Rr => {
            var Or = jA();
            q(Rr, Or)
          };
          Se(ar, Rr => {
            m(Ue) && Rr(Ar)
          })
        }
        var Kr = D(ar);
        P(kt), P(Gt), Re(() => {
          dr = Vr(kt, 1, "font-flag relative font-medium", null, dr, {
            "bg-base-200": m(Ue),
            "bg-base-300": m(xt)
          }), te(Kr, ` ${m(bt).label??""}`)
        }), q(qt, Gt)
      }), P(j), P(Wr);
      var V = D(Wr, 2),
        X = I(V);
      X.__click = () => {
        An.muted = !An.muted
      };
      var re = I(X);
      {
        var Q = qt => {
            kA(qt, {
              class: "size-4"
            })
          },
          ue = qt => {
            zA(qt, {
              class: "size-4"
            })
          };
        Se(re, qt => {
          An.muted ? qt(Q) : qt(ue, !1)
        })
      }
      P(X), P(V);
      var Te = D(V, 2);
      {
        var be = qt => {
          var bt = VA(),
            Ue = I(bt);
          Ue.__click = () => {
            An.theme = An.theme === "dark" ? "custom-winter" : "dark"
          };
          var xt = I(Ue);
          {
            var Gt = dr => {
                fA(dr, {
                  class: "size-4"
                })
              },
              kt = dr => {
                dA(dr, {
                  class: "size-4"
                })
              };
            Se(xt, dr => {
              An.theme === "dark" ? dr(Gt) : dr(kt, !1)
            })
          }
          P(Ue), P(bt), Re(dr => Qt(bt, "data-tip", dr), [() => An.theme === "dark" ? Iw() : Cw()]), q(qt, bt)
        };
        Se(Te, qt => {
          u.user.hasPermission(za.ui.themeDarkMode) && qt(be)
        })
      }
      var ze = D(Te, 2);
      {
        var We = qt => {
          var bt = ZA();
          bt.__click = () => {
            var kt;
            H(k, !m(k)), (kt = u.ontogglepixelarts) == null || kt.call(u, m(k))
          };
          var Ue = I(bt);
          {
            var xt = kt => {
                IA(kt, {
                  class: "size-4"
                })
              },
              Gt = kt => {
                by(kt, {
                  class: "size-4"
                })
              };
            Se(Ue, kt => {
              m(k) ? kt(Gt, !1) : kt(xt)
            })
          }
          P(bt), Re(kt => Qt(bt, "data-tip", kt), [() => m(k) == !1 ? Aw() : kw()]), q(qt, bt)
        };
        Se(ze, qt => {
          u.user.hasPermission(za.ui.tooglePixelArt) && qt(We)
        })
      }
      var Be = D(ze, 2);
      Be.__click = function(...qt) {
        var bt;
        (bt = u.onnotificationclick) == null || bt.apply(this, qt)
      };
      var ae = I(Be);
      _A(ae, {
        class: "size-4"
      });
      var J = D(ae, 2);
      {
        var Ve = qt => {
          Kv(qt, {
            class: "absolute -right-1 -top-1",
            get count() {
              return u.user.notificiationCount
            }
          })
        };
        Se(J, qt => {
          u.user.notificiationCount && qt(Ve)
        })
      }
      P(Be), P(er), P(wr);
      var tt = D(wr, 2);
      {
        var Ze = qt => {
          var bt = NA();
          bt.__click = async () => {
            var Gt;
            try {
              const kt = await ((Gt = m(B)) == null ? void 0 : Gt.prompt());
              (kt == null ? void 0 : kt.outcome) === "accepted" && H(B, void 0)
            } catch (kt) {
              Nt.error(Ew({
                error: kt.message
              }))
            }
          };
          var Ue = I(bt);
          Qm(Ue, {
            class: "size-5"
          });
          var xt = D(Ue);
          P(bt), Re(Gt => te(xt, ` ${Gt??""}`), [() => zw()]), q(qt, bt)
        };
        Se(tt, qt => {
          m(B) && qt(Ze)
        })
      }
      var ne = D(tt, 2);
      {
        var Ce = qt => {
          var bt = UA(),
            Ue = I(bt);
          tp(Ue, {
            class: "size-5"
          });
          var xt = D(Ue);
          P(bt), Re(Gt => {
            Qt(bt, "href", m(ee)), te(xt, ` ${Gt??""}`)
          }, [() => l3()]), q(qt, bt)
        };
        Se(ne, qt => {
          u.user.hasAnyPermission(za.dashboard) && qt(Ce)
        })
      }
      var He = D(ne, 2);
      {
        var ht = qt => {
          var bt = GA(),
            Ue = I(bt);
          tp(Ue, {
            class: "size-5"
          });
          var xt = D(Ue);
          P(bt), Re(Gt => {
            Qt(bt, "href", `${ga.url.origin??""}/tickets`), te(xt, ` ${Gt??""}`)
          }, [() => Lw()]), q(qt, bt)
        };
        Se(He, qt => {
          u.user.hasAnyPermission(za.tickets) && qt(ht)
        })
      }
      var Tt = D(He, 2);
      {
        var dt = qt => {
          var bt = WA(),
            Ue = I(bt);
          tp(Ue, {
            class: "size-5"
          });
          var xt = D(Ue);
          P(bt), Re(Gt => {
            Qt(bt, "href", `${ga.url.origin??""}/appeals`), te(xt, ` ${Gt??""}`)
          }, [() => o3()]), q(qt, bt)
        };
        Se(Tt, qt => {
          u.user.hasAnyPermission(za.appeals) && qt(dt)
        })
      }
      var St = D(Tt, 2);
      {
        var jt = qt => {
          var bt = HA(),
            Ue = I(bt);
          tp(Ue, {
            class: "size-5"
          });
          var xt = D(Ue);
          P(bt), Re(Gt => {
            Qt(bt, "href", `${ga.url.origin??""}/wayback`), te(xt, ` ${Gt??""}`)
          }, [() => Dw()]), q(qt, bt)
        };
        Se(St, qt => {
          u.user.hasAnyPermission(za.tools.wayback) && qt(jt)
        })
      }
      var je = D(St, 2),
        yt = I(je);
      hm(yt, {
        class: "size-5"
      });
      var Kt = D(yt);
      P(je);
      var Cr = D(je, 2),
        fr = I(Cr);
      bA(fr, {
        class: "size-5"
      });
      var Je = D(fr);
      P(Cr);
      var tr = D(Cr, 2);
      {
        var Yt = qt => {
          var bt = $A(),
            Ue = Ct(bt),
            xt = I(Ue),
            Gt = I(xt);
          yA(Gt, {
            class: "size-5"
          });
          var kt = D(Gt);
          P(xt), P(Ue);
          var dr = D(Ue, 2),
            ar = I(dr);
          Ju(ar, {
            class: "size-5"
          });
          var Ar = D(ar);
          P(dr), Re((Kr, Rr, Or) => {
            Qt(Ue, "action", `${V1}/payment/create-portal-session`), te(kt, ` ${Kr??""}`), Qt(dr, "href", Rr), te(Ar, ` ${Or??""}`)
          }, [() => O5(), S0, () => d0()]), q(qt, bt)
        };
        Se(tr, qt => {
          var bt;
          (bt = u.user.data) != null && bt.isCustomer && qt(Yt)
        })
      }
      var Tr = D(tr, 2);
      Tr.__click = async () => {
        var qt;
        try {
          H(b, !0), await u.user.logout(), z(), Nt.warning(vw(), {
            icon: Jv
          }), (qt = u.onlogout) == null || qt.call(u)
        } catch {
          Nt.error(yw())
        } finally {
          H(b, !1)
        }
      };
      var Dr = I(Tr);
      Jv(Dr, {
        class: "size-5"
      });
      var Jr = D(Dr);
      P(Tr), P(br), P(Ae), P(we);
      var yr = D(we, 2);
      lA(yr, {
        get userData() {
          return u.user.data
        },
        get open() {
          return m(v)
        },
        set open(qt) {
          H(v, qt, !0)
        }
      }), Re((qt, bt, Ue, xt, Gt, kt, dr, ar, Ar, Kr, Rr, Or, Fr, ti) => {
        xe = Vr(Fe, 1, "btn relative size-12 p-0 shadow-md", null, xe, {
          "bg-red-500": m(W)
        }), Qt(Fe, "title", qt), Qt(ot, "title", u.user.data.name), te(Ht, u.user.data.name), Vr(vt, 1, bt), te(Dt, `#${u.user.data.id??""}`), te(Zt, `${Ue??""}: `), te(Ot, xt), te(It, `Level ${Gt??""}`), te(Ut, ` (${kt??""}%) `), Qt(ut, "data-tip", dr), te(Gr, ar), Qt(sr, "data-tip", Ar), Qt(V, "data-tip", Kr), Qt(Be, "data-tip", Rr), te(Kt, ` ${Or??""}`), te(Je, ` ${Fr??""}`), Tr.disabled = m(b), te(Jr, ` ${ti??""}`)
      }, [() => xw(), () => jo(tn(u.user.data.id)), () => Gm(), () => u.user.data.pixelsPainted.toLocaleString(navigator.language), () => Math.floor(u.user.data.level), () => Math.floor(u.user.data.level % 1 * 100), () => bw(), () => ww(), () => Tw(), () => An.muted ? Sw() : Pw(), () => f0(), () => F5(), () => c3(), () => B5()]), Mi("focus", Fe, () => {
        H(B, window.pwaInstallPrompt, !0)
      }), q(Z, Ie)
    };
    Se(oe, Z => {
      u.user.data && u.user.charges !== void 0 && Z(me)
    })
  }
  q(y, $), ii()
}
$i(["click"]);
var KA = he('<label class="tab grow font-semibold max-sm:h-10"><input type="radio" class="tab grow"/> <!> </label>'),
  JA = he('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  QA = he('<span class="font-flag tooltip ml-0.5"> </span>'),
  ek = he("<span> </span>"),
  tk = he('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="max-sm:px-1"><div class="flex items-center gap-2"><!> <div class="items-center gap-2 sm:flex"><span> <span class="ml-0.5"> </span></span> <!> <!> <!></div></div></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  rk = he('<table class="table"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  ik = he('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="h-14 max-sm:px-1"><span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  ak = he('<table class="table"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  nk = he('<div class="h-screen pt-20"><div class="flex justify-center"><span class="loading loading-spinner"></span></div></div>'),
  sk = he('<div class="tabs tabs-box"></div> <div class="my-4 flex items-center justify-between"><!></div> <!>', 1);

function ok(y, u) {
  ri(u, !0);
  const v = [];
  let b = Ke("today"),
    k = {
      players: {
        label: p0(),
        icon: Dp
      },
      alliances: {
        label: P0(),
        icon: Rp
      }
    },
    z = Ke("players"),
    T = _a({
      players: {},
      alliances: {}
    });
  const s = mt(() => T[m(z)][m(b)]);
  oi(() => {
    if (m(s)) return;
    const Z = m(b),
      Ie = m(z);
    Ie === "players" ? ui.leaderboardRegionPlayers(u.regionId, Z).then(we => {
      T[Ie][Z] = we
    }).catch(we => {
      Nt.error(we.message)
    }) : Ie === "alliances" && ui.leaderboardRegionAlliances(u.regionId, Z).then(we => {
      T[Ie][Z] = we
    }).catch(we => {
      Nt.error(we.message)
    })
  });
  var B = sk(),
    W = Ct(B);
  na(W, 21, () => Object.entries(k), ([Z, {
    label: Ie,
    icon: we
  }]) => Z, (Z, Ie) => {
    var we = mt(() => t0(m(Ie), 2));
    let Fe = () => m(we)[0],
      xe = () => m(we)[1].label,
      $e = () => m(we)[1].icon;
    const et = mt($e);
    var Xe = KA(),
      Ae = I(Xe);
    Xa(Ae);
    var De, Ye = D(Ae, 2);
    yn(Ye, () => m(et), (qe, _t) => {
      _t(qe, {
        get this() {
          return $e()
        },
        class: "mr-1 size-5 max-sm:hidden"
      })
    });
    var Le = D(Ye);
    P(Xe), Re(() => {
      Qt(Ae, "aria-label", xe()), De !== (De = Fe()) && (Ae.value = (Ae.__value = Fe()) ?? ""), te(Le, ` ${xe()??""}`)
    }), Nm(v, [], Ae, () => (Fe(), m(z)), qe => H(z, qe)), q(Z, Xe)
  }), P(W);
  var ee = D(W, 2),
    $ = I(ee);
  lg($, {
    get value() {
      return m(b)
    },
    set value(Z) {
      H(b, Z, !0)
    }
  }), P(ee);
  var oe = D(ee, 2);
  {
    var me = Z => {
        var Ie = JA(),
          we = I(Ie),
          Fe = D(we);
        {
          var xe = et => {
              var Xe = Ba();
              Re(Ae => te(Xe, Ae), [() => kp().toLowerCase()]), q(et, Xe)
            },
            $e = et => {
              var Xe = Sr(),
                Ae = Ct(Xe);
              {
                var De = Le => {
                    var qe = Ba();
                    Re(_t => te(qe, _t), [() => $m()]), q(Le, qe)
                  },
                  Ye = Le => {
                    var qe = Sr(),
                      _t = Ct(qe);
                    {
                      var Qe = Ge => {
                        var ft = Ba();
                        Re(Vt => te(ft, Vt), [() => Xm()]), q(Ge, ft)
                      };
                      Se(_t, Ge => {
                        m(b) === "month" && Ge(Qe)
                      }, !0)
                    }
                    q(Le, qe)
                  };
                Se(Ae, Le => {
                  m(b) === "week" ? Le(De) : Le(Ye, !1)
                }, !0)
              }
              q(et, Xe)
            };
          Se(Fe, et => {
            m(b) === "today" ? et(xe) : et($e, !1)
          })
        }
        P(Ie), Re(et => te(we, `${et??""} `), [() => Hm()]), q(Z, Ie)
      },
      _e = Z => {
        var Ie = Sr(),
          we = Ct(Ie);
        {
          var Fe = $e => {
              var et = Sr(),
                Xe = Ct(et);
              {
                var Ae = Ye => {
                    const Le = mt(() => m(s));
                    var qe = rk(),
                      _t = I(qe),
                      Qe = I(_t),
                      Ge = D(I(Qe)),
                      ft = I(Ge, !0);
                    P(Ge);
                    var Vt = D(Ge),
                      Et = I(Vt),
                      Pt = D(Et, 2, !0);
                    P(Vt), P(Qe), P(_t);
                    var ot = D(_t);
                    na(ot, 31, () => m(Le), Ht => Ht.id, (Ht, vt, Dt) => {
                      const Rt = mt(() => {
                        var wr;
                        return ((wr = Lt.data) == null ? void 0 : wr.id) === m(vt).id
                      });
                      var $t = tk();
                      let pr;
                      var Xt = I($t),
                        or = I(Xt, !0);
                      P(Xt);
                      var nt = D(Xt),
                        rt = I(nt),
                        Zt = I(rt);
                      Dn(Zt, {
                        class: "size-10 border",
                        get userId() {
                          return m(vt).id
                        },
                        get pictureUrl() {
                          return m(vt).picture
                        },
                        get borderUrl() {
                          return m(vt).frameUrl
                        }
                      });
                      var Jt = D(Zt, 2),
                        Ot = I(Jt),
                        mr = I(Ot),
                        At = D(mr),
                        Mt = I(At);
                      P(At), P(Ot);
                      var wt = D(Ot, 2);
                      {
                        var It = wr => {
                          const Nr = mt(() => zs(m(vt).equippedFlag));
                          var Gr = QA(),
                            er = I(Gr, !0);
                          P(Gr), Re(() => {
                            Qt(Gr, "data-tip", m(Nr).name), te(er, m(Nr).flag)
                          }), q(wr, Gr)
                        };
                        Se(wt, wr => {
                          "equippedFlag" in m(vt) && m(vt).equippedFlag && wr(It)
                        })
                      }
                      var Ut = D(wt, 2);
                      {
                        var ut = wr => {
                          zh(wr, {
                            get username() {
                              return m(vt).discord
                            },
                            get id() {
                              return m(vt).discordId
                            }
                          })
                        };
                        Se(Ut, wr => {
                          m(vt).discord && wr(ut)
                        })
                      }
                      var ur = D(Ut, 2);
                      {
                        var br = wr => {
                          var Nr = ek(),
                            Gr = I(Nr, !0);
                          P(Nr), Re((er, Wr) => {
                            Vr(Nr, 1, `badge badge-sm ml-0.5 border-0 ${er??""} ${Wr??""}`), te(Gr, m(vt).allianceName)
                          }, [() => Cp(m(vt).allianceId), () => tn(m(vt).allianceId)]), q(wr, Nr)
                        };
                        Se(ur, wr => {
                          "allianceName" in m(vt) && m(vt).allianceName && wr(br)
                        })
                      }
                      P(Jt), P(rt), P(nt);
                      var cr = D(nt),
                        jr = I(cr, !0);
                      P(cr), P($t), Re((wr, Nr) => {
                        pr = Vr($t, 1, "", null, pr, {
                          "bg-base-200": m(Rt)
                        }), te(or, m(Dt) + 1), Vr(Ot, 1, `font-semibold max-sm:ml-2 ${wr??""} flex gap-1`), te(mr, `${m(vt).name??""} `), te(Mt, `#${m(vt).id??""}`), te(jr, Nr)
                      }, [() => tn(m(vt).id), () => m(vt).pixelsPainted.toLocaleString(navigator.language)]), fl($t, () => ml, () => ({
                        duration: 200
                      })), q(Ht, $t)
                    }), P(ot), P(qe), Re((Ht, vt, Dt) => {
                      te(ft, Ht), te(Et, `${vt??""} `), te(Pt, Dt)
                    }, [() => Km(), () => Sc(), () => Pc().toLowerCase()]), q(Ye, qe)
                  },
                  De = Ye => {
                    var Le = Sr(),
                      qe = Ct(Le);
                    {
                      var _t = Qe => {
                        var Ge = ak(),
                          ft = I(Ge),
                          Vt = I(ft),
                          Et = D(I(Vt)),
                          Pt = I(Et, !0);
                        P(Et);
                        var ot = D(Et),
                          Ht = I(ot),
                          vt = D(Ht, 2, !0);
                        P(ot), P(Vt), P(ft);
                        var Dt = D(ft);
                        na(Dt, 31, () => m(s), Rt => Rt.id, (Rt, $t, pr) => {
                          const Xt = mt(() => {
                            var wt;
                            return ((wt = Lt.data) == null ? void 0 : wt.allianceId) === m($t).id
                          });
                          var or = ik();
                          let nt;
                          var rt = I(or),
                            Zt = I(rt, !0);
                          P(rt);
                          var Jt = D(rt),
                            Ot = I(Jt),
                            mr = I(Ot, !0);
                          P(Ot), P(Jt);
                          var At = D(Jt),
                            Mt = I(At, !0);
                          P(At), P(or), Re((wt, It) => {
                            nt = Vr(or, 1, "", null, nt, {
                              "bg-base-200": m(Xt)
                            }), te(Zt, m(pr) + 1), Vr(Ot, 1, `font-semibold ${wt??""}`), te(mr, m($t).name), te(Mt, It)
                          }, [() => tn(m($t).id), () => m($t).pixelsPainted.toLocaleString(navigator.language)]), fl(or, () => ml, () => ({
                            duration: 200
                          })), q(Rt, or)
                        }), P(Dt), P(Ge), Re((Rt, $t, pr) => {
                          te(Pt, Rt), te(Ht, `${$t??""} `), te(vt, pr)
                        }, [() => zp(), () => Sc(), () => Pc().toLowerCase()]), q(Qe, Ge)
                      };
                      Se(qe, Qe => {
                        m(z) === "alliances" && Qe(_t)
                      }, !0)
                    }
                    q(Ye, Le)
                  };
                Se(Xe, Ye => {
                  m(z) === "players" ? Ye(Ae) : Ye(De, !1)
                })
              }
              q($e, et)
            },
            xe = $e => {
              var et = nk();
              q($e, et)
            };
          Se(we, $e => {
            m(s) ? $e(Fe) : $e(xe, !1)
          }, !0)
        }
        q(Z, Ie)
      };
    Se(oe, Z => {
      m(s) && m(s).length === 0 ? Z(me) : Z(_e, !1)
    })
  }
  q(y, B), ii()
}
var lk = he('<div class="mt-5"><!></div>'),
  ck = he('<dialog class="modal" closedby="any"><div class="modal-box h-11/12 max-w-3xl"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2"></button></form> <h2><span class="font-flag tooltip"> </span> <span> </span> <span> </span></h2> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function uk(y, u) {
  ri(u, !0);
  let v = rr(u, "open", 15);
  const b = mt(() => zs(u.region.countryId));
  var k = ck(),
    z = I(k),
    T = D(I(z), 2),
    s = I(T),
    B = I(s, !0);
  P(s);
  var W = D(s, 2),
    ee = I(W, !0);
  P(W);
  var $ = D(W, 2),
    oe = I($);
  P($), P(T);
  var me = D(T, 2);
  {
    var _e = Z => {
      var Ie = lk(),
        we = I(Ie);
      ok(we, {
        get regionId() {
          return u.region.id
        }
      }), P(Ie), pn(2, Ie, () => Kn, () => ({
        duration: 300
      })), q(Z, Ie)
    };
    Se(me, Z => {
      v() && Z(_e)
    })
  }
  P(z), vi(2), P(k), Ya(k, () => Z => {
    oi(() => {
      v() ? Z.show() : Z.close()
    })
  }), Re(Z => {
    Vr(T, 1, `flex gap-2 text-xl font-bold sm:text-2xl ${Z??""}`), Qt(s, "data-tip", m(b).name), te(B, m(b).flag), te(ee, u.region.name), te(oe, `#${u.region.number??""}`)
  }, [() => tn(u.region.cityId)]), Mi("close", k, () => v(!1)), q(y, k), ii()
}

function hk(y) {
  switch (y) {
    case "en":
    case "pt":
    case "es":
    case "fr":
    case "de":
    case "it":
    case "pl":
    case "ru":
    case "uk":
    case "vi":
      return y;
    case "jp":
      return "ja";
    case "ch":
      return "zh";
    default:
      return ""
  }
}
async function dk(y) {
  const u = hk(nb());
  let v = `https://geocoding.wplace.live/v1/autocomplete?text=${encodeURIComponent(y)}${u!=="en"?`&lang=${u}`:""}`;
  const b = await fetch(v);
  if (!b.ok) {
    const k = await b.text();
    throw console.error(`Geocoding API error: ${k}`), new Error($1())
  }
  return b.json()
}
var pk = he('<div class="text-base-content/80 absolute right-3 top-1/2 z-10 -translate-y-1/2 sm:right-6"><button class="btn btn-ghost btn-sm btn-circle hidden group-hover:flex"><!></button></div>'),
  fk = he('<div class="group relative"><button class="hover:bg-base-200 active:bg-base-200 flex w-full gap-3 px-3 py-2 sm:px-6"><!> <div class="sm:pr-8"><h3 class="text-left font-semibold"> </h3> <div class="text-base-content/80 text-left text-sm"> </div></div></button> <!></div>');

function Qf(y, u) {
  ri(u, !0);
  const v = (s, B) => {
    let W = () => B == null ? void 0 : B().name,
      ee = () => B == null ? void 0 : B().label,
      $ = () => B == null ? void 0 : B().onclick;
    var oe = fk(),
      me = I(oe);
    me.__click = function(...Xe) {
      var Ae;
      (Ae = $()) == null || Ae.apply(this, Xe)
    };
    var _e = I(me);
    Lp(_e, {
      class: "text-base-content/80 mt-0.5 size-6 min-w-6"
    });
    var Z = D(_e, 2),
      Ie = I(Z),
      we = I(Ie, !0);
    P(Ie);
    var Fe = D(Ie, 2),
      xe = I(Fe, !0);
    P(Fe), P(Z), P(me);
    var $e = D(me, 2);
    {
      var et = Xe => {
        var Ae = pk(),
          De = I(Ae);
        De.__click = function(...Le) {
          var qe;
          (qe = u.onremove) == null || qe.apply(this, Le)
        };
        var Ye = I(De);
        Ls(Ye, {
          class: "size-4"
        }), P(De), P(Ae), q(Xe, Ae)
      };
      Se($e, Xe => {
        u.onremove && Xe(et)
      })
    }
    P(oe), Re(() => {
      te(we, W()), te(xe, ee())
    }), q(s, oe)
  };
  var b = Sr(),
    k = Ct(b);
  {
    var z = s => {
        v(s, () => ({
          name: u.location.name,
          label: u.location.label,
          onclick: u.onclick
        }))
      },
      T = s => {
        var B = Sr(),
          W = Ct(B);
        {
          var ee = oe => {
              {
                let me = mt(() => ({
                  name: u.location.name,
                  label: Ym(),
                  onclick: u.onclick
                }));
                v(oe, () => m(me))
              }
            },
            $ = oe => {
              var me = Sr(),
                _e = Ct(me);
              {
                var Z = Ie => {
                  {
                    let we = mt(() => ({
                      name: `${u.location.pos.lat.toFixed(4)}, ${u.location.pos.lng.toFixed(4)}`,
                      label: h0(),
                      onclick: u.onclick
                    }));
                    v(Ie, () => m(we))
                  }
                };
                Se(_e, Ie => {
                  u.location.type === "coordinates" && Ie(Z)
                }, !0)
              }
              q(oe, me)
            };
          Se(W, oe => {
            u.location.type === "country" ? oe(ee) : oe($, !1)
          }, !0)
        }
        q(s, B)
      };
    Se(k, s => {
      u.location.type === "place" ? s(z) : s(T, !1)
    })
  }
  q(y, b), ii()
}
$i(["click"]);
var mk = Xr('<svg><path d="m336-280 144-144 144 144 56-56-144-144 144-144-56-56-144 144-144-144-56 56 144 144-144 144 56 56ZM480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"></path></svg>');

function gk(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = mk();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var _k = Xr('<svg><path d="M300-240q25 0 42.5-17.5T360-300q0-25-17.5-42.5T300-360q-25 0-42.5 17.5T240-300q0 25 17.5 42.5T300-240Zm0-360q25 0 42.5-17.5T360-660q0-25-17.5-42.5T300-720q-25 0-42.5 17.5T240-660q0 25 17.5 42.5T300-600Zm180 180q25 0 42.5-17.5T540-480q0-25-17.5-42.5T480-540q-25 0-42.5 17.5T420-480q0 25 17.5 42.5T480-420Zm180 180q25 0 42.5-17.5T720-300q0-25-17.5-42.5T660-360q-25 0-42.5 17.5T600-300q0 25 17.5 42.5T660-240Zm0-360q25 0 42.5-17.5T720-660q0-25-17.5-42.5T660-720q-25 0-42.5 17.5T600-660q0 25 17.5 42.5T660-600ZM200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm0-560v560-560Z"></path></svg>');

function vk(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = _k();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var yk = he('<button type="button" class="absolute right-1 top-1/2 z-10 -translate-y-1/2 rounded-full p-2"><!></button>'),
  xk = he('<p class="text-base-content/80 pt-4 text-center text-sm"> </p>'),
  bk = he("<!> <!>", 1),
  wk = he('<p class="text-base-content/80 pt-6 text-center text-sm"> </p>'),
  Tk = he('<div class="mb-2 flex items-center justify-between px-4 sm:px-7"><h3 class="text-sm font-semibold"> </h3> <button class="btn btn-sm btn-ghost btn-circle tooltip tooltip-bottom before:-translate-x-1/3"><!></button></div> <!> <!>', 1),
  Sk = he('<dialog class="modal duration-0"><div class="modal-box sm:max-h-11/12 sm:h-11/12 flex flex-col p-0 max-sm:h-full max-sm:w-full max-sm:max-w-full max-sm:rounded-none"><section class="px-3 pt-3 sm:px-6 sm:pt-6"><form class="relative h-max"><input class="input placeholder:text-base-content/80 input-no-cancel-button w-full pl-10 pr-9" type="search"/> <button type="button" class="absolute left-1 top-1/2 z-10 -translate-y-1/2 rounded-full p-2"><!></button> <!></form></section> <section class="grow overflow-y-auto overflow-x-hidden pb-3 pt-4 sm:pb-6"><!></section></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function Pk(y, u) {
  ri(u, !0);
  let v = rr(u, "open", 15),
    b = Ke(""),
    k = Ke(!1),
    z = Ke(!1);
  const T = new CP(() => m(b), 400);
  let s = Ke(null),
    B = Ke(void 0),
    W = Ke([]);
  const ee = /^([+-]?([1-8]?\d(\.\d+)?|90(\.0+)?))\s*,\s*([+-]?(180(\.0+)?|((1[0-7]\d)|([1-9]?\d))(\.\d+)?))$/,
    $ = mt(() => {
      const Qe = ee.exec(m(b));
      if (Qe) {
        const Ge = parseFloat(Qe[1]),
          ft = parseFloat(Qe[5]);
        return {
          type: "coordinates",
          id: `coords-${Ge}-${ft}`,
          pos: {
            lat: Ge,
            lng: ft
          },
          zoom: u.tileZoom + 2
        }
      }
    }),
    oe = "recent-locations";
  $a(() => {
    const Qe = localStorage.getItem(oe);
    if (Qe) try {
      H(W, JSON.parse(Qe))
    } catch (Ge) {
      console.error("Failed to parse recent locations from localStorage", Ge)
    }
  }), oi(() => {
    T.current && dk(T.current).then(Qe => {
      H(B, Qe.features.map(Ge => {
        if (Ge.properties.layer === "country") return {
          type: "country",
          id: Ge.properties.id,
          name: Ge.properties.name,
          bbox: Ge.bbox,
          coordinates: Ge.geometry.type === "Point" ? {
            lat: Ge.geometry.coordinates[1],
            lng: Ge.geometry.coordinates[0]
          } : void 0
        };
        const ft = Ge.properties.label.replace(Ge.properties.name + ",", "").trim();
        return {
          type: "place",
          id: Ge.properties.id,
          name: Ge.properties.name,
          label: ft,
          bbox: Ge.bbox,
          coordinates: Ge.geometry.type === "Point" ? {
            lat: Ge.geometry.coordinates[1],
            lng: Ge.geometry.coordinates[0]
          } : void 0
        }
      })), m(k) && m(B).length > 0 && _e(m(B)[0])
    })
  }), oi(() => {
    m(b) || H(B, void 0)
  }), oi(() => {
    v() ? setTimeout(() => {
      m(s).focus()
    }, 50) : (H(b, ""), H(k, !1), H(B, void 0))
  });
  async function me() {
    const {
      tile: Qe,
      pixel: Ge
    } = await ui.getRandomTile(u.season), ft = new kn(u.tileSize), Vt = Qe.x * u.tileSize + Ge.x, Et = Qe.y * u.tileSize + Ge.y, [Pt, ot] = ft.pixelsToLatLon(Vt, Et, u.tileZoom), Ht = {
      lat: Pt,
      lng: ot
    }, vt = u.tileZoom + 2;
    u.map.flyTo({
      zoom: vt,
      center: Ht
    }), Z({
      type: "coordinates",
      id: `coords-${Pt}-${ot}`,
      pos: Ht,
      zoom: vt
    })
  }

  function _e(Qe) {
    Qe.type === "coordinates" ? u.map.flyTo({
      zoom: Qe.zoom,
      center: Qe.pos
    }) : Qe.bbox ? u.map.fitBounds([
      [Qe.bbox[0], Qe.bbox[1]],
      [Qe.bbox[2], Qe.bbox[3]]
    ], {
      padding: 40,
      duration: 1e3
    }) : Qe.coordinates && u.map.flyTo({
      zoom: 16,
      center: Qe.coordinates,
      duration: 1e3
    }), v(!1), H(B, void 0), Z(Qe)
  }

  function Z(Qe) {
    H(W, m(W).filter(ft => ft.id !== Qe.id)), m(W).unshift(Qe);
    const Ge = 15;
    m(W).length > Ge && H(W, m(W).slice(0, Ge)), H(W, [...m(W)]), localStorage.setItem(oe, JSON.stringify(m(W)))
  }
  var Ie = Sk(),
    we = I(Ie),
    Fe = I(we),
    xe = I(Fe),
    $e = I(xe);
  Xa($e), Rn($e, Qe => H(s, Qe), () => m(s));
  var et = D($e, 2);
  et.__click = () => v(!1);
  var Xe = I(et);
  w0(Xe, {
    class: "size-5"
  }), P(et);
  var Ae = D(et, 2);
  {
    var De = Qe => {
      var Ge = yk();
      Ge.__click = () => H(b, "");
      var ft = I(Ge);
      gk(ft, {
        class: "size-4.5"
      }), P(Ge), q(Qe, Ge)
    };
    Se(Ae, Qe => {
      m(b) && Qe(De)
    })
  }
  P(xe), P(Fe);
  var Ye = D(Fe, 2),
    Le = I(Ye);
  {
    var qe = Qe => {
        Qf(Qe, {
          get location() {
            return m($)
          },
          onclick: () => _e(m($))
        })
      },
      _t = Qe => {
        var Ge = Sr(),
          ft = Ct(Ge);
        {
          var Vt = Pt => {
              var ot = bk(),
                Ht = Ct(ot);
              na(Ht, 17, () => m(B), Rt => Rt.id, (Rt, $t) => {
                Qf(Rt, {
                  get location() {
                    return m($t)
                  },
                  onclick: () => _e(m($t))
                })
              });
              var vt = D(Ht, 2);
              {
                var Dt = Rt => {
                  var $t = xk(),
                    pr = I($t, !0);
                  P($t), Re(Xt => te(pr, Xt), [() => Ow()]), q(Rt, $t)
                };
                Se(vt, Rt => {
                  m(B).length === 0 && Rt(Dt)
                })
              }
              q(Pt, ot)
            },
            Et = Pt => {
              var ot = Tk(),
                Ht = Ct(ot),
                vt = I(Ht),
                Dt = I(vt, !0);
              P(vt);
              var Rt = D(vt, 2);
              Rt.__click = async () => {
                try {
                  await me(), v(!1)
                } catch (nt) {
                  Nt.error(nt.message)
                } finally {
                  H(z, !1)
                }
              };
              var $t = I(Rt);
              vk($t, {
                class: "size-5"
              }), P(Rt), P(Ht);
              var pr = D(Ht, 2);
              na(pr, 17, () => m(W), nt => nt.id, (nt, rt) => {
                Qf(nt, {
                  get location() {
                    return m(rt)
                  },
                  onclick: () => {
                    _e(m(rt))
                  },
                  onremove: () => {
                    H(W, m(W).filter(Zt => Zt.id !== m(rt).id)), localStorage.setItem(oe, JSON.stringify(m(W)))
                  }
                })
              });
              var Xt = D(pr, 2);
              {
                var or = nt => {
                  var rt = wk(),
                    Zt = I(rt, !0);
                  P(rt), Re(Jt => te(Zt, Jt), [() => jw()]), q(nt, rt)
                };
                Se(Xt, nt => {
                  m(W).length === 0 && nt(or)
                })
              }
              Re((nt, rt) => {
                te(Dt, nt), Qt(Rt, "data-tip", rt), Rt.disabled = m(z)
              }, [() => Fw(), () => Bw()]), q(Pt, ot)
            };
          Se(ft, Pt => {
            m(B) ? Pt(Vt) : Pt(Et, !1)
          }, !0)
        }
        q(Qe, Ge)
      };
    Se(Le, Qe => {
      m($) ? Qe(qe) : Qe(_t, !1)
    })
  }
  P(Ye), P(we), vi(2), P(Ie), Ya(Ie, () => Qe => {
    oi(() => {
      v() ? Qe.showModal() : Qe.close()
    })
  }), Re(Qe => Qt($e, "placeholder", Qe), [() => x0()]), Mi("close", Ie, () => v(!1)), Mi("submit", xe, () => {
    var Qe;
    m($) ? _e(m($)) : T.pending ? H(k, !0) : (Qe = m(B)) != null && Qe.length && _e(m(B)[0])
  }), vl($e, () => m(b), Qe => H(b, Qe)), q(y, Ie), ii()
}
$i(["click"]);
var Mk = Xr('<svg><path d="M200-80q-50 0-85-35t-35-85q0-39 22.5-69.5T160-313v-334q-35-13-57.5-43.5T80-760q0-50 35-85t85-35q39 0 69.5 22.5T313-800h334q12-35 42.5-57.5T760-880q50 0 85 35t35 85q0 40-22.5 70.5T800-647v334q35 13 57.5 43.5T880-200q0 50-35 85t-85 35q-39 0-69.5-22.5T647-160H313q-13 35-43.5 57.5T200-80Zm0-640q17 0 28.5-11.5T240-760q0-17-11.5-28.5T200-800q-17 0-28.5 11.5T160-760q0 17 11.5 28.5T200-720Zm560 0q17 0 28.5-11.5T800-760q0-17-11.5-28.5T760-800q-17 0-28.5 11.5T720-760q0 17 11.5 28.5T760-720ZM313-240h334q9-26 28-45t45-28v-334q-26-9-45-28t-28-45H313q-9 26-28 45t-45 28v334q26 9 45 28t28 45Zm447 80q17 0 28.5-11.5T800-200q0-17-11.5-28.5T760-240q-17 0-28.5 11.5T720-200q0 17 11.5 28.5T760-160Zm-560 0q17 0 28.5-11.5T240-200q0-17-11.5-28.5T200-240q-17 0-28.5 11.5T160-200q0 17 11.5 28.5T200-160Zm0-600Zm560 0Zm0 560Zm-560 0Z"></path></svg>');

function Bm(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = Mk();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var Ik = Xr('<svg><path fill="currentColor" d="M9 14c1.381 0 2.631-.56 3.536-1.465C13.44 11.631 14 10.381 14 9s-.56-2.631-1.464-3.535C11.631 4.56 10.381 4 9 4s-2.631.56-3.536 1.465C4.56 6.369 4 7.619 4 9s.56 2.631 1.464 3.535A5 5 0 0 0 9 14m0 7c3.518 0 6-1 6-2c0-2-2.354-4-6-4c-3.75 0-6 2-6 4c0 1 2.25 2 6 2m12-9h-2v-2a1 1 0 1 0-2 0v2h-2a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2"></path></svg>');

function Ck(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = Ik();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    ...v
  })), q(y, b)
}
var Ak = Xr('<svg><circle cx="12" cy="12" r="8" fill="none" stroke="currentColor" stroke-width="2"></circle><circle cx="12" cy="12" r="3" fill="currentColor"></circle></svg>');

function kk(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = Ak();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    ...v
  })), q(y, b)
}
var Ek = Xr('<svg><path fill="currentColor" d="m15 21l-6-2.1l-4.65 1.8q-.5.2-.925-.112T3 19.75v-14q0-.325.188-.575T3.7 4.8L9 3l6 2.1l4.65-1.8q.5-.2.925.113T21 4.25v14q0 .325-.187.575t-.513.375zm-1-2.45V6.85l-4-1.4v11.7zm2 0l3-1V5.7l-3 1.15zM5 18.3l3-1.15V5.45l-3 1zM16 6.85v11.7zm-8-1.4v11.7z"></path></svg>');

function zk(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = Ek();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    ...v
  })), q(y, b)
}
var Lk = Xr('<svg><rect x="6" y="6" width="12" height="12" fill="none" stroke="currentColor" stroke-width="2" rx="2"></rect><rect x="10" y="10" width="4" height="4" fill="currentColor" rx="1"></rect></svg>');

function Dk(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = Lk();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    ...v
  })), q(y, b)
}
var Rk = he("<!> <!>", 1),
  Fk = he('<span class="loading loading-spinner loading-xs svelte-15blegn"></span>'),
  Bk = he('<span class="loading loading-spinner loading-xs svelte-15blegn"></span>'),
  Ok = he('<div class="mt-3 flex justify-center svelte-15blegn"><span class="loading loading-spinner svelte-15blegn"></span></div>'),
  jk = he('<div class="mt-3 flex justify-center svelte-15blegn"><p class="text-base-content/80 text-sm svelte-15blegn">No one has painted in this area yet.</p></div>'),
  qk = he('<button class="btn btn-xs btn-circle btn-soft btn-error tooltip tooltip-bottom svelte-15blegn" data-tip="Timeout selected players"><!></button>'),
  Vk = he('<button class="btn btn-xs btn-circle btn-soft btn-error tooltip tooltip-bottom ml-0.5 svelte-15blegn" data-tip="Ban selected players"><!></button>'),
  Zk = he('<span class="loading loading-spinner loading-xs svelte-15blegn"></span>'),
  Nk = he('<button class="btn btn-xs btn-circle btn-soft btn-primary tooltip tooltip-bottom mr-1 svelte-15blegn" data-tip="Paint selected pixels with transparent color"><!></button>'),
  Uk = he('<div class="size-5 svelte-15blegn"></div> <div class="text-base-content/80 ml-0.5 svelte-15blegn">Not painted</div>', 1),
  Gk = he("<span> </span>"),
  Wk = he('<span class="badge badge-sm badge-error ml-0.5 border-0 svelte-15blegn">DELETED</span>'),
  Hk = he('<span class="tooltip svelte-15blegn"><!></span>'),
  $k = he('<span class="tooltip svelte-15blegn"><!></span>'),
  Xk = he('<!> <div class="ml-0.5 flex flex-wrap items-center gap-1 svelte-15blegn"><span><span class="svelte-15blegn"> </span> <span class="svelte-15blegn"> </span></span> <!> <!> <div class="ml-0.5 flex items-center svelte-15blegn"><!></div></div>', 1),
  Yk = he('<span class="text-primary ml-1 text-xs svelte-15blegn"> </span>'),
  Kk = he('<tr><th class="w-1 svelte-15blegn"><input type="checkbox" class="checkbox-sm checkbox pointer-event-none svelte-15blegn"/></th><td class="flex items-center gap-1 svelte-15blegn"><!></td><td class="text-center svelte-15blegn"> <!></td></tr>'),
  Jk = he('<div class="max-h-[27vh] overflow-y-auto overflow-x-hidden svelte-15blegn"><table class="table max-w-full svelte-15blegn"><thead class="svelte-15blegn"><tr class="svelte-15blegn"><th class="w-1 svelte-15blegn"><input type="checkbox" class="checkbox-sm checkbox svelte-15blegn"/></th><th class="svelte-15blegn">Player <button class="btn btn-xs btn-circle btn-ghost tooltip tooltip-bottom ml-0.5 svelte-15blegn" data-tip="Copy selected players IDs"><!></button> <!> <!></th><th class="text-center svelte-15blegn"><!> Pixels Painted</th></tr></thead><tbody class="svelte-15blegn"></tbody></table></div>'),
  Qk = he('<div class="pointer-events-none w-full select-none svelte-15blegn"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box pointer-events-auto w-full border-t sm:mb-3 sm:shadow-xl svelte-15blegn"><div class="p-3 svelte-15blegn"><div class="flex cursor-grab flex-wrap items-center justify-between gap-1 active:cursor-grabbing svelte-15blegn"><h2 class="flex items-center gap-1 pl-1 text-lg svelte-15blegn"><div class="bg-base-content/20 flex size-6 items-center justify-center rounded-full svelte-15blegn"><!></div> <span class="ml-0.5 svelte-15blegn">Selected area</span> <span class="text-base-content/80 ml-0.5 text-sm svelte-15blegn"> </span></h2> <div class="flex items-center gap-1 svelte-15blegn"><div class="flex items-center gap-0 svelte-15blegn"><button class="btn btn-xs btn-soft text-base-content/80 flex items-center gap-1 whitespace-nowrap rounded-br-none rounded-tr-none pr-1 text-xs svelte-15blegn"><!> <input type="checkbox" class="checkbox checkbox-xs svelte-15blegn"/></button> <button class="btn btn-xs tooltip tooltip-bottom btn-soft rounded-bl-none rounded-tl-none svelte-15blegn"><!></button></div> <button><!></button> <button><!></button> <button><!></button> <button class="btn btn-circle btn-sm svelte-15blegn"><!></button></div></div> <div class="pb-3 svelte-15blegn"><!></div></div></div></div>');

function e8(y, u) {
  ri(u, !0);
  let v = _a([]),
    b = Ke(_a([])),
    k = Ke(!1),
    z = Ke(!1),
    T = Ke(!1),
    s = Ke(!1),
    B = Ke(!1),
    W, ee, $, oe, me, _e = Ke(void 0),
    Z = _a({
      x: 0,
      y: 0
    }),
    Ie, we;
  const Fe = 15e6,
    xe = new yp,
    $e = new Map;
  let et = Ke(0);
  const Xe = mt(() => {
      m(et);
      const ae = new Map;
      for (const J of $e.values()) ae.set(J.userId, (ae.get(J.userId) ?? 0) + 1);
      return ae
    }),
    Ae = mt(() => {
      m(et), xe.size;
      let ae = 0;
      for (const J of $e.values()) xe.has(J.userId) || (ae += 1);
      return ae
    }),
    De = mt(() => {
      m(et);
      const ae = m(Ae);
      return xe.size === 0 && ae === 0 ? "none" : xe.size === m(b).length && ae === 0 ? "all" : "some"
    }),
    Ye = mt(() => {
      m(et);
      let ae = 0;
      for (const J of xe.values()) J.id !== 0 && (ae += J.painted.latitudes.length);
      for (const J of $e.values()) xe.has(J.userId) || (ae += 1);
      return ae
    }),
    Le = mt(() => m(Ge) * 2 + 1);
  let qe = Ke("area-select"),
    _t = Ke(!1);
  const Qe = 15;
  let Ge = Ke(Qe);
  const ft = 0,
    Vt = 4096,
    Et = "select-area-info:brush-radius",
    Pt = new yp,
    ot = new Map,
    Ht = [],
    vt = () => m(qe) === "brush-circle" || m(qe) === "brush-square";
  let Dt, Rt = !1,
    $t = !1;

  function pr() {
    Rt && (Rt = !1, Dt = void 0)
  }

  function Xt() {
    if (Ht.length > 0) return;
    const ae = [u.map.dragPan, u.map.scrollZoom, u.map.boxZoom, u.map.keyboard, u.map.doubleClickZoom, u.map.touchZoomRotate].filter(Boolean);
    for (const J of ae) {
      const Ve = J.isEnabled ? J.isEnabled() !== !1 : !0;
      J.disable && J.disable(), Ht.push({
        handler: J,
        wasEnabled: Ve
      })
    }
  }

  function or() {
    if (Ht.length !== 0) {
      for (const {
          handler: ae,
          wasEnabled: J
        }
        of Ht) J && ae.enable && ae.enable();
      Ht.length = 0
    }
  }

  function nt() {
    var Ve, tt;
    if (!Ie) return;
    const {
      handle: ae,
      pointerId: J
    } = Ie;
    (Ve = ae.hasPointerCapture) != null && Ve.call(ae, J) && ((tt = ae.releasePointerCapture) == null || tt.call(ae, J)), Ie = void 0, we !== void 0 && (document.body.style.userSelect = we, we = void 0), rt()
  }

  function rt() {
    var St, jt;
    if (!m(_e)) return;
    const ae = (jt = (St = u.map).getContainer) == null ? void 0 : jt.call(St);
    if (!ae) return;
    const J = ae.getBoundingClientRect(),
      Ve = m(_e).getBoundingClientRect(),
      tt = Ve.left - Z.x,
      Ze = Ve.top - Z.y,
      ne = J.left - tt,
      Ce = J.right - tt - Ve.width,
      He = J.top - Ze,
      ht = J.bottom - Ze - Ve.height;
    let Tt = Z.x,
      dt = Z.y;
    Ce >= ne ? (Tt < ne && (Tt = ne), Tt > Ce && (Tt = Ce)) : Tt = ne, ht >= He ? (dt < He && (dt = He), dt > ht && (dt = ht)) : dt = He, Tt !== Z.x && (Z.x = Tt), dt !== Z.y && (Z.y = dt)
  }

  function Zt(ae) {
    var He, ht, Tt;
    if (Ie || ae.pointerType === "mouse" && ae.button !== 0) return;
    const J = ae.target;
    if (J && J.closest('button, input, textarea, select, a, [role="button"]')) return;
    const Ve = ae.currentTarget;
    if (!Ve) return;
    const tt = m(_e);
    if (!tt) return;
    const Ze = (ht = (He = u.map).getContainer) == null ? void 0 : ht.call(He);
    if (!Ze) return;
    const ne = Ze.getBoundingClientRect(),
      Ce = tt.getBoundingClientRect();
    Ie = {
      pointerId: ae.pointerId,
      handle: Ve,
      startX: ae.clientX,
      startY: ae.clientY,
      startPosX: Z.x,
      startPosY: Z.y,
      baseLeft: Ce.left - Z.x,
      baseTop: Ce.top - Z.y,
      containerRect: ne,
      panelWidth: Ce.width,
      panelHeight: Ce.height
    }, we === void 0 && (we = document.body.style.userSelect), document.body.style.userSelect = "none", (Tt = Ve.setPointerCapture) == null || Tt.call(Ve, ae.pointerId), ae.preventDefault(), ae.stopPropagation()
  }
  $a(() => {
    const ae = window.localStorage.getItem(Et);
    if (ae !== null) {
      const yt = Number(ae);
      if (!Number.isNaN(yt)) {
        const Kt = Math.min(Vt, Math.max(ft, Math.trunc(yt)));
        H(Ge, Kt, !0)
      }
    }
    ya.droppletAndPlop.play(), W = It();
    const J = async yt => {
      if (m(qe) === "user-picker") {
        await jr(yt, "select");
        return
      }
      if (vt()) {
        const Kt = yt.originalEvent;
        j(yt, "add", {
          silent: !!(Kt != null && Kt.altKey)
        });
        return
      }
      if (v.length >= 2) {
        u.onclose();
        return
      }
      if (v.push(yt.lngLat), Ut(), ya.plop.play(), v.length === 2) try {
        H(k, !0), H(b, await Ot(v[0], v[1]), !0)
      } finally {
        H(k, !1)
      }
    }, Ve = async yt => {
      var Cr, fr;
      if (m(qe) === "user-picker") {
        (Cr = yt.preventDefault) == null || Cr.call(yt);
        const Je = yt.originalEvent;
        Je == null || Je.preventDefault();
        try {
          await jr(yt, "deselect")
        } catch (tr) {
          console.error(tr)
        }
        return
      }
      if (!vt()) return;
      (fr = yt.preventDefault) == null || fr.call(yt);
      const Kt = yt.originalEvent;
      Kt == null || Kt.preventDefault(), j(yt, "remove")
    }, tt = yt => {
      if (!vt()) return;
      const Kt = yt.originalEvent;
      if (!Kt || !Kt.altKey) return;
      const Cr = Kt.button === 2 ? "remove" : "add";
      Kt.preventDefault(), Xt(), Dt = Cr, Rt = !0, j(yt, Cr, {
        silent: !0
      })
    }, Ze = () => {
      pr()
    }, ne = u.map.on("click", J), Ce = u.map.on("contextmenu", Ve), He = u.map.on("mousedown", tt), ht = u.map.on("mouseup", Ze), Tt = yt => {
      const Kt = Ie;
      if (!Kt || yt.pointerId !== Kt.pointerId) return;
      const Cr = yt.clientX - Kt.startX,
        fr = yt.clientY - Kt.startY;
      let Je = Kt.startPosX + Cr,
        tr = Kt.startPosY + fr;
      const Yt = Kt.containerRect.left - Kt.baseLeft,
        Tr = Kt.containerRect.right - Kt.baseLeft - Kt.panelWidth,
        Dr = Kt.containerRect.top - Kt.baseTop,
        Jr = Kt.containerRect.bottom - Kt.baseTop - Kt.panelHeight;
      Tr >= Yt ? (Je < Yt && (Je = Yt), Je > Tr && (Je = Tr)) : Je = Yt, Jr >= Dr ? (tr < Dr && (tr = Dr), tr > Jr && (tr = Jr)) : tr = Dr, Z.x !== Je && (Z.x = Je), Z.y !== tr && (Z.y = tr)
    }, dt = yt => {
      const Kt = Ie;
      !Kt || yt.pointerId !== Kt.pointerId || nt()
    };
    window.addEventListener("pointermove", Tt), window.addEventListener("pointerup", dt), window.addEventListener("pointercancel", dt), window.addEventListener("resize", rt);
    const St = yt => {
        if (yt.altKey && (yt.key === "r" || yt.key === "R")) {
          H(Ge, Qe), yt.preventDefault(), ut();
          return
        }
        yt.key === "Alt" && ($t || ($t = !0, vt() && Xt()))
      },
      jt = yt => {
        yt.key === "Alt" && ($t = !1, pr(), or())
      },
      je = () => {
        nt(), !(!$t && !Rt) && ($t = !1, pr(), or())
      };
    return window.addEventListener("keydown", St), window.addEventListener("keyup", jt), window.addEventListener("blur", je), () => {
      var Kt, Cr;
      ne.unsubscribe(), Ce.unsubscribe(), He.unsubscribe(), ht.unsubscribe(), window.removeEventListener("pointermove", Tt), window.removeEventListener("pointerup", dt), window.removeEventListener("pointercancel", dt), window.removeEventListener("resize", rt), window.removeEventListener("keydown", St), window.removeEventListener("keyup", jt), window.removeEventListener("blur", je), nt(), pr(), or(), $t = !1, u.crosshair.clear();
      const yt = (Cr = (Kt = u.map).getCanvas) == null ? void 0 : Cr.call(Kt);
      yt && (yt.style.cursor = ""), W == null || W(), W = void 0
    }
  });

  function Jt() {
    nt(), m(z) || (W == null || W(), W = void 0, H(qe, "area-select"), pr(), or(), $t = !1, Z.x = 0, Z.y = 0, $e.clear(), H(et, m(et) + 1), Pt.clear(), ot.clear(), u.crosshair.clear(), u.onclose())
  }
  async function Ot(ae, J) {
    const Ve = new kn(u.tileSize),
      [tt, Ze] = Ve.latLonToPixelsFloor(ae.lat, ae.lng, u.pixelArtZoom),
      [ne, Ce] = Ve.latLonToPixelsFloor(J.lat, J.lng, u.pixelArtZoom),
      [He, ht] = [Math.min(tt, ne), Math.min(Ze, Ce)],
      [Tt, dt] = [Math.max(tt, ne), Math.max(Ze, Ce)],
      St = Tt - He,
      jt = dt - ht;
    if (St * jt > Fe) return Nt.error(`The selected area is too big. Please select an area smaller than ${Fe.toLocaleString(navigator.language)} pixels.`), [];
    const yt = Math.floor(He / u.tileSize),
      Kt = Math.floor(ht / u.tileSize),
      Cr = Math.floor(Tt / u.tileSize),
      fr = Math.floor(dt / u.tileSize),
      Je = Cr - yt + 1,
      tr = fr - Kt + 1,
      Yt = new Array(tr).fill(0).flatMap((bt, Ue) => new Array(Je).fill(0).map(async (xt, Gt) => {
        const kt = yt + Gt,
          dr = Kt + Ue;
        let ar = 0,
          Ar = 0,
          Kr = u.tileSize - 1,
          Rr = u.tileSize - 1;
        dr === Kt && (Ar = ht % u.tileSize), kt === yt && (ar = He % u.tileSize), dr === fr && (Rr = dt % u.tileSize), kt === Cr && (Kr = Tt % u.tileSize);
        const bi = [kt, dr],
          Yr = [ar, Ar],
          Zr = [Kr, Rr];
        return {
          response: await ui.getPixelAreaInfo({
            season: u.season,
            tile: bi,
            p0: Yr,
            p1: Zr
          }),
          tile: bi,
          p0: Yr,
          p1: Zr
        }
      })),
      Tr = await Promise.all(Yt);
    Pt.clear(), ot.clear();
    const Dr = new Map;
    for (const {
        response: bt,
        p0: Ue,
        p1: xt,
        tile: Gt
      }
      of Tr) {
      const [kt, dr] = Gt, [ar, Ar] = Ue, [Kr, Rr] = xt, Or = Kr - ar + 1, Fr = Rr - Ar + 1;
      for (let ti = 0; ti < Fr; ti++)
        for (let Ai = 0; Ai < Or; Ai++) {
          const bi = ti * Or + Ai,
            Yr = bt.paintedBy[bi];
          let Zr = Dr.get(Yr);
          Zr || (Zr = {
            latitudes: [],
            longitudes: [],
            tileXs: [],
            tileYs: [],
            pixelXs: [],
            pixelYs: [],
            globalPx: [],
            globalPy: [],
            minLat: 1 / 0,
            maxLat: -1 / 0,
            minLon: 1 / 0,
            maxLon: -1 / 0
          }, Dr.set(Yr, Zr));
          const Ii = ar + Ai,
            ki = Ar + ti,
            wi = kt * u.tileSize + (Ii + .5),
            Vi = dr * u.tileSize + (ki + .5),
            [Yi, pt] = Ve.pixelsToLatLon(wi, Vi, u.pixelArtZoom);
          if (Zr.latitudes.push(Yi), Zr.longitudes.push(pt), Zr.tileXs.push(kt), Zr.tileYs.push(dr), Zr.pixelXs.push(Ii), Zr.pixelYs.push(ki), Zr.globalPx.push(wi), Zr.globalPy.push(Vi), Yi < Zr.minLat && (Zr.minLat = Yi), Yi > Zr.maxLat && (Zr.maxLat = Yi), pt < Zr.minLon && (Zr.minLon = pt), pt > Zr.maxLon && (Zr.maxLon = pt), Yr !== 0) {
            const Ft = `${kt}:${dr}:${Ii}:${ki}`,
              zr = {
                key: Ft,
                userId: Yr,
                lat: Yi,
                lon: pt,
                tile: [kt, dr],
                pixel: [Ii, ki],
                globalPx: wi,
                globalPy: Vi
              };
            Pt.set(Ft, zr);
            const Bi = `${kt}:${dr}`;
            let Zi = ot.get(Bi);
            Zi || (Zi = [], ot.set(Bi, Zi)), Zi.push(zr)
          }
        }
    }
    const {
      users: Jr
    } = await ui.getMultipleUsersInfoById([...Dr.keys()]), yr = X1(Jr, bt => bt.id), qt = [...Dr.entries()].map(([bt, Ue]) => ({
      ...yr[bt] ?? {
        id: bt,
        name: "Player",
        deleted: !0
      },
      painted: Ue
    }));
    return qt.sort((bt, Ue) => bt.id === 0 ? 1 : Ue.id === 0 ? -1 : Ue.painted.latitudes.length - bt.painted.latitudes.length), qt
  }
  async function mr({
    preserveSelection: ae = !1
  } = {}) {
    if (v.length < 2) return;
    const J = ae ? new Set([...xe.keys()]) : void 0,
      Ve = ae ? [...$e.keys()] : void 0;
    try {
      H(k, !0);
      const tt = await Ot(v[0], v[1]);
      if (H(b, tt, !0), xe.clear(), $e.clear(), H(et, m(et) + 1), u.crosshair.clear(), ae && (J != null && J.size)) {
        for (const Ze of tt) J.has(Ze.id) && xe.set(Ze.id, Ze);
        for (const Ze of xe.values())
          for (let ne = 0; ne < Ze.painted.latitudes.length; ne++) u.crosshair.place([Ze.painted.latitudes[ne], Ze.painted.longitudes[ne]])
      }
      if (ae && (Ve != null && Ve.length)) {
        let Ze = !1;
        for (const ne of Ve) {
          const Ce = Pt.get(ne);
          Ce && ($e.set(ne, Ce), Ze = !0)
        }
        Ze && H(et, m(et) + 1)
      }
      for (const Ze of $e.values()) u.crosshair.place([Ze.lat, Ze.lon])
    } finally {
      H(k, !1)
    }
  }

  function At(ae) {
    let J = !1;
    for (const Ve of ae)(er(Ve) || Ve.id === 0) && (J = !0);
    J && ya.plop.play()
  }

  function Mt(ae) {
    for (let J = 0; J < ae.latitudes.length; J++) u.crosshair.remove([ae.latitudes[J], ae.longitudes[J]])
  }

  function wt(ae) {
    if (!ae) {
      me = void 0;
      return
    }
    if (v.length >= 2 && m(qe) === "area-select") {
      me = void 0;
      return
    }
    me = ae
  }
  oi(() => {
    v.length < 2 && m(qe) !== "area-select" && H(qe, "area-select");
    const ae = u.map.getCanvas();
    if (!ae) return;
    const J = m(qe) === "user-picker" || m(qe) === "brush-circle" || m(qe) === "brush-square";
    ae.style.cursor = J ? "crosshair" : "", ut()
  }), oi(() => {
    const ae = vt();
    ae || pr(), $t && (ae ? Xt() : or())
  }), oi(() => {
    m(Ge), ut()
  }), oi(() => {
    typeof window < "u" && window.localStorage.setItem(Et, String(Math.trunc(m(Ge))))
  }), oi(() => {
    v.length, v.length < 2 ? (Z.x !== 0 && (Z.x = 0), Z.y !== 0 && (Z.y = 0)) : rt(), Ut(), ur()
  });

  function It() {
    const ae = u.map.getContainer(),
      J = document.createElement("div");
    J.classList.add("selection-rectangle"), J.style.position = "absolute", J.style.pointerEvents = "none", J.style.display = "none", J.style.zIndex = "6", ae.appendChild(J);
    const Ve = document.createElement("div");
    Ve.classList.add("selection-brush"), Ve.style.position = "absolute", Ve.style.pointerEvents = "none", Ve.style.display = "none", Ve.style.zIndex = "7", ae.appendChild(Ve);
    const tt = cr(ae, "horizontal"),
      Ze = cr(ae, "vertical");
    oe = {
      horizontal: tt,
      vertical: Ze
    }, $ = Ve;
    const ne = dt => {
        wt({
          x: dt.point.x,
          y: dt.point.y
        }), Ut(), ur(), ut();
        const St = dt.originalEvent;
        if (!St) {
          Rt && pr();
          return
        }
        if (!Rt && St.altKey && vt()) {
          let jt = !1;
          if (St.buttons & 1 ? (Xt(), Dt = "add", Rt = !0, jt = !0) : St.buttons & 2 && (Xt(), Dt = "remove", Rt = !0, jt = !0), jt && Dt) {
            j(dt, Dt, {
              silent: !0
            });
            return
          }
        }
        if (Rt && Dt) {
          if (!St.altKey || St.buttons === 0) {
            pr();
            return
          }
          j(dt, Dt, {
            silent: !0
          })
        }
      },
      Ce = dt => {
        const St = ae.getBoundingClientRect();
        wt({
          x: dt.clientX - St.left,
          y: dt.clientY - St.top
        }), Ut(), ur(), ut()
      },
      He = () => {
        me = void 0, pr(), Ut(), ur(), ut()
      },
      ht = () => {
        rt(), Ut(), ur(), ut()
      },
      Tt = dt => {
        if (!vt()) return;
        if (!(dt.altKey || $t)) {
          Rt && (pr(), or());
          return
        }
        $t = !0, Xt(), dt.preventDefault(), dt.stopPropagation(), typeof dt.stopImmediatePropagation == "function" && dt.stopImmediatePropagation();
        const St = dt.deltaY < 0 ? 1 : -1,
          jt = (dt.shiftKey ? 10 : 1) * St,
          je = Math.min(Vt, Math.max(ft, m(Ge) + jt));
        je !== m(Ge) && (H(Ge, je, !0), ut())
      };
    return u.map.on("mousemove", ne), ae.addEventListener("pointermove", Ce), ae.addEventListener("mouseleave", He), u.map.on("move", ht), u.map.on("resize", ht), ae.addEventListener("wheel", Tt, {
      passive: !1
    }), ee = J, Ut(), ur(), ut(), () => {
      u.map.off("mousemove", ne), u.map.off("move", ht), u.map.off("resize", ht), ae.removeEventListener("pointermove", Ce), ae.removeEventListener("mouseleave", He), ae.removeEventListener("wheel", Tt), J.remove(), ee = void 0, me = void 0, oe == null || oe.horizontal.remove(), oe == null || oe.vertical.remove(), oe = void 0, $ == null || $.remove(), $ = void 0
    }
  }

  function Ut() {
    const ae = ee;
    if (!ae) return;
    const J = new kn(u.tileSize);
    let Ve, tt, Ze, ne;
    if (v.length >= 2) {
      const Cr = v.map(fr => J.latLonToPixelsFloor(fr.lat, fr.lng, u.pixelArtZoom));
      Ve = Math.min(...Cr.map(([fr]) => fr)), tt = Math.max(...Cr.map(([fr]) => fr)) + 1, Ze = Math.min(...Cr.map(([, fr]) => fr)), ne = Math.max(...Cr.map(([, fr]) => fr)) + 1
    } else if (v.length === 1 && me) {
      const [Cr, fr] = J.latLonToPixelsFloor(v[0].lat, v[0].lng, u.pixelArtZoom), Je = u.map.unproject([me.x, me.y]), [tr, Yt] = J.latLonToPixelsFloor(Je.lat, Je.lng, u.pixelArtZoom);
      Ve = Math.min(Cr, tr), tt = Math.max(Cr, tr) + 1, Ze = Math.min(fr, Yt), ne = Math.max(fr, Yt) + 1
    } else {
      ae.style.display = "none";
      return
    }
    const [Ce, He] = J.pixelsToLatLon(Ve, Ze, u.pixelArtZoom), [ht, Tt] = J.pixelsToLatLon(tt, ne, u.pixelArtZoom), dt = u.map.project([He, Ce]), St = u.map.project([Tt, ht]);
    let jt = Math.min(dt.x, St.x),
      je = Math.max(dt.x, St.x),
      yt = Math.min(dt.y, St.y),
      Kt = Math.max(dt.y, St.y);
    je - jt < 1 && (je = jt + 1), Kt - yt < 1 && (Kt = yt + 1), ae.style.display = "block", ae.style.left = `${jt}px`, ae.style.top = `${yt}px`, ae.style.width = `${je-jt}px`, ae.style.height = `${Kt-yt}px`
  }

  function ut() {
    const ae = $;
    if (!ae) return;
    if (!(m(qe) === "brush-circle" || m(qe) === "brush-square") || !me) {
      ae.style.display = "none";
      return
    }
    const J = new kn(u.tileSize),
      Ve = u.map.unproject([me.x, me.y]),
      [tt, Ze] = J.latLonToPixels(Ve.lat, Ve.lng, u.pixelArtZoom),
      ne = m(Ge) + .5,
      [Ce, He] = J.pixelsToLatLon(tt - ne, Ze - ne, u.pixelArtZoom),
      [ht, Tt] = J.pixelsToLatLon(tt + ne, Ze + ne, u.pixelArtZoom),
      dt = u.map.project([He, Ce]),
      St = u.map.project([Tt, ht]),
      jt = Math.min(dt.x, St.x),
      je = Math.max(dt.x, St.x),
      yt = Math.min(dt.y, St.y),
      Kt = Math.max(dt.y, St.y);
    ae.style.display = "block", ae.style.left = `${jt}px`, ae.style.top = `${yt}px`, ae.style.width = `${Math.max(je-jt,2)}px`, ae.style.height = `${Math.max(Kt-yt,2)}px`, ae.style.borderRadius = m(qe) === "brush-circle" ? "100%" : "4px", ae.dataset.radius = String(m(Ge))
  }

  function ur() {
    const ae = oe;
    if (ae) {
      if (!me || v.length >= 2) {
        br();
        return
      }
      ae.horizontal.style.display = "block", ae.horizontal.style.top = `${me.y}px`, ae.horizontal.style.transform = "translateY(-0.5px)", ae.vertical.style.display = "block", ae.vertical.style.left = `${me.x}px`, ae.vertical.style.transform = "translateX(-0.5px)"
    }
  }

  function br() {
    oe && (oe.horizontal.style.display = "none", oe.vertical.style.display = "none")
  }

  function cr(ae, J) {
    const Ve = document.createElement("div");
    return Ve.style.position = "absolute", Ve.style.pointerEvents = "none", Ve.style.zIndex = "5", Ve.style.display = "none", Ve.style.mixBlendMode = "difference", Ve.style.backgroundColor = "rgba(255, 255, 255, 0.9)", J === "horizontal" ? (Ve.style.left = "0", Ve.style.right = "0", Ve.style.height = "1px") : (Ve.style.top = "0", Ve.style.bottom = "0", Ve.style.width = "1px"), ae.appendChild(Ve), Ve
  }
  async function jr(ae, J = "select") {
    var Ve;
    if (!m(_t)) {
      if (m(k)) {
        Nt.info("Wait until the selected area finishes loading.");
        return
      }
      if (v.length < 2) {
        Nt.info("Select an area first to use the user picker.");
        return
      }
      H(_t, !0);
      try {
        const tt = new kn(u.tileSize),
          {
            tile: Ze,
            pixel: ne
          } = tt.latLonToTileAndPixel(ae.lngLat.lat, ae.lngLat.lng, u.pixelArtZoom),
          {
            paintedBy: Ce
          } = await ui.getPixelInfo({
            season: u.season,
            tile: Ze,
            pixel: ne,
            role: (Ve = Lt.data) == null ? void 0 : Ve.role
          });
        if (!Ce || Ce.id === 0) {
          Nt.info("That pixel is not painted by any player.");
          return
        }
        const He = m(b).find(Tt => Tt.id === Ce.id);
        if (!He) {
          Nt.info("Selected pixel is outside the selected area.");
          return
        }
        if (J === "deselect") {
          if (!xe.has(He.id)) {
            Gr(He.id) ? (ya.plop.play(), Nt.success(`${He.name} deselected`)) : Nt.info("That player is not selected.");
            return
          }
          xe.delete(He.id), Mt(He.painted), Gr(He.id, {
            skipCrosshair: !0
          }), ya.plop.play(), Nt.success(`${He.name} deselected`);
          return
        }
        if (xe.has(He.id)) {
          Nt.info("Player already selected.");
          return
        }
        xe.set(He.id, He), (er(He) || He.id === 0) && ya.plop.play(), Nt.success(`${He.name} selected`)
      } catch (tt) {
        Nt.error(tt.message)
      } finally {
        H(_t, !1)
      }
    }
  }

  function wr(ae, {
    skipCrosshair: J = !1
  } = {}) {
    return $e.has(ae.key) ? !1 : ($e.set(ae.key, ae), J || u.crosshair.place([ae.lat, ae.lon]), !0)
  }

  function Nr(ae, {
    skipCrosshair: J = !1
  } = {}) {
    const Ve = $e.get(ae);
    return Ve ? ($e.delete(ae), J || u.crosshair.remove([Ve.lat, Ve.lon]), !0) : !1
  }

  function Gr(ae, {
    skipCrosshair: J = !1
  } = {}) {
    const Ve = [];
    for (const [Ze, ne] of $e.entries()) ne.userId === ae && Ve.push(Ze);
    let tt = !1;
    for (const Ze of Ve) Nr(Ze, {
      skipCrosshair: J
    }) && (tt = !0);
    return tt && H(et, m(et) + 1), tt
  }

  function er(ae, {
    skipCrosshair: J = !1
  } = {}) {
    if (ae.id === 0) return !1;
    const Ve = ae.painted;
    let tt = !1;
    for (let Ze = 0; Ze < Ve.latitudes.length; Ze++) {
      const ne = Ve.tileXs[Ze],
        Ce = Ve.tileYs[Ze],
        He = Ve.pixelXs[Ze],
        ht = Ve.pixelYs[Ze],
        Tt = `${ne}:${Ce}:${He}:${ht}`;
      let dt = Pt.get(Tt);
      if (!dt) {
        dt = {
          key: Tt,
          userId: ae.id,
          lat: Ve.latitudes[Ze],
          lon: Ve.longitudes[Ze],
          tile: [ne, Ce],
          pixel: [He, ht],
          globalPx: Ve.globalPx[Ze],
          globalPy: Ve.globalPy[Ze]
        }, Pt.set(Tt, dt);
        const St = `${ne}:${Ce}`;
        let jt = ot.get(St);
        jt || (jt = [], ot.set(St, jt)), jt.push(dt)
      }
      wr(dt, {
        skipCrosshair: J
      }) && (tt = !0)
    }
    return tt && H(et, m(et) + 1), tt
  }

  function Wr(ae) {
    return m(b).find(J => J.id === ae)
  }

  function sr(ae, {
    silent: J = !1
  } = {}) {
    let Ve = !1;
    for (const [tt, Ze] of ae) {
      if (xe.has(tt)) continue;
      const ne = Wr(tt);
      if (!ne) continue;
      const Ce = ne.painted.latitudes.length;
      (m(Xe).get(tt) ?? 0) + Ze >= Ce && (xe.set(tt, ne), Ve = !0)
    }
    Ve && !J && ya.plop.play()
  }

  function de(ae, J) {
    if (Pt.size === 0) return [];
    const Ve = new kn(u.tileSize),
      [tt, Ze] = Ve.latLonToPixels(ae, J, u.pixelArtZoom),
      ne = m(Ge) + .5,
      Ce = tt - ne,
      He = tt + ne,
      ht = Ze - ne,
      Tt = Ze + ne,
      dt = Math.floor(Ce / u.tileSize),
      St = Math.floor(He / u.tileSize),
      jt = Math.floor(ht / u.tileSize),
      je = Math.floor(Tt / u.tileSize),
      yt = [];
    for (let Kt = dt; Kt <= St; Kt++)
      for (let Cr = jt; Cr <= je; Cr++) {
        const fr = `${Kt}:${Cr}`,
          Je = ot.get(fr);
        if (Je)
          for (const tr of Je) {
            const Yt = tr.globalPx - tt,
              Tr = tr.globalPy - Ze;
            if (m(qe) === "brush-circle") {
              if (Yt * Yt + Tr * Tr > ne * ne) continue
            } else if (Math.abs(Yt) > ne || Math.abs(Tr) > ne) continue;
            yt.push(tr)
          }
      }
    return yt
  }

  function j(ae, J, {
    silent: Ve = !1
  } = {}) {
    if (m(k)) return Ve || Nt.info("Wait until the selected area finishes loading."), !1;
    if (v.length < 2) return Ve || Nt.info("Select an area first to use the brush tool."), !1;
    const tt = de(ae.lngLat.lat, ae.lngLat.lng);
    if (tt.length === 0) {
      if (!Ve) {
        const Ce = J === "add" ? "No painted pixels found within the brush." : "No selected pixels to remove within the brush.";
        Nt.info(Ce)
      }
      return !1
    }
    let Ze = !1;
    const ne = new Map;
    if (J === "add")
      for (const Ce of tt) xe.has(Ce.userId) || $e.has(Ce.key) || wr(Ce) && (Ze = !0, ne.set(Ce.userId, (ne.get(Ce.userId) ?? 0) + 1));
    else
      for (const Ce of tt) Nr(Ce.key) && (Ze = !0, xe.has(Ce.userId) && xe.delete(Ce.userId));
    return Ze ? (J === "add" && ne.size > 0 && sr(ne, {
      silent: Ve
    }), H(et, m(et) + 1), Ve || ya.plop.play(), !0) : (!Ve && J === "add" && Nt.info("All pixels inside the brush are already selected."), !1)
  }
  async function V() {
    const ae = u.map.getCanvas();
    if (!ae) return Nt.error("Unable to access map canvas."), !1;
    const J = ae.getBoundingClientRect();
    if (!J.width || !J.height) return Nt.error("Map is not visible to capture."), !1;
    let Ve = 1 / 0,
      tt = -1 / 0,
      Ze = 1 / 0,
      ne = -1 / 0;
    for (const Ue of v) {
      const {
        lat: xt,
        lng: Gt
      } = Ue;
      xt < Ve && (Ve = xt), xt > tt && (tt = xt), Gt < Ze && (Ze = Gt), Gt > ne && (ne = Gt)
    }
    if (!isFinite(Ve) || !isFinite(tt) || !isFinite(Ze) || !isFinite(ne)) return Nt.error("Unable to determine selected area."), !1;
    const Ce = u.map.project([Ze, tt]),
      He = u.map.project([ne, Ve]);
    if (!Number.isFinite(Ce.x) || !Number.isFinite(Ce.y) || !Number.isFinite(He.x) || !Number.isFinite(He.y)) return Nt.error("Unable to project selected area on the map."), !1;
    let ht = Math.min(Ce.x, He.x),
      Tt = Math.max(Ce.x, He.x),
      dt = Math.min(Ce.y, He.y),
      St = Math.max(Ce.y, He.y);
    ht = Math.max(0, ht), dt = Math.max(0, dt), Tt = Math.min(J.width, Tt), St = Math.min(J.height, St);
    const jt = Tt - ht,
      je = St - dt;
    if (jt <= 0 || je <= 0) return Nt.error("Selected area is outside the current map view."), !1;
    const yt = ae.width / J.width,
      Kt = ae.height / J.height,
      Cr = Math.floor(ht * yt),
      fr = Math.floor(dt * Kt),
      Je = Math.max(1, Math.ceil(Tt * yt) - Cr),
      tr = Math.max(1, Math.ceil(St * Kt) - fr),
      Yt = await wp(u.map);
    let Tr;
    if ("createImageBitmap" in window) Tr = await createImageBitmap(Yt);
    else {
      const Ue = URL.createObjectURL(Yt);
      Tr = await new Promise((xt, Gt) => {
        const kt = new Image;
        kt.crossOrigin = "anonymous", kt.onload = () => xt(kt), kt.onerror = () => Gt(new Error("Failed to decode map image.")), kt.src = Ue
      }), URL.revokeObjectURL(Ue)
    }
    const Dr = document.createElement("canvas");
    Dr.width = Je, Dr.height = tr;
    const Jr = Dr.getContext("2d");
    if (!Jr) return "close" in Tr && Tr.close(), Nt.error("Unable to create drawing context."), !1;
    Jr.drawImage(Tr, Cr, fr, Je, tr, 0, 0, Je, tr), "close" in Tr && Tr.close();
    const yr = await new Promise((Ue, xt) => {
        Dr.toBlob(Gt => {
          Gt ? Ue(Gt) : xt(new Error("Failed to prepare download."))
        }, "image/png")
      }),
      qt = URL.createObjectURL(yr),
      bt = document.createElement("a");
    return bt.href = qt, bt.download = `selected-map-${Je}x${tr}.png`, document.body.appendChild(bt), bt.click(), document.body.removeChild(bt), URL.revokeObjectURL(qt), !0
  }
  async function X() {
    if (!(m(s) || m(k))) {
      if (v.length < 2) {
        Nt.info(m(B) ? "Select an area first to save the map view." : "Select an area first to save pixel art.");
        return
      }
      H(s, !0);
      try {
        switch (m(B)) {
          case !0:
            if (m(B)) {
              await V() && Nt.success("Selected map view saved");
              return
            }
          case !1:
            const ae = new kn(u.tileSize);
            let J = 1 / 0,
              Ve = -1 / 0,
              tt = 1 / 0,
              Ze = -1 / 0;
            for (let Je = 0; Je < v.length; Je++) {
              const tr = v[Je],
                Yt = ae.latLonToPixelsFloor(tr.lat, tr.lng, u.pixelArtZoom),
                Tr = Yt[0],
                Dr = Yt[1];
              Tr < J && (J = Tr), Tr > Ve && (Ve = Tr), Dr < tt && (tt = Dr), Dr > Ze && (Ze = Dr)
            }
            if (!isFinite(J) || !isFinite(Ve) || !isFinite(tt) || !isFinite(Ze)) {
              Nt.error("Unable to determine selected area.");
              return
            }
            const ne = Ve + 1,
              Ce = Ze + 1,
              He = ne - J,
              ht = Ce - tt;
            if (He <= 0 || ht <= 0) {
              Nt.error("Selected area has no size.");
              return
            }
            const Tt = document.createElement("canvas");
            Tt.width = He, Tt.height = ht;
            const dt = Tt.getContext("2d");
            if (!dt) {
              Nt.error("Unable to create drawing context.");
              return
            }
            const St = Math.floor(J / u.tileSize),
              jt = Math.floor((ne - 1) / u.tileSize),
              je = Math.floor(tt / u.tileSize),
              yt = Math.floor((Ce - 1) / u.tileSize);
            for (let Je = je; Je <= yt; Je++)
              for (let tr = St; tr <= jt; tr++) {
                const Yt = tr * u.tileSize,
                  Tr = Je * u.tileSize,
                  Dr = Math.max(J, Yt),
                  Jr = Math.max(tt, Tr),
                  yr = Math.min(ne, Yt + u.tileSize),
                  qt = Math.min(Ce, Tr + u.tileSize),
                  bt = yr - Dr,
                  Ue = qt - Jr;
                if (bt <= 0 || Ue <= 0) continue;
                const xt = await fetch(`${i0}/s${u.season}/tiles/${tr}/${Je}.png`);
                if (!xt.ok) throw new Error("Failed to load tile image.");
                const Gt = await xt.blob();
                if ("createImageBitmap" in window) {
                  const kt = await createImageBitmap(Gt);
                  dt.drawImage(kt, Dr - Yt, Jr - Tr, bt, Ue, Dr - J, Jr - tt, bt, Ue), kt.close && kt.close()
                } else {
                  const kt = URL.createObjectURL(Gt),
                    dr = await new Promise((ar, Ar) => {
                      const Kr = new Image;
                      Kr.crossOrigin = "anonymous", Kr.onload = () => ar(Kr), Kr.onerror = () => Ar(new Error("Failed to decode tile image.")), Kr.src = kt
                    });
                  dt.drawImage(dr, Dr - Yt, Jr - Tr, bt, Ue, Dr - J, Jr - tt, bt, Ue), URL.revokeObjectURL(kt)
                }
              }
            const Kt = await new Promise((Je, tr) => {
                Tt.toBlob(Yt => {
                  Yt ? Je(Yt) : tr(new Error("Failed to prepare download."))
                }, "image/png")
              }),
              Cr = URL.createObjectURL(Kt),
              fr = document.createElement("a");
            fr.href = Cr, fr.download = `selected-area-${He}x${ht}.png`, document.body.appendChild(fr), fr.click(), document.body.removeChild(fr), URL.revokeObjectURL(Cr), Nt.success("Selected area image saved")
        }
      } catch (ae) {
        Nt.error(ae.message)
      } finally {
        H(s, !1)
      }
    }
  }
  async function re() {
    if (m(T) || m(k)) return;
    const ae = new Map;
    for (const J of xe.values()) {
      if (J.id === 0) continue;
      const {
        tileXs: Ve,
        tileYs: tt,
        pixelXs: Ze,
        pixelYs: ne
      } = J.painted;
      for (let Ce = 0; Ce < Ve.length; Ce++) {
        const He = [Ve[Ce], tt[Ce]],
          ht = [Ze[Ce], ne[Ce]],
          Tt = {
            tile: He,
            pixel: ht,
            season: u.season
          },
          dt = `${He[0]}:${He[1]}:${ht[0]}:${ht[1]}`;
        ae.set(dt, Tt)
      }
    }
    for (const J of $e.values()) xe.has(J.userId) || ae.has(J.key) || ae.set(J.key, {
      tile: J.tile,
      pixel: J.pixel,
      season: u.season
    });
    if (ae.size === 0) {
      Nt.info("Select painted pixels to clear with transparent color");
      return
    }
    H(T, !0);
    try {
      ya.droppletAndPlop.play();
      const J = await og(),
        Ve = [];
      for (const ne of ae.values()) Ve.push({
        ...ne,
        colorIdx: 0
      });
      await ui.selectAreaClear(Ve, J);
      const tt = _p(0),
        Ze = Ve.map(({
          tile: ne,
          pixel: Ce,
          season: He
        }) => ({
          tile: ne,
          pixel: Ce,
          season: He,
          color: tt
        }));
      await Zm(Ze), Nt.success("Painted selected pixels with transparent color"), await mr()
    } catch (J) {
      Nt.error(J.message)
    } finally {
      H(T, !1)
    }
  }
  const Q = ae => ({
    id: ae.id,
    name: ae.name,
    picture: ae.picture,
    allianceId: ae.allianceId ?? void 0,
    allianceName: ae.allianceName ?? void 0,
    timedOut: ae.timedOut,
    banned: ae.banned,
    deleted: ae.deleted
  });

  function ue() {
    const ae = new Map;
    for (const J of xe.values()) J.id !== 0 && ae.set(J.id, J);
    if ($e.size > 0) {
      let J;
      for (const Ve of $e.values()) {
        const tt = Ve.userId;
        if (tt === 0 || ae.has(tt)) continue;
        if (!J) {
          J = new Map;
          for (const ne of m(b)) J.set(ne.id, ne)
        }
        const Ze = J.get(tt);
        Ze && ae.set(Ze.id, Ze)
      }
    }
    return [...ae.values()]
  }
  async function Te(ae, J) {
    try {
      H(z, !0);
      const Ve = ae.filter(dt => dt.id !== 0);
      if (Ve.length === 0) {
        Nt.info("Select at least one player");
        return
      }
      let tt = 1 / 0,
        Ze = -1 / 0,
        ne = 1 / 0,
        Ce = -1 / 0;
      if (v.length >= 2)
        for (const dt of v) {
          const {
            lat: St,
            lng: jt
          } = dt;
          !isFinite(St) || !isFinite(jt) || (St < tt && (tt = St), St > Ze && (Ze = St), jt < ne && (ne = jt), jt > Ce && (Ce = jt))
        }
      tt === Ze && (tt -= 1e-6, Ze += 1e-6), ne === Ce && (ne -= 1e-6, Ce += 1e-6), u.map.stop();
      const He = u.map.getCanvas(),
        ht = Math.max(48, Math.min(He.width, He.height) * .08);
      u.map.fitBounds([
        [Math.min(ne, Ce), Math.min(tt, Ze)],
        [Math.max(ne, Ce), Math.max(tt, Ze)]
      ], {
        padding: ht,
        duration: 0
      });
      const Tt = (async () => await wp(u.map, {
        maxHeight: 1080,
        maxWidth: 1080,
        quality: .8,
        type: "image/jpeg"
      }))();
      u.onmodaction({
        action: J,
        targets: Ve.map(Q),
        image: Tt,
        latLon: [(tt + Ze) / 2, (ne + Ce) / 2],
        zoom: u.map.getZoom(),
        onSuccess: async () => {
          await mr({
            preserveSelection: !0
          })
        }
      })
    } catch (Ve) {
      Nt.error(Ve.message)
    } finally {
      H(z, !1)
    }
  }
  var be = Sr();
  Mi("keydown", Oo, ae => ae.code === "Escape" && Jt());
  var ze = Ct(be);
  {
    var We = ae => {
        Tc(ae, {
          class: "bg-warning animate-bounce",
          children: (J, Ve) => {
            var tt = Rk(),
              Ze = Ct(tt);
            Bm(Ze, {
              class: "inline size-5"
            });
            var ne = D(Ze, 2);
            {
              var Ce = ht => {
                  var Tt = Ba();
                  Re(dt => te(Tt, dt), [() => qw()]), q(ht, Tt)
                },
                He = ht => {
                  var Tt = Sr(),
                    dt = Ct(Tt);
                  {
                    var St = jt => {
                      var je = Ba();
                      Re(yt => te(je, yt), [() => Zw()]), q(jt, je)
                    };
                    Se(dt, jt => {
                      v.length === 1 && jt(St)
                    }, !0)
                  }
                  q(ht, Tt)
                };
              Se(ne, ht => {
                v.length === 0 ? ht(Ce) : ht(He, !1)
              })
            }
            q(J, tt)
          },
          $$slots: {
            default: !0
          }
        })
      },
      Be = ae => {
        var J = Qk();
        let Ve;
        var tt = I(J),
          Ze = I(tt),
          ne = I(Ze);
        ne.__pointerdown = Zt, uo(ne, "", {}, {
          "touch-action": "none"
        });
        var Ce = I(ne),
          He = I(Ce),
          ht = I(He);
        Bm(ht, {
          class: "size-4"
        }), P(He);
        var Tt = D(He, 4),
          dt = I(Tt);
        P(Tt), P(Ce);
        var St = D(Ce, 2),
          jt = I(St),
          je = I(jt);
        je.__click = () => {
          H(B, m(B) !== !0)
        };
        var yt = I(je);
        zk(yt, {
          class: "h-4 w-4"
        });
        var Kt = D(yt, 2);
        Xa(Kt), P(je);
        var Cr = D(je, 2);
        Cr.__click = X;
        var fr = I(Cr);
        {
          var Je = Fr => {
              var ti = Fk();
              q(Fr, ti)
            },
            tr = Fr => {
              Qm(Fr, {
                class: "size-4"
              })
            };
          Se(fr, Fr => {
            m(s) ? Fr(Je) : Fr(tr, !1)
          })
        }
        P(Cr), P(jt);
        var Yt = D(jt, 2);
        let Tr;
        Yt.__click = () => {
          if (m(qe) === "brush-circle") {
            H(qe, "area-select");
            return
          }
          if (m(k)) {
            Nt.info("Wait until the selected area finishes loading.");
            return
          }
          if (v.length < 2) {
            Nt.info("Select an area first to use the brush tools.");
            return
          }
          H(qe, "brush-circle")
        };
        var Dr = I(Yt);
        kk(Dr, {
          class: "size-4"
        }), P(Yt);
        var Jr = D(Yt, 2);
        let yr;
        Jr.__click = () => {
          if (m(qe) === "brush-square") {
            H(qe, "area-select");
            return
          }
          if (m(k)) {
            Nt.info("Wait until the selected area finishes loading.");
            return
          }
          if (v.length < 2) {
            Nt.info("Select an area first to use the brush tools.");
            return
          }
          H(qe, "brush-square")
        };
        var qt = I(Jr);
        Dk(qt, {
          class: "size-4"
        }), P(Jr);
        var bt = D(Jr, 2);
        let Ue;
        bt.__click = () => {
          if (m(qe) === "user-picker") {
            H(qe, "area-select");
            return
          }
          if (m(k)) {
            Nt.info("Wait until the selected area finishes loading.");
            return
          }
          if (v.length < 2) {
            Nt.info("Select an area first to use the user picker.");
            return
          }
          H(qe, "user-picker")
        };
        var xt = I(bt);
        {
          var Gt = Fr => {
              var ti = Bk();
              q(Fr, ti)
            },
            kt = Fr => {
              Ck(Fr, {
                class: "size-4"
              })
            };
          Se(xt, Fr => {
            m(_t) ? Fr(Gt) : Fr(kt, !1)
          })
        }
        P(bt);
        var dr = D(bt, 2);
        dr.__click = Jt;
        var ar = I(dr);
        Ls(ar, {
          class: "size-4"
        }), P(dr), P(St), P(ne);
        var Ar = D(ne, 2),
          Kr = I(Ar);
        {
          var Rr = Fr => {
              var ti = Ok();
              q(Fr, ti)
            },
            Or = Fr => {
              var ti = Sr(),
                Ai = Ct(ti);
              {
                var bi = Zr => {
                    var Ii = jk();
                    q(Zr, Ii)
                  },
                  Yr = Zr => {
                    var Ii = Jk(),
                      ki = I(Ii),
                      wi = I(ki),
                      Vi = I(wi),
                      Yi = I(Vi),
                      pt = I(Yi);
                    Xa(pt), pt.__click = hi => {
                      if (m(De) === "none") {
                        $e.clear(), H(et, m(et) + 1), u.crosshair.clear();
                        const kr = [];
                        for (const mi of m(b)) xe.has(mi.id) || (xe.set(mi.id, mi), kr.push(mi));
                        kr.length && At(kr);
                        return
                      }
                      xe.clear(), $e.clear(), H(et, m(et) + 1), u.crosshair.clear()
                    }, P(Yi);
                    var Ft = D(Yi),
                      zr = D(I(Ft));
                    zr.__click = () => {
                      navigator.clipboard.writeText([...xe.keys()].filter(hi => hi !== 0).join(", ")), Nt.success("Player IDs copied to clipboard")
                    };
                    var Bi = I(zr);
                    tg(Bi, {
                      class: "size-3"
                    }), P(zr);
                    var Zi = D(zr, 2);
                    {
                      var Ta = hi => {
                        var kr = qk();
                        kr.__click = () => {
                          const Ir = ue();
                          Te(Ir, "timeout")
                        };
                        var mi = I(kr);
                        Xu(mi, {
                          class: "size-4"
                        }), P(kr), Re(() => kr.disabled = m(z)), q(hi, kr)
                      };
                      Se(Zi, hi => {
                        Lt.hasPermission(za.tools.selectArea.timeout) && hi(Ta)
                      })
                    }
                    var Xi = D(Zi, 2);
                    {
                      var ji = hi => {
                        var kr = Vk();
                        kr.__click = () => {
                          const Ir = ue();
                          Te(Ir, "ban")
                        };
                        var mi = I(kr);
                        vp(mi, {
                          class: "size-4"
                        }), P(kr), Re(() => kr.disabled = m(z)), q(hi, kr)
                      };
                      Se(Xi, hi => {
                        Lt.hasPermission(za.tools.selectArea.ban) && hi(ji)
                      })
                    }
                    P(Ft);
                    var La = D(Ft),
                      Br = I(La);
                    {
                      var Pr = hi => {
                        var kr = Nk();
                        kr.__click = re;
                        var mi = I(kr);
                        {
                          var Ir = Ni => {
                              var Oi = Zk();
                              q(Ni, Oi)
                            },
                            ei = Ni => {
                              rm(Ni, {
                                class: "size-4"
                              })
                            };
                          Se(mi, Ni => {
                            m(T) ? Ni(Ir) : Ni(ei, !1)
                          })
                        }
                        P(kr), Re(() => kr.disabled = m(T) || m(k) || xe.size === 0 && m(Ae) === 0), q(hi, kr)
                      };
                      Se(Br, hi => {
                        Lt.hasPermission(za.tools.selectArea.clear) && hi(Pr)
                      })
                    }
                    vi(), P(La), P(Vi), P(wi);
                    var zi = D(wi);
                    na(zi, 23, () => m(b), hi => hi.id, (hi, kr, mi, Ir) => {
                      const ei = mt(() => xe.has(m(kr).id)),
                        Ni = mt(() => m(Xe).get(m(kr).id) ?? 0),
                        Oi = mt(() => m(ei) || m(Ni) > 0);
                      var Ei = Kk();
                      let Si;
                      Ei.__click = () => {
                        m(ei) ? (xe.delete(m(kr).id), Mt(m(kr).painted), Gr(m(kr).id, {
                          skipCrosshair: !0
                        })) : (Gr(m(kr).id, {
                          skipCrosshair: !0
                        }), xe.set(m(kr).id, m(kr)), (er(m(kr)) || m(kr).id === 0) && ya.plop.play())
                      };
                      var Pi = I(Ei),
                        di = I(Pi);
                      Xa(di), P(Pi);
                      var li = D(Pi),
                        rn = I(li);
                      {
                        var Ui = ca => {
                            var Pa = Uk();
                            vi(2), q(ca, Pa)
                          },
                          ra = ca => {
                            var Pa = Xk(),
                              ja = Ct(Pa);
                            Dn(ja, {
                              class: "size-5 border-0",
                              get userId() {
                                return m(kr).id
                              },
                              get pictureUrl() {
                                return m(kr).picture
                              }
                            });
                            var Ti = D(ja, 2),
                              bn = I(Ti),
                              gi = I(bn),
                              _i = I(gi, !0);
                            P(gi);
                            var Bn = D(gi, 2),
                              Li = I(Bn);
                            P(Bn), P(bn);
                            var On = D(bn, 2);
                            {
                              var qa = ua => {
                                var Ma = Gk(),
                                  fn = I(Ma, !0);
                                P(Ma), Re((ha, Vn) => {
                                  Vr(Ma, 1, `badge badge-sm ml-0.5 border-0 ${ha??""} ${Vn??""}`, "svelte-15blegn"), te(fn, m(kr).allianceName)
                                }, [() => Cp(m(kr).allianceId), () => tn(m(kr).allianceId)]), q(ua, Ma)
                              };
                              Se(On, ua => {
                                m(kr).allianceId && ua(qa)
                              })
                            }
                            var Qn = D(On, 2);
                            {
                              var jn = ua => {
                                var Ma = Wk();
                                q(ua, Ma)
                              };
                              Se(Qn, ua => {
                                m(kr).deleted && ua(jn)
                              })
                            }
                            var wn = D(Qn, 2),
                              ns = I(wn);
                            {
                              var qn = ua => {
                                  var Ma = Hk(),
                                    fn = I(Ma);
                                  vp(fn, {
                                    class: "text-error size-4"
                                  }), P(Ma), Re(ha => Qt(Ma, "data-tip", ha), [() => Jm()]), q(ua, Ma)
                                },
                                es = ua => {
                                  var Ma = Sr(),
                                    fn = Ct(Ma);
                                  {
                                    var ha = Vn => {
                                      var Fs = $k(),
                                        _o = I(Fs);
                                      Xu(_o, {
                                        class: "text-error size-4"
                                      }), P(Fs), Re(Gi => Qt(Fs, "data-tip", Gi), [() => C0()]), q(Vn, Fs)
                                    };
                                    Se(fn, Vn => {
                                      m(kr).timedOut && Vn(ha)
                                    }, !0)
                                  }
                                  q(ua, Ma)
                                };
                              Se(ns, ua => {
                                m(kr).banned ? ua(qn) : ua(es, !1)
                              })
                            }
                            P(wn), P(Ti), Re(ua => {
                              Vr(bn, 1, `font-medium ${ua??""} flex gap-1.5`, "svelte-15blegn"), te(_i, m(kr).name), te(Li, `#${m(kr).id??""}`)
                            }, [() => tn(m(kr).id)]), q(ca, Pa)
                          };
                        Se(rn, ca => {
                          m(kr).id === 0 ? ca(Ui) : ca(ra, !1)
                        })
                      }
                      P(li);
                      var sa = D(li),
                        Da = I(sa),
                        Sa = D(Da);
                      {
                        var Ki = ca => {
                          var Pa = Yk(),
                            ja = I(Pa);
                          P(Pa), Re(Ti => te(ja, `(${Ti??""} selected)`), [() => m(Ni).toLocaleString(navigator.language)]), q(ca, Pa)
                        };
                        Se(Sa, ca => {
                          !m(ei) && m(Ni) > 0 && ca(Ki)
                        })
                      }
                      P(sa), P(Ei), Re(ca => {
                        Si = Vr(Ei, 1, "hover:bg-base-300 cursor-pointer svelte-15blegn", null, Si, {
                          "bg-base-200": m(Oi)
                        }), em(di, m(ei)), di.indeterminate = !m(ei) && m(Ni) > 0, te(Da, `${ca??""} `)
                      }, [() => m(kr).painted.latitudes.length.toLocaleString(navigator.language)]), q(hi, Ei)
                    }), P(zi), P(ki), P(Ii), Re(() => {
                      em(pt, m(De) !== "none"), pt.indeterminate = m(De) === "some"
                    }), q(Zr, Ii)
                  };
                Se(Ai, Zr => {
                  m(b).length === 0 ? Zr(bi) : Zr(Yr, !1)
                }, !0)
              }
              q(Fr, ti)
            };
          Se(Kr, Fr => {
            m(k) ? Fr(Rr) : Fr(Or, !1)
          })
        }
        P(Ar), P(Ze), P(tt), P(J), Rn(J, Fr => H(_e, Fr), () => m(_e)), Re((Fr, ti) => {
          Ve = uo(J, "", Ve, {
            transform: `translate3d(${Z.x}px, ${Z.y}px, 0)`,
            "will-change": "transform"
          }), te(dt, `(Pixels: ${Fr??""})`), Qt(Kt, "aria-label", `${ti??""} toggle`), Qt(Cr, "data-tip", m(B) ? "Save selected map view" : "Save selected pixel art"), Cr.disabled = m(s) || m(k), Tr = Vr(Yt, 1, "btn btn-xs tooltip tooltip-bottom svelte-15blegn", null, Tr, {
            "btn-soft": m(qe) !== "brush-circle",
            "btn-primary": m(qe) === "brush-circle"
          }), Qt(Yt, "data-tip", `Circle brush (Alt + scroll to resize)  Size: ${m(Le)}`), Qt(Yt, "aria-label", m(qe) === "brush-circle" ? "Disable circle brush tool" : `Enable circle brush tool (size ${m(Le)})`), Qt(Yt, "aria-pressed", m(qe) === "brush-circle"), yr = Vr(Jr, 1, "btn btn-xs tooltip tooltip-bottom svelte-15blegn", null, yr, {
            "btn-soft": m(qe) !== "brush-square",
            "btn-primary": m(qe) === "brush-square"
          }), Qt(Jr, "data-tip", `Square brush (Alt + scroll to resize)  Size: ${m(Le)}`), Qt(Jr, "aria-label", m(qe) === "brush-square" ? "Disable square brush tool" : `Enable square brush tool (size ${m(Le)})`), Qt(Jr, "aria-pressed", m(qe) === "brush-square"), Ue = Vr(bt, 1, "btn btn-xs tooltip tooltip-bottom svelte-15blegn", null, Ue, {
            "btn-soft": m(qe) !== "user-picker",
            "btn-primary": m(qe) === "user-picker"
          }), Qt(bt, "data-tip", m(qe) === "user-picker" ? "User picker enabled. Click pixels to select their painter." : "Enable the user picker to select a player by clicking a pixel."), Qt(bt, "aria-label", m(qe) === "user-picker" ? "Disable user picker tool" : "Enable user picker tool"), Qt(bt, "aria-pressed", m(qe) === "user-picker")
        }, [() => m(Ye).toLocaleString(navigator.language), () => Vw()]), gp(Kt, () => m(B), Fr => H(B, Fr)), pn(3, tt, () => ip, () => ({
          duration: 100
        })), q(ae, J)
      };
    Se(ze, ae => {
      v.length < 2 ? ae(We) : ae(Be, !1)
    })
  }
  q(y, be), ii()
}
$i(["pointerdown", "click"]);
var t8 = Xr('<svg><path d="M382-240 154-468l57-57 171 171 367-367 57 57-424 424Z"></path></svg>');

function pg(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = t8();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var r8 = Xr('<svg><path d="M791-55 686-160H160v-112q0-34 17.5-62.5T224-378q45-23 91.5-37t94.5-21L55-791l57-57 736 736-57 57ZM240-240h366L486-360h-6q-56 0-111 13.5T260-306q-9 5-14.5 14t-5.5 20v32Zm496-138q29 14 46 42.5t18 61.5L666-408q18 7 35.5 14t34.5 16ZM568-506l-59-59q23-9 37-29.5t14-45.5q0-33-23.5-56.5T480-720q-25 0-45.5 14T405-669l-59-59q23-34 58-53t76-19q66 0 113 47t47 113q0 41-19 76t-53 58Zm38 266H240h366ZM457-617Z"></path></svg>');

function i8(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = r8();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var a8 = Xr('<svg><path d="m233-120 65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Z"></path></svg>'),
  n8 = Xr('<svg><path d="m354-287 126-76 126 77-33-144 111-96-146-13-58-136-58 135-146 13 111 97-33 143ZM233-120l65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Zm247-350Z"></path></svg>');

function s8(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy", "filled"]);
  var b = Sr(),
    k = Ct(b);
  {
    var z = s => {
        var B = a8();
        Lr(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...v
        })), q(s, B)
      },
      T = s => {
        var B = n8();
        Lr(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...v
        })), q(s, B)
      };
    Se(k, s => {
      u.filled ? s(z) : s(T, !1)
    })
  }
  q(y, b)
}
var o8 = he('<a target="_blank"><button class="btn btn-xs py-3"><!></button></a>'),
  l8 = he('<button><span class="font-flag tooltip"> </span> <span class="line-clamp-1 text-ellipsis"> </span> <span> </span></button> <!>', 1),
  c8 = he('<div class="skeleton h-5 w-16"></div>'),
  u8 = he('<div class="skeleton mt-1 h-5 w-32"></div>'),
  h8 = he('<div class="flex items-center gap-1"><span> </span> <div class="ml-0.5"><div class="bg-base-content/20 flex size-5 items-center justify-center rounded-full text-sm"></div></div> <div class="flex flex-wrap items-center gap-1"><span class="flex gap-1.5 font-medium text-orange-500"><span>Christmas</span></span></div></div>'),
  d8 = he('<img alt="Frame equipado" class="pointer-events-none absolute inset-0 h-6 w-6 select-none"/>'),
  p8 = he('<span class="font-flag tooltip ml-0.5"> </span>'),
  f8 = he("<button><!></button>"),
  m8 = he("<span> </span> <!>", 1),
  g8 = he('<span class="tooltip"><!></span>'),
  _8 = he('<span class="tooltip"><!></span>'),
  v8 = he("<li><button><!> </button></li>"),
  y8 = he("<li><button><!> </button></li>"),
  x8 = he("<li><button><!> </button></li>"),
  b8 = he('<li><button class="text-error font-medium"><!> </button></li>'),
  w8 = he('<div class="dropdown dropdown-top max-sm:dropdown-top max-sm:dropdown-left ml-1"><button tabindex="0" class="btn btn-xs btn-circle"><!></button> <ul tabindex="0" class="dropdown-content menu bg-base-100 z-1 mb-1 w-max gap-0.5 rounded-xl p-2.5 shadow-sm"></ul></div>'),
  T8 = he('<div class="flex items-center gap-1"><span> </span> <div class="relative ml-0.5 h-5 w-6"><div class="ml-0.5"><!></div> <!></div> <div class="flex flex-wrap items-center gap-1"><span><span> </span> <span> </span></span> <!> <!> <!> <!> <!></div> <!></div>'),
  S8 = he('<button class="btn btn-primary"><!> </button>'),
  P8 = he("<!> ", 1),
  M8 = he("<!> ", 1),
  I8 = he('<button class="btn btn-primary"><!></button>'),
  C8 = he("<button><!> </button>"),
  A8 = he('<div><div class="flex gap-2 px-3"><div class="flex grow gap-1"><button class="btn btn-sm btn-circle btn-soft"><!></button> <h2 class="mt-0.5 flex items-center gap-2 text-lg"><span class="whitespace-nowrap"> </span> <!></h2></div> <button class="btn btn-circle btn-sm"><!></button></div> <div class="text-base-content/80 mt-1 px-3 text-sm"><!></div> <div class="hide-scrollbar flex max-w-full gap-1.5 overflow-x-auto px-3 pb-2 pt-3 sm:pb-3"><!> <!> <button class="btn btn-primary btn-soft"><!> </button></div></div>');

function k8(y, u) {
  ri(u, !0);
  let v = Ke(void 0);
  const b = mt(() => new kn(u.tileSize));
  let k = Ke(void 0),
    z = Ke(void 0),
    T = Ke(!1),
    s = Ke(!1);
  const B = mt(() => {
      var nt, rt, Zt;
      return !!((rt = (nt = m(v)) == null ? void 0 : nt.paintedBy) != null && rt.id) && ((Zt = Lt.data) == null ? void 0 : Zt.id) === m(v).paintedBy.id
    }),
    W = mt(() => {
      const [nt, rt] = u.latLon ?? [0, 0];
      return `https://wplace.eralyon.net/?lat=${nt}&lng=${rt}&zoom=${u.zoom}`
    }),
    ee = mt(() => {
      const [nt, rt] = u.latLon ?? [0, 0], Zt = m(b).latLonToPixelBoundsLatLon(nt, rt, u.pixelArtZoom), Jt = ig(Zt), {
        tile: Ot,
        pixel: mr
      } = m(b).latLonToTileAndPixel(nt, rt, u.pixelArtZoom), At = m(b).latLonToRegionAndPixel(nt, rt, u.pixelArtZoom);
      return {
        lat: nt,
        lon: rt,
        bounds: Zt,
        center: Jt,
        tile: Ot,
        pixel: mr,
        regionPixel: At.pixel
      }
    });
  oi(() => {
    ya.plop.play(), u.crosshair.clearAndPlace(u.latLon)
  });
  let $ = 0;
  const oe = ({
    pixel: nt,
    tile: rt,
    season: Zt
  }) => `s${Zt}:p(${nt[0]},${nt[1]}):t(${rt[0]},${rt[1]})`;
  let me;
  ho(() => [m(ee), u.season], () => {
    const nt = {
      ...m(ee),
      season: u.season
    };
    u.christmasTreeId !== void 0 && (nt.christmasTreeId = u.christmasTreeId);
    const rt = oe(nt);
    if (H(v, u.pixelInfoCache.get(rt), !0), m(v) !== void 0) return;
    u.pixelInfoCache.size === 0 && ($ = 0), $++, $ > 6 ? (clearTimeout(me), me = setTimeout(async () => _e(nt), 500)) : _e(nt)
  });
  async function _e(nt) {
    var Jt;
    const rt = await ui.getPixelInfo({
      ...nt,
      role: (Jt = Lt.data) == null ? void 0 : Jt.role,
      christmasTreeId: u.christmasTreeId
    });
    if (rt.paintedBy !== void 0) {
      const Ot = oe(nt);
      u.pixelInfoCache.set(Ot, rt)
    }
    const Zt = oe({
      ...m(ee),
      season: u.season
    });
    return H(v, u.pixelInfoCache.get(Zt), !0), rt
  }
  $a(() => () => {
    u.crosshair.clear(), ya.smallPlop.play()
  });
  const Z = mt(() => {
    const nt = [];
    return Lt.hasPermission(za.tools.selectPixel.ban) && nt.push("ban-user"), Lt.hasPermission(za.tools.selectPixel.timeout) && nt.push("timeout-user"), !m(B) && Lt.data && nt.push("report-user"), nt
  });

  function Ie(nt) {
    const rt = (async () => await wp(u.map, {
      maxHeight: 1080,
      maxWidth: 1080,
      quality: .8,
      type: "image/jpeg"
    }))();
    u.onclickmodaction(m(v), rt, u.latLon, nt)
  }
  async function we() {
    try {
      await ui.claimEventPixel(u.christmasTreeId), await _e({
        ...m(ee),
        season: u.season
      }), await ui.getChristmasLocations(), await Lt.refresh()
    } catch (nt) {
      Nt.error(nt.message)
    }
  }
  var Fe = A8();
  Mi("keypress", Oo, nt => {
    nt.key === "Escape" && u.onclose()
  });
  var xe = I(Fe),
    $e = I(xe),
    et = I($e);
  et.__click = () => {
    if (m(k) && m(z)) {
      const nt = m(k) - m(z).clientHeight,
        rt = m(k) / 2 - nt / 2;
      u.map.flyTo({
        center: {
          lat: m(ee).center[0],
          lng: m(ee).center[1]
        },
        zoom: 17.5,
        offset: [0, -rt]
      })
    }
  };
  var Xe = I(et);
  Lp(Xe, {
    class: "fill-primary size-5"
  }), P(et);
  var Ae = D(et, 2),
    De = I(Ae),
    Ye = I(De);
  P(De);
  var Le = D(De, 2);
  {
    var qe = nt => {
        const rt = mt(() => m(v).region),
          Zt = mt(() => zs(m(rt).countryId));
        var Jt = l8(),
          Ot = Ct(Jt);
        Ot.__click = () => u.onclickregion(m(rt));
        var mr = I(Ot),
          At = I(mr, !0);
        P(mr);
        var Mt = D(mr, 2),
          wt = I(Mt, !0);
        P(Mt);
        var It = D(Mt, 2),
          Ut = I(It);
        P(It), P(Ot);
        var ut = D(Ot, 2);
        {
          var ur = br => {
            var cr = o8(),
              jr = I(cr),
              wr = I(jr);
            fy(wr, {
              class: "h-4 w-4"
            }), P(jr), P(cr), Re(() => Qt(cr, "href", m(W))), q(br, cr)
          };
          Se(ut, br => {
            var cr;
            ((cr = Lt.data) == null ? void 0 : cr.role) !== "user" && Lt.hasPermission(za.tools.selectPixel.archive) && br(ur)
          })
        }
        Re(br => {
          Vr(Ot, 1, `btn btn-xs flex gap-1 py-3 text-sm max-sm:max-w-32 ${br??""}`), Qt(mr, "data-tip", m(Zt).name), te(At, m(Zt).flag), te(wt, m(rt).name), te(Ut, `#${m(rt).number??""}`)
        }, [() => tn(m(rt).cityId)]), q(nt, Jt)
      },
      _t = nt => {
        var rt = c8();
        q(nt, rt)
      };
    Se(Le, nt => {
      var rt;
      (rt = m(v)) != null && rt.region ? nt(qe) : nt(_t, !1)
    })
  }
  P(Ae), P($e);
  var Qe = D($e, 2);
  Qe.__click = function(...nt) {
    var rt;
    (rt = u.onclose) == null || rt.apply(this, nt)
  };
  var Ge = I(Qe);
  Ls(Ge, {
    class: "size-4"
  }), P(Qe), P(xe);
  var ft = D(xe, 2),
    Vt = I(ft);
  {
    var Et = nt => {
        var rt = u8();
        q(nt, rt)
      },
      Pt = nt => {
        var rt = Sr(),
          Zt = Ct(rt);
        {
          var Jt = mr => {
              var At = Ba();
              Re(Mt => te(At, Mt), [() => $w()]), q(mr, At)
            },
            Ot = mr => {
              var At = Sr(),
                Mt = Ct(At);
              {
                var wt = Ut => {
                    var ut = h8(),
                      ur = I(ut),
                      br = I(ur);
                    P(ur), vi(4), P(ut), Re(cr => te(br, `${cr??""}:`), [() => Xw()]), q(Ut, ut)
                  },
                  It = Ut => {
                    const ut = mt(() => m(v).paintedBy);
                    var ur = T8(),
                      br = I(ur),
                      cr = I(br);
                    P(br);
                    var jr = D(br, 2),
                      wr = I(jr),
                      Nr = I(wr);
                    Dn(Nr, {
                      class: "size-5 border-0",
                      get userId() {
                        return m(ut).id
                      },
                      get pictureUrl() {
                        return m(ut).picture
                      }
                    }), P(wr);
                    var Gr = D(wr, 2);
                    {
                      var er = ne => {
                        var Ce = d8();
                        Re(() => Qt(Ce, "src", m(ut).equippedFrameUrl)), q(ne, Ce)
                      };
                      Se(Gr, ne => {
                        m(ut).equippedFrameUrl && ne(er)
                      })
                    }
                    P(jr);
                    var Wr = D(jr, 2),
                      sr = I(Wr),
                      de = I(sr),
                      j = I(de, !0);
                    P(de);
                    var V = D(de, 2),
                      X = I(V);
                    P(V), P(sr);
                    var re = D(sr, 2);
                    {
                      var Q = ne => {
                        const Ce = mt(() => zs(m(ut).equippedFlag));
                        var He = p8(),
                          ht = I(He, !0);
                        P(He), Re(() => {
                          Qt(He, "data-tip", m(Ce).name), te(ht, m(Ce).flag)
                        }), q(ne, He)
                      };
                      Se(re, ne => {
                        m(ut).equippedFlag && ne(Q)
                      })
                    }
                    var ue = D(re, 2);
                    {
                      var Te = ne => {
                        zh(ne, {
                          get username() {
                            return m(ut).discord
                          },
                          get id() {
                            return m(ut).discordId
                          }
                        })
                      };
                      Se(ue, ne => {
                        m(ut).discord && ne(Te)
                      })
                    }
                    var be = D(ue, 2);
                    {
                      var ze = ne => {
                        I0(ne, {
                          get role() {
                            return m(ut).role
                          },
                          big: !1
                        })
                      };
                      Se(be, ne => {
                        m(ut).role && m(ut).role !== "user" && ne(ze)
                      })
                    }
                    var We = D(be, 2);
                    {
                      var Be = ne => {
                        var Ce = m8(),
                          He = Ct(Ce),
                          ht = I(He, !0);
                        P(He);
                        var Tt = D(He, 2);
                        {
                          var dt = St => {
                            var jt = f8();
                            jt.__click = () => {
                              navigator.clipboard.writeText(m(ut).allianceId.toString()), Nt.success(Wm())
                            };
                            var je = I(jt);
                            tg(je, {
                              class: "size-3"
                            }), P(jt), Re((yt, Kt) => {
                              Vr(jt, 1, yt), Qt(jt, "title", Kt)
                            }, [() => jo(tn(m(ut).allianceId)), () => h3({
                              allianceId: m(ut).allianceId
                            })]), q(St, jt)
                          };
                          Se(Tt, St => {
                            var jt, je, yt;
                            (((jt = Lt.data) == null ? void 0 : jt.role) === "admin" || ((je = Lt.data) == null ? void 0 : je.role) === "moderator" || ((yt = Lt.data) == null ? void 0 : yt.role) === "global_moderator") && St(dt)
                          })
                        }
                        Re((St, jt) => {
                          Vr(He, 1, `badge badge-sm ml-0.5 border-0 ${St??""} ${jt??""}`), te(ht, m(ut).allianceName)
                        }, [() => Cp(m(ut).allianceId), () => tn(m(ut).allianceId)]), q(ne, Ce)
                      };
                      Se(We, ne => {
                        m(ut).allianceId && ne(Be)
                      })
                    }
                    var ae = D(We, 2);
                    {
                      var J = ne => {
                          var Ce = g8(),
                            He = I(Ce);
                          vp(He, {
                            class: "text-error size-4"
                          }), P(Ce), Re(ht => Qt(Ce, "data-tip", ht), [() => Jm()]), q(ne, Ce)
                        },
                        Ve = ne => {
                          var Ce = Sr(),
                            He = Ct(Ce);
                          {
                            var ht = Tt => {
                              var dt = _8(),
                                St = I(dt);
                              Xu(St, {
                                class: "text-error size-4"
                              }), P(dt), Re(jt => Qt(dt, "data-tip", jt), [() => C0()]), q(Tt, dt)
                            };
                            Se(He, Tt => {
                              m(v).paintedBy.timedOut && Tt(ht)
                            }, !0)
                          }
                          q(ne, Ce)
                        };
                      Se(ae, ne => {
                        m(v).paintedBy.banned ? ne(J) : ne(Ve, !1)
                      })
                    }
                    P(Wr);
                    var tt = D(Wr, 2);
                    {
                      var Ze = ne => {
                        var Ce = w8(),
                          He = I(Ce),
                          ht = I(He);
                        cg(ht, {
                          class: "size-4"
                        }), P(He);
                        var Tt = D(He, 2);
                        na(Tt, 21, () => m(Z), Lc, (dt, St) => {
                          var jt = Sr(),
                            je = Ct(jt);
                          {
                            var yt = Cr => {
                                var fr = v8(),
                                  Je = I(fr);
                                let tr;
                                Je.__click = () => {
                                  Ie("report-user")
                                };
                                var Yt = I(Je);
                                Fm(Yt, {
                                  class: "size-5"
                                });
                                var Tr = D(Yt);
                                P(Je), P(fr), Re(Dr => {
                                  tr = Vr(Je, 1, "py-2 font-medium text-red-300", null, tr, {
                                    "cursor-not-allowed": m(B)
                                  }), te(Tr, ` ${Dr??""}`)
                                }, [() => j5()]), q(Cr, fr)
                              },
                              Kt = Cr => {
                                var fr = Sr(),
                                  Je = Ct(fr);
                                {
                                  var tr = Tr => {
                                      var Dr = y8(),
                                        Jr = I(Dr);
                                      let yr;
                                      Jr.__click = () => {
                                        Ie("timeout")
                                      };
                                      var qt = I(Jr);
                                      Xu(qt, {
                                        class: "size-5"
                                      });
                                      var bt = D(qt);
                                      P(Jr), P(Dr), Re(Ue => {
                                        yr = Vr(Jr, 1, "text-warning font-medium", null, yr, {
                                          "cursor-not-allowed": m(B)
                                        }), te(bt, ` ${Ue??""}`)
                                      }, [() => q5()]), q(Tr, Dr)
                                    },
                                    Yt = Tr => {
                                      var Dr = Sr(),
                                        Jr = Ct(Dr);
                                      {
                                        var yr = bt => {
                                            var Ue = x8(),
                                              xt = I(Ue);
                                            let Gt;
                                            xt.__click = () => {
                                              Ie("ban")
                                            };
                                            var kt = I(xt);
                                            vp(kt, {
                                              class: "size-5"
                                            });
                                            var dr = D(kt);
                                            P(xt), P(Ue), Re(ar => {
                                              Gt = Vr(xt, 1, "text-error font-medium", null, Gt, {
                                                "cursor-not-allowed": m(B)
                                              }), te(dr, ` ${ar??""}`)
                                            }, [() => V5()]), q(bt, Ue)
                                          },
                                          qt = bt => {
                                            var Ue = Sr(),
                                              xt = Ct(Ue);
                                            {
                                              var Gt = kt => {
                                                var dr = b8(),
                                                  ar = I(dr);
                                                ar.__click = async () => {
                                                  H(s, !0);
                                                  try {
                                                    await ui.banAllianceUser(m(ut).id), await _e({
                                                      ...m(ee),
                                                      season: u.season
                                                    })
                                                  } catch (Rr) {
                                                    Nt.error(Rr.message)
                                                  } finally {
                                                    H(s, !1)
                                                  }
                                                };
                                                var Ar = I(ar);
                                                i8(Ar, {
                                                  class: "size-5"
                                                });
                                                var Kr = D(Ar);
                                                P(ar), P(dr), Re(Rr => te(Kr, ` ${Rr??""}`), [() => u0()]), q(kt, dr)
                                              };
                                              Se(xt, kt => {
                                                m(St) === "ban-alliance" && kt(Gt)
                                              }, !0)
                                            }
                                            q(bt, Ue)
                                          };
                                        Se(Jr, bt => {
                                          m(St) === "ban-user" ? bt(yr) : bt(qt, !1)
                                        }, !0)
                                      }
                                      q(Tr, Dr)
                                    };
                                  Se(Je, Tr => {
                                    m(St) === "timeout-user" ? Tr(tr) : Tr(Yt, !1)
                                  }, !0)
                                }
                                q(Cr, fr)
                              };
                            Se(je, Cr => {
                              m(St) === "report-user" ? Cr(yt) : Cr(Kt, !1)
                            })
                          }
                          q(dt, jt)
                        }), P(Tt), P(Ce), q(ne, Ce)
                      };
                      Se(tt, ne => {
                        m(Z).length > 0 && ne(Ze)
                      })
                    }
                    P(ur), Re((ne, Ce) => {
                      var He;
                      te(cr, `${ne??""}:`), Vr(sr, 1, `font-medium ${Ce??""} flex gap-1.5`), te(j, ((He = Lt.data) == null ? void 0 : He.id) === m(ut).id ? Lt.data.name : m(ut).name), te(X, `#${m(ut).id??""}`)
                    }, [() => Yw(), () => tn(m(ut).id)]), q(Ut, ur)
                  };
                Se(Mt, Ut => {
                  m(v).paintedBy.event ? Ut(wt) : Ut(It, !1)
                }, !0)
              }
              q(mr, At)
            };
          Se(Zt, mr => {
            m(v).paintedBy.id === 0 ? mr(Jt) : mr(Ot, !1)
          }, !0)
        }
        q(nt, rt)
      };
    Se(Vt, nt => {
      m(v) === void 0 ? nt(Et) : nt(Pt, !1)
    })
  }
  P(ft);
  var ot = D(ft, 2),
    Ht = I(ot);
  {
    var vt = nt => {
        var rt = S8();
        rt.__click = () => u.onclickpaint(u.latLon);
        var Zt = I(rt);
        yl(Zt, {
          class: "size-4.5"
        });
        var Jt = D(Zt);
        P(rt), Re(Ot => {
          rt.disabled = Lt.loading, te(Jt, ` ${Ot??""}`)
        }, [() => m0()]), q(nt, rt)
      },
      Dt = nt => {
        var rt = Sr(),
          Zt = Ct(rt);
        {
          var Jt = Ot => {
            var mr = I8();
            mr.__click = () => we();
            var At = I(mr);
            {
              var Mt = It => {
                  var Ut = P8(),
                    ut = Ct(Ut);
                  u3(ut, {
                    class: "size-4.5"
                  });
                  var ur = D(ut);
                  Re(br => te(ur, ` ${br??""}`), [() => Kw()]), q(It, Ut)
                },
                wt = It => {
                  var Ut = M8(),
                    ut = Ct(Ut);
                  pg(ut, {
                    class: "size-4.5"
                  });
                  var ur = D(ut);
                  Re(br => te(ur, ` ${br??""}`), [() => Jw()]), q(It, Ut)
                };
              Se(At, It => {
                m(v).paintedBy.claimed ? It(Mt) : It(wt, !1)
              })
            }
            P(mr), Re(() => mr.disabled = Lt.loading || m(v).paintedBy.claimed), q(Ot, mr)
          };
          Se(Zt, Ot => {
            Lt.data && m(v).paintedBy.eventClaimNumber && Ot(Jt)
          }, !0)
        }
        q(nt, rt)
      };
    Se(Ht, nt => {
      var rt;
      (rt = m(v)) != null && rt.paintedBy.event ? nt(Dt, !1) : nt(vt)
    })
  }
  var Rt = D(Ht, 2);
  {
    var $t = nt => {
      const rt = mt(() => Lt.data.favoriteLocations.find(Mt => Math.abs(Mt.latitude - m(ee).center[0]) < 5e-5 && Math.abs(Mt.longitude - m(ee).center[1]) < 5e-5)),
        Zt = mt(() => !m(rt) && Lt.data.favoriteLocations.length >= Lt.data.maxFavoriteLocations);
      var Jt = C8();
      let Ot;
      Jt.__click = async () => {
        try {
          H(T, !0), m(rt) ? (await ui.deleteFavoriteLocation(m(rt).id), Nt.warning(Uw())) : (await ui.favoriteLocation(m(ee).center), Nt.success(Gw())), ya.smallPlop.play(), Lt.refresh()
        } catch (Mt) {
          Nt.error(Mt.message)
        } finally {
          H(T, !1)
        }
      };
      var mr = I(Jt);
      {
        let Mt = mt(() => !!m(rt));
        s8(mr, {
          class: "size-4.5",
          get filled() {
            return m(Mt)
          }
        })
      }
      var At = D(mr);
      P(Jt), Re(Mt => {
        Ot = Vr(Jt, 1, "btn btn-primary btn-soft", null, Ot, {
          "text-yellow-400": !!m(rt)
        }), Jt.disabled = m(T) || m(Zt), te(At, ` ${Mt??""}`)
      }, [() => m(Zt) ? Ww() : Hw()]), q(nt, Jt)
    };
    Se(Rt, nt => {
      Lt.data && nt($t)
    })
  }
  var pr = D(Rt, 2);
  pr.__click = () => u.onclickshare(R3(ga.url, {
    pos: {
      lat: m(ee).center[0],
      lng: m(ee).center[1]
    },
    zoom: u.zoom
  }));
  var Xt = I(pr);
  K0(Xt, {
    class: "size-4.5"
  });
  var or = D(Xt);
  P(pr), P(ot), P(Fe), Rn(Fe, nt => H(z, nt), () => m(z)), Re(nt => {
    te(Ye, `Pixel: ${m(ee).regionPixel[0]??""}, ${m(ee).regionPixel[1]??""}`), te(or, ` ${nt??""}`)
  }, [() => Nw()]), Ch("innerHeight", nt => H(k, nt, !0)), q(y, Fe), ii()
}
$i(["click"]);

function E8(y) {
  var b;
  const u = document.createElement("div");
  (b = y.parentElement) == null || b.insertBefore(u, y.nextSibling);
  const v = new IntersectionObserver(k => {
    k[0].isIntersecting ? y.classList.remove("stuck") : y.classList.add("stuck")
  }, {
    threshold: 0,
    rootMargin: "0px"
  });
  return v.observe(u), () => {
    u.remove(), v.disconnect()
  }
}
var Om;
(y => {
  function u() {
    let v, b;
    return {
      promise: new Promise((z, T) => {
        v = z, b = T
      }),
      resolve: v,
      reject: b
    }
  }
  y.withResolvers = u
})(Om || (Om = {}));
var z8 = Xr('<svg><path d="M200-120v-680h360l16 80h224v400H520l-16-80H280v280h-80Z"></path></svg>'),
  L8 = Xr('<svg><path d="M200-120v-680h360l16 80h224v400H520l-16-80H280v280h-80Zm300-440Zm86 160h134v-240H510l-16-80H280v240h290l16 80Z"></path></svg>');

function D8(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy", "filled"]);
  var b = Sr(),
    k = Ct(b);
  {
    var z = s => {
        var B = z8();
        Lr(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...v
        })), q(s, B)
      },
      T = s => {
        var B = L8();
        Lr(B, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ...v
        })), q(s, B)
      };
    Se(k, s => {
      u.filled ? s(z) : s(T, !1)
    })
  }
  q(y, b)
}
var R8 = he("<p><!></p>"),
  F8 = he('<span class="loading loading-spinner center-absolute absolute"></span>'),
  B8 = he('<span class="text-sm"> </span>'),
  O8 = he(' <span class="text-sm">Droplets</span>', 1),
  j8 = he('<button class="btn btn-lg sm:btn-md btn-primary relative h-10"><!> <!> <!></button>'),
  q8 = he('<span class="loading loading-spinner center-absolute absolute"></span>'),
  V8 = he('<!> <span class="text-sm"> </span>', 1),
  Z8 = he('<span class="text-sm"> </span>'),
  N8 = he('<button><div class="tooltip-content max-w-54 p-2"> </div> <!> <!></button>'),
  U8 = he('<div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="font-flag flex grow items-center justify-center p-1 text-7xl"> </div> <h3 class="mt-2 text-center text-xl font-bold"> <!></h3> <!> <div><!></div></div>'),
  G8 = he('<div><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <p class="text-base-content/80 text-sm"> </p> <div class="grid-cols mt-3 grid gap-3 sm:grid-cols-2 lg:grid-cols-4"></div> <div class="mt-4 flex justify-center"><button class="btn btn-lg"> </button></div></div>');

function W8(y, u) {
  ri(u, !0);
  const v = (Xe, Ae = Jn, De = Jn) => {
      const Ye = mt(() => {
          var Xt;
          return (((Xt = Lt.data) == null ? void 0 : Xt.droplets) ?? 0) >= s.price
        }),
        Le = mt(() => m(W) === Ae().id),
        qe = mt(() => b.has(Ae().id));
      var _t = U8(),
        Qe = I(_t),
        Ge = I(Qe, !0);
      P(Qe);
      var ft = D(Qe, 2),
        Vt = I(ft),
        Et = D(Vt);
      {
        var Pt = Xt => {
          var or = R8(),
            nt = I(or);
          Ju(nt, {
            class: "text-base-content/60 size-4.5 inline pb-0.5"
          }), P(or), Re(rt => {
            Vr(or, 1, jo({
              "tooltip inline": !0,
              "lg:before:-translate-x-1/3": (De() + 1) % 4 === 0,
              "lg:before:translate-x-1/3": De() % 4 === 0,
              "before:-translate-x-1/3": (De() + 1) % 2 === 0,
              "before:translate-x-1/3": De() % 2 === 0
            })), Qt(or, "data-tip", rt)
          }, [() => i5()]), q(Xt, or)
        };
        Se(Et, Xt => {
          m(qe) && Xt(Pt)
        })
      }
      P(ft);
      var ot = D(ft, 2);
      {
        var Ht = Xt => {
          dg(Xt, {})
        };
        Se(ot, Xt => {
          Ae().id === m(ee) && Xt(Ht)
        })
      }
      var vt = D(ot, 2);
      let Dt;
      var Rt = I(vt);
      {
        var $t = Xt => {
            var or = j8();
            or.__click = async () => {
              if (!(m(qe) && !await u.promptUserConfirmation(Ae().label))) try {
                const At = Ae().id;
                H(W, At, !0), await ui.purchase({
                  id: T,
                  amount: 1,
                  variant: At
                }), Lt.refresh(), ya.notification1.play();
                const Mt = z.find(wt => wt.id === At);
                Mt && (Mt.owned = !0), H(ee, At, !0)
              } catch (At) {
                Nt.error(At.message)
              } finally {
                H(W, void 0)
              }
            };
            var nt = I(or);
            {
              var rt = At => {
                var Mt = F8();
                q(At, Mt)
              };
              Se(nt, At => {
                m(Le) && At(rt)
              })
            }
            var Zt = D(nt, 2);
            Ip(Zt, {
              class: "size-4"
            });
            var Jt = D(Zt, 2);
            {
              var Ot = At => {
                  var Mt = B8(),
                    wt = I(Mt, !0);
                  P(Mt), Re(It => te(wt, It), [() => n5()]), q(At, Mt)
                },
                mr = At => {
                  var Mt = O8(),
                    wt = Ct(Mt);
                  vi(), Re(It => te(wt, `${It??""} `), [() => s.price.toLocaleString(navigator.language)]), q(At, Mt)
                };
              Se(Jt, At => {
                var Mt;
                (Mt = Lt.data) != null && Mt.freeFlag ? At(Ot) : At(mr, !1)
              })
            }
            P(or), Re(() => {
              var At;
              return or.disabled = !m(Ye) && ((At = Lt.data) == null ? void 0 : At.freeFlag) == !1 || m(Le)
            }), q(Xt, or)
          },
          pr = Xt => {
            const or = mt(() => {
              var It;
              return ((It = Lt.data) == null ? void 0 : It.equippedFlag) === Ae().id
            });
            var nt = N8();
            let rt;
            nt.__click = async () => {
              try {
                H(W, Ae().id, !0);
                const It = m(or) ? 0 : Ae().id;
                await ui.equipFlag(It), Lt.data && (Lt.data.equippedFlag = It), Lt.refresh()
              } catch (It) {
                Nt.error(It.message)
              } finally {
                H(W, void 0)
              }
            };
            var Zt = I(nt),
              Jt = I(Zt, !0);
            P(Zt);
            var Ot = D(Zt, 2);
            {
              var mr = It => {
                var Ut = q8();
                q(It, Ut)
              };
              Se(Ot, It => {
                m(Le) && It(mr)
              })
            }
            var At = D(Ot, 2);
            {
              var Mt = It => {
                  var Ut = V8(),
                    ut = Ct(Ut);
                  Ls(ut, {
                    class: "size-4"
                  });
                  var ur = D(ut, 2),
                    br = I(ur, !0);
                  P(ur), Re(cr => te(br, cr), [() => s5()]), q(It, Ut)
                },
                wt = It => {
                  var Ut = Z8(),
                    ut = I(Ut, !0);
                  P(Ut), Re(ur => te(ut, ur), [() => o5()]), q(It, Ut)
                };
              Se(At, It => {
                m(or) ? It(Mt) : It(wt, !1)
              })
            }
            P(nt), Re(It => {
              rt = Vr(nt, 1, "btn btn-lg sm:btn-md tooltip tooltip-bottom relative h-10", null, rt, {
                "btn-warning": m(or)
              }), nt.disabled = m(Le), te(Jt, It)
            }, [() => a5()]), q(Xt, nt)
          };
        Se(Rt, Xt => {
          Ae().owned ? Xt(pr, !1) : Xt($t)
        })
      }
      P(vt), P(_t), Re(Xt => {
        var or;
        te(Ge, Ae().flag), te(Vt, `${Ae().label??""} `), Dt = Vr(vt, 1, "mt-3", null, Dt, {
          tooltip: !m(Ye) && !Ae().owned && ((or = Lt.data) == null ? void 0 : or.freeFlag) == !1
        }), Qt(vt, "data-tip", Xt)
      }, [() => Ep()]), q(Xe, _t)
    },
    b = new Set([8, 30, 32, 84, 96, 125, 143, 146, 150, 192, 200, 236, 240, 251]),
    k = xn.countries.map(Xe => {
      var Ae, De;
      return {
        ...Xe,
        owned: Lt.flagsBitmap.get(Xe.id),
        label: ((De = (Ae = K5)[Xe.code]) == null ? void 0 : De.call(Ae)) ?? Xe.name
      }
    });
  k.sort((Xe, Ae) => Number(Ae.owned) - Number(Xe.owned));
  const z = _a(k),
    T = 110,
    s = xn.products[T];
  let B = Ke(!1),
    W = Ke(void 0),
    ee = Ke(void 0);
  var $ = G8(),
    oe = I($),
    me = I(oe);
  D8(me, {
    class: "size-5.5",
    filled: !0
  });
  var _e = D(me, 2),
    Z = I(_e, !0);
  P(_e), P(oe);
  var Ie = D(oe, 2),
    we = I(Ie, !0);
  P(Ie);
  var Fe = D(Ie, 2);
  na(Fe, 23, () => z, Xe => Xe.id, (Xe, Ae, De) => {
    var Ye = Sr(),
      Le = Ct(Ye);
    {
      var qe = _t => {
        v(_t, () => m(Ae), () => m(De))
      };
      Se(Le, _t => {
        (m(De) < 8 || m(B)) && _t(qe)
      })
    }
    q(Xe, Ye)
  }), P(Fe);
  var xe = D(Fe, 2),
    $e = I(xe);
  $e.__click = () => {
    H(B, !m(B))
  };
  var et = I($e, !0);
  P($e), P(xe), P($), Re((Xe, Ae, De) => {
    te(Z, Xe), te(we, Ae), te(et, De)
  }, [() => Qw(), () => e5(), () => m(B) ? t5() : r5()]), q(y, $), ii()
}
$i(["click"]);
var H8 = he('<p class="mt-1 text-center text-sm"> </p>'),
  $8 = he('<button class="text-base-content/80 absolute left-full top-1/2 ml-2 size-10 -translate-y-1/2 rounded-full text-[10px] font-bold">MAX</button>'),
  X8 = he('<span class="loading loading-spinner center-absolute absolute"></span>'),
  Y8 = he('<div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><!></div> <p class="mt-2 text-center text-2xl font-bold sm:text-3xl"> </p> <!> <div class="relative mt-4 flex justify-center gap-3"><button class="btn btn-circle">-</button> <input class="input number-input max-w-16 text-center font-bold opacity-80" type="number" min="1"/> <button class="btn btn-circle">+</button> <!></div> <div><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <!> <span class="text-sm">Droplets</span></button></div></div>');

function Qv(y, u) {
  ri(u, !0);
  let v = rr(u, "amount", 15, 1);
  const b = mt(() => v() * u.unitPrice),
    k = mt(() => Math.floor(u.userDroplets / u.unitPrice));
  let z = Ke(!1);
  oi(() => {
    v() < 0 && v(0)
  });
  var T = Y8(),
    s = I(T),
    B = I(s);
  Oa(B, () => u.icon ?? Jn), P(s);
  var W = D(s, 2),
    ee = I(W, !0);
  P(W);
  var $ = D(W, 2);
  {
    var oe = Le => {
      var qe = H8(),
        _t = I(qe, !0);
      P(qe), Re(() => te(_t, u.subtitle)), q(Le, qe)
    };
    Se($, Le => {
      u.subtitle && Le(oe)
    })
  }
  var me = D($, 2),
    _e = I(me);
  _e.__click = () => {
    cv(v, -1)
  };
  var Z = D(_e, 2);
  Xa(Z);
  var Ie = D(Z, 2);
  Ie.__click = () => {
    cv(v)
  };
  var we = D(Ie, 2);
  {
    var Fe = Le => {
      var qe = $8();
      qe.__click = () => {
        v(m(k))
      }, q(Le, qe)
    };
    Se(we, Le => {
      v() < m(k) && Le(Fe)
    })
  }
  P(me);
  var xe = D(me, 2);
  let $e;
  var et = I(xe);
  et.__click = async () => {
    try {
      H(z, !0), await ui.purchase({
        id: u.productId,
        amount: v()
      }), ya.notification1.play(), u.onpurchasecompleted(v())
    } catch (Le) {
      Nt.error(Le.message)
    } finally {
      H(z, !1)
    }
  };
  var Xe = I(et);
  {
    var Ae = Le => {
      var qe = X8();
      q(Le, qe)
    };
    Se(Xe, Le => {
      m(z) && Le(Ae)
    })
  }
  var De = D(Xe, 2);
  Ip(De, {
    class: "size-4"
  });
  var Ye = D(De);
  vi(), P(et), P(xe), P(T), Re((Le, qe, _t) => {
    te(ee, Le), Ie.disabled = v() >= m(k), Qt(xe, "data-tip", qe), $e = Vr(xe, 1, "", null, $e, {
      tooltip: u.userDroplets < m(b)
    }), et.disabled = u.userDroplets < m(b) || m(z) || !v(), te(Ye, ` ${_t??""} `)
  }, [() => u.title(v()), () => Ep(), () => m(b).toLocaleString(navigator.language)]), vl(Z, v), q(y, T), ii()
}
$i(["click"]);
var K8 = Xr('<svg><path d="M346-140 100-386q-10-10-15-22t-5-25q0-13 5-25t15-22l230-229-106-106 62-65 400 400q10 10 14.5 22t4.5 25q0 13-4.5 25T686-386L440-140q-10 10-22 15t-25 5q-13 0-25-5t-22-15Zm47-506L179-432h428L393-646Zm399 526q-36 0-61-25.5T706-208q0-27 13.5-51t30.5-47l42-54 44 54q16 23 30 47t14 51q0 37-26 62.5T792-120Z"></path></svg>');

function J8(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = K8();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var Q8 = Xr('<svg><path d="M280-80q-33 0-56.5-23.5T200-160q0-33 23.5-56.5T280-240q33 0 56.5 23.5T360-160q0 33-23.5 56.5T280-80Zm400 0q-33 0-56.5-23.5T600-160q0-33 23.5-56.5T680-240q33 0 56.5 23.5T760-160q0 33-23.5 56.5T680-80ZM246-720l96 200h280l110-200H246Zm-38-80h590q23 0 35 20.5t1 41.5L692-482q-11 20-29.5 31T622-440H324l-44 80h480v80H280q-45 0-68-39.5t-2-78.5l54-98-144-304H40v-80h130l38 80Zm134 280h280-280Z"></path></svg>');

function wy(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = Q8();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var eE = Xr('<svg><path d="m700-300-57-56 84-84H120v-80h607l-83-84 57-56 179 180-180 180Z"></path></svg>');

function tE(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = eE();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var rE = Xr('<svg><path d="M280-160v-80h400v80H280Zm160-160v-327L336-544l-56-56 200-200 200 200-56 56-104-103v327h-80Z"></path></svg>');

function iE(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = rE();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var aE = he('<div><section class="not-stuck:border-transparent stuck:border-base-content/10 bg-base-100/70 sticky top-0 z-10 border-b px-6 pb-4 pt-6 backdrop-blur-sm"><div class="relative flex items-center gap-1"><!> <h3 class="text-3xl font-bold"> </h3> <div class="ml-auto mr-4"><!></div> <form method="dialog" class="absolute -right-4 -top-4"><button class="btn btn-sm btn-circle btn-ghost"></button></form></div></section> <div class="flex flex-col gap-6 px-6 pb-6"><section><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <p class="text-base-content/80 text-sm"> </p> <div class="mt-3 grid gap-3 sm:grid-cols-2"><!> <!></div></section> <section><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <div class="mt-3"><div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><div class="relative flex size-52 items-center justify-center"><div class="scale-[3]"><!></div></div></div> <p class="mt-2 text-center text-2xl font-bold sm:text-3xl"> </p> <p class="mt-1 text-center text-sm"> </p> <div><a href="/profile-picture"><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <span class="text-sm">Droplets</span></button></a></div></div></div></section> <section><!></section></div></div>'),
  nE = he('<span class="center-absolute absolute"><!></span>'),
  sE = he('<dialog class="modal" closedby="any"><div class="modal-box max-h-11/12 w-11/12 max-w-4xl p-0"><!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog> <dialog class="modal"><div class="modal-box w-max overflow-hidden"><div class="flex flex-col items-center gap-6 px-4"><h2 class="text-lg font-semibold"> </h2> <div class="flex items-center gap-2 text-3xl sm:text-5xl"><span class="text-base-content/80 flex items-center gap-2"> <span class="text-primary text-3xl font-semibold max-sm:hidden"> </span></span> <span><!></span> <span class="text-primary flex font-bold"> </span></div> <form method="dialog"><button class="btn btn-primary btn-lg relative"> <!></button></form></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog> <dialog class="modal"><div class="modal-box w-max overflow-hidden"><h3 class="mb-2 text-lg font-bold"> </h3> <p class="text-sm opacity-80"><!></p> <div class="mt-5 flex justify-end gap-2"><button class="btn btn-ghost"> </button> <button class="btn btn-primary"> </button></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>', 1);

function oE(y, u) {
  ri(u, !0);
  let v = rr(u, "open", 15),
    b = Ke(null),
    k = Ke(_a({
      name: yv(),
      prev: 1e3,
      new: 1e5
    }));
  const z = {
      id: 70,
      product: xn.products[70]
    },
    T = {
      id: 80,
      product: xn.products[80]
    },
    s = {
      product: xn.products[120]
    };
  let B = Ke(null),
    W = Ke(null),
    ee = Ke("");
  async function $(ut) {
    return m(B).showModal(), H(W, Om.withResolvers(), !0), H(ee, ut, !0), m(W).promise
  }
  var oe = sE(),
    me = Ct(oe),
    _e = I(me),
    Z = I(_e);
  {
    var Ie = ut => {
      var ur = aE(),
        br = I(ur),
        cr = I(br),
        jr = I(cr);
      wy(jr, {
        class: "size-8"
      });
      var wr = D(jr, 2),
        Nr = I(wr, !0);
      P(wr);
      var Gr = D(wr, 2),
        er = I(Gr);
      {
        let Yt = mt(() => {
          var Tr;
          return ((Tr = Lt.data) == null ? void 0 : Tr.droplets) ?? 0
        });
        n0(er, {
          get value() {
            return m(Yt)
          }
        })
      }
      P(Gr), vi(2), P(cr), P(br), Ya(br, () => E8);
      var Wr = D(br, 2),
        sr = I(Wr),
        de = I(sr),
        j = I(de);
      J8(j, {
        class: "size-5.5",
        filled: !0
      });
      var V = D(j, 2),
        X = I(V, !0);
      P(V), P(de);
      var re = D(de, 2),
        Q = I(re, !0);
      P(re);
      var ue = D(re, 2),
        Te = I(ue);
      {
        const Yt = Dr => {
          iE(Dr, {
            class: "text-primary size-26"
          })
        };
        let Tr = mt(() => g5());
        Qv(Te, {
          get productId() {
            return z.id
          },
          title: Dr => u5({
            amount: z.product.items[0].amount * Dr
          }),
          get subtitle() {
            return m(Tr)
          },
          get unitPrice() {
            return z.product.price
          },
          get userDroplets() {
            return Lt.data.droplets
          },
          onpurchasecompleted: async Dr => {
            var qt, bt, Ue, xt;
            const Jr = (bt = (qt = Lt.data) == null ? void 0 : qt.charges) == null ? void 0 : bt.max;
            await Lt.refresh();
            const yr = (xt = (Ue = Lt.data) == null ? void 0 : Ue.charges) == null ? void 0 : xt.max;
            Jr !== void 0 && yr !== void 0 && (H(k, {
              name: yv(),
              prev: Jr,
              new: yr
            }, !0), m(b).show())
          },
          icon: Yt,
          $$slots: {
            icon: !0
          }
        })
      }
      var be = D(Te, 2);
      {
        const Yt = Dr => {
          vy(Dr, {
            class: "text-primary my-3 size-20"
          })
        };
        let Tr = mt(() => _5());
        Qv(be, {
          get productId() {
            return T.id
          },
          title: Dr => h5({
            amount: T.product.items[0].amount * Dr
          }),
          get subtitle() {
            return m(Tr)
          },
          get unitPrice() {
            return T.product.price
          },
          get userDroplets() {
            return Lt.data.droplets
          },
          onpurchasecompleted: async Dr => {
            var yr, qt, bt;
            const Jr = (qt = (yr = Lt.data) == null ? void 0 : yr.charges) == null ? void 0 : qt.count;
            await Lt.refresh(), Jr !== void 0 && (H(k, {
              name: Z5(),
              prev: Math.floor(Jr),
              new: Math.floor(Jr + T.product.items[0].amount * Dr)
            }, !0), (bt = m(b)) == null || bt.show())
          },
          icon: Yt,
          $$slots: {
            icon: !0
          }
        })
      }
      P(ue), P(sr);
      var ze = D(sr, 2),
        We = I(ze),
        Be = I(We);
      Dp(Be, {
        class: "size-5.5",
        filled: !0
      });
      var ae = D(Be, 2),
        J = I(ae, !0);
      P(ae), P(We);
      var Ve = D(We, 2),
        tt = I(Ve),
        Ze = I(tt),
        ne = I(Ze),
        Ce = I(ne),
        He = I(Ce);
      s0(He, {
        get userId() {
          return Lt.data.id
        },
        get level() {
          return Lt.data.level
        },
        get pictureUrl() {
          return Lt.data.picture
        }
      }), P(Ce), P(ne), P(Ze);
      var ht = D(Ze, 2),
        Tt = I(ht, !0);
      P(ht);
      var dt = D(ht, 2),
        St = I(dt, !0);
      P(dt);
      var jt = D(dt, 2);
      let je;
      var yt = I(jt),
        Kt = I(yt),
        Cr = I(Kt);
      Ip(Cr, {
        class: "size-4"
      });
      var fr = D(Cr);
      vi(), P(Kt), P(yt), P(jt), P(tt), P(Ve), P(ze);
      var Je = D(ze, 2),
        tr = I(Je);
      W8(tr, {
        promptUserConfirmation: $
      }), P(Je), P(Wr), P(ur), Re((Yt, Tr, Dr, Jr, yr, qt, bt, Ue) => {
        te(Nr, Yt), te(X, Tr), te(Q, Dr), te(J, Jr), te(Tt, yr), te(St, qt), Qt(jt, "data-tip", bt), je = Vr(jt, 1, "", null, je, {
          tooltip: Lt.data.droplets < s.product.price
        }), Kt.disabled = Lt.data.droplets < s.product.price, te(fr, ` ${Ue??""} `)
      }, [() => _0(), () => d5(), () => p5(), () => f5(), () => N5(), () => m5(), () => Ep(), () => s.product.price.toLocaleString(navigator.language)]), pn(2, ur, () => Kn), q(ut, ur)
    };
    Se(Z, ut => {
      Lt.data && v() && ut(Ie)
    })
  }
  P(_e);
  var we = D(_e, 2),
    Fe = I(we),
    xe = I(Fe, !0);
  P(Fe), P(we), P(me), Ya(me, () => ut => {
    oi(() => {
      v() ? ut.show() : ut.close()
    })
  });
  var $e = D(me, 2),
    et = I($e),
    Xe = I(et),
    Ae = I(Xe),
    De = I(Ae, !0);
  P(Ae);
  var Ye = D(Ae, 2),
    Le = I(Ye),
    qe = I(Le),
    _t = D(qe),
    Qe = I(_t);
  P(_t), P(Le);
  var Ge = D(Le, 2),
    ft = I(Ge);
  tE(ft, {
    class: "size-5"
  }), P(Ge);
  var Vt = D(Ge, 2),
    Et = I(Vt, !0);
  P(Vt), P(Ye);
  var Pt = D(Ye, 2),
    ot = I(Pt),
    Ht = I(ot),
    vt = D(Ht);
  Ec(vt, () => m(k).new, ut => {
    var ur = nE(),
      br = I(ur);
    dg(br, {}), P(ur), q(ut, ur)
  }), P(ot), P(Pt), P(Xe), P(et);
  var Dt = D(et, 2),
    Rt = I(Dt),
    $t = I(Rt, !0);
  P(Rt), P(Dt), P($e), Rn($e, ut => H(b, ut), () => m(b));
  var pr = D($e, 2),
    Xt = I(pr),
    or = I(Xt),
    nt = I(or, !0);
  P(or);
  var rt = D(or, 2),
    Zt = I(rt);
  Ap(Zt, () => c5({
    country: m(ee)
  })), P(rt);
  var Jt = D(rt, 2),
    Ot = I(Jt);
  Ot.__click = () => {
    var ut;
    (ut = m(W)) == null || ut.resolve(!1), m(B).close()
  };
  var mr = I(Ot, !0);
  P(Ot);
  var At = D(Ot, 2);
  At.__click = () => {
    var ut;
    (ut = m(W)) == null || ut.resolve(!0), m(B).close()
  };
  var Mt = I(At, !0);
  P(At), P(Jt), P(Xt);
  var wt = D(Xt, 2),
    It = I(wt),
    Ut = I(It, !0);
  P(It), P(wt), P(pr), Rn(pr, ut => H(B, ut), () => m(B)), Re((ut, ur, br, cr, jr, wr, Nr) => {
    te(xe, ut), te(De, m(k).name), te(qe, `${m(k).prev??""} `), te(Qe, `(+${m(k).new-m(k).prev})`), te(Et, m(k).new), te(Ht, `${ur??""} `), te($t, br), te(nt, cr), te(mr, jr), te(Mt, wr), te(Ut, Nr)
  }, [() => co(), () => co(), () => co(), () => l5(), () => Rc(), () => M0(), () => co()]), Mi("close", me, () => v(!1)), q(y, oe), ii()
}
$i(["click"]);
var lE = Xr('<svg><path d="M480-680q-33 0-56.5-23.5T400-760q0-33 23.5-56.5T480-840q33 0 56.5 23.5T560-760q0 33-23.5 56.5T480-680Zm-60 560v-480h120v480H420Z"></path></svg>');

function cE(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = lE();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var uE = Xr('<svg><path d="M440-40v-80q-125-14-214.5-103.5T122-438H42v-80h80q14-125 103.5-214.5T440-836v-80h80v80q125 14 214.5 103.5T838-518h80v80h-80q-14 125-103.5 214.5T520-120v80h-80Zm40-158q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Z"></path></svg>');

function hE(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = uE();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var dE = Xr('<svg><path d="M440-42v-80q-125-14-214.5-103.5T122-440H42v-80h80q14-125 103.5-214.5T440-838v-80h80v80q125 14 214.5 103.5T838-520h80v80h-80q-14 125-103.5 214.5T520-122v80h-80Zm40-158q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Zm0-120q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47Z"></path></svg>');

function pE(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = dE();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var fE = Xr('<svg><path d="M380-720v-98L142-580h98v60H40v-200h60v98l238-238h-98v-60h200v200h-60ZM593-40q-24 0-46-9t-39-26L304-280l30-31q16-16 37.5-21.5t42.5.5l66 19v-327q0-17 11.5-28.5T520-680q17 0 28.5 11.5T560-640v433l-97-27 102 102q5 5 12.5 8.5T593-120h167q33 0 56.5-23.5T840-200v-160q0-17 11.5-28.5T880-400q17 0 28.5 11.5T920-360v160q0 66-47 113T760-40H593Zm7-280v-160q0-17 11.5-28.5T640-520q17 0 28.5 11.5T680-480v160h-80Zm120 0v-120q0-17 11.5-28.5T760-480q17 0 28.5 11.5T800-440v120h-80Zm-20 80Z"></path></svg>');

function mE(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = fE();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var gE = Xr('<svg><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q146 0 255.5 91.5T872-559h-82q-19-73-68.5-130.5T600-776v16q0 33-23.5 56.5T520-680h-80v80q0 17-11.5 28.5T400-560h-80v80h80v120h-40L168-552q-3 18-5.5 36t-2.5 36q0 131 92 225t228 95v80Zm364-20L716-228q-21 12-45 20t-51 8q-75 0-127.5-52.5T440-380q0-75 52.5-127.5T620-560q75 0 127.5 52.5T800-380q0 27-8 51t-20 45l128 128-56 56ZM620-280q42 0 71-29t29-71q0-42-29-71t-71-29q-42 0-71 29t-29 71q0 42 29 71t71 29Z"></path></svg>');

function _E(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = gE();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ...v
  })), q(y, b)
}

function vE(y, u, v) {
  return y < u ? u : y > v ? v : y
}

function yE(y, u) {
  const v = 10 ** u;
  return Math.round(y * v) / v
}
var xE = he('<div class="badge badge-error badge-sm"> </div>'),
  bE = he('<span class="loading loading-spinner loading-sm"></span>'),
  wE = he('<div class="bg-base-100/80 absolute inset-0 flex items-center justify-center"><span class="loading loading-spinner loading-lg"></span></div>'),
  TE = he('<div class="bg-base-200 absolute left-4 top-4 rounded-lg p-3 shadow-lg"><div class="text-sm font-semibold">Pixel Info</div> <div class="mt-2 space-y-1 text-xs"><div> </div> <div>User ID: <span class="badge badge-sm"> </span></div> <div> </div></div></div>'),
  SE = he('<canvas class="absolute inset-0 cursor-crosshair"></canvas> <!>', 1),
  PE = he('<span class="badge badge-outline badge-sm"> </span>'),
  ME = he('<div><button><div class="flex items-center justify-between"><div class="flex items-center gap-2"><input type="checkbox" class="checkbox checkbox-sm pointer-events-auto"/> <span class="badge badge-sm"> </span> <!></div> <span class="text-xs"> </span></div> <div class="text-base-content/60 mt-1 text-xs"> </div></button></div>'),
  IE = he('<span class="loading loading-spinner loading-xs"></span>'),
  CE = he('<div class="border-base-300 border-t p-2"><button class="btn btn-outline btn-block btn-sm"><!> Load 100 Older Events</button></div>'),
  AE = he('<div class="fixed inset-0 z-50 flex flex-col"><div class="border-base-300 bg-base-100/95 pointer-events-auto flex items-center justify-between border-b p-3 backdrop-blur-sm"><div class="flex items-center gap-4"><h2 class="text-lg font-bold">Wayback Video Mode</h2> <div class="flex gap-4 text-sm"><div class="badge badge-sm"> </div> <div class="badge badge-sm"> </div> <div class="badge badge-sm"> </div> <!></div></div> <div class="flex items-center gap-2"><button class="btn btn-success btn-sm"><!> Reconstruct</button> <button class="btn btn-circle btn-sm"><!></button></div></div> <div class="flex flex-1 overflow-hidden"><div class="relative flex-1"><!></div> <div class="bg-base-200/95 border-base-300 pointer-events-auto flex w-80 flex-col border-l backdrop-blur-sm"><div class="border-base-300 border-b p-3"><h3 class="font-semibold">Events History</h3> <p class="text-base-content/60 text-xs">Click to exclude/include</p></div> <div class="flex-1 overflow-y-auto p-2"><div class="space-y-1"></div></div> <!></div></div> <div class="border-base-300 bg-base-200/95 border-t p-3"><div class="flex items-center gap-4"><div class="font-mono text-xs"> </div> <input type="range" class="range range-primary flex-1"/> <div class="font-mono text-xs"> </div></div> <div class="text-primary mt-2 text-center font-mono text-sm font-bold"> </div></div></div>');

function kE(y, u) {
  ri(u, !0);
  let v = Ke(!1),
    b = Ke(!1),
    k = Ke(_a([])),
    z = Ke(!1);
  const T = Date.now();
  let s = Ke(_a(T)),
    B = Ke(_a(T)),
    W = Ke(_a(T)),
    ee = Ke(!0),
    $ = 100,
    oe = Ke(void 0),
    me = null,
    _e = Ke(_a(new Map)),
    Z = Ke(null),
    Ie = Ke(null),
    we = Ke(void 0);
  const Fe = new kn(u.tileSize);
  let xe = mt(() => m(k).filter(Q => Q.ts <= m(W) && Q.selected)),
    $e = mt(() => m(xe).reduce((Q, ue) => Q + ue.pixelsCount, 0)),
    et = mt(() => new Set(m(xe).map(Q => Q.userId)).size),
    Xe = mt(() => m(k).filter(Q => !Q.selected).length);
  oi(() => {
    m(oe) && (me = m(oe).getContext("2d", {
      willReadFrequently: !0
    }), me && (me.imageSmoothingEnabled = !1))
  });
  async function Ae() {
    H(v, !0);
    try {
      const Q = u.map.getBounds(),
        ue = new URLSearchParams({
          to_ts: T.toString(),
          min_lat: Q.getSouth().toString(),
          max_lat: Q.getNorth().toString(),
          min_lon: Q.getWest().toString(),
          max_lon: Q.getEast().toString(),
          limit: $.toString()
        }),
        Te = await ui.getWaybackVideo(u.season, ue.toString());
      if (!Te.ok) throw new Error("Failed to load events");
      const ze = ((await Te.json()).events ?? []).map(We => ({
        ...We,
        selected: !0
      }));
      H(k, ze, !0), ze.length > 0 && (H(s, ze[0].ts, !0), H(B, ze[ze.length - 1].ts, !0), H(W, m(B), !0)), H(ee, ze.length === $), setTimeout(() => Ye(), 0), Nt.success(`Carregados ${ze.length} eventos mais recentes`)
    } catch (Q) {
      Nt.error(Q.message)
    } finally {
      H(v, !1)
    }
  }
  async function De() {
    if (!(m(b) || !m(ee))) {
      H(b, !0);
      try {
        const Q = u.map.getBounds(),
          ue = new URLSearchParams({
            from_ts: (m(s) - 10080 * 60 * 1e3).toString(),
            to_ts: m(s).toString(),
            min_lat: Q.getSouth().toString(),
            max_lat: Q.getNorth().toString(),
            min_lon: Q.getWest().toString(),
            max_lon: Q.getEast().toString(),
            limit: $.toString()
          }),
          Te = await ui.getWaybackVideo(u.season, ue.toString());
        if (!Te.ok) throw new Error("Failed to load more events");
        const ze = ((await Te.json()).events ?? []).map(We => ({
          ...We,
          selected: !0
        }));
        if (ze.length === 0) {
          H(ee, !1), Nt.info("No more events");
          return
        }
        H(k, [...ze, ...m(k)], !0), H(s, ze[0].ts, !0), H(ee, ze.length === $), setTimeout(() => Ye(), 0), Nt.success(`Loaded +${ze.length} older events`)
      } catch (Q) {
        Nt.error(Q.message)
      } finally {
        H(b, !1)
      }
    }
  }

  function Ye() {
    var be, ze, We;
    if (console.log("rebuildCanvas called", {
        hasCtx: !!me,
        hasCanvas: !!m(oe),
        visibleEventsCount: m(xe).length,
        canvasWidth: (be = m(oe)) == null ? void 0 : be.width,
        canvasHeight: (ze = m(oe)) == null ? void 0 : ze.height
      }), !me || !m(oe)) {
      console.log("No ctx or canvas");
      return
    }
    if (!me || !m(oe)) return;
    me.clearRect(0, 0, m(oe).width, m(oe).height), m(_e).clear();
    const Q = u.map.getBounds(),
      ue = u.map.project([Q.getWest(), Q.getNorth()]),
      Te = u.map.project([Q.getEast(), Q.getSouth()]);
    for (let Be = 0; Be < m(xe).length; Be++) {
      const ae = m(xe)[Be];
      for (let J = 0; J < ae.pixelsX.length; J++) {
        const Ve = ae.pixelsX[J],
          tt = ae.pixelsY[J],
          Ze = ae.colors[J],
          ne = ae.tileX * u.tileSize + Ve,
          Ce = ae.tileY * u.tileSize + tt,
          He = Fe.pixelsToLatLon(ne + .5, Ce + .5, u.pixelArtZoom),
          ht = u.map.project([He[1], He[0]]);
        if (ht.x >= ue.x && ht.x <= Te.x && ht.y >= ue.y && ht.y <= Te.y) {
          const Tt = `${ae.tileX},${ae.tileY},${Ve},${tt}`;
          m(_e).set(Tt, {
            color: Ze,
            userId: ae.userId,
            ts: ae.ts,
            eventIndex: Be
          });
          const dt = xn.colors[Ze];
          if (dt) {
            const [St, jt, je] = dt.rgb;
            me.fillStyle = `rgb(${St}, ${jt}, ${je})`;
            const yt = ne + 1,
              Kt = Ce + 1,
              Cr = Fe.pixelsToLatLon(yt + .5, Kt + .5, u.pixelArtZoom),
              fr = u.map.project([Cr[1], Cr[0]]),
              Je = Math.max(1, Math.abs(fr.x - ht.x)),
              tr = Math.max(1, Math.abs(fr.y - ht.y));
            me.fillRect(Math.floor(ht.x), Math.floor(ht.y), Math.ceil(Je), Math.ceil(tr)), m(Ie) !== null && ((We = m(k)[m(Ie)]) == null ? void 0 : We.userId) === ae.userId && (me.strokeStyle = "rgba(255, 255, 0, 0.8)", me.lineWidth = 2, me.strokeRect(Math.floor(ht.x) - 1, Math.floor(ht.y) - 1, Math.ceil(Je) + 2, Math.ceil(tr) + 2))
          }
        }
      }
    }
    H(_e, new Map(m(_e)), !0)
  }

  function Le(Q) {
    if (!m(oe)) return;
    const ue = m(oe).getBoundingClientRect(),
      Te = Q.clientX - ue.left,
      be = Q.clientY - ue.top,
      ze = u.map.unproject([Te + ue.left, be + ue.top]),
      We = Fe.latLonToPixels(ze.lat, ze.lng, u.pixelArtZoom),
      Be = Math.floor(We[0]),
      ae = Math.floor(We[1]),
      J = Math.floor(Be / u.tileSize),
      Ve = Math.floor(ae / u.tileSize),
      tt = Be % u.tileSize,
      Ze = ae % u.tileSize,
      ne = `${J},${Ve},${tt},${Ze}`,
      Ce = m(_e).get(ne);
    if (Ce) {
      H(Z, {
        x: Be,
        y: ae,
        userId: Ce.userId,
        ts: Ce.ts
      }, !0);
      const He = m(k).findIndex(ht => ht.ts === Ce.ts && ht.userId === Ce.userId);
      He !== -1 && (H(Ie, He, !0), Qe(He), setTimeout(() => Ye(), 0))
    } else H(Z, null), H(Ie, null), setTimeout(() => Ye(), 0)
  }

  function qe(Q) {
    m(k)[Q].selected = !m(k)[Q].selected, H(k, [...m(k)], !0), setTimeout(() => Ye(), 0)
  }

  function _t(Q, ue) {
    H(Ie, Q, !0), H(Z, {
      x: ue.tileX * u.tileSize + (ue.pixelsX[0] ?? 0),
      y: ue.tileY * u.tileSize + (ue.pixelsY[0] ?? 0),
      userId: ue.userId,
      ts: ue.ts
    }, !0), setTimeout(() => Ye(), 0)
  }

  function Qe(Q) {
    if (!m(we)) return;
    const ue = m(we).querySelector(`[data-event-index="${Q}"]`);
    ue && ue.scrollIntoView({
      behavior: "smooth",
      block: "center"
    })
  }
  async function Ge() {
    if (m(xe).length === 0) {
      Nt.error("No events to reconstruct");
      return
    }
    H(z, !0);
    try {
      const Q = new Map;
      for (const Te of m(xe)) {
        const be = `${Te.tileX},${Te.tileY}`;
        Q.has(be) || Q.set(be, []), Q.get(be).push(Te)
      }
      let ue = 0;
      for (const [Te, be] of Q) {
        const [ze, We] = Te.split(",").map(Number), Be = new Map;
        for (const tt of be)
          for (let Ze = 0; Ze < tt.pixelsX.length; Ze++) {
            const ne = `${tt.pixelsX[Ze]},${tt.pixelsY[Ze]}`;
            Be.set(ne, {
              x: tt.pixelsX[Ze],
              y: tt.pixelsY[Ze],
              color: tt.colors[Ze],
              userId: tt.userId
            })
          }
        const ae = Array.from(Be.values()),
          J = {
            events: [{
              tileX: ze,
              tileY: We,
              pixelsX: ae.map(tt => tt.x),
              pixelsY: ae.map(tt => tt.y),
              colors: ae.map(tt => tt.color),
              userIds: ae.map(tt => tt.userId)
            }]
          };
        if (!(await ui.postWaybackReconstruct(u.season, J)).ok) throw new Error(`Failed to reconstruct tile ${Te}`);
        ue += ae.length
      }
      u.refreshPixelArt(), Nt.success(`Reconstructed ${ue} pixels from ${m(xe).length} events`)
    } catch (Q) {
      Nt.error(Q.message)
    } finally {
      H(z, !1)
    }
  }

  function ft(Q) {
    return new Date(Q).toLocaleString(navigator.language)
  }

  function Vt(Q) {
    return new Date(Q).toLocaleTimeString(navigator.language)
  }
  oi(() => {
    if (u.map && m(k).length > 0) {
      const Q = () => setTimeout(() => Ye(), 0);
      return u.map.on("move", Q), u.map.on("zoom", Q), () => {
        u.map.off("move", Q), u.map.off("zoom", Q)
      }
    }
  }), oi(() => {
    m(W) !== void 0 && setTimeout(() => Ye(), 0)
  }), $a(() => {
    setTimeout(() => Ae(), 100)
  });
  var Et = AE(),
    Pt = I(Et),
    ot = I(Pt),
    Ht = D(I(ot), 2),
    vt = I(Ht),
    Dt = I(vt);
  P(vt);
  var Rt = D(vt, 2),
    $t = I(Rt);
  P(Rt);
  var pr = D(Rt, 2),
    Xt = I(pr);
  P(pr);
  var or = D(pr, 2);
  {
    var nt = Q => {
      var ue = xE(),
        Te = I(ue);
      P(ue), Re(() => te(Te, `${m(Xe)??""} excluded`)), q(Q, ue)
    };
    Se(or, Q => {
      m(Xe) > 0 && Q(nt)
    })
  }
  P(Ht), P(ot);
  var rt = D(ot, 2),
    Zt = I(rt);
  Zt.__click = Ge;
  var Jt = I(Zt);
  {
    var Ot = Q => {
        var ue = bE();
        q(Q, ue)
      },
      mr = Q => {
        pg(Q, {
          class: "size-4"
        })
      };
    Se(Jt, Q => {
      m(z) ? Q(Ot) : Q(mr, !1)
    })
  }
  vi(), P(Zt);
  var At = D(Zt, 2);
  At.__click = function(...Q) {
    var ue;
    (ue = u.onclose) == null || ue.apply(this, Q)
  };
  var Mt = I(At);
  Ls(Mt, {
    class: "size-4"
  }), P(At), P(rt), P(Pt);
  var wt = D(Pt, 2),
    It = I(wt),
    Ut = I(It);
  {
    var ut = Q => {
        var ue = wE();
        q(Q, ue)
      },
      ur = Q => {
        var ue = SE(),
          Te = Ct(ue);
        Qt(Te, "width", window.innerWidth), Qt(Te, "height", window.innerHeight - 150), Te.__click = Le, Rn(Te, We => H(oe, We), () => m(oe));
        var be = D(Te, 2);
        {
          var ze = We => {
            var Be = TE(),
              ae = D(I(Be), 2),
              J = I(ae),
              Ve = I(J);
            P(J);
            var tt = D(J, 2),
              Ze = D(I(tt)),
              ne = I(Ze, !0);
            P(Ze), P(tt);
            var Ce = D(tt, 2),
              He = I(Ce);
            P(Ce), P(ae), P(Be), Re(ht => {
              te(Ve, `Position: (${m(Z).x??""}, ${m(Z).y??""})`), te(ne, m(Z).userId), te(He, `Time: ${ht??""}`)
            }, [() => Vt(m(Z).ts)]), q(We, Be)
          };
          Se(be, We => {
            m(Z) && We(ze)
          })
        }
        q(Q, ue)
      };
    Se(Ut, Q => {
      m(v) ? Q(ut) : Q(ur, !1)
    })
  }
  P(It);
  var br = D(It, 2),
    cr = D(I(br), 2),
    jr = I(cr);
  na(jr, 21, () => m(k), Lc, (Q, ue, Te) => {
    const be = mt(() => m(ue).ts <= m(W)),
      ze = mt(() => m(ue).selected),
      We = mt(() => m(Ie) === Te);
    var Be = ME();
    Qt(Be, "data-event-index", Te);
    var ae = I(Be);
    let J;
    ae.__click = je => {
      const yt = je.target;
      yt.tagName === "INPUT" || yt.closest("input") ? qe(Te) : _t(Te, m(ue))
    };
    var Ve = I(ae),
      tt = I(Ve),
      Ze = I(tt);
    Xa(Ze), Ze.__click = je => {
      je.stopPropagation(), qe(Te)
    };
    var ne = D(Ze, 2),
      Ce = I(ne, !0);
    P(ne);
    var He = D(ne, 2);
    {
      var ht = je => {
        var yt = PE(),
          Kt = I(yt, !0);
        P(yt), Re(() => te(Kt, m(ue).allianceId)), q(je, yt)
      };
      Se(He, je => {
        m(ue).allianceId > 0 && je(ht)
      })
    }
    P(tt);
    var Tt = D(tt, 2),
      dt = I(Tt);
    P(Tt), P(Ve);
    var St = D(Ve, 2),
      jt = I(St);
    P(St), P(ae), P(Be), Re(je => {
      Vr(Be, 1, "relative rounded transition-all" + (m(We) ? " ring-primary bg-primary/10 ring-2" : "")), J = Vr(ae, 1, "hover:bg-base-300 w-full rounded p-2 text-left transition-colors", null, J, {
        "opacity-30": !m(be),
        "bg-base-300": !m(ze) && !m(We),
        "line-through": !m(ze)
      }), ae.disabled = !m(be), em(Ze, m(ze)), Ze.disabled = !m(be), te(Ce, m(ue).userId), te(dt, `${m(ue).pixelsCount??""}px`), te(jt, `${je??""}  Tile (${m(ue).tileX??""}, ${m(ue).tileY??""})`)
    }, [() => Vt(m(ue).ts)]), q(Q, Be)
  }), P(jr), P(cr), Rn(cr, Q => H(we, Q), () => m(we));
  var wr = D(cr, 2);
  {
    var Nr = Q => {
      var ue = CE(),
        Te = I(ue);
      Te.__click = De;
      var be = I(Te);
      {
        var ze = We => {
          var Be = IE();
          q(We, Be)
        };
        Se(be, We => {
          m(b) && We(ze)
        })
      }
      vi(), P(Te), P(ue), Re(() => Te.disabled = m(b)), q(Q, ue)
    };
    Se(wr, Q => {
      m(ee) && Q(Nr)
    })
  }
  P(br), P(wt);
  var Gr = D(wt, 2),
    er = I(Gr),
    Wr = I(er),
    sr = I(Wr, !0);
  P(Wr);
  var de = D(Wr, 2);
  Xa(de), Qt(de, "step", 1e3);
  var j = D(de, 2),
    V = I(j, !0);
  P(j), P(er);
  var X = D(er, 2),
    re = I(X, !0);
  P(X), P(Gr), P(Et), Re((Q, ue, Te) => {
    te(Dt, `${m(xe).length??""} events`), te($t, `${m($e)??""} pixels`), te(Xt, `${m(et)??""} users`), Zt.disabled = m(z) || m(xe).length === 0 || m(Xe) === 0, te(sr, Q), Qt(de, "min", m(s)), Qt(de, "max", m(B)), te(V, ue), te(re, Te)
  }, [() => ft(m(s)), () => ft(m(B)), () => ft(m(W))]), vl(de, () => m(W), Q => H(W, Q)), pn(3, Et, () => Kn), q(y, Et), ii()
}
$i(["click"]);
var EE = Xr('<svg><path d="M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8 12.5v-9l6 4.5-6 4.5z"></path></svg>');

function zE(y, u) {
  let v = Er(u, ["$$slots", "$$events", "$$legacy"]);
  var b = EE();
  Lr(b, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    ...v
  })), q(y, b)
}
var LE = he('<meta property="og:title" content="Wplace - A massive real-time pixel art canvas on the world map!"/> <meta name="twitter:title" content="Wplace - A massive real-time pixel art canvas on the world map!"/> <meta name="robots" content="index, follow, max-image-preview:large"/> <meta name="color-scheme" content="light only"/>', 1),
  DE = he("<button><!></button>"),
  RE = he('<div class="relative"><!> <span class="center-absolute absolute text-[10px] text-red-400">?</span></div>'),
  FE = he('<button class="btn btn-lg btn-square sm:btn-xl z-30 shadow-md"><!></button>'),
  BE = he('<button class="btn btn-primary shadow-xl"> </button>'),
  OE = he('<div class="absolute top-0 -left-2 -translate-x-full translate-y-1/2 select-none"><!></div>'),
  jE = he('<div class="relative"><!> <!></div>'),
  qE = he('<button class="btn btn-square shadow-md"><!></button> <button class="btn btn-square relative shadow-md"><!></button>', 1),
  VE = he('<button title="Auto painter" class="btn btn-square shadow-md"><!></button>'),
  ZE = he('<button title="Video Wayback" class="btn btn-square shadow-md"><!></button>'),
  NE = he('<div class="flex flex-col items-center gap-3"><!> <button class="btn btn-square relative shadow-md"><!></button> <button class="btn btn-square shadow-md"><!></button> <!> <!></div>'),
  UE = he('<div class="flex flex-col gap-3"><button><!></button></div>'),
  GE = he('<button class="btn btn-sm btn-circle"><!></button>'),
  WE = he('<div class="tooltip tooltip-right"><div class="tooltip-content">Select Area <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">C</kbd></div> <button class="btn btn-sm btn-circle" title="Select area"><!></button></div>'),
  HE = he('<button class="btn btn-sm btn-circle"><!></button>'),
  $E = he('<button class="btn btn-sm btn-circle not-pwa:hidden"><!></button>'),
  XE = he('<div class="btn btn-sm btn-error w-max cursor-auto text-xs text-nowrap sm:text-base"><!> </div>'),
  YE = he('<button class="btn sm:btn-lg duration text-xs text-nowrap transition-opacity sm:text-base"><!> </button>'),
  KE = he("<span></span>"),
  JE = he('<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2 md:max-w-lg"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t pt-2 sm:mb-3 sm:shadow-xl"><!></div></div>'),
  QE = he('<div class="absolute bottom-0 left-0 z-50 w-full"><div class="rounded-t-box bg-base-100 border-base-300 w-full border-t py-3"><!></div></div>'),
  ez = he('<div class="pointer-events-none absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-lg sm:-translate-x-1/2 md:max-w-xl"><!></div>'),
  tz = he('<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t pt-2 sm:mb-3 sm:shadow-xl"><div class="px-3 pt-1 pb-2"><div class="flex items-center justify-between"><span><!> </span> <button class="btn btn-circle btn-sm"><!></button></div> <div class="mt-1 flex items-center justify-center gap-4"><button class="btn btn-primary w-46"><!></button></div></div></div></div>'),
  rz = he('<div class="disable-pinch-zoom relative h-full overflow-hidden"><div id="map" class="h-screen w-screen cursor-default"></div> <div><div><!> <!></div></div> <div><!> <div class="flex flex-col gap-1 max-sm:hidden"><button class="btn btn-sm btn-circle">+</button> <button class="btn btn-sm btn-circle">-</button></div> <!> <!> <!></div> <div><!> <!></div> <div><!></div> <div><!></div> <div><!></div>  <!></div> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>', 1);

function gL(y, u) {
  ri(u, !0);
  let v = Ke(!1);
  const b = Xd,
    k = Y1,
    z = new kn(k),
    T = b - .4,
    s = D3(ga.url),
    B = s.season ?? lv;
  let W = Ke(0);
  const ee = new Map;
  let $ = Ke(void 0),
    oe = Ke(14.5),
    me = Ke(!1);
  const _e = mt(() => {
    var pt;
    return ((pt = Lt.data) == null ? void 0 : pt.id) === 401
  });
  let Z = Ke(!1),
    Ie = Ke("select-pixel"),
    we = Ke(_a(s.select && s.pos ? {
      name: "pixelSelected",
      latLon: [s.pos.lat, s.pos.lng]
    } : {
      name: "mainMenu"
    }));
  $a(() => {
    et().then(zr => H($, zr)).catch(zr => {
      Nt.error(b5(), {
        duration: 5e3
      }), console.error("Error setting up map:", zr)
    });
    let pt = [0, 0];

    function Ft(zr) {
      var Bi;
      if (m($) && m(oe) > b + 1) {
        const {
          lat: Zi,
          lng: Ta
        } = m($).unproject([zr.clientX, zr.clientY]), Xi = z.latLonToPixels(Zi, Ta, b), ji = Math.floor(Xi[0]), La = Math.floor(Xi[1]);
        if (pt[0] !== ji || pt[1] !== La) {
          const Br = z.latLonToPixelBoundsLatLon(Zi, Ta, b),
            Pr = rg(Br, !0);
          (Bi = m($).getSource(De)) == null || Bi.setCoordinates(Pr), pt = [ji, La]
        }
      }
    }
    return window.addEventListener("mousemove", Ft), () => {
      var zr;
      (zr = m($)) == null || zr.remove(), window.removeEventListener("mousemove", Ft), $e && clearInterval($e), tm()
    }
  }), ho(() => [An.theme], () => {
    if (m($)) {
      xe = !1;
      const pt = Fe(An.theme);
      m($).setStyle(pt)
    }
  });

  function Fe(pt) {
    return `https://maps.wplace.live/styles/${pt==="custom-winter"?"liberty":"fiord"}`
  }
  let xe = !1,
    $e;
  async function et() {
    let pt = s.pos ? {
      ...s.pos,
      zoom: m(oe)
    } : await w3();
    s.zoom !== void 0 && (pt.zoom = s.zoom), P3(pt) || (pt = {
      zoom: pt.zoom,
      ...A0.tokyo
    });
    const Ft = await new Promise(Xi => {
        const ji = new Yd.Map({
          style: Fe(An.theme),
          center: pt,
          zoom: pt.zoom,
          container: "map",
          dragRotate: !1,
          doubleClickZoom: !1,
          pitch: 0,
          maxPitch: 0,
          attributionControl: !1
        });
        ji.touchZoomRotate.disableRotation(), ji.on("styledata", La => {
          xe || (An.theme === "custom-winter" && (ji.setLayoutProperty("poi_transit", "visibility", "none"), ji.setLayoutProperty("poi_r20", "visibility", "none"), ji.setLayoutProperty("poi_r7", "visibility", "none"), ji.setLayoutProperty("poi_r1", "visibility", "none"), ji.setLayoutProperty("building", "visibility", "none"), ji.setLayoutProperty("building-3d", "visibility", "none"), ji.setLayoutProperty("landuse_pitch", "visibility", "none"), ji.setLayoutProperty("landuse_hospital", "visibility", "none"), ji.setLayoutProperty("landuse_school", "visibility", "none"), ji.setLayoutProperty("landuse_residential", "visibility", "none"), ji.setLayoutProperty("waterway_tunnel", "visibility", "none"), ji.setFilter("water", ["all", ["!=", "brunnel", "tunnel"],
            ["!=", "class", "swimming_pool"]
          ])), Ae(ji), _t(), xe = !0)
        }), ji.on("style.load", () => {
          Xi(ji)
        })
      }),
      zr = xn.refreshIntervalMs;

    function Bi() {
      let Xi = m(oe) > b + 1.5 ? zr : 2.5 * zr;
      try {
        document.visibilityState === "visible" && Ae(Ft)
      } finally {
        setTimeout(Bi, Xi)
      }
    }
    $e = setTimeout(Bi, zr), Ft.on("load", () => {
      s.discordLinked && (Nt.success(w5()), ga.url.searchParams.delete("discord-linked"), mp(ga.url.toString())), s.twitchMigration && (Nt.success(T5()), ga.url.searchParams.delete("twitch-migration"), mp(ga.url.toString()))
    });
    let Zi = m(oe);
    Ft.on("zoom", () => {
      H(oe, Ft.getZoom(), !0);
      const Xi = yE(m(oe), 1);
      Xi != Zi && (m(Ht) && m(Ht).setOpacity(vt(Zi)), Zi = Xi)
    });
    let Ta = "default";
    return Ft.on("dragstart", () => {
      const Xi = Ft.getCanvas();
      Ta = Xi.style.cursor, Xi.style.cursor = "move"
    }), Ft.on("dragend", () => {
      Ft.getCanvas().style.cursor = Ta
    }), Ft.on("mouseout", () => {
      Qe()
    }), Ft.on("click", async Xi => {
      var zi;
      const ji = Xi.lngLat.lat,
        La = Xi.lngLat.lng,
        Br = [ji, La];
      if (m(we).name === "paintingPixel" || m(we).name === "selectArea") return;
      if (m(we).name === "selectHq") {
        m(we).hq = Br, (zi = m(Dt)) == null || zi.clearAndPlace(Br);
        return
      }
      const Pr = Ft.getZoom();
      if (Pr < T) {
        Nt.info(S5());
        return
      }
      no({
        lat: ji,
        lng: La
      }, Pr), H(we, {
        name: "pixelSelected",
        latLon: Br
      }, !0)
    }), Ft
  }
  const Xe = "pixel-art-layer";

  function Ae(pt) {
    const Ft = window.innerWidth,
      zr = `${i0}/s${lv}/tiles/{x}/{y}.png`;
    if (ee.clear(), !pt.style) return;
    pt.getSource(Xe) ? pt.refreshTiles(Xe) : pt.addSource(Xe, {
      type: "raster",
      tiles: [zr],
      minzoom: b,
      maxzoom: b,
      tileSize: Ft > 640 ? 550 : 400
    }), pt.getLayer(Xe) || pt.addLayer({
      id: Xe,
      type: "raster",
      source: Xe,
      paint: {
        "raster-resampling": "nearest",
        "raster-opacity": m(Vt)
      }
    })
  }
  const De = "pixel-hover",
    Ye = 1e-5,
    Le = [
      [0, 0],
      [Ye, 0],
      [Ye, -Ye],
      [0, -Ye]
    ],
    qe = .4;
  async function _t() {
    var pt, Ft, zr, Bi;
    if (!((pt = m($)) != null && pt.getSource(De))) {
      const Zi = X0(await lp(x3));
      (Ft = m($)) == null || Ft.addSource(De, {
        type: "canvas",
        canvas: Zi,
        coordinates: Le
      })
    }(zr = m($)) != null && zr.getLayer(De) || (Bi = m($)) == null || Bi.addLayer({
      id: De,
      type: "raster",
      source: De,
      paint: {
        "raster-resampling": "nearest",
        "raster-opacity": qe
      }
    })
  }

  function Qe() {
    var pt, Ft;
    (Ft = (pt = m($)) == null ? void 0 : pt.getSource(De)) == null || Ft.setCoordinates(Le)
  }
  let Ge = Ke(_a(s.opaque ?? !0)),
    ft = Ke(!0),
    Vt = mt(() => m(ft) ? m(Ge) ? 1 : .2 : 0);
  oi(() => {
    var pt;
    (pt = m($)) != null && pt.getLayer(Xe) && m($).setPaintProperty(Xe, "raster-opacity", m(Vt))
  });
  let Et = Ke(void 0),
    Pt = Ke(void 0),
    ot = Ke(void 0);
  $a(() => (navigator.permissions.query({
    name: "geolocation"
  }).then(pt => {
    pt.state === "granted" && H(ot, navigator.geolocation.watchPosition(Ft => {
      H(Et, Ft)
    }, Ft => {
      H(Pt, Ft)
    }, {
      enableHighAccuracy: !1,
      maximumAge: 1e3,
      timeout: 6e3
    }), !0)
  }), () => {
    m(ot) && navigator.geolocation.clearWatch(m(ot))
  }));
  let Ht = Ke(void 0);
  ho(() => [m(Et), m($)], () => {
    var pt, Ft;
    if (m(Et) && m($)) {
      const zr = {
          lat: m(Et).coords.latitude,
          lng: m(Et).coords.longitude
        },
        Bi = vt(m(oe));
      if (!m(Ht)) {
        const Zi = document.createElement("div");
        Zi.classList.add("maplibregl-user-location-dot"), Zi.classList.add("cursor-auto"), H(Ht, new Yd.Marker({
          element: Zi,
          opacity: Bi
        }).setLngLat(zr).addTo(m($)))
      }(Ft = (pt = m(Ht)) == null ? void 0 : pt.setLngLat(zr)) == null || Ft.setOpacity(Bi)
    }
  });

  function vt(pt) {
    return pt < b ? "1.0" : vE((pt - b) * .2, .5, 1).toFixed(2)
  }
  let Dt = Ke(void 0);
  oi(() => {
    var pt;
    m($) && ((pt = Cn(() => m(Dt))) == null || pt.clear(), lp(wv).then(Ft => {
      H(Dt, new Sv({
        id: "select-crosshair",
        map: m($),
        tileSize: k,
        zoom: b,
        img: Ft,
        markerFn: () => {
          const zr = new Yd.Marker({
            color: "#0069ff"
          });
          return zr.addClassName("z-20"), zr
        }
      }))
    }))
  });
  let Rt = Ke(void 0);
  oi(() => {
    var pt;
    m($) && ((pt = Cn(() => m(Dt))) == null || pt.clear(), lp(wv).then(Ft => {
      H(Rt, new Sv({
        id: "paint-crosshair",
        map: m($),
        tileSize: k,
        zoom: b,
        img: Ft
      }))
    }))
  });
  let $t = Ke(!1),
    pr = Ke(_a(ga.url)),
    Xt = Ke(_a({
      cityId: 0,
      countryId: 1,
      id: 0,
      name: "None",
      number: 1
    })),
    or = Ke(!1);
  oi(() => {
    var pt;
    H(or, !!((pt = Lt.data) != null && pt.needsPhoneVerification))
  });
  let nt = Ke([]),
    rt = mt(() => m(oe) < T ? "1.0" : m(oe) < T + 2 ? "0.5" : "0.3");
  oi(() => {
    var Ft;
    const pt = (Ft = Lt.data) == null ? void 0 : Ft.favoriteLocations;
    if (pt && m($)) {
      for (const zr of Cn(() => m(nt))) zr.remove();
      H(nt, pt.map(zr => {
        const Bi = document.createElement("div");
        Bi.classList.add("text-yellow-400"), Bi.classList.add("cursor-pointer"), Bi.classList.add("z-10"), Bi.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor">
					<path fill="#000a" d="m183-51 79-338L-1-617l346-29 135-319 135 319 346 29-263 228 79 338-297-180L183-51Z"/>
					<path d="m293-203.08 49.62-212.54-164.93-142.84 217.23-18.85L480-777.69l85.08 200.38 217.23 18.85-164.93 142.84L667-203.08 480-315.92 293-203.08Z"/>
				</svg>`;
        const Zi = {
          lat: zr.latitude,
          lng: zr.longitude
        };
        return Bi.addEventListener("click", Xi => {
          Xi.stopPropagation(), Zt([zr.latitude, zr.longitude])
        }), new Yd.Marker({
          element: Bi,
          opacity: m(rt)
        }).setLngLat(Zi).addTo(m($))
      }))
    }
  });

  function Zt(pt) {
    var zr;
    const Ft = {
      lat: pt[0],
      lng: pt[1]
    };
    (zr = m($)) == null || zr.flyTo({
      center: Ft,
      zoom: Math.max(m(oe), 15)
    }), no(Ft, m(oe)), H(we, {
      name: "pixelSelected",
      latLon: [Ft.lat, Ft.lng]
    }, !0)
  }
  oi(() => {
    const pt = m(we).name === "paintingPixel";
    for (const Ft of m(nt)) pt ? Ft.addClassName("hidden") : (Ft.removeClassName("hidden"), Ft.setOpacity(m(rt)))
  });
  let Jt = Number.MAX_VALUE;
  oi(() => {
    if (Lt.charges !== void 0 && Lt.data) {
      const pt = Lt.data.charges.max,
        Ft = Lt.charges;
      Jt < pt && Ft >= pt && ya.notification1.play(), Jt = Lt.charges
    }
  });
  let Ot = Ke(!1),
    mr = Date.now();
  $a(() => {
    const pt = L3(),
      Ft = () => {
        var Bi;
        if (!document.hidden && Date.now() - mr > 30 * wc.min) {
          if (pt) {
            const Ta = (Bi = m($)) == null ? void 0 : Bi.getCenter();
            Ta && no(Ta, m(oe)), window.location.replace(ga.url.origin)
          } else Lt.refresh();
          mr = Date.now()
        }
      };
    return document.addEventListener("visibilitychange", Ft), () => document.removeEventListener("visibilitychange", Ft)
  }), $a(() => {
    function pt() {
      ui.online = !0
    }
    window.addEventListener("online", pt);

    function Ft() {
      ui.online = !1
    }
    return window.addEventListener("offline", Ft), () => {
      window.removeEventListener("online", pt), window.removeEventListener("offline", Ft)
    }
  }), oi(() => {
    if (!ui.online) {
      const pt = setInterval(() => {
        ui.health().then(() => {
          ui.online = !0, !Lt.data && !Lt.loading && Lt.refresh()
        })
      }, 5e3);
      return () => {
        clearInterval(pt)
      }
    }
  }), $a(() => {
    if (!navigator.serviceWorker) {
      setTimeout(() => {
        console.log("Setting up service worker message listener", navigator.serviceWorker), Nt.warning(P5(), {
          duration: 5e3
        })
      });
      return
    }

    function pt(Ft) {
      Ft.data.type && m($) && Ae(m($))
    }
    return navigator.serviceWorker.addEventListener("message", pt), () => {
      navigator.serviceWorker.removeEventListener("message", pt)
    }
  });
  let At = Ke(!1),
    Mt = Ke("report-user"),
    wt = Ke(void 0),
    It = Ke(void 0),
    Ut = Ke(void 0),
    ut = Ke(0),
    ur = Ke(void 0);
  oi(() => {
    m(At) || (H(ur, void 0), H(It, void 0), H(wt, void 0), H(Ut, void 0))
  });

  function br() {
    H(we, {
      name: "mainMenu"
    }, !0), Qe()
  }
  let cr = Ke(!1),
    jr = Ke(!1),
    wr = Ke(!1),
    Nr = Ke(!1),
    Gr = Ke(!1),
    er = Ke(!1),
    Wr = Ke(!!s.newUser),
    sr = Ke(!1),
    de = Ke(!!s.alliance),
    j = Ke(!1);
  const V = mt(() => m(cr) || m(jr) || m(wr) || m(Nr) || m(Gr) || m(er) || m(Wr) || m(sr) || m(de) || m(j));
  var X = rz();
  Mi("keydown", Oo, async pt => {
    if (!m(V) && !(pt.target instanceof HTMLInputElement || pt.target instanceof HTMLTextAreaElement) && !pt.ctrlKey) switch (pt.code) {
      case "KeyC":
        if (!Lt.hasAnyPermission(za.tools.selectArea) || m(we).name === "paintingPixel" || pt.repeat) return;
        br(), await qm(), H(we, {
          name: "selectArea"
        }, !0);
        break
    }
  }), O1("1uha8ag", pt => {
    var Ft = LE();
    vi(6), F1(() => {
      B1.title = "Wplace - Paint the world"
    }), q(pt, Ft)
  });
  var re = Ct(X);
  {
    const pt = Br => {
        var Pr = DE();
        Pr.__click = () => {
          H(Ge, !m(Ge))
        };
        var zi = I(Pr);
        {
          let hi = mt(() => !m(Ge));
          yy(zi, {
            class: "size-5",
            get filled() {
              return m(hi)
            }
          })
        }
        P(Pr), Re(hi => {
          Qt(Pr, "title", hi), Vr(Pr, 1, jo({
            "btn btn-lg btn-square sm:btn-xl z-30 shadow-md": !0,
            "text-base-content/80": m(Ge),
            "btn-primary btn-soft": !m(Ge)
          }))
        }, [() => g0()]), q(Br, Pr)
      },
      Ft = Br => {
        var Pr = FE();
        Pr.__click = async () => {
          var mi;
          m(Et) || H(Et, await new Promise((Ir, ei) => {
            navigator.geolocation.getCurrentPosition(Ni => {
              Ir(Ni)
            }, Ni => {
              ei(Ni)
            })
          })), m(Et) && (no({
            lat: m(Et).coords.latitude,
            lng: m(Et).coords.longitude
          }, m(oe)), (mi = m($)) == null || mi.flyTo({
            center: {
              lat: m(Et).coords.latitude,
              lng: m(Et).coords.longitude
            },
            zoom: 16.5
          }))
        };
        var zi = I(Pr);
        {
          var hi = mi => {
              pE(mi, {
                class: "size-5.5 fill-blue-800"
              })
            },
            kr = mi => {
              var Ir = RE(),
                ei = I(Ir);
              hE(ei, {
                class: "size-5.5 fill-red-400"
              }), vi(2), P(Ir), q(mi, Ir)
            };
          Se(zi, mi => {
            m(Et) ? mi(hi) : mi(kr, !1)
          })
        }
        P(Pr), Re(mi => Qt(Pr, "title", mi), [() => v5()]), q(Br, Pr)
      };
    var Q = D(I(re), 2);
    let zr;
    var ue = I(Q);
    let Bi;
    var Te = I(ue);
    {
      var be = Br => {
          var Pr = BE();
          Pr.__click = () => {
            var hi;
            H(Nr, !0), m($) && no((hi = m($)) == null ? void 0 : hi.getCenter(), m(oe))
          };
          var zi = I(Pr, !0);
          P(Pr), Re(hi => te(zi, hi), [() => M5()]), q(Br, Pr)
        },
        ze = Br => {
          var Pr = Sr(),
            zi = Ct(Pr);
          {
            var hi = kr => {
              var mi = jE(),
                Ir = I(mi);
              {
                var ei = Oi => {
                  var Ei = OE(),
                    Si = I(Ei);
                  I0(Si, {
                    get role() {
                      return Lt.data.role
                    }
                  }), P(Ei), q(Oi, Ei)
                };
                Se(Ir, Oi => {
                  var Ei;
                  (Ei = Lt.data) != null && Ei.role && Lt.data.role !== "user" && Oi(ei)
                })
              }
              var Ni = D(Ir, 2);
              YA(Ni, {
                get user() {
                  return Lt
                },
                onlogout: () => {
                  H(we, {
                    name: "mainMenu"
                  }, !0)
                },
                onbanappeal: () => {
                  H(cr, !0)
                },
                onnotificationclick: () => {
                  H(jr, !0)
                },
                ontogglepixelarts: Oi => {
                  H(ft, Oi, !0)
                }
              }), P(mi), pn(3, mi, () => Kn, () => ({
                duration: 150
              })), q(kr, mi)
            };
            Se(zi, kr => {
              Lt.data && m($) && m(we).name !== "paintingPixel" && kr(hi)
            }, !0)
          }
          q(Br, Pr)
        };
      Se(Te, Br => {
        !Lt.loading && !Lt.data ? Br(be) : Br(ze, !1)
      })
    }
    var We = D(Te, 2);
    {
      var Be = Br => {
          var Pr = NE(),
            zi = I(Pr);
          {
            var hi = Pi => {
              var di = qE(),
                li = Ct(di);
              li.__click = () => {
                var Da;
                H(Gr, !0);
                const sa = (Da = m($)) == null ? void 0 : Da.getCenter();
                sa && no(sa, m(oe))
              };
              var rn = I(li);
              wy(rn, {
                class: "size-5"
              }), P(li);
              var Ui = D(li, 2);
              Ui.__click = () => {
                H(de, !0)
              };
              var ra = I(Ui);
              Rp(ra, {
                class: "size-5"
              }), P(Ui), Re((sa, Da) => {
                Qt(li, "title", sa), Qt(Ui, "title", Da)
              }, [() => _0(), () => zp()]), q(Pi, di)
            };
            Se(zi, Pi => {
              Lt.data && Pi(hi)
            })
          }
          var kr = D(zi, 2);
          kr.__click = () => {
            H(er, !0)
          };
          var mi = I(kr);
          my(mi, {
            class: "size-5"
          }), P(kr);
          var Ir = D(kr, 2);
          Ir.__click = () => {
            H(wr, !0)
          };
          var ei = I(Ir);
          _E(ei, {
            class: "size-5"
          }), P(Ir);
          var Ni = D(Ir, 2);
          {
            var Oi = Pi => {
              var di = VE();
              di.__click = () => {
                m($) && H(we, {
                  name: "adminAutoPaint"
                }, !0)
              };
              var li = I(di);
              yl(li, {
                class: "size-5"
              }), P(di), q(Pi, di)
            };
            Se(Ni, Pi => {
              Lt.hasPermission(za.tools.autoPainter) && Pi(Oi)
            })
          }
          var Ei = D(Ni, 2);
          {
            var Si = Pi => {
              var di = ZE();
              di.__click = () => {
                m($) && H(v, !0)
              };
              var li = I(di);
              zE(li, {
                class: "size-5"
              }), P(di), q(Pi, di)
            };
            Se(Ei, Pi => {
              Lt.hasPermission("staff.tools.wayback.video") && Pi(Si)
            })
          }
          P(Pr), Re((Pi, di) => {
            Qt(kr, "title", Pi), Qt(Ir, "title", di)
          }, [() => eg(), () => x0()]), pn(3, Pr, () => Kn, () => ({
            duration: 150
          })), q(Br, Pr)
        },
        ae = Br => {
          var Pr = Sr(),
            zi = Ct(Pr);
          {
            var hi = kr => {
              var mi = UE(),
                Ir = I(mi);
              let ei;
              Ir.__click = () => {
                H(me, !m(me))
              };
              var Ni = I(Ir);
              {
                var Oi = Si => {
                    Rm(Si, {
                      class: "size-5"
                    })
                  },
                  Ei = Si => {
                    Tp(Si, {
                      class: "size-5"
                    })
                  };
                Se(Ni, Si => {
                  m(me) ? Si(Oi) : Si(Ei, !1)
                })
              }
              P(Ir), P(mi), Re(Si => {
                Qt(Ir, "title", Si), ei = Vr(Ir, 1, "btn btn-square not-touchscreen:hidden shadow-md", null, ei, {
                  "btn-primary": m(me)
                })
              }, [() => m(me) ? U5() : E5()]), pn(1, mi, () => Kn, () => ({
                delay: 150,
                duration: 150
              })), q(kr, mi)
            };
            Se(zi, kr => {
              m($) && m(we).name === "paintingPixel" && kr(hi)
            }, !0)
          }
          q(Br, Pr)
        };
      Se(We, Br => {
        m($) && m(we).name !== "paintingPixel" ? Br(Be) : Br(ae, !1)
      })
    }
    P(ue), P(Q);
    var J = D(Q, 2);
    let Zi;
    var Ve = I(J);
    {
      var tt = Br => {
        var Pr = GE();
        Pr.__click = () => {
          H(sr, !0)
        };
        var zi = I(Pr);
        cE(zi, {
          class: "size-3.5"
        }), P(Pr), Re(hi => Qt(Pr, "title", hi), [() => I5()]), q(Br, Pr)
      };
      Se(Ve, Br => {
        m(we).name !== "paintingPixel" && Br(tt)
      })
    }
    var Ze = D(Ve, 2),
      ne = I(Ze);
    ne.__click = () => {
      var Br;
      (Br = m($)) == null || Br.zoomIn()
    };
    var Ce = D(ne, 2);
    Ce.__click = () => {
      var Br;
      (Br = m($)) == null || Br.zoomOut()
    }, P(Ze);
    var He = D(Ze, 2);
    {
      var ht = Br => {
        var Pr = WE(),
          zi = D(I(Pr), 2);
        zi.__click = () => {
          H(we, {
            name: "selectArea"
          }, !0)
        };
        var hi = I(zi);
        Bm(hi, {
          class: "size-4"
        }), P(zi), P(Pr), q(Br, Pr)
      };
      Se(He, Br => {
        m(we).name !== "paintingPixel" && Lt.hasAnyPermission(za.tools.selectArea) && Br(ht)
      })
    }
    var Tt = D(He, 2);
    {
      var dt = Br => {
        var Pr = HE(),
          zi = I(Pr);
        by(zi, {
          class: "size-4",
          onclick: () => {
            H(Z, !m(Z))
          }
        }), P(Pr), Re(hi => Qt(Pr, "title", hi), [() => C5()]), q(Br, Pr)
      };
      Se(Tt, Br => {
        m(_e) && Br(dt)
      })
    }
    var St = D(Tt, 2);
    {
      var jt = Br => {
        var Pr = $E();
        Pr.__click = () => {
          window.location.replace(ga.url.origin)
        };
        var zi = I(Pr);
        d3(zi, {
          class: "size-3"
        }), P(Pr), Re(hi => Qt(Pr, "title", hi), [() => f3()]), q(Br, Pr)
      };
      Se(St, Br => {
        m(we).name !== "paintingPixel" && Br(jt)
      })
    }
    P(J);
    var je = D(J, 2);
    let Ta;
    var yt = I(je);
    {
      var Kt = Br => {
        var Pr = XE(),
          zi = I(Pr);
        p3(zi, {
          class: "size-5"
        });
        var hi = D(zi);
        P(Pr), Re(kr => te(hi, ` ${kr??""}`), [() => A5()]), pn(1, Pr, () => Kn, () => ({
          duration: 1e3
        })), pn(2, Pr, () => Kn), q(Br, Pr)
      };
      Se(yt, Br => {
        ui.online || Br(Kt)
      })
    }
    var Cr = D(yt, 2);
    {
      var fr = Br => {
        var Pr = YE();
        Pr.__click = () => {
          var kr;
          (kr = m($)) == null || kr.flyTo({
            center: m($).getCenter(),
            zoom: b
          })
        };
        var zi = I(Pr);
        mE(zi, {
          class: "size-5"
        });
        var hi = D(zi);
        P(Pr), Re(kr => te(hi, ` ${kr??""}`), [() => k5()]), pn(3, Pr, () => Kn, () => ({
          duration: 300
        })), q(Br, Pr)
      };
      Se(Cr, Br => {
        m(oe) < T && Br(fr)
      })
    }
    P(je);
    var Je = D(je, 2);
    let Xi;
    var tr = I(Je);
    pt(tr), P(Je);
    var Yt = D(Je, 2);
    let ji;
    var Tr = I(Yt);
    {
      var Dr = Br => {
          {
            let Pr = mt(() => m(W) - 96 - 32);
            _y(Br, {
              class: "z-30",
              get maxWidth() {
                return m(Pr)
              },
              onclick: () => {
                var zi;
                (zi = Lt.data) != null && zi.needsPhoneVerification ? (H(or, !0), Nt.warning(vv())) : Lt.charges !== void 0 && Lt.charges < 1 ? Nt.warning(I6, {
                  icon: Xu
                }) : m($) && Lt.data ? (ya.smallDropplet.play(), H(we, {
                  name: "paintingPixel"
                }, !0)) : (H(Nr, !0), m($) && no(m($).getCenter(), m(oe)))
              },
              get disabled() {
                return Lt.loading
              },
              get loading() {
                return Lt.loading
              },
              get charges() {
                return Lt.charges
              }
            })
          }
        },
        Jr = Br => {
          var Pr = KE();
          q(Br, Pr)
        };
      Se(Tr, Br => {
        m(we).name === "mainMenu" ? Br(Dr) : Br(Jr, !1)
      })
    }
    P(Yt);
    var yr = D(Yt, 2);
    let La;
    var qt = I(yr);
    Ft(qt), P(yr);
    var bt = D(yr, 2);
    {
      var Ue = Br => {
        var Pr = Sr(),
          zi = Ct(Pr);
        {
          var hi = mi => {
              var Ir = JE(),
                ei = I(Ir),
                Ni = I(ei);
              k8(Ni, {
                get latLon() {
                  return m(we).latLon
                },
                get map() {
                  return m($)
                },
                get crosshair() {
                  return m(Dt)
                },
                get pixelInfoCache() {
                  return ee
                },
                get season() {
                  return B
                },
                get tileSize() {
                  return k
                },
                get pixelArtZoom() {
                  return b
                },
                get zoom() {
                  return m(oe)
                },
                get opaquePixelArt() {
                  return m(Ge)
                },
                onclose: () => H(we, {
                  name: "mainMenu"
                }, !0),
                onclickshare: Oi => {
                  H(pr, Oi, !0), H($t, !0)
                },
                onclickpaint: ([Oi, Ei]) => {
                  var Pi, di, li;
                  if (!Lt.data) {
                    H(Nr, !0);
                    return
                  }
                  if ((Pi = Lt.data) != null && Pi.needsPhoneVerification) {
                    H(or, !0), Nt.warning(vv());
                    return
                  }
                  if (Lt.charges !== void 0 && Lt.charges < 1) {
                    Nt.warning(z5());
                    return
                  }
                  const Si = ig(z.latLonToPixelBoundsLatLon(Oi, Ei, b));
                  (di = m($)) == null || di.flyTo({
                    center: {
                      lat: Si[0],
                      lon: Si[1]
                    }
                  }), H(we, {
                    name: "paintingPixel",
                    clickedLatLon: [Oi, Ei]
                  }, !0), (li = m(Dt)) == null || li.clear()
                },
                onclickregion: Oi => {
                  H(Xt, Oi, !0), H(j, !0)
                },
                onclickmodaction: (Oi, Ei, Si, Pi) => {
                  var rn, Ui, ra;
                  (rn = m($)) == null || rn.setZoom(Math.max(m(oe), b + 3.5));
                  const di = z.latLonToPixelBoundsLatLon(Si[0], Si[1], b);
                  if ((Ui = m($)) == null || Ui.setCenter({
                      lat: di.min[0],
                      lng: (di.max[1] + di.min[1]) / 2
                    }), !(Oi != null && Oi.paintedBy)) {
                    Nt.error(xv());
                    return
                  }
                  const li = Oi.paintedBy;
                  H(wt, Ei, !0), H(It, [{
                    id: li.id,
                    name: li.name,
                    picture: li.picture,
                    allianceId: li.allianceId ?? void 0,
                    allianceName: li.allianceName ?? void 0,
                    timedOut: li.timedOut,
                    banned: li.banned
                  }], !0), H(Ut, Si, !0), H(ut, ((ra = m($)) == null ? void 0 : ra.getZoom()) ?? 0, !0), H(Mt, Pi, !0), H(ur, void 0), H(At, !0), H(Ie, "select-pixel")
                },
                get christmasTreeId() {
                  return m(we).christmasTreeId
                }
              }), P(ei), P(Ir), pn(3, ei, () => ip, () => ({
                duration: 100
              })), q(mi, Ir)
            },
            kr = mi => {
              var Ir = Sr(),
                ei = Ct(Ir);
              {
                var Ni = Ei => {
                    var Si = QE(),
                      Pi = I(Si),
                      di = I(Pi);
                    LC(di, {
                      get map() {
                        return m($)
                      },
                      get clickedLatLon() {
                        return m(we).clickedLatLon
                      },
                      get tileSize() {
                        return k
                      },
                      get tileZoom() {
                        return b
                      },
                      get season() {
                        return B
                      },
                      get zoom() {
                        return m(oe)
                      },
                      get crosshair() {
                        return m(Rt)
                      },
                      refreshPixelArt: () => m($) && Ae(m($)),
                      hidePixelHover: Qe,
                      hoverLayerId: De,
                      onclose: () => {
                        H(we, {
                          name: "mainMenu"
                        }, !0), Qe()
                      },
                      get screenLocked() {
                        return m(me)
                      },
                      set screenLocked(li) {
                        H(me, li, !0)
                      },
                      get opaquePixelArt() {
                        return m(Ge)
                      },
                      set opaquePixelArt(li) {
                        H(Ge, li, !0)
                      }
                    }), P(Pi), P(Si), pn(3, Pi, () => ip, () => ({
                      duration: 100
                    })), q(Ei, Si)
                  },
                  Oi = Ei => {
                    var Si = Sr(),
                      Pi = Ct(Si);
                    {
                      var di = rn => {
                          var Ui = ez(),
                            ra = I(Ui);
                          e8(ra, {
                            get map() {
                              return m($)
                            },
                            get tileSize() {
                              return k
                            },
                            get pixelArtZoom() {
                              return Xd
                            },
                            get season() {
                              return B
                            },
                            get crosshair() {
                              return m(Rt)
                            },
                            onmodaction: sa => {
                              var Ti;
                              const {
                                targets: Da,
                                image: Sa,
                                latLon: Ki,
                                zoom: ca,
                                action: Pa,
                                onSuccess: ja
                              } = sa;
                              if (!Da || Da.length === 0) {
                                Nt.error(xv());
                                return
                              }
                              H(wt, Sa, !0), H(It, Da, !0), H(Ut, Ki, !0), H(ut, ca ?? ((Ti = m($)) == null ? void 0 : Ti.getZoom()) ?? 0, !0), H(Mt, Pa, !0), H(ur, {
                                onSuccess: ja
                              }, !0), H(At, !0), H(Ie, "select-area")
                            },
                            onclose: br
                          }), P(Ui), q(rn, Ui)
                        },
                        li = rn => {
                          var Ui = Sr(),
                            ra = Ct(Ui);
                          {
                            var sa = Sa => {
                                sP(Sa, {
                                  get map() {
                                    return m($)
                                  },
                                  get tileSize() {
                                    return k
                                  },
                                  get tileZoom() {
                                    return b
                                  },
                                  get season() {
                                    return B
                                  },
                                  refreshPixelArt: () => m($) && Ae(m($)),
                                  onclose: () => {
                                    H(we, {
                                      name: "mainMenu"
                                    }, !0)
                                  }
                                })
                              },
                              Da = Sa => {
                                var Ki = Sr(),
                                  ca = Ct(Ki);
                                {
                                  var Pa = ja => {
                                    var Ti = tz(),
                                      bn = I(Ti),
                                      gi = I(bn),
                                      _i = I(gi),
                                      Bn = I(_i),
                                      Li = I(Bn);
                                    xy(Li, {
                                      class: "inline size-4"
                                    });
                                    var On = D(Li);
                                    P(Bn);
                                    var qa = D(Bn, 2);
                                    qa.__click = () => {
                                      H(we, {
                                        name: "mainMenu"
                                      }, !0)
                                    };
                                    var Qn = I(qa);
                                    Ls(Qn, {
                                      class: "size-4"
                                    }), P(qa), P(_i);
                                    var jn = D(_i, 2),
                                      wn = I(jn);
                                    wn.__click = async () => {
                                      var qn;
                                      if (m(we).name === "selectHq") {
                                        const es = m(we).hq;
                                        if (es) try {
                                          H(Ot, !0), await ui.updateAllianceHeadquarters(es[0], es[1]), (qn = m(Dt)) == null || qn.clear(), H(de, !0), H(we, {
                                            name: "mainMenu"
                                          }, !0)
                                        } catch (ua) {
                                          Nt.error(ua.message)
                                        } finally {
                                          H(Ot, !1)
                                        }
                                      }
                                    };
                                    var ns = I(wn);
                                    pg(ns, {
                                      class: "size-6"
                                    }), P(wn), P(jn), P(gi), P(bn), P(Ti), Re(qn => {
                                      te(On, ` ${qn??""}`), wn.disabled = m(we).hq === void 0 || m(Ot)
                                    }, [() => L5()]), pn(3, bn, () => ip, () => ({
                                      duration: 100
                                    })), q(ja, Ti)
                                  };
                                  Se(ca, ja => {
                                    m(we).name === "selectHq" && ja(Pa)
                                  }, !0)
                                }
                                q(Sa, Ki)
                              };
                            Se(ra, Sa => {
                              m(we).name === "adminAutoPaint" && m($) ? Sa(sa) : Sa(Da, !1)
                            }, !0)
                          }
                          q(rn, Ui)
                        };
                      Se(Pi, rn => {
                        m(we).name === "selectArea" ? rn(di) : rn(li, !1)
                      }, !0)
                    }
                    q(Ei, Si)
                  };
                Se(ei, Ei => {
                  m(we).name === "paintingPixel" && m(Rt) ? Ei(Ni) : Ei(Oi, !1)
                }, !0)
              }
              q(mi, Ir)
            };
          Se(zi, mi => {
            m(we).name === "pixelSelected" && m(Dt) ? mi(hi) : mi(kr, !1)
          })
        }
        q(Br, Pr)
      };
      Se(bt, Br => {
        m($) && Br(Ue)
      })
    }
    P(re), Re((Br, Pr) => {
      zr = Vr(Q, 1, "absolute top-2 right-2 z-30", null, zr, {
        hidden: m(Z)
      }), Bi = Vr(ue, 1, "flex flex-col gap-4", null, Bi, {
        "items-end": !Lt.data,
        "items-center": Lt.data
      }), Zi = Vr(J, 1, "absolute top-2 left-2 z-30 flex flex-col gap-3", null, Zi, {
        hidden: m(Z)
      }), Qt(ne, "title", Br), Qt(Ce, "title", Pr), Ta = Vr(je, 1, "absolute top-2 left-1/2 z-30 flex -translate-x-1/2 flex-col items-center justify-center gap-2", null, Ta, {
        hidden: m(Z)
      }), Xi = Vr(Je, 1, "absolute bottom-3 left-3 z-30", null, Xi, {
        hidden: m(Z)
      }), ji = Vr(Yt, 1, "absolute bottom-3 left-1/2 z-30 -translate-x-1/2", null, ji, {
        hidden: m(Z)
      }), La = Vr(yr, 1, "absolute right-3 bottom-3 z-30", null, La, {
        hidden: m(Z)
      })
    }, [() => y5(), () => x5()])
  }
  var xt = D(re, 2);
  {
    var Gt = pt => {
      kE(pt, {
        get map() {
          return m($)
        },
        get season() {
          return B
        },
        get tileSize() {
          return k
        },
        get pixelArtZoom() {
          return Xd
        },
        refreshPixelArt: () => m($) && Ae(m($)),
        onclose: () => {
          H(v, !1)
        }
      })
    };
    Se(xt, pt => {
      m(v) && m($) && pt(Gt)
    })
  }
  var kt = D(xt, 2);
  P6(kt, {
    get open() {
      return m(Nr)
    },
    set open(pt) {
      H(Nr, pt, !0)
    }
  });
  var dr = D(kt, 2);
  oE(dr, {
    get open() {
      return m(Gr)
    },
    set open(pt) {
      H(Gr, pt, !0)
    }
  });
  var ar = D(dr, 2);
  V4(ar, {
    get open() {
      return m(Wr)
    },
    set open(pt) {
      H(Wr, pt, !0)
    }
  });
  var Ar = D(ar, 2);
  nM(Ar, {
    get open() {
      return m(sr)
    },
    set open(pt) {
      H(sr, pt, !0)
    }
  });
  var Kr = D(Ar, 2);
  w6(Kr, {
    onvisitclick: pt => {
      var Ft;
      (Ft = m($)) == null || Ft.flyTo({
        center: pt,
        zoom: Xd + 1
      }), no(pt, m(oe)), I3.push({
        pos: pt,
        zoom: m(oe)
      }), H(er, !1)
    },
    get open() {
      return m(er)
    },
    set open(pt) {
      H(er, pt, !0)
    }
  });
  var Rr = D(Kr, 2);
  uk(Rr, {
    get region() {
      return m(Xt)
    },
    get open() {
      return m(j)
    },
    set open(pt) {
      H(j, pt, !0)
    }
  });
  var Or = D(Rr, 2);
  ib(Or, {
    get open() {
      return An.dropletsDialogOpen
    },
    set open(pt) {
      An.dropletsDialogOpen = pt
    }
  });
  var Fr = D(Or, 2);
  {
    var ti = pt => {
      S4(pt, {
        onhqchange: () => {
          H(we, {
            name: "selectHq"
          }, !0), H(de, !1)
        },
        onhqclick: Ft => {
          var zr;
          (zr = m($)) == null || zr.flyTo({
            center: Ft,
            zoom: Math.max(m(oe), 15)
          }), H(we, {
            name: "pixelSelected",
            latLon: [Ft.lat, Ft.lng]
          }, !0), H(de, !1)
        },
        onlastpixelclick: Ft => {
          var zr;
          (zr = m($)) == null || zr.flyTo({
            center: Ft,
            zoom: Math.max(m(oe), 15)
          }), H(we, {
            name: "pixelSelected",
            latLon: [Ft.lat, Ft.lng]
          }, !0), H(de, !1)
        },
        get open() {
          return m(de)
        },
        set open(Ft) {
          H(de, Ft, !0)
        }
      })
    };
    Se(Fr, pt => {
      m($) && pt(ti)
    })
  }
  var Ai = D(Fr, 2);
  {
    var bi = pt => {
      R4(pt, {
        get url() {
          return m(pr)
        },
        get map() {
          return m($)
        },
        hideHover: () => {
          var Ft, zr;
          (Ft = m($)) == null || Ft.setPaintProperty(De, "raster-opacity", 0), (zr = m(Dt)) == null || zr.setCanvasOpacity(0)
        },
        showHover: () => {
          var Ft, zr;
          (Ft = m($)) == null || Ft.setPaintProperty(De, "raster-opacity", qe), (zr = m(Dt)) == null || zr.setCanvasOpacity(1)
        },
        get open() {
          return m($t)
        },
        set open(Ft) {
          H($t, Ft, !0)
        }
      })
    };
    Se(Ai, pt => {
      m($) && pt(bi)
    })
  }
  var Yr = D(Ai, 2);
  {
    var Zr = pt => {
      J5(pt, {
        get image() {
          return m(wt)
        },
        get targets() {
          return m(It)
        },
        get latLon() {
          return m(Ut)
        },
        get zoom() {
          return m(ut)
        },
        get action() {
          return m(Mt)
        },
        onsuccess: () => {
          var Ft, zr;
          (zr = (Ft = m(ur)) == null ? void 0 : Ft.onSuccess) == null || zr.call(Ft)
        },
        get origin() {
          return m(Ie)
        },
        get open() {
          return m(At)
        },
        set open(Ft) {
          H(At, Ft, !0)
        }
      })
    };
    Se(Yr, pt => {
      m(It) && m(It).length > 0 && m(wt) && m(Ut) && pt(Zr)
    })
  }
  var Ii = D(Yr, 2);
  {
    var ki = pt => {
      RC(pt, {
        get userData() {
          return Lt.data
        },
        get open() {
          return m(cr)
        },
        set open(Ft) {
          H(cr, Ft, !0)
        }
      })
    };
    Se(Ii, pt => {
      Lt.data && pt(ki)
    })
  }
  var wi = D(Ii, 2);
  U6(wi, {
    get open() {
      return m(jr)
    },
    set open(pt) {
      H(jr, pt, !0)
    }
  });
  var Vi = D(wi, 2);
  {
    var Yi = pt => {
      Pk(pt, {
        get map() {
          return m($)
        },
        get tileSize() {
          return k
        },
        get season() {
          return B
        },
        get tileZoom() {
          return b
        },
        get open() {
          return m(wr)
        },
        set open(Ft) {
          H(wr, Ft, !0)
        }
      })
    };
    Se(Vi, pt => {
      m($) && pt(Yi)
    })
  }
  Ch("innerWidth", pt => H(W, pt, !0)), q(y, X), ii()
}
$i(["click"]);
export {
  gL as component
};