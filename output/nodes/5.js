var L1 = Object.defineProperty;
var D1 = Object.getPrototypeOf;
var R1 = Reflect.get;
var dv = y => {
  throw TypeError(y)
};
var F1 = (y, l, _) => l in y ? L1(y, l, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: _
}) : y[l] = _;
var bi = (y, l, _) => F1(y, typeof l != "symbol" ? l + "" : l, _),
  Kf = (y, l, _) => l.has(y) || dv("Cannot " + _);
var ar = (y, l, _) => (Kf(y, l, "read from private field"), _ ? _.call(y) : l.get(y)),
  Ii = (y, l, _) => l.has(y) ? dv("Cannot add the same private member more than once") : l instanceof WeakSet ? l.add(y) : l.set(y, _),
  Mn = (y, l, _, x) => (Kf(y, l, "write to private field"), x ? x.call(y, _) : l.set(y, _), _),
  oi = (y, l, _) => (Kf(y, l, "access private method"), _);
var pv = (y, l, _) => R1(D1(y), _, l);
import "../chunks/d5UiUYZZ.js";
import {
  o as Oa,
  a as B1,
  s as La
} from "../chunks/CaGBnsSj.js";
import {
  a4 as O1,
  bn as j1,
  bA as q1,
  bp as N1,
  bB as V1,
  bh as U1,
  bC as Z1,
  e as Xe,
  bD as fv,
  a2 as G1,
  j as h,
  i as j,
  aV as Gu,
  A as Yr,
  b as B,
  p as Gr,
  a1 as en,
  bE as Jf,
  bF as W1,
  f as ae,
  w as Ci,
  av as qo,
  a as zt,
  d as P,
  r as S,
  s as E,
  n as wi,
  c as Wr,
  t as ke,
  y as An,
  h as br,
  bG as mv,
  z as H1,
  bH as X1,
  q as ja,
  g as Wi,
  o as Ui,
  u as Je,
  v as Qr,
  by as yp,
  af as Hm,
  aG as Y1,
  aF as gv,
  aH as K1,
  am as Xm,
  bI as mo,
  bi as $n,
  bJ as h0,
  B as J1,
  $ as $1
} from "../chunks/B2OmeKf3.js";
import {
  s as ee,
  c as d0
} from "../chunks/DZ2GTRzh.js";
import {
  i as Te
} from "../chunks/DmaHgtEc.js";
import {
  h as Q1
} from "../chunks/Ca5Oexje.js";
import {
  f as jr,
  a as Er,
  s as Xt,
  d as Qn,
  r as Ka,
  e as Ym,
  b as eb,
  g as qa,
  c as _l,
  i as op,
  h as cm
} from "../chunks/Wwysor49.js";
import {
  a as vl,
  t as dn
} from "../chunks/DqiiHVHt.js";
import {
  g as xp,
  b as tb
} from "../chunks/DX0Gvfq2.js";
import {
  p as xa
} from "../chunks/CAjMwQhK.js";
import {
  g as vn,
  P as rb,
  b as p0
} from "../chunks/BnQs7QRl.js";
import {
  f as xn,
  u as bt,
  t as Bt,
  a as Kr,
  a3 as Ds,
  V as ib,
  a4 as ab,
  a5 as nb,
  c as sb,
  a2 as ob,
  m as lb,
  e as cb,
  a6 as ub,
  C as _v,
  a7 as ep,
  P as hb
} from "../chunks/o0_U8pOt.js";
import {
  A as aa,
  p as Km,
  c as um,
  g as $f,
  a as db
} from "../chunks/CDqqNjWF.js";
import {
  P as Ba
} from "../chunks/R9Ou4GAr.js";
import "../chunks/D_NVu-yM.js";
import {
  e as Hi,
  i as po
} from "../chunks/BRCSQ2Qa.js";
import {
  a as bp,
  b as Tl,
  c as Jm
} from "../chunks/C-1D8vGt.js";
import {
  b as Rn
} from "../chunks/mhrRdOB7.js";
import {
  i as $m
} from "../chunks/t_BgcJ7S.js";
import {
  r as Or,
  p as Ot,
  s as Bc,
  u as vv
} from "../chunks/CCWrnJZ-.js";
import {
  C as ss,
  S as pb,
  U as fb,
  a as mb
} from "../chunks/C0X2H68t.js";
import {
  U as gb,
  A as f0,
  D as m0,
  a as Dp,
  I as hm,
  r as _b,
  P as vb,
  b as yb
} from "../chunks/8toSEb3v.js";
import {
  c as wp,
  b as g0,
  g as Dn,
  a as Rp
} from "../chunks/D6KGKkcs.js";
import {
  h as Fp
} from "../chunks/BuLhzYXx.js";
import {
  L as _0
} from "../chunks/D5fktieu.js";
import {
  l as xb,
  g as bb
} from "../chunks/DFupwelK.js";
import {
  c as No
} from "../chunks/CAi1WXDx.js";
import {
  d as wb,
  p as Qm
} from "../chunks/CO1qD7Z6.js";
import {
  cv as Tb,
  aZ as v0,
  ax as Sb,
  bX as Pb,
  I as eg,
  cx as Ib,
  cl as Bp,
  cC as Mb,
  aO as Cb,
  d as Ab,
  b5 as tg,
  ce as rg,
  cd as ig,
  ak as kb,
  a4 as zb,
  aj as Eb,
  u as y0,
  aU as Lb,
  aX as Db,
  O as Rb,
  N as Fb,
  e as Bb,
  aA as Ob,
  be as jb,
  ah as qb,
  o as Nb,
  P as Vb,
  aw as Ub,
  al as Zb,
  bg as Gb,
  b_ as Wb,
  H as x0,
  ar as Hb,
  aq as Xb,
  Z as Yb,
  bP as Kb,
  as as Jb,
  cA as $b,
  ac as Qb,
  a as e2,
  X as t2,
  b0 as r2,
  b2 as i2,
  bb as a2,
  T as n2,
  br as s2,
  by as o2,
  cD as l2,
  cq as c2,
  bz as u2,
  bk as h2,
  bm as d2,
  ap as p2,
  cE as f2,
  bj as m2,
  ao as g2,
  c4 as _2,
  h as v2,
  aK as y2,
  ca as x2,
  bA as b2,
  bH as b0,
  c8 as w2,
  x as T2,
  aa as S2,
  cy as P2,
  cw as I2,
  ay as M2,
  aY as C2,
  M as ag,
  bx as w0,
  L as A2,
  bJ as k2,
  bI as z2,
  bu as Cc,
  bq as Ac,
  bw as E2,
  bv as L2,
  bh as T0,
  aL as D2,
  bL as yv,
  bM as xv,
  bN as R2,
  b4 as F2,
  j as bv,
  k as wv,
  bK as Tv,
  l as Sv,
  bo as S0,
  bd as Op,
  b1 as B2,
  b3 as O2,
  bp as j2,
  G as q2,
  cm as P0,
  cr as N2,
  bG as V2,
  bR as U2,
  bS as Z2,
  bt as G2,
  F as W2,
  bl as H2,
  s as X2,
  cj as Y2,
  ck as K2,
  i as J2,
  ch as $2,
  c7 as Q2,
  cF as ew,
  p as tw,
  m as rw,
  n as iw,
  b as aw,
  S as dm,
  q as nw,
  cf as sw,
  cc as ow,
  co as lw,
  cp as cw,
  aJ as uw,
  bO as hw,
  c6 as I0,
  ba as dw,
  bW as Tp,
  ae as pw,
  C as fw,
  cK as mw,
  bc as M0,
  a_ as gw,
  a$ as _w,
  _ as vw,
  y as yw,
  aS as xw,
  b$ as bw,
  aP as ww,
  bC as Tw,
  A as Sw,
  V as Pw,
  aD as Iw,
  ct as Mw,
  cs as Cw,
  w as Qf,
  aW as Aw,
  t as kw,
  B as zw,
  a2 as Ew,
  cJ as Lw,
  aV as Dw,
  r as Rw,
  a3 as Fw,
  aI as Bw,
  K as Ow,
  c3 as jw,
  aM as qw,
  aN as Nw,
  z as Vw,
  cu as Uw,
  aQ as Zw,
  aB as Gw,
  R as Ww,
  ci as Hw,
  c2 as Xw,
  am as Yw,
  J as Kw,
  av as Jw,
  cg as $w,
  cB as Qw,
  cI as e5,
  v as Pv,
  bE as t5,
  bD as r5,
  b6 as i5,
  b8 as a5,
  bT as n5,
  bQ as s5,
  bU as o5,
  bZ as l5,
  aF as c5,
  aE as u5,
  aC as h5,
  a6 as d5,
  bf as p5,
  a5 as f5,
  E as m5,
  D as g5,
  a9 as _5,
  W as v5,
  c0 as y5,
  c1 as x5,
  b9 as b5,
  Y as w5,
  ag as T5,
  a0 as Rc,
  $ as jp,
  cz as S5,
  aT as C0,
  b7 as P5,
  c as I5,
  Q as M5,
  ab as C5,
  cb as A5,
  bn as Iv,
  a8 as k5,
  a7 as z5,
  c5 as A0,
  f as E5,
  g as L5,
  az as D5,
  ai as R5,
  bB as F5,
  at as B5,
  bF as O5,
  af as j5,
  a1 as q5,
  ad as N5,
  aR as V5,
  cL as U5,
  cN as Z5,
  bY as G5,
  U as W5,
  cn as H5,
  cH as X5,
  c9 as Y5,
  aH as K5,
  au as J5,
  an as $5,
  bi as Q5,
  cM as e3,
  bs as Mv,
  aG as t3,
  cG as r3,
  bV as i3
} from "../chunks/C-4XOZMv.js";
import {
  c as pm
} from "../chunks/DC5Kkxfa.js";
import {
  P as bn,
  t as a3
} from "../chunks/BvOZl7GW.js";
import {
  L as qp
} from "../chunks/BsPYrghM.js";
import {
  l as n3,
  v as s3,
  a as Ju,
  s as k0
} from "../chunks/BDK4SShz.js";
import {
  p as ng,
  m as z0
} from "../chunks/B6FFVWgi.js";
import {
  f as yl
} from "../chunks/DVxb96gU.js";
import {
  k as bl
} from "../chunks/DLxRqgXy.js";
import {
  A as sg
} from "../chunks/D4G3Pgg_.js";
import {
  b as og
} from "../chunks/BUygcoYw.js";
import {
  u as o3
} from "../chunks/BThgDl77.js";
import {
  u as l3
} from "../chunks/T53K15iB.js";
import {
  n as fm,
  c as E0,
  b as c3,
  a as u3
} from "../chunks/2jlt47DU.js";
import {
  E as mm,
  D as lg,
  a as Cv,
  W as h3,
  b as d3,
  R as p3
} from "../chunks/B3OBC1Pg.js";
import {
  l as cg
} from "../chunks/BhWbBhR6.js";
import {
  g as Np,
  s as f3,
  f as m3,
  l as L0,
  b as g3,
  c as _3,
  e as v3,
  z as y3,
  y as x3,
  x as b3,
  d as Sp,
  p as D0,
  m as Av,
  a as w3,
  u as T3,
  t as kv
} from "../chunks/BjKeV4GC.js";
import {
  f as Jn,
  s as lp
} from "../chunks/Dthyznzp.js";
import {
  C as ug
} from "../chunks/BrkIhsbF.js";
import {
  L as R0
} from "../chunks/Cys85D-6.js";
import {
  t as S3,
  r as F0,
  g as P3
} from "../chunks/13dJBKtW.js";
import {
  c as uo
} from "../chunks/Bic-T4cv.js";
import {
  c as yn
} from "../chunks/CXeigOfT.js";
import {
  a as B0
} from "../chunks/D1kgE7xc.js";
import {
  L as I3
} from "../chunks/tuBYSTZl.js";
import {
  e as M3,
  a as C3
} from "../chunks/MIzAAZhN.js";
import {
  b as A3
} from "../chunks/ByvLBDhg.js";
import {
  c as O0
} from "../chunks/D0k5EwYZ.js";
import {
  e as j0
} from "../chunks/BeVbZvgs.js";
import {
  p as q0
} from "../chunks/SzzCqiQg.js";
import {
  a as k3
} from "../chunks/BHUhp09o.js";
import {
  d as z3
} from "../chunks/CLZbx-Zt.js";
import {
  r as E3
} from "../chunks/CfVM6hZR.js";
import {
  p as L3
} from "../chunks/C1hqb5CV.js";
import {
  R as N0
} from "../chunks/0PlbdZDc.js";
import {
  T as $u,
  G as Pp
} from "../chunks/CGCZebnp.js";
import {
  t as V0
} from "../chunks/PLdG5BP0.js";
import {
  C as D3
} from "../chunks/nz-irfvU.js";
import {
  R as R3
} from "../chunks/VaJd0_t7.js";
import {
  W as F3
} from "../chunks/CE0yZS35.js";
import {
  r as B3
} from "../chunks/D9jJdl3-.js";
(function() {
  try {
    var y = typeof window < "u" ? window : typeof global < "u" ? global : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {};
    y.SENTRY_RELEASE = {
      id: "70dda2bcd37c81e0ed25f634cf032d8abd8db068"
    }
  } catch {}
})();
try {
  (function() {
    var y = typeof window < "u" ? window : typeof global < "u" ? global : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {},
      l = new y.Error().stack;
    l && (y._sentryDebugIds = y._sentryDebugIds || {}, y._sentryDebugIds[l] = "3d9ff4db-8054-4f56-953e-1415b545708a", y._sentryDebugIdIdentifier = "sentry-dbid-3d9ff4db-8054-4f56-953e-1415b545708a")
  })()
} catch {}
const O3 = [];

function j3(y, l = !1, _ = !1) {
  return cp(y, new Map, "", O3, null, _)
}

function cp(y, l, _, x, k = null, z = !1) {
  if (typeof y == "object" && y !== null) {
    var T = l.get(y);
    if (T !== void 0) return T;
    if (y instanceof Map) return new Map(y);
    if (y instanceof Set) return new Set(y);
    if (O1(y)) {
      var s = Array(y.length);
      l.set(y, s), k !== null && l.set(k, s);
      for (var F = 0; F < y.length; F += 1) {
        var Z = y[F];
        F in y && (s[F] = cp(Z, l, _, x, null, z))
      }
      return s
    }
    if (j1(y) === q1) {
      s = {}, l.set(y, s), k !== null && l.set(k, s);
      for (var K in y) s[K] = cp(y[K], l, _, x, null, z);
      return s
    }
    if (y instanceof Date) return structuredClone(y);
    if (typeof y.toJSON == "function" && !z) return cp(y.toJSON(), l, _, x, y)
  }
  if (y instanceof EventTarget) return y;
  try {
    return structuredClone(y)
  } catch {
    return y
  }
}

function q3() {
  return Symbol(N1)
}

function Eh(y, l) {
  V1(window, ["resize"], () => U1(() => l(window[y])))
}

function N3(y) {
  return function(...l) {
    var _ = l[0];
    return _.preventDefault(), y == null ? void 0 : y.apply(this, l)
  }
}
const V3 = Z1;
var Es, Ls, lo, zp, Ts, Wu, up;
const Tg = class Tg extends Map {
  constructor(_) {
    super();
    Ii(this, Ts);
    Ii(this, Es, new Map);
    Ii(this, Ls, Xe(0));
    Ii(this, lo, Xe(0));
    Ii(this, zp, fv || -1);
    if (_) {
      for (var [x, k] of _) super.set(x, k);
      ar(this, lo).v = super.size
    }
  }
  has(_) {
    var x = ar(this, Es),
      k = x.get(_);
    if (k === void 0) {
      var z = super.get(_);
      if (z !== void 0) k = oi(this, Ts, Wu).call(this, 0), x.set(_, k);
      else return h(ar(this, Ls)), !1
    }
    return h(k), !0
  }
  forEach(_, x) {
    oi(this, Ts, up).call(this), super.forEach(_, x)
  }
  get(_) {
    var x = ar(this, Es),
      k = x.get(_);
    if (k === void 0) {
      var z = super.get(_);
      if (z !== void 0) k = oi(this, Ts, Wu).call(this, 0), x.set(_, k);
      else {
        h(ar(this, Ls));
        return
      }
    }
    return h(k), super.get(_)
  }
  set(_, x) {
    var G;
    var k = ar(this, Es),
      z = k.get(_),
      T = super.get(_),
      s = super.set(_, x),
      F = ar(this, Ls);
    if (z === void 0) z = oi(this, Ts, Wu).call(this, 0), k.set(_, z), j(ar(this, lo), super.size), Gu(F);
    else if (T !== x) {
      Gu(z);
      var Z = F.reactions === null ? null : new Set(F.reactions),
        K = Z === null || !((G = z.reactions) != null && G.every(re => Z.has(re)));
      K && Gu(F)
    }
    return s
  }
  delete(_) {
    var x = ar(this, Es),
      k = x.get(_),
      z = super.delete(_);
    return k !== void 0 && (x.delete(_), j(ar(this, lo), super.size), j(k, -1), Gu(ar(this, Ls))), z
  }
  clear() {
    if (super.size !== 0) {
      super.clear();
      var _ = ar(this, Es);
      j(ar(this, lo), 0);
      for (var x of _.values()) j(x, -1);
      Gu(ar(this, Ls)), _.clear()
    }
  }
  keys() {
    return h(ar(this, Ls)), super.keys()
  }
  values() {
    return oi(this, Ts, up).call(this), super.values()
  }
  entries() {
    return oi(this, Ts, up).call(this), super.entries()
  } [Symbol.iterator]() {
    return this.entries()
  }
  get size() {
    return h(ar(this, lo)), super.size
  }
};
Es = new WeakMap, Ls = new WeakMap, lo = new WeakMap, zp = new WeakMap, Ts = new WeakSet, Wu = function(_) {
  return fv === ar(this, zp) ? Xe(_) : G1(_)
}, up = function() {
  h(ar(this, Ls));
  var _ = ar(this, Es);
  if (ar(this, lo).v !== _.size) {
    for (var x of pv(Tg.prototype, this, "keys").call(this))
      if (!_.has(x)) {
        var k = oi(this, Ts, Wu).call(this, 0);
        _.set(x, k)
      }
  }
  for ([, k] of ar(this, Es)) h(k)
};
let Ip = Tg;
const no = 2 * Math.PI * 6378137 / 2;
class kn {
  constructor(l = 256) {
    bi(this, "initialResolution");
    this.tileSize = l, this.initialResolution = 2 * no / this.tileSize
  }
  latLonToMeters(l, _) {
    const x = _ / 180 * no,
      k = Math.log(Math.tan((90 + l) * Math.PI / 360)) / (Math.PI / 180) * no / 180;
    return [x, k]
  }
  metersToLatLon(l, _) {
    const x = l / no * 180;
    let k = _ / no * 180;
    return k = 180 / Math.PI * (2 * Math.atan(Math.exp(k * Math.PI / 180)) - Math.PI / 2), [k, x]
  }
  pixelsToMeters(l, _, x) {
    const k = this.resolution(x),
      z = l * k - no,
      T = no - _ * k;
    return [z, T]
  }
  pixelsToLatLon(l, _, x) {
    const [k, z] = this.pixelsToMeters(l, _, x);
    return this.metersToLatLon(k, z)
  }
  latLonToPixels(l, _, x) {
    const [k, z] = this.latLonToMeters(l, _);
    return this.metersToPixels(k, z, x)
  }
  latLonToPixelsFloor(l, _, x) {
    const [k, z] = this.latLonToPixels(l, _, x);
    return [Math.floor(k), Math.floor(z)]
  }
  metersToPixels(l, _, x) {
    const k = this.resolution(x),
      z = (l + no) / k,
      T = (no - _) / k;
    return [z, T]
  }
  latLonToTile(l, _, x) {
    const [k, z] = this.latLonToMeters(l, _);
    return this.metersToTile(k, z, x)
  }
  metersToTile(l, _, x) {
    const [k, z] = this.metersToPixels(l, _, x);
    return this.pixelsToTile(k, z)
  }
  pixelsToTile(l, _) {
    const x = Math.ceil(l / this.tileSize) - 1,
      k = Math.ceil(_ / this.tileSize) - 1;
    return [x, k]
  }
  pixelsToTileLocal(l, _) {
    return {
      tile: this.pixelsToTile(l, _),
      pixel: [Math.floor(l) % this.tileSize, Math.floor(_) % this.tileSize]
    }
  }
  tileBounds(l, _, x) {
    const [k, z] = this.pixelsToMeters(l * this.tileSize, _ * this.tileSize, x), [T, s] = this.pixelsToMeters((l + 1) * this.tileSize, (_ + 1) * this.tileSize, x);
    return {
      min: [k, z],
      max: [T, s]
    }
  }
  tileBoundsLatLon(l, _, x) {
    const k = this.tileBounds(l, _, x);
    return {
      min: this.metersToLatLon(k.min[0], k.min[1]),
      max: this.metersToLatLon(k.max[0], k.max[1])
    }
  }
  resolution(l) {
    return this.initialResolution / 2 ** l
  }
  latLonToTileAndPixel(l, _, x) {
    const [k, z] = this.latLonToMeters(l, _), [T, s] = this.metersToTile(k, z, x), [F, Z] = this.metersToPixels(k, z, x);
    return {
      tile: [T, s],
      pixel: [Math.floor(F) % this.tileSize, Math.floor(Z) % this.tileSize]
    }
  }
  pixelBounds(l, _, x) {
    return {
      min: this.pixelsToMeters(l, _, x),
      max: this.pixelsToMeters(l + 1, _ + 1, x)
    }
  }
  pixelToBoundsLatLon(l, _, x) {
    const k = this.pixelBounds(l, _, x),
      z = .001885,
      T = (k.max[0] - k.min[0]) * z,
      s = (k.max[1] - k.min[1]) * z;
    return k.min[0] -= T, k.max[0] -= T, k.min[1] -= s, k.max[1] -= s, {
      min: this.metersToLatLon(k.min[0], k.min[1]),
      max: this.metersToLatLon(k.max[0], k.max[1])
    }
  }
  latLonToTileBoundsLatLon(l, _, x) {
    const [k, z] = this.latLonToMeters(l, _), [T, s] = this.metersToTile(k, z, x);
    return this.tileBoundsLatLon(T, s, x)
  }
  latLonToPixelBoundsLatLon(l, _, x) {
    const [k, z] = this.latLonToMeters(l, _), [T, s] = this.metersToPixels(k, z, x);
    return this.pixelToBoundsLatLon(Math.floor(T), Math.floor(s), x)
  }
  latLonToRegionAndPixel(l, _, x, k = xn.regionSize) {
    const [z, T] = this.latLonToPixelsFloor(l, _, x), s = this.tileSize * k;
    return {
      region: [Math.floor(z / s), Math.floor(T / s)],
      pixel: [z % s, T % s]
    }
  }
}

function hg(y, l = !0) {
  const {
    min: _,
    max: x
  } = y;
  return l ? [
    [_[1], x[0]],
    [x[1], x[0]],
    [x[1], _[0]],
    [_[1], _[0]]
  ] : [
    [_[0], x[1]],
    [x[0], x[1]],
    [x[0], _[1]],
    [_[0], _[1]]
  ]
}

function dg(y) {
  return [(y.min[0] + y.max[0]) / 2, (y.min[1] + y.max[1]) / 2]
}
const U3 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAAAAACoWZBhAAAAAXNSR0IArs4c6QAAACpJREFUeNpj+AsEZ86ASIa/DAwMZ84ACRDzDBigMs/AARITq1oUwxBWAADaREUdDMswKwAAAABJRU5ErkJggg==",
  zv = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAACVJREFUeNpj+A8FDEAAZwMRBAIBmIYLIgHcgkQDIs3E6SRsjgcABYFLtfTgakEAAAAASUVORK5CYII=";

function Z3(y) {
  return Math.floor(Math.random() * y)
}
const gm = 14.5;
async function G3() {
  const y = H3();
  if (y) return y;
  try {
    if ((await navigator.permissions.query({
        name: "geolocation"
      })).state === "granted") {
      const _ = await new Promise((x, k) => navigator.geolocation.getCurrentPosition(z => x(z), z => k(z)));
      return {
        lat: _.coords.latitude,
        lng: _.coords.longitude,
        zoom: gm
      }
    }
  } catch (l) {
    console.error(l)
  }
  return {
    ...W3().pos,
    zoom: gm
  }
}

function W3() {
  const y = Object.entries(U0),
    l = Z3(y.length),
    [_, x] = y[l];
  return {
    city: _,
    pos: x
  }
}
const U0 = {
    tokyo: {
      lat: 35.677545560719665,
      lng: 139.76394445809638
    },
    paris: {
      lat: 48.8537151734952,
      lng: 2.3484026030630787
    },
    newYork: {
      lat: 40.71283173786517,
      lng: -74.00599771376795
    },
    saoPaulo: {
      lat: -23.550584064565356,
      lng: -46.63339720713918
    },
    sydney: {
      lat: -33.86943325619071,
      lng: 151.2083447239608
    }
  },
  Z0 = "location";

function so(y, l) {
  localStorage.setItem(Z0, JSON.stringify({
    ...y,
    zoom: l
  }))
}

function H3() {
  const y = localStorage.getItem(Z0);
  if (!y) return;
  const l = JSON.parse(y);
  return l.zoom ?? (l.zoom = gm), l
}

function X3(y) {
  return y.lat >= -90 && y.lat <= 90 && y.lng >= -180 && y.lng <= 180
}
var ih, ah;
class Y3 {
  constructor() {
    Ii(this, ih, Xe(-1));
    Ii(this, ah, Xe([]))
  }
  get idx() {
    return h(ar(this, ih))
  }
  set idx(l) {
    j(ar(this, ih), l, !0)
  }
  get entries() {
    return h(ar(this, ah))
  }
  set entries(l) {
    j(ar(this, ah), l)
  }
  hasNext() {
    return this.idx < this.entries.length - 1
  }
  goToNext(l) {
    const _ = this.idx + 1,
      x = this.entries[_];
    x && (this.idx = _, l.flyTo({
      center: x.pos,
      zoom: x.zoom
    }))
  }
  hasPrev() {
    return this.idx > 0
  }
  goToPrev(l) {
    const _ = this.idx - 1,
      x = this.entries[_];
    x && (this.idx = _, l.flyTo({
      center: x.pos,
      zoom: x.zoom
    }))
  }
  isEmpty() {
    return this.entries.length === 0
  }
  push(l) {
    this.idx = this.idx + 1, this.entries = [...this.entries.slice(0, this.idx), l]
  }
}
ih = new WeakMap, ah = new WeakMap;
const K3 = new Y3;

function J3(y) {
  return y && y.__esModule && Object.prototype.hasOwnProperty.call(y, "default") ? y.default : y
}
var hp = {
  exports: {}
};
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.11.0/LICENSE.txt
 */
var $3 = hp.exports,
  Ev;

function Q3() {
  return Ev || (Ev = 1, (function(y, l) {
    (function(_, x) {
      y.exports = x()
    })($3, (function() {
      var _ = {},
        x = {};

      function k(T, s, F) {
        if (x[T] = F, T === "index") {
          var Z = "var sharedModule = {}; (" + x.shared + ")(sharedModule); (" + x.worker + ")(sharedModule);",
            K = {};
          return x.shared(K), x.index(_, K), typeof window < "u" && _.setWorkerUrl(window.URL.createObjectURL(new Blob([Z], {
            type: "text/javascript"
          }))), _
        }
      }
      k("shared", ["exports"], (function(T) {
        function s(i, t, r, n) {
          return new(r || (r = Promise))((function(c, f) {
            function m(M) {
              try {
                b(n.next(M))
              } catch (C) {
                f(C)
              }
            }

            function v(M) {
              try {
                b(n.throw(M))
              } catch (C) {
                f(C)
              }
            }

            function b(M) {
              var C;
              M.done ? c(M.value) : (C = M.value, C instanceof r ? C : new r((function(D) {
                D(C)
              }))).then(m, v)
            }
            b((n = n.apply(i, t || [])).next())
          }))
        }

        function F(i, t) {
          this.x = i, this.y = t
        }

        function Z(i) {
          return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i
        }
        var K, G;
        typeof SuppressedError == "function" && SuppressedError, F.prototype = {
          clone() {
            return new F(this.x, this.y)
          },
          add(i) {
            return this.clone()._add(i)
          },
          sub(i) {
            return this.clone()._sub(i)
          },
          multByPoint(i) {
            return this.clone()._multByPoint(i)
          },
          divByPoint(i) {
            return this.clone()._divByPoint(i)
          },
          mult(i) {
            return this.clone()._mult(i)
          },
          div(i) {
            return this.clone()._div(i)
          },
          rotate(i) {
            return this.clone()._rotate(i)
          },
          rotateAround(i, t) {
            return this.clone()._rotateAround(i, t)
          },
          matMult(i) {
            return this.clone()._matMult(i)
          },
          unit() {
            return this.clone()._unit()
          },
          perp() {
            return this.clone()._perp()
          },
          round() {
            return this.clone()._round()
          },
          mag() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
          },
          equals(i) {
            return this.x === i.x && this.y === i.y
          },
          dist(i) {
            return Math.sqrt(this.distSqr(i))
          },
          distSqr(i) {
            const t = i.x - this.x,
              r = i.y - this.y;
            return t * t + r * r
          },
          angle() {
            return Math.atan2(this.y, this.x)
          },
          angleTo(i) {
            return Math.atan2(this.y - i.y, this.x - i.x)
          },
          angleWith(i) {
            return this.angleWithSep(i.x, i.y)
          },
          angleWithSep(i, t) {
            return Math.atan2(this.x * t - this.y * i, this.x * i + this.y * t)
          },
          _matMult(i) {
            const t = i[2] * this.x + i[3] * this.y;
            return this.x = i[0] * this.x + i[1] * this.y, this.y = t, this
          },
          _add(i) {
            return this.x += i.x, this.y += i.y, this
          },
          _sub(i) {
            return this.x -= i.x, this.y -= i.y, this
          },
          _mult(i) {
            return this.x *= i, this.y *= i, this
          },
          _div(i) {
            return this.x /= i, this.y /= i, this
          },
          _multByPoint(i) {
            return this.x *= i.x, this.y *= i.y, this
          },
          _divByPoint(i) {
            return this.x /= i.x, this.y /= i.y, this
          },
          _unit() {
            return this._div(this.mag()), this
          },
          _perp() {
            const i = this.y;
            return this.y = this.x, this.x = -i, this
          },
          _rotate(i) {
            const t = Math.cos(i),
              r = Math.sin(i),
              n = r * this.x + t * this.y;
            return this.x = t * this.x - r * this.y, this.y = n, this
          },
          _rotateAround(i, t) {
            const r = Math.cos(i),
              n = Math.sin(i),
              c = t.y + n * (this.x - t.x) + r * (this.y - t.y);
            return this.x = t.x + r * (this.x - t.x) - n * (this.y - t.y), this.y = c, this
          },
          _round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
          },
          constructor: F
        }, F.convert = function(i) {
          if (i instanceof F) return i;
          if (Array.isArray(i)) return new F(+i[0], +i[1]);
          if (i.x !== void 0 && i.y !== void 0) return new F(+i.x, +i.y);
          throw new Error("Expected [x, y] or {x, y} point format")
        };
        var re = (function() {
            if (G) return K;

            function i(t, r, n, c) {
              this.cx = 3 * t, this.bx = 3 * (n - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * r, this.by = 3 * (c - r) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = r, this.p2x = n, this.p2y = c
            }
            return G = 1, K = i, i.prototype = {
              sampleCurveX: function(t) {
                return ((this.ax * t + this.bx) * t + this.cx) * t
              },
              sampleCurveY: function(t) {
                return ((this.ay * t + this.by) * t + this.cy) * t
              },
              sampleCurveDerivativeX: function(t) {
                return (3 * this.ax * t + 2 * this.bx) * t + this.cx
              },
              solveCurveX: function(t, r) {
                if (r === void 0 && (r = 1e-6), t < 0) return 0;
                if (t > 1) return 1;
                for (var n = t, c = 0; c < 8; c++) {
                  var f = this.sampleCurveX(n) - t;
                  if (Math.abs(f) < r) return n;
                  var m = this.sampleCurveDerivativeX(n);
                  if (Math.abs(m) < 1e-6) break;
                  n -= f / m
                }
                var v = 0,
                  b = 1;
                for (n = t, c = 0; c < 20 && (f = this.sampleCurveX(n), !(Math.abs(f - t) < r)); c++) t > f ? v = n : b = n, n = .5 * (b - v) + v;
                return n
              },
              solve: function(t, r) {
                return this.sampleCurveY(this.solveCurveX(t, r))
              }
            }, K
          })(),
          he = Z(re);
        let me, q;

        function ye() {
          return me == null && (me = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), me
        }

        function be() {
          if (q == null && (q = !1, ye())) {
            const t = new OffscreenCanvas(5, 5).getContext("2d", {
              willReadFrequently: !0
            });
            if (t) {
              for (let n = 0; n < 25; n++) {
                const c = 4 * n;
                t.fillStyle = `rgb(${c},${c+1},${c+2})`, t.fillRect(n % 5, Math.floor(n / 5), 1, 1)
              }
              const r = t.getImageData(0, 0, 5, 5).data;
              for (let n = 0; n < 100; n++)
                if (n % 4 != 3 && r[n] !== n) {
                  q = !0;
                  break
                }
            }
          }
          return q || !1
        }
        var qe = 1e-6,
          xe = typeof Float32Array < "u" ? Float32Array : Array;

        function Ye() {
          var i = new xe(9);
          return xe != Float32Array && (i[1] = 0, i[2] = 0, i[3] = 0, i[5] = 0, i[6] = 0, i[7] = 0), i[0] = 1, i[4] = 1, i[8] = 1, i
        }

        function We(i) {
          return i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i
        }

        function ze() {
          var i = new xe(3);
          return xe != Float32Array && (i[0] = 0, i[1] = 0, i[2] = 0), i
        }

        function Se(i) {
          var t = i[0],
            r = i[1],
            n = i[2];
          return Math.sqrt(t * t + r * r + n * n)
        }

        function Pe(i, t, r) {
          var n = new xe(3);
          return n[0] = i, n[1] = t, n[2] = r, n
        }

        function Ae(i, t, r) {
          return i[0] = t[0] + r[0], i[1] = t[1] + r[1], i[2] = t[2] + r[2], i
        }

        function Me(i, t, r) {
          return i[0] = t[0] * r, i[1] = t[1] * r, i[2] = t[2] * r, i
        }

        function Ee(i, t, r) {
          var n = t[0],
            c = t[1],
            f = t[2],
            m = r[0],
            v = r[1],
            b = r[2];
          return i[0] = c * b - f * v, i[1] = f * m - n * b, i[2] = n * v - c * m, i
        }
        var Qe, Ue = Se;

        function je(i, t, r) {
          var n = t[0],
            c = t[1],
            f = t[2],
            m = t[3];
          return i[0] = r[0] * n + r[4] * c + r[8] * f + r[12] * m, i[1] = r[1] * n + r[5] * c + r[9] * f + r[13] * m, i[2] = r[2] * n + r[6] * c + r[10] * f + r[14] * m, i[3] = r[3] * n + r[7] * c + r[11] * f + r[15] * m, i
        }

        function rt() {
          var i = new xe(4);
          return xe != Float32Array && (i[0] = 0, i[1] = 0, i[2] = 0), i[3] = 1, i
        }

        function _t(i, t, r, n) {
          var c = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "zyx",
            f = Math.PI / 360;
          t *= f, n *= f, r *= f;
          var m = Math.sin(t),
            v = Math.cos(t),
            b = Math.sin(r),
            M = Math.cos(r),
            C = Math.sin(n),
            D = Math.cos(n);
          switch (c) {
            case "xyz":
              i[0] = m * M * D + v * b * C, i[1] = v * b * D - m * M * C, i[2] = v * M * C + m * b * D, i[3] = v * M * D - m * b * C;
              break;
            case "xzy":
              i[0] = m * M * D - v * b * C, i[1] = v * b * D - m * M * C, i[2] = v * M * C + m * b * D, i[3] = v * M * D + m * b * C;
              break;
            case "yxz":
              i[0] = m * M * D + v * b * C, i[1] = v * b * D - m * M * C, i[2] = v * M * C - m * b * D, i[3] = v * M * D + m * b * C;
              break;
            case "yzx":
              i[0] = m * M * D + v * b * C, i[1] = v * b * D + m * M * C, i[2] = v * M * C - m * b * D, i[3] = v * M * D - m * b * C;
              break;
            case "zxy":
              i[0] = m * M * D - v * b * C, i[1] = v * b * D + m * M * C, i[2] = v * M * C + m * b * D, i[3] = v * M * D - m * b * C;
              break;
            case "zyx":
              i[0] = m * M * D - v * b * C, i[1] = v * b * D + m * M * C, i[2] = v * M * C - m * b * D, i[3] = v * M * D + m * b * C;
              break;
            default:
              throw new Error("Unknown angle order " + c)
          }
          return i
        }

        function dt() {
          var i = new xe(2);
          return xe != Float32Array && (i[0] = 0, i[1] = 0), i
        }

        function at(i, t) {
          var r = new xe(2);
          return r[0] = i, r[1] = t, r
        }
        ze(), Qe = new xe(4), xe != Float32Array && (Qe[0] = 0, Qe[1] = 0, Qe[2] = 0, Qe[3] = 0), ze(), Pe(1, 0, 0), Pe(0, 1, 0), rt(), rt(), Ye(), dt();
        const nt = 8192;

        function ot(i, t, r) {
          return t * (nt / (i.tileSize * Math.pow(2, r - i.tileID.overscaledZ)))
        }

        function ut(i, t) {
          return (i % t + t) % t
        }

        function st(i, t, r) {
          return i * (1 - r) + t * r
        }

        function wt(i) {
          if (i <= 0) return 0;
          if (i >= 1) return 1;
          const t = i * i,
            r = t * i;
          return 4 * (i < .5 ? r : 3 * (i - t) + r - .75)
        }

        function Ct(i, t, r, n) {
          const c = new he(i, t, r, n);
          return f => c.solve(f)
        }
        const rr = Ct(.25, .1, .25, 1);

        function Zt(i, t, r) {
          return Math.min(r, Math.max(t, i))
        }

        function lt(i, t, r) {
          const n = r - t,
            c = ((i - t) % n + n) % n + t;
          return c === t ? r : c
        }

        function ht(i, ...t) {
          for (const r of t)
            for (const n in r) i[n] = r[n];
          return i
        }
        let Dt = 1;

        function Vt(i, t, r) {
          const n = {};
          for (const c in i) n[c] = t.call(this, i[c], c, i);
          return n
        }

        function Jt(i, t, r) {
          const n = {};
          for (const c in i) t.call(this, i[c], c, i) && (n[c] = i[c]);
          return n
        }

        function jt(i) {
          return Array.isArray(i) ? i.map(jt) : typeof i == "object" && i ? Vt(i, jt) : i
        }
        const nr = {};

        function St(i) {
          nr[i] || (typeof console < "u" && console.warn(i), nr[i] = !0)
        }

        function Et(i, t, r) {
          return (r.y - i.y) * (t.x - i.x) > (t.y - i.y) * (r.x - i.x)
        }

        function Ut(i) {
          return typeof WorkerGlobalScope < "u" && i !== void 0 && i instanceof WorkerGlobalScope
        }
        let Gt = null;

        function Rt(i) {
          if (Gt == null) {
            const t = i.navigator ? i.navigator.userAgent : null;
            Gt = !!i.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome")))
          }
          return Gt
        }

        function ir(i) {
          return typeof ImageBitmap < "u" && i instanceof ImageBitmap
        }
        const kr = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";

        function _r(i, t, r, n, c) {
          return s(this, void 0, void 0, (function*() {
            if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
            const f = new VideoFrame(i, {
              timestamp: 0
            });
            try {
              const m = f == null ? void 0 : f.format;
              if (!m || !m.startsWith("BGR") && !m.startsWith("RGB")) throw new Error(`Unrecognized format ${m}`);
              const v = m.startsWith("BGR"),
                b = new Uint8ClampedArray(n * c * 4);
              if (yield f.copyTo(b, (function(M, C, D, N, W) {
                  const X = 4 * Math.max(-C, 0),
                    Q = (Math.max(0, D) - D) * N * 4 + X,
                    le = 4 * N,
                    we = Math.max(0, C),
                    et = Math.max(0, D);
                  return {
                    rect: {
                      x: we,
                      y: et,
                      width: Math.min(M.width, C + N) - we,
                      height: Math.min(M.height, D + W) - et
                    },
                    layout: [{
                      offset: Q,
                      stride: le
                    }]
                  }
                })(i, t, r, n, c)), v)
                for (let M = 0; M < b.length; M += 4) {
                  const C = b[M];
                  b[M] = b[M + 2], b[M + 2] = C
                }
              return b
            } finally {
              f.close()
            }
          }))
        }
        let fr, Yt;

        function sr(i, t, r, n) {
          return i.addEventListener(t, r, n), {
            unsubscribe: () => {
              i.removeEventListener(t, r, n)
            }
          }
        }

        function Kt(i) {
          return i * Math.PI / 180
        }

        function vr(i) {
          return i / Math.PI * 180
        }
        const Lr = {
            touchstart: !0,
            touchmove: !0,
            touchmoveWindow: !0,
            touchend: !0,
            touchcancel: !0
          },
          ii = {
            dblclick: !0,
            click: !0,
            mouseover: !0,
            mouseout: !0,
            mousedown: !0,
            mousemove: !0,
            mousemoveWindow: !0,
            mouseup: !0,
            mouseupWindow: !0,
            contextmenu: !0,
            wheel: !0
          },
          mr = "AbortError";

        function ge() {
          return new Error(mr)
        }
        const V = {
          MAX_PARALLEL_IMAGE_REQUESTS: 16,
          MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8,
          MAX_TILE_CACHE_ZOOM_LEVELS: 5,
          REGISTERED_PROTOCOLS: {},
          WORKER_URL: ""
        };

        function U(i) {
          return V.REGISTERED_PROTOCOLS[i.substring(0, i.indexOf("://"))]
        }
        const J = "global-dispatcher";
        class se extends Error {
          constructor(t, r, n, c) {
            super(`AJAXError: ${r} (${t}): ${n}`), this.status = t, this.statusText = r, this.url = n, this.body = c
          }
        }
        const te = () => Ut(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href,
          _e = function(i, t) {
            if (/:\/\//.test(i.url) && !/^https?:|^file:/.test(i.url)) {
              const n = U(i.url);
              if (n) return n(i, t);
              if (Ut(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
                type: "GR",
                data: i,
                targetMapId: J
              }, t)
            }
            if (!(/^file:/.test(r = i.url) || /^file:/.test(te()) && !/^\w+:/.test(r))) {
              if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return (function(n, c) {
                return s(this, void 0, void 0, (function*() {
                  const f = new Request(n.url, {
                    method: n.method || "GET",
                    body: n.body,
                    credentials: n.credentials,
                    headers: n.headers,
                    cache: n.cache,
                    referrer: te(),
                    signal: c.signal
                  });
                  let m, v;
                  n.type !== "json" || f.headers.has("Accept") || f.headers.set("Accept", "application/json");
                  try {
                    m = yield fetch(f)
                  } catch (M) {
                    throw new se(0, M.message, n.url, new Blob)
                  }
                  if (!m.ok) {
                    const M = yield m.blob();
                    throw new se(m.status, m.statusText, n.url, M)
                  }
                  v = n.type === "arrayBuffer" || n.type === "image" ? m.arrayBuffer() : n.type === "json" ? m.json() : m.text();
                  const b = yield v;
                  if (c.signal.aborted) throw ge();
                  return {
                    data: b,
                    cacheControl: m.headers.get("Cache-Control"),
                    expires: m.headers.get("Expires")
                  }
                }))
              })(i, t);
              if (Ut(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
                type: "GR",
                data: i,
                mustQueue: !0,
                targetMapId: J
              }, t)
            }
            var r;
            return (function(n, c) {
              return new Promise(((f, m) => {
                var v;
                const b = new XMLHttpRequest;
                b.open(n.method || "GET", n.url, !0), n.type !== "arrayBuffer" && n.type !== "image" || (b.responseType = "arraybuffer");
                for (const M in n.headers) b.setRequestHeader(M, n.headers[M]);
                n.type === "json" && (b.responseType = "text", !((v = n.headers) === null || v === void 0) && v.Accept || b.setRequestHeader("Accept", "application/json")), b.withCredentials = n.credentials === "include", b.onerror = () => {
                  m(new Error(b.statusText))
                }, b.onload = () => {
                  if (!c.signal.aborted)
                    if ((b.status >= 200 && b.status < 300 || b.status === 0) && b.response !== null) {
                      let M = b.response;
                      if (n.type === "json") try {
                        M = JSON.parse(b.response)
                      } catch (C) {
                        return void m(C)
                      }
                      f({
                        data: M,
                        cacheControl: b.getResponseHeader("Cache-Control"),
                        expires: b.getResponseHeader("Expires")
                      })
                    } else {
                      const M = new Blob([b.response], {
                        type: b.getResponseHeader("Content-Type")
                      });
                      m(new se(b.status, b.statusText, n.url, M))
                    }
                }, c.signal.addEventListener("abort", (() => {
                  b.abort(), m(ge())
                })), b.send(n.body)
              }))
            })(i, t)
          };

        function Re(i) {
          if (!i || i.indexOf("://") <= 0 || i.indexOf("data:image/") === 0 || i.indexOf("blob:") === 0) return !0;
          const t = new URL(i),
            r = window.location;
          return t.protocol === r.protocol && t.host === r.host
        }

        function ne(i, t, r) {
          r[i] && r[i].indexOf(t) !== -1 || (r[i] = r[i] || [], r[i].push(t))
        }

        function oe(i, t, r) {
          if (r && r[i]) {
            const n = r[i].indexOf(t);
            n !== -1 && r[i].splice(n, 1)
          }
        }
        class fe {
          constructor(t, r = {}) {
            ht(this, r), this.type = t
          }
        }
        class ve extends fe {
          constructor(t, r = {}) {
            super("error", ht({
              error: t
            }, r))
          }
        }
        class ie {
          on(t, r) {
            return this._listeners = this._listeners || {}, ne(t, r, this._listeners), {
              unsubscribe: () => {
                this.off(t, r)
              }
            }
          }
          off(t, r) {
            return oe(t, r, this._listeners), oe(t, r, this._oneTimeListeners), this
          }
          once(t, r) {
            return r ? (this._oneTimeListeners = this._oneTimeListeners || {}, ne(t, r, this._oneTimeListeners), this) : new Promise((n => this.once(t, n)))
          }
          fire(t, r) {
            typeof t == "string" && (t = new fe(t, r || {}));
            const n = t.type;
            if (this.listens(n)) {
              t.target = this;
              const c = this._listeners && this._listeners[n] ? this._listeners[n].slice() : [];
              for (const v of c) v.call(this, t);
              const f = this._oneTimeListeners && this._oneTimeListeners[n] ? this._oneTimeListeners[n].slice() : [];
              for (const v of f) oe(n, v, this._oneTimeListeners), v.call(this, t);
              const m = this._eventedParent;
              m && (ht(t, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), m.fire(t))
            } else t instanceof ve && console.error(t.error);
            return this
          }
          listens(t) {
            return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t)
          }
          setEventedParent(t, r) {
            return this._eventedParent = t, this._eventedParentData = r, this
          }
        }
        var Y = {
          $version: 8,
          $root: {
            version: {
              required: !0,
              type: "enum",
              values: [8]
            },
            name: {
              type: "string"
            },
            metadata: {
              type: "*"
            },
            center: {
              type: "array",
              value: "number"
            },
            centerAltitude: {
              type: "number"
            },
            zoom: {
              type: "number"
            },
            bearing: {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees"
            },
            pitch: {
              type: "number",
              default: 0,
              units: "degrees"
            },
            roll: {
              type: "number",
              default: 0,
              units: "degrees"
            },
            state: {
              type: "state",
              default: {}
            },
            light: {
              type: "light"
            },
            sky: {
              type: "sky"
            },
            projection: {
              type: "projection"
            },
            terrain: {
              type: "terrain"
            },
            sources: {
              required: !0,
              type: "sources"
            },
            sprite: {
              type: "sprite"
            },
            glyphs: {
              type: "string"
            },
            "font-faces": {
              type: "array",
              value: "fontFaces"
            },
            transition: {
              type: "transition"
            },
            layers: {
              required: !0,
              type: "array",
              value: "layer"
            }
          },
          sources: {
            "*": {
              type: "source"
            }
          },
          source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"],
          source_vector: {
            type: {
              required: !0,
              type: "enum",
              values: {
                vector: {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            scheme: {
              type: "enum",
              values: {
                xyz: {},
                tms: {}
              },
              default: "xyz"
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            attribution: {
              type: "string"
            },
            promoteId: {
              type: "promoteId"
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            encoding: {
              type: "enum",
              values: {
                mvt: {},
                mlt: {}
              },
              default: "mvt"
            },
            "*": {
              type: "*"
            }
          },
          source_raster: {
            type: {
              required: !0,
              type: "enum",
              values: {
                raster: {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            tileSize: {
              type: "number",
              default: 512,
              units: "pixels"
            },
            scheme: {
              type: "enum",
              values: {
                xyz: {},
                tms: {}
              },
              default: "xyz"
            },
            attribution: {
              type: "string"
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            "*": {
              type: "*"
            }
          },
          source_raster_dem: {
            type: {
              required: !0,
              type: "enum",
              values: {
                "raster-dem": {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            tileSize: {
              type: "number",
              default: 512,
              units: "pixels"
            },
            attribution: {
              type: "string"
            },
            encoding: {
              type: "enum",
              values: {
                terrarium: {},
                mapbox: {},
                custom: {}
              },
              default: "mapbox"
            },
            redFactor: {
              type: "number",
              default: 1
            },
            blueFactor: {
              type: "number",
              default: 1
            },
            greenFactor: {
              type: "number",
              default: 1
            },
            baseShift: {
              type: "number",
              default: 0
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            "*": {
              type: "*"
            }
          },
          source_geojson: {
            type: {
              required: !0,
              type: "enum",
              values: {
                geojson: {}
              }
            },
            data: {
              required: !0,
              type: "*"
            },
            maxzoom: {
              type: "number",
              default: 18
            },
            attribution: {
              type: "string"
            },
            buffer: {
              type: "number",
              default: 128,
              maximum: 512,
              minimum: 0
            },
            filter: {
              type: "*"
            },
            tolerance: {
              type: "number",
              default: .375
            },
            cluster: {
              type: "boolean",
              default: !1
            },
            clusterRadius: {
              type: "number",
              default: 50,
              minimum: 0
            },
            clusterMaxZoom: {
              type: "number"
            },
            clusterMinPoints: {
              type: "number"
            },
            clusterProperties: {
              type: "*"
            },
            lineMetrics: {
              type: "boolean",
              default: !1
            },
            generateId: {
              type: "boolean",
              default: !1
            },
            promoteId: {
              type: "promoteId"
            }
          },
          source_video: {
            type: {
              required: !0,
              type: "enum",
              values: {
                video: {}
              }
            },
            urls: {
              required: !0,
              type: "array",
              value: "string"
            },
            coordinates: {
              required: !0,
              type: "array",
              length: 4,
              value: {
                type: "array",
                length: 2,
                value: "number"
              }
            }
          },
          source_image: {
            type: {
              required: !0,
              type: "enum",
              values: {
                image: {}
              }
            },
            url: {
              required: !0,
              type: "string"
            },
            coordinates: {
              required: !0,
              type: "array",
              length: 4,
              value: {
                type: "array",
                length: 2,
                value: "number"
              }
            }
          },
          layer: {
            id: {
              type: "string",
              required: !0
            },
            type: {
              type: "enum",
              values: {
                fill: {},
                line: {},
                symbol: {},
                circle: {},
                heatmap: {},
                "fill-extrusion": {},
                raster: {},
                hillshade: {},
                "color-relief": {},
                background: {}
              },
              required: !0
            },
            metadata: {
              type: "*"
            },
            source: {
              type: "string"
            },
            "source-layer": {
              type: "string"
            },
            minzoom: {
              type: "number",
              minimum: 0,
              maximum: 24
            },
            maxzoom: {
              type: "number",
              minimum: 0,
              maximum: 24
            },
            filter: {
              type: "filter"
            },
            layout: {
              type: "layout"
            },
            paint: {
              type: "paint"
            }
          },
          layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"],
          layout_background: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_fill: {
            "fill-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_circle: {
            "circle-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_heatmap: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          "layout_fill-extrusion": {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_line: {
            "line-cap": {
              type: "enum",
              values: {
                butt: {},
                round: {},
                square: {}
              },
              default: "butt",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-join": {
              type: "enum",
              values: {
                bevel: {},
                round: {},
                miter: {}
              },
              default: "miter",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "line-miter-limit": {
              type: "number",
              default: 2,
              requires: [{
                "line-join": "miter"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-round-limit": {
              type: "number",
              default: 1.05,
              requires: [{
                "line-join": "round"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_symbol: {
            "symbol-placement": {
              type: "enum",
              values: {
                point: {},
                line: {},
                "line-center": {}
              },
              default: "point",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-spacing": {
              type: "number",
              default: 250,
              minimum: 1,
              units: "pixels",
              requires: [{
                "symbol-placement": "line"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-avoid-edges": {
              type: "boolean",
              default: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "symbol-z-order": {
              type: "enum",
              values: {
                auto: {},
                "viewport-y": {},
                source: {}
              },
              default: "auto",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-allow-overlap": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", {
                "!": "icon-overlap"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-overlap": {
              type: "enum",
              values: {
                never: {},
                always: {},
                cooperative: {}
              },
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-ignore-placement": {
              type: "boolean",
              default: !1,
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-optional": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", "text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-rotation-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-size": {
              type: "number",
              default: 1,
              minimum: 0,
              units: "factor of the original icon size",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-text-fit": {
              type: "enum",
              values: {
                none: {},
                width: {},
                height: {},
                both: {}
              },
              default: "none",
              requires: ["icon-image", "text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-text-fit-padding": {
              type: "array",
              value: "number",
              length: 4,
              default: [0, 0, 0, 0],
              units: "pixels",
              requires: ["icon-image", "text-field", {
                "icon-text-fit": ["both", "width", "height"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-image": {
              type: "resolvedImage",
              tokens: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-rotate": {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-padding": {
              type: "padding",
              default: [2],
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-keep-upright": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", {
                "icon-rotation-alignment": "map"
              }, {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-offset": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-anchor": {
              type: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              default: "center",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-rotation-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                "viewport-glyph": {},
                auto: {}
              },
              default: "auto",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-field": {
              type: "formatted",
              default: "",
              tokens: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-font": {
              type: "array",
              value: "string",
              default: ["Open Sans Regular", "Arial Unicode MS Regular"],
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-size": {
              type: "number",
              default: 16,
              minimum: 0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-max-width": {
              type: "number",
              default: 10,
              minimum: 0,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-line-height": {
              type: "number",
              default: 1.2,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-letter-spacing": {
              type: "number",
              default: 0,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-justify": {
              type: "enum",
              values: {
                auto: {},
                left: {},
                center: {},
                right: {}
              },
              default: "center",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-radial-offset": {
              type: "number",
              units: "ems",
              default: 0,
              requires: ["text-field"],
              "property-type": "data-driven",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              }
            },
            "text-variable-anchor": {
              type: "array",
              value: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-variable-anchor-offset": {
              type: "variableAnchorOffsetCollection",
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-anchor": {
              type: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              default: "center",
              requires: ["text-field", {
                "!": "text-variable-anchor"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-max-angle": {
              type: "number",
              default: 45,
              units: "degrees",
              requires: ["text-field", {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-writing-mode": {
              type: "array",
              value: "enum",
              values: {
                horizontal: {},
                vertical: {}
              },
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-rotate": {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-padding": {
              type: "number",
              default: 2,
              minimum: 0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-keep-upright": {
              type: "boolean",
              default: !0,
              requires: ["text-field", {
                "text-rotation-alignment": "map"
              }, {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-transform": {
              type: "enum",
              values: {
                none: {},
                uppercase: {},
                lowercase: {}
              },
              default: "none",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-offset": {
              type: "array",
              value: "number",
              units: "ems",
              length: 2,
              default: [0, 0],
              requires: ["text-field", {
                "!": "text-radial-offset"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-allow-overlap": {
              type: "boolean",
              default: !1,
              requires: ["text-field", {
                "!": "text-overlap"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-overlap": {
              type: "enum",
              values: {
                never: {},
                always: {},
                cooperative: {}
              },
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-ignore-placement": {
              type: "boolean",
              default: !1,
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-optional": {
              type: "boolean",
              default: !1,
              requires: ["text-field", "icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_raster: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_hillshade: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          "layout_color-relief": {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          filter: {
            type: "array",
            value: "*"
          },
          filter_operator: {
            type: "enum",
            values: {
              "==": {},
              "!=": {},
              ">": {},
              ">=": {},
              "<": {},
              "<=": {},
              in: {},
              "!in": {},
              all: {},
              any: {},
              none: {},
              has: {},
              "!has": {}
            }
          },
          geometry_type: {
            type: "enum",
            values: {
              Point: {},
              LineString: {},
              Polygon: {}
            }
          },
          function: {
            expression: {
              type: "expression"
            },
            stops: {
              type: "array",
              value: "function_stop"
            },
            base: {
              type: "number",
              default: 1,
              minimum: 0
            },
            property: {
              type: "string",
              default: "$zoom"
            },
            type: {
              type: "enum",
              values: {
                identity: {},
                exponential: {},
                interval: {},
                categorical: {}
              },
              default: "exponential"
            },
            colorSpace: {
              type: "enum",
              values: {
                rgb: {},
                lab: {},
                hcl: {}
              },
              default: "rgb"
            },
            default: {
              type: "*",
              required: !1
            }
          },
          function_stop: {
            type: "array",
            minimum: 0,
            maximum: 24,
            value: ["number", "color"],
            length: 2
          },
          expression: {
            type: "array",
            value: "*",
            minimum: 1
          },
          light: {
            anchor: {
              type: "enum",
              default: "viewport",
              values: {
                map: {},
                viewport: {}
              },
              "property-type": "data-constant",
              transition: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              }
            },
            position: {
              type: "array",
              default: [1.15, 210, 30],
              length: 3,
              value: "number",
              "property-type": "data-constant",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              }
            },
            color: {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            intensity: {
              type: "number",
              "property-type": "data-constant",
              default: .5,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            }
          },
          sky: {
            "sky-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#88C6FC",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "horizon-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "fog-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "fog-ground-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .5,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "horizon-fog-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "sky-horizon-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "atmosphere-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            }
          },
          terrain: {
            source: {
              type: "string",
              required: !0
            },
            exaggeration: {
              type: "number",
              minimum: 0,
              default: 1
            }
          },
          projection: {
            type: {
              type: "projectionDefinition",
              default: "mercator",
              "property-type": "data-constant",
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              }
            }
          },
          paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"],
          paint_fill: {
            "fill-antialias": {
              type: "boolean",
              default: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "fill-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-outline-color": {
              type: "color",
              transition: !0,
              requires: [{
                "!": "fill-pattern"
              }, {
                "fill-antialias": !0
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["fill-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            }
          },
          "paint_fill-extrusion": {
            "fill-extrusion-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "fill-extrusion-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["fill-extrusion-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "fill-extrusion-height": {
              type: "number",
              default: 0,
              minimum: 0,
              units: "meters",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-base": {
              type: "number",
              default: 0,
              minimum: 0,
              units: "meters",
              transition: !0,
              requires: ["fill-extrusion-height"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-vertical-gradient": {
              type: "boolean",
              default: !0,
              transition: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_line: {
            "line-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "line-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["line-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-width": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-gap-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-offset": {
              type: "number",
              default: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-dasharray": {
              type: "array",
              value: "number",
              minimum: 0,
              transition: !0,
              units: "line widths",
              requires: [{
                "!": "line-pattern"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "line-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "line-gradient": {
              type: "color",
              transition: !1,
              requires: [{
                "!": "line-dasharray"
              }, {
                "!": "line-pattern"
              }, {
                source: "geojson",
                has: {
                  lineMetrics: !0
                }
              }],
              expression: {
                interpolated: !0,
                parameters: ["line-progress"]
              },
              "property-type": "color-ramp"
            }
          },
          paint_circle: {
            "circle-radius": {
              type: "number",
              default: 5,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-blur": {
              type: "number",
              default: 0,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["circle-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-pitch-scale": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "viewport",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-stroke-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-stroke-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-stroke-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            }
          },
          paint_heatmap: {
            "heatmap-radius": {
              type: "number",
              default: 30,
              minimum: 1,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "heatmap-weight": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "heatmap-intensity": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "heatmap-color": {
              type: "color",
              default: ["interpolate", ["linear"],
                ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", .1, "royalblue", .3, "cyan", .5, "lime", .7, "yellow", 1, "red"
              ],
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["heatmap-density"]
              },
              "property-type": "color-ramp"
            },
            "heatmap-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_symbol: {
            "icon-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-color": {
              type: "color",
              default: "rgba(0, 0, 0, 0)",
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["icon-image", "icon-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              overridable: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-color": {
              type: "color",
              default: "rgba(0, 0, 0, 0)",
              transition: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["text-field", "text-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_raster: {
            "raster-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-hue-rotate": {
              type: "number",
              default: 0,
              period: 360,
              transition: !0,
              units: "degrees",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-brightness-min": {
              type: "number",
              default: 0,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-brightness-max": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-saturation": {
              type: "number",
              default: 0,
              minimum: -1,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-contrast": {
              type: "number",
              default: 0,
              minimum: -1,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-resampling": {
              type: "enum",
              values: {
                linear: {},
                nearest: {}
              },
              default: "linear",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-fade-duration": {
              type: "number",
              default: 300,
              minimum: 0,
              transition: !1,
              units: "milliseconds",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_hillshade: {
            "hillshade-illumination-direction": {
              type: "numberArray",
              default: 335,
              minimum: 0,
              maximum: 359,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-illumination-altitude": {
              type: "numberArray",
              default: 45,
              minimum: 0,
              maximum: 90,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-illumination-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "viewport",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-exaggeration": {
              type: "number",
              default: .5,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-shadow-color": {
              type: "colorArray",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-highlight-color": {
              type: "colorArray",
              default: "#FFFFFF",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-accent-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-method": {
              type: "enum",
              values: {
                standard: {},
                basic: {},
                combined: {},
                igor: {},
                multidirectional: {}
              },
              default: "standard",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          "paint_color-relief": {
            "color-relief-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "color-relief-color": {
              type: "color",
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["elevation"]
              },
              "property-type": "color-ramp"
            }
          },
          paint_background: {
            "background-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "background-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "background-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "cross-faded"
            },
            "background-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          transition: {
            duration: {
              type: "number",
              default: 300,
              minimum: 0,
              units: "milliseconds"
            },
            delay: {
              type: "number",
              default: 0,
              minimum: 0,
              units: "milliseconds"
            }
          },
          "property-type": {
            "data-driven": {
              type: "property-type"
            },
            "cross-faded": {
              type: "property-type"
            },
            "cross-faded-data-driven": {
              type: "property-type"
            },
            "color-ramp": {
              type: "property-type"
            },
            "data-constant": {
              type: "property-type"
            },
            constant: {
              type: "property-type"
            }
          },
          promoteId: {
            "*": {
              type: "string"
            }
          }
        };
        const Fe = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];

        function Ne(i, t) {
          const r = {};
          for (const n in i) n !== "ref" && (r[n] = i[n]);
          return Fe.forEach((n => {
            n in t && (r[n] = t[n])
          })), r
        }

        function Ge(i, t) {
          if (Array.isArray(i)) {
            if (!Array.isArray(t) || i.length !== t.length) return !1;
            for (let r = 0; r < i.length; r++)
              if (!Ge(i[r], t[r])) return !1;
            return !0
          }
          if (typeof i == "object" && i !== null && t !== null) {
            if (typeof t != "object" || Object.keys(i).length !== Object.keys(t).length) return !1;
            for (const r in i)
              if (!Ge(i[r], t[r])) return !1;
            return !0
          }
          return i === t
        }

        function pe(i, t) {
          i.push(t)
        }

        function Ve(i, t, r) {
          pe(r, {
            command: "addSource",
            args: [i, t[i]]
          })
        }

        function it(i, t, r) {
          pe(t, {
            command: "removeSource",
            args: [i]
          }), r[i] = !0
        }

        function yt(i, t, r, n) {
          it(i, r, n), Ve(i, t, r)
        }

        function Lt(i, t, r) {
          let n;
          for (n in i[r])
            if (Object.prototype.hasOwnProperty.call(i[r], n) && n !== "data" && !Ge(i[r][n], t[r][n])) return !1;
          for (n in t[r])
            if (Object.prototype.hasOwnProperty.call(t[r], n) && n !== "data" && !Ge(i[r][n], t[r][n])) return !1;
          return !0
        }

        function ct(i, t, r, n, c, f) {
          i = i || {}, t = t || {};
          for (const m in i) Object.prototype.hasOwnProperty.call(i, m) && (Ge(i[m], t[m]) || r.push({
            command: f,
            args: [n, m, t[m], c]
          }));
          for (const m in t) Object.prototype.hasOwnProperty.call(t, m) && !Object.prototype.hasOwnProperty.call(i, m) && (Ge(i[m], t[m]) || r.push({
            command: f,
            args: [n, m, t[m], c]
          }))
        }

        function At(i) {
          return i.id
        }

        function qt(i, t) {
          return i[t.id] = t, i
        }
        class Ke {
          constructor(t, r, n, c) {
            this.message = (t ? `${t}: ` : "") + n, c && (this.identifier = c), r != null && r.__line__ && (this.line = r.__line__)
          }
        }

        function Tt(i, ...t) {
          for (const r of t)
            for (const n in r) i[n] = r[n];
          return i
        }
        class Wt extends Error {
          constructor(t, r) {
            super(r), this.message = r, this.key = t
          }
        }
        class Fr {
          constructor(t, r = []) {
            this.parent = t, this.bindings = {};
            for (const [n, c] of r) this.bindings[n] = c
          }
          concat(t) {
            return new Fr(this, t)
          }
          get(t) {
            if (this.bindings[t]) return this.bindings[t];
            if (this.parent) return this.parent.get(t);
            throw new Error(`${t} not found in scope.`)
          }
          has(t) {
            return !!this.bindings[t] || !!this.parent && this.parent.has(t)
          }
        }
        const or = {
            kind: "null"
          },
          tt = {
            kind: "number"
          },
          Ht = {
            kind: "string"
          },
          Qt = {
            kind: "boolean"
          },
          Sr = {
            kind: "color"
          },
          ei = {
            kind: "projectionDefinition"
          },
          li = {
            kind: "object"
          },
          Dr = {
            kind: "value"
          },
          Oi = {
            kind: "collator"
          },
          Jr = {
            kind: "formatted"
          },
          It = {
            kind: "padding"
          },
          er = {
            kind: "colorArray"
          },
          Pr = {
            kind: "numberArray"
          },
          pr = {
            kind: "resolvedImage"
          },
          qr = {
            kind: "variableAnchorOffsetCollection"
          };

        function ur(i, t) {
          return {
            kind: "array",
            itemType: i,
            N: t
          }
        }

        function Mr(i) {
          if (i.kind === "array") {
            const t = Mr(i.itemType);
            return typeof i.N == "number" ? `array<${t}, ${i.N}>` : i.itemType.kind === "value" ? "array" : `array<${t}>`
          }
          return i.kind
        }
        const di = [or, tt, Ht, Qt, Sr, ei, Jr, li, ur(Dr), It, Pr, er, pr, qr];

        function ti(i, t) {
          if (t.kind === "error") return null;
          if (i.kind === "array") {
            if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !ti(i.itemType, t.itemType)) && (typeof i.N != "number" || i.N === t.N)) return null
          } else {
            if (i.kind === t.kind) return null;
            if (i.kind === "value") {
              for (const r of di)
                if (!ti(r, t)) return null
            }
          }
          return `Expected ${Mr(i)} but found ${Mr(t)} instead.`
        }

        function Vr(i, t) {
          return t.some((r => r.kind === i.kind))
        }

        function Rr(i, t) {
          return t.some((r => r === "null" ? i === null : r === "array" ? Array.isArray(i) : r === "object" ? i && !Array.isArray(i) && typeof i == "object" : r === typeof i))
        }

        function ni(i, t) {
          return i.kind === "array" && t.kind === "array" ? i.itemType.kind === t.itemType.kind && typeof i.N == "number" : i.kind === t.kind
        }
        const Ri = .96422,
          qi = .82521,
          ai = 4 / 29,
          Pt = 6 / 29,
          tr = 3 * Pt * Pt,
          Br = Pt * Pt * Pt,
          Zr = Math.PI / 180,
          ci = 180 / Math.PI;

        function ui(i) {
          return (i %= 360) < 0 && (i += 360), i
        }

        function pt([i, t, r, n]) {
          let c, f;
          const m = dr((.2225045 * (i = kt(i)) + .7168786 * (t = kt(t)) + .0606169 * (r = kt(r))) / 1);
          i === t && t === r ? c = f = m : (c = dr((.4360747 * i + .3850649 * t + .1430804 * r) / Ri), f = dr((.0139322 * i + .0971045 * t + .7141733 * r) / qi));
          const v = 116 * m - 16;
          return [v < 0 ? 0 : v, 500 * (c - m), 200 * (m - f), n]
        }

        function kt(i) {
          return i <= .04045 ? i / 12.92 : Math.pow((i + .055) / 1.055, 2.4)
        }

        function dr(i) {
          return i > Br ? Math.pow(i, 1 / 3) : i / tr + ai
        }

        function pi([i, t, r, n]) {
          let c = (i + 16) / 116,
            f = isNaN(t) ? c : c + t / 500,
            m = isNaN(r) ? c : c - r / 200;
          return c = 1 * Ji(c), f = Ri * Ji(f), m = qi * Ji(m), [vi(3.1338561 * f - 1.6168667 * c - .4906146 * m), vi(-.9787684 * f + 1.9161415 * c + .033454 * m), vi(.0719453 * f - .2289914 * c + 1.4052427 * m), n]
        }

        function vi(i) {
          return (i = i <= .00304 ? 12.92 * i : 1.055 * Math.pow(i, 1 / 2.4) - .055) < 0 ? 0 : i > 1 ? 1 : i
        }

        function Ji(i) {
          return i > Pt ? i * i * i : tr * (i - ai)
        }
        const Zi = Object.hasOwn || function(i, t) {
          return Object.prototype.hasOwnProperty.call(i, t)
        };

        function Ei(i, t) {
          return Zi(i, t) ? i[t] : void 0
        }

        function ca(i) {
          return parseInt(i.padEnd(2, i), 16) / 255
        }

        function Ir(i, t) {
          return wr(t ? i / 100 : i, 0, 1)
        }

        function wr(i, t, r) {
          return Math.min(Math.max(t, i), r)
        }

        function Ai(i) {
          return !i.some(Number.isNaN)
        }
        const gi = {
          aliceblue: [240, 248, 255],
          antiquewhite: [250, 235, 215],
          aqua: [0, 255, 255],
          aquamarine: [127, 255, 212],
          azure: [240, 255, 255],
          beige: [245, 245, 220],
          bisque: [255, 228, 196],
          black: [0, 0, 0],
          blanchedalmond: [255, 235, 205],
          blue: [0, 0, 255],
          blueviolet: [138, 43, 226],
          brown: [165, 42, 42],
          burlywood: [222, 184, 135],
          cadetblue: [95, 158, 160],
          chartreuse: [127, 255, 0],
          chocolate: [210, 105, 30],
          coral: [255, 127, 80],
          cornflowerblue: [100, 149, 237],
          cornsilk: [255, 248, 220],
          crimson: [220, 20, 60],
          cyan: [0, 255, 255],
          darkblue: [0, 0, 139],
          darkcyan: [0, 139, 139],
          darkgoldenrod: [184, 134, 11],
          darkgray: [169, 169, 169],
          darkgreen: [0, 100, 0],
          darkgrey: [169, 169, 169],
          darkkhaki: [189, 183, 107],
          darkmagenta: [139, 0, 139],
          darkolivegreen: [85, 107, 47],
          darkorange: [255, 140, 0],
          darkorchid: [153, 50, 204],
          darkred: [139, 0, 0],
          darksalmon: [233, 150, 122],
          darkseagreen: [143, 188, 143],
          darkslateblue: [72, 61, 139],
          darkslategray: [47, 79, 79],
          darkslategrey: [47, 79, 79],
          darkturquoise: [0, 206, 209],
          darkviolet: [148, 0, 211],
          deeppink: [255, 20, 147],
          deepskyblue: [0, 191, 255],
          dimgray: [105, 105, 105],
          dimgrey: [105, 105, 105],
          dodgerblue: [30, 144, 255],
          firebrick: [178, 34, 34],
          floralwhite: [255, 250, 240],
          forestgreen: [34, 139, 34],
          fuchsia: [255, 0, 255],
          gainsboro: [220, 220, 220],
          ghostwhite: [248, 248, 255],
          gold: [255, 215, 0],
          goldenrod: [218, 165, 32],
          gray: [128, 128, 128],
          green: [0, 128, 0],
          greenyellow: [173, 255, 47],
          grey: [128, 128, 128],
          honeydew: [240, 255, 240],
          hotpink: [255, 105, 180],
          indianred: [205, 92, 92],
          indigo: [75, 0, 130],
          ivory: [255, 255, 240],
          khaki: [240, 230, 140],
          lavender: [230, 230, 250],
          lavenderblush: [255, 240, 245],
          lawngreen: [124, 252, 0],
          lemonchiffon: [255, 250, 205],
          lightblue: [173, 216, 230],
          lightcoral: [240, 128, 128],
          lightcyan: [224, 255, 255],
          lightgoldenrodyellow: [250, 250, 210],
          lightgray: [211, 211, 211],
          lightgreen: [144, 238, 144],
          lightgrey: [211, 211, 211],
          lightpink: [255, 182, 193],
          lightsalmon: [255, 160, 122],
          lightseagreen: [32, 178, 170],
          lightskyblue: [135, 206, 250],
          lightslategray: [119, 136, 153],
          lightslategrey: [119, 136, 153],
          lightsteelblue: [176, 196, 222],
          lightyellow: [255, 255, 224],
          lime: [0, 255, 0],
          limegreen: [50, 205, 50],
          linen: [250, 240, 230],
          magenta: [255, 0, 255],
          maroon: [128, 0, 0],
          mediumaquamarine: [102, 205, 170],
          mediumblue: [0, 0, 205],
          mediumorchid: [186, 85, 211],
          mediumpurple: [147, 112, 219],
          mediumseagreen: [60, 179, 113],
          mediumslateblue: [123, 104, 238],
          mediumspringgreen: [0, 250, 154],
          mediumturquoise: [72, 209, 204],
          mediumvioletred: [199, 21, 133],
          midnightblue: [25, 25, 112],
          mintcream: [245, 255, 250],
          mistyrose: [255, 228, 225],
          moccasin: [255, 228, 181],
          navajowhite: [255, 222, 173],
          navy: [0, 0, 128],
          oldlace: [253, 245, 230],
          olive: [128, 128, 0],
          olivedrab: [107, 142, 35],
          orange: [255, 165, 0],
          orangered: [255, 69, 0],
          orchid: [218, 112, 214],
          palegoldenrod: [238, 232, 170],
          palegreen: [152, 251, 152],
          paleturquoise: [175, 238, 238],
          palevioletred: [219, 112, 147],
          papayawhip: [255, 239, 213],
          peachpuff: [255, 218, 185],
          peru: [205, 133, 63],
          pink: [255, 192, 203],
          plum: [221, 160, 221],
          powderblue: [176, 224, 230],
          purple: [128, 0, 128],
          rebeccapurple: [102, 51, 153],
          red: [255, 0, 0],
          rosybrown: [188, 143, 143],
          royalblue: [65, 105, 225],
          saddlebrown: [139, 69, 19],
          salmon: [250, 128, 114],
          sandybrown: [244, 164, 96],
          seagreen: [46, 139, 87],
          seashell: [255, 245, 238],
          sienna: [160, 82, 45],
          silver: [192, 192, 192],
          skyblue: [135, 206, 235],
          slateblue: [106, 90, 205],
          slategray: [112, 128, 144],
          slategrey: [112, 128, 144],
          snow: [255, 250, 250],
          springgreen: [0, 255, 127],
          steelblue: [70, 130, 180],
          tan: [210, 180, 140],
          teal: [0, 128, 128],
          thistle: [216, 191, 216],
          tomato: [255, 99, 71],
          turquoise: [64, 224, 208],
          violet: [238, 130, 238],
          wheat: [245, 222, 179],
          white: [255, 255, 255],
          whitesmoke: [245, 245, 245],
          yellow: [255, 255, 0],
          yellowgreen: [154, 205, 50]
        };

        function Cr(i, t, r) {
          return i + r * (t - i)
        }

        function _i(i, t, r) {
          return i.map(((n, c) => Cr(n, t[c], r)))
        }
        class Ar {
          constructor(t, r, n, c = 1, f = !0) {
            this.r = t, this.g = r, this.b = n, this.a = c, f || (this.r *= c, this.g *= c, this.b *= c, c || this.overwriteGetter("rgb", [t, r, n, c]))
          }
          static parse(t) {
            if (t instanceof Ar) return t;
            if (typeof t != "string") return;
            const r = (function(n) {
              if ((n = n.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
              const c = Ei(gi, n);
              if (c) {
                const [m, v, b] = c;
                return [m / 255, v / 255, b / 255, 1]
              }
              if (n.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(n)) {
                const m = n.length < 6 ? 1 : 2;
                let v = 1;
                return [ca(n.slice(v, v += m)), ca(n.slice(v, v += m)), ca(n.slice(v, v += m)), ca(n.slice(v, v + m) || "ff")]
              }
              if (n.startsWith("rgb")) {
                const m = n.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (m) {
                  const [v, b, M, C, D, N, W, X, Q, le, we, et] = m, De = [C || " ", W || " ", le].join("");
                  if (De === "  " || De === "  /" || De === ",," || De === ",,,") {
                    const Ze = [M, N, Q].join(""),
                      mt = Ze === "%%%" ? 100 : Ze === "" ? 255 : 0;
                    if (mt) {
                      const Mt = [wr(+b / mt, 0, 1), wr(+D / mt, 0, 1), wr(+X / mt, 0, 1), we ? Ir(+we, et) : 1];
                      if (Ai(Mt)) return Mt
                    }
                  }
                  return
                }
              }
              const f = n.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (f) {
                const [m, v, b, M, C, D, N, W, X] = f, Q = [b || " ", C || " ", N].join("");
                if (Q === "  " || Q === "  /" || Q === ",," || Q === ",,,") {
                  const le = [+v, wr(+M, 0, 100), wr(+D, 0, 100), W ? Ir(+W, X) : 1];
                  if (Ai(le)) return (function([we, et, De, Ze]) {
                    function mt(Mt) {
                      const $t = (Mt + we / 30) % 12,
                        Tr = et * Math.min(De, 1 - De);
                      return De - Tr * Math.max(-1, Math.min($t - 3, 9 - $t, 1))
                    }
                    return we = ui(we), et /= 100, De /= 100, [mt(0), mt(8), mt(4), Ze]
                  })(le)
                }
              }
            })(t);
            return r ? new Ar(...r, !1) : void 0
          }
          get rgb() {
            const {
              r: t,
              g: r,
              b: n,
              a: c
            } = this, f = c || 1 / 0;
            return this.overwriteGetter("rgb", [t / f, r / f, n / f, c])
          }
          get hcl() {
            return this.overwriteGetter("hcl", (function(t) {
              const [r, n, c, f] = pt(t), m = Math.sqrt(n * n + c * c);
              return [Math.round(1e4 * m) ? ui(Math.atan2(c, n) * ci) : NaN, m, r, f]
            })(this.rgb))
          }
          get lab() {
            return this.overwriteGetter("lab", pt(this.rgb))
          }
          overwriteGetter(t, r) {
            return Object.defineProperty(this, t, {
              value: r
            }), r
          }
          toString() {
            const [t, r, n, c] = this.rgb;
            return `rgba(${[t,r,n].map((f=>Math.round(255*f))).join(",")},${c})`
          }
          static interpolate(t, r, n, c = "rgb") {
            switch (c) {
              case "rgb": {
                const [f, m, v, b] = _i(t.rgb, r.rgb, n);
                return new Ar(f, m, v, b, !1)
              }
              case "hcl": {
                const [f, m, v, b] = t.hcl, [M, C, D, N] = r.hcl;
                let W, X;
                if (isNaN(f) || isNaN(M)) isNaN(f) ? isNaN(M) ? W = NaN : (W = M, v !== 1 && v !== 0 || (X = C)) : (W = f, D !== 1 && D !== 0 || (X = m));
                else {
                  let De = M - f;
                  M > f && De > 180 ? De -= 360 : M < f && f - M > 180 && (De += 360), W = f + n * De
                }
                const [Q, le, we, et] = (function([De, Ze, mt, Mt]) {
                  return De = isNaN(De) ? 0 : De * Zr, pi([mt, Math.cos(De) * Ze, Math.sin(De) * Ze, Mt])
                })([W, X ?? Cr(m, C, n), Cr(v, D, n), Cr(b, N, n)]);
                return new Ar(Q, le, we, et, !1)
              }
              case "lab": {
                const [f, m, v, b] = pi(_i(t.lab, r.lab, n));
                return new Ar(f, m, v, b, !1)
              }
            }
          }
        }
        Ar.black = new Ar(0, 0, 0, 1), Ar.white = new Ar(1, 1, 1, 1), Ar.transparent = new Ar(0, 0, 0, 0), Ar.red = new Ar(1, 0, 0, 1);
        class ri {
          constructor(t, r, n) {
            this.sensitivity = t ? r ? "variant" : "case" : r ? "accent" : "base", this.locale = n, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
              sensitivity: this.sensitivity,
              usage: "search"
            })
          }
          compare(t, r) {
            return this.collator.compare(t, r)
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale
          }
        }
        const Xi = ["bottom", "center", "top"];
        class Vi {
          constructor(t, r, n, c, f, m) {
            this.text = t, this.image = r, this.scale = n, this.fontStack = c, this.textColor = f, this.verticalAlign = m
          }
        }
        class Di {
          constructor(t) {
            this.sections = t
          }
          static fromString(t) {
            return new Di([new Vi(t, null, null, null, null, null)])
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some((t => t.text.length !== 0 || t.image && t.image.name.length !== 0))
          }
          static factory(t) {
            return t instanceof Di ? t : Di.fromString(t)
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map((t => t.text)).join("")
          }
        }
        class ki {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof ki) return t;
            if (typeof t == "number") return new ki([t, t, t, t]);
            if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
              for (const r of t)
                if (typeof r != "number") return;
              switch (t.length) {
                case 1:
                  t = [t[0], t[0], t[0], t[0]];
                  break;
                case 2:
                  t = [t[0], t[1], t[0], t[1]];
                  break;
                case 3:
                  t = [t[0], t[1], t[2], t[1]]
              }
              return new ki(t)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, r, n) {
            return new ki(_i(t.values, r.values, n))
          }
        }
        class zi {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof zi) return t;
            if (typeof t == "number") return new zi([t]);
            if (Array.isArray(t)) {
              for (const r of t)
                if (typeof r != "number") return;
              return new zi(t)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, r, n) {
            return new zi(_i(t.values, r.values, n))
          }
        }
        class yi {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof yi) return t;
            if (typeof t == "string") {
              const n = Ar.parse(t);
              return n ? new yi([n]) : void 0
            }
            if (!Array.isArray(t)) return;
            const r = [];
            for (const n of t) {
              if (typeof n != "string") return;
              const c = Ar.parse(n);
              if (!c) return;
              r.push(c)
            }
            return new yi(r)
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, r, n, c = "rgb") {
            const f = [];
            if (t.values.length != r.values.length) throw new Error(`colorArray: Arrays have mismatched length (${t.values.length} vs. ${r.values.length}), cannot interpolate.`);
            for (let m = 0; m < t.values.length; m++) f.push(Ar.interpolate(t.values[m], r.values[m], n, c));
            return new yi(f)
          }
        }
        class fi extends Error {
          constructor(t) {
            super(t), this.name = "RuntimeError"
          }
          toJSON() {
            return this.message
          }
        }
        const tn = new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class Yi {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof Yi) return t;
            if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
              for (let r = 0; r < t.length; r += 2) {
                const n = t[r],
                  c = t[r + 1];
                if (typeof n != "string" || !tn.has(n) || !Array.isArray(c) || c.length !== 2 || typeof c[0] != "number" || typeof c[1] != "number") return
              }
              return new Yi(t)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, r, n) {
            const c = t.values,
              f = r.values;
            if (c.length !== f.length) throw new fi(`Cannot interpolate values of different length. from: ${t.toString()}, to: ${r.toString()}`);
            const m = [];
            for (let v = 0; v < c.length; v += 2) {
              if (c[v] !== f[v]) throw new fi(`Cannot interpolate values containing mismatched anchors. from[${v}]: ${c[v]}, to[${v}]: ${f[v]}`);
              m.push(c[v]);
              const [b, M] = c[v + 1], [C, D] = f[v + 1];
              m.push([Cr(b, C, n), Cr(M, D, n)])
            }
            return new Yi(m)
          }
        }
        class sa {
          constructor(t) {
            this.name = t.name, this.available = t.available
          }
          toString() {
            return this.name
          }
          static fromString(t) {
            return t ? new sa({
              name: t,
              available: !1
            }) : null
          }
        }
        class ua {
          constructor(t, r, n) {
            this.from = t, this.to = r, this.transition = n
          }
          static interpolate(t, r, n) {
            return new ua(t, r, n)
          }
          static parse(t) {
            return t instanceof ua ? t : Array.isArray(t) && t.length === 3 && typeof t[0] == "string" && typeof t[1] == "string" && typeof t[2] == "number" ? new ua(t[0], t[1], t[2]) : typeof t == "object" && typeof t.from == "string" && typeof t.to == "string" && typeof t.transition == "number" ? new ua(t.from, t.to, t.transition) : typeof t == "string" ? new ua(t, t, 1) : void 0
          }
        }

        function Da(i, t, r, n) {
          return typeof i == "number" && i >= 0 && i <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof r == "number" && r >= 0 && r <= 255 ? n === void 0 || typeof n == "number" && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[i,t,r,n].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof n=="number"?[i,t,r,n]:[i,t,r]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`
        }

        function Pa(i) {
          if (i === null || typeof i == "string" || typeof i == "boolean" || typeof i == "number" || i instanceof ua || i instanceof Ar || i instanceof ri || i instanceof Di || i instanceof ki || i instanceof zi || i instanceof yi || i instanceof Yi || i instanceof sa) return !0;
          if (Array.isArray(i)) {
            for (const t of i)
              if (!Pa(t)) return !1;
            return !0
          }
          if (typeof i == "object") {
            for (const t in i)
              if (!Pa(i[t])) return !1;
            return !0
          }
          return !1
        }

        function ea(i) {
          if (i === null) return or;
          if (typeof i == "string") return Ht;
          if (typeof i == "boolean") return Qt;
          if (typeof i == "number") return tt;
          if (i instanceof Ar) return Sr;
          if (i instanceof ua) return ei;
          if (i instanceof ri) return Oi;
          if (i instanceof Di) return Jr;
          if (i instanceof ki) return It;
          if (i instanceof zi) return Pr;
          if (i instanceof yi) return er;
          if (i instanceof Yi) return qr;
          if (i instanceof sa) return pr;
          if (Array.isArray(i)) {
            const t = i.length;
            let r;
            for (const n of i) {
              const c = ea(n);
              if (r) {
                if (r === c) continue;
                r = Dr;
                break
              }
              r = c
            }
            return ur(r || Dr, t)
          }
          return li
        }

        function pa(i) {
          const t = typeof i;
          return i === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(i) : i instanceof Ar || i instanceof ua || i instanceof Di || i instanceof ki || i instanceof zi || i instanceof yi || i instanceof Yi || i instanceof sa ? i.toString() : JSON.stringify(i)
        }
        class Ia {
          constructor(t, r) {
            this.type = t, this.value = r
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`'literal' expression requires exactly one argument, but found ${t.length-1} instead.`);
            if (!Pa(t[1])) return r.error("invalid value");
            const n = t[1];
            let c = ea(n);
            const f = r.expectedType;
            return c.kind !== "array" || c.N !== 0 || !f || f.kind !== "array" || typeof f.N == "number" && f.N !== 0 || (c = f), new Ia(c, n)
          }
          evaluate() {
            return this.value
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        const Na = {
          string: Ht,
          number: tt,
          boolean: Qt,
          object: li
        };
        class Mi {
          constructor(t, r) {
            this.type = t, this.args = r
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            let n, c = 1;
            const f = t[0];
            if (f === "array") {
              let v, b;
              if (t.length > 2) {
                const M = t[1];
                if (typeof M != "string" || !(M in Na) || M === "object") return r.error('The item type argument of "array" must be one of string, number, boolean', 1);
                v = Na[M], c++
              } else v = Dr;
              if (t.length > 3) {
                if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2]))) return r.error('The length argument to "array" must be a positive integer literal', 2);
                b = t[2], c++
              }
              n = ur(v, b)
            } else {
              if (!Na[f]) throw new Error(`Types doesn't contain name = ${f}`);
              n = Na[f]
            }
            const m = [];
            for (; c < t.length; c++) {
              const v = r.parse(t[c], c, Dr);
              if (!v) return null;
              m.push(v)
            }
            return new Mi(n, m)
          }
          evaluate(t) {
            for (let r = 0; r < this.args.length; r++) {
              const n = this.args[r].evaluate(t);
              if (!ti(this.type, ea(n))) return n;
              if (r === this.args.length - 1) throw new fi(`Expected value to be of type ${Mr(this.type)}, but found ${Mr(ea(n))} instead.`)
            }
            throw new Error
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return this.args.every((t => t.outputDefined()))
          }
        }
        const wn = {
          "to-boolean": Qt,
          "to-color": Sr,
          "to-number": tt,
          "to-string": Ht
        };
        class Ti {
          constructor(t, r) {
            this.type = t, this.args = r
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            const n = t[0];
            if (!wn[n]) throw new Error(`Can't parse ${n} as it is not part of the known types`);
            if ((n === "to-boolean" || n === "to-string") && t.length !== 2) return r.error("Expected one argument.");
            const c = wn[n],
              f = [];
            for (let m = 1; m < t.length; m++) {
              const v = r.parse(t[m], m, Dr);
              if (!v) return null;
              f.push(v)
            }
            return new Ti(c, f)
          }
          evaluate(t) {
            switch (this.type.kind) {
              case "boolean":
                return !!this.args[0].evaluate(t);
              case "color": {
                let r, n;
                for (const c of this.args) {
                  if (r = c.evaluate(t), n = null, r instanceof Ar) return r;
                  if (typeof r == "string") {
                    const f = t.parseColor(r);
                    if (f) return f
                  } else if (Array.isArray(r) && (n = r.length < 3 || r.length > 4 ? `Invalid rgba value ${JSON.stringify(r)}: expected an array containing either three or four numeric values.` : Da(r[0], r[1], r[2], r[3]), !n)) return new Ar(r[0] / 255, r[1] / 255, r[2] / 255, r[3])
                }
                throw new fi(n || `Could not parse color from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "padding": {
                let r;
                for (const n of this.args) {
                  r = n.evaluate(t);
                  const c = ki.parse(r);
                  if (c) return c
                }
                throw new fi(`Could not parse padding from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "numberArray": {
                let r;
                for (const n of this.args) {
                  r = n.evaluate(t);
                  const c = zi.parse(r);
                  if (c) return c
                }
                throw new fi(`Could not parse numberArray from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "colorArray": {
                let r;
                for (const n of this.args) {
                  r = n.evaluate(t);
                  const c = yi.parse(r);
                  if (c) return c
                }
                throw new fi(`Could not parse colorArray from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "variableAnchorOffsetCollection": {
                let r;
                for (const n of this.args) {
                  r = n.evaluate(t);
                  const c = Yi.parse(r);
                  if (c) return c
                }
                throw new fi(`Could not parse variableAnchorOffsetCollection from value '${typeof r=="string"?r:JSON.stringify(r)}'`)
              }
              case "number": {
                let r = null;
                for (const n of this.args) {
                  if (r = n.evaluate(t), r === null) return 0;
                  const c = Number(r);
                  if (!isNaN(c)) return c
                }
                throw new fi(`Could not convert ${JSON.stringify(r)} to number.`)
              }
              case "formatted":
                return Di.fromString(pa(this.args[0].evaluate(t)));
              case "resolvedImage":
                return sa.fromString(pa(this.args[0].evaluate(t)));
              case "projectionDefinition":
                return this.args[0].evaluate(t);
              default:
                return pa(this.args[0].evaluate(t))
            }
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return this.args.every((t => t.outputDefined()))
          }
        }
        const Si = ["Unknown", "Point", "LineString", "Polygon"];
        class Bn {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = new Map, this.availableImages = null, this.canonical = null
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? Si[this.feature.type] : this.feature.type : null
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null
          }
          canonicalID() {
            return this.canonical
          }
          properties() {
            return this.feature && this.feature.properties || {}
          }
          parseColor(t) {
            let r = this._parseColorCache.get(t);
            return r || (r = Ar.parse(t), this._parseColorCache.set(t, r)), r
          }
        }
        class Fi {
          constructor(t, r, n = [], c, f = new Fr, m = []) {
            this.registry = t, this.path = n, this.key = n.map((v => `[${v}]`)).join(""), this.scope = f, this.errors = m, this.expectedType = c, this._isConstant = r
          }
          parse(t, r, n, c, f = {}) {
            return r ? this.concat(r, n, c)._parse(t, f) : this._parse(t, f)
          }
          _parse(t, r) {
            function n(c, f, m) {
              return m === "assert" ? new Mi(f, [c]) : m === "coerce" ? new Ti(f, [c]) : c
            }
            if (t !== null && typeof t != "string" && typeof t != "boolean" && typeof t != "number" || (t = ["literal", t]), Array.isArray(t)) {
              if (t.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const c = t[0];
              if (typeof c != "string") return this.error(`Expression name must be a string, but found ${typeof c} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const f = this.registry[c];
              if (f) {
                let m = f.parse(t, this);
                if (!m) return null;
                if (this.expectedType) {
                  const v = this.expectedType,
                    b = m.type;
                  if (v.kind !== "string" && v.kind !== "number" && v.kind !== "boolean" && v.kind !== "object" && v.kind !== "array" || b.kind !== "value") {
                    if (v.kind === "projectionDefinition" && ["string", "array"].includes(b.kind) || ["color", "formatted", "resolvedImage"].includes(v.kind) && ["value", "string"].includes(b.kind) || ["padding", "numberArray"].includes(v.kind) && ["value", "number", "array"].includes(b.kind) || v.kind === "colorArray" && ["value", "string", "array"].includes(b.kind) || v.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(b.kind)) m = n(m, v, r.typeAnnotation || "coerce");
                    else if (this.checkSubtype(v, b)) return null
                  } else m = n(m, v, r.typeAnnotation || "assert")
                }
                if (!(m instanceof Ia) && m.type.kind !== "resolvedImage" && this._isConstant(m)) {
                  const v = new Bn;
                  try {
                    m = new Ia(m.type, m.evaluate(v))
                  } catch (b) {
                    return this.error(b.message), null
                  }
                }
                return m
              }
              return this.error(`Unknown expression "${c}". If you wanted a literal array, use ["literal", [...]].`, 0)
            }
            return this.error(t === void 0 ? "'undefined' value invalid. Use null instead." : typeof t == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`)
          }
          concat(t, r, n) {
            const c = typeof t == "number" ? this.path.concat(t) : this.path,
              f = n ? this.scope.concat(n) : this.scope;
            return new Fi(this.registry, this._isConstant, c, r || null, f, this.errors)
          }
          error(t, ...r) {
            const n = `${this.key}${r.map((c=>`[${c}]`)).join("")}`;
            this.errors.push(new Wt(n, t))
          }
          checkSubtype(t, r) {
            const n = ti(t, r);
            return n && this.error(n), n
          }
        }
        class On {
          constructor(t, r) {
            this.type = r.type, this.bindings = [].concat(t), this.result = r
          }
          evaluate(t) {
            return this.result.evaluate(t)
          }
          eachChild(t) {
            for (const r of this.bindings) t(r[1]);
            t(this.result)
          }
          static parse(t, r) {
            if (t.length < 4) return r.error(`Expected at least 3 arguments, but found ${t.length-1} instead.`);
            const n = [];
            for (let f = 1; f < t.length - 1; f += 2) {
              const m = t[f];
              if (typeof m != "string") return r.error(`Expected string, but found ${typeof m} instead.`, f);
              if (/[^a-zA-Z0-9_]/.test(m)) return r.error("Variable names must contain only alphanumeric characters or '_'.", f);
              const v = r.parse(t[f + 1], f + 1);
              if (!v) return null;
              n.push([m, v])
            }
            const c = r.parse(t[t.length - 1], t.length - 1, r.expectedType, n);
            return c ? new On(n, c) : null
          }
          outputDefined() {
            return this.result.outputDefined()
          }
        }
        class Va {
          constructor(t, r) {
            this.type = r.type, this.name = t, this.boundExpression = r
          }
          static parse(t, r) {
            if (t.length !== 2 || typeof t[1] != "string") return r.error("'var' expression requires exactly one string literal argument.");
            const n = t[1];
            return r.scope.has(n) ? new Va(n, r.scope.get(n)) : r.error(`Unknown variable "${n}". Make sure "${n}" has been bound in an enclosing "let" expression before using it.`, 1)
          }
          evaluate(t) {
            return this.boundExpression.evaluate(t)
          }
          eachChild() {}
          outputDefined() {
            return !1
          }
        }
        class es {
          constructor(t, r, n) {
            this.type = t, this.index = r, this.input = n
          }
          static parse(t, r) {
            if (t.length !== 3) return r.error(`Expected 2 arguments, but found ${t.length-1} instead.`);
            const n = r.parse(t[1], 1, tt),
              c = r.parse(t[2], 2, ur(r.expectedType || Dr));
            return n && c ? new es(c.type.itemType, n, c) : null
          }
          evaluate(t) {
            const r = this.index.evaluate(t),
              n = this.input.evaluate(t);
            if (r < 0) throw new fi(`Array index out of bounds: ${r} < 0.`);
            if (r >= n.length) throw new fi(`Array index out of bounds: ${r} > ${n.length-1}.`);
            if (r !== Math.floor(r)) throw new fi(`Array index must be an integer, but found ${r} instead.`);
            return n[r]
          }
          eachChild(t) {
            t(this.index), t(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        class jn {
          constructor(t, r) {
            this.type = Qt, this.needle = t, this.haystack = r
          }
          static parse(t, r) {
            if (t.length !== 3) return r.error(`Expected 2 arguments, but found ${t.length-1} instead.`);
            const n = r.parse(t[1], 1, Dr),
              c = r.parse(t[2], 2, Dr);
            return n && c ? Vr(n.type, [Qt, Ht, tt, or, Dr]) ? new jn(n, c) : r.error(`Expected first argument to be of type boolean, string, number or null, but found ${Mr(n.type)} instead`) : null
          }
          evaluate(t) {
            const r = this.needle.evaluate(t),
              n = this.haystack.evaluate(t);
            if (!n) return !1;
            if (!Rr(r, ["boolean", "string", "number", "null"])) throw new fi(`Expected first argument to be of type boolean, string, number or null, but found ${Mr(ea(r))} instead.`);
            if (!Rr(n, ["string", "array"])) throw new fi(`Expected second argument to be of type array or string, but found ${Mr(ea(n))} instead.`);
            return n.indexOf(r) >= 0
          }
          eachChild(t) {
            t(this.needle), t(this.haystack)
          }
          outputDefined() {
            return !0
          }
        }
        class Tn {
          constructor(t, r, n) {
            this.type = tt, this.needle = t, this.haystack = r, this.fromIndex = n
          }
          static parse(t, r) {
            if (t.length <= 2 || t.length >= 5) return r.error(`Expected 2 or 3 arguments, but found ${t.length-1} instead.`);
            const n = r.parse(t[1], 1, Dr),
              c = r.parse(t[2], 2, Dr);
            if (!n || !c) return null;
            if (!Vr(n.type, [Qt, Ht, tt, or, Dr])) return r.error(`Expected first argument to be of type boolean, string, number or null, but found ${Mr(n.type)} instead`);
            if (t.length === 4) {
              const f = r.parse(t[3], 3, tt);
              return f ? new Tn(n, c, f) : null
            }
            return new Tn(n, c)
          }
          evaluate(t) {
            const r = this.needle.evaluate(t),
              n = this.haystack.evaluate(t);
            if (!Rr(r, ["boolean", "string", "number", "null"])) throw new fi(`Expected first argument to be of type boolean, string, number or null, but found ${Mr(ea(r))} instead.`);
            let c;
            if (this.fromIndex && (c = this.fromIndex.evaluate(t)), Rr(n, ["string"])) {
              const f = n.indexOf(r, c);
              return f === -1 ? -1 : [...n.slice(0, f)].length
            }
            if (Rr(n, ["array"])) return n.indexOf(r, c);
            throw new fi(`Expected second argument to be of type array or string, but found ${Mr(ea(n))} instead.`)
          }
          eachChild(t) {
            t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex)
          }
          outputDefined() {
            return !1
          }
        }
        class os {
          constructor(t, r, n, c, f, m) {
            this.inputType = t, this.type = r, this.input = n, this.cases = c, this.outputs = f, this.otherwise = m
          }
          static parse(t, r) {
            if (t.length < 5) return r.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
            if (t.length % 2 != 1) return r.error("Expected an even number of arguments.");
            let n, c;
            r.expectedType && r.expectedType.kind !== "value" && (c = r.expectedType);
            const f = {},
              m = [];
            for (let M = 2; M < t.length - 1; M += 2) {
              let C = t[M];
              const D = t[M + 1];
              Array.isArray(C) || (C = [C]);
              const N = r.concat(M);
              if (C.length === 0) return N.error("Expected at least one branch label.");
              for (const X of C) {
                if (typeof X != "number" && typeof X != "string") return N.error("Branch labels must be numbers or strings.");
                if (typeof X == "number" && Math.abs(X) > Number.MAX_SAFE_INTEGER) return N.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof X == "number" && Math.floor(X) !== X) return N.error("Numeric branch labels must be integer values.");
                if (n) {
                  if (N.checkSubtype(n, ea(X))) return null
                } else n = ea(X);
                if (f[String(X)] !== void 0) return N.error("Branch labels must be unique.");
                f[String(X)] = m.length
              }
              const W = r.parse(D, M, c);
              if (!W) return null;
              c = c || W.type, m.push(W)
            }
            const v = r.parse(t[1], 1, Dr);
            if (!v) return null;
            const b = r.parse(t[t.length - 1], t.length - 1, c);
            return b ? v.type.kind !== "value" && r.concat(1).checkSubtype(n, v.type) ? null : new os(n, c, v, f, m, b) : null
          }
          evaluate(t) {
            const r = this.input.evaluate(t);
            return (ea(r) === this.inputType && this.outputs[this.cases[r]] || this.otherwise).evaluate(t)
          }
          eachChild(t) {
            t(this.input), this.outputs.forEach(t), t(this.otherwise)
          }
          outputDefined() {
            return this.outputs.every((t => t.outputDefined())) && this.otherwise.outputDefined()
          }
        }
        class qn {
          constructor(t, r, n) {
            this.type = t, this.branches = r, this.otherwise = n
          }
          static parse(t, r) {
            if (t.length < 4) return r.error(`Expected at least 3 arguments, but found only ${t.length-1}.`);
            if (t.length % 2 != 0) return r.error("Expected an odd number of arguments.");
            let n;
            r.expectedType && r.expectedType.kind !== "value" && (n = r.expectedType);
            const c = [];
            for (let m = 1; m < t.length - 1; m += 2) {
              const v = r.parse(t[m], m, Qt);
              if (!v) return null;
              const b = r.parse(t[m + 1], m + 1, n);
              if (!b) return null;
              c.push([v, b]), n = n || b.type
            }
            const f = r.parse(t[t.length - 1], t.length - 1, n);
            if (!f) return null;
            if (!n) throw new Error("Can't infer output type");
            return new qn(n, c, f)
          }
          evaluate(t) {
            for (const [r, n] of this.branches)
              if (r.evaluate(t)) return n.evaluate(t);
            return this.otherwise.evaluate(t)
          }
          eachChild(t) {
            for (const [r, n] of this.branches) t(r), t(n);
            t(this.otherwise)
          }
          outputDefined() {
            return this.branches.every((([t, r]) => r.outputDefined())) && this.otherwise.outputDefined()
          }
        }
        class ts {
          constructor(t, r, n, c) {
            this.type = t, this.input = r, this.beginIndex = n, this.endIndex = c
          }
          static parse(t, r) {
            if (t.length <= 2 || t.length >= 5) return r.error(`Expected 2 or 3 arguments, but found ${t.length-1} instead.`);
            const n = r.parse(t[1], 1, Dr),
              c = r.parse(t[2], 2, tt);
            if (!n || !c) return null;
            if (!Vr(n.type, [ur(Dr), Ht, Dr])) return r.error(`Expected first argument to be of type array or string, but found ${Mr(n.type)} instead`);
            if (t.length === 4) {
              const f = r.parse(t[3], 3, tt);
              return f ? new ts(n.type, n, c, f) : null
            }
            return new ts(n.type, n, c)
          }
          evaluate(t) {
            const r = this.input.evaluate(t),
              n = this.beginIndex.evaluate(t);
            let c;
            if (this.endIndex && (c = this.endIndex.evaluate(t)), Rr(r, ["string"])) return [...r].slice(n, c).join("");
            if (Rr(r, ["array"])) return r.slice(n, c);
            throw new fi(`Expected first argument to be of type array or string, but found ${Mr(ea(r))} instead.`)
          }
          eachChild(t) {
            t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex)
          }
          outputDefined() {
            return !1
          }
        }

        function fa(i, t) {
          const r = i.length - 1;
          let n, c, f = 0,
            m = r,
            v = 0;
          for (; f <= m;)
            if (v = Math.floor((f + m) / 2), n = i[v], c = i[v + 1], n <= t) {
              if (v === r || t < c) return v;
              f = v + 1
            } else {
              if (!(n > t)) throw new fi("Input is not a number.");
              m = v - 1
            } return 0
        }
        class Ma {
          constructor(t, r, n) {
            this.type = t, this.input = r, this.labels = [], this.outputs = [];
            for (const [c, f] of n) this.labels.push(c), this.outputs.push(f)
          }
          static parse(t, r) {
            if (t.length - 1 < 4) return r.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
            if ((t.length - 1) % 2 != 0) return r.error("Expected an even number of arguments.");
            const n = r.parse(t[1], 1, tt);
            if (!n) return null;
            const c = [];
            let f = null;
            r.expectedType && r.expectedType.kind !== "value" && (f = r.expectedType);
            for (let m = 1; m < t.length; m += 2) {
              const v = m === 1 ? -1 / 0 : t[m],
                b = t[m + 1],
                M = m,
                C = m + 1;
              if (typeof v != "number") return r.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', M);
              if (c.length && c[c.length - 1][0] >= v) return r.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', M);
              const D = r.parse(b, C, f);
              if (!D) return null;
              f = f || D.type, c.push([v, D])
            }
            return new Ma(f, n, c)
          }
          evaluate(t) {
            const r = this.labels,
              n = this.outputs;
            if (r.length === 1) return n[0].evaluate(t);
            const c = this.input.evaluate(t);
            if (c <= r[0]) return n[0].evaluate(t);
            const f = r.length;
            return c >= r[f - 1] ? n[f - 1].evaluate(t) : n[fa(r, c)].evaluate(t)
          }
          eachChild(t) {
            t(this.input);
            for (const r of this.outputs) t(r)
          }
          outputDefined() {
            return this.outputs.every((t => t.outputDefined()))
          }
        }

        function pn(i) {
          return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i
        }
        var ma, Nn, Bs = (function() {
            if (Nn) return ma;

            function i(t, r, n, c) {
              this.cx = 3 * t, this.bx = 3 * (n - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * r, this.by = 3 * (c - r) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = r, this.p2x = n, this.p2y = c
            }
            return Nn = 1, ma = i, i.prototype = {
              sampleCurveX: function(t) {
                return ((this.ax * t + this.bx) * t + this.cx) * t
              },
              sampleCurveY: function(t) {
                return ((this.ay * t + this.by) * t + this.cy) * t
              },
              sampleCurveDerivativeX: function(t) {
                return (3 * this.ax * t + 2 * this.bx) * t + this.cx
              },
              solveCurveX: function(t, r) {
                if (r === void 0 && (r = 1e-6), t < 0) return 0;
                if (t > 1) return 1;
                for (var n = t, c = 0; c < 8; c++) {
                  var f = this.sampleCurveX(n) - t;
                  if (Math.abs(f) < r) return n;
                  var m = this.sampleCurveDerivativeX(n);
                  if (Math.abs(m) < 1e-6) break;
                  n -= f / m
                }
                var v = 0,
                  b = 1;
                for (n = t, c = 0; c < 20 && (f = this.sampleCurveX(n), !(Math.abs(f - t) < r)); c++) t > f ? v = n : b = n, n = .5 * (b - v) + v;
                return n
              },
              solve: function(t, r) {
                return this.sampleCurveY(this.solveCurveX(t, r))
              }
            }, ma
          })(),
          yo = pn(Bs);
        class Ki {
          constructor(t, r, n, c, f) {
            this.type = t, this.operator = r, this.interpolation = n, this.input = c, this.labels = [], this.outputs = [];
            for (const [m, v] of f) this.labels.push(m), this.outputs.push(v)
          }
          static interpolationFactor(t, r, n, c) {
            let f = 0;
            if (t.name === "exponential") f = Pl(r, t.base, n, c);
            else if (t.name === "linear") f = Pl(r, 1, n, c);
            else if (t.name === "cubic-bezier") {
              const m = t.controlPoints;
              f = new yo(m[0], m[1], m[2], m[3]).solve(Pl(r, 1, n, c))
            }
            return f
          }
          static parse(t, r) {
            let [n, c, f, ...m] = t;
            if (!Array.isArray(c) || c.length === 0) return r.error("Expected an interpolation type expression.", 1);
            if (c[0] === "linear") c = {
              name: "linear"
            };
            else if (c[0] === "exponential") {
              const M = c[1];
              if (typeof M != "number") return r.error("Exponential interpolation requires a numeric base.", 1, 1);
              c = {
                name: "exponential",
                base: M
              }
            } else {
              if (c[0] !== "cubic-bezier") return r.error(`Unknown interpolation type ${String(c[0])}`, 1, 0);
              {
                const M = c.slice(1);
                if (M.length !== 4 || M.some((C => typeof C != "number" || C < 0 || C > 1))) return r.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                c = {
                  name: "cubic-bezier",
                  controlPoints: M
                }
              }
            }
            if (t.length - 1 < 4) return r.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
            if ((t.length - 1) % 2 != 0) return r.error("Expected an even number of arguments.");
            if (f = r.parse(f, 2, tt), !f) return null;
            const v = [];
            let b = null;
            n !== "interpolate-hcl" && n !== "interpolate-lab" || r.expectedType == er ? r.expectedType && r.expectedType.kind !== "value" && (b = r.expectedType) : b = Sr;
            for (let M = 0; M < m.length; M += 2) {
              const C = m[M],
                D = m[M + 1],
                N = M + 3,
                W = M + 4;
              if (typeof C != "number") return r.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', N);
              if (v.length && v[v.length - 1][0] >= C) return r.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', N);
              const X = r.parse(D, W, b);
              if (!X) return null;
              b = b || X.type, v.push([C, X])
            }
            return ni(b, tt) || ni(b, ei) || ni(b, Sr) || ni(b, It) || ni(b, Pr) || ni(b, er) || ni(b, qr) || ni(b, ur(tt)) ? new Ki(b, n, c, f, v) : r.error(`Type ${Mr(b)} is not interpolatable.`)
          }
          evaluate(t) {
            const r = this.labels,
              n = this.outputs;
            if (r.length === 1) return n[0].evaluate(t);
            const c = this.input.evaluate(t);
            if (c <= r[0]) return n[0].evaluate(t);
            const f = r.length;
            if (c >= r[f - 1]) return n[f - 1].evaluate(t);
            const m = fa(r, c),
              v = Ki.interpolationFactor(this.interpolation, c, r[m], r[m + 1]),
              b = n[m].evaluate(t),
              M = n[m + 1].evaluate(t);
            switch (this.operator) {
              case "interpolate":
                switch (this.type.kind) {
                  case "number":
                    return Cr(b, M, v);
                  case "color":
                    return Ar.interpolate(b, M, v);
                  case "padding":
                    return ki.interpolate(b, M, v);
                  case "colorArray":
                    return yi.interpolate(b, M, v);
                  case "numberArray":
                    return zi.interpolate(b, M, v);
                  case "variableAnchorOffsetCollection":
                    return Yi.interpolate(b, M, v);
                  case "array":
                    return _i(b, M, v);
                  case "projectionDefinition":
                    return ua.interpolate(b, M, v)
                }
              case "interpolate-hcl":
                switch (this.type.kind) {
                  case "color":
                    return Ar.interpolate(b, M, v, "hcl");
                  case "colorArray":
                    return yi.interpolate(b, M, v, "hcl")
                }
              case "interpolate-lab":
                switch (this.type.kind) {
                  case "color":
                    return Ar.interpolate(b, M, v, "lab");
                  case "colorArray":
                    return yi.interpolate(b, M, v, "lab")
                }
            }
          }
          eachChild(t) {
            t(this.input);
            for (const r of this.outputs) t(r)
          }
          outputDefined() {
            return this.outputs.every((t => t.outputDefined()))
          }
        }

        function Pl(i, t, r, n) {
          const c = n - r,
            f = i - r;
          return c === 0 ? 0 : t === 1 ? f / c : (Math.pow(t, f) - 1) / (Math.pow(t, c) - 1)
        }
        const En = {
          color: Ar.interpolate,
          number: Cr,
          padding: ki.interpolate,
          numberArray: zi.interpolate,
          colorArray: yi.interpolate,
          variableAnchorOffsetCollection: Yi.interpolate,
          array: _i
        };
        class Uo {
          constructor(t, r) {
            this.type = t, this.args = r
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            let n = null;
            const c = r.expectedType;
            c && c.kind !== "value" && (n = c);
            const f = [];
            for (const v of t.slice(1)) {
              const b = r.parse(v, 1 + f.length, n, void 0, {
                typeAnnotation: "omit"
              });
              if (!b) return null;
              n = n || b.type, f.push(b)
            }
            if (!n) throw new Error("No output type");
            const m = c && f.some((v => ti(c, v.type)));
            return new Uo(m ? Dr : n, f)
          }
          evaluate(t) {
            let r, n = null,
              c = 0;
            for (const f of this.args)
              if (c++, n = f.evaluate(t), n && n instanceof sa && !n.available && (r || (r = n.name), n = null, c === this.args.length && (n = r)), n !== null) break;
            return n
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return this.args.every((t => t.outputDefined()))
          }
        }

        function Oh(i, t) {
          return i === "==" || i === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value"
        }

        function Os(i, t, r, n) {
          return n.compare(t, r) === 0
        }

        function ls(i, t, r) {
          const n = i !== "==" && i !== "!=";
          return class G0 {
            constructor(f, m, v) {
              this.type = Qt, this.lhs = f, this.rhs = m, this.collator = v, this.hasUntypedArgument = f.type.kind === "value" || m.type.kind === "value"
            }
            static parse(f, m) {
              if (f.length !== 3 && f.length !== 4) return m.error("Expected two or three arguments.");
              const v = f[0];
              let b = m.parse(f[1], 1, Dr);
              if (!b) return null;
              if (!Oh(v, b.type)) return m.concat(1).error(`"${v}" comparisons are not supported for type '${Mr(b.type)}'.`);
              let M = m.parse(f[2], 2, Dr);
              if (!M) return null;
              if (!Oh(v, M.type)) return m.concat(2).error(`"${v}" comparisons are not supported for type '${Mr(M.type)}'.`);
              if (b.type.kind !== M.type.kind && b.type.kind !== "value" && M.type.kind !== "value") return m.error(`Cannot compare types '${Mr(b.type)}' and '${Mr(M.type)}'.`);
              n && (b.type.kind === "value" && M.type.kind !== "value" ? b = new Mi(M.type, [b]) : b.type.kind !== "value" && M.type.kind === "value" && (M = new Mi(b.type, [M])));
              let C = null;
              if (f.length === 4) {
                if (b.type.kind !== "string" && M.type.kind !== "string" && b.type.kind !== "value" && M.type.kind !== "value") return m.error("Cannot use collator to compare non-string types.");
                if (C = m.parse(f[3], 3, Oi), !C) return null
              }
              return new G0(b, M, C)
            }
            evaluate(f) {
              const m = this.lhs.evaluate(f),
                v = this.rhs.evaluate(f);
              if (n && this.hasUntypedArgument) {
                const b = ea(m),
                  M = ea(v);
                if (b.kind !== M.kind || b.kind !== "string" && b.kind !== "number") throw new fi(`Expected arguments for "${i}" to be (string, string) or (number, number), but found (${b.kind}, ${M.kind}) instead.`)
              }
              if (this.collator && !n && this.hasUntypedArgument) {
                const b = ea(m),
                  M = ea(v);
                if (b.kind !== "string" || M.kind !== "string") return t(f, m, v)
              }
              return this.collator ? r(f, m, v, this.collator.evaluate(f)) : t(f, m, v)
            }
            eachChild(f) {
              f(this.lhs), f(this.rhs), this.collator && f(this.collator)
            }
            outputDefined() {
              return !0
            }
          }
        }
        const jc = ls("==", (function(i, t, r) {
            return t === r
          }), Os),
          Zp = ls("!=", (function(i, t, r) {
            return t !== r
          }), (function(i, t, r, n) {
            return !Os(0, t, r, n)
          })),
          jh = ls("<", (function(i, t, r) {
            return t < r
          }), (function(i, t, r, n) {
            return n.compare(t, r) < 0
          })),
          Il = ls(">", (function(i, t, r) {
            return t > r
          }), (function(i, t, r, n) {
            return n.compare(t, r) > 0
          })),
          Ml = ls("<=", (function(i, t, r) {
            return t <= r
          }), (function(i, t, r, n) {
            return n.compare(t, r) <= 0
          })),
          Vn = ls(">=", (function(i, t, r) {
            return t >= r
          }), (function(i, t, r, n) {
            return n.compare(t, r) >= 0
          }));
        class Zo {
          constructor(t, r, n) {
            this.type = Oi, this.locale = n, this.caseSensitive = t, this.diacriticSensitive = r
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error("Expected one argument.");
            const n = t[1];
            if (typeof n != "object" || Array.isArray(n)) return r.error("Collator options argument must be an object.");
            const c = r.parse(n["case-sensitive"] !== void 0 && n["case-sensitive"], 1, Qt);
            if (!c) return null;
            const f = r.parse(n["diacritic-sensitive"] !== void 0 && n["diacritic-sensitive"], 1, Qt);
            if (!f) return null;
            let m = null;
            return n.locale && (m = r.parse(n.locale, 1, Ht), !m) ? null : new Zo(c, f, m)
          }
          evaluate(t) {
            return new ri(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null)
          }
          eachChild(t) {
            t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale)
          }
          outputDefined() {
            return !1
          }
        }
        class xo {
          constructor(t, r, n, c, f) {
            this.type = Ht, this.number = t, this.locale = r, this.currency = n, this.minFractionDigits = c, this.maxFractionDigits = f
          }
          static parse(t, r) {
            if (t.length !== 3) return r.error("Expected two arguments.");
            const n = r.parse(t[1], 1, tt);
            if (!n) return null;
            const c = t[2];
            if (typeof c != "object" || Array.isArray(c)) return r.error("NumberFormat options argument must be an object.");
            let f = null;
            if (c.locale && (f = r.parse(c.locale, 1, Ht), !f)) return null;
            let m = null;
            if (c.currency && (m = r.parse(c.currency, 1, Ht), !m)) return null;
            let v = null;
            if (c["min-fraction-digits"] && (v = r.parse(c["min-fraction-digits"], 1, tt), !v)) return null;
            let b = null;
            return c["max-fraction-digits"] && (b = r.parse(c["max-fraction-digits"], 1, tt), !b) ? null : new xo(n, f, m, v, b)
          }
          evaluate(t) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], {
              style: this.currency ? "currency" : "decimal",
              currency: this.currency ? this.currency.evaluate(t) : void 0,
              minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,
              maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0
            }).format(this.number.evaluate(t))
          }
          eachChild(t) {
            t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits)
          }
          outputDefined() {
            return !1
          }
        }
        class Cl {
          constructor(t) {
            this.type = Jr, this.sections = t
          }
          static parse(t, r) {
            if (t.length < 2) return r.error("Expected at least one argument.");
            const n = t[1];
            if (!Array.isArray(n) && typeof n == "object") return r.error("First argument must be an image or text section.");
            const c = [];
            let f = !1;
            for (let m = 1; m <= t.length - 1; ++m) {
              const v = t[m];
              if (f && typeof v == "object" && !Array.isArray(v)) {
                f = !1;
                let b = null;
                if (v["font-scale"] && (b = r.parse(v["font-scale"], 1, tt), !b)) return null;
                let M = null;
                if (v["text-font"] && (M = r.parse(v["text-font"], 1, ur(Ht)), !M)) return null;
                let C = null;
                if (v["text-color"] && (C = r.parse(v["text-color"], 1, Sr), !C)) return null;
                let D = null;
                if (v["vertical-align"]) {
                  if (typeof v["vertical-align"] == "string" && !Xi.includes(v["vertical-align"])) return r.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${v["vertical-align"]}' instead.`);
                  if (D = r.parse(v["vertical-align"], 1, Ht), !D) return null
                }
                const N = c[c.length - 1];
                N.scale = b, N.font = M, N.textColor = C, N.verticalAlign = D
              } else {
                const b = r.parse(t[m], 1, Dr);
                if (!b) return null;
                const M = b.type.kind;
                if (M !== "string" && M !== "value" && M !== "null" && M !== "resolvedImage") return r.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                f = !0, c.push({
                  content: b,
                  scale: null,
                  font: null,
                  textColor: null,
                  verticalAlign: null
                })
              }
            }
            return new Cl(c)
          }
          evaluate(t) {
            return new Di(this.sections.map((r => {
              const n = r.content.evaluate(t);
              return ea(n) === pr ? new Vi("", n, null, null, null, r.verticalAlign ? r.verticalAlign.evaluate(t) : null) : new Vi(pa(n), null, r.scale ? r.scale.evaluate(t) : null, r.font ? r.font.evaluate(t).join(",") : null, r.textColor ? r.textColor.evaluate(t) : null, r.verticalAlign ? r.verticalAlign.evaluate(t) : null)
            })))
          }
          eachChild(t) {
            for (const r of this.sections) t(r.content), r.scale && t(r.scale), r.font && t(r.font), r.textColor && t(r.textColor), r.verticalAlign && t(r.verticalAlign)
          }
          outputDefined() {
            return !1
          }
        }
        class Go {
          constructor(t) {
            this.type = pr, this.input = t
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error("Expected two arguments.");
            const n = r.parse(t[1], 1, Ht);
            return n ? new Go(n) : r.error("No image name provided.")
          }
          evaluate(t) {
            const r = this.input.evaluate(t),
              n = sa.fromString(r);
            return n && t.availableImages && (n.available = t.availableImages.indexOf(r) > -1), n
          }
          eachChild(t) {
            t(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        class qc {
          constructor(t) {
            this.type = tt, this.input = t
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`Expected 1 argument, but found ${t.length-1} instead.`);
            const n = r.parse(t[1], 1);
            return n ? n.type.kind !== "array" && n.type.kind !== "string" && n.type.kind !== "value" ? r.error(`Expected argument of type string or array, but found ${Mr(n.type)} instead.`) : new qc(n) : null
          }
          evaluate(t) {
            const r = this.input.evaluate(t);
            if (typeof r == "string") return [...r].length;
            if (Array.isArray(r)) return r.length;
            throw new fi(`Expected value to be of type string or array, but found ${Mr(ea(r))} instead.`)
          }
          eachChild(t) {
            t(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        const rs = 8192;

        function Gp(i, t) {
          const r = (180 + i[0]) / 360,
            n = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i[1] * Math.PI / 360))) / 360,
            c = Math.pow(2, t.z);
          return [Math.round(r * c * rs), Math.round(n * c * rs)]
        }

        function Nc(i, t) {
          const r = Math.pow(2, t.z);
          return [(c = (i[0] / rs + t.x) / r, 360 * c - 180), (n = (i[1] / rs + t.y) / r, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n) * Math.PI / 180)) - 90)];
          var n, c
        }

        function Ps(i, t) {
          i[0] = Math.min(i[0], t[0]), i[1] = Math.min(i[1], t[1]), i[2] = Math.max(i[2], t[0]), i[3] = Math.max(i[3], t[1])
        }

        function Wo(i, t) {
          return !(i[0] <= t[0] || i[2] >= t[2] || i[1] <= t[1] || i[3] >= t[3])
        }

        function qh(i, t, r) {
          const n = i[0] - t[0],
            c = i[1] - t[1],
            f = i[0] - r[0],
            m = i[1] - r[1];
          return n * m - f * c == 0 && n * f <= 0 && c * m <= 0
        }

        function Ho(i, t, r, n) {
          return (c = [n[0] - r[0], n[1] - r[1]])[0] * (f = [t[0] - i[0], t[1] - i[1]])[1] - c[1] * f[0] != 0 && !(!Vh(i, t, r, n) || !Vh(r, n, i, t));
          var c, f
        }

        function Wp(i, t, r) {
          for (const n of r)
            for (let c = 0; c < n.length - 1; ++c)
              if (Ho(i, t, n[c], n[c + 1])) return !0;
          return !1
        }

        function js(i, t, r = !1) {
          let n = !1;
          for (const v of t)
            for (let b = 0; b < v.length - 1; b++) {
              if (qh(i, v[b], v[b + 1])) return r;
              (f = v[b])[1] > (c = i)[1] != (m = v[b + 1])[1] > c[1] && c[0] < (m[0] - f[0]) * (c[1] - f[1]) / (m[1] - f[1]) + f[0] && (n = !n)
            }
          var c, f, m;
          return n
        }

        function Hp(i, t) {
          for (const r of t)
            if (js(i, r)) return !0;
          return !1
        }

        function Nh(i, t) {
          for (const r of i)
            if (!js(r, t)) return !1;
          for (let r = 0; r < i.length - 1; ++r)
            if (Wp(i[r], i[r + 1], t)) return !1;
          return !0
        }

        function Xp(i, t) {
          for (const r of t)
            if (Nh(i, r)) return !0;
          return !1
        }

        function Vh(i, t, r, n) {
          const c = n[0] - r[0],
            f = n[1] - r[1],
            m = (i[0] - r[0]) * f - c * (i[1] - r[1]),
            v = (t[0] - r[0]) * f - c * (t[1] - r[1]);
          return m > 0 && v < 0 || m < 0 && v > 0
        }

        function Vc(i, t, r) {
          const n = [];
          for (let c = 0; c < i.length; c++) {
            const f = [];
            for (let m = 0; m < i[c].length; m++) {
              const v = Gp(i[c][m], r);
              Ps(t, v), f.push(v)
            }
            n.push(f)
          }
          return n
        }

        function Uc(i, t, r) {
          const n = [];
          for (let c = 0; c < i.length; c++) {
            const f = Vc(i[c], t, r);
            n.push(f)
          }
          return n
        }

        function Zc(i, t, r, n) {
          if (i[0] < r[0] || i[0] > r[2]) {
            const c = .5 * n;
            let f = i[0] - r[0] > c ? -n : r[0] - i[0] > c ? n : 0;
            f === 0 && (f = i[0] - r[2] > c ? -n : r[2] - i[0] > c ? n : 0), i[0] += f
          }
          Ps(t, i)
        }

        function Gc(i, t, r, n) {
          const c = Math.pow(2, n.z) * rs,
            f = [n.x * rs, n.y * rs],
            m = [];
          for (const v of i)
            for (const b of v) {
              const M = [b.x + f[0], b.y + f[1]];
              Zc(M, t, r, c), m.push(M)
            }
          return m
        }

        function Uh(i, t, r, n) {
          const c = Math.pow(2, n.z) * rs,
            f = [n.x * rs, n.y * rs],
            m = [];
          for (const b of i) {
            const M = [];
            for (const C of b) {
              const D = [C.x + f[0], C.y + f[1]];
              Ps(t, D), M.push(D)
            }
            m.push(M)
          }
          if (t[2] - t[0] <= c / 2) {
            (v = t)[0] = v[1] = 1 / 0, v[2] = v[3] = -1 / 0;
            for (const b of m)
              for (const M of b) Zc(M, t, r, c)
          }
          var v;
          return m
        }
        class qs {
          constructor(t, r) {
            this.type = Qt, this.geojson = t, this.geometries = r
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`'within' expression requires exactly one argument, but found ${t.length-1} instead.`);
            if (Pa(t[1])) {
              const n = t[1];
              if (n.type === "FeatureCollection") {
                const c = [];
                for (const f of n.features) {
                  const {
                    type: m,
                    coordinates: v
                  } = f.geometry;
                  m === "Polygon" && c.push(v), m === "MultiPolygon" && c.push(...v)
                }
                if (c.length) return new qs(n, {
                  type: "MultiPolygon",
                  coordinates: c
                })
              } else if (n.type === "Feature") {
                const c = n.geometry.type;
                if (c === "Polygon" || c === "MultiPolygon") return new qs(n, n.geometry)
              } else if (n.type === "Polygon" || n.type === "MultiPolygon") return new qs(n, n)
            }
            return r.error("'within' expression requires valid geojson object that contains polygon geometry type.")
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(r, n) {
                const c = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  f = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  m = r.canonicalID();
                if (n.type === "Polygon") {
                  const v = Vc(n.coordinates, f, m),
                    b = Gc(r.geometry(), c, f, m);
                  if (!Wo(c, f)) return !1;
                  for (const M of b)
                    if (!js(M, v)) return !1
                }
                if (n.type === "MultiPolygon") {
                  const v = Uc(n.coordinates, f, m),
                    b = Gc(r.geometry(), c, f, m);
                  if (!Wo(c, f)) return !1;
                  for (const M of b)
                    if (!Hp(M, v)) return !1
                }
                return !0
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(r, n) {
                const c = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  f = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  m = r.canonicalID();
                if (n.type === "Polygon") {
                  const v = Vc(n.coordinates, f, m),
                    b = Uh(r.geometry(), c, f, m);
                  if (!Wo(c, f)) return !1;
                  for (const M of b)
                    if (!Nh(M, v)) return !1
                }
                if (n.type === "MultiPolygon") {
                  const v = Uc(n.coordinates, f, m),
                    b = Uh(r.geometry(), c, f, m);
                  if (!Wo(c, f)) return !1;
                  for (const M of b)
                    if (!Xp(M, v)) return !1
                }
                return !0
              })(t, this.geometries)
            }
            return !1
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        let Zh = class {
          constructor(i = [], t = (r, n) => r < n ? -1 : r > n ? 1 : 0) {
            if (this.data = i, this.length = this.data.length, this.compare = t, this.length > 0)
              for (let r = (this.length >> 1) - 1; r >= 0; r--) this._down(r)
          }
          push(i) {
            this.data.push(i), this._up(this.length++)
          }
          pop() {
            if (this.length === 0) return;
            const i = this.data[0],
              t = this.data.pop();
            return --this.length > 0 && (this.data[0] = t, this._down(0)), i
          }
          peek() {
            return this.data[0]
          }
          _up(i) {
            const {
              data: t,
              compare: r
            } = this, n = t[i];
            for (; i > 0;) {
              const c = i - 1 >> 1,
                f = t[c];
              if (r(n, f) >= 0) break;
              t[i] = f, i = c
            }
            t[i] = n
          }
          _down(i) {
            const {
              data: t,
              compare: r
            } = this, n = this.length >> 1, c = t[i];
            for (; i < n;) {
              let f = 1 + (i << 1);
              const m = f + 1;
              if (m < this.length && r(t[m], t[f]) < 0 && (f = m), r(t[f], c) >= 0) break;
              t[i] = t[f], i = f
            }
            t[i] = c
          }
        };

        function Gh(i, t, r = 0, n = i.length - 1, c = Yp) {
          for (; n > r;) {
            if (n - r > 600) {
              const b = n - r + 1,
                M = t - r + 1,
                C = Math.log(b),
                D = .5 * Math.exp(2 * C / 3),
                N = .5 * Math.sqrt(C * D * (b - D) / b) * (M - b / 2 < 0 ? -1 : 1);
              Gh(i, t, Math.max(r, Math.floor(t - M * D / b + N)), Math.min(n, Math.floor(t + (b - M) * D / b + N)), c)
            }
            const f = i[t];
            let m = r,
              v = n;
            for (Is(i, r, t), c(i[n], f) > 0 && Is(i, r, n); m < v;) {
              for (Is(i, m, v), m++, v--; c(i[m], f) < 0;) m++;
              for (; c(i[v], f) > 0;) v--
            }
            c(i[r], f) === 0 ? Is(i, r, v) : (v++, Is(i, v, n)), v <= t && (r = v + 1), t <= v && (n = v - 1)
          }
        }

        function Is(i, t, r) {
          const n = i[t];
          i[t] = i[r], i[r] = n
        }

        function Yp(i, t) {
          return i < t ? -1 : i > t ? 1 : 0
        }

        function Al(i, t) {
          if (i.length <= 1) return [i];
          const r = [];
          let n, c;
          for (const f of i) {
            const m = Jp(f);
            m !== 0 && (f.area = Math.abs(m), c === void 0 && (c = m < 0), c === m < 0 ? (n && r.push(n), n = [f]) : n.push(f))
          }
          if (n && r.push(n), t > 1)
            for (let f = 0; f < r.length; f++) r[f].length <= t || (Gh(r[f], t, 1, r[f].length - 1, Kp), r[f] = r[f].slice(0, t));
          return r
        }

        function Kp(i, t) {
          return t.area - i.area
        }

        function Jp(i) {
          let t = 0;
          for (let r, n, c = 0, f = i.length, m = f - 1; c < f; m = c++) r = i[c], n = i[m], t += (n.x - r.x) * (r.y + n.y);
          return t
        }
        const kl = 1 / 298.257223563,
          Wc = kl * (2 - kl),
          Wh = Math.PI / 180;
        class Hc {
          constructor(t) {
            const r = 6378.137 * Wh * 1e3,
              n = Math.cos(t * Wh),
              c = 1 / (1 - Wc * (1 - n * n)),
              f = Math.sqrt(c);
            this.kx = r * f * n, this.ky = r * f * c * (1 - Wc)
          }
          distance(t, r) {
            const n = this.wrap(t[0] - r[0]) * this.kx,
              c = (t[1] - r[1]) * this.ky;
            return Math.sqrt(n * n + c * c)
          }
          pointOnLine(t, r) {
            let n, c, f, m, v = 1 / 0;
            for (let b = 0; b < t.length - 1; b++) {
              let M = t[b][0],
                C = t[b][1],
                D = this.wrap(t[b + 1][0] - M) * this.kx,
                N = (t[b + 1][1] - C) * this.ky,
                W = 0;
              D === 0 && N === 0 || (W = (this.wrap(r[0] - M) * this.kx * D + (r[1] - C) * this.ky * N) / (D * D + N * N), W > 1 ? (M = t[b + 1][0], C = t[b + 1][1]) : W > 0 && (M += D / this.kx * W, C += N / this.ky * W)), D = this.wrap(r[0] - M) * this.kx, N = (r[1] - C) * this.ky;
              const X = D * D + N * N;
              X < v && (v = X, n = M, c = C, f = b, m = W)
            }
            return {
              point: [n, c],
              index: f,
              t: Math.max(0, Math.min(1, m))
            }
          }
          wrap(t) {
            for (; t < -180;) t += 360;
            for (; t > 180;) t -= 360;
            return t
          }
        }

        function Xc(i, t) {
          return t[0] - i[0]
        }

        function Xo(i) {
          return i[1] - i[0] + 1
        }

        function cs(i, t) {
          return i[1] >= i[0] && i[1] < t
        }

        function Yc(i, t) {
          if (i[0] > i[1]) return [null, null];
          const r = Xo(i);
          if (t) {
            if (r === 2) return [i, null];
            const c = Math.floor(r / 2);
            return [
              [i[0], i[0] + c],
              [i[0] + c, i[1]]
            ]
          }
          if (r === 1) return [i, null];
          const n = Math.floor(r / 2) - 1;
          return [
            [i[0], i[0] + n],
            [i[0] + n + 1, i[1]]
          ]
        }

        function Kc(i, t) {
          if (!cs(t, i.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let n = t[0]; n <= t[1]; ++n) Ps(r, i[n]);
          return r
        }

        function zl(i) {
          const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (const r of i)
            for (const n of r) Ps(t, n);
          return t
        }

        function Hh(i) {
          return i[0] !== -1 / 0 && i[1] !== -1 / 0 && i[2] !== 1 / 0 && i[3] !== 1 / 0
        }

        function Jc(i, t, r) {
          if (!Hh(i) || !Hh(t)) return NaN;
          let n = 0,
            c = 0;
          return i[2] < t[0] && (n = t[0] - i[2]), i[0] > t[2] && (n = i[0] - t[2]), i[1] > t[3] && (c = i[1] - t[3]), i[3] < t[1] && (c = t[1] - i[3]), r.distance([0, 0], [n, c])
        }

        function Ns(i, t, r) {
          const n = r.pointOnLine(t, i);
          return r.distance(i, n.point)
        }

        function $c(i, t, r, n, c) {
          const f = Math.min(Ns(i, [r, n], c), Ns(t, [r, n], c)),
            m = Math.min(Ns(r, [i, t], c), Ns(n, [i, t], c));
          return Math.min(f, m)
        }

        function $i(i, t, r, n, c) {
          if (!cs(t, i.length) || !cs(n, r.length)) return 1 / 0;
          let f = 1 / 0;
          for (let m = t[0]; m < t[1]; ++m) {
            const v = i[m],
              b = i[m + 1];
            for (let M = n[0]; M < n[1]; ++M) {
              const C = r[M],
                D = r[M + 1];
              if (Ho(v, b, C, D)) return 0;
              f = Math.min(f, $c(v, b, C, D, c))
            }
          }
          return f
        }

        function $p(i, t, r, n, c) {
          if (!cs(t, i.length) || !cs(n, r.length)) return NaN;
          let f = 1 / 0;
          for (let m = t[0]; m <= t[1]; ++m)
            for (let v = n[0]; v <= n[1]; ++v)
              if (f = Math.min(f, c.distance(i[m], r[v])), f === 0) return f;
          return f
        }

        function Qp(i, t, r) {
          if (js(i, t, !0)) return 0;
          let n = 1 / 0;
          for (const c of t) {
            const f = c[0],
              m = c[c.length - 1];
            if (f !== m && (n = Math.min(n, Ns(i, [m, f], r)), n === 0)) return n;
            const v = r.pointOnLine(c, i);
            if (n = Math.min(n, r.distance(i, v.point)), n === 0) return n
          }
          return n
        }

        function ef(i, t, r, n) {
          if (!cs(t, i.length)) return NaN;
          for (let f = t[0]; f <= t[1]; ++f)
            if (js(i[f], r, !0)) return 0;
          let c = 1 / 0;
          for (let f = t[0]; f < t[1]; ++f) {
            const m = i[f],
              v = i[f + 1];
            for (const b of r)
              for (let M = 0, C = b.length, D = C - 1; M < C; D = M++) {
                const N = b[D],
                  W = b[M];
                if (Ho(m, v, N, W)) return 0;
                c = Math.min(c, $c(m, v, N, W, n))
              }
          }
          return c
        }

        function Xh(i, t) {
          for (const r of i)
            for (const n of r)
              if (js(n, t, !0)) return !0;
          return !1
        }

        function tf(i, t, r, n = 1 / 0) {
          const c = zl(i),
            f = zl(t);
          if (n !== 1 / 0 && Jc(c, f, r) >= n) return n;
          if (Wo(c, f)) {
            if (Xh(i, t)) return 0
          } else if (Xh(t, i)) return 0;
          let m = 1 / 0;
          for (const v of i)
            for (let b = 0, M = v.length, C = M - 1; b < M; C = b++) {
              const D = v[C],
                N = v[b];
              for (const W of t)
                for (let X = 0, Q = W.length, le = Q - 1; X < Q; le = X++) {
                  const we = W[le],
                    et = W[X];
                  if (Ho(D, N, we, et)) return 0;
                  m = Math.min(m, $c(D, N, we, et, r))
                }
            }
          return m
        }

        function Yh(i, t, r, n, c, f) {
          if (!f) return;
          const m = Jc(Kc(n, f), c, r);
          m < t && i.push([m, f, [0, 0]])
        }

        function El(i, t, r, n, c, f, m) {
          if (!f || !m) return;
          const v = Jc(Kc(n, f), Kc(c, m), r);
          v < t && i.push([v, f, m])
        }

        function Ll(i, t, r, n, c = 1 / 0) {
          let f = Math.min(n.distance(i[0], r[0][0]), c);
          if (f === 0) return f;
          const m = new Zh([
              [0, [0, i.length - 1],
                [0, 0]
              ]
            ], Xc),
            v = zl(r);
          for (; m.length > 0;) {
            const b = m.pop();
            if (b[0] >= f) continue;
            const M = b[1],
              C = t ? 50 : 100;
            if (Xo(M) <= C) {
              if (!cs(M, i.length)) return NaN;
              if (t) {
                const D = ef(i, M, r, n);
                if (isNaN(D) || D === 0) return D;
                f = Math.min(f, D)
              } else
                for (let D = M[0]; D <= M[1]; ++D) {
                  const N = Qp(i[D], r, n);
                  if (f = Math.min(f, N), f === 0) return 0
                }
            } else {
              const D = Yc(M, t);
              Yh(m, f, n, i, v, D[0]), Yh(m, f, n, i, v, D[1])
            }
          }
          return f
        }

        function Dl(i, t, r, n, c, f = 1 / 0) {
          let m = Math.min(f, c.distance(i[0], r[0]));
          if (m === 0) return m;
          const v = new Zh([
            [0, [0, i.length - 1],
              [0, r.length - 1]
            ]
          ], Xc);
          for (; v.length > 0;) {
            const b = v.pop();
            if (b[0] >= m) continue;
            const M = b[1],
              C = b[2],
              D = t ? 50 : 100,
              N = n ? 50 : 100;
            if (Xo(M) <= D && Xo(C) <= N) {
              if (!cs(M, i.length) && cs(C, r.length)) return NaN;
              let W;
              if (t && n) W = $i(i, M, r, C, c), m = Math.min(m, W);
              else if (t && !n) {
                const X = i.slice(M[0], M[1] + 1);
                for (let Q = C[0]; Q <= C[1]; ++Q)
                  if (W = Ns(r[Q], X, c), m = Math.min(m, W), m === 0) return m
              } else if (!t && n) {
                const X = r.slice(C[0], C[1] + 1);
                for (let Q = M[0]; Q <= M[1]; ++Q)
                  if (W = Ns(i[Q], X, c), m = Math.min(m, W), m === 0) return m
              } else W = $p(i, M, r, C, c), m = Math.min(m, W)
            } else {
              const W = Yc(M, t),
                X = Yc(C, n);
              El(v, m, c, i, r, W[0], X[0]), El(v, m, c, i, r, W[0], X[1]), El(v, m, c, i, r, W[1], X[0]), El(v, m, c, i, r, W[1], X[1])
            }
          }
          return m
        }

        function Qc(i) {
          return i.type === "MultiPolygon" ? i.coordinates.map((t => ({
            type: "Polygon",
            coordinates: t
          }))) : i.type === "MultiLineString" ? i.coordinates.map((t => ({
            type: "LineString",
            coordinates: t
          }))) : i.type === "MultiPoint" ? i.coordinates.map((t => ({
            type: "Point",
            coordinates: t
          }))) : [i]
        }
        class Vs {
          constructor(t, r) {
            this.type = tt, this.geojson = t, this.geometries = r
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`'distance' expression requires exactly one argument, but found ${t.length-1} instead.`);
            if (Pa(t[1])) {
              const n = t[1];
              if (n.type === "FeatureCollection") return new Vs(n, n.features.map((c => Qc(c.geometry))).flat());
              if (n.type === "Feature") return new Vs(n, Qc(n.geometry));
              if ("type" in n && "coordinates" in n) return new Vs(n, Qc(n))
            }
            return r.error("'distance' expression requires valid geojson object that contains polygon geometry type.")
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(r, n) {
                const c = r.geometry(),
                  f = c.flat().map((b => Nc([b.x, b.y], r.canonical)));
                if (c.length === 0) return NaN;
                const m = new Hc(f[0][1]);
                let v = 1 / 0;
                for (const b of n) {
                  switch (b.type) {
                    case "Point":
                      v = Math.min(v, Dl(f, !1, [b.coordinates], !1, m, v));
                      break;
                    case "LineString":
                      v = Math.min(v, Dl(f, !1, b.coordinates, !0, m, v));
                      break;
                    case "Polygon":
                      v = Math.min(v, Ll(f, !1, b.coordinates, m, v))
                  }
                  if (v === 0) return v
                }
                return v
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(r, n) {
                const c = r.geometry(),
                  f = c.flat().map((b => Nc([b.x, b.y], r.canonical)));
                if (c.length === 0) return NaN;
                const m = new Hc(f[0][1]);
                let v = 1 / 0;
                for (const b of n) {
                  switch (b.type) {
                    case "Point":
                      v = Math.min(v, Dl(f, !0, [b.coordinates], !1, m, v));
                      break;
                    case "LineString":
                      v = Math.min(v, Dl(f, !0, b.coordinates, !0, m, v));
                      break;
                    case "Polygon":
                      v = Math.min(v, Ll(f, !0, b.coordinates, m, v))
                  }
                  if (v === 0) return v
                }
                return v
              })(t, this.geometries);
              if (t.geometryType() === "Polygon") return (function(r, n) {
                const c = r.geometry();
                if (c.length === 0 || c[0].length === 0) return NaN;
                const f = Al(c, 0).map((b => b.map((M => M.map((C => Nc([C.x, C.y], r.canonical))))))),
                  m = new Hc(f[0][0][0][1]);
                let v = 1 / 0;
                for (const b of n)
                  for (const M of f) {
                    switch (b.type) {
                      case "Point":
                        v = Math.min(v, Ll([b.coordinates], !1, M, m, v));
                        break;
                      case "LineString":
                        v = Math.min(v, Ll(b.coordinates, !0, M, m, v));
                        break;
                      case "Polygon":
                        v = Math.min(v, tf(M, b.coordinates, m, v))
                    }
                    if (v === 0) return v
                  }
                return v
              })(t, this.geometries)
            }
            return NaN
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        class Yo {
          constructor(t) {
            this.type = Dr, this.key = t
          }
          static parse(t, r) {
            if (t.length !== 2) return r.error(`Expected 1 argument, but found ${t.length-1} instead.`);
            const n = t[1];
            return n == null ? r.error("Global state property must be defined.") : typeof n != "string" ? r.error(`Global state property must be string, but found ${typeof t[1]} instead.`) : new Yo(n)
          }
          evaluate(t) {
            var r;
            const n = (r = t.globals) === null || r === void 0 ? void 0 : r.globalState;
            return n && Object.keys(n).length !== 0 ? Ei(n, this.key) : null
          }
          eachChild() {}
          outputDefined() {
            return !1
          }
        }
        const bo = {
          "==": jc,
          "!=": Zp,
          ">": Il,
          "<": jh,
          ">=": Vn,
          "<=": Ml,
          array: Mi,
          at: es,
          boolean: Mi,
          case: qn,
          coalesce: Uo,
          collator: Zo,
          format: Cl,
          image: Go,
          in: jn,
          "index-of": Tn,
          interpolate: Ki,
          "interpolate-hcl": Ki,
          "interpolate-lab": Ki,
          length: qc,
          let: On,
          literal: Ia,
          match: os,
          number: Mi,
          "number-format": xo,
          object: Mi,
          slice: ts,
          step: Ma,
          string: Mi,
          "to-boolean": Ti,
          "to-color": Ti,
          "to-number": Ti,
          "to-string": Ti,
          var: Va,
          within: qs,
          distance: Vs,
          "global-state": Yo
        };
        class Ln {
          constructor(t, r, n, c) {
            this.name = t, this.type = r, this._evaluate = n, this.args = c
          }
          evaluate(t) {
            return this._evaluate(t, this.args)
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return !1
          }
          static parse(t, r) {
            const n = t[0],
              c = Ln.definitions[n];
            if (!c) return r.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const f = Array.isArray(c) ? c[0] : c.type,
              m = Array.isArray(c) ? [
                [c[1], c[2]]
              ] : c.overloads,
              v = m.filter((([M]) => !Array.isArray(M) || M.length === t.length - 1));
            let b = null;
            for (const [M, C] of v) {
              b = new Fi(r.registry, Rl, r.path, null, r.scope);
              const D = [];
              let N = !1;
              for (let W = 1; W < t.length; W++) {
                const X = t[W],
                  Q = Array.isArray(M) ? M[W - 1] : M.type,
                  le = b.parse(X, 1 + D.length, Q);
                if (!le) {
                  N = !0;
                  break
                }
                D.push(le)
              }
              if (!N)
                if (Array.isArray(M) && M.length !== D.length) b.error(`Expected ${M.length} arguments, but found ${D.length} instead.`);
                else {
                  for (let W = 0; W < D.length; W++) {
                    const X = Array.isArray(M) ? M[W] : M.type,
                      Q = D[W];
                    b.concat(W + 1).checkSubtype(X, Q.type)
                  }
                  if (b.errors.length === 0) return new Ln(n, f, C, D)
                }
            }
            if (v.length === 1) r.errors.push(...b.errors);
            else {
              const M = (v.length ? v : m).map((([D]) => {
                  return N = D, Array.isArray(N) ? `(${N.map(Mr).join(", ")})` : `(${Mr(N.type)}...)`;
                  var N
                })).join(" | "),
                C = [];
              for (let D = 1; D < t.length; D++) {
                const N = r.parse(t[D], 1 + C.length);
                if (!N) return null;
                C.push(Mr(N.type))
              }
              r.error(`Expected arguments of type ${M}, but found (${C.join(", ")}) instead.`)
            }
            return null
          }
          static register(t, r) {
            Ln.definitions = r;
            for (const n in r) t[n] = Ln
          }
        }

        function Kh(i, [t, r, n, c]) {
          t = t.evaluate(i), r = r.evaluate(i), n = n.evaluate(i);
          const f = c ? c.evaluate(i) : 1,
            m = Da(t, r, n, f);
          if (m) throw new fi(m);
          return new Ar(t / 255, r / 255, n / 255, f, !1)
        }

        function Jh(i, t) {
          return i in t
        }

        function eu(i, t) {
          const r = t[i];
          return r === void 0 ? null : r
        }

        function Us(i) {
          return {
            type: i
          }
        }

        function Rl(i) {
          if (i instanceof Va) return Rl(i.boundExpression);
          if (i instanceof Ln && i.name === "error" || i instanceof Zo || i instanceof qs || i instanceof Vs || i instanceof Yo) return !1;
          const t = i instanceof Ti || i instanceof Mi;
          let r = !0;
          return i.eachChild((n => {
            r = t ? r && Rl(n) : r && n instanceof Ia
          })), !!r && Fl(i) && Bl(i, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"])
        }

        function Fl(i) {
          if (i instanceof Ln && (i.name === "get" && i.args.length === 1 || i.name === "feature-state" || i.name === "has" && i.args.length === 1 || i.name === "properties" || i.name === "geometry-type" || i.name === "id" || /^filter-/.test(i.name)) || i instanceof qs || i instanceof Vs) return !1;
          let t = !0;
          return i.eachChild((r => {
            t && !Fl(r) && (t = !1)
          })), t
        }

        function Ko(i) {
          if (i instanceof Ln && i.name === "feature-state") return !1;
          let t = !0;
          return i.eachChild((r => {
            t && !Ko(r) && (t = !1)
          })), t
        }

        function Bl(i, t) {
          if (i instanceof Ln && t.indexOf(i.name) >= 0) return !1;
          let r = !0;
          return i.eachChild((n => {
            r && !Bl(n, t) && (r = !1)
          })), r
        }

        function $h(i) {
          return {
            result: "success",
            value: i
          }
        }

        function wo(i) {
          return {
            result: "error",
            value: i
          }
        }

        function To(i) {
          return i["property-type"] === "data-driven" || i["property-type"] === "cross-faded-data-driven"
        }

        function Qh(i) {
          return !!i.expression && i.expression.parameters.indexOf("zoom") > -1
        }

        function tu(i) {
          return !!i.expression && i.expression.interpolated
        }

        function ji(i) {
          return i instanceof Number ? "number" : i instanceof String ? "string" : i instanceof Boolean ? "boolean" : Array.isArray(i) ? "array" : i === null ? "null" : typeof i
        }

        function Ol(i) {
          return typeof i == "object" && i !== null && !Array.isArray(i) && ea(i) === li
        }

        function rf(i) {
          return i
        }

        function ed(i, t) {
          const r = i.stops && typeof i.stops[0][0] == "object",
            n = r || !(r || i.property !== void 0),
            c = i.type || (tu(t) ? "exponential" : "interval"),
            f = (function(C) {
              switch (C.type) {
                case "color":
                  return Ar.parse;
                case "padding":
                  return ki.parse;
                case "numberArray":
                  return zi.parse;
                case "colorArray":
                  return yi.parse;
                default:
                  return null
              }
            })(t);
          if (f && ((i = Tt({}, i)).stops && (i.stops = i.stops.map((C => [C[0], f(C[1])]))), i.default = f(i.default ? i.default : t.default)), i.colorSpace && (m = i.colorSpace) !== "rgb" && m !== "hcl" && m !== "lab") throw new Error(`Unknown color space: "${i.colorSpace}"`);
          var m;
          const v = (function(C) {
            switch (C) {
              case "exponential":
                return td;
              case "interval":
                return nf;
              case "categorical":
                return af;
              case "identity":
                return rd;
              default:
                throw new Error(`Unknown function type "${C}"`)
            }
          })(c);
          let b, M;
          if (c === "categorical") {
            b = Object.create(null);
            for (const C of i.stops) b[C[0]] = C[1];
            M = typeof i.stops[0][0]
          }
          if (r) {
            const C = {},
              D = [];
            for (let X = 0; X < i.stops.length; X++) {
              const Q = i.stops[X],
                le = Q[0].zoom;
              C[le] === void 0 && (C[le] = {
                zoom: le,
                type: i.type,
                property: i.property,
                default: i.default,
                stops: []
              }, D.push(le)), C[le].stops.push([Q[0].value, Q[1]])
            }
            const N = [];
            for (const X of D) N.push([C[X].zoom, ed(C[X], t)]);
            const W = {
              name: "linear"
            };
            return {
              kind: "composite",
              interpolationType: W,
              interpolationFactor: Ki.interpolationFactor.bind(void 0, W),
              zoomStops: N.map((X => X[0])),
              evaluate: ({
                zoom: X
              }, Q) => td({
                stops: N,
                base: i.base
              }, t, X).evaluate(X, Q)
            }
          }
          if (n) {
            const C = c === "exponential" ? {
              name: "exponential",
              base: i.base !== void 0 ? i.base : 1
            } : null;
            return {
              kind: "camera",
              interpolationType: C,
              interpolationFactor: Ki.interpolationFactor.bind(void 0, C),
              zoomStops: i.stops.map((D => D[0])),
              evaluate: ({
                zoom: D
              }) => v(i, t, D, b, M)
            }
          }
          return {
            kind: "source",
            evaluate(C, D) {
              const N = D && D.properties ? D.properties[i.property] : void 0;
              return N === void 0 ? Zs(i.default, t.default) : v(i, t, N, b, M)
            }
          }
        }

        function Zs(i, t, r) {
          return i !== void 0 ? i : t !== void 0 ? t : r !== void 0 ? r : void 0
        }

        function af(i, t, r, n, c) {
          return Zs(typeof r === c ? n[r] : void 0, i.default, t.default)
        }

        function nf(i, t, r) {
          if (ji(r) !== "number") return Zs(i.default, t.default);
          const n = i.stops.length;
          if (n === 1 || r <= i.stops[0][0]) return i.stops[0][1];
          if (r >= i.stops[n - 1][0]) return i.stops[n - 1][1];
          const c = fa(i.stops.map((f => f[0])), r);
          return i.stops[c][1]
        }

        function td(i, t, r) {
          const n = i.base !== void 0 ? i.base : 1;
          if (ji(r) !== "number") return Zs(i.default, t.default);
          const c = i.stops.length;
          if (c === 1 || r <= i.stops[0][0]) return i.stops[0][1];
          if (r >= i.stops[c - 1][0]) return i.stops[c - 1][1];
          const f = fa(i.stops.map((C => C[0])), r),
            m = (function(C, D, N, W) {
              const X = W - N,
                Q = C - N;
              return X === 0 ? 0 : D === 1 ? Q / X : (Math.pow(D, Q) - 1) / (Math.pow(D, X) - 1)
            })(r, n, i.stops[f][0], i.stops[f + 1][0]),
            v = i.stops[f][1],
            b = i.stops[f + 1][1],
            M = En[t.type] || rf;
          return typeof v.evaluate == "function" ? {
            evaluate(...C) {
              const D = v.evaluate.apply(void 0, C),
                N = b.evaluate.apply(void 0, C);
              if (D !== void 0 && N !== void 0) return M(D, N, m, i.colorSpace)
            }
          } : M(v, b, m, i.colorSpace)
        }

        function rd(i, t, r) {
          switch (t.type) {
            case "color":
              r = Ar.parse(r);
              break;
            case "formatted":
              r = Di.fromString(r.toString());
              break;
            case "resolvedImage":
              r = sa.fromString(r.toString());
              break;
            case "padding":
              r = ki.parse(r);
              break;
            case "colorArray":
              r = yi.parse(r);
              break;
            case "numberArray":
              r = zi.parse(r);
              break;
            default:
              ji(r) === t.type || t.type === "enum" && t.values[r] || (r = void 0)
          }
          return Zs(r, i.default, t.default)
        }
        Ln.register(bo, {
          error: [{
              kind: "error"
            },
            [Ht], (i, [t]) => {
              throw new fi(t.evaluate(i))
            }
          ],
          typeof: [Ht, [Dr], (i, [t]) => Mr(ea(t.evaluate(i)))],
          "to-rgba": [ur(tt, 4), [Sr], (i, [t]) => {
            const [r, n, c, f] = t.evaluate(i).rgb;
            return [255 * r, 255 * n, 255 * c, f]
          }],
          rgb: [Sr, [tt, tt, tt], Kh],
          rgba: [Sr, [tt, tt, tt, tt], Kh],
          has: {
            type: Qt,
            overloads: [
              [
                [Ht], (i, [t]) => Jh(t.evaluate(i), i.properties())
              ],
              [
                [Ht, li], (i, [t, r]) => Jh(t.evaluate(i), r.evaluate(i))
              ]
            ]
          },
          get: {
            type: Dr,
            overloads: [
              [
                [Ht], (i, [t]) => eu(t.evaluate(i), i.properties())
              ],
              [
                [Ht, li], (i, [t, r]) => eu(t.evaluate(i), r.evaluate(i))
              ]
            ]
          },
          "feature-state": [Dr, [Ht], (i, [t]) => eu(t.evaluate(i), i.featureState || {})],
          properties: [li, [], i => i.properties()],
          "geometry-type": [Ht, [], i => i.geometryType()],
          id: [Dr, [], i => i.id()],
          zoom: [tt, [], i => i.globals.zoom],
          "heatmap-density": [tt, [], i => i.globals.heatmapDensity || 0],
          elevation: [tt, [], i => i.globals.elevation || 0],
          "line-progress": [tt, [], i => i.globals.lineProgress || 0],
          accumulated: [Dr, [], i => i.globals.accumulated === void 0 ? null : i.globals.accumulated],
          "+": [tt, Us(tt), (i, t) => {
            let r = 0;
            for (const n of t) r += n.evaluate(i);
            return r
          }],
          "*": [tt, Us(tt), (i, t) => {
            let r = 1;
            for (const n of t) r *= n.evaluate(i);
            return r
          }],
          "-": {
            type: tt,
            overloads: [
              [
                [tt, tt], (i, [t, r]) => t.evaluate(i) - r.evaluate(i)
              ],
              [
                [tt], (i, [t]) => -t.evaluate(i)
              ]
            ]
          },
          "/": [tt, [tt, tt], (i, [t, r]) => t.evaluate(i) / r.evaluate(i)],
          "%": [tt, [tt, tt], (i, [t, r]) => t.evaluate(i) % r.evaluate(i)],
          ln2: [tt, [], () => Math.LN2],
          pi: [tt, [], () => Math.PI],
          e: [tt, [], () => Math.E],
          "^": [tt, [tt, tt], (i, [t, r]) => Math.pow(t.evaluate(i), r.evaluate(i))],
          sqrt: [tt, [tt], (i, [t]) => Math.sqrt(t.evaluate(i))],
          log10: [tt, [tt], (i, [t]) => Math.log(t.evaluate(i)) / Math.LN10],
          ln: [tt, [tt], (i, [t]) => Math.log(t.evaluate(i))],
          log2: [tt, [tt], (i, [t]) => Math.log(t.evaluate(i)) / Math.LN2],
          sin: [tt, [tt], (i, [t]) => Math.sin(t.evaluate(i))],
          cos: [tt, [tt], (i, [t]) => Math.cos(t.evaluate(i))],
          tan: [tt, [tt], (i, [t]) => Math.tan(t.evaluate(i))],
          asin: [tt, [tt], (i, [t]) => Math.asin(t.evaluate(i))],
          acos: [tt, [tt], (i, [t]) => Math.acos(t.evaluate(i))],
          atan: [tt, [tt], (i, [t]) => Math.atan(t.evaluate(i))],
          min: [tt, Us(tt), (i, t) => Math.min(...t.map((r => r.evaluate(i))))],
          max: [tt, Us(tt), (i, t) => Math.max(...t.map((r => r.evaluate(i))))],
          abs: [tt, [tt], (i, [t]) => Math.abs(t.evaluate(i))],
          round: [tt, [tt], (i, [t]) => {
            const r = t.evaluate(i);
            return r < 0 ? -Math.round(-r) : Math.round(r)
          }],
          floor: [tt, [tt], (i, [t]) => Math.floor(t.evaluate(i))],
          ceil: [tt, [tt], (i, [t]) => Math.ceil(t.evaluate(i))],
          "filter-==": [Qt, [Ht, Dr], (i, [t, r]) => i.properties()[t.value] === r.value],
          "filter-id-==": [Qt, [Dr], (i, [t]) => i.id() === t.value],
          "filter-type-==": [Qt, [Ht], (i, [t]) => i.geometryType() === t.value],
          "filter-<": [Qt, [Ht, Dr], (i, [t, r]) => {
            const n = i.properties()[t.value],
              c = r.value;
            return typeof n == typeof c && n < c
          }],
          "filter-id-<": [Qt, [Dr], (i, [t]) => {
            const r = i.id(),
              n = t.value;
            return typeof r == typeof n && r < n
          }],
          "filter->": [Qt, [Ht, Dr], (i, [t, r]) => {
            const n = i.properties()[t.value],
              c = r.value;
            return typeof n == typeof c && n > c
          }],
          "filter-id->": [Qt, [Dr], (i, [t]) => {
            const r = i.id(),
              n = t.value;
            return typeof r == typeof n && r > n
          }],
          "filter-<=": [Qt, [Ht, Dr], (i, [t, r]) => {
            const n = i.properties()[t.value],
              c = r.value;
            return typeof n == typeof c && n <= c
          }],
          "filter-id-<=": [Qt, [Dr], (i, [t]) => {
            const r = i.id(),
              n = t.value;
            return typeof r == typeof n && r <= n
          }],
          "filter->=": [Qt, [Ht, Dr], (i, [t, r]) => {
            const n = i.properties()[t.value],
              c = r.value;
            return typeof n == typeof c && n >= c
          }],
          "filter-id->=": [Qt, [Dr], (i, [t]) => {
            const r = i.id(),
              n = t.value;
            return typeof r == typeof n && r >= n
          }],
          "filter-has": [Qt, [Dr], (i, [t]) => t.value in i.properties()],
          "filter-has-id": [Qt, [], i => i.id() !== null && i.id() !== void 0],
          "filter-type-in": [Qt, [ur(Ht)], (i, [t]) => t.value.indexOf(i.geometryType()) >= 0],
          "filter-id-in": [Qt, [ur(Dr)], (i, [t]) => t.value.indexOf(i.id()) >= 0],
          "filter-in-small": [Qt, [Ht, ur(Dr)], (i, [t, r]) => r.value.indexOf(i.properties()[t.value]) >= 0],
          "filter-in-large": [Qt, [Ht, ur(Dr)], (i, [t, r]) => (function(n, c, f, m) {
            for (; f <= m;) {
              const v = f + m >> 1;
              if (c[v] === n) return !0;
              c[v] > n ? m = v - 1 : f = v + 1
            }
            return !1
          })(i.properties()[t.value], r.value, 0, r.value.length - 1)],
          all: {
            type: Qt,
            overloads: [
              [
                [Qt, Qt], (i, [t, r]) => t.evaluate(i) && r.evaluate(i)
              ],
              [Us(Qt), (i, t) => {
                for (const r of t)
                  if (!r.evaluate(i)) return !1;
                return !0
              }]
            ]
          },
          any: {
            type: Qt,
            overloads: [
              [
                [Qt, Qt], (i, [t, r]) => t.evaluate(i) || r.evaluate(i)
              ],
              [Us(Qt), (i, t) => {
                for (const r of t)
                  if (r.evaluate(i)) return !0;
                return !1
              }]
            ]
          },
          "!": [Qt, [Qt], (i, [t]) => !t.evaluate(i)],
          "is-supported-script": [Qt, [Ht], (i, [t]) => {
            const r = i.globals && i.globals.isSupportedScript;
            return !r || r(t.evaluate(i))
          }],
          upcase: [Ht, [Ht], (i, [t]) => t.evaluate(i).toUpperCase()],
          downcase: [Ht, [Ht], (i, [t]) => t.evaluate(i).toLowerCase()],
          concat: [Ht, Us(Dr), (i, t) => t.map((r => pa(r.evaluate(i)))).join("")],
          "resolved-locale": [Ht, [Oi], (i, [t]) => t.evaluate(i).resolvedLocale()]
        });
        class ru {
          constructor(t, r, n) {
            this.expression = t, this._warningHistory = {}, this._evaluator = new Bn, this._defaultValue = r ? (function(c) {
              if (c.type === "color" && Ol(c.default)) return new Ar(0, 0, 0, 0);
              switch (c.type) {
                case "color":
                  return Ar.parse(c.default) || null;
                case "padding":
                  return ki.parse(c.default) || null;
                case "numberArray":
                  return zi.parse(c.default) || null;
                case "colorArray":
                  return yi.parse(c.default) || null;
                case "variableAnchorOffsetCollection":
                  return Yi.parse(c.default) || null;
                case "projectionDefinition":
                  return ua.parse(c.default) || null;
                default:
                  return c.default === void 0 ? null : c.default
              }
            })(r) : null, this._enumValues = r && r.type === "enum" ? r.values : null, this._globalState = n
          }
          evaluateWithoutErrorHandling(t, r, n, c, f, m) {
            return this._globalState && (t = Ws(t, this._globalState)), this._evaluator.globals = t, this._evaluator.feature = r, this._evaluator.featureState = n, this._evaluator.canonical = c, this._evaluator.availableImages = f || null, this._evaluator.formattedSection = m, this.expression.evaluate(this._evaluator)
          }
          evaluate(t, r, n, c, f, m) {
            this._globalState && (t = Ws(t, this._globalState)), this._evaluator.globals = t, this._evaluator.feature = r || null, this._evaluator.featureState = n || null, this._evaluator.canonical = c, this._evaluator.availableImages = f || null, this._evaluator.formattedSection = m || null;
            try {
              const v = this.expression.evaluate(this._evaluator);
              if (v == null || typeof v == "number" && v != v) return this._defaultValue;
              if (this._enumValues && !(v in this._enumValues)) throw new fi(`Expected value to be one of ${Object.keys(this._enumValues).map((b=>JSON.stringify(b))).join(", ")}, but found ${JSON.stringify(v)} instead.`);
              return v
            } catch (v) {
              return this._warningHistory[v.message] || (this._warningHistory[v.message] = !0, typeof console < "u" && console.warn(v.message)), this._defaultValue
            }
          }
        }

        function jl(i) {
          return Array.isArray(i) && i.length > 0 && typeof i[0] == "string" && i[0] in bo
        }

        function Gs(i, t, r) {
          const n = new Fi(bo, Rl, [], t ? (function(f) {
              const m = {
                color: Sr,
                string: Ht,
                number: tt,
                enum: Ht,
                boolean: Qt,
                formatted: Jr,
                padding: It,
                numberArray: Pr,
                colorArray: er,
                projectionDefinition: ei,
                resolvedImage: pr,
                variableAnchorOffsetCollection: qr
              };
              return f.type === "array" ? ur(m[f.value] || Dr, f.length) : m[f.type]
            })(t) : void 0),
            c = n.parse(i, void 0, void 0, void 0, t && t.type === "string" ? {
              typeAnnotation: "coerce"
            } : void 0);
          return c ? $h(new ru(c, t, r)) : wo(n.errors)
        }
        class Jo {
          constructor(t, r, n) {
            this.kind = t, this._styleExpression = r, this.isStateDependent = t !== "constant" && !Ko(r.expression), this.globalStateRefs = Vl(r.expression), this._globalState = n
          }
          evaluateWithoutErrorHandling(t, r, n, c, f, m) {
            return this._globalState && (t = Ws(t, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(t, r, n, c, f, m)
          }
          evaluate(t, r, n, c, f, m) {
            return this._globalState && (t = Ws(t, this._globalState)), this._styleExpression.evaluate(t, r, n, c, f, m)
          }
        }
        class iu {
          constructor(t, r, n, c, f) {
            this.kind = t, this.zoomStops = n, this._styleExpression = r, this.isStateDependent = t !== "camera" && !Ko(r.expression), this.globalStateRefs = Vl(r.expression), this.interpolationType = c, this._globalState = f
          }
          evaluateWithoutErrorHandling(t, r, n, c, f, m) {
            return this._globalState && (t = Ws(t, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(t, r, n, c, f, m)
          }
          evaluate(t, r, n, c, f, m) {
            return this._globalState && (t = Ws(t, this._globalState)), this._styleExpression.evaluate(t, r, n, c, f, m)
          }
          interpolationFactor(t, r, n) {
            return this.interpolationType ? Ki.interpolationFactor(this.interpolationType, t, r, n) : 0
          }
        }

        function id(i, t, r) {
          const n = Gs(i, t, r);
          if (n.result === "error") return n;
          const c = n.value.expression,
            f = Fl(c);
          if (!f && !To(t)) return wo([new Wt("", "data expressions not supported")]);
          const m = Bl(c, ["zoom"]);
          if (!m && !Qh(t)) return wo([new Wt("", "zoom expressions not supported")]);
          const v = Nl(c);
          return v || m ? v instanceof Wt ? wo([v]) : v instanceof Ki && !tu(t) ? wo([new Wt("", '"interpolate" expressions cannot be used with this property')]) : $h(v ? new iu(f ? "camera" : "composite", n.value, v.labels, v instanceof Ki ? v.interpolation : void 0, r) : new Jo(f ? "constant" : "source", n.value, r)) : wo([new Wt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')])
        }
        class ql {
          constructor(t, r) {
            this._parameters = t, this._specification = r, Tt(this, ed(this._parameters, this._specification))
          }
          static deserialize(t) {
            return new ql(t._parameters, t._specification)
          }
          static serialize(t) {
            return {
              _parameters: t._parameters,
              _specification: t._specification
            }
          }
        }

        function Nl(i) {
          let t = null;
          if (i instanceof On) t = Nl(i.result);
          else if (i instanceof Uo) {
            for (const r of i.args)
              if (t = Nl(r), t) break
          } else(i instanceof Ma || i instanceof Ki) && i.input instanceof Ln && i.input.name === "zoom" && (t = i);
          return t instanceof Wt || i.eachChild((r => {
            const n = Nl(r);
            n instanceof Wt ? t = n : !t && n ? t = new Wt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && n && t !== n && (t = new Wt("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'))
          })), t
        }

        function Vl(i, t = new Set) {
          return i instanceof Yo && t.add(i.key), i.eachChild((r => {
            Vl(r, t)
          })), t
        }

        function Ws(i, t) {
          const {
            zoom: r,
            heatmapDensity: n,
            elevation: c,
            lineProgress: f,
            isSupportedScript: m,
            accumulated: v
          } = i ?? {};
          return {
            zoom: r,
            heatmapDensity: n,
            elevation: c,
            lineProgress: f,
            isSupportedScript: m,
            accumulated: v,
            globalState: t
          }
        }

        function Ul(i) {
          if (i === !0 || i === !1) return !0;
          if (!Array.isArray(i) || i.length === 0) return !1;
          switch (i[0]) {
            case "has":
              return i.length >= 2 && i[1] !== "$id" && i[1] !== "$type";
            case "in":
              return i.length >= 3 && (typeof i[1] != "string" || Array.isArray(i[2]));
            case "!in":
            case "!has":
            case "none":
              return !1;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return i.length !== 3 || Array.isArray(i[1]) || Array.isArray(i[2]);
            case "any":
            case "all":
              for (const t of i.slice(1))
                if (!Ul(t) && typeof t != "boolean") return !1;
              return !0;
            default:
              return !0
          }
        }
        const sf = {
          type: "boolean",
          default: !1,
          transition: !1,
          "property-type": "data-driven",
          expression: {
            interpolated: !1,
            parameters: ["zoom", "feature"]
          }
        };

        function $o(i, t) {
          if (i == null) return {
            filter: () => !0,
            needGeometry: !1,
            getGlobalStateRefs: () => new Set
          };
          Ul(i) || (i = Qo(i));
          const r = Gs(i, sf, t);
          if (r.result === "error") throw new Error(r.value.map((n => `${n.key}: ${n.message}`)).join(", "));
          return {
            filter: (n, c, f) => r.value.evaluate(n, c, {}, f),
            needGeometry: au(i),
            getGlobalStateRefs: () => Vl(r.value.expression)
          }
        }

        function ad(i, t) {
          return i < t ? -1 : i > t ? 1 : 0
        }

        function au(i) {
          if (!Array.isArray(i)) return !1;
          if (i[0] === "within" || i[0] === "distance") return !0;
          for (let t = 1; t < i.length; t++)
            if (au(i[t])) return !0;
          return !1
        }

        function Qo(i) {
          if (!i) return !0;
          const t = i[0];
          return i.length <= 1 ? t !== "any" : t === "==" ? nu(i[1], i[2], "==") : t === "!=" ? Zl(nu(i[1], i[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? nu(i[1], i[2], t) : t === "any" ? (r = i.slice(1), ["any"].concat(r.map(Qo))) : t === "all" ? ["all"].concat(i.slice(1).map(Qo)) : t === "none" ? ["all"].concat(i.slice(1).map(Qo).map(Zl)) : t === "in" ? nd(i[1], i.slice(2)) : t === "!in" ? Zl(nd(i[1], i.slice(2))) : t === "has" ? sd(i[1]) : t !== "!has" || Zl(sd(i[1]));
          var r
        }

        function nu(i, t, r) {
          switch (i) {
            case "$type":
              return [`filter-type-${r}`, t];
            case "$id":
              return [`filter-id-${r}`, t];
            default:
              return [`filter-${r}`, i, t]
          }
        }

        function nd(i, t) {
          if (t.length === 0) return !1;
          switch (i) {
            case "$type":
              return ["filter-type-in", ["literal", t]];
            case "$id":
              return ["filter-id-in", ["literal", t]];
            default:
              return t.length > 200 && !t.some((r => typeof r != typeof t[0])) ? ["filter-in-large", i, ["literal", t.sort(ad)]] : ["filter-in-small", i, ["literal", t]]
          }
        }

        function sd(i) {
          switch (i) {
            case "$type":
              return !0;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", i]
          }
        }

        function Zl(i) {
          return ["!", i]
        }

        function Gl(i) {
          const t = typeof i;
          if (t === "number" || t === "boolean" || t === "string" || i == null) return JSON.stringify(i);
          if (Array.isArray(i)) {
            let c = "[";
            for (const f of i) c += `${Gl(f)},`;
            return `${c}]`
          }
          const r = Object.keys(i).sort();
          let n = "{";
          for (let c = 0; c < r.length; c++) n += `${JSON.stringify(r[c])}:${Gl(i[r[c]])},`;
          return `${n}}`
        }

        function od(i) {
          let t = "";
          for (const r of Fe) t += `/${Gl(i[r])}`;
          return t
        }

        function Wl(i) {
          const t = i.value;
          return t ? [new Ke(i.key, t, "constants have been deprecated as of v8")] : []
        }

        function ga(i) {
          return i instanceof Number || i instanceof String || i instanceof Boolean ? i.valueOf() : i
        }

        function us(i) {
          if (Array.isArray(i)) return i.map(us);
          if (i instanceof Object && !(i instanceof Number || i instanceof String || i instanceof Boolean)) {
            const t = {};
            for (const r in i) t[r] = us(i[r]);
            return t
          }
          return ga(i)
        }

        function fn(i) {
          const t = i.key,
            r = i.value,
            n = i.valueSpec || {},
            c = i.objectElementValidators || {},
            f = i.style,
            m = i.styleSpec,
            v = i.validateSpec;
          let b = [];
          const M = ji(r);
          if (M !== "object") return [new Ke(t, r, `object expected, ${M} found`)];
          for (const C in r) {
            const D = C.split(".")[0],
              N = Ei(n, D) || n["*"];
            let W;
            if (Ei(c, D)) W = c[D];
            else if (Ei(n, D)) W = v;
            else if (c["*"]) W = c["*"];
            else {
              if (!n["*"]) {
                b.push(new Ke(t, r[C], `unknown property "${C}"`));
                continue
              }
              W = v
            }
            b = b.concat(W({
              key: (t && `${t}.`) + C,
              value: r[C],
              valueSpec: N,
              style: f,
              styleSpec: m,
              object: r,
              objectKey: C,
              validateSpec: v
            }, r))
          }
          for (const C in n) c[C] || n[C].required && n[C].default === void 0 && r[C] === void 0 && b.push(new Ke(t, r, `missing required property "${C}"`));
          return b
        }

        function So(i) {
          const t = i.value,
            r = i.valueSpec,
            n = i.style,
            c = i.styleSpec,
            f = i.key,
            m = i.arrayElementValidator || i.validateSpec;
          if (ji(t) !== "array") return [new Ke(f, t, `array expected, ${ji(t)} found`)];
          if (r.length && t.length !== r.length) return [new Ke(f, t, `array length ${r.length} expected, length ${t.length} found`)];
          if (r["min-length"] && t.length < r["min-length"]) return [new Ke(f, t, `array length at least ${r["min-length"]} expected, length ${t.length} found`)];
          let v = {
            type: r.value,
            values: r.values
          };
          c.$version < 7 && (v.function = r.function), ji(r.value) === "object" && (v = r.value);
          let b = [];
          for (let M = 0; M < t.length; M++) b = b.concat(m({
            array: t,
            arrayIndex: M,
            value: t[M],
            valueSpec: v,
            validateSpec: i.validateSpec,
            style: n,
            styleSpec: c,
            key: `${f}[${M}]`
          }));
          return b
        }

        function Hl(i) {
          const t = i.key,
            r = i.value,
            n = i.valueSpec;
          let c = ji(r);
          return c === "number" && r != r && (c = "NaN"), c !== "number" ? [new Ke(t, r, `number expected, ${c} found`)] : "minimum" in n && r < n.minimum ? [new Ke(t, r, `${r} is less than the minimum value ${n.minimum}`)] : "maximum" in n && r > n.maximum ? [new Ke(t, r, `${r} is greater than the maximum value ${n.maximum}`)] : []
        }

        function ld(i) {
          const t = i.valueSpec,
            r = ga(i.value.type);
          let n, c, f, m = {};
          const v = r !== "categorical" && i.value.property === void 0,
            b = !v,
            M = ji(i.value.stops) === "array" && ji(i.value.stops[0]) === "array" && ji(i.value.stops[0][0]) === "object",
            C = fn({
              key: i.key,
              value: i.value,
              valueSpec: i.styleSpec.function,
              validateSpec: i.validateSpec,
              style: i.style,
              styleSpec: i.styleSpec,
              objectElementValidators: {
                stops: function(W) {
                  if (r === "identity") return [new Ke(W.key, W.value, 'identity function may not have a "stops" property')];
                  let X = [];
                  const Q = W.value;
                  return X = X.concat(So({
                    key: W.key,
                    value: Q,
                    valueSpec: W.valueSpec,
                    validateSpec: W.validateSpec,
                    style: W.style,
                    styleSpec: W.styleSpec,
                    arrayElementValidator: D
                  })), ji(Q) === "array" && Q.length === 0 && X.push(new Ke(W.key, Q, "array must have at least one stop")), X
                },
                default: function(W) {
                  return W.validateSpec({
                    key: W.key,
                    value: W.value,
                    valueSpec: t,
                    validateSpec: W.validateSpec,
                    style: W.style,
                    styleSpec: W.styleSpec
                  })
                }
              }
            });
          return r === "identity" && v && C.push(new Ke(i.key, i.value, 'missing required property "property"')), r === "identity" || i.value.stops || C.push(new Ke(i.key, i.value, 'missing required property "stops"')), r === "exponential" && i.valueSpec.expression && !tu(i.valueSpec) && C.push(new Ke(i.key, i.value, "exponential functions not supported")), i.styleSpec.$version >= 8 && (b && !To(i.valueSpec) ? C.push(new Ke(i.key, i.value, "property functions not supported")) : v && !Qh(i.valueSpec) && C.push(new Ke(i.key, i.value, "zoom functions not supported"))), r !== "categorical" && !M || i.value.property !== void 0 || C.push(new Ke(i.key, i.value, '"property" property is required')), C;

          function D(W) {
            let X = [];
            const Q = W.value,
              le = W.key;
            if (ji(Q) !== "array") return [new Ke(le, Q, `array expected, ${ji(Q)} found`)];
            if (Q.length !== 2) return [new Ke(le, Q, `array length 2 expected, length ${Q.length} found`)];
            if (M) {
              if (ji(Q[0]) !== "object") return [new Ke(le, Q, `object expected, ${ji(Q[0])} found`)];
              if (Q[0].zoom === void 0) return [new Ke(le, Q, "object stop key must have zoom")];
              if (Q[0].value === void 0) return [new Ke(le, Q, "object stop key must have value")];
              if (f && f > ga(Q[0].zoom)) return [new Ke(le, Q[0].zoom, "stop zoom values must appear in ascending order")];
              ga(Q[0].zoom) !== f && (f = ga(Q[0].zoom), c = void 0, m = {}), X = X.concat(fn({
                key: `${le}[0]`,
                value: Q[0],
                valueSpec: {
                  zoom: {}
                },
                validateSpec: W.validateSpec,
                style: W.style,
                styleSpec: W.styleSpec,
                objectElementValidators: {
                  zoom: Hl,
                  value: N
                }
              }))
            } else X = X.concat(N({
              key: `${le}[0]`,
              value: Q[0],
              validateSpec: W.validateSpec,
              style: W.style,
              styleSpec: W.styleSpec
            }, Q));
            return jl(us(Q[1])) ? X.concat([new Ke(`${le}[1]`, Q[1], "expressions are not allowed in function stops.")]) : X.concat(W.validateSpec({
              key: `${le}[1]`,
              value: Q[1],
              valueSpec: t,
              validateSpec: W.validateSpec,
              style: W.style,
              styleSpec: W.styleSpec
            }))
          }

          function N(W, X) {
            const Q = ji(W.value),
              le = ga(W.value),
              we = W.value !== null ? W.value : X;
            if (n) {
              if (Q !== n) return [new Ke(W.key, we, `${Q} stop domain type must match previous stop domain type ${n}`)]
            } else n = Q;
            if (Q !== "number" && Q !== "string" && Q !== "boolean") return [new Ke(W.key, we, "stop domain value must be a number, string, or boolean")];
            if (Q !== "number" && r !== "categorical") {
              let et = `number expected, ${Q} found`;
              return To(t) && r === void 0 && (et += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new Ke(W.key, we, et)]
            }
            return r !== "categorical" || Q !== "number" || isFinite(le) && Math.floor(le) === le ? r !== "categorical" && Q === "number" && c !== void 0 && le < c ? [new Ke(W.key, we, "stop domain values must appear in ascending order")] : (c = le, r === "categorical" && le in m ? [new Ke(W.key, we, "stop domain values must be unique")] : (m[le] = !0, [])) : [new Ke(W.key, we, `integer expected, found ${le}`)]
          }
        }

        function Po(i) {
          const t = (i.expressionContext === "property" ? id : Gs)(us(i.value), i.valueSpec);
          if (t.result === "error") return t.value.map((n => new Ke(`${i.key}${n.key}`, i.value, n.message)));
          const r = t.value.expression || t.value._styleExpression.expression;
          if (i.expressionContext === "property" && i.propertyKey === "text-font" && !r.outputDefined()) return [new Ke(i.key, i.value, `Invalid data expression for "${i.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (i.expressionContext === "property" && i.propertyType === "layout" && !Ko(r)) return [new Ke(i.key, i.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (i.expressionContext === "filter" && !Ko(r)) return [new Ke(i.key, i.value, '"feature-state" data expressions are not supported with filters.')];
          if (i.expressionContext && i.expressionContext.indexOf("cluster") === 0) {
            if (!Bl(r, ["zoom", "feature-state"])) return [new Ke(i.key, i.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (i.expressionContext === "cluster-initial" && !Fl(r)) return [new Ke(i.key, i.value, "Feature data expressions are not supported with initial expression part of cluster properties.")]
          }
          return []
        }

        function su(i) {
          const t = i.key,
            r = i.value,
            n = ji(r);
          return n !== "string" ? [new Ke(t, r, `color expected, ${n} found`)] : Ar.parse(String(r)) ? [] : [new Ke(t, r, `color expected, "${r}" found`)]
        }

        function el(i) {
          const t = i.key,
            r = i.value,
            n = i.valueSpec,
            c = [];
          return Array.isArray(n.values) ? n.values.indexOf(ga(r)) === -1 && c.push(new Ke(t, r, `expected one of [${n.values.join(", ")}], ${JSON.stringify(r)} found`)) : Object.keys(n.values).indexOf(ga(r)) === -1 && c.push(new Ke(t, r, `expected one of [${Object.keys(n.values).join(", ")}], ${JSON.stringify(r)} found`)), c
        }

        function ou(i) {
          return Ul(us(i.value)) ? Po(Tt({}, i, {
            expressionContext: "filter",
            valueSpec: {
              value: "boolean"
            }
          })) : lu(i)
        }

        function lu(i) {
          const t = i.value,
            r = i.key;
          if (ji(t) !== "array") return [new Ke(r, t, `array expected, ${ji(t)} found`)];
          const n = i.styleSpec;
          let c, f = [];
          if (t.length < 1) return [new Ke(r, t, "filter array must have at least 1 element")];
          switch (f = f.concat(el({
              key: `${r}[0]`,
              value: t[0],
              valueSpec: n.filter_operator,
              style: i.style,
              styleSpec: i.styleSpec
            })), ga(t[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              t.length >= 2 && ga(t[1]) === "$type" && f.push(new Ke(r, t, `"$type" cannot be use with operator "${t[0]}"`));
            case "==":
            case "!=":
              t.length !== 3 && f.push(new Ke(r, t, `filter array for operator "${t[0]}" must have 3 elements`));
            case "in":
            case "!in":
              t.length >= 2 && (c = ji(t[1]), c !== "string" && f.push(new Ke(`${r}[1]`, t[1], `string expected, ${c} found`)));
              for (let m = 2; m < t.length; m++) c = ji(t[m]), ga(t[1]) === "$type" ? f = f.concat(el({
                key: `${r}[${m}]`,
                value: t[m],
                valueSpec: n.geometry_type,
                style: i.style,
                styleSpec: i.styleSpec
              })) : c !== "string" && c !== "number" && c !== "boolean" && f.push(new Ke(`${r}[${m}]`, t[m], `string, number, or boolean expected, ${c} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let m = 1; m < t.length; m++) f = f.concat(lu({
                key: `${r}[${m}]`,
                value: t[m],
                style: i.style,
                styleSpec: i.styleSpec
              }));
              break;
            case "has":
            case "!has":
              c = ji(t[1]), t.length !== 2 ? f.push(new Ke(r, t, `filter array for "${t[0]}" operator must have 2 elements`)) : c !== "string" && f.push(new Ke(`${r}[1]`, t[1], `string expected, ${c} found`))
          }
          return f
        }

        function cu(i, t) {
          const r = i.key,
            n = i.validateSpec,
            c = i.style,
            f = i.styleSpec,
            m = i.value,
            v = i.objectKey,
            b = f[`${t}_${i.layerType}`];
          if (!b) return [];
          const M = v.match(/^(.*)-transition$/);
          if (t === "paint" && M && b[M[1]] && b[M[1]].transition) return n({
            key: r,
            value: m,
            valueSpec: f.transition,
            style: c,
            styleSpec: f
          });
          const C = i.valueSpec || b[v];
          if (!C) return [new Ke(r, m, `unknown property "${v}"`)];
          let D;
          if (ji(m) === "string" && To(C) && !C.tokens && (D = /^{([^}]+)}$/.exec(m))) return [new Ke(r, m, `"${v}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(D[1])} }\`.`)];
          const N = [];
          return i.layerType === "symbol" && v === "text-font" && Ol(us(m)) && ga(m.type) === "identity" && N.push(new Ke(r, m, '"text-font" does not support identity functions')), N.concat(n({
            key: i.key,
            value: m,
            valueSpec: C,
            style: c,
            styleSpec: f,
            expressionContext: "property",
            propertyType: t,
            propertyKey: v
          }))
        }

        function tl(i) {
          return cu(i, "paint")
        }

        function cd(i) {
          return cu(i, "layout")
        }

        function uu(i) {
          let t = [];
          const r = i.value,
            n = i.key,
            c = i.style,
            f = i.styleSpec;
          if (ji(r) !== "object") return [new Ke(n, r, `object expected, ${ji(r)} found`)];
          r.type || r.ref || t.push(new Ke(n, r, 'either "type" or "ref" is required'));
          let m = ga(r.type);
          const v = ga(r.ref);
          if (r.id) {
            const b = ga(r.id);
            for (let M = 0; M < i.arrayIndex; M++) {
              const C = c.layers[M];
              ga(C.id) === b && t.push(new Ke(n, r.id, `duplicate layer id "${r.id}", previously used at line ${C.id.__line__}`))
            }
          }
          if ("ref" in r) {
            let b;
            ["type", "source", "source-layer", "filter", "layout"].forEach((M => {
              M in r && t.push(new Ke(n, r[M], `"${M}" is prohibited for ref layers`))
            })), c.layers.forEach((M => {
              ga(M.id) === v && (b = M)
            })), b ? b.ref ? t.push(new Ke(n, r.ref, "ref cannot reference another ref layer")) : m = ga(b.type) : t.push(new Ke(n, r.ref, `ref layer "${v}" not found`))
          } else if (m !== "background")
            if (r.source) {
              const b = c.sources && c.sources[r.source],
                M = b && ga(b.type);
              b ? M === "vector" && m === "raster" ? t.push(new Ke(n, r.source, `layer "${r.id}" requires a raster source`)) : M !== "raster-dem" && m === "hillshade" || M !== "raster-dem" && m === "color-relief" ? t.push(new Ke(n, r.source, `layer "${r.id}" requires a raster-dem source`)) : M === "raster" && m !== "raster" ? t.push(new Ke(n, r.source, `layer "${r.id}" requires a vector source`)) : M !== "vector" || r["source-layer"] ? M === "raster-dem" && m !== "hillshade" && m !== "color-relief" ? t.push(new Ke(n, r.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : m !== "line" || !r.paint || !r.paint["line-gradient"] || M === "geojson" && b.lineMetrics || t.push(new Ke(n, r, `layer "${r.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new Ke(n, r, `layer "${r.id}" must specify a "source-layer"`)) : t.push(new Ke(n, r.source, `source "${r.source}" not found`))
            } else t.push(new Ke(n, r, 'missing required property "source"'));
          return t = t.concat(fn({
            key: n,
            value: r,
            valueSpec: f.layer,
            style: i.style,
            styleSpec: i.styleSpec,
            validateSpec: i.validateSpec,
            objectElementValidators: {
              "*": () => [],
              type: () => i.validateSpec({
                key: `${n}.type`,
                value: r.type,
                valueSpec: f.layer.type,
                style: i.style,
                styleSpec: i.styleSpec,
                validateSpec: i.validateSpec,
                object: r,
                objectKey: "type"
              }),
              filter: ou,
              layout: b => fn({
                layer: r,
                key: b.key,
                value: b.value,
                style: b.style,
                styleSpec: b.styleSpec,
                validateSpec: b.validateSpec,
                objectElementValidators: {
                  "*": M => cd(Tt({
                    layerType: m
                  }, M))
                }
              }),
              paint: b => fn({
                layer: r,
                key: b.key,
                value: b.value,
                style: b.style,
                styleSpec: b.styleSpec,
                validateSpec: b.validateSpec,
                objectElementValidators: {
                  "*": M => tl(Tt({
                    layerType: m
                  }, M))
                }
              })
            }
          })), t
        }

        function Ms(i) {
          const t = i.value,
            r = i.key,
            n = ji(t);
          return n !== "string" ? [new Ke(r, t, `string expected, ${n} found`)] : []
        }
        const ud = {
          promoteId: function({
            key: i,
            value: t
          }) {
            if (ji(t) === "string") return Ms({
              key: i,
              value: t
            });
            {
              const r = [];
              for (const n in t) r.push(...Ms({
                key: `${i}.${n}`,
                value: t[n]
              }));
              return r
            }
          }
        };

        function hu(i) {
          const t = i.value,
            r = i.key,
            n = i.styleSpec,
            c = i.style,
            f = i.validateSpec;
          if (!t.type) return [new Ke(r, t, '"type" is required')];
          const m = ga(t.type);
          let v;
          switch (m) {
            case "vector":
            case "raster":
              return v = fn({
                key: r,
                value: t,
                valueSpec: n[`source_${m.replace("-","_")}`],
                style: i.style,
                styleSpec: n,
                objectElementValidators: ud,
                validateSpec: f
              }), v;
            case "raster-dem":
              return v = (function(b) {
                var M;
                const C = (M = b.sourceName) !== null && M !== void 0 ? M : "",
                  D = b.value,
                  N = b.styleSpec,
                  W = N.source_raster_dem,
                  X = b.style;
                let Q = [];
                const le = ji(D);
                if (D === void 0) return Q;
                if (le !== "object") return Q.push(new Ke("source_raster_dem", D, `object expected, ${le} found`)), Q;
                const we = ga(D.encoding) === "custom",
                  et = ["redFactor", "greenFactor", "blueFactor", "baseShift"],
                  De = b.value.encoding ? `"${b.value.encoding}"` : "Default";
                for (const Ze in D) !we && et.includes(Ze) ? Q.push(new Ke(Ze, D[Ze], `In "${C}": "${Ze}" is only valid when "encoding" is set to "custom". ${De} encoding found`)) : W[Ze] ? Q = Q.concat(b.validateSpec({
                  key: Ze,
                  value: D[Ze],
                  valueSpec: W[Ze],
                  validateSpec: b.validateSpec,
                  style: X,
                  styleSpec: N
                })) : Q.push(new Ke(Ze, D[Ze], `unknown property "${Ze}"`));
                return Q
              })({
                sourceName: r,
                value: t,
                style: i.style,
                styleSpec: n,
                validateSpec: f
              }), v;
            case "geojson":
              if (v = fn({
                  key: r,
                  value: t,
                  valueSpec: n.source_geojson,
                  style: c,
                  styleSpec: n,
                  validateSpec: f,
                  objectElementValidators: ud
                }), t.cluster)
                for (const b in t.clusterProperties) {
                  const [M, C] = t.clusterProperties[b], D = typeof M == "string" ? [M, ["accumulated"],
                    ["get", b]
                  ] : M;
                  v.push(...Po({
                    key: `${r}.${b}.map`,
                    value: C,
                    expressionContext: "cluster-map"
                  })), v.push(...Po({
                    key: `${r}.${b}.reduce`,
                    value: D,
                    expressionContext: "cluster-reduce"
                  }))
                }
              return v;
            case "video":
              return fn({
                key: r,
                value: t,
                valueSpec: n.source_video,
                style: c,
                validateSpec: f,
                styleSpec: n
              });
            case "image":
              return fn({
                key: r,
                value: t,
                valueSpec: n.source_image,
                style: c,
                validateSpec: f,
                styleSpec: n
              });
            case "canvas":
              return [new Ke(r, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return el({
                key: `${r}.type`,
                value: t.type,
                valueSpec: {
                  values: ["vector", "raster", "raster-dem", "geojson", "video", "image"]
                }
              })
          }
        }

        function du(i) {
          const t = i.value,
            r = i.styleSpec,
            n = r.light,
            c = i.style;
          let f = [];
          const m = ji(t);
          if (t === void 0) return f;
          if (m !== "object") return f = f.concat([new Ke("light", t, `object expected, ${m} found`)]), f;
          for (const v in t) {
            const b = v.match(/^(.*)-transition$/);
            f = f.concat(b && n[b[1]] && n[b[1]].transition ? i.validateSpec({
              key: v,
              value: t[v],
              valueSpec: r.transition,
              validateSpec: i.validateSpec,
              style: c,
              styleSpec: r
            }) : n[v] ? i.validateSpec({
              key: v,
              value: t[v],
              valueSpec: n[v],
              validateSpec: i.validateSpec,
              style: c,
              styleSpec: r
            }) : [new Ke(v, t[v], `unknown property "${v}"`)])
          }
          return f
        }

        function Io(i) {
          const t = i.value,
            r = i.styleSpec,
            n = r.sky,
            c = i.style,
            f = ji(t);
          if (t === void 0) return [];
          if (f !== "object") return [new Ke("sky", t, `object expected, ${f} found`)];
          let m = [];
          for (const v in t) m = m.concat(n[v] ? i.validateSpec({
            key: v,
            value: t[v],
            valueSpec: n[v],
            style: c,
            styleSpec: r
          }) : [new Ke(v, t[v], `unknown property "${v}"`)]);
          return m
        }

        function hd(i) {
          const t = i.value,
            r = i.styleSpec,
            n = r.terrain,
            c = i.style;
          let f = [];
          const m = ji(t);
          if (t === void 0) return f;
          if (m !== "object") return f = f.concat([new Ke("terrain", t, `object expected, ${m} found`)]), f;
          for (const v in t) f = f.concat(n[v] ? i.validateSpec({
            key: v,
            value: t[v],
            valueSpec: n[v],
            validateSpec: i.validateSpec,
            style: c,
            styleSpec: r
          }) : [new Ke(v, t[v], `unknown property "${v}"`)]);
          return f
        }

        function dd(i) {
          let t = [];
          const r = i.value,
            n = i.key;
          if (Array.isArray(r)) {
            const c = [],
              f = [];
            for (const m in r) r[m].id && c.includes(r[m].id) && t.push(new Ke(n, r, `all the sprites' ids must be unique, but ${r[m].id} is duplicated`)), c.push(r[m].id), r[m].url && f.includes(r[m].url) && t.push(new Ke(n, r, `all the sprites' URLs must be unique, but ${r[m].url} is duplicated`)), f.push(r[m].url), t = t.concat(fn({
              key: `${n}[${m}]`,
              value: r[m],
              valueSpec: {
                id: {
                  type: "string",
                  required: !0
                },
                url: {
                  type: "string",
                  required: !0
                }
              },
              validateSpec: i.validateSpec
            }));
            return t
          }
          return Ms({
            key: n,
            value: r
          })
        }

        function pd(i) {
          return t = i.value, t && t.constructor === Object ? [] : [new Ke(i.key, i.value, `object expected, ${ji(i.value)} found`)];
          var t
        }
        const fd = {
          "*": () => [],
          array: So,
          boolean: function(i) {
            const t = i.value,
              r = i.key,
              n = ji(t);
            return n !== "boolean" ? [new Ke(r, t, `boolean expected, ${n} found`)] : []
          },
          number: Hl,
          color: su,
          constants: Wl,
          enum: el,
          filter: ou,
          function: ld,
          layer: uu,
          object: fn,
          source: hu,
          light: du,
          sky: Io,
          terrain: hd,
          projection: function(i) {
            const t = i.value,
              r = i.styleSpec,
              n = r.projection,
              c = i.style,
              f = ji(t);
            if (t === void 0) return [];
            if (f !== "object") return [new Ke("projection", t, `object expected, ${f} found`)];
            let m = [];
            for (const v in t) m = m.concat(n[v] ? i.validateSpec({
              key: v,
              value: t[v],
              valueSpec: n[v],
              style: c,
              styleSpec: r
            }) : [new Ke(v, t[v], `unknown property "${v}"`)]);
            return m
          },
          projectionDefinition: function(i) {
            const t = i.key;
            let r = i.value;
            r = r instanceof String ? r.valueOf() : r;
            const n = ji(r);
            return n !== "array" || (function(c) {
              return Array.isArray(c) && c.length === 3 && typeof c[0] == "string" && typeof c[1] == "string" && typeof c[2] == "number"
            })(r) || (function(c) {
              return !!["interpolate", "step", "literal"].includes(c[0])
            })(r) ? ["array", "string"].includes(n) ? [] : [new Ke(t, r, `projection expected, invalid type "${n}" found`)] : [new Ke(t, r, `projection expected, invalid array ${JSON.stringify(r)} found`)]
          },
          string: Ms,
          formatted: function(i) {
            return Ms(i).length === 0 ? [] : Po(i)
          },
          resolvedImage: function(i) {
            return Ms(i).length === 0 ? [] : Po(i)
          },
          padding: function(i) {
            const t = i.key,
              r = i.value;
            if (ji(r) === "array") {
              if (r.length < 1 || r.length > 4) return [new Ke(t, r, `padding requires 1 to 4 values; ${r.length} values found`)];
              const n = {
                type: "number"
              };
              let c = [];
              for (let f = 0; f < r.length; f++) c = c.concat(i.validateSpec({
                key: `${t}[${f}]`,
                value: r[f],
                validateSpec: i.validateSpec,
                valueSpec: n
              }));
              return c
            }
            return Hl({
              key: t,
              value: r,
              valueSpec: {}
            })
          },
          numberArray: function(i) {
            const t = i.key,
              r = i.value;
            if (ji(r) === "array") {
              const n = {
                type: "number"
              };
              if (r.length < 1) return [new Ke(t, r, "array length at least 1 expected, length 0 found")];
              let c = [];
              for (let f = 0; f < r.length; f++) c = c.concat(i.validateSpec({
                key: `${t}[${f}]`,
                value: r[f],
                validateSpec: i.validateSpec,
                valueSpec: n
              }));
              return c
            }
            return Hl({
              key: t,
              value: r,
              valueSpec: {}
            })
          },
          colorArray: function(i) {
            const t = i.key,
              r = i.value;
            if (ji(r) === "array") {
              if (r.length < 1) return [new Ke(t, r, "array length at least 1 expected, length 0 found")];
              let n = [];
              for (let c = 0; c < r.length; c++) n = n.concat(su({
                key: `${t}[${c}]`,
                value: r[c]
              }));
              return n
            }
            return su({
              key: t,
              value: r
            })
          },
          variableAnchorOffsetCollection: function(i) {
            const t = i.key,
              r = i.value,
              n = ji(r),
              c = i.styleSpec;
            if (n !== "array" || r.length < 1 || r.length % 2 != 0) return [new Ke(t, r, "variableAnchorOffsetCollection requires a non-empty array of even length")];
            let f = [];
            for (let m = 0; m < r.length; m += 2) f = f.concat(el({
              key: `${t}[${m}]`,
              value: r[m],
              valueSpec: c.layout_symbol["text-anchor"]
            })), f = f.concat(So({
              key: `${t}[${m+1}]`,
              value: r[m + 1],
              valueSpec: {
                length: 2,
                value: "number"
              },
              validateSpec: i.validateSpec,
              style: i.style,
              styleSpec: c
            }));
            return f
          },
          sprite: dd,
          state: pd
        };

        function Xl(i) {
          const t = i.value,
            r = i.valueSpec,
            n = i.styleSpec;
          return i.validateSpec = Xl, r.expression && Ol(ga(t)) ? ld(i) : r.expression && jl(us(t)) ? Po(i) : r.type && fd[r.type] ? fd[r.type](i) : fn(Tt({}, i, {
            valueSpec: r.type ? n[r.type] : r
          }))
        }

        function md(i) {
          const t = i.value,
            r = i.key,
            n = Ms(i);
          return n.length || (t.indexOf("{fontstack}") === -1 && n.push(new Ke(r, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf("{range}") === -1 && n.push(new Ke(r, t, '"glyphs" url must include a "{range}" token'))), n
        }

        function rn(i, t = Y) {
          let r = [];
          return r = r.concat(Xl({
            key: "",
            value: i,
            valueSpec: t.$root,
            styleSpec: t,
            style: i,
            validateSpec: Xl,
            objectElementValidators: {
              glyphs: md,
              "*": () => []
            }
          })), i.constants && (r = r.concat(Wl({
            key: "constants",
            value: i.constants
          }))), mn(r)
        }

        function on(i) {
          return function(t) {
            return i(Object.assign({}, t, {
              validateSpec: Xl
            }))
          }
        }

        function mn(i) {
          return [].concat(i).sort(((t, r) => t.line - r.line))
        }

        function ln(i) {
          return function(...t) {
            return mn(i.apply(this, t))
          }
        }
        rn.source = ln(on(hu)), rn.sprite = ln(on(dd)), rn.glyphs = ln(on(md)), rn.light = ln(on(du)), rn.sky = ln(on(Io)), rn.terrain = ln(on(hd)), rn.state = ln(on(pd)), rn.layer = ln(on(uu)), rn.filter = ln(on(ou)), rn.paintProperty = ln(on(tl)), rn.layoutProperty = ln(on(cd));
        const gd = Y,
          Mo = rn,
          of = Mo.light,
          rl = Mo.sky,
          _d = Mo.paintProperty,
          pu = Mo.layoutProperty;

        function vd(i, t) {
          let r = !1;
          if (t && t.length)
            for (const n of t) i.fire(new ve(new Error(n.message))), r = !0;
          return r
        }
        class Hs {
          constructor(t, r, n) {
            const c = this.cells = [];
            if (t instanceof ArrayBuffer) {
              this.arrayBuffer = t;
              const m = new Int32Array(this.arrayBuffer);
              t = m[0], this.d = (r = m[1]) + 2 * (n = m[2]);
              for (let b = 0; b < this.d * this.d; b++) {
                const M = m[3 + b],
                  C = m[3 + b + 1];
                c.push(M === C ? null : m.subarray(M, C))
              }
              const v = m[3 + c.length + 1];
              this.keys = m.subarray(m[3 + c.length], v), this.bboxes = m.subarray(v), this.insert = this._insertReadonly
            } else {
              this.d = r + 2 * n;
              for (let m = 0; m < this.d * this.d; m++) c.push([]);
              this.keys = [], this.bboxes = []
            }
            this.n = r, this.extent = t, this.padding = n, this.scale = r / t, this.uid = 0;
            const f = n / r * t;
            this.min = -f, this.max = t + f
          }
          insert(t, r, n, c, f) {
            this._forEachCell(r, n, c, f, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t), this.bboxes.push(r), this.bboxes.push(n), this.bboxes.push(c), this.bboxes.push(f)
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.")
          }
          _insertCell(t, r, n, c, f, m) {
            this.cells[f].push(m)
          }
          query(t, r, n, c, f) {
            const m = this.min,
              v = this.max;
            if (t <= m && r <= m && v <= n && v <= c && !f) return Array.prototype.slice.call(this.keys);
            {
              const b = [];
              return this._forEachCell(t, r, n, c, this._queryCell, b, {}, f), b
            }
          }
          _queryCell(t, r, n, c, f, m, v, b) {
            const M = this.cells[f];
            if (M !== null) {
              const C = this.keys,
                D = this.bboxes;
              for (let N = 0; N < M.length; N++) {
                const W = M[N];
                if (v[W] === void 0) {
                  const X = 4 * W;
                  (b ? b(D[X + 0], D[X + 1], D[X + 2], D[X + 3]) : t <= D[X + 2] && r <= D[X + 3] && n >= D[X + 0] && c >= D[X + 1]) ? (v[W] = !0, m.push(C[W])) : v[W] = !1
                }
              }
            }
          }
          _forEachCell(t, r, n, c, f, m, v, b) {
            const M = this._convertToCellCoord(t),
              C = this._convertToCellCoord(r),
              D = this._convertToCellCoord(n),
              N = this._convertToCellCoord(c);
            for (let W = M; W <= D; W++)
              for (let X = C; X <= N; X++) {
                const Q = this.d * X + W;
                if ((!b || b(this._convertFromCellCoord(W), this._convertFromCellCoord(X), this._convertFromCellCoord(W + 1), this._convertFromCellCoord(X + 1))) && f.call(this, t, r, n, c, Q, m, v, b)) return
              }
          }
          _convertFromCellCoord(t) {
            return (t - this.padding) / this.scale
          }
          _convertToCellCoord(t) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding))
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const t = this.cells,
              r = 3 + this.cells.length + 1 + 1;
            let n = 0;
            for (let m = 0; m < this.cells.length; m++) n += this.cells[m].length;
            const c = new Int32Array(r + n + this.keys.length + this.bboxes.length);
            c[0] = this.extent, c[1] = this.n, c[2] = this.padding;
            let f = r;
            for (let m = 0; m < t.length; m++) {
              const v = t[m];
              c[3 + m] = f, c.set(v, f), f += v.length
            }
            return c[3 + t.length] = f, c.set(this.keys, f), f += this.keys.length, c[3 + t.length + 1] = f, c.set(this.bboxes, f), f += this.bboxes.length, c.buffer
          }
          static serialize(t, r) {
            const n = t.toArrayBuffer();
            return r && r.push(n), {
              buffer: n
            }
          }
          static deserialize(t) {
            return new Hs(t.buffer)
          }
        }
        const hs = {};

        function zr(i, t, r = {}) {
          if (hs[i]) throw new Error(`${i} is already registered.`);
          Object.defineProperty(t, "_classRegistryKey", {
            value: i,
            writeable: !1
          }), hs[i] = {
            klass: t,
            omit: r.omit || [],
            shallow: r.shallow || []
          }
        }
        zr("Object", Object), zr("Set", Set), zr("TransferableGridIndex", Hs), zr("Color", Ar), zr("Error", Error), zr("AJAXError", se), zr("ResolvedImage", sa), zr("StylePropertyFunction", ql), zr("StyleExpression", ru, {
          omit: ["_evaluator"]
        }), zr("ZoomDependentExpression", iu), zr("ZoomConstantExpression", Jo), zr("CompoundExpression", Ln, {
          omit: ["_evaluate"]
        });
        for (const i in bo) bo[i]._classRegistryKey || zr(`Expression_${i}`, bo[i]);

        function yd(i) {
          return i && typeof ArrayBuffer < "u" && (i instanceof ArrayBuffer || i.constructor && i.constructor.name === "ArrayBuffer")
        }

        function fu(i) {
          return i.$name || i.constructor._classRegistryKey
        }

        function xd(i) {
          return !(function(t) {
            if (t === null || typeof t != "object") return !1;
            const r = fu(t);
            return !(!r || r === "Object")
          })(i) && (i == null || typeof i == "boolean" || typeof i == "number" || typeof i == "string" || i instanceof Boolean || i instanceof Number || i instanceof String || i instanceof Date || i instanceof RegExp || i instanceof Blob || i instanceof Error || yd(i) || ir(i) || ArrayBuffer.isView(i) || i instanceof ImageData)
        }

        function ds(i, t) {
          if (xd(i)) return (yd(i) || ir(i)) && t && t.push(i), ArrayBuffer.isView(i) && t && t.push(i.buffer), i instanceof ImageData && t && t.push(i.data.buffer), i;
          if (Array.isArray(i)) {
            const f = [];
            for (const m of i) f.push(ds(m, t));
            return f
          }
          if (typeof i != "object") throw new Error("can't serialize object of type " + typeof i);
          const r = fu(i);
          if (!r) throw new Error(`can't serialize object of unregistered class ${i.constructor.name}`);
          if (!hs[r]) throw new Error(`${r} is not registered.`);
          const {
            klass: n
          } = hs[r], c = n.serialize ? n.serialize(i, t) : {};
          if (n.serialize) {
            if (t && c === t[t.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property")
          } else {
            for (const f in i) {
              if (!i.hasOwnProperty(f) || hs[r].omit.indexOf(f) >= 0) continue;
              const m = i[f];
              c[f] = hs[r].shallow.indexOf(f) >= 0 ? m : ds(m, t)
            }
            i instanceof Error && (c.message = i.message)
          }
          if (c.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return r !== "Object" && (c.$name = r), c
        }

        function il(i) {
          if (xd(i)) return i;
          if (Array.isArray(i)) return i.map(il);
          if (typeof i != "object") throw new Error("can't deserialize object of type " + typeof i);
          const t = fu(i) || "Object";
          if (!hs[t]) throw new Error(`can't deserialize unregistered class ${t}`);
          const {
            klass: r
          } = hs[t];
          if (!r) throw new Error(`can't deserialize unregistered class ${t}`);
          if (r.deserialize) return r.deserialize(i);
          const n = Object.create(r.prototype);
          for (const c of Object.keys(i)) {
            if (c === "$name") continue;
            const f = i[c];
            n[c] = hs[t].shallow.indexOf(c) >= 0 ? f : il(f)
          }
          return n
        }
        class mu {
          constructor() {
            this.first = !0
          }
          update(t, r) {
            const n = Math.floor(t);
            return this.first ? (this.first = !1, this.lastIntegerZoom = n, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = n, !0) : (this.lastFloorZoom > n ? (this.lastIntegerZoom = n + 1, this.lastIntegerZoomTime = r) : this.lastFloorZoom < n && (this.lastIntegerZoom = n, this.lastIntegerZoomTime = r), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = n, !0))
          }
        }
        const Bi = {
          "Latin-1 Supplement": i => i >= 128 && i <= 255,
          "Hangul Jamo": i => i >= 4352 && i <= 4607,
          Khmer: i => i >= 6016 && i <= 6143,
          "General Punctuation": i => i >= 8192 && i <= 8303,
          "Letterlike Symbols": i => i >= 8448 && i <= 8527,
          "Number Forms": i => i >= 8528 && i <= 8591,
          "Miscellaneous Technical": i => i >= 8960 && i <= 9215,
          "Control Pictures": i => i >= 9216 && i <= 9279,
          "Optical Character Recognition": i => i >= 9280 && i <= 9311,
          "Enclosed Alphanumerics": i => i >= 9312 && i <= 9471,
          "Geometric Shapes": i => i >= 9632 && i <= 9727,
          "Miscellaneous Symbols": i => i >= 9728 && i <= 9983,
          "Miscellaneous Symbols and Arrows": i => i >= 11008 && i <= 11263,
          "Ideographic Description Characters": i => i >= 12272 && i <= 12287,
          "CJK Symbols and Punctuation": i => i >= 12288 && i <= 12351,
          Hiragana: i => i >= 12352 && i <= 12447,
          Katakana: i => i >= 12448 && i <= 12543,
          Kanbun: i => i >= 12688 && i <= 12703,
          "CJK Strokes": i => i >= 12736 && i <= 12783,
          "Enclosed CJK Letters and Months": i => i >= 12800 && i <= 13055,
          "CJK Compatibility": i => i >= 13056 && i <= 13311,
          "Yijing Hexagram Symbols": i => i >= 19904 && i <= 19967,
          "CJK Unified Ideographs": i => i >= 19968 && i <= 40959,
          "Hangul Syllables": i => i >= 44032 && i <= 55215,
          "Private Use Area": i => i >= 57344 && i <= 63743,
          "Vertical Forms": i => i >= 65040 && i <= 65055,
          "CJK Compatibility Forms": i => i >= 65072 && i <= 65103,
          "Small Form Variants": i => i >= 65104 && i <= 65135,
          "Halfwidth and Fullwidth Forms": i => i >= 65280 && i <= 65519
        };

        function gu(i) {
          for (const t of i)
            if (Yl(t.charCodeAt(0))) return !0;
          return !1
        }

        function _u(i) {
          for (const t of i)
            if (!wd(t.charCodeAt(0))) return !1;
          return !0
        }

        function Co(i) {
          const t = i.map((r => {
            try {
              return new RegExp(`\\p{sc=${r}}`, "u").source
            } catch {
              return null
            }
          })).filter((r => r));
          return new RegExp(t.join("|"), "u")
        }
        const bd = Co(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);

        function wd(i) {
          return !bd.test(String.fromCodePoint(i))
        }
        const vu = Co(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);

        function Yl(i) {
          return !(i !== 746 && i !== 747 && (i < 4352 || !(Bi["CJK Compatibility Forms"](i) && !(i >= 65097 && i <= 65103) || Bi["CJK Compatibility"](i) || Bi["CJK Strokes"](i) || !(!Bi["CJK Symbols and Punctuation"](i) || i >= 12296 && i <= 12305 || i >= 12308 && i <= 12319 || i === 12336) || Bi["Enclosed CJK Letters and Months"](i) || Bi["Ideographic Description Characters"](i) || Bi.Kanbun(i) || Bi.Katakana(i) && i !== 12540 || !(!Bi["Halfwidth and Fullwidth Forms"](i) || i === 65288 || i === 65289 || i === 65293 || i >= 65306 && i <= 65310 || i === 65339 || i === 65341 || i === 65343 || i >= 65371 && i <= 65503 || i === 65507 || i >= 65512 && i <= 65519) || !(!Bi["Small Form Variants"](i) || i >= 65112 && i <= 65118 || i >= 65123 && i <= 65126) || Bi["Vertical Forms"](i) || Bi["Yijing Hexagram Symbols"](i) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(i)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(i)) || vu.test(String.fromCodePoint(i)))))
        }

        function Kl(i) {
          return !(Yl(i) || (function(t) {
            return !!(Bi["Latin-1 Supplement"](t) && (t === 167 || t === 169 || t === 174 || t === 177 || t === 188 || t === 189 || t === 190 || t === 215 || t === 247) || Bi["General Punctuation"](t) && (t === 8214 || t === 8224 || t === 8225 || t === 8240 || t === 8241 || t === 8251 || t === 8252 || t === 8258 || t === 8263 || t === 8264 || t === 8265 || t === 8273) || Bi["Letterlike Symbols"](t) || Bi["Number Forms"](t) || Bi["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || t === 9003 || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || t === 9167 || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || Bi["Control Pictures"](t) && t !== 9251 || Bi["Optical Character Recognition"](t) || Bi["Enclosed Alphanumerics"](t) || Bi["Geometric Shapes"](t) || Bi["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || Bi["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || Bi["CJK Symbols and Punctuation"](t) || Bi.Katakana(t) || Bi["Private Use Area"](t) || Bi["CJK Compatibility Forms"](t) || Bi["Small Form Variants"](t) || Bi["Halfwidth and Fullwidth Forms"](t) || t === 8734 || t === 8756 || t === 8757 || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || t === 65532 || t === 65533)
          })(i))
        }
        const Td = Co(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);

        function Sd(i) {
          return Td.test(String.fromCodePoint(i))
        }

        function Pd(i, t) {
          return !(!t && Sd(i) || i >= 2304 && i <= 3583 || i >= 3840 && i <= 4255 || Bi.Khmer(i))
        }

        function lf(i) {
          for (const t of i)
            if (Sd(t.charCodeAt(0))) return !0;
          return !1
        }
        const ps = new class {
          constructor() {
            this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {}
          }
          setState(i) {
            this.pluginStatus = i.pluginStatus, this.pluginURL = i.pluginURL
          }
          getState() {
            return {
              pluginStatus: this.pluginStatus,
              pluginURL: this.pluginURL
            }
          }
          setMethods(i) {
            if (ps.isParsed()) throw new Error("RTL text plugin already registered.");
            this.applyArabicShaping = i.applyArabicShaping, this.processBidirectionalText = i.processBidirectionalText, this.processStyledBidirectionalText = i.processStyledBidirectionalText, this.loadScriptResolve()
          }
          isParsed() {
            return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus
          }
          syncState(i, t) {
            return s(this, void 0, void 0, (function*() {
              if (this.isParsed()) return this.getState();
              if (i.pluginStatus !== "loading") return this.setState(i), i;
              const r = i.pluginURL,
                n = new Promise((f => {
                  this.loadScriptResolve = f
                }));
              t(r);
              const c = new Promise((f => setTimeout((() => f()), this.TIMEOUT)));
              if (yield Promise.race([n, c]), this.isParsed()) {
                const f = {
                  pluginStatus: "loaded",
                  pluginURL: r
                };
                return this.setState(f), f
              }
              throw this.setState({
                pluginStatus: "error",
                pluginURL: ""
              }), new Error(`RTL Text Plugin failed to import scripts from ${r}`)
            }))
          }
        };
        class ta {
          constructor(t, r) {
            this.isSupportedScript = Id, this.zoom = t, r ? (this.now = r.now || 0, this.fadeDuration = r.fadeDuration || 0, this.zoomHistory = r.zoomHistory || new mu, this.transition = r.transition || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new mu, this.transition = {})
          }
          crossFadingFactor() {
            return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1)
          }
          getCrossfadeParameters() {
            const t = this.zoom,
              r = t - Math.floor(t),
              n = this.crossFadingFactor();
            return t > this.zoomHistory.lastIntegerZoom ? {
              fromScale: 2,
              toScale: 1,
              t: r + (1 - r) * n
            } : {
              fromScale: .5,
              toScale: 1,
              t: 1 - (1 - n) * r
            }
          }
        }

        function Id(i) {
          return (function(t, r) {
            for (const n of t)
              if (!Pd(n.charCodeAt(0), r)) return !1;
            return !0
          })(i, ps.getRTLTextPluginStatus() === "loaded")
        }
        class al {
          constructor(t, r, n) {
            this.property = t, this.value = r, this.expression = (function(c, f, m) {
              if (Ol(c)) return new ql(c, f);
              if (jl(c)) {
                const v = id(c, f, m);
                if (v.result === "error") throw new Error(v.value.map((b => `${b.key}: ${b.message}`)).join(", "));
                return v.value
              } {
                let v = c;
                return f.type === "color" && typeof c == "string" ? v = Ar.parse(c) : f.type !== "padding" || typeof c != "number" && !Array.isArray(c) ? f.type !== "numberArray" || typeof c != "number" && !Array.isArray(c) ? f.type !== "colorArray" || typeof c != "string" && !Array.isArray(c) ? f.type === "variableAnchorOffsetCollection" && Array.isArray(c) ? v = Yi.parse(c) : f.type === "projectionDefinition" && typeof c == "string" && (v = ua.parse(c)) : v = yi.parse(c) : v = zi.parse(c) : v = ki.parse(c), {
                  globalStateRefs: new Set,
                  _globalState: null,
                  kind: "constant",
                  evaluate: () => v
                }
              }
            })(r === void 0 ? t.specification.default : r, t.specification, n)
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite"
          }
          getGlobalStateRefs() {
            return this.expression.globalStateRefs || new Set
          }
          possiblyEvaluate(t, r, n) {
            return this.property.possiblyEvaluate(this, t, r, n)
          }
        }
        class yu {
          constructor(t, r) {
            this.property = t, this.value = new al(t, void 0, r)
          }
          transitioned(t, r) {
            return new xu(this.property, this.value, r, ht({}, t.transition, this.transition), t.now)
          }
          untransitioned() {
            return new xu(this.property, this.value, null, {}, 0)
          }
        }
        class Md {
          constructor(t, r) {
            this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues), this._globalState = r
          }
          getValue(t) {
            return jt(this._values[t].value.value)
          }
          setValue(t, r) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new yu(this._values[t].property, this._globalState)), this._values[t].value = new al(this._values[t].property, r === null ? void 0 : jt(r), this._globalState)
          }
          getTransition(t) {
            return jt(this._values[t].transition)
          }
          setTransition(t, r) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new yu(this._values[t].property, this._globalState)), this._values[t].transition = jt(r) || void 0
          }
          serialize() {
            const t = {};
            for (const r of Object.keys(this._values)) {
              const n = this.getValue(r);
              n !== void 0 && (t[r] = n);
              const c = this.getTransition(r);
              c !== void 0 && (t[`${r}-transition`] = c)
            }
            return t
          }
          transitioned(t, r) {
            const n = new bu(this._properties);
            for (const c of Object.keys(this._values)) n._values[c] = this._values[c].transitioned(t, r._values[c]);
            return n
          }
          untransitioned() {
            const t = new bu(this._properties);
            for (const r of Object.keys(this._values)) t._values[r] = this._values[r].untransitioned();
            return t
          }
        }
        class xu {
          constructor(t, r, n, c, f) {
            this.property = t, this.value = r, this.begin = f + c.delay || 0, this.end = this.begin + c.duration || 0, t.specification.transition && (c.delay || c.duration) && (this.prior = n)
          }
          possiblyEvaluate(t, r, n) {
            const c = t.now || 0,
              f = this.value.possiblyEvaluate(t, r, n),
              m = this.prior;
            if (m) {
              if (c > this.end) return this.prior = null, f;
              if (this.value.isDataDriven()) return this.prior = null, f;
              if (c < this.begin) return m.possiblyEvaluate(t, r, n);
              {
                const v = (c - this.begin) / (this.end - this.begin);
                return this.property.interpolate(m.possiblyEvaluate(t, r, n), f, wt(v))
              }
            }
            return f
          }
        }
        class bu {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues)
          }
          possiblyEvaluate(t, r, n) {
            const c = new Xs(this._properties);
            for (const f of Object.keys(this._values)) c._values[f] = this._values[f].possiblyEvaluate(t, r, n);
            return c
          }
          hasTransition() {
            for (const t of Object.keys(this._values))
              if (this._values[t].prior) return !0;
            return !1
          }
        }
        class Cd {
          constructor(t, r) {
            this._properties = t, this._values = Object.create(t.defaultPropertyValues), this._globalState = r
          }
          hasValue(t) {
            return this._values[t].value !== void 0
          }
          getValue(t) {
            return jt(this._values[t].value)
          }
          setValue(t, r) {
            this._values[t] = new al(this._values[t].property, r === null ? void 0 : jt(r), this._globalState)
          }
          serialize() {
            const t = {};
            for (const r of Object.keys(this._values)) {
              const n = this.getValue(r);
              n !== void 0 && (t[r] = n)
            }
            return t
          }
          possiblyEvaluate(t, r, n) {
            const c = new Xs(this._properties);
            for (const f of Object.keys(this._values)) c._values[f] = this._values[f].possiblyEvaluate(t, r, n);
            return c
          }
        }
        class Un {
          constructor(t, r, n) {
            this.property = t, this.value = r, this.parameters = n
          }
          isConstant() {
            return this.value.kind === "constant"
          }
          constantOr(t) {
            return this.value.kind === "constant" ? this.value.value : t
          }
          evaluate(t, r, n, c) {
            return this.property.evaluate(this.value, this.parameters, t, r, n, c)
          }
        }
        class Xs {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues)
          }
          get(t) {
            return this._values[t]
          }
        }
        class Xr {
          constructor(t) {
            this.specification = t
          }
          possiblyEvaluate(t, r) {
            if (t.isDataDriven()) throw new Error("Value should not be data driven");
            return t.expression.evaluate(r)
          }
          interpolate(t, r, n) {
            const c = En[this.specification.type];
            return c ? c(t, r, n) : t
          }
        }
        class hi {
          constructor(t, r) {
            this.specification = t, this.overrides = r
          }
          possiblyEvaluate(t, r, n, c) {
            return new Un(this, t.expression.kind === "constant" || t.expression.kind === "camera" ? {
              kind: "constant",
              value: t.expression.evaluate(r, null, {}, n, c)
            } : t.expression, r)
          }
          interpolate(t, r, n) {
            if (t.value.kind !== "constant" || r.value.kind !== "constant") return t;
            if (t.value.value === void 0 || r.value.value === void 0) return new Un(this, {
              kind: "constant",
              value: void 0
            }, t.parameters);
            const c = En[this.specification.type];
            if (c) {
              const f = c(t.value.value, r.value.value, n);
              return new Un(this, {
                kind: "constant",
                value: f
              }, t.parameters)
            }
            return t
          }
          evaluate(t, r, n, c, f, m) {
            return t.kind === "constant" ? t.value : t.evaluate(r, n, c, f, m)
          }
        }
        class nl extends hi {
          possiblyEvaluate(t, r, n, c) {
            if (t.value === void 0) return new Un(this, {
              kind: "constant",
              value: void 0
            }, r);
            if (t.expression.kind === "constant") {
              const f = t.expression.evaluate(r, null, {}, n, c),
                m = t.property.specification.type === "resolvedImage" && typeof f != "string" ? f.name : f,
                v = this._calculate(m, m, m, r);
              return new Un(this, {
                kind: "constant",
                value: v
              }, r)
            }
            if (t.expression.kind === "camera") {
              const f = this._calculate(t.expression.evaluate({
                zoom: r.zoom - 1
              }), t.expression.evaluate({
                zoom: r.zoom
              }), t.expression.evaluate({
                zoom: r.zoom + 1
              }), r);
              return new Un(this, {
                kind: "constant",
                value: f
              }, r)
            }
            return new Un(this, t.expression, r)
          }
          evaluate(t, r, n, c, f, m) {
            if (t.kind === "source") {
              const v = t.evaluate(r, n, c, f, m);
              return this._calculate(v, v, v, r)
            }
            return t.kind === "composite" ? this._calculate(t.evaluate({
              zoom: Math.floor(r.zoom) - 1
            }, n, c), t.evaluate({
              zoom: Math.floor(r.zoom)
            }, n, c), t.evaluate({
              zoom: Math.floor(r.zoom) + 1
            }, n, c), r) : t.value
          }
          _calculate(t, r, n, c) {
            return c.zoom > c.zoomHistory.lastIntegerZoom ? {
              from: t,
              to: r
            } : {
              from: n,
              to: r
            }
          }
          interpolate(t) {
            return t
          }
        }
        class Ad {
          constructor(t) {
            this.specification = t
          }
          possiblyEvaluate(t, r, n, c) {
            if (t.value !== void 0) {
              if (t.expression.kind === "constant") {
                const f = t.expression.evaluate(r, null, {}, n, c);
                return this._calculate(f, f, f, r)
              }
              return this._calculate(t.expression.evaluate(new ta(Math.floor(r.zoom - 1), r)), t.expression.evaluate(new ta(Math.floor(r.zoom), r)), t.expression.evaluate(new ta(Math.floor(r.zoom + 1), r)), r)
            }
          }
          _calculate(t, r, n, c) {
            return c.zoom > c.zoomHistory.lastIntegerZoom ? {
              from: t,
              to: r
            } : {
              from: n,
              to: r
            }
          }
          interpolate(t) {
            return t
          }
        }
        class sl {
          constructor(t) {
            this.specification = t
          }
          possiblyEvaluate(t, r, n, c) {
            return !!t.expression.evaluate(r, null, {}, n, c)
          }
          interpolate() {
            return !1
          }
        }
        class an {
          constructor(t) {
            this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const r in t) {
              const n = t[r];
              n.specification.overridable && this.overridableProperties.push(r);
              const c = this.defaultPropertyValues[r] = new al(n, void 0, void 0),
                f = this.defaultTransitionablePropertyValues[r] = new yu(n, void 0);
              this.defaultTransitioningPropertyValues[r] = f.untransitioned(), this.defaultPossiblyEvaluatedValues[r] = c.possiblyEvaluate({})
            }
          }
        }
        zr("DataDrivenProperty", hi), zr("DataConstantProperty", Xr), zr("CrossFadedDataDrivenProperty", nl), zr("CrossFadedProperty", Ad), zr("ColorRampProperty", sl);
        const wu = "-transition";
        class Zn extends ie {
          constructor(t, r, n) {
            if (super(), this.id = t.id, this.type = t.type, this._globalState = n, this._featureFilter = {
                filter: () => !0,
                needGeometry: !1,
                getGlobalStateRefs: () => new Set
              }, t.type !== "custom" && (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, t.type !== "background" && (this.source = t.source, this.sourceLayer = t["source-layer"], this.filter = t.filter, this._featureFilter = $o(t.filter, n)), r.layout && (this._unevaluatedLayout = new Cd(r.layout, n)), r.paint)) {
              this._transitionablePaint = new Md(r.paint, n);
              for (const c in t.paint) this.setPaintProperty(c, t.paint[c], {
                validate: !1
              });
              for (const c in t.layout) this.setLayoutProperty(c, t.layout[c], {
                validate: !1
              });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Xs(r.paint)
            }
          }
          setFilter(t) {
            this.filter = t, this._featureFilter = $o(t, this._globalState)
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters
          }
          getLayoutProperty(t) {
            return t === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t)
          }
          getLayoutAffectingGlobalStateRefs() {
            const t = new Set;
            if (this._unevaluatedLayout)
              for (const r in this._unevaluatedLayout._values) {
                const n = this._unevaluatedLayout._values[r];
                for (const c of n.getGlobalStateRefs()) t.add(c)
              }
            for (const r of this._featureFilter.getGlobalStateRefs()) t.add(r);
            return t
          }
          getPaintAffectingGlobalStateRefs() {
            var t;
            const r = new globalThis.Map;
            if (this._transitionablePaint)
              for (const n in this._transitionablePaint._values) {
                const c = this._transitionablePaint._values[n].value;
                for (const f of c.getGlobalStateRefs()) {
                  const m = (t = r.get(f)) !== null && t !== void 0 ? t : [];
                  m.push({
                    name: n,
                    value: c.value
                  }), r.set(f, m)
                }
              }
            return r
          }
          setLayoutProperty(t, r, n = {}) {
            r != null && this._validate(pu, `layers.${this.id}.layout.${t}`, t, r, n) || (t !== "visibility" ? this._unevaluatedLayout.setValue(t, r) : this.visibility = r)
          }
          getPaintProperty(t) {
            return t.endsWith(wu) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t)
          }
          setPaintProperty(t, r, n = {}) {
            if (r != null && this._validate(_d, `layers.${this.id}.paint.${t}`, t, r, n)) return !1;
            if (t.endsWith(wu)) return this._transitionablePaint.setTransition(t.slice(0, -11), r || void 0), !1;
            {
              const c = this._transitionablePaint._values[t],
                f = c.property.specification["property-type"] === "cross-faded-data-driven",
                m = c.value.isDataDriven(),
                v = c.value;
              this._transitionablePaint.setValue(t, r), this._handleSpecialPaintPropertyUpdate(t);
              const b = this._transitionablePaint._values[t].value;
              return b.isDataDriven() || m || f || this._handleOverridablePaintPropertyUpdate(t, v, b)
            }
          }
          _handleSpecialPaintPropertyUpdate(t) {}
          _handleOverridablePaintPropertyUpdate(t, r, n) {
            return !1
          }
          isHidden(t, r = !1) {
            return !!(this.minzoom && t < (r ? Math.floor(this.minzoom) : this.minzoom)) || !!(this.maxzoom && t >= this.maxzoom) || this.visibility === "none"
          }
          updateTransitions(t) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint)
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition()
          }
          recalculate(t, r) {
            t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, r)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, r)
          }
          serialize() {
            const t = {
              id: this.id,
              type: this.type,
              source: this.source,
              "source-layer": this.sourceLayer,
              metadata: this.metadata,
              minzoom: this.minzoom,
              maxzoom: this.maxzoom,
              filter: this.filter,
              layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
              paint: this._transitionablePaint && this._transitionablePaint.serialize()
            };
            return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), Jt(t, ((r, n) => !(r === void 0 || n === "layout" && !Object.keys(r).length || n === "paint" && !Object.keys(r).length)))
          }
          _validate(t, r, n, c, f = {}) {
            return (!f || f.validate !== !1) && vd(this, t.call(Mo, {
              key: r,
              layerType: this.type,
              objectKey: n,
              value: c,
              styleSpec: Y,
              style: {
                glyphs: !0,
                sprite: !0
              }
            }))
          }
          is3D() {
            return !1
          }
          isTileClipped() {
            return !1
          }
          hasOffscreenPass() {
            return !1
          }
          resize() {}
          isStateDependent() {
            for (const t in this.paint._values) {
              const r = this.paint.get(t);
              if (r instanceof Un && To(r.property.specification) && (r.value.kind === "source" || r.value.kind === "composite") && r.value.isStateDependent) return !0
            }
            return !1
          }
        }
        let kd;
        var cf = {
          get paint() {
            return kd = kd || new an({
              "raster-opacity": new Xr(Y.paint_raster["raster-opacity"]),
              "raster-hue-rotate": new Xr(Y.paint_raster["raster-hue-rotate"]),
              "raster-brightness-min": new Xr(Y.paint_raster["raster-brightness-min"]),
              "raster-brightness-max": new Xr(Y.paint_raster["raster-brightness-max"]),
              "raster-saturation": new Xr(Y.paint_raster["raster-saturation"]),
              "raster-contrast": new Xr(Y.paint_raster["raster-contrast"]),
              "raster-resampling": new Xr(Y.paint_raster["raster-resampling"]),
              "raster-fade-duration": new Xr(Y.paint_raster["raster-fade-duration"])
            })
          }
        };
        class uf extends Zn {
          constructor(t, r) {
            super(t, cf, r)
          }
        }
        const hf = {
          Int8: Int8Array,
          Uint8: Uint8Array,
          Int16: Int16Array,
          Uint16: Uint16Array,
          Int32: Int32Array,
          Uint32: Uint32Array,
          Float32: Float32Array
        };
        class is {
          constructor(t, r) {
            this._structArray = t, this._pos1 = r * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8
          }
        }
        class _a {
          constructor() {
            this.isTransferred = !1, this.capacity = -1, this.resize(0)
          }
          static serialize(t, r) {
            return t._trim(), r && (t.isTransferred = !0, r.push(t.arrayBuffer)), {
              length: t.length,
              arrayBuffer: t.arrayBuffer
            }
          }
          static deserialize(t) {
            const r = Object.create(this.prototype);
            return r.arrayBuffer = t.arrayBuffer, r.length = t.length, r.capacity = t.arrayBuffer.byteLength / r.bytesPerElement, r._refreshViews(), r
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews())
          }
          clear() {
            this.length = 0
          }
          resize(t) {
            this.reserve(t), this.length = t
          }
          reserve(t) {
            if (t > this.capacity) {
              this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const r = this.uint8;
              this._refreshViews(), r && this.uint8.set(r)
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout")
          }
        }

        function wa(i, t = 1) {
          let r = 0,
            n = 0;
          return {
            members: i.map((c => {
              const f = hf[c.type].BYTES_PER_ELEMENT,
                m = r = zd(r, Math.max(t, f)),
                v = c.components || 1;
              return n = Math.max(n, f), r += f * v, {
                name: c.name,
                type: c.type,
                components: v,
                offset: m
              }
            })),
            size: zd(r, Math.max(n, t)),
            alignment: t
          }
        }

        function zd(i, t) {
          return Math.ceil(i / t) * t
        }
        class Ao extends _a {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t, r)
          }
          emplace(t, r, n) {
            const c = 2 * t;
            return this.int16[c + 0] = r, this.int16[c + 1] = n, t
          }
        }
        Ao.prototype.bytesPerElement = 4, zr("StructArrayLayout2i4", Ao);
        class Jl extends _a {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r, n)
          }
          emplace(t, r, n, c) {
            const f = 3 * t;
            return this.int16[f + 0] = r, this.int16[f + 1] = n, this.int16[f + 2] = c, t
          }
        }
        Jl.prototype.bytesPerElement = 6, zr("StructArrayLayout3i6", Jl);
        class Tu extends _a {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n, c) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, t, r, n, c)
          }
          emplace(t, r, n, c, f) {
            const m = 4 * t;
            return this.int16[m + 0] = r, this.int16[m + 1] = n, this.int16[m + 2] = c, this.int16[m + 3] = f, t
          }
        }
        Tu.prototype.bytesPerElement = 8, zr("StructArrayLayout4i8", Tu);
        class fs extends _a {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n, c, f, m) {
            const v = this.length;
            return this.resize(v + 1), this.emplace(v, t, r, n, c, f, m)
          }
          emplace(t, r, n, c, f, m, v) {
            const b = 6 * t;
            return this.int16[b + 0] = r, this.int16[b + 1] = n, this.int16[b + 2] = c, this.int16[b + 3] = f, this.int16[b + 4] = m, this.int16[b + 5] = v, t
          }
        }
        fs.prototype.bytesPerElement = 12, zr("StructArrayLayout2i4i12", fs);
        class $l extends _a {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n, c, f, m) {
            const v = this.length;
            return this.resize(v + 1), this.emplace(v, t, r, n, c, f, m)
          }
          emplace(t, r, n, c, f, m, v) {
            const b = 4 * t,
              M = 8 * t;
            return this.int16[b + 0] = r, this.int16[b + 1] = n, this.uint8[M + 4] = c, this.uint8[M + 5] = f, this.uint8[M + 6] = m, this.uint8[M + 7] = v, t
          }
        }
        $l.prototype.bytesPerElement = 8, zr("StructArrayLayout2i4ub8", $l);
        class Ys extends _a {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t, r)
          }
          emplace(t, r, n) {
            const c = 2 * t;
            return this.float32[c + 0] = r, this.float32[c + 1] = n, t
          }
        }
        Ys.prototype.bytesPerElement = 8, zr("StructArrayLayout2f8", Ys);
        class Ql extends _a {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n, c, f, m, v, b, M, C) {
            const D = this.length;
            return this.resize(D + 1), this.emplace(D, t, r, n, c, f, m, v, b, M, C)
          }
          emplace(t, r, n, c, f, m, v, b, M, C, D) {
            const N = 10 * t;
            return this.uint16[N + 0] = r, this.uint16[N + 1] = n, this.uint16[N + 2] = c, this.uint16[N + 3] = f, this.uint16[N + 4] = m, this.uint16[N + 5] = v, this.uint16[N + 6] = b, this.uint16[N + 7] = M, this.uint16[N + 8] = C, this.uint16[N + 9] = D, t
          }
        }
        Ql.prototype.bytesPerElement = 20, zr("StructArrayLayout10ui20", Ql);
        class ol extends _a {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n, c, f, m, v, b) {
            const M = this.length;
            return this.resize(M + 1), this.emplace(M, t, r, n, c, f, m, v, b)
          }
          emplace(t, r, n, c, f, m, v, b, M) {
            const C = 8 * t;
            return this.uint16[C + 0] = r, this.uint16[C + 1] = n, this.uint16[C + 2] = c, this.uint16[C + 3] = f, this.uint16[C + 4] = m, this.uint16[C + 5] = v, this.uint16[C + 6] = b, this.uint16[C + 7] = M, t
          }
        }
        ol.prototype.bytesPerElement = 16, zr("StructArrayLayout8ui16", ol);
        class Su extends _a {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n, c, f, m, v, b, M, C, D, N) {
            const W = this.length;
            return this.resize(W + 1), this.emplace(W, t, r, n, c, f, m, v, b, M, C, D, N)
          }
          emplace(t, r, n, c, f, m, v, b, M, C, D, N, W) {
            const X = 12 * t;
            return this.int16[X + 0] = r, this.int16[X + 1] = n, this.int16[X + 2] = c, this.int16[X + 3] = f, this.uint16[X + 4] = m, this.uint16[X + 5] = v, this.uint16[X + 6] = b, this.uint16[X + 7] = M, this.int16[X + 8] = C, this.int16[X + 9] = D, this.int16[X + 10] = N, this.int16[X + 11] = W, t
          }
        }
        Su.prototype.bytesPerElement = 24, zr("StructArrayLayout4i4ui4i24", Su);
        class ko extends _a {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r, n)
          }
          emplace(t, r, n, c) {
            const f = 3 * t;
            return this.float32[f + 0] = r, this.float32[f + 1] = n, this.float32[f + 2] = c, t
          }
        }
        ko.prototype.bytesPerElement = 12, zr("StructArrayLayout3f12", ko);
        class Ks extends _a {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer)
          }
          emplaceBack(t) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, t)
          }
          emplace(t, r) {
            return this.uint32[1 * t + 0] = r, t
          }
        }
        Ks.prototype.bytesPerElement = 4, zr("StructArrayLayout1ul4", Ks);
        class Pu extends _a {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n, c, f, m, v, b, M) {
            const C = this.length;
            return this.resize(C + 1), this.emplace(C, t, r, n, c, f, m, v, b, M)
          }
          emplace(t, r, n, c, f, m, v, b, M, C) {
            const D = 10 * t,
              N = 5 * t;
            return this.int16[D + 0] = r, this.int16[D + 1] = n, this.int16[D + 2] = c, this.int16[D + 3] = f, this.int16[D + 4] = m, this.int16[D + 5] = v, this.uint32[N + 3] = b, this.uint16[D + 8] = M, this.uint16[D + 9] = C, t
          }
        }
        Pu.prototype.bytesPerElement = 20, zr("StructArrayLayout6i1ul2ui20", Pu);
        class ec extends _a {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n, c, f, m) {
            const v = this.length;
            return this.resize(v + 1), this.emplace(v, t, r, n, c, f, m)
          }
          emplace(t, r, n, c, f, m, v) {
            const b = 6 * t;
            return this.int16[b + 0] = r, this.int16[b + 1] = n, this.int16[b + 2] = c, this.int16[b + 3] = f, this.int16[b + 4] = m, this.int16[b + 5] = v, t
          }
        }
        ec.prototype.bytesPerElement = 12, zr("StructArrayLayout2i2i2i12", ec);
        class Js extends _a {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n, c, f) {
            const m = this.length;
            return this.resize(m + 1), this.emplace(m, t, r, n, c, f)
          }
          emplace(t, r, n, c, f, m) {
            const v = 4 * t,
              b = 8 * t;
            return this.float32[v + 0] = r, this.float32[v + 1] = n, this.float32[v + 2] = c, this.int16[b + 6] = f, this.int16[b + 7] = m, t
          }
        }
        Js.prototype.bytesPerElement = 16, zr("StructArrayLayout2f1f2i16", Js);
        class Iu extends _a {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n, c, f, m) {
            const v = this.length;
            return this.resize(v + 1), this.emplace(v, t, r, n, c, f, m)
          }
          emplace(t, r, n, c, f, m, v) {
            const b = 16 * t,
              M = 4 * t,
              C = 8 * t;
            return this.uint8[b + 0] = r, this.uint8[b + 1] = n, this.float32[M + 1] = c, this.float32[M + 2] = f, this.int16[C + 6] = m, this.int16[C + 7] = v, t
          }
        }
        Iu.prototype.bytesPerElement = 16, zr("StructArrayLayout2ub2f2i16", Iu);
        class tc extends _a {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r, n)
          }
          emplace(t, r, n, c) {
            const f = 3 * t;
            return this.uint16[f + 0] = r, this.uint16[f + 1] = n, this.uint16[f + 2] = c, t
          }
        }
        tc.prototype.bytesPerElement = 6, zr("StructArrayLayout3ui6", tc);
        class rc extends _a {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n, c, f, m, v, b, M, C, D, N, W, X, Q, le, we) {
            const et = this.length;
            return this.resize(et + 1), this.emplace(et, t, r, n, c, f, m, v, b, M, C, D, N, W, X, Q, le, we)
          }
          emplace(t, r, n, c, f, m, v, b, M, C, D, N, W, X, Q, le, we, et) {
            const De = 24 * t,
              Ze = 12 * t,
              mt = 48 * t;
            return this.int16[De + 0] = r, this.int16[De + 1] = n, this.uint16[De + 2] = c, this.uint16[De + 3] = f, this.uint32[Ze + 2] = m, this.uint32[Ze + 3] = v, this.uint32[Ze + 4] = b, this.uint16[De + 10] = M, this.uint16[De + 11] = C, this.uint16[De + 12] = D, this.float32[Ze + 7] = N, this.float32[Ze + 8] = W, this.uint8[mt + 36] = X, this.uint8[mt + 37] = Q, this.uint8[mt + 38] = le, this.uint32[Ze + 10] = we, this.int16[De + 22] = et, t
          }
        }
        rc.prototype.bytesPerElement = 48, zr("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", rc);
        class Mu extends _a {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n, c, f, m, v, b, M, C, D, N, W, X, Q, le, we, et, De, Ze, mt, Mt, $t, Tr, hr, yr, $r, gr) {
            const xr = this.length;
            return this.resize(xr + 1), this.emplace(xr, t, r, n, c, f, m, v, b, M, C, D, N, W, X, Q, le, we, et, De, Ze, mt, Mt, $t, Tr, hr, yr, $r, gr)
          }
          emplace(t, r, n, c, f, m, v, b, M, C, D, N, W, X, Q, le, we, et, De, Ze, mt, Mt, $t, Tr, hr, yr, $r, gr, xr) {
            const Ft = 32 * t,
              mi = 16 * t;
            return this.int16[Ft + 0] = r, this.int16[Ft + 1] = n, this.int16[Ft + 2] = c, this.int16[Ft + 3] = f, this.int16[Ft + 4] = m, this.int16[Ft + 5] = v, this.int16[Ft + 6] = b, this.int16[Ft + 7] = M, this.uint16[Ft + 8] = C, this.uint16[Ft + 9] = D, this.uint16[Ft + 10] = N, this.uint16[Ft + 11] = W, this.uint16[Ft + 12] = X, this.uint16[Ft + 13] = Q, this.uint16[Ft + 14] = le, this.uint16[Ft + 15] = we, this.uint16[Ft + 16] = et, this.uint16[Ft + 17] = De, this.uint16[Ft + 18] = Ze, this.uint16[Ft + 19] = mt, this.uint16[Ft + 20] = Mt, this.uint16[Ft + 21] = $t, this.uint16[Ft + 22] = Tr, this.uint32[mi + 12] = hr, this.float32[mi + 13] = yr, this.float32[mi + 14] = $r, this.uint16[Ft + 30] = gr, this.uint16[Ft + 31] = xr, t
          }
        }
        Mu.prototype.bytesPerElement = 64, zr("StructArrayLayout8i15ui1ul2f2ui64", Mu);
        class d extends _a {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, t)
          }
          emplace(t, r) {
            return this.float32[1 * t + 0] = r, t
          }
        }
        d.prototype.bytesPerElement = 4, zr("StructArrayLayout1f4", d);
        class e extends _a {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r, n)
          }
          emplace(t, r, n, c) {
            const f = 3 * t;
            return this.uint16[6 * t + 0] = r, this.float32[f + 1] = n, this.float32[f + 2] = c, t
          }
        }
        e.prototype.bytesPerElement = 12, zr("StructArrayLayout1ui2f12", e);
        class a extends _a {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, t, r, n)
          }
          emplace(t, r, n, c) {
            const f = 4 * t;
            return this.uint32[2 * t + 0] = r, this.uint16[f + 2] = n, this.uint16[f + 3] = c, t
          }
        }
        a.prototype.bytesPerElement = 8, zr("StructArrayLayout1ul2ui8", a);
        class o extends _a {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, r) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t, r)
          }
          emplace(t, r, n) {
            const c = 2 * t;
            return this.uint16[c + 0] = r, this.uint16[c + 1] = n, t
          }
        }
        o.prototype.bytesPerElement = 4, zr("StructArrayLayout2ui4", o);
        class u extends _a {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, t)
          }
          emplace(t, r) {
            return this.uint16[1 * t + 0] = r, t
          }
        }
        u.prototype.bytesPerElement = 2, zr("StructArrayLayout1ui2", u);
        class p extends _a {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, r, n, c) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, t, r, n, c)
          }
          emplace(t, r, n, c, f) {
            const m = 4 * t;
            return this.float32[m + 0] = r, this.float32[m + 1] = n, this.float32[m + 2] = c, this.float32[m + 3] = f, t
          }
        }
        p.prototype.bytesPerElement = 16, zr("StructArrayLayout4f16", p);
        class g extends is {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2]
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3]
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4]
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5]
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3]
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8]
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9]
          }
          get anchorPoint() {
            return new F(this.anchorPointX, this.anchorPointY)
          }
        }
        g.prototype.size = 20;
        class w extends Pu {
          get(t) {
            return new g(this, t)
          }
        }
        zr("CollisionBoxArray", w);
        class I extends is {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2]
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3]
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2]
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3]
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4]
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10]
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11]
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12]
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7]
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8]
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36]
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37]
          }
          set placedOrientation(t) {
            this._structArray.uint8[this._pos1 + 37] = t
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38]
          }
          set hidden(t) {
            this._structArray.uint8[this._pos1 + 38] = t
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10]
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 10] = t
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22]
          }
        }
        I.prototype.size = 48;
        class A extends rc {
          get(t) {
            return new I(this, t)
          }
        }
        zr("PlacedSymbolArray", A);
        class L extends is {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2]
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3]
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4]
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5]
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6]
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7]
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8]
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9]
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10]
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11]
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12]
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13]
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14]
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15]
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16]
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17]
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18]
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19]
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20]
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21]
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22]
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12]
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 12] = t
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13]
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14]
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30]
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31]
          }
        }
        L.prototype.size = 64;
        class O extends Mu {
          get(t) {
            return new L(this, t)
          }
        }
        zr("SymbolInstanceArray", O);
        class R extends d {
          getoffsetX(t) {
            return this.float32[1 * t + 0]
          }
        }
        zr("GlyphOffsetArray", R);
        class H extends Jl {
          getx(t) {
            return this.int16[3 * t + 0]
          }
          gety(t) {
            return this.int16[3 * t + 1]
          }
          gettileUnitDistanceFromAnchor(t) {
            return this.int16[3 * t + 2]
          }
        }
        zr("SymbolLineVertexArray", H);
        class $ extends is {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0]
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1]
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2]
          }
        }
        $.prototype.size = 12;
        class ce extends e {
          get(t) {
            return new $(this, t)
          }
        }
        zr("TextAnchorOffsetArray", ce);
        class ue extends is {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0]
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2]
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3]
          }
        }
        ue.prototype.size = 8;
        class de extends a {
          get(t) {
            return new ue(this, t)
          }
        }
        zr("FeatureIndexArray", de);
        class Ce extends Ao {}
        class Be extends Ao {}
        class Ie extends Ao {}
        class Oe extends fs {}
        class He extends $l {}
        class Le extends Ys {}
        class $e extends Ql {}
        class vt extends ol {}
        class ft extends Su {}
        class gt extends ko {}
        class xt extends Ks {}
        class lr extends ec {}
        class cr extends Iu {}
        class Nt extends tc {}
        class Nr extends o {}
        const Pi = wa([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: Qi
          } = Pi;
        class Li {
          constructor(t = []) {
            this._forceNewSegmentOnNextPrepare = !1, this.segments = t
          }
          prepareSegment(t, r, n, c) {
            const f = this.segments[this.segments.length - 1];
            return t > Li.MAX_VERTEX_ARRAY_LENGTH && St(`Max vertices per segment is ${Li.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${Li.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !f || f.vertexLength + t > Li.MAX_VERTEX_ARRAY_LENGTH || f.sortKey !== c ? this.createNewSegment(r, n, c) : f
          }
          createNewSegment(t, r, n) {
            const c = {
              vertexOffset: t.length,
              primitiveOffset: r.length,
              vertexLength: 0,
              primitiveLength: 0,
              vaos: {}
            };
            return n !== void 0 && (c.sortKey = n), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(c), c
          }
          getOrCreateLatestSegment(t, r, n) {
            return this.prepareSegment(0, t, r, n)
          }
          forceNewSegmentOnNextPrepare() {
            this._forceNewSegmentOnNextPrepare = !0
          }
          get() {
            return this.segments
          }
          destroy() {
            for (const t of this.segments)
              for (const r in t.vaos) t.vaos[r].destroy()
          }
          static simpleSegment(t, r, n, c) {
            return new Li([{
              vertexOffset: t,
              primitiveOffset: r,
              vertexLength: n,
              primitiveLength: c,
              vaos: {},
              sortKey: 0
            }])
          }
        }

        function ra(i, t) {
          return 256 * (i = Zt(Math.floor(i), 0, 255)) + Zt(Math.floor(t), 0, 255)
        }
        Li.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, zr("SegmentVector", Li);
        const va = wa([{
            name: "a_pattern_from",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_pattern_to",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_pixel_ratio_from",
            components: 1,
            type: "Uint16"
          }, {
            name: "a_pixel_ratio_to",
            components: 1,
            type: "Uint16"
          }]),
          na = wa([{
            name: "a_dasharray_from",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_dasharray_to",
            components: 4,
            type: "Uint16"
          }]);
        var za, ha, Ua, da = {
            exports: {}
          },
          Ca = {
            exports: {}
          },
          cn = {
            exports: {}
          },
          $s = (function() {
            if (Ua) return da.exports;
            Ua = 1;
            var i = (za || (za = 1, Ca.exports = function(r, n) {
                var c, f, m, v, b, M, C, D;
                for (f = r.length - (c = 3 & r.length), m = n, b = 3432918353, M = 461845907, D = 0; D < f;) C = 255 & r.charCodeAt(D) | (255 & r.charCodeAt(++D)) << 8 | (255 & r.charCodeAt(++D)) << 16 | (255 & r.charCodeAt(++D)) << 24, ++D, m = 27492 + (65535 & (v = 5 * (65535 & (m = (m ^= C = (65535 & (C = (C = (65535 & C) * b + (((C >>> 16) * b & 65535) << 16) & 4294967295) << 15 | C >>> 17)) * M + (((C >>> 16) * M & 65535) << 16) & 4294967295) << 13 | m >>> 19)) + ((5 * (m >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (v >>> 16) & 65535) << 16);
                switch (C = 0, c) {
                  case 3:
                    C ^= (255 & r.charCodeAt(D + 2)) << 16;
                  case 2:
                    C ^= (255 & r.charCodeAt(D + 1)) << 8;
                  case 1:
                    m ^= C = (65535 & (C = (C = (65535 & (C ^= 255 & r.charCodeAt(D))) * b + (((C >>> 16) * b & 65535) << 16) & 4294967295) << 15 | C >>> 17)) * M + (((C >>> 16) * M & 65535) << 16) & 4294967295
                }
                return m ^= r.length, m = 2246822507 * (65535 & (m ^= m >>> 16)) + ((2246822507 * (m >>> 16) & 65535) << 16) & 4294967295, m = 3266489909 * (65535 & (m ^= m >>> 13)) + ((3266489909 * (m >>> 16) & 65535) << 16) & 4294967295, (m ^= m >>> 16) >>> 0
              }), Ca.exports),
              t = (ha || (ha = 1, cn.exports = function(r, n) {
                for (var c, f = r.length, m = n ^ f, v = 0; f >= 4;) c = 1540483477 * (65535 & (c = 255 & r.charCodeAt(v) | (255 & r.charCodeAt(++v)) << 8 | (255 & r.charCodeAt(++v)) << 16 | (255 & r.charCodeAt(++v)) << 24)) + ((1540483477 * (c >>> 16) & 65535) << 16), m = 1540483477 * (65535 & m) + ((1540483477 * (m >>> 16) & 65535) << 16) ^ (c = 1540483477 * (65535 & (c ^= c >>> 24)) + ((1540483477 * (c >>> 16) & 65535) << 16)), f -= 4, ++v;
                switch (f) {
                  case 3:
                    m ^= (255 & r.charCodeAt(v + 2)) << 16;
                  case 2:
                    m ^= (255 & r.charCodeAt(v + 1)) << 8;
                  case 1:
                    m = 1540483477 * (65535 & (m ^= 255 & r.charCodeAt(v))) + ((1540483477 * (m >>> 16) & 65535) << 16)
                }
                return m = 1540483477 * (65535 & (m ^= m >>> 13)) + ((1540483477 * (m >>> 16) & 65535) << 16), (m ^= m >>> 15) >>> 0
              }), cn.exports);
            return da.exports = i, da.exports.murmur3 = i, da.exports.murmur2 = t, da.exports
          })(),
          ms = Z($s);
        class as {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = !1
          }
          add(t, r, n, c) {
            this.ids.push(Qs(t)), this.positions.push(r, n, c)
          }
          getPositions(t) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const r = Qs(t);
            let n = 0,
              c = this.ids.length - 1;
            for (; n < c;) {
              const m = n + c >> 1;
              this.ids[m] >= r ? c = m : n = m + 1
            }
            const f = [];
            for (; this.ids[n] === r;) f.push({
              index: this.positions[3 * n],
              start: this.positions[3 * n + 1],
              end: this.positions[3 * n + 2]
            }), n++;
            return f
          }
          static serialize(t, r) {
            const n = new Float64Array(t.ids),
              c = new Uint32Array(t.positions);
            return zo(n, c, 0, n.length - 1), r && r.push(n.buffer, c.buffer), {
              ids: n,
              positions: c
            }
          }
          static deserialize(t) {
            const r = new as;
            return r.ids = t.ids, r.positions = t.positions, r.indexed = !0, r
          }
        }

        function Qs(i) {
          const t = +i;
          return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER ? t : ms(String(i))
        }

        function zo(i, t, r, n) {
          for (; r < n;) {
            const c = i[r + n >> 1];
            let f = r - 1,
              m = n + 1;
            for (;;) {
              do f++; while (i[f] < c);
              do m--; while (i[m] > c);
              if (f >= m) break;
              eo(i, f, m), eo(t, 3 * f, 3 * m), eo(t, 3 * f + 1, 3 * m + 1), eo(t, 3 * f + 2, 3 * m + 2)
            }
            m - r < n - m ? (zo(i, t, r, m), r = m + 1) : (zo(i, t, m + 1, n), n = m)
          }
        }

        function eo(i, t, r) {
          const n = i[t];
          i[t] = i[r], i[r] = n
        }
        zr("FeaturePositionMap", as);
        class gn {
          constructor(t, r) {
            this.gl = t.gl, this.location = r
          }
        }
        class un extends gn {
          constructor(t, r) {
            super(t, r), this.current = 0
          }
          set(t) {
            this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t))
          }
        }
        class gs extends gn {
          constructor(t, r) {
            super(t, r), this.current = [0, 0, 0, 0]
          }
          set(t) {
            t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]))
          }
        }
        class Cs extends gn {
          constructor(t, r) {
            super(t, r), this.current = Ar.transparent
          }
          set(t) {
            t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a))
          }
        }
        const ll = new Float32Array(16);

        function Aa(i) {
          return [ra(255 * i.r, 255 * i.g), ra(255 * i.b, 255 * i.a)]
        }
        class Ta {
          constructor(t, r, n) {
            this.value = t, this.uniformNames = r.map((c => `u_${c}`)), this.type = n
          }
          setUniform(t, r, n) {
            t.set(n.constantOr(this.value))
          }
          getBinding(t, r, n) {
            return this.type === "color" ? new Cs(t, r) : new un(t, r)
          }
        }
        class Za {
          constructor(t, r) {
            this.uniformNames = r.map((n => `u_${n}`)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1
          }
          setConstantPatternPositions(t, r) {
            this.pixelRatioFrom = r.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = r.tlbr, this.patternTo = t.tlbr
          }
          setConstantDashPositions(t, r) {
            this.dashTo = [0, t.y, t.height, t.width], this.dashFrom = [0, r.y, r.height, r.width]
          }
          setUniform(t, r, n, c) {
            let f = null;
            c === "u_pattern_to" ? f = this.patternTo : c === "u_pattern_from" ? f = this.patternFrom : c === "u_dasharray_to" ? f = this.dashTo : c === "u_dasharray_from" ? f = this.dashFrom : c === "u_pixel_ratio_to" ? f = this.pixelRatioTo : c === "u_pixel_ratio_from" && (f = this.pixelRatioFrom), f !== null && t.set(f)
          }
          getBinding(t, r, n) {
            return n.substr(0, 9) === "u_pattern" || n.substr(0, 12) === "u_dasharray_" ? new gs(t, r) : new un(t, r)
          }
        }
        class oa {
          constructor(t, r, n, c) {
            this.expression = t, this.type = n, this.maxValue = 0, this.paintVertexAttributes = r.map((f => ({
              name: `a_${f}`,
              type: "Float32",
              components: n === "color" ? 2 : 1,
              offset: 0
            }))), this.paintVertexArray = new c
          }
          populatePaintArray(t, r, n) {
            const c = this.paintVertexArray.length,
              f = this.expression.evaluate(new ta(0, n), r, {}, n.canonical, [], n.formattedSection);
            this.paintVertexArray.resize(t), this._setPaintValue(c, t, f)
          }
          updatePaintArray(t, r, n, c, f) {
            const m = this.expression.evaluate(new ta(0, f), n, c);
            this._setPaintValue(t, r, m)
          }
          _setPaintValue(t, r, n) {
            if (this.type === "color") {
              const c = Aa(n);
              for (let f = t; f < r; f++) this.paintVertexArray.emplace(f, c[0], c[1])
            } else {
              for (let c = t; c < r; c++) this.paintVertexArray.emplace(c, n);
              this.maxValue = Math.max(this.maxValue, Math.abs(n))
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy()
          }
        }
        class Gn {
          constructor(t, r, n, c, f, m) {
            this.expression = t, this.uniformNames = r.map((v => `u_${v}_t`)), this.type = n, this.useIntegerZoom = c, this.zoom = f, this.maxValue = 0, this.paintVertexAttributes = r.map((v => ({
              name: `a_${v}`,
              type: "Float32",
              components: n === "color" ? 4 : 2,
              offset: 0
            }))), this.paintVertexArray = new m
          }
          populatePaintArray(t, r, n) {
            const c = this.expression.evaluate(new ta(this.zoom, n), r, {}, n.canonical, [], n.formattedSection),
              f = this.expression.evaluate(new ta(this.zoom + 1, n), r, {}, n.canonical, [], n.formattedSection),
              m = this.paintVertexArray.length;
            this.paintVertexArray.resize(t), this._setPaintValue(m, t, c, f)
          }
          updatePaintArray(t, r, n, c, f) {
            const m = this.expression.evaluate(new ta(this.zoom, f), n, c),
              v = this.expression.evaluate(new ta(this.zoom + 1, f), n, c);
            this._setPaintValue(t, r, m, v)
          }
          _setPaintValue(t, r, n, c) {
            if (this.type === "color") {
              const f = Aa(n),
                m = Aa(c);
              for (let v = t; v < r; v++) this.paintVertexArray.emplace(v, f[0], f[1], m[0], m[1])
            } else {
              for (let f = t; f < r; f++) this.paintVertexArray.emplace(f, n, c);
              this.maxValue = Math.max(this.maxValue, Math.abs(n), Math.abs(c))
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy()
          }
          setUniform(t, r) {
            const n = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom,
              c = Zt(this.expression.interpolationFactor(n, this.zoom, this.zoom + 1), 0, 1);
            t.set(c)
          }
          getBinding(t, r, n) {
            return new un(t, r)
          }
        }
        class As {
          constructor(t, r, n, c, f, m) {
            this.expression = t, this.type = r, this.useIntegerZoom = n, this.zoom = c, this.layerId = m, this.zoomInPaintVertexArray = new f, this.zoomOutPaintVertexArray = new f
          }
          populatePaintArray(t, r, n) {
            const c = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(c, t, this.getPositionIds(r), n)
          }
          updatePaintArray(t, r, n, c, f) {
            this._setPaintValues(t, r, this.getPositionIds(n), f)
          }
          _setPaintValues(t, r, n, c) {
            const f = this.getPositions(c);
            if (!f || !n) return;
            const m = f[n.min],
              v = f[n.mid],
              b = f[n.max];
            if (m && v && b)
              for (let M = t; M < r; M++) this.emplace(this.zoomInPaintVertexArray, M, v, m), this.emplace(this.zoomOutPaintVertexArray, M, v, b)
          }
          upload(t) {
            if (this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer) {
              const r = this.getVertexAttributes();
              this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, r, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, r, this.expression.isStateDependent)
            }
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy()
          }
        }
        class Ed extends As {
          getPositions(t) {
            return t.imagePositions
          }
          getPositionIds(t) {
            return t.patterns && t.patterns[this.layerId]
          }
          getVertexAttributes() {
            return va.members
          }
          emplace(t, r, n, c) {
            t.emplace(r, n.tlbr[0], n.tlbr[1], n.tlbr[2], n.tlbr[3], c.tlbr[0], c.tlbr[1], c.tlbr[2], c.tlbr[3], n.pixelRatio, c.pixelRatio)
          }
        }
        class Ld extends As {
          getPositions(t) {
            return t.dashPositions
          }
          getPositionIds(t) {
            return t.dashes && t.dashes[this.layerId]
          }
          getVertexAttributes() {
            return na.members
          }
          emplace(t, r, n, c) {
            t.emplace(r, 0, n.y, n.height, n.width, 0, c.y, c.height, c.width)
          }
        }
        class Dd {
          constructor(t, r, n) {
            this.binders = {}, this._buffers = [];
            const c = [];
            for (const f in t.paint._values) {
              if (!n(f)) continue;
              const m = t.paint.get(f);
              if (!(m instanceof Un && To(m.property.specification))) continue;
              const v = ro(f, t.type),
                b = m.value,
                M = m.property.specification.type,
                C = m.property.useIntegerZoom,
                D = m.property.specification["property-type"],
                N = D === "cross-faded" || D === "cross-faded-data-driven";
              if (b.kind === "constant") this.binders[f] = N ? new Za(b.value, v) : new Ta(b.value, v, M), c.push(`/u_${f}`);
              else if (b.kind === "source" || N) {
                const W = Cu(f, M, "source");
                this.binders[f] = N ? f === "line-dasharray" ? new Ld(b, M, C, r, W, t.id) : new Ed(b, M, C, r, W, t.id) : new oa(b, v, M, W), c.push(`/a_${f}`)
              } else {
                const W = Cu(f, M, "composite");
                this.binders[f] = new Gn(b, v, M, C, r, W), c.push(`/z_${f}`)
              }
            }
            this.cacheKey = c.sort().join("")
          }
          getMaxValue(t) {
            const r = this.binders[t];
            return r instanceof oa || r instanceof Gn ? r.maxValue : 0
          }
          populatePaintArrays(t, r, n) {
            for (const c in this.binders) {
              const f = this.binders[c];
              (f instanceof oa || f instanceof Gn || f instanceof As) && f.populatePaintArray(t, r, n)
            }
          }
          setConstantPatternPositions(t, r) {
            for (const n in this.binders) {
              const c = this.binders[n];
              c instanceof Za && c.setConstantPatternPositions(t, r)
            }
          }
          setConstantDashPositions(t, r) {
            for (const n in this.binders) {
              const c = this.binders[n];
              c instanceof Za && c.setConstantDashPositions(t, r)
            }
          }
          updatePaintArrays(t, r, n, c, f) {
            let m = !1;
            for (const v in t) {
              const b = r.getPositions(v);
              for (const M of b) {
                const C = n.feature(M.index);
                for (const D in this.binders) {
                  const N = this.binders[D];
                  if ((N instanceof oa || N instanceof Gn || N instanceof As) && N.expression.isStateDependent === !0) {
                    const W = c.paint.get(D);
                    N.expression = W.value, N.updatePaintArray(M.start, M.end, C, t[v], f), m = !0
                  }
                }
              }
            }
            return m
          }
          defines() {
            const t = [];
            for (const r in this.binders) {
              const n = this.binders[r];
              (n instanceof Ta || n instanceof Za) && t.push(...n.uniformNames.map((c => `#define HAS_UNIFORM_${c}`)))
            }
            return t
          }
          getBinderAttributes() {
            const t = [];
            for (const r in this.binders) {
              const n = this.binders[r];
              if (n instanceof oa || n instanceof Gn)
                for (let c = 0; c < n.paintVertexAttributes.length; c++) t.push(n.paintVertexAttributes[c].name);
              else if (n instanceof As) {
                const c = n.getVertexAttributes();
                for (const f of c) t.push(f.name)
              }
            }
            return t
          }
          getBinderUniforms() {
            const t = [];
            for (const r in this.binders) {
              const n = this.binders[r];
              if (n instanceof Ta || n instanceof Za || n instanceof Gn)
                for (const c of n.uniformNames) t.push(c)
            }
            return t
          }
          getPaintVertexBuffers() {
            return this._buffers
          }
          getUniforms(t, r) {
            const n = [];
            for (const c in this.binders) {
              const f = this.binders[c];
              if (f instanceof Ta || f instanceof Za || f instanceof Gn) {
                for (const m of f.uniformNames)
                  if (r[m]) {
                    const v = f.getBinding(t, r[m], m);
                    n.push({
                      name: m,
                      property: c,
                      binding: v
                    })
                  }
              }
            }
            return n
          }
          setUniforms(t, r, n, c) {
            for (const {
                name: f,
                property: m,
                binding: v
              }
              of r) this.binders[m].setUniform(v, c, n.get(m), f)
          }
          updatePaintBuffers(t) {
            this._buffers = [];
            for (const r in this.binders) {
              const n = this.binders[r];
              if (t && n instanceof As) {
                const c = t.fromScale === 2 ? n.zoomInPaintVertexBuffer : n.zoomOutPaintVertexBuffer;
                c && this._buffers.push(c)
              } else(n instanceof oa || n instanceof Gn) && n.paintVertexBuffer && this._buffers.push(n.paintVertexBuffer)
            }
          }
          upload(t) {
            for (const r in this.binders) {
              const n = this.binders[r];
              (n instanceof oa || n instanceof Gn || n instanceof As) && n.upload(t)
            }
            this.updatePaintBuffers()
          }
          destroy() {
            for (const t in this.binders) {
              const r = this.binders[t];
              (r instanceof oa || r instanceof Gn || r instanceof As) && r.destroy()
            }
          }
        }
        class to {
          constructor(t, r, n = () => !0) {
            this.programConfigurations = {};
            for (const c of t) this.programConfigurations[c.id] = new Dd(c, r, n);
            this.needsUpload = !1, this._featureMap = new as, this._bufferOffset = 0
          }
          populatePaintArrays(t, r, n, c) {
            for (const f in this.programConfigurations) this.programConfigurations[f].populatePaintArrays(t, r, c);
            r.id !== void 0 && this._featureMap.add(r.id, n, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0
          }
          updatePaintArrays(t, r, n, c) {
            for (const f of n) this.needsUpload = this.programConfigurations[f.id].updatePaintArrays(t, this._featureMap, r, f, c) || this.needsUpload
          }
          get(t) {
            return this.programConfigurations[t]
          }
          upload(t) {
            if (this.needsUpload) {
              for (const r in this.programConfigurations) this.programConfigurations[r].upload(t);
              this.needsUpload = !1
            }
          }
          destroy() {
            for (const t in this.programConfigurations) this.programConfigurations[t].destroy()
          }
        }

        function ro(i, t) {
          return {
            "text-opacity": ["opacity"],
            "icon-opacity": ["opacity"],
            "text-color": ["fill_color"],
            "icon-color": ["fill_color"],
            "text-halo-color": ["halo_color"],
            "icon-halo-color": ["halo_color"],
            "text-halo-blur": ["halo_blur"],
            "icon-halo-blur": ["halo_blur"],
            "text-halo-width": ["halo_width"],
            "icon-halo-width": ["halo_width"],
            "line-gap-width": ["gapwidth"],
            "line-dasharray": ["dasharray_to", "dasharray_from"],
            "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
            "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
            "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"]
          } [i] || [i.replace(`${t}-`, "").replace(/-/g, "_")]
        }

        function Cu(i, t, r) {
          const n = {
              color: {
                source: Ys,
                composite: p
              },
              number: {
                source: d,
                composite: Ys
              }
            },
            c = (function(f) {
              return {
                "line-pattern": {
                  source: $e,
                  composite: $e
                },
                "fill-pattern": {
                  source: $e,
                  composite: $e
                },
                "fill-extrusion-pattern": {
                  source: $e,
                  composite: $e
                },
                "line-dasharray": {
                  source: vt,
                  composite: vt
                }
              } [f]
            })(i);
          return c && c[r] || n[t][r]
        }
        zr("ConstantBinder", Ta), zr("CrossFadedConstantBinder", Za), zr("SourceExpressionBinder", oa), zr("CrossFadedPatternBinder", Ed), zr("CrossFadedDasharrayBinder", Ld), zr("CompositeExpressionBinder", Gn), zr("ProgramConfiguration", Dd, {
          omit: ["_buffers"]
        }), zr("ProgramConfigurationSet", to);
        const ic = Math.pow(2, 14) - 1,
          Au = -ic - 1;

        function _s(i) {
          const t = nt / i.extent,
            r = i.loadGeometry();
          for (let n = 0; n < r.length; n++) {
            const c = r[n];
            for (let f = 0; f < c.length; f++) {
              const m = c[f],
                v = Math.round(m.x * t),
                b = Math.round(m.y * t);
              m.x = Zt(v, Au, ic), m.y = Zt(b, Au, ic), (v < m.x || v > m.x + 1 || b < m.y || b > m.y + 1) && St("Geometry exceeds allowed extent, reduce your vector tile buffer size")
            }
          }
          return r
        }

        function ks(i, t) {
          return {
            type: i.type,
            id: i.id,
            properties: i.properties,
            geometry: t ? _s(i) : []
          }
        }
        const ac = -32768;

        function Oy(i, t, r, n, c) {
          i.emplaceBack(ac + 8 * t + n, ac + 8 * r + c)
        }
        class df {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r => r.id)), this.index = t.index, this.hasDependencies = !1, this.layoutVertexArray = new Be, this.indexArray = new Nt, this.segments = new Li, this.programConfigurations = new to(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
          }
          populate(t, r, n) {
            const c = this.layers[0],
              f = [];
            let m = null,
              v = !1,
              b = c.type === "heatmap";
            if (c.type === "circle") {
              const C = c;
              m = C.layout.get("circle-sort-key"), v = !m.isConstant(), b = b || C.paint.get("circle-pitch-alignment") === "map"
            }
            const M = b ? r.subdivisionGranularity.circle : 1;
            for (const {
                feature: C,
                id: D,
                index: N,
                sourceLayerIndex: W
              }
              of t) {
              const X = this.layers[0]._featureFilter.needGeometry,
                Q = ks(C, X);
              if (!this.layers[0]._featureFilter.filter(new ta(this.zoom), Q, n)) continue;
              const le = v ? m.evaluate(Q, {}, n) : void 0,
                we = {
                  id: D,
                  properties: C.properties,
                  type: C.type,
                  sourceLayerIndex: W,
                  index: N,
                  geometry: X ? Q.geometry : _s(C),
                  patterns: {},
                  sortKey: le
                };
              f.push(we)
            }
            v && f.sort(((C, D) => C.sortKey - D.sortKey));
            for (const C of f) {
              const {
                geometry: D,
                index: N,
                sourceLayerIndex: W
              } = C, X = t[N].feature;
              this.addFeature(C, D, N, n, M), r.featureIndex.insert(X, D, N, W, this.index)
            }
          }
          update(t, r, n) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, {
              imagePositions: n
            })
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Qi), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy())
          }
          addFeature(t, r, n, c, f = 1) {
            let m;
            switch (f) {
              case 1:
                m = [0, 7];
                break;
              case 3:
                m = [0, 2, 5, 7];
                break;
              case 5:
                m = [0, 1, 3, 4, 6, 7];
                break;
              case 7:
                m = [0, 1, 2, 3, 4, 5, 6, 7];
                break;
              default:
                throw new Error(`Invalid circle bucket granularity: ${f}; valid values are 1, 3, 5, 7.`)
            }
            const v = m.length;
            for (const b of r)
              for (const M of b) {
                const C = M.x,
                  D = M.y;
                if (C < 0 || C >= nt || D < 0 || D >= nt) continue;
                const N = this.segments.prepareSegment(v * v, this.layoutVertexArray, this.indexArray, t.sortKey),
                  W = N.vertexLength;
                for (let X = 0; X < v; X++)
                  for (let Q = 0; Q < v; Q++) Oy(this.layoutVertexArray, C, D, m[Q], m[X]);
                for (let X = 0; X < v - 1; X++)
                  for (let Q = 0; Q < v - 1; Q++) {
                    const le = W + X * v + Q,
                      we = W + (X + 1) * v + Q;
                    this.indexArray.emplaceBack(le, we + 1, le + 1), this.indexArray.emplaceBack(le, we, we + 1)
                  }
                N.vertexLength += v * v, N.primitiveLength += (v - 1) * (v - 1) * 2
              }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, n, {
              imagePositions: {},
              canonical: c
            })
          }
        }

        function Lg(i, t) {
          for (let r = 0; r < i.length; r++)
            if (nc(t, i[r])) return !0;
          for (let r = 0; r < t.length; r++)
            if (nc(i, t[r])) return !0;
          return !!pf(i, t)
        }

        function Rd(i, t, r) {
          return !!nc(i, t) || !!ff(t, i, r)
        }

        function Dg(i, t) {
          if (i.length === 1) return Fg(t, i[0]);
          for (let r = 0; r < t.length; r++) {
            const n = t[r];
            for (let c = 0; c < n.length; c++)
              if (nc(i, n[c])) return !0
          }
          for (let r = 0; r < i.length; r++)
            if (Fg(t, i[r])) return !0;
          for (let r = 0; r < t.length; r++)
            if (pf(i, t[r])) return !0;
          return !1
        }

        function jy(i, t, r) {
          if (i.length > 1) {
            if (pf(i, t)) return !0;
            for (let n = 0; n < t.length; n++)
              if (ff(t[n], i, r)) return !0
          }
          for (let n = 0; n < i.length; n++)
            if (ff(i[n], t, r)) return !0;
          return !1
        }

        function pf(i, t) {
          if (i.length === 0 || t.length === 0) return !1;
          for (let r = 0; r < i.length - 1; r++) {
            const n = i[r],
              c = i[r + 1];
            for (let f = 0; f < t.length - 1; f++)
              if (qy(n, c, t[f], t[f + 1])) return !0
          }
          return !1
        }

        function qy(i, t, r, n) {
          return Et(i, r, n) !== Et(t, r, n) && Et(i, t, r) !== Et(i, t, n)
        }

        function ff(i, t, r) {
          const n = r * r;
          if (t.length === 1) return i.distSqr(t[0]) < n;
          for (let c = 1; c < t.length; c++)
            if (Rg(i, t[c - 1], t[c]) < n) return !0;
          return !1
        }

        function Rg(i, t, r) {
          const n = t.distSqr(r);
          if (n === 0) return i.distSqr(t);
          const c = ((i.x - t.x) * (r.x - t.x) + (i.y - t.y) * (r.y - t.y)) / n;
          return i.distSqr(c < 0 ? t : c > 1 ? r : r.sub(t)._mult(c)._add(t))
        }

        function Fg(i, t) {
          let r, n, c, f = !1;
          for (let m = 0; m < i.length; m++) {
            r = i[m];
            for (let v = 0, b = r.length - 1; v < r.length; b = v++) n = r[v], c = r[b], n.y > t.y != c.y > t.y && t.x < (c.x - n.x) * (t.y - n.y) / (c.y - n.y) + n.x && (f = !f)
          }
          return f
        }

        function nc(i, t) {
          let r = !1;
          for (let n = 0, c = i.length - 1; n < i.length; c = n++) {
            const f = i[n],
              m = i[c];
            f.y > t.y != m.y > t.y && t.x < (m.x - f.x) * (t.y - f.y) / (m.y - f.y) + f.x && (r = !r)
          }
          return r
        }

        function Ny(i, t, r) {
          const n = r[0],
            c = r[2];
          if (i.x < n.x && t.x < n.x || i.x > c.x && t.x > c.x || i.y < n.y && t.y < n.y || i.y > c.y && t.y > c.y) return !1;
          const f = Et(i, t, r[0]);
          return f !== Et(i, t, r[1]) || f !== Et(i, t, r[2]) || f !== Et(i, t, r[3])
        }

        function sc(i, t, r) {
          const n = t.paint.get(i).value;
          return n.kind === "constant" ? n.value : r.programConfigurations.get(t.id).getMaxValue(i)
        }

        function Fd(i) {
          return Math.sqrt(i[0] * i[0] + i[1] * i[1])
        }

        function Bd(i, t, r, n, c) {
          if (!t[0] && !t[1]) return i;
          const f = F.convert(t)._mult(c);
          r === "viewport" && f._rotate(-n);
          const m = [];
          for (let v = 0; v < i.length; v++) m.push(i[v].sub(f));
          return m
        }

        function Vy({
          queryGeometry: i,
          size: t
        }, r) {
          return Rd(i, r, t)
        }

        function Uy({
          queryGeometry: i,
          size: t,
          transform: r,
          unwrappedTileID: n,
          getElevation: c
        }, f) {
          return Rd(i, f, t * (r.projectTileCoordinates(f.x, f.y, n, c).signedDistanceFromCamera / r.cameraToCenterDistance))
        }

        function Zy({
          queryGeometry: i,
          size: t,
          transform: r,
          unwrappedTileID: n,
          getElevation: c
        }, f) {
          const m = r.projectTileCoordinates(f.x, f.y, n, c).signedDistanceFromCamera,
            v = t * (r.cameraToCenterDistance / m);
          return Rd(i, mf(f, r, n, c), v)
        }

        function Gy({
          queryGeometry: i,
          size: t,
          transform: r,
          unwrappedTileID: n,
          getElevation: c
        }, f) {
          return Rd(i, mf(f, r, n, c), t)
        }

        function Bg({
          queryGeometry: i,
          size: t,
          transform: r,
          unwrappedTileID: n,
          getElevation: c,
          pitchAlignment: f = "map",
          pitchScale: m = "map"
        }, v) {
          const b = f === "map" ? m === "map" ? Vy : Uy : m === "map" ? Zy : Gy,
            M = {
              queryGeometry: i,
              size: t,
              transform: r,
              unwrappedTileID: n,
              getElevation: c
            };
          for (const C of v)
            for (const D of C)
              if (b(M, D)) return !0;
          return !1
        }

        function mf(i, t, r, n) {
          const c = t.projectTileCoordinates(i.x, i.y, r, n).point;
          return new F((.5 * c.x + .5) * t.width, (.5 * -c.y + .5) * t.height)
        }
        let Og, jg;
        zr("CircleBucket", df, {
          omit: ["layers"]
        });
        var Wy = {
          get paint() {
            return jg = jg || new an({
              "circle-radius": new hi(Y.paint_circle["circle-radius"]),
              "circle-color": new hi(Y.paint_circle["circle-color"]),
              "circle-blur": new hi(Y.paint_circle["circle-blur"]),
              "circle-opacity": new hi(Y.paint_circle["circle-opacity"]),
              "circle-translate": new Xr(Y.paint_circle["circle-translate"]),
              "circle-translate-anchor": new Xr(Y.paint_circle["circle-translate-anchor"]),
              "circle-pitch-scale": new Xr(Y.paint_circle["circle-pitch-scale"]),
              "circle-pitch-alignment": new Xr(Y.paint_circle["circle-pitch-alignment"]),
              "circle-stroke-width": new hi(Y.paint_circle["circle-stroke-width"]),
              "circle-stroke-color": new hi(Y.paint_circle["circle-stroke-color"]),
              "circle-stroke-opacity": new hi(Y.paint_circle["circle-stroke-opacity"])
            })
          },
          get layout() {
            return Og = Og || new an({
              "circle-sort-key": new hi(Y.layout_circle["circle-sort-key"])
            })
          }
        };
        class Hy extends Zn {
          constructor(t, r) {
            super(t, Wy, r)
          }
          createBucket(t) {
            return new df(t)
          }
          queryRadius(t) {
            const r = t;
            return sc("circle-radius", this, r) + sc("circle-stroke-width", this, r) + Fd(this.paint.get("circle-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: r,
            featureState: n,
            geometry: c,
            transform: f,
            pixelsToTileUnits: m,
            unwrappedTileID: v,
            getElevation: b
          }) {
            const M = Bd(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -f.bearingInRadians, m),
              C = this.paint.get("circle-radius").evaluate(r, n) + this.paint.get("circle-stroke-width").evaluate(r, n),
              D = this.paint.get("circle-pitch-scale"),
              N = this.paint.get("circle-pitch-alignment");
            let W, X;
            return N === "map" ? (W = M, X = C * m) : (W = (function(Q, le, we, et) {
              return Q.map((De => mf(De, le, we, et)))
            })(M, f, v, b), X = C), Bg({
              queryGeometry: W,
              size: X,
              transform: f,
              unwrappedTileID: v,
              getElevation: b,
              pitchAlignment: N,
              pitchScale: D
            }, c)
          }
        }
        class qg extends df {}
        let Ng;
        zr("HeatmapBucket", qg, {
          omit: ["layers"]
        });
        var Xy = {
          get paint() {
            return Ng = Ng || new an({
              "heatmap-radius": new hi(Y.paint_heatmap["heatmap-radius"]),
              "heatmap-weight": new hi(Y.paint_heatmap["heatmap-weight"]),
              "heatmap-intensity": new Xr(Y.paint_heatmap["heatmap-intensity"]),
              "heatmap-color": new sl(Y.paint_heatmap["heatmap-color"]),
              "heatmap-opacity": new Xr(Y.paint_heatmap["heatmap-opacity"])
            })
          }
        };

        function gf(i, {
          width: t,
          height: r
        }, n, c) {
          if (c) {
            if (c instanceof Uint8ClampedArray) c = new Uint8Array(c.buffer);
            else if (c.length !== t * r * n) throw new RangeError(`mismatched image size. expected: ${c.length} but got: ${t*r*n}`)
          } else c = new Uint8Array(t * r * n);
          return i.width = t, i.height = r, i.data = c, i
        }

        function Vg(i, {
          width: t,
          height: r
        }, n) {
          if (t === i.width && r === i.height) return;
          const c = gf({}, {
            width: t,
            height: r
          }, n);
          _f(i, c, {
            x: 0,
            y: 0
          }, {
            x: 0,
            y: 0
          }, {
            width: Math.min(i.width, t),
            height: Math.min(i.height, r)
          }, n), i.width = t, i.height = r, i.data = c.data
        }

        function _f(i, t, r, n, c, f) {
          if (c.width === 0 || c.height === 0) return t;
          if (c.width > i.width || c.height > i.height || r.x > i.width - c.width || r.y > i.height - c.height) throw new RangeError("out of range source coordinates for image copy");
          if (c.width > t.width || c.height > t.height || n.x > t.width - c.width || n.y > t.height - c.height) throw new RangeError("out of range destination coordinates for image copy");
          const m = i.data,
            v = t.data;
          if (m === v) throw new Error("srcData equals dstData, so image is already copied");
          for (let b = 0; b < c.height; b++) {
            const M = ((r.y + b) * i.width + r.x) * f,
              C = ((n.y + b) * t.width + n.x) * f;
            for (let D = 0; D < c.width * f; D++) v[C + D] = m[M + D]
          }
          return t
        }
        class ku {
          constructor(t, r) {
            gf(this, t, 1, r)
          }
          resize(t) {
            Vg(this, t, 1)
          }
          clone() {
            return new ku({
              width: this.width,
              height: this.height
            }, new Uint8Array(this.data))
          }
          static copy(t, r, n, c, f) {
            _f(t, r, n, c, f, 1)
          }
        }
        class Sn {
          constructor(t, r) {
            gf(this, t, 4, r)
          }
          resize(t) {
            Vg(this, t, 4)
          }
          replace(t, r) {
            r ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t
          }
          clone() {
            return new Sn({
              width: this.width,
              height: this.height
            }, new Uint8Array(this.data))
          }
          static copy(t, r, n, c, f) {
            _f(t, r, n, c, f, 4)
          }
          setPixel(t, r, n) {
            const c = 4 * (t * this.width + r);
            this.data[c + 0] = Math.round(255 * n.r / n.a), this.data[c + 1] = Math.round(255 * n.g / n.a), this.data[c + 2] = Math.round(255 * n.b / n.a), this.data[c + 3] = Math.round(255 * n.a)
          }
        }

        function Ug(i) {
          const t = {},
            r = i.resolution || 256,
            n = i.clips ? i.clips.length : 1,
            c = i.image || new Sn({
              width: r,
              height: n
            });
          if (Math.log(r) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${r}`);
          const f = (m, v, b) => {
            t[i.evaluationKey] = b;
            const M = i.expression.evaluate(t);
            c.setPixel(m / 4 / r, v / 4, M)
          };
          if (i.clips)
            for (let m = 0, v = 0; m < n; ++m, v += 4 * r)
              for (let b = 0, M = 0; b < r; b++, M += 4) {
                const C = b / (r - 1),
                  {
                    start: D,
                    end: N
                  } = i.clips[m];
                f(v, M, D * (1 - C) + N * C)
              } else
                for (let m = 0, v = 0; m < r; m++, v += 4) f(0, v, m / (r - 1));
          return c
        }
        zr("AlphaImage", ku), zr("RGBAImage", Sn);
        const vf = "big-fb";
        class Yy extends Zn {
          createBucket(t) {
            return new qg(t)
          }
          constructor(t, r) {
            super(t, Xy, r), this.heatmapFbos = new Map, this._updateColorRamp()
          }
          _handleSpecialPaintPropertyUpdate(t) {
            t === "heatmap-color" && this._updateColorRamp()
          }
          _updateColorRamp() {
            this.colorRamp = Ug({
              expression: this._transitionablePaint._values["heatmap-color"].value.expression,
              evaluationKey: "heatmapDensity",
              image: this.colorRamp
            }), this.colorRampTexture = null
          }
          resize() {
            this.heatmapFbos.has(vf) && this.heatmapFbos.delete(vf)
          }
          queryRadius(t) {
            return sc("heatmap-radius", this, t)
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: r,
            featureState: n,
            geometry: c,
            transform: f,
            pixelsToTileUnits: m,
            unwrappedTileID: v,
            getElevation: b
          }) {
            return Bg({
              queryGeometry: t,
              size: this.paint.get("heatmap-radius").evaluate(r, n) * m,
              transform: f,
              unwrappedTileID: v,
              getElevation: b
            }, c)
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none"
          }
        }
        let Zg;
        var Ky = {
          get paint() {
            return Zg = Zg || new an({
              "hillshade-illumination-direction": new Xr(Y.paint_hillshade["hillshade-illumination-direction"]),
              "hillshade-illumination-altitude": new Xr(Y.paint_hillshade["hillshade-illumination-altitude"]),
              "hillshade-illumination-anchor": new Xr(Y.paint_hillshade["hillshade-illumination-anchor"]),
              "hillshade-exaggeration": new Xr(Y.paint_hillshade["hillshade-exaggeration"]),
              "hillshade-shadow-color": new Xr(Y.paint_hillshade["hillshade-shadow-color"]),
              "hillshade-highlight-color": new Xr(Y.paint_hillshade["hillshade-highlight-color"]),
              "hillshade-accent-color": new Xr(Y.paint_hillshade["hillshade-accent-color"]),
              "hillshade-method": new Xr(Y.paint_hillshade["hillshade-method"])
            })
          }
        };
        class Jy extends Zn {
          constructor(t, r) {
            super(t, Ky, r), this.recalculate({
              zoom: 0,
              zoomHistory: {}
            }, void 0)
          }
          getIlluminationProperties() {
            let t = this.paint.get("hillshade-illumination-direction").values,
              r = this.paint.get("hillshade-illumination-altitude").values,
              n = this.paint.get("hillshade-highlight-color").values,
              c = this.paint.get("hillshade-shadow-color").values;
            const f = Math.max(t.length, r.length, n.length, c.length);
            t = t.concat(Array(f - t.length).fill(t.at(-1))), r = r.concat(Array(f - r.length).fill(r.at(-1))), n = n.concat(Array(f - n.length).fill(n.at(-1))), c = c.concat(Array(f - c.length).fill(c.at(-1)));
            const m = r.map(Kt);
            return {
              directionRadians: t.map(Kt),
              altitudeRadians: m,
              shadowColor: c,
              highlightColor: n
            }
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none"
          }
        }
        let Gg;
        var $y = {
          get paint() {
            return Gg = Gg || new an({
              "color-relief-opacity": new Xr(Y["paint_color-relief"]["color-relief-opacity"]),
              "color-relief-color": new sl(Y["paint_color-relief"]["color-relief-color"])
            })
          }
        };
        class yf {
          constructor(t, r, n, c) {
            this.context = t, this.format = n, this.texture = t.gl.createTexture(), this.update(r, c)
          }
          update(t, r, n) {
            const {
              width: c,
              height: f
            } = t, m = !(this.size && this.size[0] === c && this.size[1] === f || n), {
              context: v
            } = this, {
              gl: b
            } = v;
            if (this.useMipmap = !!(r && r.useMipmap), b.bindTexture(b.TEXTURE_2D, this.texture), v.pixelStoreUnpackFlipY.set(!1), v.pixelStoreUnpack.set(1), v.pixelStoreUnpackPremultiplyAlpha.set(this.format === b.RGBA && (!r || r.premultiply !== !1)), m) this.size = [c, f], t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || ir(t) ? b.texImage2D(b.TEXTURE_2D, 0, this.format, this.format, b.UNSIGNED_BYTE, t) : b.texImage2D(b.TEXTURE_2D, 0, this.format, c, f, 0, this.format, b.UNSIGNED_BYTE, t.data);
            else {
              const {
                x: M,
                y: C
              } = n || {
                x: 0,
                y: 0
              };
              t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || ir(t) ? b.texSubImage2D(b.TEXTURE_2D, 0, M, C, b.RGBA, b.UNSIGNED_BYTE, t) : b.texSubImage2D(b.TEXTURE_2D, 0, M, C, c, f, b.RGBA, b.UNSIGNED_BYTE, t.data)
            }
            this.useMipmap && this.isSizePowerOfTwo() && b.generateMipmap(b.TEXTURE_2D), v.pixelStoreUnpackFlipY.setDefault(), v.pixelStoreUnpack.setDefault(), v.pixelStoreUnpackPremultiplyAlpha.setDefault()
          }
          bind(t, r, n) {
            const {
              context: c
            } = this, {
              gl: f
            } = c;
            f.bindTexture(f.TEXTURE_2D, this.texture), n !== f.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (n = f.LINEAR), t !== this.filter && (f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, t), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, n || t), this.filter = t), r !== this.wrap && (f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, r), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, r), this.wrap = r)
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0
          }
          destroy() {
            const {
              gl: t
            } = this.context;
            t.deleteTexture(this.texture), this.texture = null
          }
        }
        class Wg {
          constructor(t, r, n, c = 1, f = 1, m = 1, v = 0) {
            if (this.uid = t, r.height !== r.width) throw new RangeError("DEM tiles must be square");
            if (n && !["mapbox", "terrarium", "custom"].includes(n)) return void St(`"${n}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = r.height;
            const b = this.dim = r.height - 2;
            switch (this.data = new Uint32Array(r.data.buffer), n) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = c, this.greenFactor = f, this.blueFactor = m, this.baseShift = v;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = .1, this.baseShift = 1e4
            }
            for (let M = 0; M < b; M++) this.data[this._idx(-1, M)] = this.data[this._idx(0, M)], this.data[this._idx(b, M)] = this.data[this._idx(b - 1, M)], this.data[this._idx(M, -1)] = this.data[this._idx(M, 0)], this.data[this._idx(M, b)] = this.data[this._idx(M, b - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(b, -1)] = this.data[this._idx(b - 1, 0)], this.data[this._idx(-1, b)] = this.data[this._idx(0, b - 1)], this.data[this._idx(b, b)] = this.data[this._idx(b - 1, b - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let M = 0; M < b; M++)
              for (let C = 0; C < b; C++) {
                const D = this.get(M, C);
                D > this.max && (this.max = D), D < this.min && (this.min = D)
              }
          }
          get(t, r) {
            const n = new Uint8Array(this.data.buffer),
              c = 4 * this._idx(t, r);
            return this.unpack(n[c], n[c + 1], n[c + 2])
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift]
          }
          _idx(t, r) {
            if (t < -1 || t >= this.dim + 1 || r < -1 || r >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (r + 1) * this.stride + (t + 1)
          }
          unpack(t, r, n) {
            return t * this.redFactor + r * this.greenFactor + n * this.blueFactor - this.baseShift
          }
          pack(t) {
            return Hg(t, this.getUnpackVector())
          }
          getPixels() {
            return new Sn({
              width: this.stride,
              height: this.stride
            }, new Uint8Array(this.data.buffer))
          }
          backfillBorder(t, r, n) {
            if (this.dim !== t.dim) throw new Error("dem dimension mismatch");
            let c = r * this.dim,
              f = r * this.dim + this.dim,
              m = n * this.dim,
              v = n * this.dim + this.dim;
            switch (r) {
              case -1:
                c = f - 1;
                break;
              case 1:
                f = c + 1
            }
            switch (n) {
              case -1:
                m = v - 1;
                break;
              case 1:
                v = m + 1
            }
            const b = -r * this.dim,
              M = -n * this.dim;
            for (let C = m; C < v; C++)
              for (let D = c; D < f; D++) this.data[this._idx(D, C)] = t.data[this._idx(D + b, C + M)]
          }
        }

        function Hg(i, t) {
          const r = t[0],
            n = t[1],
            c = t[2],
            f = t[3],
            m = Math.min(r, n, c),
            v = Math.round((i + f) / m);
          return {
            r: Math.floor(v * m / r) % 256,
            g: Math.floor(v * m / n) % 256,
            b: Math.floor(v * m / c) % 256
          }
        }
        zr("DEMData", Wg);
        class Qy extends Zn {
          constructor(t, r) {
            super(t, $y, r)
          }
          _createColorRamp(t) {
            const r = {
                elevationStops: [],
                colorStops: []
              },
              n = this._transitionablePaint._values["color-relief-color"].value.expression;
            if (n instanceof Jo && n._styleExpression.expression instanceof Ki) {
              this.colorRampExpression = n;
              const m = n._styleExpression.expression;
              r.elevationStops = m.labels, r.colorStops = [];
              for (const v of r.elevationStops) r.colorStops.push(m.evaluate({
                globals: {
                  elevation: v
                }
              }))
            }
            if (r.elevationStops.length < 1 && (r.elevationStops = [0], r.colorStops = [Ar.transparent]), r.elevationStops.length < 2 && (r.elevationStops.push(r.elevationStops[0] + 1), r.colorStops.push(r.colorStops[0])), r.elevationStops.length <= t) return r;
            const c = {
                elevationStops: [],
                colorStops: []
              },
              f = (r.elevationStops.length - 1) / (t - 1);
            for (let m = 0; m < r.elevationStops.length - .5; m += f) c.elevationStops.push(r.elevationStops[Math.round(m)]), c.colorStops.push(r.colorStops[Math.round(m)]);
            return St(`Too many colors in specification of ${this.id} color-relief layer, may not render properly. Max possible colors: ${t}, provided: ${r.elevationStops.length}`), c
          }
          _colorRampChanged() {
            return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression
          }
          getColorRampTextures(t, r, n) {
            if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
            const c = this._createColorRamp(r),
              f = new Sn({
                width: c.colorStops.length,
                height: 1
              }),
              m = new Sn({
                width: c.colorStops.length,
                height: 1
              });
            for (let v = 0; v < c.elevationStops.length; v++) {
              const b = Hg(c.elevationStops[v], n);
              m.setPixel(0, v, new Ar(b.r / 255, b.g / 255, b.b / 255, 1)), f.setPixel(0, v, c.colorStops[v])
            }
            return this.colorRampTextures = {
              elevationTexture: new yf(t, m, t.gl.RGBA),
              colorTexture: new yf(t, f, t.gl.RGBA)
            }, this.colorRampTextures
          }
          hasOffscreenPass() {
            return this.visibility !== "none" && !!this.colorRampTextures
          }
        }
        const ex = wa([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: tx
          } = ex;

        function Od(i, t, r) {
          const n = r.patternDependencies;
          let c = !1;
          for (const f of t) {
            const m = f.paint.get(`${i}-pattern`);
            m.isConstant() || (c = !0);
            const v = m.constantOr(null);
            v && (c = !0, n[v.to] = !0, n[v.from] = !0)
          }
          return c
        }

        function xf(i, t, r, n, c) {
          const {
            zoom: f
          } = n, m = c.patternDependencies;
          for (const v of t) {
            const b = v.paint.get(`${i}-pattern`).value;
            if (b.kind !== "constant") {
              let M = b.evaluate({
                  zoom: f - 1
                }, r, {}, c.availableImages),
                C = b.evaluate({
                  zoom: f
                }, r, {}, c.availableImages),
                D = b.evaluate({
                  zoom: f + 1
                }, r, {}, c.availableImages);
              M = M && M.name ? M.name : M, C = C && C.name ? C.name : C, D = D && D.name ? D.name : D, m[M] = !0, m[C] = !0, m[D] = !0, r.patterns[v.id] = {
                min: M,
                mid: C,
                max: D
              }
            }
          }
          return r
        }

        function Xg(i, t, r, n, c) {
          let f;
          if (c === (function(m, v, b, M) {
              let C = 0;
              for (let D = v, N = b - M; D < b; D += M) C += (m[N] - m[D]) * (m[D + 1] + m[N + 1]), N = D;
              return C
            })(i, t, r, n) > 0)
            for (let m = t; m < r; m += n) f = $g(m / n | 0, i[m], i[m + 1], f);
          else
            for (let m = r - n; m >= t; m -= n) f = $g(m / n | 0, i[m], i[m + 1], f);
          return f && oc(f, f.next) && (Du(f), f = f.next), f
        }

        function cl(i, t) {
          if (!i) return i;
          t || (t = i);
          let r, n = i;
          do
            if (r = !1, n.steiner || !oc(n, n.next) && ka(n.prev, n, n.next) !== 0) n = n.next;
            else {
              if (Du(n), n = t = n.prev, n === n.next) break;
              r = !0
            } while (r || n !== t);
          return t
        }

        function zu(i, t, r, n, c, f, m) {
          if (!i) return;
          !m && f && (function(b, M, C, D) {
            let N = b;
            do N.z === 0 && (N.z = bf(N.x, N.y, M, C, D)), N.prevZ = N.prev, N.nextZ = N.next, N = N.next; while (N !== b);
            N.prevZ.nextZ = null, N.prevZ = null, (function(W) {
              let X, Q = 1;
              do {
                let le, we = W;
                W = null;
                let et = null;
                for (X = 0; we;) {
                  X++;
                  let De = we,
                    Ze = 0;
                  for (let Mt = 0; Mt < Q && (Ze++, De = De.nextZ, De); Mt++);
                  let mt = Q;
                  for (; Ze > 0 || mt > 0 && De;) Ze !== 0 && (mt === 0 || !De || we.z <= De.z) ? (le = we, we = we.nextZ, Ze--) : (le = De, De = De.nextZ, mt--), et ? et.nextZ = le : W = le, le.prevZ = et, et = le;
                  we = De
                }
                et.nextZ = null, Q *= 2
              } while (X > 1)
            })(N)
          })(i, n, c, f);
          let v = i;
          for (; i.prev !== i.next;) {
            const b = i.prev,
              M = i.next;
            if (f ? ix(i, n, c, f) : rx(i)) t.push(b.i, i.i, M.i), Du(i), i = M.next, v = M.next;
            else if ((i = M) === v) {
              m ? m === 1 ? zu(i = ax(cl(i), t), t, r, n, c, f, 2) : m === 2 && nx(i, t, r, n, c, f) : zu(cl(i), t, r, n, c, f, 1);
              break
            }
          }
        }

        function rx(i) {
          const t = i.prev,
            r = i,
            n = i.next;
          if (ka(t, r, n) >= 0) return !1;
          const c = t.x,
            f = r.x,
            m = n.x,
            v = t.y,
            b = r.y,
            M = n.y,
            C = Math.min(c, f, m),
            D = Math.min(v, b, M),
            N = Math.max(c, f, m),
            W = Math.max(v, b, M);
          let X = n.next;
          for (; X !== t;) {
            if (X.x >= C && X.x <= N && X.y >= D && X.y <= W && Eu(c, v, f, b, m, M, X.x, X.y) && ka(X.prev, X, X.next) >= 0) return !1;
            X = X.next
          }
          return !0
        }

        function ix(i, t, r, n) {
          const c = i.prev,
            f = i,
            m = i.next;
          if (ka(c, f, m) >= 0) return !1;
          const v = c.x,
            b = f.x,
            M = m.x,
            C = c.y,
            D = f.y,
            N = m.y,
            W = Math.min(v, b, M),
            X = Math.min(C, D, N),
            Q = Math.max(v, b, M),
            le = Math.max(C, D, N),
            we = bf(W, X, t, r, n),
            et = bf(Q, le, t, r, n);
          let De = i.prevZ,
            Ze = i.nextZ;
          for (; De && De.z >= we && Ze && Ze.z <= et;) {
            if (De.x >= W && De.x <= Q && De.y >= X && De.y <= le && De !== c && De !== m && Eu(v, C, b, D, M, N, De.x, De.y) && ka(De.prev, De, De.next) >= 0 || (De = De.prevZ, Ze.x >= W && Ze.x <= Q && Ze.y >= X && Ze.y <= le && Ze !== c && Ze !== m && Eu(v, C, b, D, M, N, Ze.x, Ze.y) && ka(Ze.prev, Ze, Ze.next) >= 0)) return !1;
            Ze = Ze.nextZ
          }
          for (; De && De.z >= we;) {
            if (De.x >= W && De.x <= Q && De.y >= X && De.y <= le && De !== c && De !== m && Eu(v, C, b, D, M, N, De.x, De.y) && ka(De.prev, De, De.next) >= 0) return !1;
            De = De.prevZ
          }
          for (; Ze && Ze.z <= et;) {
            if (Ze.x >= W && Ze.x <= Q && Ze.y >= X && Ze.y <= le && Ze !== c && Ze !== m && Eu(v, C, b, D, M, N, Ze.x, Ze.y) && ka(Ze.prev, Ze, Ze.next) >= 0) return !1;
            Ze = Ze.nextZ
          }
          return !0
        }

        function ax(i, t) {
          let r = i;
          do {
            const n = r.prev,
              c = r.next.next;
            !oc(n, c) && Kg(n, r, r.next, c) && Lu(n, c) && Lu(c, n) && (t.push(n.i, r.i, c.i), Du(r), Du(r.next), r = i = c), r = r.next
          } while (r !== i);
          return cl(r)
        }

        function nx(i, t, r, n, c, f) {
          let m = i;
          do {
            let v = m.next.next;
            for (; v !== m.prev;) {
              if (m.i !== v.i && ux(m, v)) {
                let b = Jg(m, v);
                return m = cl(m, m.next), b = cl(b, b.next), zu(m, t, r, n, c, f, 0), void zu(b, t, r, n, c, f, 0)
              }
              v = v.next
            }
            m = m.next
          } while (m !== i)
        }

        function sx(i, t) {
          let r = i.x - t.x;
          return r === 0 && (r = i.y - t.y, r === 0) && (r = (i.next.y - i.y) / (i.next.x - i.x) - (t.next.y - t.y) / (t.next.x - t.x)), r
        }

        function ox(i, t) {
          const r = (function(c, f) {
            let m = f;
            const v = c.x,
              b = c.y;
            let M, C = -1 / 0;
            if (oc(c, m)) return m;
            do {
              if (oc(c, m.next)) return m.next;
              if (b <= m.y && b >= m.next.y && m.next.y !== m.y) {
                const Q = m.x + (b - m.y) * (m.next.x - m.x) / (m.next.y - m.y);
                if (Q <= v && Q > C && (C = Q, M = m.x < m.next.x ? m : m.next, Q === v)) return M
              }
              m = m.next
            } while (m !== f);
            if (!M) return null;
            const D = M,
              N = M.x,
              W = M.y;
            let X = 1 / 0;
            m = M;
            do {
              if (v >= m.x && m.x >= N && v !== m.x && Yg(b < W ? v : C, b, N, W, b < W ? C : v, b, m.x, m.y)) {
                const Q = Math.abs(b - m.y) / (v - m.x);
                Lu(m, c) && (Q < X || Q === X && (m.x > M.x || m.x === M.x && lx(M, m))) && (M = m, X = Q)
              }
              m = m.next
            } while (m !== D);
            return M
          })(i, t);
          if (!r) return t;
          const n = Jg(r, i);
          return cl(n, n.next), cl(r, r.next)
        }

        function lx(i, t) {
          return ka(i.prev, i, t.prev) < 0 && ka(t.next, i, i.next) < 0
        }

        function bf(i, t, r, n, c) {
          return (i = 1431655765 & ((i = 858993459 & ((i = 252645135 & ((i = 16711935 & ((i = (i - r) * c | 0) | i << 8)) | i << 4)) | i << 2)) | i << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - n) * c | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
        }

        function cx(i) {
          let t = i,
            r = i;
          do(t.x < r.x || t.x === r.x && t.y < r.y) && (r = t), t = t.next; while (t !== i);
          return r
        }

        function Yg(i, t, r, n, c, f, m, v) {
          return (c - m) * (t - v) >= (i - m) * (f - v) && (i - m) * (n - v) >= (r - m) * (t - v) && (r - m) * (f - v) >= (c - m) * (n - v)
        }

        function Eu(i, t, r, n, c, f, m, v) {
          return !(i === m && t === v) && Yg(i, t, r, n, c, f, m, v)
        }

        function ux(i, t) {
          return i.next.i !== t.i && i.prev.i !== t.i && !(function(r, n) {
            let c = r;
            do {
              if (c.i !== r.i && c.next.i !== r.i && c.i !== n.i && c.next.i !== n.i && Kg(c, c.next, r, n)) return !0;
              c = c.next
            } while (c !== r);
            return !1
          })(i, t) && (Lu(i, t) && Lu(t, i) && (function(r, n) {
            let c = r,
              f = !1;
            const m = (r.x + n.x) / 2,
              v = (r.y + n.y) / 2;
            do c.y > v != c.next.y > v && c.next.y !== c.y && m < (c.next.x - c.x) * (v - c.y) / (c.next.y - c.y) + c.x && (f = !f), c = c.next; while (c !== r);
            return f
          })(i, t) && (ka(i.prev, i, t.prev) || ka(i, t.prev, t)) || oc(i, t) && ka(i.prev, i, i.next) > 0 && ka(t.prev, t, t.next) > 0)
        }

        function ka(i, t, r) {
          return (t.y - i.y) * (r.x - t.x) - (t.x - i.x) * (r.y - t.y)
        }

        function oc(i, t) {
          return i.x === t.x && i.y === t.y
        }

        function Kg(i, t, r, n) {
          const c = qd(ka(i, t, r)),
            f = qd(ka(i, t, n)),
            m = qd(ka(r, n, i)),
            v = qd(ka(r, n, t));
          return c !== f && m !== v || !(c !== 0 || !jd(i, r, t)) || !(f !== 0 || !jd(i, n, t)) || !(m !== 0 || !jd(r, i, n)) || !(v !== 0 || !jd(r, t, n))
        }

        function jd(i, t, r) {
          return t.x <= Math.max(i.x, r.x) && t.x >= Math.min(i.x, r.x) && t.y <= Math.max(i.y, r.y) && t.y >= Math.min(i.y, r.y)
        }

        function qd(i) {
          return i > 0 ? 1 : i < 0 ? -1 : 0
        }

        function Lu(i, t) {
          return ka(i.prev, i, i.next) < 0 ? ka(i, t, i.next) >= 0 && ka(i, i.prev, t) >= 0 : ka(i, t, i.prev) < 0 || ka(i, i.next, t) < 0
        }

        function Jg(i, t) {
          const r = wf(i.i, i.x, i.y),
            n = wf(t.i, t.x, t.y),
            c = i.next,
            f = t.prev;
          return i.next = t, t.prev = i, r.next = c, c.prev = r, n.next = r, r.prev = n, f.next = n, n.prev = f, n
        }

        function $g(i, t, r, n) {
          const c = wf(i, t, r);
          return n ? (c.next = n.next, c.prev = n, n.next.prev = c, n.next = c) : (c.prev = c, c.next = c), c
        }

        function Du(i) {
          i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ)
        }

        function wf(i, t, r) {
          return {
            i,
            x: t,
            y: r,
            prev: null,
            next: null,
            z: 0,
            prevZ: null,
            nextZ: null,
            steiner: !1
          }
        }
        class lc {
          constructor(t, r) {
            if (r > t) throw new Error("Min granularity must not be greater than base granularity.");
            this._baseZoomGranularity = t, this._minGranularity = r
          }
          getGranularityForZoomLevel(t) {
            return Math.max(Math.floor(this._baseZoomGranularity / (1 << t)), this._minGranularity, 1)
          }
        }
        class Nd {
          constructor(t) {
            this.fill = t.fill, this.line = t.line, this.tile = t.tile, this.stencil = t.stencil, this.circle = t.circle
          }
        }
        Nd.noSubdivision = new Nd({
          fill: new lc(0, 0),
          line: new lc(0, 0),
          tile: new lc(0, 0),
          stencil: new lc(0, 0),
          circle: 1
        }), zr("SubdivisionGranularityExpression", lc), zr("SubdivisionGranularitySetting", Nd);
        const cc = -32768,
          Ru = 32767;
        class hx {
          constructor(t, r) {
            this._vertexBuffer = [], this._vertexDictionary = new Map, this._used = !1, this._granularity = t, this._granularityCellSize = nt / t, this._canonical = r
          }
          _getKey(t, r) {
            return (t += 32768) << 16 | r + 32768
          }
          _vertexToIndex(t, r) {
            if (t < -32768 || r < -32768 || t > 32767 || r > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
            const n = 0 | Math.round(t),
              c = 0 | Math.round(r),
              f = this._getKey(n, c);
            if (this._vertexDictionary.has(f)) return this._vertexDictionary.get(f);
            const m = this._vertexBuffer.length / 2;
            return this._vertexDictionary.set(f, m), this._vertexBuffer.push(n, c), m
          }
          _subdivideTrianglesScanline(t) {
            if (this._granularity < 2) return (function(c, f) {
              const m = [];
              for (let v = 0; v < f.length; v += 3) {
                const b = f[v],
                  M = f[v + 1],
                  C = f[v + 2],
                  D = c[2 * b],
                  N = c[2 * b + 1];
                (c[2 * M] - D) * (c[2 * C + 1] - N) - (c[2 * M + 1] - N) * (c[2 * C] - D) > 0 ? (m.push(b), m.push(C), m.push(M)) : (m.push(b), m.push(M), m.push(C))
              }
              return m
            })(this._vertexBuffer, t);
            const r = [],
              n = t.length;
            for (let c = 0; c < n; c += 3) {
              const f = [t[c + 0], t[c + 1], t[c + 2]],
                m = [this._vertexBuffer[2 * t[c + 0] + 0], this._vertexBuffer[2 * t[c + 0] + 1], this._vertexBuffer[2 * t[c + 1] + 0], this._vertexBuffer[2 * t[c + 1] + 1], this._vertexBuffer[2 * t[c + 2] + 0], this._vertexBuffer[2 * t[c + 2] + 1]];
              let v = 1 / 0,
                b = 1 / 0,
                M = -1 / 0,
                C = -1 / 0;
              for (let Q = 0; Q < 3; Q++) {
                const le = m[2 * Q],
                  we = m[2 * Q + 1];
                v = Math.min(v, le), M = Math.max(M, le), b = Math.min(b, we), C = Math.max(C, we)
              }
              if (v === M || b === C) continue;
              const D = Math.floor(v / this._granularityCellSize),
                N = Math.ceil(M / this._granularityCellSize),
                W = Math.floor(b / this._granularityCellSize),
                X = Math.ceil(C / this._granularityCellSize);
              if (D !== N || W !== X)
                for (let Q = W; Q < X; Q++) {
                  const le = this._scanlineGenerateVertexRingForCellRow(Q, m, f);
                  dx(this._vertexBuffer, le, r)
                } else r.push(...f)
            }
            return r
          }
          _scanlineGenerateVertexRingForCellRow(t, r, n) {
            const c = t * this._granularityCellSize,
              f = c + this._granularityCellSize,
              m = [];
            for (let v = 0; v < 3; v++) {
              const b = r[2 * v],
                M = r[2 * v + 1],
                C = r[2 * (v + 1) % 6],
                D = r[(2 * (v + 1) + 1) % 6],
                N = r[2 * (v + 2) % 6],
                W = r[(2 * (v + 2) + 1) % 6],
                X = C - b,
                Q = D - M,
                le = X === 0,
                we = Q === 0,
                et = (c - M) / Q,
                De = (f - M) / Q,
                Ze = Math.min(et, De),
                mt = Math.max(et, De);
              if (!we && (Ze >= 1 || mt <= 0) || we && (M < c || M > f)) {
                D >= c && D <= f && m.push(n[(v + 1) % 3]);
                continue
              }!we && Ze > 0 && m.push(this._vertexToIndex(b + X * Ze, M + Q * Ze));
              const Mt = b + X * Math.max(Ze, 0),
                $t = b + X * Math.min(mt, 1);
              le || this._generateIntraEdgeVertices(m, b, M, C, D, Mt, $t), !we && mt < 1 && m.push(this._vertexToIndex(b + X * mt, M + Q * mt)), (we || D >= c && D <= f) && m.push(n[(v + 1) % 3]), !we && (D <= c || D >= f) && this._generateInterEdgeVertices(m, b, M, C, D, N, W, $t, c, f)
            }
            return m
          }
          _generateIntraEdgeVertices(t, r, n, c, f, m, v) {
            const b = c - r,
              M = f - n,
              C = M === 0,
              D = C ? Math.min(r, c) : Math.min(m, v),
              N = C ? Math.max(r, c) : Math.max(m, v),
              W = Math.floor(D / this._granularityCellSize) + 1,
              X = Math.ceil(N / this._granularityCellSize) - 1;
            if (C ? r < c : m < v)
              for (let Q = W; Q <= X; Q++) {
                const le = Q * this._granularityCellSize;
                t.push(this._vertexToIndex(le, n + M * (le - r) / b))
              } else
                for (let Q = X; Q >= W; Q--) {
                  const le = Q * this._granularityCellSize;
                  t.push(this._vertexToIndex(le, n + M * (le - r) / b))
                }
          }
          _generateInterEdgeVertices(t, r, n, c, f, m, v, b, M, C) {
            const D = f - n,
              N = m - c,
              W = v - f,
              X = (M - f) / W,
              Q = (C - f) / W,
              le = Math.min(X, Q),
              we = Math.max(X, Q),
              et = c + N * le;
            let De = Math.floor(Math.min(et, b) / this._granularityCellSize) + 1,
              Ze = Math.ceil(Math.max(et, b) / this._granularityCellSize) - 1,
              mt = b < et;
            const Mt = W === 0;
            if (Mt && (v === M || v === C)) return;
            if (Mt || le >= 1 || we <= 0) {
              const Tr = n - v,
                hr = m + (r - m) * Math.min((M - v) / Tr, (C - v) / Tr);
              De = Math.floor(Math.min(hr, b) / this._granularityCellSize) + 1, Ze = Math.ceil(Math.max(hr, b) / this._granularityCellSize) - 1, mt = b < hr
            }
            const $t = D > 0 ? C : M;
            if (mt)
              for (let Tr = De; Tr <= Ze; Tr++) t.push(this._vertexToIndex(Tr * this._granularityCellSize, $t));
            else
              for (let Tr = Ze; Tr >= De; Tr--) t.push(this._vertexToIndex(Tr * this._granularityCellSize, $t))
          }
          _generateOutline(t) {
            const r = [];
            for (const n of t) {
              const c = ul(n, this._granularity, !0),
                f = this._pointArrayToIndices(c),
                m = [];
              for (let v = 1; v < f.length; v++) m.push(f[v - 1]), m.push(f[v]);
              r.push(m)
            }
            return r
          }
          _handlePoles(t) {
            let r = !1,
              n = !1;
            this._canonical && (this._canonical.y === 0 && (r = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (n = !0)), (r || n) && this._fillPoles(t, r, n)
          }
          _ensureNoPoleVertices() {
            const t = this._vertexBuffer;
            for (let r = 0; r < t.length; r += 2) {
              const n = t[r + 1];
              n === cc && (t[r + 1] = -32767), n === Ru && (t[r + 1] = 32766)
            }
          }
          _generatePoleQuad(t, r, n, c, f, m) {
            c > f != (m === cc) ? (t.push(r), t.push(n), t.push(this._vertexToIndex(c, m)), t.push(n), t.push(this._vertexToIndex(f, m)), t.push(this._vertexToIndex(c, m))) : (t.push(n), t.push(r), t.push(this._vertexToIndex(c, m)), t.push(this._vertexToIndex(f, m)), t.push(n), t.push(this._vertexToIndex(c, m)))
          }
          _fillPoles(t, r, n) {
            const c = this._vertexBuffer,
              f = nt,
              m = t.length;
            for (let v = 2; v < m; v += 3) {
              const b = t[v - 2],
                M = t[v - 1],
                C = t[v],
                D = c[2 * b],
                N = c[2 * b + 1],
                W = c[2 * M],
                X = c[2 * M + 1],
                Q = c[2 * C],
                le = c[2 * C + 1];
              r && (N === 0 && X === 0 && this._generatePoleQuad(t, b, M, D, W, cc), X === 0 && le === 0 && this._generatePoleQuad(t, M, C, W, Q, cc), le === 0 && N === 0 && this._generatePoleQuad(t, C, b, Q, D, cc)), n && (N === f && X === f && this._generatePoleQuad(t, b, M, D, W, Ru), X === f && le === f && this._generatePoleQuad(t, M, C, W, Q, Ru), le === f && N === f && this._generatePoleQuad(t, C, b, Q, D, Ru))
            }
          }
          _initializeVertices(t) {
            for (let r = 0; r < t.length; r += 2) this._vertexToIndex(t[r], t[r + 1])
          }
          subdividePolygonInternal(t, r) {
            if (this._used) throw new Error("Subdivision: multiple use not allowed.");
            this._used = !0;
            const {
              flattened: n,
              holeIndices: c
            } = (function(v) {
              const b = [],
                M = [];
              for (const C of v)
                if (C.length !== 0) {
                  C !== v[0] && b.push(M.length / 2);
                  for (let D = 0; D < C.length; D++) M.push(C[D].x), M.push(C[D].y)
                } return {
                flattened: M,
                holeIndices: b
              }
            })(t);
            let f;
            this._initializeVertices(n);
            try {
              const v = (function(M, C, D = 2) {
                  const N = C && C.length,
                    W = N ? C[0] * D : M.length;
                  let X = Xg(M, 0, W, D, !0);
                  const Q = [];
                  if (!X || X.next === X.prev) return Q;
                  let le, we, et;
                  if (N && (X = (function(De, Ze, mt, Mt) {
                      const $t = [];
                      for (let Tr = 0, hr = Ze.length; Tr < hr; Tr++) {
                        const yr = Xg(De, Ze[Tr] * Mt, Tr < hr - 1 ? Ze[Tr + 1] * Mt : De.length, Mt, !1);
                        yr === yr.next && (yr.steiner = !0), $t.push(cx(yr))
                      }
                      $t.sort(sx);
                      for (let Tr = 0; Tr < $t.length; Tr++) mt = ox($t[Tr], mt);
                      return mt
                    })(M, C, X, D)), M.length > 80 * D) {
                    le = M[0], we = M[1];
                    let De = le,
                      Ze = we;
                    for (let mt = D; mt < W; mt += D) {
                      const Mt = M[mt],
                        $t = M[mt + 1];
                      Mt < le && (le = Mt), $t < we && (we = $t), Mt > De && (De = Mt), $t > Ze && (Ze = $t)
                    }
                    et = Math.max(De - le, Ze - we), et = et !== 0 ? 32767 / et : 0
                  }
                  return zu(X, Q, D, le, we, et, 0), Q
                })(n, c),
                b = this._convertIndices(n, v);
              f = this._subdivideTrianglesScanline(b)
            } catch (v) {
              console.error(v)
            }
            let m = [];
            return r && (m = this._generateOutline(t)), this._ensureNoPoleVertices(), this._handlePoles(f), {
              verticesFlattened: this._vertexBuffer,
              indicesTriangles: f,
              indicesLineList: m
            }
          }
          _convertIndices(t, r) {
            const n = [];
            for (let c = 0; c < r.length; c++) n.push(this._vertexToIndex(t[2 * r[c]], t[2 * r[c] + 1]));
            return n
          }
          _pointArrayToIndices(t) {
            const r = [];
            for (let n = 0; n < t.length; n++) {
              const c = t[n];
              r.push(this._vertexToIndex(c.x, c.y))
            }
            return r
          }
        }

        function Qg(i, t, r, n = !0) {
          return new hx(r, t).subdividePolygonInternal(i, n)
        }

        function ul(i, t, r = !1) {
          if (!i || i.length < 1) return [];
          if (i.length < 2) return [];
          const n = i[0],
            c = i[i.length - 1],
            f = r && (n.x !== c.x || n.y !== c.y);
          if (t < 2) return f ? [...i, i[0]] : [...i];
          const m = Math.floor(nt / t),
            v = [];
          v.push(new F(i[0].x, i[0].y));
          const b = i.length,
            M = f ? b : b - 1;
          for (let C = 0; C < M; C++) {
            const D = i[C],
              N = C < b - 1 ? i[C + 1] : i[0],
              W = D.x,
              X = D.y,
              Q = N.x,
              le = N.y,
              we = W !== Q,
              et = X !== le;
            if (!we && !et) continue;
            const De = Q - W,
              Ze = le - X,
              mt = Math.abs(De),
              Mt = Math.abs(Ze);
            let $t = W,
              Tr = X;
            for (;;) {
              const yr = De > 0 ? (Math.floor($t / m) + 1) * m : (Math.ceil($t / m) - 1) * m,
                $r = Ze > 0 ? (Math.floor(Tr / m) + 1) * m : (Math.ceil(Tr / m) - 1) * m,
                gr = Math.abs($t - yr),
                xr = Math.abs(Tr - $r),
                Ft = Math.abs($t - Q),
                mi = Math.abs(Tr - le),
                xi = we ? gr / mt : Number.POSITIVE_INFINITY,
                si = et ? xr / Mt : Number.POSITIVE_INFINITY;
              if ((Ft <= gr || !we) && (mi <= xr || !et)) break;
              if (xi < si && we || !et) {
                $t = yr, Tr += Ze * xi;
                const Hr = new F($t, Math.round(Tr));
                v[v.length - 1].x === Hr.x && v[v.length - 1].y === Hr.y || v.push(Hr)
              } else {
                $t += De * si, Tr = $r;
                const Hr = new F(Math.round($t), Tr);
                v[v.length - 1].x === Hr.x && v[v.length - 1].y === Hr.y || v.push(Hr)
              }
            }
            const hr = new F(Q, le);
            v[v.length - 1].x === hr.x && v[v.length - 1].y === hr.y || v.push(hr)
          }
          return v
        }

        function dx(i, t, r) {
          if (t.length === 0) throw new Error("Subdivision vertex ring is empty.");
          let n = 0,
            c = i[2 * t[0]];
          for (let b = 1; b < t.length; b++) {
            const M = i[2 * t[b]];
            M < c && (c = M, n = b)
          }
          const f = t.length;
          let m = n,
            v = (m + 1) % f;
          for (;;) {
            const b = m - 1 >= 0 ? m - 1 : f - 1,
              M = (v + 1) % f,
              C = i[2 * t[b]],
              D = i[2 * t[M]],
              N = i[2 * t[m]],
              W = i[2 * t[m] + 1],
              X = i[2 * t[v] + 1];
            let Q = !1;
            if (C < D) Q = !0;
            else if (C > D) Q = !1;
            else {
              const le = X - W,
                we = -(i[2 * t[v]] - N),
                et = W < X ? 1 : -1;
              ((C - N) * le + (i[2 * t[b] + 1] - W) * we) * et > ((D - N) * le + (i[2 * t[M] + 1] - W) * we) * et && (Q = !0)
            }
            if (Q) {
              const le = t[b],
                we = t[m],
                et = t[v];
              le !== we && le !== et && we !== et && r.push(et, we, le), m--, m < 0 && (m = f - 1)
            } else {
              const le = t[M],
                we = t[m],
                et = t[v];
              le !== we && le !== et && we !== et && r.push(et, we, le), v++, v >= f && (v = 0)
            }
            if (b === M) break
          }
        }

        function e_(i, t, r, n, c, f, m, v, b) {
          const M = c.length / 2,
            C = m && v && b;
          if (M < Li.MAX_VERTEX_ARRAY_LENGTH) {
            const D = t.prepareSegment(M, r, n),
              N = D.vertexLength;
            for (let Q = 0; Q < f.length; Q += 3) n.emplaceBack(N + f[Q], N + f[Q + 1], N + f[Q + 2]);
            let W, X;
            D.vertexLength += M, D.primitiveLength += f.length / 3, C && (X = m.prepareSegment(M, r, v), W = X.vertexLength, X.vertexLength += M);
            for (let Q = 0; Q < c.length; Q += 2) i(c[Q], c[Q + 1]);
            if (C)
              for (let Q = 0; Q < b.length; Q++) {
                const le = b[Q];
                for (let we = 1; we < le.length; we += 2) v.emplaceBack(W + le[we - 1], W + le[we]);
                X.primitiveLength += le.length / 2
              }
          } else(function(D, N, W, X, Q, le) {
            const we = [];
            for (let Mt = 0; Mt < X.length / 2; Mt++) we.push(-1);
            const et = {
              count: 0
            };
            let De = 0,
              Ze = D.getOrCreateLatestSegment(N, W),
              mt = Ze.vertexLength;
            for (let Mt = 2; Mt < Q.length; Mt += 3) {
              const $t = Q[Mt - 2],
                Tr = Q[Mt - 1],
                hr = Q[Mt];
              let yr = we[$t] < De,
                $r = we[Tr] < De,
                gr = we[hr] < De;
              Ze.vertexLength + ((yr ? 1 : 0) + ($r ? 1 : 0) + (gr ? 1 : 0)) > Li.MAX_VERTEX_ARRAY_LENGTH && (Ze = D.createNewSegment(N, W), De = et.count, yr = !0, $r = !0, gr = !0, mt = 0);
              const xr = Fu(we, X, le, et, $t, yr, Ze),
                Ft = Fu(we, X, le, et, Tr, $r, Ze),
                mi = Fu(we, X, le, et, hr, gr, Ze);
              W.emplaceBack(mt + xr - De, mt + Ft - De, mt + mi - De), Ze.primitiveLength++
            }
          })(t, r, n, c, f, i), C && (function(D, N, W, X, Q, le) {
            const we = [];
            for (let Mt = 0; Mt < X.length / 2; Mt++) we.push(-1);
            const et = {
              count: 0
            };
            let De = 0,
              Ze = D.getOrCreateLatestSegment(N, W),
              mt = Ze.vertexLength;
            for (let Mt = 0; Mt < Q.length; Mt++) {
              const $t = Q[Mt];
              for (let Tr = 1; Tr < Q[Mt].length; Tr += 2) {
                const hr = $t[Tr - 1],
                  yr = $t[Tr];
                let $r = we[hr] < De,
                  gr = we[yr] < De;
                Ze.vertexLength + (($r ? 1 : 0) + (gr ? 1 : 0)) > Li.MAX_VERTEX_ARRAY_LENGTH && (Ze = D.createNewSegment(N, W), De = et.count, $r = !0, gr = !0, mt = 0);
                const xr = Fu(we, X, le, et, hr, $r, Ze),
                  Ft = Fu(we, X, le, et, yr, gr, Ze);
                W.emplaceBack(mt + xr - De, mt + Ft - De), Ze.primitiveLength++
              }
            }
          })(m, r, v, c, b, i), t.forceNewSegmentOnNextPrepare(), m == null || m.forceNewSegmentOnNextPrepare()
        }

        function Fu(i, t, r, n, c, f, m) {
          if (f) {
            const v = n.count;
            return r(t[2 * c], t[2 * c + 1]), i[c] = n.count, n.count++, m.vertexLength++, v
          }
          return i[c]
        }
        class Tf {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r => r.id)), this.index = t.index, this.hasDependencies = !1, this.patternFeatures = [], this.layoutVertexArray = new Ie, this.indexArray = new Nt, this.indexArray2 = new Nr, this.programConfigurations = new to(t.layers, t.zoom), this.segments = new Li, this.segments2 = new Li, this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
          }
          populate(t, r, n) {
            this.hasDependencies = Od("fill", this.layers, r);
            const c = this.layers[0].layout.get("fill-sort-key"),
              f = !c.isConstant(),
              m = [];
            for (const {
                feature: v,
                id: b,
                index: M,
                sourceLayerIndex: C
              }
              of t) {
              const D = this.layers[0]._featureFilter.needGeometry,
                N = ks(v, D);
              if (!this.layers[0]._featureFilter.filter(new ta(this.zoom), N, n)) continue;
              const W = f ? c.evaluate(N, {}, n, r.availableImages) : void 0,
                X = {
                  id: b,
                  properties: v.properties,
                  type: v.type,
                  sourceLayerIndex: C,
                  index: M,
                  geometry: D ? N.geometry : _s(v),
                  patterns: {},
                  sortKey: W
                };
              m.push(X)
            }
            f && m.sort(((v, b) => v.sortKey - b.sortKey));
            for (const v of m) {
              const {
                geometry: b,
                index: M,
                sourceLayerIndex: C
              } = v;
              if (this.hasDependencies) {
                const D = xf("fill", this.layers, v, {
                  zoom: this.zoom
                }, r);
                this.patternFeatures.push(D)
              } else this.addFeature(v, b, M, n, {}, r.subdivisionGranularity);
              r.featureIndex.insert(t[M].feature, b, M, C, this.index)
            }
          }
          update(t, r, n) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, {
              imagePositions: n
            })
          }
          addFeatures(t, r, n) {
            for (const c of this.patternFeatures) this.addFeature(c, c.geometry, c.index, r, n, t.subdivisionGranularity)
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, tx), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy())
          }
          addFeature(t, r, n, c, f, m) {
            for (const v of Al(r, 500)) {
              const b = Qg(v, c, m.fill.getGranularityForZoomLevel(c.z)),
                M = this.layoutVertexArray;
              e_(((C, D) => {
                M.emplaceBack(C, D)
              }), this.segments, this.layoutVertexArray, this.indexArray, b.verticesFlattened, b.indicesTriangles, this.segments2, this.indexArray2, b.indicesLineList)
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, n, {
              imagePositions: f,
              canonical: c
            })
          }
        }
        let t_, r_;
        zr("FillBucket", Tf, {
          omit: ["layers", "patternFeatures"]
        });
        var px = {
          get paint() {
            return r_ = r_ || new an({
              "fill-antialias": new Xr(Y.paint_fill["fill-antialias"]),
              "fill-opacity": new hi(Y.paint_fill["fill-opacity"]),
              "fill-color": new hi(Y.paint_fill["fill-color"]),
              "fill-outline-color": new hi(Y.paint_fill["fill-outline-color"]),
              "fill-translate": new Xr(Y.paint_fill["fill-translate"]),
              "fill-translate-anchor": new Xr(Y.paint_fill["fill-translate-anchor"]),
              "fill-pattern": new nl(Y.paint_fill["fill-pattern"])
            })
          },
          get layout() {
            return t_ = t_ || new an({
              "fill-sort-key": new hi(Y.layout_fill["fill-sort-key"])
            })
          }
        };
        class fx extends Zn {
          constructor(t, r) {
            super(t, px, r)
          }
          recalculate(t, r) {
            super.recalculate(t, r);
            const n = this.paint._values["fill-outline-color"];
            n.value.kind === "constant" && n.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"])
          }
          createBucket(t) {
            return new Tf(t)
          }
          queryRadius() {
            return Fd(this.paint.get("fill-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: t,
            geometry: r,
            transform: n,
            pixelsToTileUnits: c
          }) {
            return Dg(Bd(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -n.bearingInRadians, c), r)
          }
          isTileClipped() {
            return !0
          }
        }
        const mx = wa([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_normal_ed",
            components: 4,
            type: "Int16"
          }], 4),
          gx = wa([{
            name: "a_centroid",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: _x
          } = mx;
        class uc {
          constructor(t, r, n, c, f) {
            this.properties = {}, this.extent = n, this.type = 0, this.id = void 0, this._pbf = t, this._geometry = -1, this._keys = c, this._values = f, t.readFields(vx, this, r)
          }
          loadGeometry() {
            const t = this._pbf;
            t.pos = this._geometry;
            const r = t.readVarint() + t.pos,
              n = [];
            let c, f = 1,
              m = 0,
              v = 0,
              b = 0;
            for (; t.pos < r;) {
              if (m <= 0) {
                const M = t.readVarint();
                f = 7 & M, m = M >> 3
              }
              if (m--, f === 1 || f === 2) v += t.readSVarint(), b += t.readSVarint(), f === 1 && (c && n.push(c), c = []), c && c.push(new F(v, b));
              else {
                if (f !== 7) throw new Error(`unknown command ${f}`);
                c && c.push(c[0].clone())
              }
            }
            return c && n.push(c), n
          }
          bbox() {
            const t = this._pbf;
            t.pos = this._geometry;
            const r = t.readVarint() + t.pos;
            let n = 1,
              c = 0,
              f = 0,
              m = 0,
              v = 1 / 0,
              b = -1 / 0,
              M = 1 / 0,
              C = -1 / 0;
            for (; t.pos < r;) {
              if (c <= 0) {
                const D = t.readVarint();
                n = 7 & D, c = D >> 3
              }
              if (c--, n === 1 || n === 2) f += t.readSVarint(), m += t.readSVarint(), f < v && (v = f), f > b && (b = f), m < M && (M = m), m > C && (C = m);
              else if (n !== 7) throw new Error(`unknown command ${n}`)
            }
            return [v, M, b, C]
          }
          toGeoJSON(t, r, n) {
            const c = this.extent * Math.pow(2, n),
              f = this.extent * t,
              m = this.extent * r,
              v = this.loadGeometry();

            function b(N) {
              return [360 * (N.x + f) / c - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (N.y + m) / c) * Math.PI)) - 90]
            }

            function M(N) {
              return N.map(b)
            }
            let C;
            if (this.type === 1) {
              const N = [];
              for (const X of v) N.push(X[0]);
              const W = M(N);
              C = N.length === 1 ? {
                type: "Point",
                coordinates: W[0]
              } : {
                type: "MultiPoint",
                coordinates: W
              }
            } else if (this.type === 2) {
              const N = v.map(M);
              C = N.length === 1 ? {
                type: "LineString",
                coordinates: N[0]
              } : {
                type: "MultiLineString",
                coordinates: N
              }
            } else {
              if (this.type !== 3) throw new Error("unknown feature type");
              {
                const N = (function(X) {
                    const Q = X.length;
                    if (Q <= 1) return [X];
                    const le = [];
                    let we, et;
                    for (let De = 0; De < Q; De++) {
                      const Ze = yx(X[De]);
                      Ze !== 0 && (et === void 0 && (et = Ze < 0), et === Ze < 0 ? (we && le.push(we), we = [X[De]]) : we && we.push(X[De]))
                    }
                    return we && le.push(we), le
                  })(v),
                  W = [];
                for (const X of N) W.push(X.map(M));
                C = W.length === 1 ? {
                  type: "Polygon",
                  coordinates: W[0]
                } : {
                  type: "MultiPolygon",
                  coordinates: W
                }
              }
            }
            const D = {
              type: "Feature",
              geometry: C,
              properties: this.properties
            };
            return this.id != null && (D.id = this.id), D
          }
        }

        function vx(i, t, r) {
          i === 1 ? t.id = r.readVarint() : i === 2 ? (function(n, c) {
            const f = n.readVarint() + n.pos;
            for (; n.pos < f;) {
              const m = c._keys[n.readVarint()],
                v = c._values[n.readVarint()];
              c.properties[m] = v
            }
          })(r, t) : i === 3 ? t.type = r.readVarint() : i === 4 && (t._geometry = r.pos)
        }

        function yx(i) {
          let t = 0;
          for (let r, n, c = 0, f = i.length, m = f - 1; c < f; m = c++) r = i[c], n = i[m], t += (n.x - r.x) * (r.y + n.y);
          return t
        }
        uc.types = ["Unknown", "Point", "LineString", "Polygon"];
        class i_ {
          constructor(t, r) {
            this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(xx, this, r), this.length = this._features.length
          }
          feature(t) {
            if (t < 0 || t >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t];
            const r = this._pbf.readVarint() + this._pbf.pos;
            return new uc(this._pbf, r, this.extent, this._keys, this._values)
          }
        }

        function xx(i, t, r) {
          i === 15 ? t.version = r.readVarint() : i === 1 ? t.name = r.readString() : i === 5 ? t.extent = r.readVarint() : i === 2 ? t._features.push(r.pos) : i === 3 ? t._keys.push(r.readString()) : i === 4 && t._values.push((function(n) {
            let c = null;
            const f = n.readVarint() + n.pos;
            for (; n.pos < f;) {
              const m = n.readVarint() >> 3;
              c = m === 1 ? n.readString() : m === 2 ? n.readFloat() : m === 3 ? n.readDouble() : m === 4 ? n.readVarint64() : m === 5 ? n.readVarint() : m === 6 ? n.readSVarint() : m === 7 ? n.readBoolean() : null
            }
            if (c == null) throw new Error("unknown feature value");
            return c
          })(r))
        }
        class a_ {
          constructor(t, r) {
            this.layers = t.readFields(bx, {}, r)
          }
        }

        function bx(i, t, r) {
          if (i === 3) {
            const n = new i_(r, r.readVarint() + r.pos);
            n.length && (t[n.name] = n)
          }
        }
        const Sf = Math.pow(2, 13);

        function Bu(i, t, r, n, c, f, m, v) {
          i.emplaceBack(t, r, 2 * Math.floor(n * Sf) + m, c * Sf * 2, f * Sf * 2, Math.round(v))
        }
        class Pf {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r => r.id)), this.index = t.index, this.hasDependencies = !1, this.layoutVertexArray = new Oe, this.centroidVertexArray = new Ce, this.indexArray = new Nt, this.programConfigurations = new to(t.layers, t.zoom), this.segments = new Li, this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
          }
          populate(t, r, n) {
            this.features = [], this.hasDependencies = Od("fill-extrusion", this.layers, r);
            for (const {
                feature: c,
                id: f,
                index: m,
                sourceLayerIndex: v
              }
              of t) {
              const b = this.layers[0]._featureFilter.needGeometry,
                M = ks(c, b);
              if (!this.layers[0]._featureFilter.filter(new ta(this.zoom), M, n)) continue;
              const C = {
                id: f,
                sourceLayerIndex: v,
                index: m,
                geometry: b ? M.geometry : _s(c),
                properties: c.properties,
                type: c.type,
                patterns: {}
              };
              this.hasDependencies ? this.features.push(xf("fill-extrusion", this.layers, C, {
                zoom: this.zoom
              }, r)) : this.addFeature(C, C.geometry, m, n, {}, r.subdivisionGranularity), r.featureIndex.insert(c, C.geometry, m, v, this.index, !0)
            }
          }
          addFeatures(t, r, n) {
            for (const c of this.features) {
              const {
                geometry: f
              } = c;
              this.addFeature(c, f, c.index, r, n, t.subdivisionGranularity)
            }
          }
          update(t, r, n) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, {
              imagePositions: n
            })
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, _x), this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, gx.members, !0), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy())
          }
          addFeature(t, r, n, c, f, m) {
            for (const v of Al(r, 500)) {
              const b = {
                  x: 0,
                  y: 0,
                  sampleCount: 0
                },
                M = this.layoutVertexArray.length;
              this.processPolygon(b, c, t, v, m);
              const C = this.layoutVertexArray.length - M,
                D = Math.floor(b.x / b.sampleCount),
                N = Math.floor(b.y / b.sampleCount);
              for (let W = 0; W < C; W++) this.centroidVertexArray.emplaceBack(D, N)
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, n, {
              imagePositions: f,
              canonical: c
            })
          }
          processPolygon(t, r, n, c, f) {
            if (c.length < 1 || n_(c[0])) return;
            for (const D of c) D.length !== 0 && wx(t, D);
            const m = {
                segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray)
              },
              v = f.fill.getGranularityForZoomLevel(r.z),
              b = uc.types[n.type] === "Polygon";
            for (const D of c) {
              if (D.length === 0 || n_(D)) continue;
              const N = ul(D, v, b);
              this._generateSideFaces(N, m)
            }
            if (!b) return;
            const M = Qg(c, r, v, !1),
              C = this.layoutVertexArray;
            e_(((D, N) => {
              Bu(C, D, N, 0, 0, 1, 1, 0)
            }), this.segments, this.layoutVertexArray, this.indexArray, M.verticesFlattened, M.indicesTriangles)
          }
          _generateSideFaces(t, r) {
            let n = 0;
            for (let c = 1; c < t.length; c++) {
              const f = t[c],
                m = t[c - 1];
              if (Tx(f, m)) continue;
              r.segment.vertexLength + 4 > Li.MAX_VERTEX_ARRAY_LENGTH && (r.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              const v = f.sub(m)._perp()._unit(),
                b = m.dist(f);
              n + b > 32768 && (n = 0), Bu(this.layoutVertexArray, f.x, f.y, v.x, v.y, 0, 0, n), Bu(this.layoutVertexArray, f.x, f.y, v.x, v.y, 0, 1, n), n += b, Bu(this.layoutVertexArray, m.x, m.y, v.x, v.y, 0, 0, n), Bu(this.layoutVertexArray, m.x, m.y, v.x, v.y, 0, 1, n);
              const M = r.segment.vertexLength;
              this.indexArray.emplaceBack(M, M + 2, M + 1), this.indexArray.emplaceBack(M + 1, M + 2, M + 3), r.segment.vertexLength += 4, r.segment.primitiveLength += 2
            }
          }
        }

        function wx(i, t) {
          for (let r = 0; r < t.length; r++) {
            const n = t[r];
            r === t.length - 1 && t[0].x === n.x && t[0].y === n.y || (i.x += n.x, i.y += n.y, i.sampleCount++)
          }
        }

        function Tx(i, t) {
          return i.x === t.x && (i.x < 0 || i.x > nt) || i.y === t.y && (i.y < 0 || i.y > nt)
        }

        function n_(i) {
          return i.every((t => t.x < 0)) || i.every((t => t.x > nt)) || i.every((t => t.y < 0)) || i.every((t => t.y > nt))
        }
        let s_;
        zr("FillExtrusionBucket", Pf, {
          omit: ["layers", "features"]
        });
        var Sx = {
          get paint() {
            return s_ = s_ || new an({
              "fill-extrusion-opacity": new Xr(Y["paint_fill-extrusion"]["fill-extrusion-opacity"]),
              "fill-extrusion-color": new hi(Y["paint_fill-extrusion"]["fill-extrusion-color"]),
              "fill-extrusion-translate": new Xr(Y["paint_fill-extrusion"]["fill-extrusion-translate"]),
              "fill-extrusion-translate-anchor": new Xr(Y["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
              "fill-extrusion-pattern": new nl(Y["paint_fill-extrusion"]["fill-extrusion-pattern"]),
              "fill-extrusion-height": new hi(Y["paint_fill-extrusion"]["fill-extrusion-height"]),
              "fill-extrusion-base": new hi(Y["paint_fill-extrusion"]["fill-extrusion-base"]),
              "fill-extrusion-vertical-gradient": new Xr(Y["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])
            })
          }
        };
        class Px extends Zn {
          constructor(t, r) {
            super(t, Sx, r)
          }
          createBucket(t) {
            return new Pf(t)
          }
          queryRadius() {
            return Fd(this.paint.get("fill-extrusion-translate"))
          }
          is3D() {
            return !0
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: r,
            featureState: n,
            geometry: c,
            transform: f,
            pixelsToTileUnits: m,
            pixelPosMatrix: v
          }) {
            const b = Bd(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -f.bearingInRadians, m),
              M = this.paint.get("fill-extrusion-height").evaluate(r, n),
              C = this.paint.get("fill-extrusion-base").evaluate(r, n),
              D = (function(W, X) {
                const Q = [];
                for (const le of W) {
                  const we = [le.x, le.y, 0, 1];
                  je(we, we, X), Q.push(new F(we[0] / we[3], we[1] / we[3]))
                }
                return Q
              })(b, v),
              N = (function(W, X, Q, le) {
                const we = [],
                  et = [],
                  De = le[8] * X,
                  Ze = le[9] * X,
                  mt = le[10] * X,
                  Mt = le[11] * X,
                  $t = le[8] * Q,
                  Tr = le[9] * Q,
                  hr = le[10] * Q,
                  yr = le[11] * Q;
                for (const $r of W) {
                  const gr = [],
                    xr = [];
                  for (const Ft of $r) {
                    const mi = Ft.x,
                      xi = Ft.y,
                      si = le[0] * mi + le[4] * xi + le[12],
                      Hr = le[1] * mi + le[5] * xi + le[13],
                      Ni = le[2] * mi + le[6] * xi + le[14],
                      ba = le[3] * mi + le[7] * xi + le[15],
                      Ra = Ni + mt,
                      sn = ba + Mt,
                      Hn = si + $t,
                      Pn = Hr + Tr,
                      Ja = Ni + hr,
                      ya = ba + yr,
                      Wa = new F((si + De) / sn, (Hr + Ze) / sn);
                    Wa.z = Ra / sn, gr.push(Wa);
                    const $a = new F(Hn / ya, Pn / ya);
                    $a.z = Ja / ya, xr.push($a)
                  }
                  we.push(gr), et.push(xr)
                }
                return [we, et]
              })(c, C, M, v);
            return (function(W, X, Q) {
              let le = 1 / 0;
              Dg(Q, X) && (le = o_(Q, X[0]));
              for (let we = 0; we < X.length; we++) {
                const et = X[we],
                  De = W[we];
                for (let Ze = 0; Ze < et.length - 1; Ze++) {
                  const mt = et[Ze],
                    Mt = [mt, et[Ze + 1], De[Ze + 1], De[Ze], mt];
                  Lg(Q, Mt) && (le = Math.min(le, o_(Q, Mt)))
                }
              }
              return le !== 1 / 0 && le
            })(N[0], N[1], D)
          }
        }

        function Ou(i, t) {
          return i.x * t.x + i.y * t.y
        }

        function o_(i, t) {
          if (i.length === 1) {
            let r = 0;
            const n = t[r++];
            let c;
            for (; !c || n.equals(c);)
              if (c = t[r++], !c) return 1 / 0;
            for (; r < t.length; r++) {
              const f = t[r],
                m = i[0],
                v = c.sub(n),
                b = f.sub(n),
                M = m.sub(n),
                C = Ou(v, v),
                D = Ou(v, b),
                N = Ou(b, b),
                W = Ou(M, v),
                X = Ou(M, b),
                Q = C * N - D * D,
                le = (N * W - D * X) / Q,
                we = (C * X - D * W) / Q,
                et = n.z * (1 - le - we) + c.z * le + f.z * we;
              if (isFinite(et)) return et
            }
            return 1 / 0
          } {
            let r = 1 / 0;
            for (const n of t) r = Math.min(r, n.z);
            return r
          }
        }
        const Ix = wa([{
            name: "a_pos_normal",
            components: 2,
            type: "Int16"
          }, {
            name: "a_data",
            components: 4,
            type: "Uint8"
          }], 4),
          {
            members: Mx
          } = Ix,
          Cx = wa([{
            name: "a_uv_x",
            components: 1,
            type: "Float32"
          }, {
            name: "a_split_index",
            components: 1,
            type: "Float32"
          }]),
          {
            members: Ax
          } = Cx,
          kx = Math.cos(Math.PI / 180 * 37.5),
          l_ = Math.pow(2, 14) / .5;
        class If {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((r => r.id)), this.index = t.index, this.hasDependencies = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((r => {
              this.gradients[r.id] = {}
            })), this.layoutVertexArray = new He, this.layoutVertexArray2 = new Le, this.indexArray = new Nt, this.programConfigurations = new to(t.layers, t.zoom), this.segments = new Li, this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((r => r.isStateDependent())).map((r => r.id))
          }
          populate(t, r, n) {
            this.hasDependencies = Od("line", this.layers, r) || this.hasLineDasharray(this.layers);
            const c = this.layers[0].layout.get("line-sort-key"),
              f = !c.isConstant(),
              m = [];
            for (const {
                feature: v,
                id: b,
                index: M,
                sourceLayerIndex: C
              }
              of t) {
              const D = this.layers[0]._featureFilter.needGeometry,
                N = ks(v, D);
              if (!this.layers[0]._featureFilter.filter(new ta(this.zoom), N, n)) continue;
              const W = f ? c.evaluate(N, {}, n) : void 0,
                X = {
                  id: b,
                  properties: v.properties,
                  type: v.type,
                  sourceLayerIndex: C,
                  index: M,
                  geometry: D ? N.geometry : _s(v),
                  patterns: {},
                  dashes: {},
                  sortKey: W
                };
              m.push(X)
            }
            f && m.sort(((v, b) => v.sortKey - b.sortKey));
            for (const v of m) {
              const {
                geometry: b,
                index: M,
                sourceLayerIndex: C
              } = v;
              this.hasDependencies ? (Od("line", this.layers, r) ? xf("line", this.layers, v, {
                zoom: this.zoom
              }, r) : this.hasLineDasharray(this.layers) && this.addLineDashDependencies(this.layers, v, this.zoom, r), this.patternFeatures.push(v)) : this.addFeature(v, b, M, n, {}, {}, r.subdivisionGranularity), r.featureIndex.insert(t[M].feature, b, M, C, this.index)
            }
          }
          update(t, r, n, c) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, r, this.stateDependentLayers, {
              imagePositions: n,
              dashPositions: c
            })
          }
          addFeatures(t, r, n, c) {
            for (const f of this.patternFeatures) this.addFeature(f, f.geometry, f.index, r, n, c, t.subdivisionGranularity)
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, Ax)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Mx), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy())
          }
          lineFeatureClips(t) {
            if (t.properties && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_end")) return {
              start: +t.properties.mapbox_clip_start,
              end: +t.properties.mapbox_clip_end
            }
          }
          addFeature(t, r, n, c, f, m, v) {
            const b = this.layers[0].layout,
              M = b.get("line-join").evaluate(t, {}),
              C = b.get("line-cap"),
              D = b.get("line-miter-limit"),
              N = b.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t);
            for (const W of r) this.addLine(W, t, M, C, D, N, c, v);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, n, {
              imagePositions: f,
              dashPositions: m,
              canonical: c
            })
          }
          addLine(t, r, n, c, f, m, v, b) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t = ul(t, v ? b.line.getGranularityForZoomLevel(v.z) : 1), this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let De = 0; De < t.length - 1; De++) this.totalDistance += t[De].dist(t[De + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance)
            }
            const M = uc.types[r.type] === "Polygon";
            let C = t.length;
            for (; C >= 2 && t[C - 1].equals(t[C - 2]);) C--;
            let D = 0;
            for (; D < C - 1 && t[D].equals(t[D + 1]);) D++;
            if (C < (M ? 3 : 2)) return;
            n === "bevel" && (f = 1.05);
            const N = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0,
              W = this.segments.prepareSegment(10 * C, this.layoutVertexArray, this.indexArray);
            let X, Q, le, we, et;
            this.e1 = this.e2 = -1, M && (X = t[C - 2], et = t[D].sub(X)._unit()._perp());
            for (let De = D; De < C; De++) {
              if (le = De === C - 1 ? M ? t[D + 1] : void 0 : t[De + 1], le && t[De].equals(le)) continue;
              et && (we = et), X && (Q = X), X = t[De], et = le ? le.sub(X)._unit()._perp() : we, we = we || et;
              let Ze = we.add(et);
              Ze.x === 0 && Ze.y === 0 || Ze._unit();
              const mt = we.x * et.x + we.y * et.y,
                Mt = Ze.x * et.x + Ze.y * et.y,
                $t = Mt !== 0 ? 1 / Mt : 1 / 0,
                Tr = 2 * Math.sqrt(2 - 2 * Mt),
                hr = Mt < kx && Q && le,
                yr = we.x * et.y - we.y * et.x > 0;
              if (hr && De > D) {
                const xr = X.dist(Q);
                if (xr > 2 * N) {
                  const Ft = X.sub(X.sub(Q)._mult(N / xr)._round());
                  this.updateDistance(Q, Ft), this.addCurrentVertex(Ft, we, 0, 0, W), Q = Ft
                }
              }
              const $r = Q && le;
              let gr = $r ? n : M ? "butt" : c;
              if ($r && gr === "round" && ($t < m ? gr = "miter" : $t <= 2 && (gr = "fakeround")), gr === "miter" && $t > f && (gr = "bevel"), gr === "bevel" && ($t > 2 && (gr = "flipbevel"), $t < f && (gr = "miter")), Q && this.updateDistance(Q, X), gr === "miter") Ze._mult($t), this.addCurrentVertex(X, Ze, 0, 0, W);
              else if (gr === "flipbevel") {
                if ($t > 100) Ze = et.mult(-1);
                else {
                  const xr = $t * we.add(et).mag() / we.sub(et).mag();
                  Ze._perp()._mult(xr * (yr ? -1 : 1))
                }
                this.addCurrentVertex(X, Ze, 0, 0, W), this.addCurrentVertex(X, Ze.mult(-1), 0, 0, W)
              } else if (gr === "bevel" || gr === "fakeround") {
                const xr = -Math.sqrt($t * $t - 1),
                  Ft = yr ? xr : 0,
                  mi = yr ? 0 : xr;
                if (Q && this.addCurrentVertex(X, we, Ft, mi, W), gr === "fakeround") {
                  const xi = Math.round(180 * Tr / Math.PI / 20);
                  for (let si = 1; si < xi; si++) {
                    let Hr = si / xi;
                    if (Hr !== .5) {
                      const ba = Hr - .5;
                      Hr += Hr * ba * (Hr - 1) * ((1.0904 + mt * (mt * (3.55645 - 1.43519 * mt) - 3.2452)) * ba * ba + (.848013 + mt * (.215638 * mt - 1.06021)))
                    }
                    const Ni = et.sub(we)._mult(Hr)._add(we)._unit()._mult(yr ? -1 : 1);
                    this.addHalfVertex(X, Ni.x, Ni.y, !1, yr, 0, W)
                  }
                }
                le && this.addCurrentVertex(X, et, -Ft, -mi, W)
              } else if (gr === "butt") this.addCurrentVertex(X, Ze, 0, 0, W);
              else if (gr === "square") {
                const xr = Q ? 1 : -1;
                this.addCurrentVertex(X, Ze, xr, xr, W)
              } else gr === "round" && (Q && (this.addCurrentVertex(X, we, 0, 0, W), this.addCurrentVertex(X, we, 1, 1, W, !0)), le && (this.addCurrentVertex(X, et, -1, -1, W, !0), this.addCurrentVertex(X, et, 0, 0, W)));
              if (hr && De < C - 1) {
                const xr = X.dist(le);
                if (xr > 2 * N) {
                  const Ft = X.add(le.sub(X)._mult(N / xr)._round());
                  this.updateDistance(X, Ft), this.addCurrentVertex(Ft, et, 0, 0, W), X = Ft
                }
              }
            }
          }
          addCurrentVertex(t, r, n, c, f, m = !1) {
            const v = r.y * c - r.x,
              b = -r.y - r.x * c;
            this.addHalfVertex(t, r.x + r.y * n, r.y - r.x * n, m, !1, n, f), this.addHalfVertex(t, v, b, m, !0, -c, f), this.distance > l_ / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t, r, n, c, f, m))
          }
          addHalfVertex({
            x: t,
            y: r
          }, n, c, f, m, v, b) {
            const M = .5 * (this.lineClips ? this.scaledDistance * (l_ - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((t << 1) + (f ? 1 : 0), (r << 1) + (m ? 1 : 0), Math.round(63 * n) + 128, Math.round(63 * c) + 128, 1 + (v === 0 ? 0 : v < 0 ? -1 : 1) | (63 & M) << 2, M >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const C = b.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, C, this.e2), b.primitiveLength++), m ? this.e2 = C : this.e1 = C
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance
          }
          updateDistance(t, r) {
            this.distance += t.dist(r), this.updateScaledDistance()
          }
          hasLineDasharray(t) {
            for (const r of t) {
              const n = r.paint.get("line-dasharray");
              if (n && !n.isConstant()) return !0
            }
            return !1
          }
          addLineDashDependencies(t, r, n, c) {
            for (const f of t) {
              const m = f.paint.get("line-dasharray");
              if (!m || m.value.kind === "constant") continue;
              const v = f.layout.get("line-cap") === "round",
                b = {
                  dasharray: m.value.evaluate({
                    zoom: n - 1
                  }, r, {}),
                  round: v
                },
                M = {
                  dasharray: m.value.evaluate({
                    zoom: n
                  }, r, {}),
                  round: v
                },
                C = {
                  dasharray: m.value.evaluate({
                    zoom: n + 1
                  }, r, {}),
                  round: v
                },
                D = `${b.dasharray.join(",")},${b.round}`,
                N = `${M.dasharray.join(",")},${M.round}`,
                W = `${C.dasharray.join(",")},${C.round}`;
              c.dashDependencies[D] = b, c.dashDependencies[N] = M, c.dashDependencies[W] = C, r.dashes[f.id] = {
                min: D,
                mid: N,
                max: W
              }
            }
          }
        }
        let c_, u_;
        zr("LineBucket", If, {
          omit: ["layers", "patternFeatures"]
        });
        var h_ = {
          get paint() {
            return u_ = u_ || new an({
              "line-opacity": new hi(Y.paint_line["line-opacity"]),
              "line-color": new hi(Y.paint_line["line-color"]),
              "line-translate": new Xr(Y.paint_line["line-translate"]),
              "line-translate-anchor": new Xr(Y.paint_line["line-translate-anchor"]),
              "line-width": new hi(Y.paint_line["line-width"]),
              "line-gap-width": new hi(Y.paint_line["line-gap-width"]),
              "line-offset": new hi(Y.paint_line["line-offset"]),
              "line-blur": new hi(Y.paint_line["line-blur"]),
              "line-dasharray": new nl(Y.paint_line["line-dasharray"]),
              "line-pattern": new nl(Y.paint_line["line-pattern"]),
              "line-gradient": new sl(Y.paint_line["line-gradient"])
            })
          },
          get layout() {
            return c_ = c_ || new an({
              "line-cap": new Xr(Y.layout_line["line-cap"]),
              "line-join": new hi(Y.layout_line["line-join"]),
              "line-miter-limit": new Xr(Y.layout_line["line-miter-limit"]),
              "line-round-limit": new Xr(Y.layout_line["line-round-limit"]),
              "line-sort-key": new hi(Y.layout_line["line-sort-key"])
            })
          }
        };
        class zx extends hi {
          possiblyEvaluate(t, r) {
            return r = new ta(Math.floor(r.zoom), {
              now: r.now,
              fadeDuration: r.fadeDuration,
              zoomHistory: r.zoomHistory,
              transition: r.transition
            }), super.possiblyEvaluate(t, r)
          }
          evaluate(t, r, n, c) {
            return r = ht({}, r, {
              zoom: Math.floor(r.zoom)
            }), super.evaluate(t, r, n, c)
          }
        }
        let Vd;
        class Ex extends Zn {
          constructor(t, r) {
            super(t, h_, r), this.gradientVersion = 0, Vd || (Vd = new zx(h_.paint.properties["line-width"].specification), Vd.useIntegerZoom = !0)
          }
          _handleSpecialPaintPropertyUpdate(t) {
            if (t === "line-gradient") {
              const r = this.gradientExpression();
              this.stepInterpolant = !!(function(n) {
                return n._styleExpression !== void 0
              })(r) && r._styleExpression.expression instanceof Ma, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression
          }
          recalculate(t, r) {
            super.recalculate(t, r), this.paint._values["line-floorwidth"] = Vd.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t)
          }
          createBucket(t) {
            return new If(t)
          }
          queryRadius(t) {
            const r = t,
              n = d_(sc("line-width", this, r), sc("line-gap-width", this, r)),
              c = sc("line-offset", this, r);
            return n / 2 + Math.abs(c) + Fd(this.paint.get("line-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: r,
            featureState: n,
            geometry: c,
            transform: f,
            pixelsToTileUnits: m
          }) {
            const v = Bd(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -f.bearingInRadians, m),
              b = m / 2 * d_(this.paint.get("line-width").evaluate(r, n), this.paint.get("line-gap-width").evaluate(r, n)),
              M = this.paint.get("line-offset").evaluate(r, n);
            return M && (c = (function(C, D) {
              const N = [];
              for (let W = 0; W < C.length; W++) {
                const X = C[W],
                  Q = [];
                for (let le = 0; le < X.length; le++) {
                  const we = X[le - 1],
                    et = X[le],
                    De = X[le + 1],
                    Ze = le === 0 ? new F(0, 0) : et.sub(we)._unit()._perp(),
                    mt = le === X.length - 1 ? new F(0, 0) : De.sub(et)._unit()._perp(),
                    Mt = Ze._add(mt)._unit(),
                    $t = Mt.x * mt.x + Mt.y * mt.y;
                  $t !== 0 && Mt._mult(1 / $t), Q.push(Mt._mult(D)._add(et))
                }
                N.push(Q)
              }
              return N
            })(c, M * m)), (function(C, D, N) {
              for (let W = 0; W < D.length; W++) {
                const X = D[W];
                if (C.length >= 3) {
                  for (let Q = 0; Q < X.length; Q++)
                    if (nc(C, X[Q])) return !0
                }
                if (jy(C, X, N)) return !0
              }
              return !1
            })(v, c, b)
          }
          isTileClipped() {
            return !0
          }
        }

        function d_(i, t) {
          return t > 0 ? t + 2 * i : i
        }
        const Lx = wa([{
            name: "a_pos_offset",
            components: 4,
            type: "Int16"
          }, {
            name: "a_data",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_pixeloffset",
            components: 4,
            type: "Int16"
          }], 4),
          Dx = wa([{
            name: "a_projected_pos",
            components: 3,
            type: "Float32"
          }], 4);
        wa([{
          name: "a_fade_opacity",
          components: 1,
          type: "Uint32"
        }], 4);
        const Rx = wa([{
          name: "a_placed",
          components: 2,
          type: "Uint8"
        }, {
          name: "a_shift",
          components: 2,
          type: "Float32"
        }, {
          name: "a_box_real",
          components: 2,
          type: "Int16"
        }]);
        wa([{
          type: "Int16",
          name: "anchorPointX"
        }, {
          type: "Int16",
          name: "anchorPointY"
        }, {
          type: "Int16",
          name: "x1"
        }, {
          type: "Int16",
          name: "y1"
        }, {
          type: "Int16",
          name: "x2"
        }, {
          type: "Int16",
          name: "y2"
        }, {
          type: "Uint32",
          name: "featureIndex"
        }, {
          type: "Uint16",
          name: "sourceLayerIndex"
        }, {
          type: "Uint16",
          name: "bucketIndex"
        }]);
        const p_ = wa([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_anchor_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_extrude",
            components: 2,
            type: "Int16"
          }], 4),
          Fx = wa([{
            name: "a_pos",
            components: 2,
            type: "Float32"
          }, {
            name: "a_radius",
            components: 1,
            type: "Float32"
          }, {
            name: "a_flags",
            components: 2,
            type: "Int16"
          }], 4);

        function Bx(i, t, r) {
          return i.sections.forEach((n => {
            n.text = (function(c, f, m) {
              const v = f.layout.get("text-transform").evaluate(m, {});
              return v === "uppercase" ? c = c.toLocaleUpperCase() : v === "lowercase" && (c = c.toLocaleLowerCase()), ps.applyArabicShaping && (c = ps.applyArabicShaping(c)), c
            })(n.text, t, r)
          })), i
        }
        wa([{
          name: "triangle",
          components: 3,
          type: "Uint16"
        }]), wa([{
          type: "Int16",
          name: "anchorX"
        }, {
          type: "Int16",
          name: "anchorY"
        }, {
          type: "Uint16",
          name: "glyphStartIndex"
        }, {
          type: "Uint16",
          name: "numGlyphs"
        }, {
          type: "Uint32",
          name: "vertexStartIndex"
        }, {
          type: "Uint32",
          name: "lineStartIndex"
        }, {
          type: "Uint32",
          name: "lineLength"
        }, {
          type: "Uint16",
          name: "segment"
        }, {
          type: "Uint16",
          name: "lowerSize"
        }, {
          type: "Uint16",
          name: "upperSize"
        }, {
          type: "Float32",
          name: "lineOffsetX"
        }, {
          type: "Float32",
          name: "lineOffsetY"
        }, {
          type: "Uint8",
          name: "writingMode"
        }, {
          type: "Uint8",
          name: "placedOrientation"
        }, {
          type: "Uint8",
          name: "hidden"
        }, {
          type: "Uint32",
          name: "crossTileID"
        }, {
          type: "Int16",
          name: "associatedIconIndex"
        }]), wa([{
          type: "Int16",
          name: "anchorX"
        }, {
          type: "Int16",
          name: "anchorY"
        }, {
          type: "Int16",
          name: "rightJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "centerJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "leftJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "verticalPlacedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "placedIconSymbolIndex"
        }, {
          type: "Int16",
          name: "verticalPlacedIconSymbolIndex"
        }, {
          type: "Uint16",
          name: "key"
        }, {
          type: "Uint16",
          name: "textBoxStartIndex"
        }, {
          type: "Uint16",
          name: "textBoxEndIndex"
        }, {
          type: "Uint16",
          name: "verticalTextBoxStartIndex"
        }, {
          type: "Uint16",
          name: "verticalTextBoxEndIndex"
        }, {
          type: "Uint16",
          name: "iconBoxStartIndex"
        }, {
          type: "Uint16",
          name: "iconBoxEndIndex"
        }, {
          type: "Uint16",
          name: "verticalIconBoxStartIndex"
        }, {
          type: "Uint16",
          name: "verticalIconBoxEndIndex"
        }, {
          type: "Uint16",
          name: "featureIndex"
        }, {
          type: "Uint16",
          name: "numHorizontalGlyphVertices"
        }, {
          type: "Uint16",
          name: "numVerticalGlyphVertices"
        }, {
          type: "Uint16",
          name: "numIconVertices"
        }, {
          type: "Uint16",
          name: "numVerticalIconVertices"
        }, {
          type: "Uint16",
          name: "useRuntimeCollisionCircles"
        }, {
          type: "Uint32",
          name: "crossTileID"
        }, {
          type: "Float32",
          name: "textBoxScale"
        }, {
          type: "Float32",
          name: "collisionCircleDiameter"
        }, {
          type: "Uint16",
          name: "textAnchorOffsetStartIndex"
        }, {
          type: "Uint16",
          name: "textAnchorOffsetEndIndex"
        }]), wa([{
          type: "Float32",
          name: "offsetX"
        }]), wa([{
          type: "Int16",
          name: "x"
        }, {
          type: "Int16",
          name: "y"
        }, {
          type: "Int16",
          name: "tileUnitDistanceFromAnchor"
        }]), wa([{
          type: "Uint16",
          name: "textAnchor"
        }, {
          type: "Float32",
          components: 2,
          name: "textOffset"
        }]);
        const ju = {
          "!": "",
          "#": "",
          $: "",
          "%": "",
          "&": "",
          "(": "",
          ")": "",
          "*": "",
          "+": "",
          ",": "",
          "-": "",
          ".": "",
          "/": "",
          ":": "",
          ";": "",
          "<": "",
          "=": "",
          ">": "",
          "?": "",
          "@": "",
          "[": "",
          "\\": "",
          "]": "",
          "^": "",
          _: "",
          "`": "",
          "{": "",
          "|": "",
          "}": "",
          "~": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": "",
          "": ""
        };
        var Ga = 24;
        const Mf = 4294967296,
          f_ = 1 / Mf,
          m_ = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
        class Cf {
          constructor(t = new Uint8Array(16)) {
            this.buf = ArrayBuffer.isView(t) ? t : new Uint8Array(t), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length
          }
          readFields(t, r, n = this.length) {
            for (; this.pos < n;) {
              const c = this.readVarint(),
                f = c >> 3,
                m = this.pos;
              this.type = 7 & c, t(f, r, this), this.pos === m && this.skip(c)
            }
            return r
          }
          readMessage(t, r) {
            return this.readFields(t, r, this.readVarint() + this.pos)
          }
          readFixed32() {
            const t = this.dataView.getUint32(this.pos, !0);
            return this.pos += 4, t
          }
          readSFixed32() {
            const t = this.dataView.getInt32(this.pos, !0);
            return this.pos += 4, t
          }
          readFixed64() {
            const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * Mf;
            return this.pos += 8, t
          }
          readSFixed64() {
            const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * Mf;
            return this.pos += 8, t
          }
          readFloat() {
            const t = this.dataView.getFloat32(this.pos, !0);
            return this.pos += 4, t
          }
          readDouble() {
            const t = this.dataView.getFloat64(this.pos, !0);
            return this.pos += 8, t
          }
          readVarint(t) {
            const r = this.buf;
            let n, c;
            return c = r[this.pos++], n = 127 & c, c < 128 ? n : (c = r[this.pos++], n |= (127 & c) << 7, c < 128 ? n : (c = r[this.pos++], n |= (127 & c) << 14, c < 128 ? n : (c = r[this.pos++], n |= (127 & c) << 21, c < 128 ? n : (c = r[this.pos], n |= (15 & c) << 28, (function(f, m, v) {
              const b = v.buf;
              let M, C;
              if (C = b[v.pos++], M = (112 & C) >> 4, C < 128 || (C = b[v.pos++], M |= (127 & C) << 3, C < 128) || (C = b[v.pos++], M |= (127 & C) << 10, C < 128) || (C = b[v.pos++], M |= (127 & C) << 17, C < 128) || (C = b[v.pos++], M |= (127 & C) << 24, C < 128) || (C = b[v.pos++], M |= (1 & C) << 31, C < 128)) return hc(f, M, m);
              throw new Error("Expected varint not more than 10 bytes")
            })(n, t, this)))))
          }
          readVarint64() {
            return this.readVarint(!0)
          }
          readSVarint() {
            const t = this.readVarint();
            return t % 2 == 1 ? (t + 1) / -2 : t / 2
          }
          readBoolean() {
            return !!this.readVarint()
          }
          readString() {
            const t = this.readVarint() + this.pos,
              r = this.pos;
            return this.pos = t, t - r >= 12 && m_ ? m_.decode(this.buf.subarray(r, t)) : (function(n, c, f) {
              let m = "",
                v = c;
              for (; v < f;) {
                const b = n[v];
                let M, C, D, N = null,
                  W = b > 239 ? 4 : b > 223 ? 3 : b > 191 ? 2 : 1;
                if (v + W > f) break;
                W === 1 ? b < 128 && (N = b) : W === 2 ? (M = n[v + 1], (192 & M) == 128 && (N = (31 & b) << 6 | 63 & M, N <= 127 && (N = null))) : W === 3 ? (M = n[v + 1], C = n[v + 2], (192 & M) == 128 && (192 & C) == 128 && (N = (15 & b) << 12 | (63 & M) << 6 | 63 & C, (N <= 2047 || N >= 55296 && N <= 57343) && (N = null))) : W === 4 && (M = n[v + 1], C = n[v + 2], D = n[v + 3], (192 & M) == 128 && (192 & C) == 128 && (192 & D) == 128 && (N = (15 & b) << 18 | (63 & M) << 12 | (63 & C) << 6 | 63 & D, (N <= 65535 || N >= 1114112) && (N = null))), N === null ? (N = 65533, W = 1) : N > 65535 && (N -= 65536, m += String.fromCharCode(N >>> 10 & 1023 | 55296), N = 56320 | 1023 & N), m += String.fromCharCode(N), v += W
              }
              return m
            })(this.buf, r, t)
          }
          readBytes() {
            const t = this.readVarint() + this.pos,
              r = this.buf.subarray(this.pos, t);
            return this.pos = t, r
          }
          readPackedVarint(t = [], r) {
            const n = this.readPackedEnd();
            for (; this.pos < n;) t.push(this.readVarint(r));
            return t
          }
          readPackedSVarint(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readSVarint());
            return t
          }
          readPackedBoolean(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readBoolean());
            return t
          }
          readPackedFloat(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readFloat());
            return t
          }
          readPackedDouble(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readDouble());
            return t
          }
          readPackedFixed32(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readFixed32());
            return t
          }
          readPackedSFixed32(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readSFixed32());
            return t
          }
          readPackedFixed64(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readFixed64());
            return t
          }
          readPackedSFixed64(t = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r;) t.push(this.readSFixed64());
            return t
          }
          readPackedEnd() {
            return this.type === 2 ? this.readVarint() + this.pos : this.pos + 1
          }
          skip(t) {
            const r = 7 & t;
            if (r === 0)
              for (; this.buf[this.pos++] > 127;);
            else if (r === 2) this.pos = this.readVarint() + this.pos;
            else if (r === 5) this.pos += 4;
            else {
              if (r !== 1) throw new Error(`Unimplemented type: ${r}`);
              this.pos += 8
            }
          }
          writeTag(t, r) {
            this.writeVarint(t << 3 | r)
          }
          realloc(t) {
            let r = this.length || 16;
            for (; r < this.pos + t;) r *= 2;
            if (r !== this.length) {
              const n = new Uint8Array(r);
              n.set(this.buf), this.buf = n, this.dataView = new DataView(n.buffer), this.length = r
            }
          }
          finish() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length)
          }
          writeFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, !0), this.pos += 4
          }
          writeSFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, !0), this.pos += 4
          }
          writeFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t * f_), !0), this.pos += 8
          }
          writeSFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t * f_), !0), this.pos += 8
          }
          writeVarint(t) {
            (t = +t || 0) > 268435455 || t < 0 ? (function(r, n) {
              let c, f;
              if (r >= 0 ? (c = r % 4294967296 | 0, f = r / 4294967296 | 0) : (c = ~(-r % 4294967296), f = ~(-r / 4294967296), 4294967295 ^ c ? c = c + 1 | 0 : (c = 0, f = f + 1 | 0)), r >= 18446744073709552e3 || r < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              n.realloc(10), (function(m, v, b) {
                b.buf[b.pos++] = 127 & m | 128, m >>>= 7, b.buf[b.pos++] = 127 & m | 128, m >>>= 7, b.buf[b.pos++] = 127 & m | 128, m >>>= 7, b.buf[b.pos++] = 127 & m | 128, b.buf[b.pos] = 127 & (m >>>= 7)
              })(c, 0, n), (function(m, v) {
                const b = (7 & m) << 4;
                v.buf[v.pos++] |= b | ((m >>>= 3) ? 128 : 0), m && (v.buf[v.pos++] = 127 & m | ((m >>>= 7) ? 128 : 0), m && (v.buf[v.pos++] = 127 & m | ((m >>>= 7) ? 128 : 0), m && (v.buf[v.pos++] = 127 & m | ((m >>>= 7) ? 128 : 0), m && (v.buf[v.pos++] = 127 & m | ((m >>>= 7) ? 128 : 0), m && (v.buf[v.pos++] = 127 & m)))))
              })(f, n)
            })(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))))
          }
          writeSVarint(t) {
            this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t)
          }
          writeBoolean(t) {
            this.writeVarint(+t)
          }
          writeString(t) {
            t = String(t), this.realloc(4 * t.length), this.pos++;
            const r = this.pos;
            this.pos = (function(c, f, m) {
              for (let v, b, M = 0; M < f.length; M++) {
                if (v = f.charCodeAt(M), v > 55295 && v < 57344) {
                  if (!b) {
                    v > 56319 || M + 1 === f.length ? (c[m++] = 239, c[m++] = 191, c[m++] = 189) : b = v;
                    continue
                  }
                  if (v < 56320) {
                    c[m++] = 239, c[m++] = 191, c[m++] = 189, b = v;
                    continue
                  }
                  v = b - 55296 << 10 | v - 56320 | 65536, b = null
                } else b && (c[m++] = 239, c[m++] = 191, c[m++] = 189, b = null);
                v < 128 ? c[m++] = v : (v < 2048 ? c[m++] = v >> 6 | 192 : (v < 65536 ? c[m++] = v >> 12 | 224 : (c[m++] = v >> 18 | 240, c[m++] = v >> 12 & 63 | 128), c[m++] = v >> 6 & 63 | 128), c[m++] = 63 & v | 128)
              }
              return m
            })(this.buf, t, this.pos);
            const n = this.pos - r;
            n >= 128 && g_(r, n, this), this.pos = r - 1, this.writeVarint(n), this.pos += n
          }
          writeFloat(t) {
            this.realloc(4), this.dataView.setFloat32(this.pos, t, !0), this.pos += 4
          }
          writeDouble(t) {
            this.realloc(8), this.dataView.setFloat64(this.pos, t, !0), this.pos += 8
          }
          writeBytes(t) {
            const r = t.length;
            this.writeVarint(r), this.realloc(r);
            for (let n = 0; n < r; n++) this.buf[this.pos++] = t[n]
          }
          writeRawMessage(t, r) {
            this.pos++;
            const n = this.pos;
            t(r, this);
            const c = this.pos - n;
            c >= 128 && g_(n, c, this), this.pos = n - 1, this.writeVarint(c), this.pos += c
          }
          writeMessage(t, r, n) {
            this.writeTag(t, 2), this.writeRawMessage(r, n)
          }
          writePackedVarint(t, r) {
            r.length && this.writeMessage(t, Ox, r)
          }
          writePackedSVarint(t, r) {
            r.length && this.writeMessage(t, jx, r)
          }
          writePackedBoolean(t, r) {
            r.length && this.writeMessage(t, Vx, r)
          }
          writePackedFloat(t, r) {
            r.length && this.writeMessage(t, qx, r)
          }
          writePackedDouble(t, r) {
            r.length && this.writeMessage(t, Nx, r)
          }
          writePackedFixed32(t, r) {
            r.length && this.writeMessage(t, Ux, r)
          }
          writePackedSFixed32(t, r) {
            r.length && this.writeMessage(t, Zx, r)
          }
          writePackedFixed64(t, r) {
            r.length && this.writeMessage(t, Gx, r)
          }
          writePackedSFixed64(t, r) {
            r.length && this.writeMessage(t, Wx, r)
          }
          writeBytesField(t, r) {
            this.writeTag(t, 2), this.writeBytes(r)
          }
          writeFixed32Field(t, r) {
            this.writeTag(t, 5), this.writeFixed32(r)
          }
          writeSFixed32Field(t, r) {
            this.writeTag(t, 5), this.writeSFixed32(r)
          }
          writeFixed64Field(t, r) {
            this.writeTag(t, 1), this.writeFixed64(r)
          }
          writeSFixed64Field(t, r) {
            this.writeTag(t, 1), this.writeSFixed64(r)
          }
          writeVarintField(t, r) {
            this.writeTag(t, 0), this.writeVarint(r)
          }
          writeSVarintField(t, r) {
            this.writeTag(t, 0), this.writeSVarint(r)
          }
          writeStringField(t, r) {
            this.writeTag(t, 2), this.writeString(r)
          }
          writeFloatField(t, r) {
            this.writeTag(t, 5), this.writeFloat(r)
          }
          writeDoubleField(t, r) {
            this.writeTag(t, 1), this.writeDouble(r)
          }
          writeBooleanField(t, r) {
            this.writeVarintField(t, +r)
          }
        }

        function hc(i, t, r) {
          return r ? 4294967296 * t + (i >>> 0) : 4294967296 * (t >>> 0) + (i >>> 0)
        }

        function g_(i, t, r) {
          const n = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (7 * Math.LN2));
          r.realloc(n);
          for (let c = r.pos - 1; c >= i; c--) r.buf[c + n] = r.buf[c]
        }

        function Ox(i, t) {
          for (let r = 0; r < i.length; r++) t.writeVarint(i[r])
        }

        function jx(i, t) {
          for (let r = 0; r < i.length; r++) t.writeSVarint(i[r])
        }

        function qx(i, t) {
          for (let r = 0; r < i.length; r++) t.writeFloat(i[r])
        }

        function Nx(i, t) {
          for (let r = 0; r < i.length; r++) t.writeDouble(i[r])
        }

        function Vx(i, t) {
          for (let r = 0; r < i.length; r++) t.writeBoolean(i[r])
        }

        function Ux(i, t) {
          for (let r = 0; r < i.length; r++) t.writeFixed32(i[r])
        }

        function Zx(i, t) {
          for (let r = 0; r < i.length; r++) t.writeSFixed32(i[r])
        }

        function Gx(i, t) {
          for (let r = 0; r < i.length; r++) t.writeFixed64(i[r])
        }

        function Wx(i, t) {
          for (let r = 0; r < i.length; r++) t.writeSFixed64(i[r])
        }

        function Hx(i, t, r) {
          i === 1 && r.readMessage(Xx, t)
        }

        function Xx(i, t, r) {
          if (i === 3) {
            const {
              id: n,
              bitmap: c,
              width: f,
              height: m,
              left: v,
              top: b,
              advance: M
            } = r.readMessage(Yx, {});
            t.push({
              id: n,
              bitmap: new ku({
                width: f + 6,
                height: m + 6
              }, c),
              metrics: {
                width: f,
                height: m,
                left: v,
                top: b,
                advance: M
              }
            })
          }
        }

        function Yx(i, t, r) {
          i === 1 ? t.id = r.readVarint() : i === 2 ? t.bitmap = r.readBytes() : i === 3 ? t.width = r.readVarint() : i === 4 ? t.height = r.readVarint() : i === 5 ? t.left = r.readSVarint() : i === 6 ? t.top = r.readSVarint() : i === 7 && (t.advance = r.readVarint())
        }

        function __(i) {
          let t = 0,
            r = 0;
          for (const m of i) t += m.w * m.h, r = Math.max(r, m.w);
          i.sort(((m, v) => v.h - m.h));
          const n = [{
            x: 0,
            y: 0,
            w: Math.max(Math.ceil(Math.sqrt(t / .95)), r),
            h: 1 / 0
          }];
          let c = 0,
            f = 0;
          for (const m of i)
            for (let v = n.length - 1; v >= 0; v--) {
              const b = n[v];
              if (!(m.w > b.w || m.h > b.h)) {
                if (m.x = b.x, m.y = b.y, f = Math.max(f, m.y + m.h), c = Math.max(c, m.x + m.w), m.w === b.w && m.h === b.h) {
                  const M = n.pop();
                  M && v < n.length && (n[v] = M)
                } else m.h === b.h ? (b.x += m.w, b.w -= m.w) : m.w === b.w ? (b.y += m.h, b.h -= m.h) : (n.push({
                  x: b.x + m.w,
                  y: b.y,
                  w: b.w - m.w,
                  h: m.h
                }), b.y += m.h, b.h -= m.h);
                break
              }
            }
          return {
            w: c,
            h: f,
            fill: t / (c * f) || 0
          }
        }
        class Af {
          constructor(t, {
            pixelRatio: r,
            version: n,
            stretchX: c,
            stretchY: f,
            content: m,
            textFitWidth: v,
            textFitHeight: b
          }) {
            this.paddedRect = t, this.pixelRatio = r, this.stretchX = c, this.stretchY = f, this.content = m, this.version = n, this.textFitWidth = v, this.textFitHeight = b
          }
          get tl() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1]
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1]
          }
          get tlbr() {
            return this.tl.concat(this.br)
          }
          get displaySize() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio]
          }
        }
        class v_ {
          constructor(t, r) {
            const n = {},
              c = {};
            this.haveRenderCallbacks = [];
            const f = [];
            this.addImages(t, n, f), this.addImages(r, c, f);
            const {
              w: m,
              h: v
            } = __(f), b = new Sn({
              width: m || 1,
              height: v || 1
            });
            for (const M in t) {
              const C = t[M],
                D = n[M].paddedRect;
              Sn.copy(C.data, b, {
                x: 0,
                y: 0
              }, {
                x: D.x + 1,
                y: D.y + 1
              }, C.data)
            }
            for (const M in r) {
              const C = r[M],
                D = c[M].paddedRect,
                N = D.x + 1,
                W = D.y + 1,
                X = C.data.width,
                Q = C.data.height;
              Sn.copy(C.data, b, {
                x: 0,
                y: 0
              }, {
                x: N,
                y: W
              }, C.data), Sn.copy(C.data, b, {
                x: 0,
                y: Q - 1
              }, {
                x: N,
                y: W - 1
              }, {
                width: X,
                height: 1
              }), Sn.copy(C.data, b, {
                x: 0,
                y: 0
              }, {
                x: N,
                y: W + Q
              }, {
                width: X,
                height: 1
              }), Sn.copy(C.data, b, {
                x: X - 1,
                y: 0
              }, {
                x: N - 1,
                y: W
              }, {
                width: 1,
                height: Q
              }), Sn.copy(C.data, b, {
                x: 0,
                y: 0
              }, {
                x: N + X,
                y: W
              }, {
                width: 1,
                height: Q
              })
            }
            this.image = b, this.iconPositions = n, this.patternPositions = c
          }
          addImages(t, r, n) {
            for (const c in t) {
              const f = t[c],
                m = {
                  x: 0,
                  y: 0,
                  w: f.data.width + 2,
                  h: f.data.height + 2
                };
              n.push(m), r[c] = new Af(m, f), f.hasRenderCallback && this.haveRenderCallbacks.push(c)
            }
          }
          patchUpdatedImages(t, r) {
            t.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const n in t.updatedImages) this.patchUpdatedImage(this.iconPositions[n], t.getImage(n), r), this.patchUpdatedImage(this.patternPositions[n], t.getImage(n), r)
          }
          patchUpdatedImage(t, r, n) {
            if (!t || !r || t.version === r.version) return;
            t.version = r.version;
            const [c, f] = t.tl;
            n.update(r.data, void 0, {
              x: c,
              y: f
            })
          }
        }
        var Eo;
        zr("ImagePosition", Af), zr("ImageAtlas", v_), T.as = void 0, (Eo = T.as || (T.as = {}))[Eo.none = 0] = "none", Eo[Eo.horizontal = 1] = "horizontal", Eo[Eo.vertical = 2] = "vertical", Eo[Eo.horizontalOnly = 3] = "horizontalOnly";
        class qu {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom"
          }
          static forText(t, r, n) {
            const c = new qu;
            return c.scale = t || 1, c.fontStack = r, c.verticalAlign = n || "bottom", c
          }
          static forImage(t, r) {
            const n = new qu;
            return n.imageName = t, n.verticalAlign = r || "bottom", n
          }
        }
        class dc {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null
          }
          static fromFeature(t, r) {
            const n = new dc;
            for (let c = 0; c < t.sections.length; c++) {
              const f = t.sections[c];
              f.image ? n.addImageSection(f) : n.addTextSection(f, r)
            }
            return n
          }
          length() {
            return this.text.length
          }
          getSection(t) {
            return this.sections[this.sectionIndex[t]]
          }
          getSectionIndex(t) {
            return this.sectionIndex[t]
          }
          getCharCode(t) {
            return this.text.charCodeAt(t)
          }
          verticalizePunctuation() {
            this.text = (function(t) {
              let r = "";
              for (let n = 0; n < t.length; n++) {
                const c = t.charCodeAt(n + 1) || null,
                  f = t.charCodeAt(n - 1) || null;
                r += c && Kl(c) && !ju[t[n + 1]] || f && Kl(f) && !ju[t[n - 1]] || !ju[t[n]] ? t[n] : ju[t[n]]
              }
              return r
            })(this.text)
          }
          trim() {
            let t = 0;
            for (let n = 0; n < this.text.length && Zd[this.text.charCodeAt(n)]; n++) t++;
            let r = this.text.length;
            for (let n = this.text.length - 1; n >= 0 && n >= t && Zd[this.text.charCodeAt(n)]; n--) r--;
            this.text = this.text.substring(t, r), this.sectionIndex = this.sectionIndex.slice(t, r)
          }
          substring(t, r) {
            const n = new dc;
            return n.text = this.text.substring(t, r), n.sectionIndex = this.sectionIndex.slice(t, r), n.sections = this.sections, n
          }
          toString() {
            return this.text
          }
          getMaxScale() {
            return this.sectionIndex.reduce(((t, r) => Math.max(t, this.sections[r].scale)), 0)
          }
          getMaxImageSize(t) {
            let r = 0,
              n = 0;
            for (let c = 0; c < this.length(); c++) {
              const f = this.getSection(c);
              if (f.imageName) {
                const m = t[f.imageName];
                if (!m) continue;
                const v = m.displaySize;
                r = Math.max(r, v[0]), n = Math.max(n, v[1])
              }
            }
            return {
              maxImageWidth: r,
              maxImageHeight: n
            }
          }
          addTextSection(t, r) {
            this.text += t.text, this.sections.push(qu.forText(t.scale, t.fontStack || r, t.verticalAlign));
            const n = this.sections.length - 1;
            for (let c = 0; c < t.text.length; ++c) this.sectionIndex.push(n)
          }
          addImageSection(t) {
            const r = t.image ? t.image.name : "";
            if (r.length === 0) return void St("Can't add FormattedSection with an empty image.");
            const n = this.getNextImageSectionCharCode();
            n ? (this.text += String.fromCharCode(n), this.sections.push(qu.forImage(r, t.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : St("Reached maximum number of images 6401")
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID)
          }
        }

        function Ud(i, t, r, n, c, f, m, v, b, M, C, D, N, W, X) {
          const Q = dc.fromFeature(i, c);
          let le;
          D === T.as.vertical && Q.verticalizePunctuation();
          const {
            processBidirectionalText: we,
            processStyledBidirectionalText: et
          } = ps;
          if (we && Q.sections.length === 1) {
            le = [];
            const mt = we(Q.toString(), kf(Q, M, f, t, n, W));
            for (const Mt of mt) {
              const $t = new dc;
              $t.text = Mt, $t.sections = Q.sections;
              for (let Tr = 0; Tr < Mt.length; Tr++) $t.sectionIndex.push(0);
              le.push($t)
            }
          } else if (et) {
            le = [];
            const mt = et(Q.text, Q.sectionIndex, kf(Q, M, f, t, n, W));
            for (const Mt of mt) {
              const $t = new dc;
              $t.text = Mt[0], $t.sectionIndex = Mt[1], $t.sections = Q.sections, le.push($t)
            }
          } else le = (function(mt, Mt) {
            const $t = [],
              Tr = mt.text;
            let hr = 0;
            for (const yr of Mt) $t.push(mt.substring(hr, yr)), hr = yr;
            return hr < Tr.length && $t.push(mt.substring(hr, Tr.length)), $t
          })(Q, kf(Q, M, f, t, n, W));
          const De = [],
            Ze = {
              positionedLines: De,
              text: Q.toString(),
              top: C[1],
              bottom: C[1],
              left: C[0],
              right: C[0],
              writingMode: D,
              iconsInText: !1,
              verticalizable: !1
            };
          return (function(mt, Mt, $t, Tr, hr, yr, $r, gr, xr, Ft, mi, xi) {
            let si = 0,
              Hr = 0,
              Ni = 0,
              ba = 0;
            const Ra = gr === "right" ? 1 : gr === "left" ? 0 : .5,
              sn = Ga / xi;
            let Hn = 0;
            for (const ya of hr) {
              ya.trim();
              const Wa = ya.getMaxScale(),
                $a = {
                  positionedGlyphs: [],
                  lineOffset: 0
                };
              mt.positionedLines[Hn] = $a;
              const Qa = $a.positionedGlyphs;
              let _n = 0;
              if (!ya.length()) {
                Hr += yr, ++Hn;
                continue
              }
              const Xn = Qx(Tr, ya, sn);
              for (let In = 0; In < ya.length(); In++) {
                const Fa = ya.getSection(In),
                  Xa = ya.getSectionIndex(In),
                  Ya = ya.getCharCode(In),
                  Ea = e1(xr, mi, Ya);
                let la;
                if (Fa.imageName) {
                  if (mt.iconsInText = !0, Fa.scale = Fa.scale * sn, la = r1(Fa, Ea, Wa, Xn, Tr), !la) continue;
                  _n = Math.max(_n, la.imageOffset)
                } else if (la = t1(Fa, Ya, Ea, Xn, Mt, $t), !la) continue;
                const {
                  rect: vs,
                  metrics: gc,
                  baselineOffset: ys
                } = la;
                Qa.push({
                  glyph: Ya,
                  imageName: Fa.imageName,
                  x: si,
                  y: Hr + ys + -17,
                  vertical: Ea,
                  scale: Fa.scale,
                  fontStack: Fa.fontStack,
                  sectionIndex: Xa,
                  metrics: gc,
                  rect: vs
                }), Ea ? (mt.verticalizable = !0, si += (Fa.imageName ? gc.advance : Ga) * Fa.scale + Ft) : si += gc.advance * Fa.scale + Ft
              }
              Qa.length !== 0 && (Ni = Math.max(si - Ft, Ni), i1(Qa, 0, Qa.length - 1, Ra)), si = 0, $a.lineOffset = Math.max(_n, (Wa - 1) * Ga);
              const Ha = yr * Wa + _n;
              Hr += Ha, ba = Math.max(Ha, ba), ++Hn
            }
            const {
              horizontalAlign: Pn,
              verticalAlign: Ja
            } = zf($r);
            (function(ya, Wa, $a, Qa, _n, Xn, Ha, In, Fa) {
              const Xa = (Wa - $a) * _n;
              let Ya = 0;
              Ya = Xn !== Ha ? -In * Qa - -17 : -Qa * Fa * Ha + .5 * Ha;
              for (const Ea of ya)
                for (const la of Ea.positionedGlyphs) la.x += Xa, la.y += Ya
            })(mt.positionedLines, Ra, Pn, Ja, Ni, ba, yr, Hr, hr.length), mt.top += -Ja * Hr, mt.bottom = mt.top + Hr, mt.left += -Pn * Ni, mt.right = mt.left + Ni
          })(Ze, t, r, n, le, m, v, b, D, M, N, X), !(function(mt) {
            for (const Mt of mt)
              if (Mt.positionedGlyphs.length !== 0) return !1;
            return !0
          })(De) && Ze
        }
        const Zd = {
            9: !0,
            10: !0,
            11: !0,
            12: !0,
            13: !0,
            32: !0
          },
          Kx = {
            10: !0,
            32: !0,
            38: !0,
            41: !0,
            43: !0,
            45: !0,
            47: !0,
            173: !0,
            183: !0,
            8203: !0,
            8208: !0,
            8211: !0,
            8231: !0
          },
          Jx = {
            40: !0
          };

        function y_(i, t, r, n, c, f) {
          if (t.imageName) {
            const m = n[t.imageName];
            return m ? m.displaySize[0] * t.scale * Ga / f + c : 0
          } {
            const m = r[t.fontStack],
              v = m && m[i];
            return v ? v.metrics.advance * t.scale + c : 0
          }
        }

        function x_(i, t, r, n) {
          const c = Math.pow(i - t, 2);
          return n ? i < t ? c / 2 : 2 * c : c + Math.abs(r) * r
        }

        function $x(i, t, r) {
          let n = 0;
          return i === 10 && (n -= 1e4), r && (n += 150), i !== 40 && i !== 65288 || (n += 50), t !== 41 && t !== 65289 || (n += 50), n
        }

        function b_(i, t, r, n, c, f) {
          let m = null,
            v = x_(t, r, c, f);
          for (const b of n) {
            const M = x_(t - b.x, r, c, f) + b.badness;
            M <= v && (m = b, v = M)
          }
          return {
            index: i,
            x: t,
            priorBreak: m,
            badness: v
          }
        }

        function w_(i) {
          return i ? w_(i.priorBreak).concat(i.index) : []
        }

        function kf(i, t, r, n, c, f) {
          if (!i) return [];
          const m = [],
            v = (function(D, N, W, X, Q, le) {
              let we = 0;
              for (let et = 0; et < D.length(); et++) {
                const De = D.getSection(et);
                we += y_(D.getCharCode(et), De, X, Q, N, le)
              }
              return we / Math.max(1, Math.ceil(we / W))
            })(i, t, r, n, c, f),
            b = i.text.indexOf("") >= 0;
          let M = 0;
          for (let D = 0; D < i.length(); D++) {
            const N = i.getSection(D),
              W = i.getCharCode(D);
            if (Zd[W] || (M += y_(W, N, n, c, t, f)), D < i.length() - 1) {
              const X = !((C = W) < 11904) && (!!Bi["CJK Compatibility Forms"](C) || !!Bi["CJK Compatibility"](C) || !!Bi["CJK Strokes"](C) || !!Bi["CJK Symbols and Punctuation"](C) || !!Bi["Enclosed CJK Letters and Months"](C) || !!Bi["Halfwidth and Fullwidth Forms"](C) || !!Bi["Ideographic Description Characters"](C) || !!Bi["Vertical Forms"](C) || vu.test(String.fromCodePoint(C)));
              (Kx[W] || X || N.imageName || D !== i.length() - 2 && Jx[i.getCharCode(D + 1)]) && m.push(b_(D + 1, M, v, m, $x(W, i.getCharCode(D + 1), X && b), !1))
            }
          }
          var C;
          return w_(b_(i.length(), M, v, m, 0, !0))
        }

        function zf(i) {
          let t = .5,
            r = .5;
          switch (i) {
            case "right":
            case "top-right":
            case "bottom-right":
              t = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              t = 0
          }
          switch (i) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              r = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              r = 0
          }
          return {
            horizontalAlign: t,
            verticalAlign: r
          }
        }

        function Qx(i, t, r) {
          const n = t.getMaxScale() * Ga,
            {
              maxImageWidth: c,
              maxImageHeight: f
            } = t.getMaxImageSize(i),
            m = Math.max(n, f * r);
          return {
            verticalLineContentWidth: Math.max(n, c * r),
            horizontalLineContentHeight: m
          }
        }

        function T_(i) {
          switch (i) {
            case "top":
              return 0;
            case "center":
              return .5;
            default:
              return 1
          }
        }

        function e1(i, t, r) {
          return !(i === T.as.horizontal || !t && !Yl(r) || t && (Zd[r] || (n = r, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(n)))));
          var n
        }

        function t1(i, t, r, n, c, f) {
          const m = f[i.fontStack],
            v = (function(M, C, D, N) {
              if (M && M.rect) return M;
              const W = C[D.fontStack],
                X = W && W[N];
              return X ? {
                rect: null,
                metrics: X.metrics
              } : null
            })(m && m[t], c, i, t);
          if (v === null) return null;
          let b;
          if (r) b = n.verticalLineContentWidth - i.scale * Ga;
          else {
            const M = T_(i.verticalAlign);
            b = (n.horizontalLineContentHeight - i.scale * Ga) * M
          }
          return {
            rect: v.rect,
            metrics: v.metrics,
            baselineOffset: b
          }
        }

        function r1(i, t, r, n, c) {
          const f = c[i.imageName];
          if (!f) return null;
          const m = f.paddedRect,
            v = f.displaySize,
            b = {
              width: v[0],
              height: v[1],
              left: 1,
              top: -3,
              advance: t ? v[1] : v[0]
            };
          let M;
          if (t) M = n.verticalLineContentWidth - v[1] * i.scale;
          else {
            const C = T_(i.verticalAlign);
            M = (n.horizontalLineContentHeight - v[1] * i.scale) * C
          }
          return {
            rect: m,
            metrics: b,
            baselineOffset: M,
            imageOffset: (t ? v[0] : v[1]) * i.scale - Ga * r
          }
        }

        function i1(i, t, r, n) {
          if (n === 0) return;
          const c = i[r],
            f = (i[r].x + c.metrics.advance * c.scale) * n;
          for (let m = t; m <= r; m++) i[m].x -= f
        }

        function a1(i, t, r) {
          const {
            horizontalAlign: n,
            verticalAlign: c
          } = zf(r), f = t[0] - i.displaySize[0] * n, m = t[1] - i.displaySize[1] * c;
          return {
            image: i,
            top: m,
            bottom: m + i.displaySize[1],
            left: f,
            right: f + i.displaySize[0]
          }
        }

        function S_(i) {
          var t, r;
          let n = i.left,
            c = i.top,
            f = i.right - n,
            m = i.bottom - c;
          const v = (t = i.image.textFitWidth) !== null && t !== void 0 ? t : "stretchOrShrink",
            b = (r = i.image.textFitHeight) !== null && r !== void 0 ? r : "stretchOrShrink",
            M = (i.image.content[2] - i.image.content[0]) / (i.image.content[3] - i.image.content[1]);
          if (b === "proportional") {
            if (v === "stretchOnly" && f / m < M || v === "proportional") {
              const C = Math.ceil(m * M);
              n *= C / f, f = C
            }
          } else if (v === "proportional" && b === "stretchOnly" && M !== 0 && f / m > M) {
            const C = Math.ceil(f / M);
            c *= C / m, m = C
          }
          return {
            x1: n,
            y1: c,
            x2: n + f,
            y2: c + m
          }
        }

        function P_(i, t, r, n, c, f) {
          const m = i.image;
          let v;
          if (m.content) {
            const le = m.content,
              we = m.pixelRatio || 1;
            v = [le[0] / we, le[1] / we, m.displaySize[0] - le[2] / we, m.displaySize[1] - le[3] / we]
          }
          const b = t.left * f,
            M = t.right * f;
          let C, D, N, W;
          r === "width" || r === "both" ? (W = c[0] + b - n[3], D = c[0] + M + n[1]) : (W = c[0] + (b + M - m.displaySize[0]) / 2, D = W + m.displaySize[0]);
          const X = t.top * f,
            Q = t.bottom * f;
          return r === "height" || r === "both" ? (C = c[1] + X - n[0], N = c[1] + Q + n[2]) : (C = c[1] + (X + Q - m.displaySize[1]) / 2, N = C + m.displaySize[1]), {
            image: m,
            top: C,
            right: D,
            bottom: N,
            left: W,
            collisionPadding: v
          }
        }
        const io = 128,
          Lo = 32640;

        function I_(i, t) {
          const {
            expression: r
          } = t;
          if (r.kind === "constant") return {
            kind: "constant",
            layoutSize: r.evaluate(new ta(i + 1))
          };
          if (r.kind === "source") return {
            kind: "source"
          };
          {
            const {
              zoomStops: n,
              interpolationType: c
            } = r;
            let f = 0;
            for (; f < n.length && n[f] <= i;) f++;
            f = Math.max(0, f - 1);
            let m = f;
            for (; m < n.length && n[m] < i + 1;) m++;
            m = Math.min(n.length - 1, m);
            const v = n[f],
              b = n[m];
            return r.kind === "composite" ? {
              kind: "composite",
              minZoom: v,
              maxZoom: b,
              interpolationType: c
            } : {
              kind: "camera",
              minZoom: v,
              maxZoom: b,
              minSize: r.evaluate(new ta(v)),
              maxSize: r.evaluate(new ta(b)),
              interpolationType: c
            }
          }
        }

        function Ef(i, t, r) {
          let n = "never";
          const c = i.get(t);
          return c ? n = c : i.get(r) && (n = "always"), n
        }
        const n1 = [{
          name: "a_fade_opacity",
          components: 1,
          type: "Uint8",
          offset: 0
        }];

        function Gd(i, t, r, n, c, f, m, v, b, M, C, D, N) {
          const W = v ? Math.min(Lo, Math.round(v[0])) : 0,
            X = v ? Math.min(Lo, Math.round(v[1])) : 0;
          i.emplaceBack(t, r, Math.round(32 * n), Math.round(32 * c), f, m, (W << 1) + (b ? 1 : 0), X, 16 * M, 16 * C, 256 * D, 256 * N)
        }

        function Lf(i, t, r) {
          i.emplaceBack(t.x, t.y, r), i.emplaceBack(t.x, t.y, r), i.emplaceBack(t.x, t.y, r), i.emplaceBack(t.x, t.y, r)
        }

        function s1(i) {
          for (const t of i.sections)
            if (lf(t.text)) return !0;
          return !1
        }
        class Df {
          constructor(t) {
            this.layoutVertexArray = new ft, this.indexArray = new Nt, this.programConfigurations = t, this.segments = new Li, this.dynamicLayoutVertexArray = new gt, this.opacityVertexArray = new xt, this.hasVisibleVertices = !1, this.placedSymbolArray = new A
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0
          }
          upload(t, r, n, c) {
            this.isEmpty() || (n && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Lx.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, r), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, Dx.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, n1, !0), this.opacityVertexBuffer.itemSize = 1), (n || c) && this.programConfigurations.upload(t))
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy())
          }
        }
        zr("SymbolBuffers", Df);
        class Rf {
          constructor(t, r, n) {
            this.layoutVertexArray = new t, this.layoutAttributes = r, this.indexArray = new n, this.segments = new Li, this.collisionVertexArray = new cr
          }
          upload(t) {
            this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, Rx.members, !0)
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy())
          }
        }
        zr("CollisionBuffers", Rf);
        class pc {
          constructor(t) {
            this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = Rt(globalThis) ? Math.min(t.overscaling, 128) : t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((m => m.id)), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasDependencies = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [];
            const r = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = I_(this.zoom, r["text-size"]), this.iconSizeData = I_(this.zoom, r["icon-size"]);
            const n = this.layers[0].layout,
              c = n.get("symbol-sort-key"),
              f = n.get("symbol-z-order");
            this.canOverlap = Ef(n, "text-overlap", "text-allow-overlap") !== "never" || Ef(n, "icon-overlap", "icon-allow-overlap") !== "never" || n.get("text-ignore-placement") || n.get("icon-ignore-placement"), this.sortFeaturesByKey = f !== "viewport-y" && !c.isConstant(), this.sortFeaturesByY = (f === "viewport-y" || f === "auto" && !this.sortFeaturesByKey) && this.canOverlap, n.get("symbol-placement") === "point" && (this.writingModes = n.get("text-writing-mode").map((m => T.as[m]))), this.stateDependentLayerIds = this.layers.filter((m => m.isStateDependent())).map((m => m.id)), this.sourceID = t.sourceID
          }
          createArrays() {
            this.text = new Df(new to(this.layers, this.zoom, (t => /^text/.test(t)))), this.icon = new Df(new to(this.layers, this.zoom, (t => /^icon/.test(t)))), this.glyphOffsetArray = new R, this.lineVertexArray = new H, this.symbolInstances = new O, this.textAnchorOffsets = new ce
          }
          calculateGlyphDependencies(t, r, n, c, f) {
            for (let m = 0; m < t.length; m++)
              if (r[t.charCodeAt(m)] = !0, (n || c) && f) {
                const v = ju[t.charAt(m)];
                v && (r[v.charCodeAt(0)] = !0)
              }
          }
          populate(t, r, n) {
            const c = this.layers[0],
              f = c.layout,
              m = f.get("text-font"),
              v = f.get("text-field"),
              b = f.get("icon-image"),
              M = (v.value.kind !== "constant" || v.value.value instanceof Di && !v.value.value.isEmpty() || v.value.value.toString().length > 0) && (m.value.kind !== "constant" || m.value.value.length > 0),
              C = b.value.kind !== "constant" || !!b.value.value || Object.keys(b.parameters).length > 0,
              D = f.get("symbol-sort-key");
            if (this.features = [], !M && !C) return;
            const N = r.iconDependencies,
              W = r.glyphDependencies,
              X = r.availableImages,
              Q = new ta(this.zoom);
            for (const {
                feature: le,
                id: we,
                index: et,
                sourceLayerIndex: De
              }
              of t) {
              const Ze = c._featureFilter.needGeometry,
                mt = ks(le, Ze);
              if (!c._featureFilter.filter(Q, mt, n)) continue;
              let Mt, $t;
              if (Ze || (mt.geometry = _s(le)), M) {
                const hr = c.getValueAndResolveTokens("text-field", mt, n, X),
                  yr = Di.factory(hr),
                  $r = this.hasRTLText = this.hasRTLText || s1(yr);
                (!$r || ps.getRTLTextPluginStatus() === "unavailable" || $r && ps.isParsed()) && (Mt = Bx(yr, c, mt))
              }
              if (C) {
                const hr = c.getValueAndResolveTokens("icon-image", mt, n, X);
                $t = hr instanceof sa ? hr : sa.fromString(hr)
              }
              if (!Mt && !$t) continue;
              const Tr = this.sortFeaturesByKey ? D.evaluate(mt, {}, n) : void 0;
              if (this.features.push({
                  id: we,
                  text: Mt,
                  icon: $t,
                  index: et,
                  sourceLayerIndex: De,
                  geometry: mt.geometry,
                  properties: le.properties,
                  type: uc.types[le.type],
                  sortKey: Tr
                }), $t && (N[$t.name] = !0), Mt) {
                const hr = m.evaluate(mt, {}, n).join(","),
                  yr = f.get("text-rotation-alignment") !== "viewport" && f.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(T.as.vertical) >= 0;
                for (const $r of Mt.sections)
                  if ($r.image) N[$r.image.name] = !0;
                  else {
                    const gr = gu(Mt.toString()),
                      xr = $r.fontStack || hr,
                      Ft = W[xr] = W[xr] || {};
                    this.calculateGlyphDependencies($r.text, Ft, yr, this.allowVerticalPlacement, gr)
                  }
              }
            }
            f.get("symbol-placement") === "line" && (this.features = (function(le) {
              const we = {},
                et = {},
                De = [];
              let Ze = 0;

              function mt(hr) {
                De.push(le[hr]), Ze++
              }

              function Mt(hr, yr, $r) {
                const gr = et[hr];
                return delete et[hr], et[yr] = gr, De[gr].geometry[0].pop(), De[gr].geometry[0] = De[gr].geometry[0].concat($r[0]), gr
              }

              function $t(hr, yr, $r) {
                const gr = we[yr];
                return delete we[yr], we[hr] = gr, De[gr].geometry[0].shift(), De[gr].geometry[0] = $r[0].concat(De[gr].geometry[0]), gr
              }

              function Tr(hr, yr, $r) {
                const gr = $r ? yr[0][yr[0].length - 1] : yr[0][0];
                return `${hr}:${gr.x}:${gr.y}`
              }
              for (let hr = 0; hr < le.length; hr++) {
                const yr = le[hr],
                  $r = yr.geometry,
                  gr = yr.text ? yr.text.toString() : null;
                if (!gr) {
                  mt(hr);
                  continue
                }
                const xr = Tr(gr, $r),
                  Ft = Tr(gr, $r, !0);
                if (xr in et && Ft in we && et[xr] !== we[Ft]) {
                  const mi = $t(xr, Ft, $r),
                    xi = Mt(xr, Ft, De[mi].geometry);
                  delete we[xr], delete et[Ft], et[Tr(gr, De[xi].geometry, !0)] = xi, De[mi].geometry = null
                } else xr in et ? Mt(xr, Ft, $r) : Ft in we ? $t(xr, Ft, $r) : (mt(hr), we[xr] = Ze - 1, et[Ft] = Ze - 1)
              }
              return De.filter((hr => hr.geometry))
            })(this.features)), this.sortFeaturesByKey && this.features.sort(((le, we) => le.sortKey - we.sortKey))
          }
          update(t, r, n) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, r, this.layers, {
              imagePositions: n
            }), this.icon.programConfigurations.updatePaintArrays(t, r, this.layers, {
              imagePositions: n
            }))
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload
          }
          upload(t) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy()
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData()
          }
          addToLineVertexArray(t, r) {
            const n = this.lineVertexArray.length;
            if (t.segment !== void 0) {
              let c = t.dist(r[t.segment + 1]),
                f = t.dist(r[t.segment]);
              const m = {};
              for (let v = t.segment + 1; v < r.length; v++) m[v] = {
                x: r[v].x,
                y: r[v].y,
                tileUnitDistanceFromAnchor: c
              }, v < r.length - 1 && (c += r[v + 1].dist(r[v]));
              for (let v = t.segment || 0; v >= 0; v--) m[v] = {
                x: r[v].x,
                y: r[v].y,
                tileUnitDistanceFromAnchor: f
              }, v > 0 && (f += r[v - 1].dist(r[v]));
              for (let v = 0; v < r.length; v++) {
                const b = m[v];
                this.lineVertexArray.emplaceBack(b.x, b.y, b.tileUnitDistanceFromAnchor)
              }
            }
            return {
              lineStartIndex: n,
              lineLength: this.lineVertexArray.length - n
            }
          }
          addSymbols(t, r, n, c, f, m, v, b, M, C, D, N) {
            const W = t.indexArray,
              X = t.layoutVertexArray,
              Q = t.segments.prepareSegment(4 * r.length, X, W, this.canOverlap ? m.sortKey : void 0),
              le = this.glyphOffsetArray.length,
              we = Q.vertexLength,
              et = this.allowVerticalPlacement && v === T.as.vertical ? Math.PI / 2 : 0,
              De = m.text && m.text.sections;
            for (let Ze = 0; Ze < r.length; Ze++) {
              const {
                tl: mt,
                tr: Mt,
                bl: $t,
                br: Tr,
                tex: hr,
                pixelOffsetTL: yr,
                pixelOffsetBR: $r,
                minFontScaleX: gr,
                minFontScaleY: xr,
                glyphOffset: Ft,
                isSDF: mi,
                sectionIndex: xi
              } = r[Ze], si = Q.vertexLength, Hr = Ft[1];
              Gd(X, b.x, b.y, mt.x, Hr + mt.y, hr.x, hr.y, n, mi, yr.x, yr.y, gr, xr), Gd(X, b.x, b.y, Mt.x, Hr + Mt.y, hr.x + hr.w, hr.y, n, mi, $r.x, yr.y, gr, xr), Gd(X, b.x, b.y, $t.x, Hr + $t.y, hr.x, hr.y + hr.h, n, mi, yr.x, $r.y, gr, xr), Gd(X, b.x, b.y, Tr.x, Hr + Tr.y, hr.x + hr.w, hr.y + hr.h, n, mi, $r.x, $r.y, gr, xr), Lf(t.dynamicLayoutVertexArray, b, et), W.emplaceBack(si, si + 2, si + 1), W.emplaceBack(si + 1, si + 2, si + 3), Q.vertexLength += 4, Q.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(Ft[0]), Ze !== r.length - 1 && xi === r[Ze + 1].sectionIndex || t.programConfigurations.populatePaintArrays(X.length, m, m.index, {
                imagePositions: {},
                canonical: N,
                formattedSection: De && De[xi]
              })
            }
            t.placedSymbolArray.emplaceBack(b.x, b.y, le, this.glyphOffsetArray.length - le, we, M, C, b.segment, n ? n[0] : 0, n ? n[1] : 0, c[0], c[1], v, 0, !1, 0, D)
          }
          _addCollisionDebugVertex(t, r, n, c, f, m) {
            return r.emplaceBack(0, 0), t.emplaceBack(n.x, n.y, c, f, Math.round(m.x), Math.round(m.y))
          }
          addCollisionDebugVertices(t, r, n, c, f, m, v) {
            const b = f.segments.prepareSegment(4, f.layoutVertexArray, f.indexArray),
              M = b.vertexLength,
              C = f.layoutVertexArray,
              D = f.collisionVertexArray,
              N = v.anchorX,
              W = v.anchorY;
            this._addCollisionDebugVertex(C, D, m, N, W, new F(t, r)), this._addCollisionDebugVertex(C, D, m, N, W, new F(n, r)), this._addCollisionDebugVertex(C, D, m, N, W, new F(n, c)), this._addCollisionDebugVertex(C, D, m, N, W, new F(t, c)), b.vertexLength += 4;
            const X = f.indexArray;
            X.emplaceBack(M, M + 1), X.emplaceBack(M + 1, M + 2), X.emplaceBack(M + 2, M + 3), X.emplaceBack(M + 3, M), b.primitiveLength += 4
          }
          addDebugCollisionBoxes(t, r, n, c) {
            for (let f = t; f < r; f++) {
              const m = this.collisionBoxArray.get(f);
              this.addCollisionDebugVertices(m.x1, m.y1, m.x2, m.y2, c ? this.textCollisionBox : this.iconCollisionBox, m.anchorPoint, n)
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Rf(lr, p_.members, Nr), this.iconCollisionBox = new Rf(lr, p_.members, Nr);
            for (let t = 0; t < this.symbolInstances.length; t++) {
              const r = this.symbolInstances.get(t);
              this.addDebugCollisionBoxes(r.textBoxStartIndex, r.textBoxEndIndex, r, !0), this.addDebugCollisionBoxes(r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r, !0), this.addDebugCollisionBoxes(r.iconBoxStartIndex, r.iconBoxEndIndex, r, !1), this.addDebugCollisionBoxes(r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex, r, !1)
            }
          }
          _deserializeCollisionBoxesForSymbol(t, r, n, c, f, m, v, b, M) {
            const C = {};
            for (let D = r; D < n; D++) {
              const N = t.get(D);
              C.textBox = {
                x1: N.x1,
                y1: N.y1,
                x2: N.x2,
                y2: N.y2,
                anchorPointX: N.anchorPointX,
                anchorPointY: N.anchorPointY
              }, C.textFeatureIndex = N.featureIndex;
              break
            }
            for (let D = c; D < f; D++) {
              const N = t.get(D);
              C.verticalTextBox = {
                x1: N.x1,
                y1: N.y1,
                x2: N.x2,
                y2: N.y2,
                anchorPointX: N.anchorPointX,
                anchorPointY: N.anchorPointY
              }, C.verticalTextFeatureIndex = N.featureIndex;
              break
            }
            for (let D = m; D < v; D++) {
              const N = t.get(D);
              C.iconBox = {
                x1: N.x1,
                y1: N.y1,
                x2: N.x2,
                y2: N.y2,
                anchorPointX: N.anchorPointX,
                anchorPointY: N.anchorPointY
              }, C.iconFeatureIndex = N.featureIndex;
              break
            }
            for (let D = b; D < M; D++) {
              const N = t.get(D);
              C.verticalIconBox = {
                x1: N.x1,
                y1: N.y1,
                x2: N.x2,
                y2: N.y2,
                anchorPointX: N.anchorPointX,
                anchorPointY: N.anchorPointY
              }, C.verticalIconFeatureIndex = N.featureIndex;
              break
            }
            return C
          }
          deserializeCollisionBoxes(t) {
            this.collisionArrays = [];
            for (let r = 0; r < this.symbolInstances.length; r++) {
              const n = this.symbolInstances.get(r);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, n.textBoxStartIndex, n.textBoxEndIndex, n.verticalTextBoxStartIndex, n.verticalTextBoxEndIndex, n.iconBoxStartIndex, n.iconBoxEndIndex, n.verticalIconBoxStartIndex, n.verticalIconBoxEndIndex))
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0
          }
          hasIconData() {
            return this.icon.segments.get().length > 0
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0
          }
          addIndicesForPlacedSymbol(t, r) {
            const n = t.placedSymbolArray.get(r),
              c = n.vertexStartIndex + 4 * n.numGlyphs;
            for (let f = n.vertexStartIndex; f < c; f += 4) t.indexArray.emplaceBack(f, f + 2, f + 1), t.indexArray.emplaceBack(f + 1, f + 2, f + 3)
          }
          getSortedSymbolIndexes(t) {
            if (this.sortedAngle === t && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
            const r = Math.sin(t),
              n = Math.cos(t),
              c = [],
              f = [],
              m = [];
            for (let v = 0; v < this.symbolInstances.length; ++v) {
              m.push(v);
              const b = this.symbolInstances.get(v);
              c.push(0 | Math.round(r * b.anchorX + n * b.anchorY)), f.push(b.featureIndex)
            }
            return m.sort(((v, b) => c[v] - c[b] || f[b] - f[v])), m
          }
          addToSortKeyRanges(t, r) {
            const n = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            n && n.sortKey === r ? n.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({
              sortKey: r,
              symbolInstanceStart: t,
              symbolInstanceEnd: t + 1
            })
          }
          sortFeatures(t) {
            if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const r of this.symbolInstanceIndexes) {
                const n = this.symbolInstances.get(r);
                this.featureSortOrder.push(n.featureIndex), [n.rightJustifiedTextSymbolIndex, n.centerJustifiedTextSymbolIndex, n.leftJustifiedTextSymbolIndex].forEach(((c, f, m) => {
                  c >= 0 && m.indexOf(c) === f && this.addIndicesForPlacedSymbol(this.text, c)
                })), n.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, n.verticalPlacedTextSymbolIndex), n.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, n.placedIconSymbolIndex), n.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, n.verticalPlacedIconSymbolIndex)
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray)
            }
          }
        }
        let M_, C_;
        zr("SymbolBucket", pc, {
          omit: ["layers", "collisionBoxArray", "features", "compareText"]
        }), pc.MAX_GLYPHS = 65535, pc.addDynamicAttributes = Lf;
        var Ff = {
          get paint() {
            return C_ = C_ || new an({
              "icon-opacity": new hi(Y.paint_symbol["icon-opacity"]),
              "icon-color": new hi(Y.paint_symbol["icon-color"]),
              "icon-halo-color": new hi(Y.paint_symbol["icon-halo-color"]),
              "icon-halo-width": new hi(Y.paint_symbol["icon-halo-width"]),
              "icon-halo-blur": new hi(Y.paint_symbol["icon-halo-blur"]),
              "icon-translate": new Xr(Y.paint_symbol["icon-translate"]),
              "icon-translate-anchor": new Xr(Y.paint_symbol["icon-translate-anchor"]),
              "text-opacity": new hi(Y.paint_symbol["text-opacity"]),
              "text-color": new hi(Y.paint_symbol["text-color"], {
                runtimeType: Sr,
                getOverride: i => i.textColor,
                hasOverride: i => !!i.textColor
              }),
              "text-halo-color": new hi(Y.paint_symbol["text-halo-color"]),
              "text-halo-width": new hi(Y.paint_symbol["text-halo-width"]),
              "text-halo-blur": new hi(Y.paint_symbol["text-halo-blur"]),
              "text-translate": new Xr(Y.paint_symbol["text-translate"]),
              "text-translate-anchor": new Xr(Y.paint_symbol["text-translate-anchor"])
            })
          },
          get layout() {
            return M_ = M_ || new an({
              "symbol-placement": new Xr(Y.layout_symbol["symbol-placement"]),
              "symbol-spacing": new Xr(Y.layout_symbol["symbol-spacing"]),
              "symbol-avoid-edges": new Xr(Y.layout_symbol["symbol-avoid-edges"]),
              "symbol-sort-key": new hi(Y.layout_symbol["symbol-sort-key"]),
              "symbol-z-order": new Xr(Y.layout_symbol["symbol-z-order"]),
              "icon-allow-overlap": new Xr(Y.layout_symbol["icon-allow-overlap"]),
              "icon-overlap": new Xr(Y.layout_symbol["icon-overlap"]),
              "icon-ignore-placement": new Xr(Y.layout_symbol["icon-ignore-placement"]),
              "icon-optional": new Xr(Y.layout_symbol["icon-optional"]),
              "icon-rotation-alignment": new Xr(Y.layout_symbol["icon-rotation-alignment"]),
              "icon-size": new hi(Y.layout_symbol["icon-size"]),
              "icon-text-fit": new Xr(Y.layout_symbol["icon-text-fit"]),
              "icon-text-fit-padding": new Xr(Y.layout_symbol["icon-text-fit-padding"]),
              "icon-image": new hi(Y.layout_symbol["icon-image"]),
              "icon-rotate": new hi(Y.layout_symbol["icon-rotate"]),
              "icon-padding": new hi(Y.layout_symbol["icon-padding"]),
              "icon-keep-upright": new Xr(Y.layout_symbol["icon-keep-upright"]),
              "icon-offset": new hi(Y.layout_symbol["icon-offset"]),
              "icon-anchor": new hi(Y.layout_symbol["icon-anchor"]),
              "icon-pitch-alignment": new Xr(Y.layout_symbol["icon-pitch-alignment"]),
              "text-pitch-alignment": new Xr(Y.layout_symbol["text-pitch-alignment"]),
              "text-rotation-alignment": new Xr(Y.layout_symbol["text-rotation-alignment"]),
              "text-field": new hi(Y.layout_symbol["text-field"]),
              "text-font": new hi(Y.layout_symbol["text-font"]),
              "text-size": new hi(Y.layout_symbol["text-size"]),
              "text-max-width": new hi(Y.layout_symbol["text-max-width"]),
              "text-line-height": new Xr(Y.layout_symbol["text-line-height"]),
              "text-letter-spacing": new hi(Y.layout_symbol["text-letter-spacing"]),
              "text-justify": new hi(Y.layout_symbol["text-justify"]),
              "text-radial-offset": new hi(Y.layout_symbol["text-radial-offset"]),
              "text-variable-anchor": new Xr(Y.layout_symbol["text-variable-anchor"]),
              "text-variable-anchor-offset": new hi(Y.layout_symbol["text-variable-anchor-offset"]),
              "text-anchor": new hi(Y.layout_symbol["text-anchor"]),
              "text-max-angle": new Xr(Y.layout_symbol["text-max-angle"]),
              "text-writing-mode": new Xr(Y.layout_symbol["text-writing-mode"]),
              "text-rotate": new hi(Y.layout_symbol["text-rotate"]),
              "text-padding": new Xr(Y.layout_symbol["text-padding"]),
              "text-keep-upright": new Xr(Y.layout_symbol["text-keep-upright"]),
              "text-transform": new hi(Y.layout_symbol["text-transform"]),
              "text-offset": new hi(Y.layout_symbol["text-offset"]),
              "text-allow-overlap": new Xr(Y.layout_symbol["text-allow-overlap"]),
              "text-overlap": new Xr(Y.layout_symbol["text-overlap"]),
              "text-ignore-placement": new Xr(Y.layout_symbol["text-ignore-placement"]),
              "text-optional": new Xr(Y.layout_symbol["text-optional"])
            })
          }
        };
        class A_ {
          constructor(t) {
            if (t.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = t.property.overrides ? t.property.overrides.runtimeType : or, this.defaultValue = t
          }
          evaluate(t) {
            if (t.formattedSection) {
              const r = this.defaultValue.property.overrides;
              if (r && r.hasOverride(t.formattedSection)) return r.getOverride(t.formattedSection)
            }
            return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default
          }
          eachChild(t) {
            this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression)
          }
          outputDefined() {
            return !1
          }
          serialize() {
            return null
          }
        }
        zr("FormatSectionOverride", A_, {
          omit: ["defaultValue"]
        });
        class Wd extends Zn {
          constructor(t, r) {
            super(t, Ff, r)
          }
          recalculate(t, r) {
            if (super.recalculate(t, r), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
              const n = this.layout.get("text-writing-mode");
              if (n) {
                const c = [];
                for (const f of n) c.indexOf(f) < 0 && c.push(f);
                this.layout._values["text-writing-mode"] = c
              } else this.layout._values["text-writing-mode"] = ["horizontal"]
            }
            this._setPaintOverrides()
          }
          getValueAndResolveTokens(t, r, n, c) {
            const f = this.layout.get(t).evaluate(r, {}, n, c),
              m = this._unevaluatedLayout._values[t];
            return m.isDataDriven() || jl(m.value) || !f ? f : (function(v, b) {
              return b.replace(/{([^{}]+)}/g, ((M, C) => v && C in v ? String(v[C]) : ""))
            })(r.properties, f)
          }
          createBucket(t) {
            return new pc(t)
          }
          queryRadius() {
            return 0
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex")
          }
          _setPaintOverrides() {
            for (const t of Ff.paint.overridableProperties) {
              if (!Wd.hasPaintOverride(this.layout, t)) continue;
              const r = this.paint.get(t),
                n = new A_(r),
                c = new ru(n, r.property.specification);
              let f = null;
              f = r.value.kind === "constant" || r.value.kind === "source" ? new Jo("source", c) : new iu("composite", c, r.value.zoomStops), this.paint._values[t] = new Un(r.property, f, r.parameters)
            }
          }
          _handleOverridablePaintPropertyUpdate(t, r, n) {
            return !(!this.layout || r.isDataDriven() || n.isDataDriven()) && Wd.hasPaintOverride(this.layout, t)
          }
          static hasPaintOverride(t, r) {
            const n = t.get("text-field"),
              c = Ff.paint.properties[r];
            let f = !1;
            const m = v => {
              for (const b of v)
                if (c.overrides && c.overrides.hasOverride(b)) return void(f = !0)
            };
            if (n.value.kind === "constant" && n.value.value instanceof Di) m(n.value.value.sections);
            else if (n.value.kind === "source" || n.value.kind === "composite") {
              const v = M => {
                  f || (M instanceof Ia && ea(M.value) === Jr ? m(M.value.sections) : M instanceof Cl ? m(M.sections) : M.eachChild(v))
                },
                b = n.value;
              b._styleExpression && v(b._styleExpression.expression)
            }
            return f
          }
        }
        let k_;
        var o1 = {
          get paint() {
            return k_ = k_ || new an({
              "background-color": new Xr(Y.paint_background["background-color"]),
              "background-pattern": new Ad(Y.paint_background["background-pattern"]),
              "background-opacity": new Xr(Y.paint_background["background-opacity"])
            })
          }
        };
        class l1 extends Zn {
          constructor(t, r) {
            super(t, o1, r)
          }
        }
        class c1 extends Zn {
          constructor(t, r) {
            super(t, {}, r), this.onAdd = n => {
              this.implementation.onAdd && this.implementation.onAdd(n, n.painter.context.gl)
            }, this.onRemove = n => {
              this.implementation.onRemove && this.implementation.onRemove(n, n.painter.context.gl)
            }, this.implementation = t
          }
          is3D() {
            return this.implementation.renderingMode === "3d"
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0
          }
          recalculate() {}
          updateTransitions() {}
          hasTransition() {
            return !1
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized")
          }
        }
        class u1 {
          constructor(t) {
            this._methodToThrottle = t, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel, this._channel.port2.onmessage = () => {
              this._triggered = !1, this._methodToThrottle()
            })
          }
          trigger() {
            this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout((() => {
              this._triggered = !1, this._methodToThrottle()
            }), 0))
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {}
          }
        }
        const h1 = {
            once: !0
          },
          Bf = 63710088e-1;
        class Do {
          constructor(t, r) {
            if (isNaN(t) || isNaN(r)) throw new Error(`Invalid LngLat object: (${t}, ${r})`);
            if (this.lng = +t, this.lat = +r, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90")
          }
          wrap() {
            return new Do(lt(this.lng, -180, 180), this.lat)
          }
          toArray() {
            return [this.lng, this.lat]
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`
          }
          distanceTo(t) {
            const r = Math.PI / 180,
              n = this.lat * r,
              c = t.lat * r,
              f = Math.sin(n) * Math.sin(c) + Math.cos(n) * Math.cos(c) * Math.cos((t.lng - this.lng) * r);
            return Bf * Math.acos(Math.min(f, 1))
          }
          static convert(t) {
            if (t instanceof Do) return t;
            if (Array.isArray(t) && (t.length === 2 || t.length === 3)) return new Do(Number(t[0]), Number(t[1]));
            if (!Array.isArray(t) && typeof t == "object" && t !== null) return new Do(Number("lng" in t ? t.lng : t.lon), Number(t.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")
          }
        }
        const z_ = 2 * Math.PI * Bf;

        function E_(i) {
          return z_ * Math.cos(i * Math.PI / 180)
        }

        function L_(i) {
          return (180 + i) / 360
        }

        function D_(i) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i * Math.PI / 360))) / 360
        }

        function R_(i, t) {
          return i / E_(t)
        }

        function F_(i) {
          return 360 * i - 180
        }

        function Hd(i) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * i) * Math.PI / 180)) - 90
        }

        function B_(i, t) {
          return i * E_(Hd(t))
        }
        class Nu {
          constructor(t, r, n = 0) {
            this.x = +t, this.y = +r, this.z = +n
          }
          static fromLngLat(t, r = 0) {
            const n = Do.convert(t);
            return new Nu(L_(n.lng), D_(n.lat), R_(r, n.lat))
          }
          toLngLat() {
            return new Do(F_(this.x), Hd(this.y))
          }
          toAltitude() {
            return B_(this.z, this.y)
          }
          meterInMercatorCoordinateUnits() {
            return 1 / z_ * (t = Hd(this.y), 1 / Math.cos(t * Math.PI / 180));
            var t
          }
        }

        function O_(i, t, r) {
          var n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);
          return [i * n - 2 * Math.PI * 6378137 / 2, t * n - 2 * Math.PI * 6378137 / 2]
        }
        class Of {
          constructor(t, r, n) {
            if (!(function(c, f, m) {
                return !(c < 0 || c > 25 || m < 0 || m >= Math.pow(2, c) || f < 0 || f >= Math.pow(2, c))
              })(t, r, n)) throw new Error(`x=${r}, y=${n}, z=${t} outside of bounds. 0<=x<${Math.pow(2,t)}, 0<=y<${Math.pow(2,t)} 0<=z<=25 `);
            this.z = t, this.x = r, this.y = n, this.key = fc(0, t, t, r, n)
          }
          equals(t) {
            return this.z === t.z && this.x === t.x && this.y === t.y
          }
          url(t, r, n) {
            const c = (m = this.y, v = this.z, b = O_(256 * (f = this.x), 256 * (m = Math.pow(2, v) - m - 1), v), M = O_(256 * (f + 1), 256 * (m + 1), v), b[0] + "," + b[1] + "," + M[0] + "," + M[1]);
            var f, m, v, b, M;
            const C = (function(D, N, W) {
              let X, Q = "";
              for (let le = D; le > 0; le--) X = 1 << le - 1, Q += (N & X ? 1 : 0) + (W & X ? 2 : 0);
              return Q
            })(this.z, this.x, this.y);
            return t[(this.x + this.y) % t.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(n === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, r > 1 ? "@2x" : "").replace(/{quadkey}/g, C).replace(/{bbox-epsg-3857}/g, c)
          }
          isChildOf(t) {
            const r = this.z - t.z;
            return r > 0 && t.x === this.x >> r && t.y === this.y >> r
          }
          getTilePoint(t) {
            const r = Math.pow(2, this.z);
            return new F((t.x * r - this.x) * nt, (t.y * r - this.y) * nt)
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`
          }
        }
        class j_ {
          constructor(t, r) {
            this.wrap = t, this.canonical = r, this.key = fc(t, r.z, r.z, r.x, r.y)
          }
        }
        class Wn {
          constructor(t, r, n, c, f) {
            if (this.terrainRttPosMatrix32f = null, t < n) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t}; z = ${n}`);
            this.overscaledZ = t, this.wrap = r, this.canonical = new Of(n, +c, +f), this.key = fc(r, t, n, c, f)
          }
          clone() {
            return new Wn(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          equals(t) {
            return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical)
          }
          scaledTo(t) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const r = this.canonical.z - t;
            return t > this.canonical.z ? new Wn(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Wn(t, this.wrap, t, this.canonical.x >> r, this.canonical.y >> r)
          }
          isOverscaled() {
            return this.overscaledZ > this.canonical.z
          }
          calculateScaledKey(t, r) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const n = this.canonical.z - t;
            return t > this.canonical.z ? fc(this.wrap * +r, t, this.canonical.z, this.canonical.x, this.canonical.y) : fc(this.wrap * +r, t, t, this.canonical.x >> n, this.canonical.y >> n)
          }
          isChildOf(t) {
            if (t.wrap !== this.wrap || this.overscaledZ - t.overscaledZ <= 0) return !1;
            if (t.overscaledZ === 0) return this.overscaledZ > 0;
            const r = this.canonical.z - t.canonical.z;
            return !(r < 0) && t.canonical.x === this.canonical.x >> r && t.canonical.y === this.canonical.y >> r
          }
          children(t) {
            if (this.overscaledZ >= t) return [new Wn(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const r = this.canonical.z + 1,
              n = 2 * this.canonical.x,
              c = 2 * this.canonical.y;
            return [new Wn(r, this.wrap, r, n, c), new Wn(r, this.wrap, r, n + 1, c), new Wn(r, this.wrap, r, n, c + 1), new Wn(r, this.wrap, r, n + 1, c + 1)]
          }
          isLessThan(t) {
            return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y))
          }
          wrapped() {
            return new Wn(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          unwrapTo(t) {
            return new Wn(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z)
          }
          toUnwrapped() {
            return new j_(this.wrap, this.canonical)
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`
          }
          getTilePoint(t) {
            return this.canonical.getTilePoint(new Nu(t.x - this.wrap, t.y))
          }
        }

        function fc(i, t, r, n, c) {
          (i *= 2) < 0 && (i = -1 * i - 1);
          const f = 1 << r;
          return (f * f * i + f * c + n).toString(36) + r.toString(36) + t.toString(36)
        }

        function Vu(i, t) {
          return t ? i.properties[t] : i.id
        }
        zr("CanonicalTileID", Of), zr("OverscaledTileID", Wn, {
          omit: ["terrainRttPosMatrix32f"]
        });
        class hl {
          constructor() {
            this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0
          }
          extend(t) {
            return this.minX = Math.min(this.minX, t.x), this.minY = Math.min(this.minY, t.y), this.maxX = Math.max(this.maxX, t.x), this.maxY = Math.max(this.maxY, t.y), this
          }
          expandBy(t) {
            return this.minX -= t, this.minY -= t, this.maxX += t, this.maxY += t, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0), this
          }
          shrinkBy(t) {
            return this.expandBy(-t)
          }
          map(t) {
            const r = new hl;
            return r.extend(t(new F(this.minX, this.minY))), r.extend(t(new F(this.maxX, this.minY))), r.extend(t(new F(this.minX, this.maxY))), r.extend(t(new F(this.maxX, this.maxY))), r
          }
          static fromPoints(t) {
            const r = new hl;
            for (const n of t) r.extend(n);
            return r
          }
          contains(t) {
            return t.x >= this.minX && t.x <= this.maxX && t.y >= this.minY && t.y <= this.maxY
          }
          empty() {
            return this.minX > this.maxX
          }
          width() {
            return this.maxX - this.minX
          }
          height() {
            return this.maxY - this.minY
          }
          covers(t) {
            return !this.empty() && !t.empty() && t.minX >= this.minX && t.maxX <= this.maxX && t.minY >= this.minY && t.maxY <= this.maxY
          }
          intersects(t) {
            return !this.empty() && !t.empty() && t.minX <= this.maxX && t.maxX >= this.minX && t.minY <= this.maxY && t.maxY >= this.minY
          }
        }
        class q_ {
          constructor(t) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let r = 0; r < t.length; r++) {
              const n = t[r];
              this._stringToNumber[n] = r, this._numberToString[r] = n
            }
          }
          encode(t) {
            return this._stringToNumber[t]
          }
          decode(t) {
            if (t >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[t]
          }
        }
        class N_ {
          constructor(t, r, n, c, f) {
            this.type = "Feature", this._vectorTileFeature = t, t._z = r, t._x = n, t._y = c, this.properties = t.properties, this.id = f
          }
          get geometry() {
            return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry
          }
          set geometry(t) {
            this._geometry = t
          }
          toJSON() {
            const t = {
              geometry: this.geometry
            };
            for (const r in this) r !== "_geometry" && r !== "_vectorTileFeature" && (t[r] = this[r]);
            return t
          }
        }
        class V_ {
          constructor(t, r) {
            this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new Hs(nt, 16, 0), this.grid3D = new Hs(nt, 16, 0), this.featureIndexArray = new de, this.promoteId = r
          }
          insert(t, r, n, c, f, m) {
            const v = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(n, c, f);
            const b = m ? this.grid3D : this.grid;
            for (let M = 0; M < r.length; M++) {
              const C = r[M],
                D = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let N = 0; N < C.length; N++) {
                const W = C[N];
                D[0] = Math.min(D[0], W.x), D[1] = Math.min(D[1], W.y), D[2] = Math.max(D[2], W.x), D[3] = Math.max(D[3], W.y)
              }
              D[0] < nt && D[1] < nt && D[2] >= 0 && D[3] >= 0 && b.insert(v, D[0], D[1], D[2], D[3])
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new a_(new Cf(this.rawTileData)).layers, this.sourceLayerCoder = new q_(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers
          }
          query(t, r, n, c) {
            this.loadVTLayers();
            const f = t.params,
              m = nt / t.tileSize / t.scale,
              v = $o(f.filter, f.globalState),
              b = t.queryGeometry,
              M = t.queryPadding * m,
              C = hl.fromPoints(b),
              D = this.grid.query(C.minX - M, C.minY - M, C.maxX + M, C.maxY + M),
              N = hl.fromPoints(t.cameraQueryGeometry).expandBy(M),
              W = this.grid3D.query(N.minX, N.minY, N.maxX, N.maxY, ((le, we, et, De) => (function(Ze, mt, Mt, $t, Tr) {
                for (const yr of Ze)
                  if (mt <= yr.x && Mt <= yr.y && $t >= yr.x && Tr >= yr.y) return !0;
                const hr = [new F(mt, Mt), new F(mt, Tr), new F($t, Tr), new F($t, Mt)];
                if (Ze.length > 2) {
                  for (const yr of hr)
                    if (nc(Ze, yr)) return !0
                }
                for (let yr = 0; yr < Ze.length - 1; yr++)
                  if (Ny(Ze[yr], Ze[yr + 1], hr)) return !0;
                return !1
              })(t.cameraQueryGeometry, le - M, we - M, et + M, De + M)));
            for (const le of W) D.push(le);
            D.sort(d1);
            const X = {};
            let Q;
            for (let le = 0; le < D.length; le++) {
              const we = D[le];
              if (we === Q) continue;
              Q = we;
              const et = this.featureIndexArray.get(we);
              let De = null;
              this.loadMatchingFeature(X, et.bucketIndex, et.sourceLayerIndex, et.featureIndex, v, f.layers, f.availableImages, r, n, c, ((Ze, mt, Mt) => (De || (De = _s(Ze)), mt.queryIntersectsFeature({
                queryGeometry: b,
                feature: Ze,
                featureState: Mt,
                geometry: De,
                zoom: this.z,
                transform: t.transform,
                pixelsToTileUnits: m,
                pixelPosMatrix: t.pixelPosMatrix,
                unwrappedTileID: this.tileID.toUnwrapped(),
                getElevation: t.getElevation
              }))))
            }
            return X
          }
          loadMatchingFeature(t, r, n, c, f, m, v, b, M, C, D) {
            const N = this.bucketLayerIDs[r];
            if (m && !N.some((le => m.has(le)))) return;
            const W = this.sourceLayerCoder.decode(n),
              X = this.vtLayers[W].feature(c);
            if (f.needGeometry) {
              const le = ks(X, !0);
              if (!f.filter(new ta(this.tileID.overscaledZ), le, this.tileID.canonical)) return
            } else if (!f.filter(new ta(this.tileID.overscaledZ), X)) return;
            const Q = this.getId(X, W);
            for (let le = 0; le < N.length; le++) {
              const we = N[le];
              if (m && !m.has(we)) continue;
              const et = b[we];
              if (!et) continue;
              let De = {};
              Q && C && (De = C.getState(et.sourceLayer || "_geojsonTileLayer", Q));
              const Ze = ht({}, M[we]);
              Ze.paint = U_(Ze.paint, et.paint, X, De, v), Ze.layout = U_(Ze.layout, et.layout, X, De, v);
              const mt = !D || D(X, et, De);
              if (!mt) continue;
              const Mt = new N_(X, this.z, this.x, this.y, Q);
              Mt.layer = Ze;
              let $t = t[we];
              $t === void 0 && ($t = t[we] = []), $t.push({
                featureIndex: c,
                feature: Mt,
                intersectionZ: mt
              })
            }
          }
          lookupSymbolFeatures(t, r, n, c, f, m, v, b) {
            const M = {};
            this.loadVTLayers();
            const C = $o(f.filterSpec, f.globalState);
            for (const D of t) this.loadMatchingFeature(M, n, c, D, C, m, v, b, r);
            return M
          }
          hasLayer(t) {
            for (const r of this.bucketLayerIDs)
              for (const n of r)
                if (t === n) return !0;
            return !1
          }
          getId(t, r) {
            var n;
            let c = t.id;
            return this.promoteId && (c = t.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[r]], typeof c == "boolean" && (c = Number(c)), c === void 0 && (!((n = t.properties) === null || n === void 0) && n.cluster) && this.promoteId && (c = Number(t.properties.cluster_id))), c
          }
        }

        function U_(i, t, r, n, c) {
          return Vt(i, ((f, m) => {
            const v = t instanceof Xs ? t.get(m) : null;
            return v && v.evaluate ? v.evaluate(r, n, c) : v
          }))
        }

        function d1(i, t) {
          return t - i
        }

        function Z_(i, t, r, n, c) {
          const f = [];
          for (let m = 0; m < i.length; m++) {
            const v = i[m];
            let b;
            for (let M = 0; M < v.length - 1; M++) {
              let C = v[M],
                D = v[M + 1];
              C.x < t && D.x < t || (C.x < t ? C = new F(t, C.y + (t - C.x) / (D.x - C.x) * (D.y - C.y))._round() : D.x < t && (D = new F(t, C.y + (t - C.x) / (D.x - C.x) * (D.y - C.y))._round()), C.y < r && D.y < r || (C.y < r ? C = new F(C.x + (r - C.y) / (D.y - C.y) * (D.x - C.x), r)._round() : D.y < r && (D = new F(C.x + (r - C.y) / (D.y - C.y) * (D.x - C.x), r)._round()), C.x >= n && D.x >= n || (C.x >= n ? C = new F(n, C.y + (n - C.x) / (D.x - C.x) * (D.y - C.y))._round() : D.x >= n && (D = new F(n, C.y + (n - C.x) / (D.x - C.x) * (D.y - C.y))._round()), C.y >= c && D.y >= c || (C.y >= c ? C = new F(C.x + (c - C.y) / (D.y - C.y) * (D.x - C.x), c)._round() : D.y >= c && (D = new F(C.x + (c - C.y) / (D.y - C.y) * (D.x - C.x), c)._round()), b && C.equals(b[b.length - 1]) || (b = [C], f.push(b)), b.push(D)))))
            }
          }
          return f
        }
        zr("FeatureIndex", V_, {
          omit: ["rawTileData", "sourceLayerCoder"]
        });
        class Ro extends F {
          constructor(t, r, n, c) {
            super(t, r), this.angle = n, c !== void 0 && (this.segment = c)
          }
          clone() {
            return new Ro(this.x, this.y, this.angle, this.segment)
          }
        }

        function G_(i, t, r, n, c) {
          if (t.segment === void 0 || r === 0) return !0;
          let f = t,
            m = t.segment + 1,
            v = 0;
          for (; v > -r / 2;) {
            if (m--, m < 0) return !1;
            v -= i[m].dist(f), f = i[m]
          }
          v += i[m].dist(i[m + 1]), m++;
          const b = [];
          let M = 0;
          for (; v < r / 2;) {
            const C = i[m],
              D = i[m + 1];
            if (!D) return !1;
            let N = i[m - 1].angleTo(C) - C.angleTo(D);
            for (N = Math.abs((N + 3 * Math.PI) % (2 * Math.PI) - Math.PI), b.push({
                distance: v,
                angleDelta: N
              }), M += N; v - b[0].distance > n;) M -= b.shift().angleDelta;
            if (M > c) return !1;
            m++, v += C.dist(D)
          }
          return !0
        }

        function W_(i) {
          let t = 0;
          for (let r = 0; r < i.length - 1; r++) t += i[r].dist(i[r + 1]);
          return t
        }

        function H_(i, t, r) {
          return i ? .6 * t * r : 0
        }

        function X_(i, t) {
          return Math.max(i ? i.right - i.left : 0, t ? t.right - t.left : 0)
        }

        function p1(i, t, r, n, c, f) {
          const m = H_(r, c, f),
            v = X_(r, n) * f;
          let b = 0;
          const M = W_(i) / 2;
          for (let C = 0; C < i.length - 1; C++) {
            const D = i[C],
              N = i[C + 1],
              W = D.dist(N);
            if (b + W > M) {
              const X = (M - b) / W,
                Q = En.number(D.x, N.x, X),
                le = En.number(D.y, N.y, X),
                we = new Ro(Q, le, N.angleTo(D), C);
              return we._round(), !m || G_(i, we, v, m, t) ? we : void 0
            }
            b += W
          }
        }

        function f1(i, t, r, n, c, f, m, v, b) {
          const M = H_(n, f, m),
            C = X_(n, c),
            D = C * m,
            N = i[0].x === 0 || i[0].x === b || i[0].y === 0 || i[0].y === b;
          return t - D < t / 4 && (t = D + t / 4), Y_(i, N ? t / 2 * v % t : (C / 2 + 2 * f) * m * v % t, t, M, r, D, N, !1, b)
        }

        function Y_(i, t, r, n, c, f, m, v, b) {
          const M = f / 2,
            C = W_(i);
          let D = 0,
            N = t - r,
            W = [];
          for (let X = 0; X < i.length - 1; X++) {
            const Q = i[X],
              le = i[X + 1],
              we = Q.dist(le),
              et = le.angleTo(Q);
            for (; N + r < D + we;) {
              N += r;
              const De = (N - D) / we,
                Ze = En.number(Q.x, le.x, De),
                mt = En.number(Q.y, le.y, De);
              if (Ze >= 0 && Ze < b && mt >= 0 && mt < b && N - M >= 0 && N + M <= C) {
                const Mt = new Ro(Ze, mt, et, X);
                Mt._round(), n && !G_(i, Mt, f, n, c) || W.push(Mt)
              }
            }
            D += we
          }
          return v || W.length || m || (W = Y_(i, D / 2, r, n, c, f, m, !0, b)), W
        }

        function K_(i, t, r, n) {
          const c = [],
            f = i.image,
            m = f.pixelRatio,
            v = f.paddedRect.w - 2,
            b = f.paddedRect.h - 2;
          let M = {
            x1: i.left,
            y1: i.top,
            x2: i.right,
            y2: i.bottom
          };
          const C = f.stretchX || [
              [0, v]
            ],
            D = f.stretchY || [
              [0, b]
            ],
            N = (Ft, mi) => Ft + mi[1] - mi[0],
            W = C.reduce(N, 0),
            X = D.reduce(N, 0),
            Q = v - W,
            le = b - X;
          let we = 0,
            et = W,
            De = 0,
            Ze = X,
            mt = 0,
            Mt = Q,
            $t = 0,
            Tr = le;
          if (f.content && n) {
            const Ft = f.content,
              mi = Ft[2] - Ft[0],
              xi = Ft[3] - Ft[1];
            (f.textFitWidth || f.textFitHeight) && (M = S_(i)), we = Xd(C, 0, Ft[0]), De = Xd(D, 0, Ft[1]), et = Xd(C, Ft[0], Ft[2]), Ze = Xd(D, Ft[1], Ft[3]), mt = Ft[0] - we, $t = Ft[1] - De, Mt = mi - et, Tr = xi - Ze
          }
          const hr = M.x1,
            yr = M.y1,
            $r = M.x2 - hr,
            gr = M.y2 - yr,
            xr = (Ft, mi, xi, si) => {
              const Hr = Yd(Ft.stretch - we, et, $r, hr),
                Ni = Kd(Ft.fixed - mt, Mt, Ft.stretch, W),
                ba = Yd(mi.stretch - De, Ze, gr, yr),
                Ra = Kd(mi.fixed - $t, Tr, mi.stretch, X),
                sn = Yd(xi.stretch - we, et, $r, hr),
                Hn = Kd(xi.fixed - mt, Mt, xi.stretch, W),
                Pn = Yd(si.stretch - De, Ze, gr, yr),
                Ja = Kd(si.fixed - $t, Tr, si.stretch, X),
                ya = new F(Hr, ba),
                Wa = new F(sn, ba),
                $a = new F(sn, Pn),
                Qa = new F(Hr, Pn),
                _n = new F(Ni / m, Ra / m),
                Xn = new F(Hn / m, Ja / m),
                Ha = t * Math.PI / 180;
              if (Ha) {
                const Xa = Math.sin(Ha),
                  Ya = Math.cos(Ha),
                  Ea = [Ya, -Xa, Xa, Ya];
                ya._matMult(Ea), Wa._matMult(Ea), Qa._matMult(Ea), $a._matMult(Ea)
              }
              const In = Ft.stretch + Ft.fixed,
                Fa = mi.stretch + mi.fixed;
              return {
                tl: ya,
                tr: Wa,
                bl: Qa,
                br: $a,
                tex: {
                  x: f.paddedRect.x + 1 + In,
                  y: f.paddedRect.y + 1 + Fa,
                  w: xi.stretch + xi.fixed - In,
                  h: si.stretch + si.fixed - Fa
                },
                writingMode: void 0,
                glyphOffset: [0, 0],
                sectionIndex: 0,
                pixelOffsetTL: _n,
                pixelOffsetBR: Xn,
                minFontScaleX: Mt / m / $r,
                minFontScaleY: Tr / m / gr,
                isSDF: r
              }
            };
          if (n && (f.stretchX || f.stretchY)) {
            const Ft = J_(C, Q, W),
              mi = J_(D, le, X);
            for (let xi = 0; xi < Ft.length - 1; xi++) {
              const si = Ft[xi],
                Hr = Ft[xi + 1];
              for (let Ni = 0; Ni < mi.length - 1; Ni++) c.push(xr(si, mi[Ni], Hr, mi[Ni + 1]))
            }
          } else c.push(xr({
            fixed: 0,
            stretch: -1
          }, {
            fixed: 0,
            stretch: -1
          }, {
            fixed: 0,
            stretch: v + 1
          }, {
            fixed: 0,
            stretch: b + 1
          }));
          return c
        }

        function Xd(i, t, r) {
          let n = 0;
          for (const c of i) n += Math.max(t, Math.min(r, c[1])) - Math.max(t, Math.min(r, c[0]));
          return n
        }

        function J_(i, t, r) {
          const n = [{
            fixed: -1,
            stretch: 0
          }];
          for (const [c, f] of i) {
            const m = n[n.length - 1];
            n.push({
              fixed: c - m.stretch,
              stretch: m.stretch
            }), n.push({
              fixed: c - m.stretch,
              stretch: m.stretch + (f - c)
            })
          }
          return n.push({
            fixed: t + 1,
            stretch: r
          }), n
        }

        function Yd(i, t, r, n) {
          return i / t * r + n
        }

        function Kd(i, t, r, n) {
          return i - t * r / n
        }
        zr("Anchor", Ro);
        class Jd {
          constructor(t, r, n, c, f, m, v, b, M, C) {
            var D;
            if (this.boxStartIndex = t.length, M) {
              let N = m.top,
                W = m.bottom;
              const X = m.collisionPadding;
              X && (N -= X[1], W += X[3]);
              let Q = W - N;
              Q > 0 && (Q = Math.max(10, Q), this.circleDiameter = Q)
            } else {
              const N = !((D = m.image) === null || D === void 0) && D.content && (m.image.textFitWidth || m.image.textFitHeight) ? S_(m) : {
                x1: m.left,
                y1: m.top,
                x2: m.right,
                y2: m.bottom
              };
              N.y1 = N.y1 * v - b[0], N.y2 = N.y2 * v + b[2], N.x1 = N.x1 * v - b[3], N.x2 = N.x2 * v + b[1];
              const W = m.collisionPadding;
              if (W && (N.x1 -= W[0] * v, N.y1 -= W[1] * v, N.x2 += W[2] * v, N.y2 += W[3] * v), C) {
                const X = new F(N.x1, N.y1),
                  Q = new F(N.x2, N.y1),
                  le = new F(N.x1, N.y2),
                  we = new F(N.x2, N.y2),
                  et = C * Math.PI / 180;
                X._rotate(et), Q._rotate(et), le._rotate(et), we._rotate(et), N.x1 = Math.min(X.x, Q.x, le.x, we.x), N.x2 = Math.max(X.x, Q.x, le.x, we.x), N.y1 = Math.min(X.y, Q.y, le.y, we.y), N.y2 = Math.max(X.y, Q.y, le.y, we.y)
              }
              t.emplaceBack(r.x, r.y, N.x1, N.y1, N.x2, N.y2, n, c, f)
            }
            this.boxEndIndex = t.length
          }
        }
        class m1 {
          constructor(t = [], r = (n, c) => n < c ? -1 : n > c ? 1 : 0) {
            if (this.data = t, this.length = this.data.length, this.compare = r, this.length > 0)
              for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n)
          }
          push(t) {
            this.data.push(t), this._up(this.length++)
          }
          pop() {
            if (this.length === 0) return;
            const t = this.data[0],
              r = this.data.pop();
            return --this.length > 0 && (this.data[0] = r, this._down(0)), t
          }
          peek() {
            return this.data[0]
          }
          _up(t) {
            const {
              data: r,
              compare: n
            } = this, c = r[t];
            for (; t > 0;) {
              const f = t - 1 >> 1,
                m = r[f];
              if (n(c, m) >= 0) break;
              r[t] = m, t = f
            }
            r[t] = c
          }
          _down(t) {
            const {
              data: r,
              compare: n
            } = this, c = this.length >> 1, f = r[t];
            for (; t < c;) {
              let m = 1 + (t << 1);
              const v = m + 1;
              if (v < this.length && n(r[v], r[m]) < 0 && (m = v), n(r[m], f) >= 0) break;
              r[t] = r[m], t = m
            }
            r[t] = f
          }
        }

        function g1(i, t = 1, r = !1) {
          const n = hl.fromPoints(i[0]),
            c = Math.min(n.width(), n.height());
          let f = c / 2;
          const m = new m1([], _1),
            {
              minX: v,
              minY: b,
              maxX: M,
              maxY: C
            } = n;
          if (c === 0) return new F(v, b);
          for (let W = v; W < M; W += c)
            for (let X = b; X < C; X += c) m.push(new mc(W + f, X + f, f, i));
          let D = (function(W) {
              let X = 0,
                Q = 0,
                le = 0;
              const we = W[0];
              for (let et = 0, De = we.length, Ze = De - 1; et < De; Ze = et++) {
                const mt = we[et],
                  Mt = we[Ze],
                  $t = mt.x * Mt.y - Mt.x * mt.y;
                Q += (mt.x + Mt.x) * $t, le += (mt.y + Mt.y) * $t, X += 3 * $t
              }
              return new mc(Q / X, le / X, 0, W)
            })(i),
            N = m.length;
          for (; m.length;) {
            const W = m.pop();
            (W.d > D.d || !D.d) && (D = W, r && console.log("found best %d after %d probes", Math.round(1e4 * W.d) / 1e4, N)), W.max - D.d <= t || (f = W.h / 2, m.push(new mc(W.p.x - f, W.p.y - f, f, i)), m.push(new mc(W.p.x + f, W.p.y - f, f, i)), m.push(new mc(W.p.x - f, W.p.y + f, f, i)), m.push(new mc(W.p.x + f, W.p.y + f, f, i)), N += 4)
          }
          return r && (console.log(`num probes: ${N}`), console.log(`best distance: ${D.d}`)), D.p
        }

        function _1(i, t) {
          return t.max - i.max
        }

        function mc(i, t, r, n) {
          this.p = new F(i, t), this.h = r, this.d = (function(c, f) {
            let m = !1,
              v = 1 / 0;
            for (let b = 0; b < f.length; b++) {
              const M = f[b];
              for (let C = 0, D = M.length, N = D - 1; C < D; N = C++) {
                const W = M[C],
                  X = M[N];
                W.y > c.y != X.y > c.y && c.x < (X.x - W.x) * (c.y - W.y) / (X.y - W.y) + W.x && (m = !m), v = Math.min(v, Rg(c, W, X))
              }
            }
            return (m ? 1 : -1) * Math.sqrt(v)
          })(this.p, n), this.max = this.d + this.h * Math.SQRT2
        }
        var nn;
        T.aI = void 0, (nn = T.aI || (T.aI = {}))[nn.center = 1] = "center", nn[nn.left = 2] = "left", nn[nn.right = 3] = "right", nn[nn.top = 4] = "top", nn[nn.bottom = 5] = "bottom", nn[nn["top-left"] = 6] = "top-left", nn[nn["top-right"] = 7] = "top-right", nn[nn["bottom-left"] = 8] = "bottom-left", nn[nn["bottom-right"] = 9] = "bottom-right";
        const jf = Number.POSITIVE_INFINITY;

        function $_(i, t) {
          return t[1] !== jf ? (function(r, n, c) {
            let f = 0,
              m = 0;
            switch (n = Math.abs(n), c = Math.abs(c), r) {
              case "top-right":
              case "top-left":
              case "top":
                m = c - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                m = 7 - c
            }
            switch (r) {
              case "top-right":
              case "bottom-right":
              case "right":
                f = -n;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                f = n
            }
            return [f, m]
          })(i, t[0], t[1]) : (function(r, n) {
            let c = 0,
              f = 0;
            n < 0 && (n = 0);
            const m = n / Math.SQRT2;
            switch (r) {
              case "top-right":
              case "top-left":
                f = m - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                f = 7 - m;
                break;
              case "bottom":
                f = 7 - n;
                break;
              case "top":
                f = n - 7
            }
            switch (r) {
              case "top-right":
              case "bottom-right":
                c = -m;
                break;
              case "top-left":
              case "bottom-left":
                c = m;
                break;
              case "left":
                c = n;
                break;
              case "right":
                c = -n
            }
            return [c, f]
          })(i, t[0])
        }

        function Q_(i, t, r) {
          var n;
          const c = i.layout,
            f = (n = c.get("text-variable-anchor-offset")) === null || n === void 0 ? void 0 : n.evaluate(t, {}, r);
          if (f) {
            const v = f.values,
              b = [];
            for (let M = 0; M < v.length; M += 2) {
              const C = b[M] = v[M],
                D = v[M + 1].map((N => N * Ga));
              C.startsWith("top") ? D[1] -= 7 : C.startsWith("bottom") && (D[1] += 7), b[M + 1] = D
            }
            return new Yi(b)
          }
          const m = c.get("text-variable-anchor");
          if (m) {
            let v;
            v = i._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [c.get("text-radial-offset").evaluate(t, {}, r) * Ga, jf] : c.get("text-offset").evaluate(t, {}, r).map((M => M * Ga));
            const b = [];
            for (const M of m) b.push(M, $_(M, v));
            return new Yi(b)
          }
          return null
        }

        function qf(i) {
          switch (i) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left"
          }
          return "center"
        }

        function v1(i, t, r, n, c, f, m, v, b, M, C, D) {
          let N = f.textMaxSize.evaluate(t, {});
          N === void 0 && (N = m);
          const W = i.layers[0].layout,
            X = W.get("icon-offset").evaluate(t, {}, C),
            Q = tv(r.horizontal),
            le = m / 24,
            we = i.tilePixelRatio * le,
            et = i.tilePixelRatio * N / 24,
            De = i.tilePixelRatio * v,
            Ze = i.tilePixelRatio * W.get("symbol-spacing"),
            mt = W.get("text-padding") * i.tilePixelRatio,
            Mt = (function(xi, si, Hr, Ni = 1) {
              const ba = xi.get("icon-padding").evaluate(si, {}, Hr),
                Ra = ba && ba.values;
              return [Ra[0] * Ni, Ra[1] * Ni, Ra[2] * Ni, Ra[3] * Ni]
            })(W, t, C, i.tilePixelRatio),
            $t = W.get("text-max-angle") / 180 * Math.PI,
            Tr = W.get("text-rotation-alignment") !== "viewport" && W.get("symbol-placement") !== "point",
            hr = W.get("icon-rotation-alignment") === "map" && W.get("symbol-placement") !== "point",
            yr = W.get("symbol-placement"),
            $r = Ze / 2,
            gr = W.get("icon-text-fit");
          let xr;
          n && gr !== "none" && (i.allowVerticalPlacement && r.vertical && (xr = P_(n, r.vertical, gr, W.get("icon-text-fit-padding"), X, le)), Q && (n = P_(n, Q, gr, W.get("icon-text-fit-padding"), X, le)));
          const Ft = C ? D.line.getGranularityForZoomLevel(C.z) : 1,
            mi = (xi, si) => {
              si.x < 0 || si.x >= nt || si.y < 0 || si.y >= nt || (function(Hr, Ni, ba, Ra, sn, Hn, Pn, Ja, ya, Wa, $a, Qa, _n, Xn, Ha, In, Fa, Xa, Ya, Ea, la, vs, gc, ys, b1) {
                const _c = Hr.addToLineVertexArray(Ni, ba);
                let dl, vc, yc, xc, nv = 0,
                  sv = 0,
                  ov = 0,
                  lv = 0,
                  Xf = -1,
                  Yf = -1;
                const ao = {};
                let cv = ms("");
                if (Hr.allowVerticalPlacement && Ra.vertical) {
                  const hn = Ja.layout.get("text-rotate").evaluate(la, {}, ys) + 90;
                  yc = new Jd(ya, Ni, Wa, $a, Qa, Ra.vertical, _n, Xn, Ha, hn), Pn && (xc = new Jd(ya, Ni, Wa, $a, Qa, Pn, Fa, Xa, Ha, hn))
                }
                if (sn) {
                  const hn = Ja.layout.get("icon-rotate").evaluate(la, {}),
                    Yn = Ja.layout.get("icon-text-fit") !== "none",
                    pl = K_(sn, hn, gc, Yn),
                    bs = Pn ? K_(Pn, hn, gc, Yn) : void 0;
                  vc = new Jd(ya, Ni, Wa, $a, Qa, sn, Fa, Xa, !1, hn), nv = 4 * pl.length;
                  const fl = Hr.iconSizeData;
                  let zs = null;
                  fl.kind === "source" ? (zs = [io * Ja.layout.get("icon-size").evaluate(la, {})], zs[0] > Lo && St(`${Hr.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : fl.kind === "composite" && (zs = [io * vs.compositeIconSizes[0].evaluate(la, {}, ys), io * vs.compositeIconSizes[1].evaluate(la, {}, ys)], (zs[0] > Lo || zs[1] > Lo) && St(`${Hr.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), Hr.addSymbols(Hr.icon, pl, zs, Ea, Ya, la, T.as.none, Ni, _c.lineStartIndex, _c.lineLength, -1, ys), Xf = Hr.icon.placedSymbolArray.length - 1, bs && (sv = 4 * bs.length, Hr.addSymbols(Hr.icon, bs, zs, Ea, Ya, la, T.as.vertical, Ni, _c.lineStartIndex, _c.lineLength, -1, ys), Yf = Hr.icon.placedSymbolArray.length - 1)
                }
                const uv = Object.keys(Ra.horizontal);
                for (const hn of uv) {
                  const Yn = Ra.horizontal[hn];
                  if (!dl) {
                    cv = ms(Yn.text);
                    const bs = Ja.layout.get("text-rotate").evaluate(la, {}, ys);
                    dl = new Jd(ya, Ni, Wa, $a, Qa, Yn, _n, Xn, Ha, bs)
                  }
                  const pl = Yn.positionedLines.length === 1;
                  if (ov += ev(Hr, Ni, Yn, Hn, Ja, Ha, la, In, _c, Ra.vertical ? T.as.horizontal : T.as.horizontalOnly, pl ? uv : [hn], ao, Xf, vs, ys), pl) break
                }
                Ra.vertical && (lv += ev(Hr, Ni, Ra.vertical, Hn, Ja, Ha, la, In, _c, T.as.vertical, ["vertical"], ao, Yf, vs, ys));
                const w1 = dl ? dl.boxStartIndex : Hr.collisionBoxArray.length,
                  T1 = dl ? dl.boxEndIndex : Hr.collisionBoxArray.length,
                  S1 = yc ? yc.boxStartIndex : Hr.collisionBoxArray.length,
                  P1 = yc ? yc.boxEndIndex : Hr.collisionBoxArray.length,
                  I1 = vc ? vc.boxStartIndex : Hr.collisionBoxArray.length,
                  M1 = vc ? vc.boxEndIndex : Hr.collisionBoxArray.length,
                  C1 = xc ? xc.boxStartIndex : Hr.collisionBoxArray.length,
                  A1 = xc ? xc.boxEndIndex : Hr.collisionBoxArray.length;
                let xs = -1;
                const Qd = (hn, Yn) => hn && hn.circleDiameter ? Math.max(hn.circleDiameter, Yn) : Yn;
                xs = Qd(dl, xs), xs = Qd(yc, xs), xs = Qd(vc, xs), xs = Qd(xc, xs);
                const hv = xs > -1 ? 1 : 0;
                hv && (xs *= b1 / Ga), Hr.glyphOffsetArray.length >= pc.MAX_GLYPHS && St("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), la.sortKey !== void 0 && Hr.addToSortKeyRanges(Hr.symbolInstances.length, la.sortKey);
                const k1 = Q_(Ja, la, ys),
                  [z1, E1] = (function(hn, Yn) {
                    const pl = hn.length,
                      bs = Yn == null ? void 0 : Yn.values;
                    if ((bs == null ? void 0 : bs.length) > 0)
                      for (let fl = 0; fl < bs.length; fl += 2) {
                        const zs = bs[fl + 1];
                        hn.emplaceBack(T.aI[bs[fl]], zs[0], zs[1])
                      }
                    return [pl, hn.length]
                  })(Hr.textAnchorOffsets, k1);
                Hr.symbolInstances.emplaceBack(Ni.x, Ni.y, ao.right >= 0 ? ao.right : -1, ao.center >= 0 ? ao.center : -1, ao.left >= 0 ? ao.left : -1, ao.vertical || -1, Xf, Yf, cv, w1, T1, S1, P1, I1, M1, C1, A1, Wa, ov, lv, nv, sv, hv, 0, _n, xs, z1, E1)
              })(i, si, xi, r, n, c, xr, i.layers[0], i.collisionBoxArray, t.index, t.sourceLayerIndex, i.index, we, [mt, mt, mt, mt], Tr, b, De, Mt, hr, X, t, f, M, C, m)
            };
          if (yr === "line")
            for (const xi of Z_(t.geometry, 0, 0, nt, nt)) {
              const si = ul(xi, Ft),
                Hr = f1(si, Ze, $t, r.vertical || Q, n, 24, et, i.overscaling, nt);
              for (const Ni of Hr) Q && y1(i, Q.text, $r, Ni) || mi(si, Ni)
            } else if (yr === "line-center") {
              for (const xi of t.geometry)
                if (xi.length > 1) {
                  const si = ul(xi, Ft),
                    Hr = p1(si, $t, r.vertical || Q, n, 24, et);
                  Hr && mi(si, Hr)
                }
            } else if (t.type === "Polygon")
            for (const xi of Al(t.geometry, 0)) {
              const si = g1(xi, 16);
              mi(ul(xi[0], Ft, !0), new Ro(si.x, si.y, 0))
            } else if (t.type === "LineString")
              for (const xi of t.geometry) {
                const si = ul(xi, Ft);
                mi(si, new Ro(si[0].x, si[0].y, 0))
              } else if (t.type === "Point")
                for (const xi of t.geometry)
                  for (const si of xi) mi([si], new Ro(si.x, si.y, 0))
        }

        function ev(i, t, r, n, c, f, m, v, b, M, C, D, N, W, X) {
          const Q = (function(et, De, Ze, mt, Mt, $t, Tr, hr) {
              const yr = mt.layout.get("text-rotate").evaluate($t, {}) * Math.PI / 180,
                $r = [];
              for (const gr of De.positionedLines)
                for (const xr of gr.positionedGlyphs) {
                  if (!xr.rect) continue;
                  const Ft = xr.rect || {};
                  let mi = 4,
                    xi = !0,
                    si = 1,
                    Hr = 0;
                  const Ni = (Mt || hr) && xr.vertical,
                    ba = xr.metrics.advance * xr.scale / 2;
                  if (hr && De.verticalizable && (Hr = gr.lineOffset / 2 - (xr.imageName ? -(Ga - xr.metrics.width * xr.scale) / 2 : (xr.scale - 1) * Ga)), xr.imageName) {
                    const Xa = Tr[xr.imageName];
                    xi = Xa.sdf, si = Xa.pixelRatio, mi = 1 / si
                  }
                  const Ra = Mt ? [xr.x + ba, xr.y] : [0, 0];
                  let sn = Mt ? [0, 0] : [xr.x + ba + Ze[0], xr.y + Ze[1] - Hr],
                    Hn = [0, 0];
                  Ni && (Hn = sn, sn = [0, 0]);
                  const Pn = xr.metrics.isDoubleResolution ? 2 : 1,
                    Ja = (xr.metrics.left - mi) * xr.scale - ba + sn[0],
                    ya = (-xr.metrics.top - mi) * xr.scale + sn[1],
                    Wa = Ja + Ft.w / Pn * xr.scale / si,
                    $a = ya + Ft.h / Pn * xr.scale / si,
                    Qa = new F(Ja, ya),
                    _n = new F(Wa, ya),
                    Xn = new F(Ja, $a),
                    Ha = new F(Wa, $a);
                  if (Ni) {
                    const Xa = new F(-ba, ba - -17),
                      Ya = -Math.PI / 2,
                      Ea = 12 - ba,
                      la = new F(22 - Ea, -(xr.imageName ? Ea : 0)),
                      vs = new F(...Hn);
                    Qa._rotateAround(Ya, Xa)._add(la)._add(vs), _n._rotateAround(Ya, Xa)._add(la)._add(vs), Xn._rotateAround(Ya, Xa)._add(la)._add(vs), Ha._rotateAround(Ya, Xa)._add(la)._add(vs)
                  }
                  if (yr) {
                    const Xa = Math.sin(yr),
                      Ya = Math.cos(yr),
                      Ea = [Ya, -Xa, Xa, Ya];
                    Qa._matMult(Ea), _n._matMult(Ea), Xn._matMult(Ea), Ha._matMult(Ea)
                  }
                  const In = new F(0, 0),
                    Fa = new F(0, 0);
                  $r.push({
                    tl: Qa,
                    tr: _n,
                    bl: Xn,
                    br: Ha,
                    tex: Ft,
                    writingMode: De.writingMode,
                    glyphOffset: Ra,
                    sectionIndex: xr.sectionIndex,
                    isSDF: xi,
                    pixelOffsetTL: In,
                    pixelOffsetBR: Fa,
                    minFontScaleX: 0,
                    minFontScaleY: 0
                  })
                }
              return $r
            })(0, r, v, c, f, m, n, i.allowVerticalPlacement),
            le = i.textSizeData;
          let we = null;
          le.kind === "source" ? (we = [io * c.layout.get("text-size").evaluate(m, {})], we[0] > Lo && St(`${i.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : le.kind === "composite" && (we = [io * W.compositeTextSizes[0].evaluate(m, {}, X), io * W.compositeTextSizes[1].evaluate(m, {}, X)], (we[0] > Lo || we[1] > Lo) && St(`${i.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), i.addSymbols(i.text, Q, we, v, f, m, M, t, b.lineStartIndex, b.lineLength, N, X);
          for (const et of C) D[et] = i.text.placedSymbolArray.length - 1;
          return 4 * Q.length
        }

        function tv(i) {
          for (const t in i) return i[t];
          return null
        }

        function y1(i, t, r, n) {
          const c = i.compareText;
          if (t in c) {
            const f = c[t];
            for (let m = f.length - 1; m >= 0; m--)
              if (n.dist(f[m]) < r) return !0
          } else c[t] = [];
          return c[t].push(n), !1
        }
        const rv = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class Nf {
          static from(t) {
            if (!(t instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [r, n] = new Uint8Array(t, 0, 2);
            if (r !== 219) throw new Error("Data does not appear to be in a KDBush format.");
            const c = n >> 4;
            if (c !== 1) throw new Error(`Got v${c} data when expected v1.`);
            const f = rv[15 & n];
            if (!f) throw new Error("Unrecognized array type.");
            const [m] = new Uint16Array(t, 2, 1), [v] = new Uint32Array(t, 4, 1);
            return new Nf(v, m, f, t)
          }
          constructor(t, r = 64, n = Float64Array, c) {
            if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
            this.numItems = +t, this.nodeSize = Math.min(Math.max(+r, 2), 65535), this.ArrayType = n, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
            const f = rv.indexOf(this.ArrayType),
              m = 2 * t * this.ArrayType.BYTES_PER_ELEMENT,
              v = t * this.IndexArrayType.BYTES_PER_ELEMENT,
              b = (8 - v % 8) % 8;
            if (f < 0) throw new Error(`Unexpected typed array class: ${n}.`);
            c && c instanceof ArrayBuffer ? (this.data = c, this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + v + b, 2 * t), this._pos = 2 * t, this._finished = !0) : (this.data = new ArrayBuffer(8 + m + v + b), this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + v + b, 2 * t), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + f]), new Uint16Array(this.data, 2, 1)[0] = r, new Uint32Array(this.data, 4, 1)[0] = t)
          }
          add(t, r) {
            const n = this._pos >> 1;
            return this.ids[n] = n, this.coords[this._pos++] = t, this.coords[this._pos++] = r, n
          }
          finish() {
            const t = this._pos >> 1;
            if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`);
            return Vf(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this
          }
          range(t, r, n, c) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const {
              ids: f,
              coords: m,
              nodeSize: v
            } = this, b = [0, f.length - 1, 0], M = [];
            for (; b.length;) {
              const C = b.pop() || 0,
                D = b.pop() || 0,
                N = b.pop() || 0;
              if (D - N <= v) {
                for (let le = N; le <= D; le++) {
                  const we = m[2 * le],
                    et = m[2 * le + 1];
                  we >= t && we <= n && et >= r && et <= c && M.push(f[le])
                }
                continue
              }
              const W = N + D >> 1,
                X = m[2 * W],
                Q = m[2 * W + 1];
              X >= t && X <= n && Q >= r && Q <= c && M.push(f[W]), (C === 0 ? t <= X : r <= Q) && (b.push(N), b.push(W - 1), b.push(1 - C)), (C === 0 ? n >= X : c >= Q) && (b.push(W + 1), b.push(D), b.push(1 - C))
            }
            return M
          }
          within(t, r, n) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const {
              ids: c,
              coords: f,
              nodeSize: m
            } = this, v = [0, c.length - 1, 0], b = [], M = n * n;
            for (; v.length;) {
              const C = v.pop() || 0,
                D = v.pop() || 0,
                N = v.pop() || 0;
              if (D - N <= m) {
                for (let le = N; le <= D; le++) av(f[2 * le], f[2 * le + 1], t, r) <= M && b.push(c[le]);
                continue
              }
              const W = N + D >> 1,
                X = f[2 * W],
                Q = f[2 * W + 1];
              av(X, Q, t, r) <= M && b.push(c[W]), (C === 0 ? t - n <= X : r - n <= Q) && (v.push(N), v.push(W - 1), v.push(1 - C)), (C === 0 ? t + n >= X : r + n >= Q) && (v.push(W + 1), v.push(D), v.push(1 - C))
            }
            return b
          }
        }

        function Vf(i, t, r, n, c, f) {
          if (c - n <= r) return;
          const m = n + c >> 1;
          iv(i, t, m, n, c, f), Vf(i, t, r, n, m - 1, 1 - f), Vf(i, t, r, m + 1, c, 1 - f)
        }

        function iv(i, t, r, n, c, f) {
          for (; c > n;) {
            if (c - n > 600) {
              const M = c - n + 1,
                C = r - n + 1,
                D = Math.log(M),
                N = .5 * Math.exp(2 * D / 3),
                W = .5 * Math.sqrt(D * N * (M - N) / M) * (C - M / 2 < 0 ? -1 : 1);
              iv(i, t, r, Math.max(n, Math.floor(r - C * N / M + W)), Math.min(c, Math.floor(r + (M - C) * N / M + W)), f)
            }
            const m = t[2 * r + f];
            let v = n,
              b = c;
            for (Uu(i, t, n, r), t[2 * c + f] > m && Uu(i, t, n, c); v < b;) {
              for (Uu(i, t, v, b), v++, b--; t[2 * v + f] < m;) v++;
              for (; t[2 * b + f] > m;) b--
            }
            t[2 * n + f] === m ? Uu(i, t, n, b) : (b++, Uu(i, t, b, c)), b <= r && (n = b + 1), r <= b && (c = b - 1)
          }
        }

        function Uu(i, t, r, n) {
          Uf(i, r, n), Uf(t, 2 * r, 2 * n), Uf(t, 2 * r + 1, 2 * n + 1)
        }

        function Uf(i, t, r) {
          const n = i[t];
          i[t] = i[r], i[r] = n
        }

        function av(i, t, r, n) {
          const c = i - r,
            f = t - n;
          return c * c + f * f
        }
        var Zf;
        T.cA = void 0, (Zf = T.cA || (T.cA = {})).create = "create", Zf.load = "load", Zf.fullLoad = "fullLoad";
        let $d = null,
          Zu = [];
        const Gf = 1e3 / 60,
          Wf = "loadTime",
          Hf = "fullLoadTime",
          x1 = {
            mark(i) {
              performance.mark(i)
            },
            frame(i) {
              const t = i;
              $d != null && Zu.push(t - $d), $d = t
            },
            clearMetrics() {
              $d = null, Zu = [], performance.clearMeasures(Wf), performance.clearMeasures(Hf);
              for (const i in T.cA) performance.clearMarks(T.cA[i])
            },
            getPerformanceMetrics() {
              performance.measure(Wf, T.cA.create, T.cA.load), performance.measure(Hf, T.cA.create, T.cA.fullLoad);
              const i = performance.getEntriesByName(Wf)[0].duration,
                t = performance.getEntriesByName(Hf)[0].duration,
                r = Zu.length,
                n = 1 / (Zu.reduce(((f, m) => f + m), 0) / r / 1e3),
                c = Zu.filter((f => f > Gf)).reduce(((f, m) => f + (m - Gf) / Gf), 0);
              return {
                loadTime: i,
                fullLoadTime: t,
                fps: n,
                percentDroppedFrames: c / (r + c) * 100,
                totalFrames: r
              }
            }
          };
        T.$ = _r, T.A = xe, T.B = Mo, T.C = function([i, t, r]) {
          return t += 90, t *= Math.PI / 180, r *= Math.PI / 180, {
            x: i * Math.cos(t) * Math.sin(r),
            y: i * Math.sin(t) * Math.sin(r),
            z: i * Math.cos(r)
          }
        }, T.D = Xr, T.E = ie, T.F = En, T.G = ta, T.H = rl, T.I = Af, T.J = Rt, T.K = class {
          constructor(i, t) {
            this.target = i, this.mapId = t, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new u1((() => this.process())), this.subscription = sr(this.target, "message", (r => this.receive(r)), !1), this.globalScope = Ut(self) ? i : window
          }
          registerMessageHandler(i, t) {
            this.messageHandlers[i] = t
          }
          sendAsync(i, t) {
            return new Promise(((r, n) => {
              const c = Math.round(1e18 * Math.random()).toString(36).substring(0, 10),
                f = t ? sr(t.signal, "abort", (() => {
                  f == null || f.unsubscribe(), delete this.resolveRejects[c];
                  const b = {
                    id: c,
                    type: "<cancel>",
                    origin: location.origin,
                    targetMapId: i.targetMapId,
                    sourceMapId: this.mapId
                  };
                  this.target.postMessage(b)
                }), h1) : null;
              this.resolveRejects[c] = {
                resolve: b => {
                  f == null || f.unsubscribe(), r(b)
                },
                reject: b => {
                  f == null || f.unsubscribe(), n(b)
                }
              };
              const m = [],
                v = Object.assign(Object.assign({}, i), {
                  id: c,
                  sourceMapId: this.mapId,
                  origin: location.origin,
                  data: ds(i.data, m)
                });
              this.target.postMessage(v, {
                transfer: m
              })
            }))
          }
          receive(i) {
            const t = i.data,
              r = t.id;
            if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== "resource://android" && location.origin !== "resource://android" && t.origin !== location.origin || t.targetMapId && this.mapId !== t.targetMapId)) {
              if (t.type === "<cancel>") {
                delete this.tasks[r];
                const n = this.abortControllers[r];
                return delete this.abortControllers[r], void(n && n.abort())
              }
              if (Ut(self) || t.mustQueue) return this.tasks[r] = t, this.taskQueue.push(r), void this.invoker.trigger();
              this.processTask(r, t)
            }
          }
          process() {
            if (this.taskQueue.length === 0) return;
            const i = this.taskQueue.shift(),
              t = this.tasks[i];
            delete this.tasks[i], this.taskQueue.length > 0 && this.invoker.trigger(), t && this.processTask(i, t)
          }
          processTask(i, t) {
            return s(this, void 0, void 0, (function*() {
              if (t.type === "<response>") {
                const c = this.resolveRejects[i];
                return delete this.resolveRejects[i], c ? void(t.error ? c.reject(il(t.error)) : c.resolve(il(t.data))) : void 0
              }
              if (!this.messageHandlers[t.type]) return void this.completeTask(i, new Error(`Could not find a registered handler for ${t.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const r = il(t.data),
                n = new AbortController;
              this.abortControllers[i] = n;
              try {
                const c = yield this.messageHandlers[t.type](t.sourceMapId, r, n);
                this.completeTask(i, null, c)
              } catch (c) {
                this.completeTask(i, c)
              }
            }))
          }
          completeTask(i, t, r) {
            const n = [];
            delete this.abortControllers[i];
            const c = {
              id: i,
              type: "<response>",
              sourceMapId: this.mapId,
              origin: location.origin,
              error: t ? ds(t) : null,
              data: ds(r, n)
            };
            this.target.postMessage(c, {
              transfer: n
            })
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe()
          }
        }, T.L = J, T.M = function() {
          var i = new xe(16);
          return xe != Float32Array && (i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0), i[0] = 1, i[5] = 1, i[10] = 1, i[15] = 1, i
        }, T.N = function(i, t, r) {
          var n, c, f, m, v, b, M, C, D, N, W, X, Q = r[0],
            le = r[1],
            we = r[2];
          return t === i ? (i[12] = t[0] * Q + t[4] * le + t[8] * we + t[12], i[13] = t[1] * Q + t[5] * le + t[9] * we + t[13], i[14] = t[2] * Q + t[6] * le + t[10] * we + t[14], i[15] = t[3] * Q + t[7] * le + t[11] * we + t[15]) : (c = t[1], f = t[2], m = t[3], v = t[4], b = t[5], M = t[6], C = t[7], D = t[8], N = t[9], W = t[10], X = t[11], i[0] = n = t[0], i[1] = c, i[2] = f, i[3] = m, i[4] = v, i[5] = b, i[6] = M, i[7] = C, i[8] = D, i[9] = N, i[10] = W, i[11] = X, i[12] = n * Q + v * le + D * we + t[12], i[13] = c * Q + b * le + N * we + t[13], i[14] = f * Q + M * le + W * we + t[14], i[15] = m * Q + C * le + X * we + t[15]), i
        }, T.O = function(i, t, r) {
          var n = r[0],
            c = r[1],
            f = r[2];
          return i[0] = t[0] * n, i[1] = t[1] * n, i[2] = t[2] * n, i[3] = t[3] * n, i[4] = t[4] * c, i[5] = t[5] * c, i[6] = t[6] * c, i[7] = t[7] * c, i[8] = t[8] * f, i[9] = t[9] * f, i[10] = t[10] * f, i[11] = t[11] * f, i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15], i
        }, T.P = F, T.Q = function(i, t, r) {
          var n = t[0],
            c = t[1],
            f = t[2],
            m = t[3],
            v = t[4],
            b = t[5],
            M = t[6],
            C = t[7],
            D = t[8],
            N = t[9],
            W = t[10],
            X = t[11],
            Q = t[12],
            le = t[13],
            we = t[14],
            et = t[15],
            De = r[0],
            Ze = r[1],
            mt = r[2],
            Mt = r[3];
          return i[0] = De * n + Ze * v + mt * D + Mt * Q, i[1] = De * c + Ze * b + mt * N + Mt * le, i[2] = De * f + Ze * M + mt * W + Mt * we, i[3] = De * m + Ze * C + mt * X + Mt * et, i[4] = (De = r[4]) * n + (Ze = r[5]) * v + (mt = r[6]) * D + (Mt = r[7]) * Q, i[5] = De * c + Ze * b + mt * N + Mt * le, i[6] = De * f + Ze * M + mt * W + Mt * we, i[7] = De * m + Ze * C + mt * X + Mt * et, i[8] = (De = r[8]) * n + (Ze = r[9]) * v + (mt = r[10]) * D + (Mt = r[11]) * Q, i[9] = De * c + Ze * b + mt * N + Mt * le, i[10] = De * f + Ze * M + mt * W + Mt * we, i[11] = De * m + Ze * C + mt * X + Mt * et, i[12] = (De = r[12]) * n + (Ze = r[13]) * v + (mt = r[14]) * D + (Mt = r[15]) * Q, i[13] = De * c + Ze * b + mt * N + Mt * le, i[14] = De * f + Ze * M + mt * W + Mt * we, i[15] = De * m + Ze * C + mt * X + Mt * et, i
        }, T.R = Sn, T.S = function(i, t) {
          const r = {};
          for (let n = 0; n < t.length; n++) {
            const c = t[n];
            c in i && (r[c] = i[c])
          }
          return r
        }, T.T = yf, T.U = Do, T.V = lt, T.W = D_, T.X = L_, T.Y = ye, T.Z = be, T._ = s, T.a = V, T.a$ = function(i, t, r) {
          return i[0] = t[0] * r[0], i[1] = t[1] * r[1], i[2] = t[2] * r[2], i[3] = t[3] * r[3], i
        }, T.a0 = Wn, T.a1 = F_, T.a2 = Hd, T.a3 = nt, T.a4 = function(i, t) {
          var r, n, c, f, m;
          if (!i) return t ?? {};
          if (!t) return i;
          let v = Object.assign({}, i);
          if (t.removeAll && (v = {
              removeAll: !0
            }), t.remove) {
            const b = new Set(t.remove);
            v.add && (v.add = v.add.filter((C => !b.has(C.id)))), v.update && (v.update = v.update.filter((C => !b.has(C.id))));
            const M = new Set(((r = i.add) !== null && r !== void 0 ? r : []).map((C => C.id)));
            t.remove = t.remove.filter((C => !M.has(C)))
          }
          if (t.remove) {
            const b = new Set(v.remove ? v.remove.concat(t.remove) : t.remove);
            v.remove = Array.from(b.values())
          }
          if (t.add) {
            const b = v.add ? v.add.concat(t.add) : t.add,
              M = new Map(b.map((C => [C.id, C])));
            v.add = Array.from(M.values())
          }
          if (t.update) {
            const b = new Map((n = v.update) === null || n === void 0 ? void 0 : n.map((M => [M.id, M])));
            for (const M of t.update) {
              const C = (c = b.get(M.id)) !== null && c !== void 0 ? c : {
                id: M.id
              };
              M.newGeometry && (C.newGeometry = M.newGeometry), M.addOrUpdateProperties && (C.addOrUpdateProperties = ((f = C.addOrUpdateProperties) !== null && f !== void 0 ? f : []).concat(M.addOrUpdateProperties)), M.removeProperties && (C.removeProperties = ((m = C.removeProperties) !== null && m !== void 0 ? m : []).concat(M.removeProperties)), M.removeAllProperties && (C.removeAllProperties = !0), b.set(M.id, C)
            }
            v.update = Array.from(b.values())
          }
          return v.remove && v.add && (v.remove = v.remove.filter((b => v.add.findIndex((M => M.id === b)) === -1))), v
        }, T.a5 = Nu, T.a6 = hl, T.a7 = 25, T.a8 = Of, T.a9 = i => {
          const t = window.document.createElement("video");
          return t.muted = !0, new Promise((r => {
            t.onloadstart = () => {
              r(t)
            };
            for (const n of i) {
              const c = window.document.createElement("source");
              Re(n) || (t.crossOrigin = "Anonymous"), c.src = n, t.appendChild(c)
            }
          }))
        }, T.aA = je, T.aB = function(i, t, r, n) {
          const c = t.y - i.y,
            f = t.x - i.x,
            m = n.y - r.y,
            v = n.x - r.x,
            b = m * f - v * c;
          if (b === 0) return null;
          const M = (v * (i.y - r.y) - m * (i.x - r.x)) / b;
          return new F(i.x + M * f, i.y + M * c)
        }, T.aC = Z_, T.aD = Lg, T.aE = function(i) {
          let t = 1 / 0,
            r = 1 / 0,
            n = -1 / 0,
            c = -1 / 0;
          for (const f of i) t = Math.min(t, f.x), r = Math.min(r, f.y), n = Math.max(n, f.x), c = Math.max(c, f.y);
          return [t, r, n, c]
        }, T.aF = Ga, T.aG = ot, T.aH = function(i, t, r, n, c = !1) {
          if (!r[0] && !r[1]) return [0, 0];
          const f = c ? n === "map" ? -i.bearingInRadians : 0 : n === "viewport" ? i.bearingInRadians : 0;
          if (f) {
            const m = Math.sin(f),
              v = Math.cos(f);
            r = [r[0] * v - r[1] * m, r[0] * m + r[1] * v]
          }
          return [c ? r[0] : ot(t, r[0], i.zoom), c ? r[1] : ot(t, r[1], i.zoom)]
        }, T.aJ = Ef, T.aK = qf, T.aL = zf, T.aM = Nf, T.aN = wa, T.aO = Nd, T.aP = Ce, T.aQ = Li, T.aR = Nt, T.aS = vr, T.aT = B_, T.aU = Me, T.aV = Ae, T.aW = function(i) {
          var t = new xe(3);
          return t[0] = i[0], t[1] = i[1], t[2] = i[2], t
        }, T.aX = function(i, t, r) {
          return i[0] = t[0] - r[0], i[1] = t[1] - r[1], i[2] = t[2] - r[2], i
        }, T.aY = function(i, t) {
          var r = t[0],
            n = t[1],
            c = t[2],
            f = r * r + n * n + c * c;
          return f > 0 && (f = 1 / Math.sqrt(f)), i[0] = t[0] * f, i[1] = t[1] * f, i[2] = t[2] * f, i
        }, T.aZ = Ee, T.a_ = function(i, t) {
          return i[0] * t[0] + i[1] * t[1] + i[2] * t[2]
        }, T.aa = Ke, T.ab = function() {
          return Dt++
        }, T.ac = w, T.ad = pc, T.ae = $o, T.af = ks, T.ag = N_, T.ah = function(i) {
          const t = {};
          if (i.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((r, n, c, f) => {
              const m = c || f;
              return t[n] = !m || m.toLowerCase(), ""
            })), t["max-age"]) {
            const r = parseInt(t["max-age"], 10);
            isNaN(r) ? delete t["max-age"] : t["max-age"] = r
          }
          return t
        }, T.ai = Zt, T.aj = 85.051129, T.ak = Kt, T.al = function(i) {
          return Math.pow(2, i)
        }, T.am = We, T.an = R_, T.ao = function(i) {
          return Math.log(i) / Math.LN2
        }, T.ap = function(i) {
          var t = i[0],
            r = i[1];
          return t * t + r * r
        }, T.aq = function(i) {
          if (!i.length) return new Set;
          const t = Math.max(...i.map((b => b.canonical.z)));
          let r = 1 / 0,
            n = -1 / 0,
            c = 1 / 0,
            f = -1 / 0;
          const m = [];
          for (const b of i) {
            const {
              x: M,
              y: C,
              z: D
            } = b.canonical, N = Math.pow(2, t - D), W = M * N, X = C * N;
            m.push({
              id: b,
              x: W,
              y: X
            }), W < r && (r = W), W > n && (n = W), X < c && (c = X), X > f && (f = X)
          }
          const v = new Set;
          for (const b of m) b.x !== r && b.x !== n && b.y !== c && b.y !== f || v.add(b.id);
          return v
        }, T.ar = function(i, t) {
          let r = 0,
            n = 0;
          if (i.kind === "constant") n = i.layoutSize;
          else if (i.kind !== "source") {
            const {
              interpolationType: c,
              minZoom: f,
              maxZoom: m
            } = i, v = c ? Zt(Ki.interpolationFactor(c, t, f, m), 0, 1) : 0;
            i.kind === "camera" ? n = En.number(i.minSize, i.maxSize, v) : r = v
          }
          return {
            uSizeT: r,
            uSize: n
          }
        }, T.at = function(i, {
          uSize: t,
          uSizeT: r
        }, {
          lowerSize: n,
          upperSize: c
        }) {
          return i.kind === "source" ? n / io : i.kind === "composite" ? En.number(n / io, c / io, r) : t
        }, T.au = function(i, t) {
          var r = t[0],
            n = t[1],
            c = t[2],
            f = t[3],
            m = t[4],
            v = t[5],
            b = t[6],
            M = t[7],
            C = t[8],
            D = t[9],
            N = t[10],
            W = t[11],
            X = t[12],
            Q = t[13],
            le = t[14],
            we = t[15],
            et = r * v - n * m,
            De = r * b - c * m,
            Ze = r * M - f * m,
            mt = n * b - c * v,
            Mt = n * M - f * v,
            $t = c * M - f * b,
            Tr = C * Q - D * X,
            hr = C * le - N * X,
            yr = C * we - W * X,
            $r = D * le - N * Q,
            gr = D * we - W * Q,
            xr = N * we - W * le,
            Ft = et * xr - De * gr + Ze * $r + mt * yr - Mt * hr + $t * Tr;
          return Ft ? (i[0] = (v * xr - b * gr + M * $r) * (Ft = 1 / Ft), i[1] = (c * gr - n * xr - f * $r) * Ft, i[2] = (Q * $t - le * Mt + we * mt) * Ft, i[3] = (N * Mt - D * $t - W * mt) * Ft, i[4] = (b * yr - m * xr - M * hr) * Ft, i[5] = (r * xr - c * yr + f * hr) * Ft, i[6] = (le * Ze - X * $t - we * De) * Ft, i[7] = (C * $t - N * Ze + W * De) * Ft, i[8] = (m * gr - v * yr + M * Tr) * Ft, i[9] = (n * yr - r * gr - f * Tr) * Ft, i[10] = (X * Mt - Q * Ze + we * et) * Ft, i[11] = (D * Ze - C * Mt - W * et) * Ft, i[12] = (v * hr - m * $r - b * Tr) * Ft, i[13] = (r * $r - n * hr + c * Tr) * Ft, i[14] = (Q * De - X * mt - le * et) * Ft, i[15] = (C * mt - D * De + N * et) * Ft, i) : null
        }, T.av = dt, T.aw = function(i) {
          var t = i[0],
            r = i[1];
          return Math.sqrt(t * t + r * r)
        }, T.ax = function(i) {
          return i[0] = 0, i[1] = 0, i
        }, T.ay = function(i, t, r) {
          return i[0] = t[0] * r, i[1] = t[1] * r, i
        }, T.az = Lf, T.b = ir, T.b$ = function(i, t, r) {
          var n = t[0],
            c = t[1],
            f = t[2];
          return i[0] = n * r[0] + c * r[3] + f * r[6], i[1] = n * r[1] + c * r[4] + f * r[7], i[2] = n * r[2] + c * r[5] + f * r[8], i
        }, T.b0 = Se, T.b1 = function(i, t, r) {
          const n = t[0] * r[0] + t[1] * r[1] + t[2] * r[2];
          return n === 0 ? null : (-(i[0] * r[0] + i[1] * r[1] + i[2] * r[2]) - r[3]) / n
        }, T.b2 = Ue, T.b3 = function(i, t, r) {
          return i[0] = t[0] * r, i[1] = t[1] * r, i[2] = t[2] * r, i[3] = t[3] * r, i
        }, T.b4 = function(i, t) {
          return i[0] * t[0] + i[1] * t[1] + i[2] * t[2] + i[3]
        }, T.b5 = j_, T.b6 = fc, T.b7 = function(i, t, r, n, c) {
          var f = 1 / Math.tan(t / 2);
          if (i[0] = f / r, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = f, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = -1, i[12] = 0, i[13] = 0, i[15] = 0, c != null && c !== 1 / 0) {
            var m = 1 / (n - c);
            i[10] = (c + n) * m, i[14] = 2 * c * n * m
          } else i[10] = -1, i[14] = -2 * n;
          return i
        }, T.b8 = function(i) {
          var t = new xe(16);
          return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], t
        }, T.b9 = function(i, t, r) {
          var n = Math.sin(r),
            c = Math.cos(r),
            f = t[0],
            m = t[1],
            v = t[2],
            b = t[3],
            M = t[4],
            C = t[5],
            D = t[6],
            N = t[7];
          return t !== i && (i[8] = t[8], i[9] = t[9], i[10] = t[10], i[11] = t[11], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[0] = f * c + M * n, i[1] = m * c + C * n, i[2] = v * c + D * n, i[3] = b * c + N * n, i[4] = M * c - f * n, i[5] = C * c - m * n, i[6] = D * c - v * n, i[7] = N * c - b * n, i
        }, T.bA = function(i, t, r, n) {
          var c = [],
            f = [];
          return c[0] = t[0] - r[0], c[1] = t[1] - r[1], c[2] = t[2] - r[2], f[0] = c[0], f[1] = c[1] * Math.cos(n) - c[2] * Math.sin(n), f[2] = c[1] * Math.sin(n) + c[2] * Math.cos(n), i[0] = f[0] + r[0], i[1] = f[1] + r[1], i[2] = f[2] + r[2], i
        }, T.bB = function(i, t, r, n) {
          var c = [],
            f = [];
          return c[0] = t[0] - r[0], c[1] = t[1] - r[1], c[2] = t[2] - r[2], f[0] = c[2] * Math.sin(n) + c[0] * Math.cos(n), f[1] = c[1], f[2] = c[2] * Math.cos(n) - c[0] * Math.sin(n), i[0] = f[0] + r[0], i[1] = f[1] + r[1], i[2] = f[2] + r[2], i
        }, T.bC = function(i, t, r) {
          var n = Math.sin(r),
            c = Math.cos(r),
            f = t[0],
            m = t[1],
            v = t[2],
            b = t[3],
            M = t[8],
            C = t[9],
            D = t[10],
            N = t[11];
          return t !== i && (i[4] = t[4], i[5] = t[5], i[6] = t[6], i[7] = t[7], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[0] = f * c - M * n, i[1] = m * c - C * n, i[2] = v * c - D * n, i[3] = b * c - N * n, i[8] = f * n + M * c, i[9] = m * n + C * c, i[10] = v * n + D * c, i[11] = b * n + N * c, i
        }, T.bD = function(i, t) {
          const r = ut(i, 360),
            n = ut(t, 360),
            c = n - r,
            f = n > r ? c - 360 : c + 360;
          return Math.abs(c) < Math.abs(f) ? c : f
        }, T.bE = function(i) {
          return i[0] = 0, i[1] = 0, i[2] = 0, i
        }, T.bF = function(i, t, r, n) {
          const c = Math.sqrt(i * i + t * t),
            f = Math.sqrt(r * r + n * n);
          i /= c, t /= c, r /= f, n /= f;
          const m = Math.acos(i * r + t * n);
          return -t * r + i * n > 0 ? m : -m
        }, T.bG = function(i, t) {
          const r = ut(i, 2 * Math.PI),
            n = ut(t, 2 * Math.PI);
          return Math.min(Math.abs(r - n), Math.abs(r - n + 2 * Math.PI), Math.abs(r - n - 2 * Math.PI))
        }, T.bH = function() {
          const i = {},
            t = Y.$version;
          for (const r in Y.$root) {
            const n = Y.$root[r];
            if (n.required) {
              let c = null;
              c = r === "version" ? t : n.type === "array" ? [] : {}, c != null && (i[r] = c)
            }
          }
          return i
        }, T.bI = mu, T.bJ = te, T.bK = function i(t, r) {
          if (Array.isArray(t)) {
            if (!Array.isArray(r) || t.length !== r.length) return !1;
            for (let n = 0; n < t.length; n++)
              if (!i(t[n], r[n])) return !1;
            return !0
          }
          if (typeof t == "object" && t !== null && r !== null) {
            if (typeof r != "object" || Object.keys(t).length !== Object.keys(r).length) return !1;
            for (const n in t)
              if (!i(t[n], r[n])) return !1;
            return !0
          }
          return t === r
        }, T.bL = function(i) {
          i = i.slice();
          const t = Object.create(null);
          for (let r = 0; r < i.length; r++) t[i[r].id] = i[r];
          for (let r = 0; r < i.length; r++) "ref" in i[r] && (i[r] = Ne(i[r], t[i[r].ref]));
          return i
        }, T.bM = function(i, t) {
          if (i.type === "custom") return new c1(i, t);
          switch (i.type) {
            case "background":
              return new l1(i, t);
            case "circle":
              return new Hy(i, t);
            case "color-relief":
              return new Qy(i, t);
            case "fill":
              return new fx(i, t);
            case "fill-extrusion":
              return new Px(i, t);
            case "heatmap":
              return new Yy(i, t);
            case "hillshade":
              return new Jy(i, t);
            case "line":
              return new Ex(i, t);
            case "raster":
              return new uf(i, t);
            case "symbol":
              return new Wd(i, t)
          }
        }, T.bN = i => i.type === "raster", T.bO = jt, T.bP = function(i, t) {
          if (!i) return [{
            command: "setStyle",
            args: [t]
          }];
          let r = [];
          try {
            if (!Ge(i.version, t.version)) return [{
              command: "setStyle",
              args: [t]
            }];
            Ge(i.center, t.center) || r.push({
              command: "setCenter",
              args: [t.center]
            }), Ge(i.state, t.state) || r.push({
              command: "setGlobalState",
              args: [t.state]
            }), Ge(i.centerAltitude, t.centerAltitude) || r.push({
              command: "setCenterAltitude",
              args: [t.centerAltitude]
            }), Ge(i.zoom, t.zoom) || r.push({
              command: "setZoom",
              args: [t.zoom]
            }), Ge(i.bearing, t.bearing) || r.push({
              command: "setBearing",
              args: [t.bearing]
            }), Ge(i.pitch, t.pitch) || r.push({
              command: "setPitch",
              args: [t.pitch]
            }), Ge(i.roll, t.roll) || r.push({
              command: "setRoll",
              args: [t.roll]
            }), Ge(i.sprite, t.sprite) || r.push({
              command: "setSprite",
              args: [t.sprite]
            }), Ge(i.glyphs, t.glyphs) || r.push({
              command: "setGlyphs",
              args: [t.glyphs]
            }), Ge(i.transition, t.transition) || r.push({
              command: "setTransition",
              args: [t.transition]
            }), Ge(i.light, t.light) || r.push({
              command: "setLight",
              args: [t.light]
            }), Ge(i.terrain, t.terrain) || r.push({
              command: "setTerrain",
              args: [t.terrain]
            }), Ge(i.sky, t.sky) || r.push({
              command: "setSky",
              args: [t.sky]
            }), Ge(i.projection, t.projection) || r.push({
              command: "setProjection",
              args: [t.projection]
            });
            const n = {},
              c = [];
            (function(m, v, b, M) {
              let C;
              for (C in v = v || {}, m = m || {}) Object.prototype.hasOwnProperty.call(m, C) && (Object.prototype.hasOwnProperty.call(v, C) || it(C, b, M));
              for (C in v) Object.prototype.hasOwnProperty.call(v, C) && (Object.prototype.hasOwnProperty.call(m, C) ? Ge(m[C], v[C]) || (m[C].type === "geojson" && v[C].type === "geojson" && Lt(m, v, C) ? pe(b, {
                command: "setGeoJSONSourceData",
                args: [C, v[C].data]
              }) : yt(C, v, b, M)) : Ve(C, v, b))
            })(i.sources, t.sources, c, n);
            const f = [];
            i.layers && i.layers.forEach((m => {
              "source" in m && n[m.source] ? r.push({
                command: "removeLayer",
                args: [m.id]
              }) : f.push(m)
            })), r = r.concat(c), (function(m, v, b) {
              v = v || [];
              const M = (m = m || []).map(At),
                C = v.map(At),
                D = m.reduce(qt, {}),
                N = v.reduce(qt, {}),
                W = M.slice(),
                X = Object.create(null);
              let Q, le, we, et, De;
              for (let Ze = 0, mt = 0; Ze < M.length; Ze++) Q = M[Ze], Object.prototype.hasOwnProperty.call(N, Q) ? mt++ : (pe(b, {
                command: "removeLayer",
                args: [Q]
              }), W.splice(W.indexOf(Q, mt), 1));
              for (let Ze = 0, mt = 0; Ze < C.length; Ze++) Q = C[C.length - 1 - Ze], W[W.length - 1 - Ze] !== Q && (Object.prototype.hasOwnProperty.call(D, Q) ? (pe(b, {
                command: "removeLayer",
                args: [Q]
              }), W.splice(W.lastIndexOf(Q, W.length - mt), 1)) : mt++, et = W[W.length - Ze], pe(b, {
                command: "addLayer",
                args: [N[Q], et]
              }), W.splice(W.length - Ze, 0, Q), X[Q] = !0);
              for (let Ze = 0; Ze < C.length; Ze++)
                if (Q = C[Ze], le = D[Q], we = N[Q], !X[Q] && !Ge(le, we))
                  if (Ge(le.source, we.source) && Ge(le["source-layer"], we["source-layer"]) && Ge(le.type, we.type)) {
                    for (De in ct(le.layout, we.layout, b, Q, null, "setLayoutProperty"), ct(le.paint, we.paint, b, Q, null, "setPaintProperty"), Ge(le.filter, we.filter) || pe(b, {
                        command: "setFilter",
                        args: [Q, we.filter]
                      }), Ge(le.minzoom, we.minzoom) && Ge(le.maxzoom, we.maxzoom) || pe(b, {
                        command: "setLayerZoomRange",
                        args: [Q, we.minzoom, we.maxzoom]
                      }), le) Object.prototype.hasOwnProperty.call(le, De) && De !== "layout" && De !== "paint" && De !== "filter" && De !== "metadata" && De !== "minzoom" && De !== "maxzoom" && (De.indexOf("paint.") === 0 ? ct(le[De], we[De], b, Q, De.slice(6), "setPaintProperty") : Ge(le[De], we[De]) || pe(b, {
                      command: "setLayerProperty",
                      args: [Q, De, we[De]]
                    }));
                    for (De in we) Object.prototype.hasOwnProperty.call(we, De) && !Object.prototype.hasOwnProperty.call(le, De) && De !== "layout" && De !== "paint" && De !== "filter" && De !== "metadata" && De !== "minzoom" && De !== "maxzoom" && (De.indexOf("paint.") === 0 ? ct(le[De], we[De], b, Q, De.slice(6), "setPaintProperty") : Ge(le[De], we[De]) || pe(b, {
                      command: "setLayerProperty",
                      args: [Q, De, we[De]]
                    }))
                  } else pe(b, {
                    command: "removeLayer",
                    args: [Q]
                  }), et = W[W.lastIndexOf(Q) + 1], pe(b, {
                    command: "addLayer",
                    args: [we, et]
                  })
            })(f, t.layers, r)
          } catch (n) {
            console.warn("Unable to compute style diff:", n), r = [{
              command: "setStyle",
              args: [t]
            }]
          }
          return r
        }, T.bQ = function(i) {
          const t = [],
            r = i.id;
          return r === void 0 && t.push({
            message: `layers.${r}: missing required property "id"`
          }), i.render === void 0 && t.push({
            message: `layers.${r}: missing required method "render"`
          }), i.renderingMode && i.renderingMode !== "2d" && i.renderingMode !== "3d" && t.push({
            message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"`
          }), t
        }, T.bR = Vt, T.bS = Jt, T.bT = class extends gn {
          constructor(i, t) {
            super(i, t), this.current = 0
          }
          set(i) {
            this.current !== i && (this.current = i, this.gl.uniform1i(this.location, i))
          }
        }, T.bU = Cs, T.bV = class extends gn {
          constructor(i, t) {
            super(i, t), this.current = ll
          }
          set(i) {
            if (i[12] !== this.current[12] || i[0] !== this.current[0]) return this.current = i, void this.gl.uniformMatrix4fv(this.location, !1, i);
            for (let t = 1; t < 16; t++)
              if (i[t] !== this.current[t]) {
                this.current = i, this.gl.uniformMatrix4fv(this.location, !1, i);
                break
              }
          }
        }, T.bW = gs, T.bX = class extends gn {
          constructor(i, t) {
            super(i, t), this.current = [0, 0, 0]
          }
          set(i) {
            i[0] === this.current[0] && i[1] === this.current[1] && i[2] === this.current[2] || (this.current = i, this.gl.uniform3f(this.location, i[0], i[1], i[2]))
          }
        }, T.bY = class extends gn {
          constructor(i, t) {
            super(i, t), this.current = [0, 0]
          }
          set(i) {
            i[0] === this.current[0] && i[1] === this.current[1] || (this.current = i, this.gl.uniform2f(this.location, i[0], i[1]))
          }
        }, T.bZ = Ye, T.b_ = function(i, t) {
          var r = Math.sin(t),
            n = Math.cos(t);
          return i[0] = n, i[1] = r, i[2] = 0, i[3] = -r, i[4] = n, i[5] = 0, i[6] = 0, i[7] = 0, i[8] = 1, i
        }, T.ba = function(i, t, r) {
          var n = Math.sin(r),
            c = Math.cos(r),
            f = t[4],
            m = t[5],
            v = t[6],
            b = t[7],
            M = t[8],
            C = t[9],
            D = t[10],
            N = t[11];
          return t !== i && (i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[4] = f * c + M * n, i[5] = m * c + C * n, i[6] = v * c + D * n, i[7] = b * c + N * n, i[8] = M * c - f * n, i[9] = C * c - m * n, i[10] = D * c - v * n, i[11] = N * c - b * n, i
        }, T.bb = function() {
          const i = new Float32Array(16);
          return We(i), i
        }, T.bc = function() {
          const i = new Float64Array(16);
          return We(i), i
        }, T.bd = function() {
          return new Float64Array(16)
        }, T.be = function(i, t, r) {
          const n = new Float64Array(4);
          return _t(n, i, t - 90, r), n
        }, T.bf = function(i, t, r, n) {
          var c, f, m, v, b, M = t[0],
            C = t[1],
            D = t[2],
            N = t[3],
            W = r[0],
            X = r[1],
            Q = r[2],
            le = r[3];
          return (f = M * W + C * X + D * Q + N * le) < 0 && (f = -f, W = -W, X = -X, Q = -Q, le = -le), 1 - f > qe ? (c = Math.acos(f), m = Math.sin(c), v = Math.sin((1 - n) * c) / m, b = Math.sin(n * c) / m) : (v = 1 - n, b = n), i[0] = v * M + b * W, i[1] = v * C + b * X, i[2] = v * D + b * Q, i[3] = v * N + b * le, i
        }, T.bg = function(i) {
          const t = new Float64Array(9);
          var r, n, c, f, m, v, b, M, C, D, N, W, X, Q, le, we, et, De;
          D = (c = (n = i)[0]) * (b = c + c), N = (f = n[1]) * b, X = (m = n[2]) * b, Q = m * (M = f + f), we = (v = n[3]) * b, et = v * M, De = v * (C = m + m), (r = t)[0] = 1 - (W = f * M) - (le = m * C), r[3] = N - De, r[6] = X + et, r[1] = N + De, r[4] = 1 - D - le, r[7] = Q - we, r[2] = X - et, r[5] = Q + we, r[8] = 1 - D - W;
          const Ze = vr(-Math.asin(Zt(t[2], -1, 1)));
          let mt, Mt;
          return Math.hypot(t[5], t[8]) < .001 ? (mt = 0, Mt = -vr(Math.atan2(t[3], t[4]))) : (mt = vr(t[5] === 0 && t[8] === 0 ? 0 : Math.atan2(t[5], t[8])), Mt = vr(t[1] === 0 && t[0] === 0 ? 0 : Math.atan2(t[1], t[0]))), {
            roll: mt,
            pitch: Ze + 90,
            bearing: Mt
          }
        }, T.bh = function(i, t) {
          return i.roll == t.roll && i.pitch == t.pitch && i.bearing == t.bearing
        }, T.bi = Ar, T.bj = un, T.bk = cc, T.bl = Ru, T.bm = lc, T.bn = st, T.bo = wt, T.bp = ua, T.bq = function(i, t, r, n, c) {
          return st(n, c, Zt((i - t) / (r - t), 0, 1))
        }, T.br = ut, T.bs = function() {
          return new Float64Array(3)
        }, T.bt = function(i, t, r, n) {
          return i[0] = t[0] + r[0] * n, i[1] = t[1] + r[1] * n, i[2] = t[2] + r[2] * n, i
        }, T.bu = _t, T.bv = function(i, t, r) {
          var n = r[0],
            c = r[1],
            f = r[2],
            m = r[3],
            v = t[0],
            b = t[1],
            M = t[2],
            C = c * M - f * b,
            D = f * v - n * M,
            N = n * b - c * v;
          return i[0] = v + m * (C += C) + c * (N += N) - f * (D += D), i[1] = b + m * D + f * C - n * N, i[2] = M + m * N + n * D - c * C, i
        }, T.bw = function(i, t, r) {
          const n = (c = [i[0], i[1], i[2], t[0], t[1], t[2], r[0], r[1], r[2]])[0] * ((C = c[8]) * (m = c[4]) - (v = c[5]) * (M = c[7])) + c[1] * (-C * (f = c[3]) + v * (b = c[6])) + c[2] * (M * f - m * b);
          var c, f, m, v, b, M, C;
          if (n === 0) return null;
          const D = Ee([], [t[0], t[1], t[2]], [r[0], r[1], r[2]]),
            N = Ee([], [r[0], r[1], r[2]], [i[0], i[1], i[2]]),
            W = Ee([], [i[0], i[1], i[2]], [t[0], t[1], t[2]]),
            X = Me([], D, -i[3]);
          return Ae(X, X, Me([], N, -t[3])), Ae(X, X, Me([], W, -r[3])), Me(X, X, 1 / n), X
        }, T.bx = Bf, T.by = function() {
          return new Float64Array(4)
        }, T.bz = function(i, t, r, n) {
          var c = [],
            f = [];
          return c[0] = t[0] - r[0], c[1] = t[1] - r[1], c[2] = t[2] - r[2], f[0] = c[0] * Math.cos(n) - c[1] * Math.sin(n), f[1] = c[0] * Math.sin(n) + c[1] * Math.cos(n), f[2] = c[2], i[0] = f[0] + r[0], i[1] = f[1] + r[1], i[2] = f[2] + r[2], i
        }, T.c = ge, T.c0 = function(i, t, r, n, c, f, m) {
          var v = 1 / (t - r),
            b = 1 / (n - c),
            M = 1 / (f - m);
          return i[0] = -2 * v, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = -2 * b, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 2 * M, i[11] = 0, i[12] = (t + r) * v, i[13] = (c + n) * b, i[14] = (m + f) * M, i[15] = 1, i
        }, T.c1 = class extends gn {
          constructor(i, t) {
            super(i, t), this.current = new Array
          }
          set(i) {
            if (i != this.current) {
              this.current = i;
              const t = new Float32Array(4 * i.length);
              for (let r = 0; r < i.length; r++) t[4 * r] = i[r].r, t[4 * r + 1] = i[r].g, t[4 * r + 2] = i[r].b, t[4 * r + 3] = i[r].a;
              this.gl.uniform4fv(this.location, t)
            }
          }
        }, T.c2 = class extends gn {
          constructor(i, t) {
            super(i, t), this.current = new Array
          }
          set(i) {
            if (i != this.current) {
              this.current = i;
              const t = new Float32Array(i);
              this.gl.uniform1fv(this.location, t)
            }
          }
        }, T.c3 = class extends Js {}, T.c4 = Fx, T.c5 = class extends tc {}, T.c6 = vf, T.c7 = function(i) {
          return i <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(i) / Math.LN2))
        }, T.c8 = Ug, T.c9 = function(i, t, r) {
          var n = t[0],
            c = t[1],
            f = t[2],
            m = r[3] * n + r[7] * c + r[11] * f + r[15];
          return i[0] = (r[0] * n + r[4] * c + r[8] * f + r[12]) / (m = m || 1), i[1] = (r[1] * n + r[5] * c + r[9] * f + r[13]) / m, i[2] = (r[2] * n + r[6] * c + r[10] * f + r[14]) / m, i
        }, T.cB = function(i) {
          return i.message === mr
        }, T.cC = se, T.cD = function(i, t) {
          V.REGISTERED_PROTOCOLS[i] = t
        }, T.cE = function(i) {
          delete V.REGISTERED_PROTOCOLS[i]
        }, T.cF = function(i, t) {
          const r = {};
          for (let c = 0; c < i.length; c++) {
            const f = t && t[i[c].id] || od(i[c]);
            t && (t[i[c].id] = f);
            let m = r[f];
            m || (m = r[f] = []), m.push(i[c])
          }
          const n = [];
          for (const c in r) n.push(r[c]);
          return n
        }, T.cG = zr, T.cH = q_, T.cI = V_, T.cJ = v_, T.cK = function(i) {
          i.bucket.createArrays(), i.bucket.tilePixelRatio = nt / (512 * i.bucket.overscaling), i.bucket.compareText = {}, i.bucket.iconsNeedLinear = !1;
          const t = i.bucket.layers[0],
            r = t.layout,
            n = t._unevaluatedLayout._values,
            c = {
              layoutIconSize: n["icon-size"].possiblyEvaluate(new ta(i.bucket.zoom + 1), i.canonical),
              layoutTextSize: n["text-size"].possiblyEvaluate(new ta(i.bucket.zoom + 1), i.canonical),
              textMaxSize: n["text-size"].possiblyEvaluate(new ta(18))
            };
          if (i.bucket.textSizeData.kind === "composite") {
            const {
              minZoom: M,
              maxZoom: C
            } = i.bucket.textSizeData;
            c.compositeTextSizes = [n["text-size"].possiblyEvaluate(new ta(M), i.canonical), n["text-size"].possiblyEvaluate(new ta(C), i.canonical)]
          }
          if (i.bucket.iconSizeData.kind === "composite") {
            const {
              minZoom: M,
              maxZoom: C
            } = i.bucket.iconSizeData;
            c.compositeIconSizes = [n["icon-size"].possiblyEvaluate(new ta(M), i.canonical), n["icon-size"].possiblyEvaluate(new ta(C), i.canonical)]
          }
          const f = r.get("text-line-height") * Ga,
            m = r.get("text-rotation-alignment") !== "viewport" && r.get("symbol-placement") !== "point",
            v = r.get("text-keep-upright"),
            b = r.get("text-size");
          for (const M of i.bucket.features) {
            const C = r.get("text-font").evaluate(M, {}, i.canonical).join(","),
              D = b.evaluate(M, {}, i.canonical),
              N = c.layoutTextSize.evaluate(M, {}, i.canonical),
              W = c.layoutIconSize.evaluate(M, {}, i.canonical),
              X = {
                horizontal: {},
                vertical: void 0
              },
              Q = M.text;
            let le, we = [0, 0];
            if (Q) {
              const Ze = Q.toString(),
                mt = r.get("text-letter-spacing").evaluate(M, {}, i.canonical) * Ga,
                Mt = _u(Ze) ? mt : 0,
                $t = r.get("text-anchor").evaluate(M, {}, i.canonical),
                Tr = Q_(t, M, i.canonical);
              if (!Tr) {
                const gr = r.get("text-radial-offset").evaluate(M, {}, i.canonical);
                we = gr ? $_($t, [gr * Ga, jf]) : r.get("text-offset").evaluate(M, {}, i.canonical).map((xr => xr * Ga))
              }
              let hr = m ? "center" : r.get("text-justify").evaluate(M, {}, i.canonical);
              const yr = r.get("symbol-placement") === "point" ? r.get("text-max-width").evaluate(M, {}, i.canonical) * Ga : 1 / 0,
                $r = () => {
                  i.bucket.allowVerticalPlacement && gu(Ze) && (X.vertical = Ud(Q, i.glyphMap, i.glyphPositions, i.imagePositions, C, yr, f, $t, "left", Mt, we, T.as.vertical, !0, N, D))
                };
              if (!m && Tr) {
                const gr = new Set;
                if (hr === "auto")
                  for (let Ft = 0; Ft < Tr.values.length; Ft += 2) gr.add(qf(Tr.values[Ft]));
                else gr.add(hr);
                let xr = !1;
                for (const Ft of gr)
                  if (!X.horizontal[Ft])
                    if (xr) X.horizontal[Ft] = X.horizontal[0];
                    else {
                      const mi = Ud(Q, i.glyphMap, i.glyphPositions, i.imagePositions, C, yr, f, "center", Ft, Mt, we, T.as.horizontal, !1, N, D);
                      mi && (X.horizontal[Ft] = mi, xr = mi.positionedLines.length === 1)
                    } $r()
              } else {
                hr === "auto" && (hr = qf($t));
                const gr = Ud(Q, i.glyphMap, i.glyphPositions, i.imagePositions, C, yr, f, $t, hr, Mt, we, T.as.horizontal, !1, N, D);
                gr && (X.horizontal[hr] = gr), $r(), gu(Ze) && m && v && (X.vertical = Ud(Q, i.glyphMap, i.glyphPositions, i.imagePositions, C, yr, f, $t, hr, Mt, we, T.as.vertical, !1, N, D))
              }
            }
            let et = !1;
            if (M.icon && M.icon.name) {
              const Ze = i.imageMap[M.icon.name];
              Ze && (le = a1(i.imagePositions[M.icon.name], r.get("icon-offset").evaluate(M, {}, i.canonical), r.get("icon-anchor").evaluate(M, {}, i.canonical)), et = !!Ze.sdf, i.bucket.sdfIcons === void 0 ? i.bucket.sdfIcons = et : i.bucket.sdfIcons !== et && St("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (Ze.pixelRatio !== i.bucket.pixelRatio || r.get("icon-rotate").constantOr(1) !== 0) && (i.bucket.iconsNeedLinear = !0))
            }
            const De = tv(X.horizontal) || X.vertical;
            i.bucket.iconsInText = !!De && De.iconsInText, (De || le) && v1(i.bucket, M, X, le, i.imageMap, c, N, W, we, et, i.canonical, i.subdivisionGranularity)
          }
          i.showCollisionBoxes && i.bucket.generateCollisionDebugBuffers()
        }, T.cL = Tf, T.cM = Pf, T.cN = If, T.cO = a_, T.cP = Cf, T.cQ = class {
          constructor(i) {
            this._marks = {
              start: [i.url, "start"].join("#"),
              end: [i.url, "end"].join("#"),
              measure: i.url.toString()
            }, performance.mark(this._marks.start)
          }
          finish() {
            performance.mark(this._marks.end);
            let i = performance.getEntriesByName(this._marks.measure);
            return i.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), i = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), i
          }
        }, T.cR = function(i, t, r, n, c) {
          return s(this, void 0, void 0, (function*() {
            if (be()) try {
              return yield _r(i, t, r, n, c)
            } catch {}
            return (function(f, m, v, b, M) {
              const C = f.width,
                D = f.height;
              fr && Yt || (fr = new OffscreenCanvas(C, D), Yt = fr.getContext("2d", {
                willReadFrequently: !0
              })), fr.width = C, fr.height = D, Yt.drawImage(f, 0, 0, C, D);
              const N = Yt.getImageData(m, v, b, M);
              return Yt.clearRect(0, 0, C, D), N.data
            })(i, t, r, n, c)
          }))
        }, T.cS = Wg, T.cT = Z, T.cU = i_, T.cV = uc, T.cW = Gs, T.cX = function(i, t) {
          const r = new Map;
          if (i != null)
            if (i.type === "Feature") r.set(Vu(i, t), i);
            else
              for (const n of i.features) r.set(Vu(n, t), n);
          return r
        }, T.cY = function(i, t) {
          if (i == null) return !0;
          if (i.type === "Feature") return Vu(i, t) != null;
          if (i.type === "FeatureCollection") {
            const r = new Set;
            for (const n of i.features) {
              const c = Vu(n, t);
              if (c == null || r.has(c)) return !1;
              r.add(c)
            }
            return !0
          }
          return !1
        }, T.cZ = function(i, t, r) {
          var n, c, f, m;
          if (t.removeAll && i.clear(), t.remove)
            for (const v of t.remove) i.delete(v);
          if (t.add)
            for (const v of t.add) {
              const b = Vu(v, r);
              b != null && i.set(b, v)
            }
          if (t.update)
            for (const v of t.update) {
              let b = i.get(v.id);
              if (b == null) continue;
              const M = !v.removeAllProperties && (((n = v.removeProperties) === null || n === void 0 ? void 0 : n.length) > 0 || ((c = v.addOrUpdateProperties) === null || c === void 0 ? void 0 : c.length) > 0);
              if ((v.newGeometry || v.removeAllProperties || M) && (b = Object.assign({}, b), i.set(v.id, b), M && (b.properties = Object.assign({}, b.properties))), v.newGeometry && (b.geometry = v.newGeometry), v.removeAllProperties) b.properties = {};
              else if (((f = v.removeProperties) === null || f === void 0 ? void 0 : f.length) > 0)
                for (const C of v.removeProperties) Object.prototype.hasOwnProperty.call(b.properties, C) && delete b.properties[C];
              if (((m = v.addOrUpdateProperties) === null || m === void 0 ? void 0 : m.length) > 0)
                for (const {
                    key: C,
                    value: D
                  }
                  of v.addOrUpdateProperties) b.properties[C] = D
            }
        }, T.c_ = ps, T.ca = class extends Tu {}, T.cb = class extends u {}, T.cc = function(i, t) {
          return i[0] === t[0] && i[1] === t[1] && i[2] === t[2] && i[3] === t[3] && i[4] === t[4] && i[5] === t[5] && i[6] === t[6] && i[7] === t[7] && i[8] === t[8] && i[9] === t[9] && i[10] === t[10] && i[11] === t[11] && i[12] === t[12] && i[13] === t[13] && i[14] === t[14] && i[15] === t[15]
        }, T.cd = function(i, t) {
          var r = i[0],
            n = i[1],
            c = i[2],
            f = i[3],
            m = i[4],
            v = i[5],
            b = i[6],
            M = i[7],
            C = i[8],
            D = i[9],
            N = i[10],
            W = i[11],
            X = i[12],
            Q = i[13],
            le = i[14],
            we = i[15],
            et = t[0],
            De = t[1],
            Ze = t[2],
            mt = t[3],
            Mt = t[4],
            $t = t[5],
            Tr = t[6],
            hr = t[7],
            yr = t[8],
            $r = t[9],
            gr = t[10],
            xr = t[11],
            Ft = t[12],
            mi = t[13],
            xi = t[14],
            si = t[15];
          return Math.abs(r - et) <= qe * Math.max(1, Math.abs(r), Math.abs(et)) && Math.abs(n - De) <= qe * Math.max(1, Math.abs(n), Math.abs(De)) && Math.abs(c - Ze) <= qe * Math.max(1, Math.abs(c), Math.abs(Ze)) && Math.abs(f - mt) <= qe * Math.max(1, Math.abs(f), Math.abs(mt)) && Math.abs(m - Mt) <= qe * Math.max(1, Math.abs(m), Math.abs(Mt)) && Math.abs(v - $t) <= qe * Math.max(1, Math.abs(v), Math.abs($t)) && Math.abs(b - Tr) <= qe * Math.max(1, Math.abs(b), Math.abs(Tr)) && Math.abs(M - hr) <= qe * Math.max(1, Math.abs(M), Math.abs(hr)) && Math.abs(C - yr) <= qe * Math.max(1, Math.abs(C), Math.abs(yr)) && Math.abs(D - $r) <= qe * Math.max(1, Math.abs(D), Math.abs($r)) && Math.abs(N - gr) <= qe * Math.max(1, Math.abs(N), Math.abs(gr)) && Math.abs(W - xr) <= qe * Math.max(1, Math.abs(W), Math.abs(xr)) && Math.abs(X - Ft) <= qe * Math.max(1, Math.abs(X), Math.abs(Ft)) && Math.abs(Q - mi) <= qe * Math.max(1, Math.abs(Q), Math.abs(mi)) && Math.abs(le - xi) <= qe * Math.max(1, Math.abs(le), Math.abs(xi)) && Math.abs(we - si) <= qe * Math.max(1, Math.abs(we), Math.abs(si))
        }, T.ce = function(i, t) {
          return i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[4] = t[4], i[5] = t[5], i[6] = t[6], i[7] = t[7], i[8] = t[8], i[9] = t[9], i[10] = t[10], i[11] = t[11], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15], i
        }, T.cf = i => i.type === "symbol", T.cg = i => i.type === "circle", T.ch = i => i.type === "heatmap", T.ci = i => i.type === "line", T.cj = i => i.type === "fill", T.ck = i => i.type === "fill-extrusion", T.cl = i => i.type === "hillshade", T.cm = i => i.type === "color-relief", T.cn = i => i.type === "background", T.co = i => i.type === "custom", T.cp = Ct, T.cq = function(i, t, r) {
          const n = at(t.x - r.x, t.y - r.y),
            c = at(i.x - r.x, i.y - r.y);
          var f, m;
          return vr(Math.atan2(n[0] * c[1] - n[1] * c[0], (f = n)[0] * (m = c)[0] + f[1] * m[1]))
        }, T.cr = rr, T.cs = function(i, t) {
          return ii[t] && (i instanceof MouseEvent || i instanceof WheelEvent)
        }, T.ct = function(i, t) {
          return Lr[t] && "touches" in i
        }, T.cu = function(i) {
          return Lr[i] || ii[i]
        }, T.cv = function(i, t, r) {
          var n = t[0],
            c = t[1];
          return i[0] = r[0] * n + r[4] * c + r[12], i[1] = r[1] * n + r[5] * c + r[13], i
        }, T.cw = function(i, t) {
          const {
            x: r,
            y: n
          } = Nu.fromLngLat(t);
          return !(i < 0 || i > 25 || n < 0 || n >= 1 || r < 0 || r >= 1)
        }, T.cx = function(i, t) {
          return i[0] = t[0], i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = t[1], i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = t[2], i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i
        }, T.cy = class extends Jl {}, T.cz = x1, T.d = Re, T.e = ht, T.f = i => s(void 0, void 0, void 0, (function*() {
          if (i.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
          const t = new Blob([new Uint8Array(i)], {
            type: "image/png"
          });
          try {
            return createImageBitmap(t)
          } catch (r) {
            throw new Error(`Could not load image because of ${r.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`)
          }
        })), T.g = U, T.h = i => new Promise(((t, r) => {
          const n = new Image;
          n.onload = () => {
            t(n), URL.revokeObjectURL(n.src), n.onload = null, window.requestAnimationFrame((() => {
              n.src = kr
            }))
          }, n.onerror = () => r(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const c = new Blob([new Uint8Array(i)], {
            type: "image/png"
          });
          n.src = i.byteLength ? URL.createObjectURL(c) : kr
        })), T.i = Ut, T.j = (i, t) => _e(ht(i, {
          type: "json"
        }), t), T.k = ve, T.l = fe, T.m = _e, T.n = (i, t) => _e(ht(i, {
          type: "arrayBuffer"
        }), t), T.o = function(i) {
          return new Cf(i).readFields(Hx, [])
        }, T.p = __, T.q = ku, T.r = an, T.s = sr, T.t = Y, T.u = Bi, T.v = gd, T.w = St, T.x = Md, T.y = of, T.z = vd
      })), k("worker", ["./shared"], (function(T) {
        class s {
          constructor(V, U) {
            this.keyCache = {}, V && this.replace(V, U)
          }
          replace(V, U) {
            this._layerConfigs = {}, this._layers = {}, this.update(V, [], U)
          }
          update(V, U, J) {
            for (const te of V) {
              this._layerConfigs[te.id] = te;
              const _e = this._layers[te.id] = T.bM(te, J);
              _e._featureFilter = T.ae(_e.filter, J), this.keyCache[te.id] && delete this.keyCache[te.id]
            }
            for (const te of U) delete this.keyCache[te], delete this._layerConfigs[te], delete this._layers[te];
            this.familiesBySource = {};
            const se = T.cF(Object.values(this._layerConfigs), this.keyCache);
            for (const te of se) {
              const _e = te.map((ie => this._layers[ie.id])),
                Re = _e[0];
              if (Re.visibility === "none") continue;
              const ne = Re.source || "";
              let oe = this.familiesBySource[ne];
              oe || (oe = this.familiesBySource[ne] = {});
              const fe = Re.sourceLayer || "_geojsonTileLayer";
              let ve = oe[fe];
              ve || (ve = oe[fe] = []), ve.push(_e)
            }
          }
        }
        class F {
          constructor(V) {
            const U = {},
              J = [];
            for (const Re in V) {
              const ne = V[Re],
                oe = U[Re] = {};
              for (const fe in ne) {
                const ve = ne[+fe];
                if (!ve || ve.bitmap.width === 0 || ve.bitmap.height === 0) continue;
                const ie = {
                  x: 0,
                  y: 0,
                  w: ve.bitmap.width + 2,
                  h: ve.bitmap.height + 2
                };
                J.push(ie), oe[fe] = {
                  rect: ie,
                  metrics: ve.metrics
                }
              }
            }
            const {
              w: se,
              h: te
            } = T.p(J), _e = new T.q({
              width: se || 1,
              height: te || 1
            });
            for (const Re in V) {
              const ne = V[Re];
              for (const oe in ne) {
                const fe = ne[+oe];
                if (!fe || fe.bitmap.width === 0 || fe.bitmap.height === 0) continue;
                const ve = U[Re][oe].rect;
                T.q.copy(fe.bitmap, _e, {
                  x: 0,
                  y: 0
                }, {
                  x: ve.x + 1,
                  y: ve.y + 1
                }, fe.bitmap)
              }
            }
            this.image = _e, this.positions = U
          }
        }
        T.cG("GlyphAtlas", F);
        class Z {
          constructor(V) {
            this.tileID = new T.a0(V.tileID.overscaledZ, V.tileID.wrap, V.tileID.canonical.z, V.tileID.canonical.x, V.tileID.canonical.y), this.uid = V.uid, this.zoom = V.zoom, this.pixelRatio = V.pixelRatio, this.tileSize = V.tileSize, this.source = V.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = V.showCollisionBoxes, this.collectResourceTiming = !!V.collectResourceTiming, this.returnDependencies = !!V.returnDependencies, this.promoteId = V.promoteId, this.inFlightDependencies = []
          }
          parse(V, U, J, se, te) {
            return T._(this, void 0, void 0, (function*() {
              this.status = "parsing", this.data = V, this.collisionBoxArray = new T.ac;
              const _e = new T.cH(Object.keys(V.layers).sort()),
                Re = new T.cI(this.tileID, this.promoteId);
              Re.bucketLayerIDs = [];
              const ne = {},
                oe = {
                  featureIndex: Re,
                  iconDependencies: {},
                  patternDependencies: {},
                  glyphDependencies: {},
                  dashDependencies: {},
                  availableImages: J,
                  subdivisionGranularity: te
                },
                fe = U.familiesBySource[this.source];
              for (const Ke in fe) {
                const Tt = V.layers[Ke];
                if (!Tt) continue;
                Tt.version === 1 && T.w(`Vector tile source "${this.source}" layer "${Ke}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const Wt = _e.encode(Ke),
                  Fr = [];
                for (let or = 0; or < Tt.length; or++) {
                  const tt = Tt.feature(or),
                    Ht = Re.getId(tt, Ke);
                  Fr.push({
                    feature: tt,
                    id: Ht,
                    index: or,
                    sourceLayerIndex: Wt
                  })
                }
                for (const or of fe[Ke]) {
                  const tt = or[0];
                  tt.source !== this.source && T.w(`layer.source = ${tt.source} does not equal this.source = ${this.source}`), tt.isHidden(this.zoom, !0) || (K(or, this.zoom, J), (ne[tt.id] = tt.createBucket({
                    index: Re.bucketLayerIDs.length,
                    layers: or,
                    zoom: this.zoom,
                    pixelRatio: this.pixelRatio,
                    overscaling: this.overscaling,
                    collisionBoxArray: this.collisionBoxArray,
                    sourceLayerIndex: Wt,
                    sourceID: this.source
                  })).populate(Fr, oe, this.tileID.canonical), Re.bucketLayerIDs.push(or.map((Ht => Ht.id))))
                }
              }
              const ve = T.bR(oe.glyphDependencies, (Ke => Object.keys(Ke).map(Number)));
              this.inFlightDependencies.forEach((Ke => Ke == null ? void 0 : Ke.abort())), this.inFlightDependencies = [];
              let ie = Promise.resolve({});
              if (Object.keys(ve).length) {
                const Ke = new AbortController;
                this.inFlightDependencies.push(Ke), ie = se.sendAsync({
                  type: "GG",
                  data: {
                    stacks: ve,
                    source: this.source,
                    tileID: this.tileID,
                    type: "glyphs"
                  }
                }, Ke)
              }
              const Y = Object.keys(oe.iconDependencies);
              let Fe = Promise.resolve({});
              if (Y.length) {
                const Ke = new AbortController;
                this.inFlightDependencies.push(Ke), Fe = se.sendAsync({
                  type: "GI",
                  data: {
                    icons: Y,
                    source: this.source,
                    tileID: this.tileID,
                    type: "icons"
                  }
                }, Ke)
              }
              const Ne = Object.keys(oe.patternDependencies);
              let Ge = Promise.resolve({});
              if (Ne.length) {
                const Ke = new AbortController;
                this.inFlightDependencies.push(Ke), Ge = se.sendAsync({
                  type: "GI",
                  data: {
                    icons: Ne,
                    source: this.source,
                    tileID: this.tileID,
                    type: "patterns"
                  }
                }, Ke)
              }
              const pe = oe.dashDependencies;
              let Ve = Promise.resolve({});
              if (Object.keys(pe).length) {
                const Ke = new AbortController;
                this.inFlightDependencies.push(Ke), Ve = se.sendAsync({
                  type: "GDA",
                  data: {
                    dashes: pe
                  }
                }, Ke)
              }
              const [it, yt, Lt, ct] = yield Promise.all([ie, Fe, Ge, Ve]), At = new F(it), qt = new T.cJ(yt, Lt);
              for (const Ke in ne) {
                const Tt = ne[Ke];
                Tt instanceof T.ad ? (K(Tt.layers, this.zoom, J), T.cK({
                  bucket: Tt,
                  glyphMap: it,
                  glyphPositions: At.positions,
                  imageMap: yt,
                  imagePositions: qt.iconPositions,
                  showCollisionBoxes: this.showCollisionBoxes,
                  canonical: this.tileID.canonical,
                  subdivisionGranularity: oe.subdivisionGranularity
                })) : Tt.hasDependencies && (Tt instanceof T.cL || Tt instanceof T.cM || Tt instanceof T.cN) && (K(Tt.layers, this.zoom, J), Tt.addFeatures(oe, this.tileID.canonical, qt.patternPositions, ct))
              }
              return this.status = "done", {
                buckets: Object.values(ne).filter((Ke => !Ke.isEmpty())),
                featureIndex: Re,
                collisionBoxArray: this.collisionBoxArray,
                glyphAtlasImage: At.image,
                imageAtlas: qt,
                dashPositions: ct,
                glyphMap: this.returnDependencies ? it : null,
                iconMap: this.returnDependencies ? yt : null,
                glyphPositions: this.returnDependencies ? At.positions : null
              }
            }))
          }
        }

        function K(ge, V, U) {
          const J = new T.G(V);
          for (const se of ge) se.recalculate(J, U)
        }
        class G {
          constructor(V, U, J) {
            this.actor = V, this.layerIndex = U, this.availableImages = J, this.fetching = {}, this.loading = {}, this.loaded = {}
          }
          loadVectorTile(V, U) {
            return T._(this, void 0, void 0, (function*() {
              const J = yield T.n(V.request, U);
              try {
                return {
                  vectorTile: new T.cO(new T.cP(J.data)),
                  rawData: J.data,
                  cacheControl: J.cacheControl,
                  expires: J.expires
                }
              } catch (se) {
                const te = new Uint8Array(J.data);
                let _e = `Unable to parse the tile at ${V.request.url}, `;
                throw _e += te[0] === 31 && te[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${se.message}`, new Error(_e)
              }
            }))
          }
          loadTile(V) {
            return T._(this, void 0, void 0, (function*() {
              const U = V.uid,
                J = !!(V && V.request && V.request.collectResourceTiming) && new T.cQ(V.request),
                se = new Z(V);
              this.loading[U] = se;
              const te = new AbortController;
              se.abort = te;
              try {
                const _e = yield this.loadVectorTile(V, te);
                if (delete this.loading[U], !_e) return null;
                const Re = _e.rawData,
                  ne = {};
                _e.expires && (ne.expires = _e.expires), _e.cacheControl && (ne.cacheControl = _e.cacheControl);
                const oe = {};
                if (J) {
                  const ve = J.finish();
                  ve && (oe.resourceTiming = JSON.parse(JSON.stringify(ve)))
                }
                se.vectorTile = _e.vectorTile;
                const fe = se.parse(_e.vectorTile, this.layerIndex, this.availableImages, this.actor, V.subdivisionGranularity);
                this.loaded[U] = se, this.fetching[U] = {
                  rawTileData: Re,
                  cacheControl: ne,
                  resourceTiming: oe
                };
                try {
                  const ve = yield fe;
                  return T.e({
                    rawTileData: Re.slice(0)
                  }, ve, ne, oe)
                } finally {
                  delete this.fetching[U]
                }
              } catch (_e) {
                throw delete this.loading[U], se.status = "done", this.loaded[U] = se, _e
              }
            }))
          }
          reloadTile(V) {
            return T._(this, void 0, void 0, (function*() {
              const U = V.uid;
              if (!this.loaded || !this.loaded[U]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const J = this.loaded[U];
              if (J.showCollisionBoxes = V.showCollisionBoxes, J.status === "parsing") {
                const se = yield J.parse(J.vectorTile, this.layerIndex, this.availableImages, this.actor, V.subdivisionGranularity);
                let te;
                if (this.fetching[U]) {
                  const {
                    rawTileData: _e,
                    cacheControl: Re,
                    resourceTiming: ne
                  } = this.fetching[U];
                  delete this.fetching[U], te = T.e({
                    rawTileData: _e.slice(0)
                  }, se, Re, ne)
                } else te = se;
                return te
              }
              if (J.status === "done" && J.vectorTile) return J.parse(J.vectorTile, this.layerIndex, this.availableImages, this.actor, V.subdivisionGranularity)
            }))
          }
          abortTile(V) {
            return T._(this, void 0, void 0, (function*() {
              const U = this.loading,
                J = V.uid;
              U && U[J] && U[J].abort && (U[J].abort.abort(), delete U[J])
            }))
          }
          removeTile(V) {
            return T._(this, void 0, void 0, (function*() {
              this.loaded && this.loaded[V.uid] && delete this.loaded[V.uid]
            }))
          }
        }
        class re {
          constructor() {
            this.loaded = {}
          }
          loadTile(V) {
            return T._(this, void 0, void 0, (function*() {
              const {
                uid: U,
                encoding: J,
                rawImageData: se,
                redFactor: te,
                greenFactor: _e,
                blueFactor: Re,
                baseShift: ne
              } = V, oe = se.width + 2, fe = se.height + 2, ve = T.b(se) ? new T.R({
                width: oe,
                height: fe
              }, yield T.cR(se, -1, -1, oe, fe)) : se, ie = new T.cS(U, ve, J, te, _e, Re, ne);
              return this.loaded = this.loaded || {}, this.loaded[U] = ie, ie
            }))
          }
          removeTile(V) {
            const U = this.loaded,
              J = V.uid;
            U && U[J] && delete U[J]
          }
        }
        var he, me, q = (function() {
            if (me) return he;

            function ge(U, J) {
              if (U.length !== 0) {
                V(U[0], J);
                for (var se = 1; se < U.length; se++) V(U[se], !J)
              }
            }

            function V(U, J) {
              for (var se = 0, te = 0, _e = 0, Re = U.length, ne = Re - 1; _e < Re; ne = _e++) {
                var oe = (U[_e][0] - U[ne][0]) * (U[ne][1] + U[_e][1]),
                  fe = se + oe;
                te += Math.abs(se) >= Math.abs(oe) ? se - fe + oe : oe - fe + se, se = fe
              }
              se + te >= 0 != !!J && U.reverse()
            }
            return me = 1, he = function U(J, se) {
              var te, _e = J && J.type;
              if (_e === "FeatureCollection")
                for (te = 0; te < J.features.length; te++) U(J.features[te], se);
              else if (_e === "GeometryCollection")
                for (te = 0; te < J.geometries.length; te++) U(J.geometries[te], se);
              else if (_e === "Feature") U(J.geometry, se);
              else if (_e === "Polygon") ge(J.coordinates, se);
              else if (_e === "MultiPolygon")
                for (te = 0; te < J.coordinates.length; te++) ge(J.coordinates[te], se);
              return J
            }
          })(),
          ye = T.cT(q);
        class be extends T.cV {
          constructor(V, U) {
            super(new T.cP, 0, U, [], []), this.feature = V, this.type = V.type, this.properties = V.tags ? V.tags : {}, "id" in V && (typeof V.id == "string" ? this.id = parseInt(V.id, 10) : typeof V.id != "number" || isNaN(V.id) || (this.id = V.id))
          }
          loadGeometry() {
            const V = [],
              U = this.feature.type === 1 ? [this.feature.geometry] : this.feature.geometry;
            for (const J of U) {
              const se = [];
              for (const te of J) se.push(new T.P(te[0], te[1]));
              V.push(se)
            }
            return V
          }
        }
        class qe extends T.cU {
          constructor(V, U) {
            super(new T.cP), this.layers = {
              _geojsonTileLayer: this
            }, this.name = "_geojsonTileLayer", this.version = U ? U.version : 1, this.extent = U ? U.extent : 4096, this.length = V.length, this.features = V
          }
          feature(V) {
            return new be(this.features[V], this.extent)
          }
        }

        function xe(ge, V) {
          V.writeVarintField(15, ge.version || 1), V.writeStringField(1, ge.name || ""), V.writeVarintField(5, ge.extent || 4096);
          const U = {
            keys: [],
            values: [],
            keycache: {},
            valuecache: {}
          };
          for (let te = 0; te < ge.length; te++) U.feature = ge.feature(te), V.writeMessage(2, Ye, U);
          const J = U.keys;
          for (const te of J) V.writeStringField(3, te);
          const se = U.values;
          for (const te of se) V.writeMessage(4, Ae, te)
        }

        function Ye(ge, V) {
          if (!ge.feature) return;
          const U = ge.feature;
          U.id !== void 0 && V.writeVarintField(1, U.id), V.writeMessage(2, We, ge), V.writeVarintField(3, U.type), V.writeMessage(4, Pe, U)
        }

        function We(ge, V) {
          var U;
          for (const J in (U = ge.feature) == null ? void 0 : U.properties) {
            let se = ge.feature.properties[J],
              te = ge.keycache[J];
            if (se === null) continue;
            te === void 0 && (ge.keys.push(J), te = ge.keys.length - 1, ge.keycache[J] = te), V.writeVarint(te), typeof se != "string" && typeof se != "boolean" && typeof se != "number" && (se = JSON.stringify(se));
            const _e = typeof se + ":" + se;
            let Re = ge.valuecache[_e];
            Re === void 0 && (ge.values.push(se), Re = ge.values.length - 1, ge.valuecache[_e] = Re), V.writeVarint(Re)
          }
        }

        function ze(ge, V) {
          return (V << 3) + (7 & ge)
        }

        function Se(ge) {
          return ge << 1 ^ ge >> 31
        }

        function Pe(ge, V) {
          const U = ge.loadGeometry(),
            J = ge.type;
          let se = 0,
            te = 0;
          for (const _e of U) {
            let Re = 1;
            J === 1 && (Re = _e.length), V.writeVarint(ze(1, Re));
            const ne = J === 3 ? _e.length - 1 : _e.length;
            for (let oe = 0; oe < ne; oe++) {
              oe === 1 && J !== 1 && V.writeVarint(ze(2, ne - 1));
              const fe = _e[oe].x - se,
                ve = _e[oe].y - te;
              V.writeVarint(Se(fe)), V.writeVarint(Se(ve)), se += fe, te += ve
            }
            ge.type === 3 && V.writeVarint(ze(7, 1))
          }
        }

        function Ae(ge, V) {
          const U = typeof ge;
          U === "string" ? V.writeStringField(1, ge) : U === "boolean" ? V.writeBooleanField(7, ge) : U === "number" && (ge % 1 != 0 ? V.writeDoubleField(3, ge) : ge < 0 ? V.writeSVarintField(6, ge) : V.writeVarintField(5, ge))
        }
        const Me = {
            minZoom: 0,
            maxZoom: 16,
            minPoints: 2,
            radius: 40,
            extent: 512,
            nodeSize: 64,
            log: !1,
            generateId: !1,
            reduce: null,
            map: ge => ge
          },
          Ee = Math.fround || (Qe = new Float32Array(1), ge => (Qe[0] = +ge, Qe[0]));
        var Qe;
        class Ue {
          constructor(V) {
            this.options = Object.assign(Object.create(Me), V), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = []
          }
          load(V) {
            const {
              log: U,
              minZoom: J,
              maxZoom: se
            } = this.options;
            U && console.time("total time");
            const te = `prepare ${V.length} points`;
            U && console.time(te), this.points = V;
            const _e = [];
            for (let ne = 0; ne < V.length; ne++) {
              const oe = V[ne];
              if (!oe.geometry) continue;
              const [fe, ve] = oe.geometry.coordinates, ie = Ee(_t(fe)), Y = Ee(dt(ve));
              _e.push(ie, Y, 1 / 0, ne, -1, 1), this.options.reduce && _e.push(0)
            }
            let Re = this.trees[se + 1] = this._createTree(_e);
            U && console.timeEnd(te);
            for (let ne = se; ne >= J; ne--) {
              const oe = +Date.now();
              Re = this.trees[ne] = this._createTree(this._cluster(Re, ne)), U && console.log("z%d: %d clusters in %dms", ne, Re.numItems, +Date.now() - oe)
            }
            return U && console.timeEnd("total time"), this
          }
          getClusters(V, U) {
            let J = ((V[0] + 180) % 360 + 360) % 360 - 180;
            const se = Math.max(-90, Math.min(90, V[1]));
            let te = V[2] === 180 ? 180 : ((V[2] + 180) % 360 + 360) % 360 - 180;
            const _e = Math.max(-90, Math.min(90, V[3]));
            if (V[2] - V[0] >= 360) J = -180, te = 180;
            else if (J > te) {
              const ve = this.getClusters([J, se, 180, _e], U),
                ie = this.getClusters([-180, se, te, _e], U);
              return ve.concat(ie)
            }
            const Re = this.trees[this._limitZoom(U)],
              ne = Re.range(_t(J), dt(_e), _t(te), dt(se)),
              oe = Re.data,
              fe = [];
            for (const ve of ne) {
              const ie = this.stride * ve;
              fe.push(oe[ie + 5] > 1 ? je(oe, ie, this.clusterProps) : this.points[oe[ie + 3]])
            }
            return fe
          }
          getChildren(V) {
            const U = this._getOriginId(V),
              J = this._getOriginZoom(V),
              se = "No cluster with the specified id.",
              te = this.trees[J];
            if (!te) throw new Error(se);
            const _e = te.data;
            if (U * this.stride >= _e.length) throw new Error(se);
            const Re = this.options.radius / (this.options.extent * Math.pow(2, J - 1)),
              ne = te.within(_e[U * this.stride], _e[U * this.stride + 1], Re),
              oe = [];
            for (const fe of ne) {
              const ve = fe * this.stride;
              _e[ve + 4] === V && oe.push(_e[ve + 5] > 1 ? je(_e, ve, this.clusterProps) : this.points[_e[ve + 3]])
            }
            if (oe.length === 0) throw new Error(se);
            return oe
          }
          getLeaves(V, U, J) {
            const se = [];
            return this._appendLeaves(se, V, U = U || 10, J = J || 0, 0), se
          }
          getTile(V, U, J) {
            const se = this.trees[this._limitZoom(V)],
              te = Math.pow(2, V),
              {
                extent: _e,
                radius: Re
              } = this.options,
              ne = Re / _e,
              oe = (J - ne) / te,
              fe = (J + 1 + ne) / te,
              ve = {
                features: []
              };
            return this._addTileFeatures(se.range((U - ne) / te, oe, (U + 1 + ne) / te, fe), se.data, U, J, te, ve), U === 0 && this._addTileFeatures(se.range(1 - ne / te, oe, 1, fe), se.data, te, J, te, ve), U === te - 1 && this._addTileFeatures(se.range(0, oe, ne / te, fe), se.data, -1, J, te, ve), ve.features.length ? ve : null
          }
          getClusterExpansionZoom(V) {
            let U = this._getOriginZoom(V) - 1;
            for (; U <= this.options.maxZoom;) {
              const J = this.getChildren(V);
              if (U++, J.length !== 1) break;
              V = J[0].properties.cluster_id
            }
            return U
          }
          _appendLeaves(V, U, J, se, te) {
            const _e = this.getChildren(U);
            for (const Re of _e) {
              const ne = Re.properties;
              if (ne && ne.cluster ? te + ne.point_count <= se ? te += ne.point_count : te = this._appendLeaves(V, ne.cluster_id, J, se, te) : te < se ? te++ : V.push(Re), V.length === J) break
            }
            return te
          }
          _createTree(V) {
            const U = new T.aM(V.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let J = 0; J < V.length; J += this.stride) U.add(V[J], V[J + 1]);
            return U.finish(), U.data = V, U
          }
          _addTileFeatures(V, U, J, se, te, _e) {
            for (const Re of V) {
              const ne = Re * this.stride,
                oe = U[ne + 5] > 1;
              let fe, ve, ie;
              if (oe) fe = rt(U, ne, this.clusterProps), ve = U[ne], ie = U[ne + 1];
              else {
                const Ne = this.points[U[ne + 3]];
                fe = Ne.properties;
                const [Ge, pe] = Ne.geometry.coordinates;
                ve = _t(Ge), ie = dt(pe)
              }
              const Y = {
                type: 1,
                geometry: [
                  [Math.round(this.options.extent * (ve * te - J)), Math.round(this.options.extent * (ie * te - se))]
                ],
                tags: fe
              };
              let Fe;
              Fe = oe || this.options.generateId ? U[ne + 3] : this.points[U[ne + 3]].id, Fe !== void 0 && (Y.id = Fe), _e.features.push(Y)
            }
          }
          _limitZoom(V) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+V), this.options.maxZoom + 1))
          }
          _cluster(V, U) {
            const {
              radius: J,
              extent: se,
              reduce: te,
              minPoints: _e
            } = this.options, Re = J / (se * Math.pow(2, U)), ne = V.data, oe = [], fe = this.stride;
            for (let ve = 0; ve < ne.length; ve += fe) {
              if (ne[ve + 2] <= U) continue;
              ne[ve + 2] = U;
              const ie = ne[ve],
                Y = ne[ve + 1],
                Fe = V.within(ne[ve], ne[ve + 1], Re),
                Ne = ne[ve + 5];
              let Ge = Ne;
              for (const pe of Fe) {
                const Ve = pe * fe;
                ne[Ve + 2] > U && (Ge += ne[Ve + 5])
              }
              if (Ge > Ne && Ge >= _e) {
                let pe, Ve = ie * Ne,
                  it = Y * Ne,
                  yt = -1;
                const Lt = (ve / fe << 5) + (U + 1) + this.points.length;
                for (const ct of Fe) {
                  const At = ct * fe;
                  if (ne[At + 2] <= U) continue;
                  ne[At + 2] = U;
                  const qt = ne[At + 5];
                  Ve += ne[At] * qt, it += ne[At + 1] * qt, ne[At + 4] = Lt, te && (pe || (pe = this._map(ne, ve, !0), yt = this.clusterProps.length, this.clusterProps.push(pe)), te(pe, this._map(ne, At)))
                }
                ne[ve + 4] = Lt, oe.push(Ve / Ge, it / Ge, 1 / 0, Lt, -1, Ge), te && oe.push(yt)
              } else {
                for (let pe = 0; pe < fe; pe++) oe.push(ne[ve + pe]);
                if (Ge > 1)
                  for (const pe of Fe) {
                    const Ve = pe * fe;
                    if (!(ne[Ve + 2] <= U)) {
                      ne[Ve + 2] = U;
                      for (let it = 0; it < fe; it++) oe.push(ne[Ve + it])
                    }
                  }
              }
            }
            return oe
          }
          _getOriginId(V) {
            return V - this.points.length >> 5
          }
          _getOriginZoom(V) {
            return (V - this.points.length) % 32
          }
          _map(V, U, J) {
            if (V[U + 5] > 1) {
              const _e = this.clusterProps[V[U + 6]];
              return J ? Object.assign({}, _e) : _e
            }
            const se = this.points[V[U + 3]].properties,
              te = this.options.map(se);
            return J && te === se ? Object.assign({}, te) : te
          }
        }

        function je(ge, V, U) {
          return {
            type: "Feature",
            id: ge[V + 3],
            properties: rt(ge, V, U),
            geometry: {
              type: "Point",
              coordinates: [(J = ge[V], 360 * (J - .5)), at(ge[V + 1])]
            }
          };
          var J
        }

        function rt(ge, V, U) {
          const J = ge[V + 5],
            se = J >= 1e4 ? `${Math.round(J/1e3)}k` : J >= 1e3 ? Math.round(J / 100) / 10 + "k" : J,
            te = ge[V + 6],
            _e = te === -1 ? {} : Object.assign({}, U[te]);
          return Object.assign(_e, {
            cluster: !0,
            cluster_id: ge[V + 3],
            point_count: J,
            point_count_abbreviated: se
          })
        }

        function _t(ge) {
          return ge / 360 + .5
        }

        function dt(ge) {
          const V = Math.sin(ge * Math.PI / 180),
            U = .5 - .25 * Math.log((1 + V) / (1 - V)) / Math.PI;
          return U < 0 ? 0 : U > 1 ? 1 : U
        }

        function at(ge) {
          const V = (180 - 360 * ge) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(V)) / Math.PI - 90
        }

        function nt(ge, V, U, J) {
          let se = J;
          const te = V + (U - V >> 1);
          let _e, Re = U - V;
          const ne = ge[V],
            oe = ge[V + 1],
            fe = ge[U],
            ve = ge[U + 1];
          for (let ie = V + 3; ie < U; ie += 3) {
            const Y = ot(ge[ie], ge[ie + 1], ne, oe, fe, ve);
            if (Y > se) _e = ie, se = Y;
            else if (Y === se) {
              const Fe = Math.abs(ie - te);
              Fe < Re && (_e = ie, Re = Fe)
            }
          }
          se > J && (_e - V > 3 && nt(ge, V, _e, J), ge[_e + 2] = se, U - _e > 3 && nt(ge, _e, U, J))
        }

        function ot(ge, V, U, J, se, te) {
          let _e = se - U,
            Re = te - J;
          if (_e !== 0 || Re !== 0) {
            const ne = ((ge - U) * _e + (V - J) * Re) / (_e * _e + Re * Re);
            ne > 1 ? (U = se, J = te) : ne > 0 && (U += _e * ne, J += Re * ne)
          }
          return _e = ge - U, Re = V - J, _e * _e + Re * Re
        }

        function ut(ge, V, U, J) {
          const se = {
            id: ge ?? null,
            type: V,
            geometry: U,
            tags: J,
            minX: 1 / 0,
            minY: 1 / 0,
            maxX: -1 / 0,
            maxY: -1 / 0
          };
          if (V === "Point" || V === "MultiPoint" || V === "LineString") st(se, U);
          else if (V === "Polygon") st(se, U[0]);
          else if (V === "MultiLineString")
            for (const te of U) st(se, te);
          else if (V === "MultiPolygon")
            for (const te of U) st(se, te[0]);
          return se
        }

        function st(ge, V) {
          for (let U = 0; U < V.length; U += 3) ge.minX = Math.min(ge.minX, V[U]), ge.minY = Math.min(ge.minY, V[U + 1]), ge.maxX = Math.max(ge.maxX, V[U]), ge.maxY = Math.max(ge.maxY, V[U + 1])
        }

        function wt(ge, V, U, J) {
          if (!V.geometry) return;
          const se = V.geometry.coordinates;
          if (se && se.length === 0) return;
          const te = V.geometry.type,
            _e = Math.pow(U.tolerance / ((1 << U.maxZoom) * U.extent), 2);
          let Re = [],
            ne = V.id;
          if (U.promoteId ? ne = V.properties[U.promoteId] : U.generateId && (ne = J || 0), te === "Point") Ct(se, Re);
          else if (te === "MultiPoint")
            for (const oe of se) Ct(oe, Re);
          else if (te === "LineString") rr(se, Re, _e, !1);
          else if (te === "MultiLineString") {
            if (U.lineMetrics) {
              for (const oe of se) Re = [], rr(oe, Re, _e, !1), ge.push(ut(ne, "LineString", Re, V.properties));
              return
            }
            Zt(se, Re, _e, !1)
          } else if (te === "Polygon") Zt(se, Re, _e, !0);
          else {
            if (te !== "MultiPolygon") {
              if (te === "GeometryCollection") {
                for (const oe of V.geometry.geometries) wt(ge, {
                  id: ne,
                  geometry: oe,
                  properties: V.properties
                }, U, J);
                return
              }
              throw new Error("Input data is not a valid GeoJSON object.")
            }
            for (const oe of se) {
              const fe = [];
              Zt(oe, fe, _e, !0), Re.push(fe)
            }
          }
          ge.push(ut(ne, te, Re, V.properties))
        }

        function Ct(ge, V) {
          V.push(lt(ge[0]), ht(ge[1]), 0)
        }

        function rr(ge, V, U, J) {
          let se, te, _e = 0;
          for (let ne = 0; ne < ge.length; ne++) {
            const oe = lt(ge[ne][0]),
              fe = ht(ge[ne][1]);
            V.push(oe, fe, 0), ne > 0 && (_e += J ? (se * fe - oe * te) / 2 : Math.sqrt(Math.pow(oe - se, 2) + Math.pow(fe - te, 2))), se = oe, te = fe
          }
          const Re = V.length - 3;
          V[2] = 1, nt(V, 0, Re, U), V[Re + 2] = 1, V.size = Math.abs(_e), V.start = 0, V.end = V.size
        }

        function Zt(ge, V, U, J) {
          for (let se = 0; se < ge.length; se++) {
            const te = [];
            rr(ge[se], te, U, J), V.push(te)
          }
        }

        function lt(ge) {
          return ge / 360 + .5
        }

        function ht(ge) {
          const V = Math.sin(ge * Math.PI / 180),
            U = .5 - .25 * Math.log((1 + V) / (1 - V)) / Math.PI;
          return U < 0 ? 0 : U > 1 ? 1 : U
        }

        function Dt(ge, V, U, J, se, te, _e, Re) {
          if (J /= V, te >= (U /= V) && _e < J) return ge;
          if (_e < U || te >= J) return null;
          const ne = [];
          for (const oe of ge) {
            const fe = oe.geometry;
            let ve = oe.type;
            const ie = se === 0 ? oe.minX : oe.minY,
              Y = se === 0 ? oe.maxX : oe.maxY;
            if (ie >= U && Y < J) {
              ne.push(oe);
              continue
            }
            if (Y < U || ie >= J) continue;
            let Fe = [];
            if (ve === "Point" || ve === "MultiPoint") Vt(fe, Fe, U, J, se);
            else if (ve === "LineString") Jt(fe, Fe, U, J, se, !1, Re.lineMetrics);
            else if (ve === "MultiLineString") nr(fe, Fe, U, J, se, !1);
            else if (ve === "Polygon") nr(fe, Fe, U, J, se, !0);
            else if (ve === "MultiPolygon")
              for (const Ne of fe) {
                const Ge = [];
                nr(Ne, Ge, U, J, se, !0), Ge.length && Fe.push(Ge)
              }
            if (Fe.length) {
              if (Re.lineMetrics && ve === "LineString") {
                for (const Ne of Fe) ne.push(ut(oe.id, ve, Ne, oe.tags));
                continue
              }
              ve !== "LineString" && ve !== "MultiLineString" || (Fe.length === 1 ? (ve = "LineString", Fe = Fe[0]) : ve = "MultiLineString"), ve !== "Point" && ve !== "MultiPoint" || (ve = Fe.length === 3 ? "Point" : "MultiPoint"), ne.push(ut(oe.id, ve, Fe, oe.tags))
            }
          }
          return ne.length ? ne : null
        }

        function Vt(ge, V, U, J, se) {
          for (let te = 0; te < ge.length; te += 3) {
            const _e = ge[te + se];
            _e >= U && _e <= J && St(V, ge[te], ge[te + 1], ge[te + 2])
          }
        }

        function Jt(ge, V, U, J, se, te, _e) {
          let Re = jt(ge);
          const ne = se === 0 ? Et : Ut;
          let oe, fe, ve = ge.start;
          for (let Ge = 0; Ge < ge.length - 3; Ge += 3) {
            const pe = ge[Ge],
              Ve = ge[Ge + 1],
              it = ge[Ge + 2],
              yt = ge[Ge + 3],
              Lt = ge[Ge + 4],
              ct = se === 0 ? pe : Ve,
              At = se === 0 ? yt : Lt;
            let qt = !1;
            _e && (oe = Math.sqrt(Math.pow(pe - yt, 2) + Math.pow(Ve - Lt, 2))), ct < U ? At > U && (fe = ne(Re, pe, Ve, yt, Lt, U), _e && (Re.start = ve + oe * fe)) : ct > J ? At < J && (fe = ne(Re, pe, Ve, yt, Lt, J), _e && (Re.start = ve + oe * fe)) : St(Re, pe, Ve, it), At < U && ct >= U && (fe = ne(Re, pe, Ve, yt, Lt, U), qt = !0), At > J && ct <= J && (fe = ne(Re, pe, Ve, yt, Lt, J), qt = !0), !te && qt && (_e && (Re.end = ve + oe * fe), V.push(Re), Re = jt(ge)), _e && (ve += oe)
          }
          let ie = ge.length - 3;
          const Y = ge[ie],
            Fe = ge[ie + 1],
            Ne = se === 0 ? Y : Fe;
          Ne >= U && Ne <= J && St(Re, Y, Fe, ge[ie + 2]), ie = Re.length - 3, te && ie >= 3 && (Re[ie] !== Re[0] || Re[ie + 1] !== Re[1]) && St(Re, Re[0], Re[1], Re[2]), Re.length && V.push(Re)
        }

        function jt(ge) {
          const V = [];
          return V.size = ge.size, V.start = ge.start, V.end = ge.end, V
        }

        function nr(ge, V, U, J, se, te) {
          for (const _e of ge) Jt(_e, V, U, J, se, te, !1)
        }

        function St(ge, V, U, J) {
          ge.push(V, U, J)
        }

        function Et(ge, V, U, J, se, te) {
          const _e = (te - V) / (J - V);
          return St(ge, te, U + (se - U) * _e, 1), _e
        }

        function Ut(ge, V, U, J, se, te) {
          const _e = (te - U) / (se - U);
          return St(ge, V + (J - V) * _e, te, 1), _e
        }

        function Gt(ge, V) {
          const U = [];
          for (let J = 0; J < ge.length; J++) {
            const se = ge[J],
              te = se.type;
            let _e;
            if (te === "Point" || te === "MultiPoint" || te === "LineString") _e = Rt(se.geometry, V);
            else if (te === "MultiLineString" || te === "Polygon") {
              _e = [];
              for (const Re of se.geometry) _e.push(Rt(Re, V))
            } else if (te === "MultiPolygon") {
              _e = [];
              for (const Re of se.geometry) {
                const ne = [];
                for (const oe of Re) ne.push(Rt(oe, V));
                _e.push(ne)
              }
            }
            U.push(ut(se.id, te, _e, se.tags))
          }
          return U
        }

        function Rt(ge, V) {
          const U = [];
          U.size = ge.size, ge.start !== void 0 && (U.start = ge.start, U.end = ge.end);
          for (let J = 0; J < ge.length; J += 3) U.push(ge[J] + V, ge[J + 1], ge[J + 2]);
          return U
        }

        function ir(ge, V) {
          if (ge.transformed) return ge;
          const U = 1 << ge.z,
            J = ge.x,
            se = ge.y;
          for (const te of ge.features) {
            const _e = te.geometry,
              Re = te.type;
            if (te.geometry = [], Re === 1)
              for (let ne = 0; ne < _e.length; ne += 2) te.geometry.push(kr(_e[ne], _e[ne + 1], V, U, J, se));
            else
              for (let ne = 0; ne < _e.length; ne++) {
                const oe = [];
                for (let fe = 0; fe < _e[ne].length; fe += 2) oe.push(kr(_e[ne][fe], _e[ne][fe + 1], V, U, J, se));
                te.geometry.push(oe)
              }
          }
          return ge.transformed = !0, ge
        }

        function kr(ge, V, U, J, se, te) {
          return [Math.round(U * (ge * J - se)), Math.round(U * (V * J - te))]
        }

        function _r(ge, V, U, J, se) {
          const te = V === se.maxZoom ? 0 : se.tolerance / ((1 << V) * se.extent),
            _e = {
              features: [],
              numPoints: 0,
              numSimplified: 0,
              numFeatures: ge.length,
              source: null,
              x: U,
              y: J,
              z: V,
              transformed: !1,
              minX: 2,
              minY: 1,
              maxX: -1,
              maxY: 0
            };
          for (const Re of ge) fr(_e, Re, te, se);
          return _e
        }

        function fr(ge, V, U, J) {
          const se = V.geometry,
            te = V.type,
            _e = [];
          if (ge.minX = Math.min(ge.minX, V.minX), ge.minY = Math.min(ge.minY, V.minY), ge.maxX = Math.max(ge.maxX, V.maxX), ge.maxY = Math.max(ge.maxY, V.maxY), te === "Point" || te === "MultiPoint")
            for (let Re = 0; Re < se.length; Re += 3) _e.push(se[Re], se[Re + 1]), ge.numPoints++, ge.numSimplified++;
          else if (te === "LineString") Yt(_e, se, ge, U, !1, !1);
          else if (te === "MultiLineString" || te === "Polygon")
            for (let Re = 0; Re < se.length; Re++) Yt(_e, se[Re], ge, U, te === "Polygon", Re === 0);
          else if (te === "MultiPolygon")
            for (let Re = 0; Re < se.length; Re++) {
              const ne = se[Re];
              for (let oe = 0; oe < ne.length; oe++) Yt(_e, ne[oe], ge, U, !0, oe === 0)
            }
          if (_e.length) {
            let Re = V.tags || null;
            if (te === "LineString" && J.lineMetrics) {
              Re = {};
              for (const oe in V.tags) Re[oe] = V.tags[oe];
              Re.mapbox_clip_start = se.start / se.size, Re.mapbox_clip_end = se.end / se.size
            }
            const ne = {
              geometry: _e,
              type: te === "Polygon" || te === "MultiPolygon" ? 3 : te === "LineString" || te === "MultiLineString" ? 2 : 1,
              tags: Re
            };
            V.id !== null && (ne.id = V.id), ge.features.push(ne)
          }
        }

        function Yt(ge, V, U, J, se, te) {
          const _e = J * J;
          if (J > 0 && V.size < (se ? _e : J)) return void(U.numPoints += V.length / 3);
          const Re = [];
          for (let ne = 0; ne < V.length; ne += 3)(J === 0 || V[ne + 2] > _e) && (U.numSimplified++, Re.push(V[ne], V[ne + 1])), U.numPoints++;
          se && (function(ne, oe) {
            let fe = 0;
            for (let ve = 0, ie = ne.length, Y = ie - 2; ve < ie; Y = ve, ve += 2) fe += (ne[ve] - ne[Y]) * (ne[ve + 1] + ne[Y + 1]);
            if (fe > 0 === oe)
              for (let ve = 0, ie = ne.length; ve < ie / 2; ve += 2) {
                const Y = ne[ve],
                  Fe = ne[ve + 1];
                ne[ve] = ne[ie - 2 - ve], ne[ve + 1] = ne[ie - 1 - ve], ne[ie - 2 - ve] = Y, ne[ie - 1 - ve] = Fe
              }
          })(Re, te), ge.push(Re)
        }
        const sr = {
          maxZoom: 14,
          indexMaxZoom: 5,
          indexMaxPoints: 1e5,
          tolerance: 3,
          extent: 4096,
          buffer: 64,
          lineMetrics: !1,
          promoteId: null,
          generateId: !1,
          debug: 0
        };
        class Kt {
          constructor(V, U) {
            const J = (U = this.options = (function(te, _e) {
              for (const Re in _e) te[Re] = _e[Re];
              return te
            })(Object.create(sr), U)).debug;
            if (J && console.time("preprocess data"), U.maxZoom < 0 || U.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (U.promoteId && U.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let se = (function(te, _e) {
              const Re = [];
              if (te.type === "FeatureCollection")
                for (let ne = 0; ne < te.features.length; ne++) wt(Re, te.features[ne], _e, ne);
              else wt(Re, te.type === "Feature" ? te : {
                geometry: te
              }, _e);
              return Re
            })(V, U);
            this.tiles = {}, this.tileCoords = [], J && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", U.indexMaxZoom, U.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), se = (function(te, _e) {
              const Re = _e.buffer / _e.extent;
              let ne = te;
              const oe = Dt(te, 1, -1 - Re, Re, 0, -1, 2, _e),
                fe = Dt(te, 1, 1 - Re, 2 + Re, 0, -1, 2, _e);
              return (oe || fe) && (ne = Dt(te, 1, -Re, 1 + Re, 0, -1, 2, _e) || [], oe && (ne = Gt(oe, 1).concat(ne)), fe && (ne = ne.concat(Gt(fe, -1)))), ne
            })(se, U), se.length && this.splitTile(se, 0, 0, 0), J && (se.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)))
          }
          splitTile(V, U, J, se, te, _e, Re) {
            const ne = [V, U, J, se],
              oe = this.options,
              fe = oe.debug;
            for (; ne.length;) {
              se = ne.pop(), J = ne.pop(), U = ne.pop(), V = ne.pop();
              const ve = 1 << U,
                ie = vr(U, J, se);
              let Y = this.tiles[ie];
              if (!Y && (fe > 1 && console.time("creation"), Y = this.tiles[ie] = _r(V, U, J, se, oe), this.tileCoords.push({
                  z: U,
                  x: J,
                  y: se
                }), fe)) {
                fe > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", U, J, se, Y.numFeatures, Y.numPoints, Y.numSimplified), console.timeEnd("creation"));
                const qt = `z${U}`;
                this.stats[qt] = (this.stats[qt] || 0) + 1, this.total++
              }
              if (Y.source = V, te == null) {
                if (U === oe.indexMaxZoom || Y.numPoints <= oe.indexMaxPoints) continue
              } else {
                if (U === oe.maxZoom || U === te) continue;
                if (te != null) {
                  const qt = te - U;
                  if (J !== _e >> qt || se !== Re >> qt) continue
                }
              }
              if (Y.source = null, V.length === 0) continue;
              fe > 1 && console.time("clipping");
              const Fe = .5 * oe.buffer / oe.extent,
                Ne = .5 - Fe,
                Ge = .5 + Fe,
                pe = 1 + Fe;
              let Ve = null,
                it = null,
                yt = null,
                Lt = null,
                ct = Dt(V, ve, J - Fe, J + Ge, 0, Y.minX, Y.maxX, oe),
                At = Dt(V, ve, J + Ne, J + pe, 0, Y.minX, Y.maxX, oe);
              V = null, ct && (Ve = Dt(ct, ve, se - Fe, se + Ge, 1, Y.minY, Y.maxY, oe), it = Dt(ct, ve, se + Ne, se + pe, 1, Y.minY, Y.maxY, oe), ct = null), At && (yt = Dt(At, ve, se - Fe, se + Ge, 1, Y.minY, Y.maxY, oe), Lt = Dt(At, ve, se + Ne, se + pe, 1, Y.minY, Y.maxY, oe), At = null), fe > 1 && console.timeEnd("clipping"), ne.push(Ve || [], U + 1, 2 * J, 2 * se), ne.push(it || [], U + 1, 2 * J, 2 * se + 1), ne.push(yt || [], U + 1, 2 * J + 1, 2 * se), ne.push(Lt || [], U + 1, 2 * J + 1, 2 * se + 1)
            }
          }
          getTile(V, U, J) {
            V = +V, U = +U, J = +J;
            const se = this.options,
              {
                extent: te,
                debug: _e
              } = se;
            if (V < 0 || V > 24) return null;
            const Re = 1 << V,
              ne = vr(V, U = U + Re & Re - 1, J);
            if (this.tiles[ne]) return ir(this.tiles[ne], te);
            _e > 1 && console.log("drilling down to z%d-%d-%d", V, U, J);
            let oe, fe = V,
              ve = U,
              ie = J;
            for (; !oe && fe > 0;) fe--, ve >>= 1, ie >>= 1, oe = this.tiles[vr(fe, ve, ie)];
            return oe && oe.source ? (_e > 1 && (console.log("found parent tile z%d-%d-%d", fe, ve, ie), console.time("drilling down")), this.splitTile(oe.source, fe, ve, ie, V, U, J), _e > 1 && console.timeEnd("drilling down"), this.tiles[ne] ? ir(this.tiles[ne], te) : null) : null
          }
        }

        function vr(ge, V, U) {
          return 32 * ((1 << ge) * U + V) + ge
        }
        class Lr extends G {
          constructor(V, U, J, se = ii) {
            super(V, U, J), this._dataUpdateable = new Map, this._createGeoJSONIndex = se
          }
          loadVectorTile(V, U) {
            return T._(this, void 0, void 0, (function*() {
              const J = V.tileID.canonical;
              if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
              const se = this._geoJSONIndex.getTile(J.z, J.x, J.y);
              if (!se) return null;
              const te = new qe(se.features, {
                version: 2,
                extent: T.a3
              });
              let _e = (function(Re) {
                const ne = new T.cP;
                return (function(oe, fe) {
                  for (const ve in oe.layers) fe.writeMessage(3, xe, oe.layers[ve])
                })(Re, ne), ne.finish()
              })(te);
              return _e.byteOffset === 0 && _e.byteLength === _e.buffer.byteLength || (_e = new Uint8Array(_e)), {
                vectorTile: te,
                rawData: _e.buffer
              }
            }))
          }
          loadData(V) {
            return T._(this, void 0, void 0, (function*() {
              var U;
              (U = this._pendingRequest) === null || U === void 0 || U.abort();
              const J = !!(V && V.request && V.request.collectResourceTiming) && new T.cQ(V.request);
              this._pendingRequest = new AbortController;
              try {
                (!this._pendingData || V.request || V.data || V.dataDiff) && (this._pendingData = this.loadAndProcessGeoJSON(V, this._pendingRequest));
                const se = yield this._pendingData;
                this._geoJSONIndex = this._createGeoJSONIndex(se, V), this.loaded = {};
                const te = {
                  data: se
                };
                if (J) {
                  const _e = J.finish();
                  _e && (te.resourceTiming = {}, te.resourceTiming[V.source] = JSON.parse(JSON.stringify(_e)))
                }
                return te
              } catch (se) {
                if (delete this._pendingRequest, T.cB(se)) return {
                  abandoned: !0
                };
                throw se
              }
            }))
          }
          getData() {
            return T._(this, void 0, void 0, (function*() {
              return this._pendingData
            }))
          }
          reloadTile(V) {
            const U = this.loaded;
            return U && U[V.uid] ? super.reloadTile(V) : this.loadTile(V)
          }
          loadAndProcessGeoJSON(V, U) {
            return T._(this, void 0, void 0, (function*() {
              let J = yield this.loadGeoJSON(V, U);
              if (delete this._pendingRequest, typeof J != "object") throw new Error(`Input data given to '${V.source}' is not a valid GeoJSON object.`);
              if (ye(J, !0), V.filter) {
                const se = T.cW(V.filter, {
                  type: "boolean",
                  "property-type": "data-driven",
                  overridable: !1,
                  transition: !1
                });
                if (se.result === "error") throw new Error(se.value.map((_e => `${_e.key}: ${_e.message}`)).join(", "));
                J = {
                  type: "FeatureCollection",
                  features: J.features.filter((_e => se.value.evaluate({
                    zoom: 0
                  }, _e)))
                }
              }
              return J
            }))
          }
          loadGeoJSON(V, U) {
            return T._(this, void 0, void 0, (function*() {
              const {
                promoteId: J
              } = V;
              if (V.request) {
                const se = yield T.j(V.request, U);
                return this._dataUpdateable = T.cY(se.data, J) ? T.cX(se.data, J) : void 0, se.data
              }
              if (typeof V.data == "string") try {
                const se = JSON.parse(V.data);
                return this._dataUpdateable = T.cY(se, J) ? T.cX(se, J) : void 0, se
              } catch {
                throw new Error(`Input data given to '${V.source}' is not a valid GeoJSON object.`)
              }
              if (!V.dataDiff) throw new Error(`Input data given to '${V.source}' is not a valid GeoJSON object.`);
              if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${V.source}`);
              return T.cZ(this._dataUpdateable, V.dataDiff, J), {
                type: "FeatureCollection",
                features: Array.from(this._dataUpdateable.values())
              }
            }))
          }
          removeSource(V) {
            return T._(this, void 0, void 0, (function*() {
              this._pendingRequest && this._pendingRequest.abort()
            }))
          }
          getClusterExpansionZoom(V) {
            return this._geoJSONIndex.getClusterExpansionZoom(V.clusterId)
          }
          getClusterChildren(V) {
            return this._geoJSONIndex.getChildren(V.clusterId)
          }
          getClusterLeaves(V) {
            return this._geoJSONIndex.getLeaves(V.clusterId, V.limit, V.offset)
          }
        }

        function ii(ge, V) {
          return V.cluster ? new Ue((function({
            superclusterOptions: U,
            clusterProperties: J
          }) {
            if (!J || !U) return U;
            const se = {},
              te = {},
              _e = {
                accumulated: null,
                zoom: 0
              },
              Re = {
                properties: null
              },
              ne = Object.keys(J);
            for (const oe of ne) {
              const [fe, ve] = J[oe], ie = T.cW(ve), Y = T.cW(typeof fe == "string" ? [fe, ["accumulated"],
                ["get", oe]
              ] : fe);
              se[oe] = ie.value, te[oe] = Y.value
            }
            return U.map = oe => {
              Re.properties = oe;
              const fe = {};
              for (const ve of ne) fe[ve] = se[ve].evaluate(_e, Re);
              return fe
            }, U.reduce = (oe, fe) => {
              Re.properties = fe;
              for (const ve of ne) _e.accumulated = oe[ve], oe[ve] = te[ve].evaluate(_e, Re)
            }, U
          })(V)).load(ge.features) : (function(U, J) {
            return new Kt(U, J)
          })(ge, V.geojsonVtOptions)
        }
        class mr {
          constructor(V) {
            this.self = V, this.actor = new T.K(V), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.globalStates = new Map, this.self.registerWorkerSource = (U, J) => {
              if (this.externalWorkerSourceTypes[U]) throw new Error(`Worker source with name "${U}" already registered.`);
              this.externalWorkerSourceTypes[U] = J
            }, this.self.addProtocol = T.cD, this.self.removeProtocol = T.cE, this.self.registerRTLTextPlugin = U => {
              T.c_.setMethods(U)
            }, this.actor.registerMessageHandler("LDT", ((U, J) => this._getDEMWorkerSource(U, J.source).loadTile(J))), this.actor.registerMessageHandler("RDT", ((U, J) => T._(this, void 0, void 0, (function*() {
              this._getDEMWorkerSource(U, J.source).removeTile(J)
            })))), this.actor.registerMessageHandler("GCEZ", ((U, J) => T._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(U, J.type, J.source).getClusterExpansionZoom(J)
            })))), this.actor.registerMessageHandler("GCC", ((U, J) => T._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(U, J.type, J.source).getClusterChildren(J)
            })))), this.actor.registerMessageHandler("GCL", ((U, J) => T._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(U, J.type, J.source).getClusterLeaves(J)
            })))), this.actor.registerMessageHandler("LD", ((U, J) => this._getWorkerSource(U, J.type, J.source).loadData(J))), this.actor.registerMessageHandler("GD", ((U, J) => this._getWorkerSource(U, J.type, J.source).getData())), this.actor.registerMessageHandler("LT", ((U, J) => this._getWorkerSource(U, J.type, J.source).loadTile(J))), this.actor.registerMessageHandler("RT", ((U, J) => this._getWorkerSource(U, J.type, J.source).reloadTile(J))), this.actor.registerMessageHandler("AT", ((U, J) => this._getWorkerSource(U, J.type, J.source).abortTile(J))), this.actor.registerMessageHandler("RMT", ((U, J) => this._getWorkerSource(U, J.type, J.source).removeTile(J))), this.actor.registerMessageHandler("RS", ((U, J) => T._(this, void 0, void 0, (function*() {
              if (!this.workerSources[U] || !this.workerSources[U][J.type] || !this.workerSources[U][J.type][J.source]) return;
              const se = this.workerSources[U][J.type][J.source];
              delete this.workerSources[U][J.type][J.source], se.removeSource !== void 0 && se.removeSource(J)
            })))), this.actor.registerMessageHandler("RM", (U => T._(this, void 0, void 0, (function*() {
              delete this.layerIndexes[U], delete this.availableImages[U], delete this.workerSources[U], delete this.demWorkerSources[U], this.globalStates.delete(U)
            })))), this.actor.registerMessageHandler("SR", ((U, J) => T._(this, void 0, void 0, (function*() {
              this.referrer = J
            })))), this.actor.registerMessageHandler("SRPS", ((U, J) => this._syncRTLPluginState(U, J))), this.actor.registerMessageHandler("IS", ((U, J) => T._(this, void 0, void 0, (function*() {
              this.self.importScripts(J)
            })))), this.actor.registerMessageHandler("SI", ((U, J) => this._setImages(U, J))), this.actor.registerMessageHandler("UL", ((U, J) => T._(this, void 0, void 0, (function*() {
              this._getLayerIndex(U).update(J.layers, J.removedIds, this._getGlobalState(U))
            })))), this.actor.registerMessageHandler("UGS", ((U, J) => T._(this, void 0, void 0, (function*() {
              const se = this._getGlobalState(U);
              for (const te in J) se[te] = J[te]
            })))), this.actor.registerMessageHandler("SL", ((U, J) => T._(this, void 0, void 0, (function*() {
              this._getLayerIndex(U).replace(J, this._getGlobalState(U))
            }))))
          }
          _getGlobalState(V) {
            let U = this.globalStates.get(V);
            return U || (U = {}, this.globalStates.set(V, U)), U
          }
          _setImages(V, U) {
            return T._(this, void 0, void 0, (function*() {
              this.availableImages[V] = U;
              for (const J in this.workerSources[V]) {
                const se = this.workerSources[V][J];
                for (const te in se) se[te].availableImages = U
              }
            }))
          }
          _syncRTLPluginState(V, U) {
            return T._(this, void 0, void 0, (function*() {
              return yield T.c_.syncState(U, this.self.importScripts)
            }))
          }
          _getAvailableImages(V) {
            let U = this.availableImages[V];
            return U || (U = []), U
          }
          _getLayerIndex(V) {
            let U = this.layerIndexes[V];
            return U || (U = this.layerIndexes[V] = new s), U
          }
          _getWorkerSource(V, U, J) {
            if (this.workerSources[V] || (this.workerSources[V] = {}), this.workerSources[V][U] || (this.workerSources[V][U] = {}), !this.workerSources[V][U][J]) {
              const se = {
                sendAsync: (te, _e) => (te.targetMapId = V, this.actor.sendAsync(te, _e))
              };
              switch (U) {
                case "vector":
                  this.workerSources[V][U][J] = new G(se, this._getLayerIndex(V), this._getAvailableImages(V));
                  break;
                case "geojson":
                  this.workerSources[V][U][J] = new Lr(se, this._getLayerIndex(V), this._getAvailableImages(V));
                  break;
                default:
                  this.workerSources[V][U][J] = new this.externalWorkerSourceTypes[U](se, this._getLayerIndex(V), this._getAvailableImages(V))
              }
            }
            return this.workerSources[V][U][J]
          }
          _getDEMWorkerSource(V, U) {
            return this.demWorkerSources[V] || (this.demWorkerSources[V] = {}), this.demWorkerSources[V][U] || (this.demWorkerSources[V][U] = new re), this.demWorkerSources[V][U]
          }
        }
        return T.i(self) && (self.worker = new mr(self)), mr
      })), k("index", ["exports", "./shared"], (function(T, s) {
        var F = "5.11.0";

        function Z() {
          var d = new s.A(4);
          return s.A != Float32Array && (d[1] = 0, d[2] = 0), d[0] = 1, d[3] = 1, d
        }
        let K, G;
        const re = {
            frame(d, e, a) {
              const o = requestAnimationFrame((p => {
                  u(), e(p)
                })),
                {
                  unsubscribe: u
                } = s.s(d.signal, "abort", (() => {
                  u(), cancelAnimationFrame(o), a(s.c())
                }), !1)
            },
            frameAsync(d) {
              return new Promise(((e, a) => {
                this.frame(d, e, a)
              }))
            },
            getImageData(d, e = 0) {
              return this.getImageCanvasContext(d).getImageData(-e, -e, d.width + 2 * e, d.height + 2 * e)
            },
            getImageCanvasContext(d) {
              const e = window.document.createElement("canvas"),
                a = e.getContext("2d", {
                  willReadFrequently: !0
                });
              if (!a) throw new Error("failed to create canvas 2d context");
              return e.width = d.width, e.height = d.height, a.drawImage(d, 0, 0, d.width, d.height), a
            },
            resolveURL: d => (K || (K = document.createElement("a")), K.href = d, K.href),
            hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4,
            get prefersReducedMotion() {
              return !!matchMedia && (G == null && (G = matchMedia("(prefers-reduced-motion: reduce)")), G.matches)
            }
          },
          he = new class {
            constructor() {
              this._realTime = typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), this._frozenAt = null
            }
            getCurrentTime() {
              return this._frozenAt !== null ? this._frozenAt : this._realTime()
            }
            setNow(d) {
              this._frozenAt = d
            }
            restoreNow() {
              this._frozenAt = null
            }
            isFrozen() {
              return this._frozenAt !== null
            }
          };

        function me() {
          return he.getCurrentTime()
        }
        class q {
          static testProp(e) {
            if (!q.docStyle) return e[0];
            for (let a = 0; a < e.length; a++)
              if (e[a] in q.docStyle) return e[a];
            return e[0]
          }
          static create(e, a, o) {
            const u = window.document.createElement(e);
            return a !== void 0 && (u.className = a), o && o.appendChild(u), u
          }
          static createNS(e, a) {
            return window.document.createElementNS(e, a)
          }
          static disableDrag() {
            q.docStyle && q.selectProp && (q.userSelect = q.docStyle[q.selectProp], q.docStyle[q.selectProp] = "none")
          }
          static enableDrag() {
            q.docStyle && q.selectProp && (q.docStyle[q.selectProp] = q.userSelect)
          }
          static setTransform(e, a) {
            e.style[q.transformProp] = a
          }
          static addEventListener(e, a, o, u = {}) {
            e.addEventListener(a, o, "passive" in u ? u : u.capture)
          }
          static removeEventListener(e, a, o, u = {}) {
            e.removeEventListener(a, o, "passive" in u ? u : u.capture)
          }
          static suppressClickInternal(e) {
            e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", q.suppressClickInternal, !0)
          }
          static suppressClick() {
            window.addEventListener("click", q.suppressClickInternal, !0), window.setTimeout((() => {
              window.removeEventListener("click", q.suppressClickInternal, !0)
            }), 0)
          }
          static getScale(e) {
            const a = e.getBoundingClientRect();
            return {
              x: a.width / e.offsetWidth || 1,
              y: a.height / e.offsetHeight || 1,
              boundingClientRect: a
            }
          }
          static getPoint(e, a, o) {
            const u = a.boundingClientRect;
            return new s.P((o.clientX - u.left) / a.x - e.clientLeft, (o.clientY - u.top) / a.y - e.clientTop)
          }
          static mousePos(e, a) {
            const o = q.getScale(e);
            return q.getPoint(e, o, a)
          }
          static touchPos(e, a) {
            const o = [],
              u = q.getScale(e);
            for (let p = 0; p < a.length; p++) o.push(q.getPoint(e, u, a[p]));
            return o
          }
          static mouseButton(e) {
            return e.button
          }
          static remove(e) {
            e.parentNode && e.parentNode.removeChild(e)
          }
          static sanitize(e) {
            const a = new DOMParser().parseFromString(e, "text/html").body || document.createElement("body"),
              o = a.querySelectorAll("script");
            for (const u of o) u.remove();
            return q.clean(a), a.innerHTML
          }
          static isPossiblyDangerous(e, a) {
            const o = a.replace(/\s+/g, "").toLowerCase();
            return !(!["src", "href", "xlink:href"].includes(e) || !o.includes("javascript:") && !o.includes("data:")) || !!e.startsWith("on") || void 0
          }
          static clean(e) {
            const a = e.children;
            for (const o of a) q.removeAttributes(o), q.clean(o)
          }
          static removeAttributes(e) {
            for (const {
                name: a,
                value: o
              }
              of e.attributes) q.isPossiblyDangerous(a, o) && e.removeAttribute(a)
          }
        }
        q.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, q.selectProp = q.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), q.transformProp = q.testProp(["transform", "WebkitTransform"]);
        const ye = {
          supported: !1,
          testSupport: function(d) {
            !xe && qe && (Ye ? We(d) : be = d)
          }
        };
        let be, qe, xe = !1,
          Ye = !1;

        function We(d) {
          const e = d.createTexture();
          d.bindTexture(d.TEXTURE_2D, e);
          try {
            if (d.texImage2D(d.TEXTURE_2D, 0, d.RGBA, d.RGBA, d.UNSIGNED_BYTE, qe), d.isContextLost()) return;
            ye.supported = !0
          } catch {}
          d.deleteTexture(e), xe = !0
        }
        var ze;
        typeof document < "u" && (qe = document.createElement("img"), qe.onload = () => {
          be && We(be), be = null, Ye = !0
        }, qe.onerror = () => {
          xe = !0, be = null
        }, qe.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), (function(d) {
          let e, a, o, u;
          d.resetRequestQueue = () => {
            e = [], a = 0, o = 0, u = {}
          }, d.addThrottleControl = I => {
            const A = o++;
            return u[A] = I, A
          }, d.removeThrottleControl = I => {
            delete u[I], g()
          }, d.getImage = (I, A, L = !0) => new Promise(((O, R) => {
            ye.supported && (I.headers || (I.headers = {}), I.headers.accept = "image/webp,*/*"), s.e(I, {
              type: "image"
            }), e.push({
              abortController: A,
              requestParameters: I,
              supportImageRefresh: L,
              state: "queued",
              onError: H => {
                R(H)
              },
              onSuccess: H => {
                O(H)
              }
            }), g()
          }));
          const p = I => s._(this, void 0, void 0, (function*() {
              I.state = "running";
              const {
                requestParameters: A,
                supportImageRefresh: L,
                onError: O,
                onSuccess: R,
                abortController: H
              } = I, $ = L === !1 && !s.i(self) && !s.g(A.url) && (!A.headers || Object.keys(A.headers).reduce(((de, Ce) => de && Ce === "accept"), !0));
              a++;
              const ce = $ ? w(A, H) : s.m(A, H);
              try {
                const de = yield ce;
                delete I.abortController, I.state = "completed", de.data instanceof HTMLImageElement || s.b(de.data) ? R(de) : de.data && R({
                  data: yield(ue = de.data, typeof createImageBitmap == "function" ? s.f(ue) : s.h(ue)),
                  cacheControl: de.cacheControl,
                  expires: de.expires
                })
              } catch (de) {
                delete I.abortController, O(de)
              } finally {
                a--, g()
              }
              var ue
            })),
            g = () => {
              const I = (() => {
                for (const A of Object.keys(u))
                  if (u[A]()) return !0;
                return !1
              })() ? s.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : s.a.MAX_PARALLEL_IMAGE_REQUESTS;
              for (let A = a; A < I && e.length > 0; A++) {
                const L = e.shift();
                L.abortController.signal.aborted ? A-- : p(L)
              }
            },
            w = (I, A) => new Promise(((L, O) => {
              const R = new Image,
                H = I.url,
                $ = I.credentials;
              $ && $ === "include" ? R.crossOrigin = "use-credentials" : ($ && $ === "same-origin" || !s.d(H)) && (R.crossOrigin = "anonymous"), A.signal.addEventListener("abort", (() => {
                R.src = "", O(s.c())
              })), R.fetchPriority = "high", R.onload = () => {
                R.onerror = R.onload = null, L({
                  data: R
                })
              }, R.onerror = () => {
                R.onerror = R.onload = null, A.signal.aborted || O(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."))
              }, R.src = H
            }))
        })(ze || (ze = {})), ze.resetRequestQueue();
        class Se {
          constructor(e) {
            this._transformRequestFn = e ?? null
          }
          transformRequest(e, a) {
            return this._transformRequestFn && this._transformRequestFn(e, a) || {
              url: e
            }
          }
          setTransformRequest(e) {
            this._transformRequestFn = e
          }
        }

        function Pe(d) {
          const e = [];
          if (typeof d == "string") e.push({
            id: "default",
            url: d
          });
          else if (d && d.length > 0) {
            const a = [];
            for (const {
                id: o,
                url: u
              }
              of d) {
              const p = `${o}${u}`;
              a.indexOf(p) === -1 && (a.push(p), e.push({
                id: o,
                url: u
              }))
            }
          }
          return e
        }

        function Ae(d, e, a) {
          try {
            const o = new URL(d);
            return o.pathname += `${e}${a}`, o.toString()
          } catch {
            throw new Error(`Invalid sprite URL "${d}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`)
          }
        }

        function Me(d) {
          const {
            userImage: e
          } = d;
          return !!(e && e.render && e.render()) && (d.data.replace(new Uint8Array(e.data.buffer)), !0)
        }
        class Ee extends s.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new s.R({
              width: 1,
              height: 1
            }), this.dirty = !0
          }
          isLoaded() {
            return this.loaded
          }
          setLoaded(e) {
            if (this.loaded !== e && (this.loaded = e, e)) {
              for (const {
                  ids: a,
                  promiseResolve: o
                }
                of this.requestors) o(this._getImagesForIds(a));
              this.requestors = []
            }
          }
          getImage(e) {
            const a = this.images[e];
            if (a && !a.data && a.spriteData) {
              const o = a.spriteData;
              a.data = new s.R({
                width: o.width,
                height: o.height
              }, o.context.getImageData(o.x, o.y, o.width, o.height).data), a.spriteData = null
            }
            return a
          }
          addImage(e, a) {
            if (this.images[e]) throw new Error(`Image id ${e} already exist, use updateImage instead`);
            this._validate(e, a) && (this.images[e] = a)
          }
          _validate(e, a) {
            let o = !0;
            const u = a.data || a.spriteData;
            return this._validateStretch(a.stretchX, u && u.width) || (this.fire(new s.k(new Error(`Image "${e}" has invalid "stretchX" value`))), o = !1), this._validateStretch(a.stretchY, u && u.height) || (this.fire(new s.k(new Error(`Image "${e}" has invalid "stretchY" value`))), o = !1), this._validateContent(a.content, a) || (this.fire(new s.k(new Error(`Image "${e}" has invalid "content" value`))), o = !1), o
          }
          _validateStretch(e, a) {
            if (!e) return !0;
            let o = 0;
            for (const u of e) {
              if (u[0] < o || u[1] < u[0] || a < u[1]) return !1;
              o = u[1]
            }
            return !0
          }
          _validateContent(e, a) {
            if (!e) return !0;
            if (e.length !== 4) return !1;
            const o = a.spriteData,
              u = o && o.width || a.data.width,
              p = o && o.height || a.data.height;
            return !(e[0] < 0 || u < e[0] || e[1] < 0 || p < e[1] || e[2] < 0 || u < e[2] || e[3] < 0 || p < e[3] || e[2] < e[0] || e[3] < e[1])
          }
          updateImage(e, a, o = !0) {
            const u = this.getImage(e);
            if (o && (u.data.width !== a.data.width || u.data.height !== a.data.height)) throw new Error(`size mismatch between old image (${u.data.width}x${u.data.height}) and new image (${a.data.width}x${a.data.height}).`);
            a.version = u.version + 1, this.images[e] = a, this.updatedImages[e] = !0
          }
          removeImage(e) {
            const a = this.images[e];
            delete this.images[e], delete this.patterns[e], a.userImage && a.userImage.onRemove && a.userImage.onRemove()
          }
          listImages() {
            return Object.keys(this.images)
          }
          getImages(e) {
            return new Promise(((a, o) => {
              let u = !0;
              if (!this.isLoaded())
                for (const p of e) this.images[p] || (u = !1);
              this.isLoaded() || u ? a(this._getImagesForIds(e)) : this.requestors.push({
                ids: e,
                promiseResolve: a
              })
            }))
          }
          _getImagesForIds(e) {
            const a = {};
            for (const o of e) {
              let u = this.getImage(o);
              u || (this.fire(new s.l("styleimagemissing", {
                id: o
              })), u = this.getImage(o)), u ? a[o] = {
                data: u.data.clone(),
                pixelRatio: u.pixelRatio,
                sdf: u.sdf,
                version: u.version,
                stretchX: u.stretchX,
                stretchY: u.stretchY,
                content: u.content,
                textFitWidth: u.textFitWidth,
                textFitHeight: u.textFitHeight,
                hasRenderCallback: !!(u.userImage && u.userImage.render)
              } : s.w(`Image "${o}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`)
            }
            return a
          }
          getPixelSize() {
            const {
              width: e,
              height: a
            } = this.atlasImage;
            return {
              width: e,
              height: a
            }
          }
          getPattern(e) {
            const a = this.patterns[e],
              o = this.getImage(e);
            if (!o) return null;
            if (a && a.position.version === o.version) return a.position;
            if (a) a.position.version = o.version;
            else {
              const u = {
                  w: o.data.width + 2,
                  h: o.data.height + 2,
                  x: 0,
                  y: 0
                },
                p = new s.I(u, o);
              this.patterns[e] = {
                bin: u,
                position: p
              }
            }
            return this._updatePatternAtlas(), this.patterns[e].position
          }
          bind(e) {
            const a = e.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new s.T(e, this.atlasImage, a.RGBA), this.atlasTexture.bind(a.LINEAR, a.CLAMP_TO_EDGE)
          }
          _updatePatternAtlas() {
            const e = [];
            for (const p in this.patterns) e.push(this.patterns[p].bin);
            const {
              w: a,
              h: o
            } = s.p(e), u = this.atlasImage;
            u.resize({
              width: a || 1,
              height: o || 1
            });
            for (const p in this.patterns) {
              const {
                bin: g
              } = this.patterns[p], w = g.x + 1, I = g.y + 1, A = this.getImage(p).data, L = A.width, O = A.height;
              s.R.copy(A, u, {
                x: 0,
                y: 0
              }, {
                x: w,
                y: I
              }, {
                width: L,
                height: O
              }), s.R.copy(A, u, {
                x: 0,
                y: O - 1
              }, {
                x: w,
                y: I - 1
              }, {
                width: L,
                height: 1
              }), s.R.copy(A, u, {
                x: 0,
                y: 0
              }, {
                x: w,
                y: I + O
              }, {
                width: L,
                height: 1
              }), s.R.copy(A, u, {
                x: L - 1,
                y: 0
              }, {
                x: w - 1,
                y: I
              }, {
                width: 1,
                height: O
              }), s.R.copy(A, u, {
                x: 0,
                y: 0
              }, {
                x: w + L,
                y: I
              }, {
                width: 1,
                height: O
              })
            }
            this.dirty = !0
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {}
          }
          dispatchRenderCallbacks(e) {
            for (const a of e) {
              if (this.callbackDispatchedThisFrame[a]) continue;
              this.callbackDispatchedThisFrame[a] = !0;
              const o = this.getImage(a);
              o || s.w(`Image with ID: "${a}" was not found`), Me(o) && this.updateImage(a, o)
            }
          }
        }
        const Qe = 1e20;

        function Ue(d, e, a, o, u, p, g, w, I) {
          for (let A = e; A < e + o; A++) je(d, a * p + A, p, u, g, w, I);
          for (let A = a; A < a + u; A++) je(d, A * p + e, 1, o, g, w, I)
        }

        function je(d, e, a, o, u, p, g) {
          p[0] = 0, g[0] = -Qe, g[1] = Qe, u[0] = d[e];
          for (let w = 1, I = 0, A = 0; w < o; w++) {
            u[w] = d[e + w * a];
            const L = w * w;
            do {
              const O = p[I];
              A = (u[w] - u[O] + L - O * O) / (w - O) / 2
            } while (A <= g[I] && --I > -1);
            I++, p[I] = w, g[I] = A, g[I + 1] = Qe
          }
          for (let w = 0, I = 0; w < o; w++) {
            for (; g[I + 1] < w;) I++;
            const A = p[I],
              L = w - A;
            d[e + w * a] = u[A] + L * L
          }
        }
        const rt = s.v.layout_symbol["text-font"].default.join(",");
        class _t {
          constructor(e, a, o) {
            this.requestManager = e, this.localIdeographFontFamily = a, this.entries = {}, this.lang = o
          }
          setURL(e) {
            this.url = e
          }
          getGlyphs(e) {
            return s._(this, void 0, void 0, (function*() {
              const a = [];
              for (const p in e)
                for (const g of e[p]) a.push(this._getAndCacheGlyphsPromise(p, g));
              const o = yield Promise.all(a), u = {};
              for (const {
                  stack: p,
                  id: g,
                  glyph: w
                }
                of o) u[p] || (u[p] = {}), u[p][g] = w && {
                id: w.id,
                bitmap: w.bitmap.clone(),
                metrics: w.metrics
              };
              return u
            }))
          }
          _getAndCacheGlyphsPromise(e, a) {
            return s._(this, void 0, void 0, (function*() {
              let o = this.entries[e];
              o || (o = this.entries[e] = {
                glyphs: {},
                requests: {},
                ranges: {}
              });
              let u = o.glyphs[a];
              return u !== void 0 ? {
                stack: e,
                id: a,
                glyph: u
              } : !this.url || this._charUsesLocalIdeographFontFamily(a) ? (u = o.glyphs[a] = this._drawGlyph(o, e, a), {
                stack: e,
                id: a,
                glyph: u
              }) : yield this._downloadAndCacheRangePromise(e, a)
            }))
          }
          _downloadAndCacheRangePromise(e, a) {
            return s._(this, void 0, void 0, (function*() {
              const o = Math.floor(a / 256);
              if (256 * o > 65535) throw new Error("glyphs > 65535 not supported");
              const u = this.entries[e];
              if (u.ranges[o]) return {
                stack: e,
                id: a,
                glyph: null
              };
              if (!u.requests[o]) {
                const p = _t.loadGlyphRange(e, o, this.url, this.requestManager);
                u.requests[o] = p
              }
              try {
                const p = yield u.requests[o];
                for (const g in p) u.glyphs[+g] = p[+g];
                return u.ranges[o] = !0, {
                  stack: e,
                  id: a,
                  glyph: p[a] || null
                }
              } catch (p) {
                const g = u.glyphs[a] = this._drawGlyph(u, e, a);
                return this._warnOnMissingGlyphRange(g, o, a, p), {
                  stack: e,
                  id: a,
                  glyph: g
                }
              }
            }))
          }
          _warnOnMissingGlyphRange(e, a, o, u) {
            const p = 256 * a,
              g = p + 255,
              w = o.toString(16).padStart(4, "0").toUpperCase();
            s.w(`Unable to load glyph range ${a}, ${p}-${g}. Rendering codepoint U+${w} locally instead. ${u}`)
          }
          _charUsesLocalIdeographFontFamily(e) {
            return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(e)) || s.u["CJK Unified Ideographs"](e) || s.u["Hangul Syllables"](e) || s.u.Hiragana(e) || s.u.Katakana(e) || s.u["CJK Symbols and Punctuation"](e) || s.u["Halfwidth and Fullwidth Forms"](e))
          }
          _drawGlyph(e, a, o) {
            const u = a === rt && this.localIdeographFontFamily !== "" && this._charUsesLocalIdeographFontFamily(o),
              p = u ? "ideographTinySDF" : "tinySDF";
            e[p] || (e[p] = this._createTinySDF(u ? this.localIdeographFontFamily : a));
            const g = e[p].draw(String.fromCharCode(o));
            return {
              id: o,
              bitmap: new s.q({
                width: g.width || 60,
                height: g.height || 60
              }, g.data),
              metrics: {
                width: g.glyphWidth / 2 || 24,
                height: g.glyphHeight / 2 || 24,
                left: g.glyphLeft / 2 + .5 || 0,
                top: g.glyphTop / 2 - 27.5 || -8,
                advance: g.glyphAdvance / 2 || 24,
                isDoubleResolution: !0
              }
            }
          }
          _createTinySDF(e) {
            const a = e ? e.split(",") : [];
            a.push("sans-serif");
            const o = a.map((u => /[-\w]+/.test(u) ? u : `'${CSS.escape(u)}'`)).join(",");
            return new _t.TinySDF({
              fontSize: 48,
              buffer: 6,
              radius: 16,
              cutoff: .25,
              fontFamily: o,
              fontWeight: this._fontWeight(a[0]),
              fontStyle: this._fontStyle(a[0]),
              lang: this.lang
            })
          }
          _fontStyle(e) {
            return /italic/i.test(e) ? "italic" : /oblique/i.test(e) ? "oblique" : "normal"
          }
          _fontWeight(e) {
            const a = {
              thin: 100,
              hairline: 100,
              "extra light": 200,
              "ultra light": 200,
              light: 300,
              normal: 400,
              regular: 400,
              medium: 500,
              semibold: 600,
              demibold: 600,
              bold: 700,
              "extra bold": 800,
              "ultra bold": 800,
              black: 900,
              heavy: 900,
              "extra black": 950,
              "ultra black": 950
            };
            let o;
            for (const [u, p] of Object.entries(a)) new RegExp(`\\b${u}\\b`, "i").test(e) && (o = `${p}`);
            return o
          }
        }
        _t.loadGlyphRange = function(d, e, a, o) {
          return s._(this, void 0, void 0, (function*() {
            const u = 256 * e,
              p = u + 255,
              g = o.transformRequest(a.replace("{fontstack}", d).replace("{range}", `${u}-${p}`), "Glyphs"),
              w = yield s.n(g, new AbortController);
            if (!w || !w.data) throw new Error(`Could not load glyph range. range: ${e}, ${u}-${p}`);
            const I = {};
            for (const A of s.o(w.data)) I[A.id] = A;
            return I
          }))
        }, _t.TinySDF = class {
          constructor({
            fontSize: d = 24,
            buffer: e = 3,
            radius: a = 8,
            cutoff: o = .25,
            fontFamily: u = "sans-serif",
            fontWeight: p = "normal",
            fontStyle: g = "normal",
            lang: w = null
          } = {}) {
            this.buffer = e, this.cutoff = o, this.radius = a, this.lang = w;
            const I = this.size = d + 4 * e,
              A = this._createCanvas(I),
              L = this.ctx = A.getContext("2d", {
                willReadFrequently: !0
              });
            L.font = `${g} ${p} ${d}px ${u}`, L.textBaseline = "alphabetic", L.textAlign = "left", L.fillStyle = "black", this.gridOuter = new Float64Array(I * I), this.gridInner = new Float64Array(I * I), this.f = new Float64Array(I), this.z = new Float64Array(I + 1), this.v = new Uint16Array(I)
          }
          _createCanvas(d) {
            const e = document.createElement("canvas");
            return e.width = e.height = d, e
          }
          draw(d) {
            const {
              width: e,
              actualBoundingBoxAscent: a,
              actualBoundingBoxDescent: o,
              actualBoundingBoxLeft: u,
              actualBoundingBoxRight: p
            } = this.ctx.measureText(d), g = Math.ceil(a), w = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(p - u))), I = Math.min(this.size - this.buffer, g + Math.ceil(o)), A = w + 2 * this.buffer, L = I + 2 * this.buffer, O = Math.max(A * L, 0), R = new Uint8ClampedArray(O), H = {
              data: R,
              width: A,
              height: L,
              glyphWidth: w,
              glyphHeight: I,
              glyphTop: g,
              glyphLeft: 0,
              glyphAdvance: e
            };
            if (w === 0 || I === 0) return H;
            const {
              ctx: $,
              buffer: ce,
              gridInner: ue,
              gridOuter: de
            } = this;
            this.lang && ($.lang = this.lang), $.clearRect(ce, ce, w, I), $.fillText(d, ce, ce + g);
            const Ce = $.getImageData(ce, ce, w, I);
            de.fill(Qe, 0, O), ue.fill(0, 0, O);
            for (let Be = 0; Be < I; Be++)
              for (let Ie = 0; Ie < w; Ie++) {
                const Oe = Ce.data[4 * (Be * w + Ie) + 3] / 255;
                if (Oe === 0) continue;
                const He = (Be + ce) * A + Ie + ce;
                if (Oe === 1) de[He] = 0, ue[He] = Qe;
                else {
                  const Le = .5 - Oe;
                  de[He] = Le > 0 ? Le * Le : 0, ue[He] = Le < 0 ? Le * Le : 0
                }
              }
            Ue(de, 0, 0, A, L, A, this.f, this.v, this.z), Ue(ue, ce, ce, w, I, A, this.f, this.v, this.z);
            for (let Be = 0; Be < O; Be++) {
              const Ie = Math.sqrt(de[Be]) - Math.sqrt(ue[Be]);
              R[Be] = Math.round(255 - 255 * (Ie / this.radius + this.cutoff))
            }
            return H
          }
        };
        class dt {
          constructor() {
            this.specification = s.t.light.position
          }
          possiblyEvaluate(e, a) {
            return s.C(e.expression.evaluate(a))
          }
          interpolate(e, a, o) {
            return {
              x: s.F.number(e.x, a.x, o),
              y: s.F.number(e.y, a.y, o),
              z: s.F.number(e.z, a.z, o)
            }
          }
        }
        let at;
        class nt extends s.E {
          constructor(e) {
            super(), at = at || new s.r({
              anchor: new s.D(s.t.light.anchor),
              position: new dt,
              color: new s.D(s.t.light.color),
              intensity: new s.D(s.t.light.intensity)
            }), this._transitionable = new s.x(at, void 0), this.setLight(e), this._transitioning = this._transitionable.untransitioned()
          }
          getLight() {
            return this._transitionable.serialize()
          }
          setLight(e, a = {}) {
            if (!this._validate(s.y, e, a))
              for (const o in e) {
                const u = e[o];
                o.endsWith("-transition") ? this._transitionable.setTransition(o.slice(0, -11), u) : this._transitionable.setValue(o, u)
              }
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          _validate(e, a, o) {
            return (!o || o.validate !== !1) && s.z(this, e.call(s.B, {
              value: a,
              style: {
                glyphs: !0,
                sprite: !0
              },
              styleSpec: s.t
            }))
          }
        }
        const ot = new s.r({
          "sky-color": new s.D(s.t.sky["sky-color"]),
          "horizon-color": new s.D(s.t.sky["horizon-color"]),
          "fog-color": new s.D(s.t.sky["fog-color"]),
          "fog-ground-blend": new s.D(s.t.sky["fog-ground-blend"]),
          "horizon-fog-blend": new s.D(s.t.sky["horizon-fog-blend"]),
          "sky-horizon-blend": new s.D(s.t.sky["sky-horizon-blend"]),
          "atmosphere-blend": new s.D(s.t.sky["atmosphere-blend"])
        });
        class ut extends s.E {
          constructor(e) {
            super(), this._transitionable = new s.x(ot, void 0), this.setSky(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new s.G(0))
          }
          setSky(e, a = {}) {
            if (!this._validate(s.H, e, a)) {
              e || (e = {
                "sky-color": "transparent",
                "horizon-color": "transparent",
                "fog-color": "transparent",
                "fog-ground-blend": 1,
                "atmosphere-blend": 0
              });
              for (const o in e) {
                const u = e[o];
                o.endsWith("-transition") ? this._transitionable.setTransition(o.slice(0, -11), u) : this._transitionable.setValue(o, u)
              }
            }
          }
          getSky() {
            return this._transitionable.serialize()
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          _validate(e, a, o = {}) {
            return (o == null ? void 0 : o.validate) !== !1 && s.z(this, e.call(s.B, s.e({
              value: a,
              style: {
                glyphs: !0,
                sprite: !0
              },
              styleSpec: s.t
            })))
          }
          calculateFogBlendOpacity(e) {
            return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1
          }
        }
        class st {
          constructor(e, a) {
            this.width = e, this.height = a, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {}
          }
          getDash(e, a) {
            const o = e.join(",") + String(a);
            return this.dashEntry[o] || (this.dashEntry[o] = this.addDash(e, a)), this.dashEntry[o]
          }
          getDashRanges(e, a, o) {
            const u = [];
            let p = e.length % 2 == 1 ? -e[e.length - 1] * o : 0,
              g = e[0] * o,
              w = !0;
            u.push({
              left: p,
              right: g,
              isDash: w,
              zeroLength: e[0] === 0
            });
            let I = e[0];
            for (let A = 1; A < e.length; A++) {
              w = !w;
              const L = e[A];
              p = I * o, I += L, g = I * o, u.push({
                left: p,
                right: g,
                isDash: w,
                zeroLength: L === 0
              })
            }
            return u
          }
          addRoundDash(e, a, o) {
            const u = a / 2;
            for (let p = -o; p <= o; p++) {
              const g = this.width * (this.nextRow + o + p);
              let w = 0,
                I = e[w];
              for (let A = 0; A < this.width; A++) {
                A / I.right > 1 && (I = e[++w]);
                const L = Math.abs(A - I.left),
                  O = Math.abs(A - I.right),
                  R = Math.min(L, O);
                let H;
                const $ = p / o * (u + 1);
                if (I.isDash) {
                  const ce = u - Math.abs($);
                  H = Math.sqrt(R * R + ce * ce)
                } else H = u - Math.sqrt(R * R + $ * $);
                this.data[g + A] = Math.max(0, Math.min(255, H + 128))
              }
            }
          }
          addRegularDash(e) {
            for (let w = e.length - 1; w >= 0; --w) {
              const I = e[w],
                A = e[w + 1];
              I.zeroLength ? e.splice(w, 1) : A && A.isDash === I.isDash && (A.left = I.left, e.splice(w, 1))
            }
            const a = e[0],
              o = e[e.length - 1];
            a.isDash === o.isDash && (a.left = o.left - this.width, o.right = a.right + this.width);
            const u = this.width * this.nextRow;
            let p = 0,
              g = e[p];
            for (let w = 0; w < this.width; w++) {
              w / g.right > 1 && (g = e[++p]);
              const I = Math.abs(w - g.left),
                A = Math.abs(w - g.right),
                L = Math.min(I, A);
              this.data[u + w] = Math.max(0, Math.min(255, (g.isDash ? L : -L) + 128))
            }
          }
          addDash(e, a) {
            const o = a ? 7 : 0,
              u = 2 * o + 1;
            if (this.nextRow + u > this.height) return s.w("LineAtlas out of space"), null;
            let p = 0;
            for (let w = 0; w < e.length; w++) p += e[w];
            if (p !== 0) {
              const w = this.width / p,
                I = this.getDashRanges(e, this.width, w);
              a ? this.addRoundDash(I, w, o) : this.addRegularDash(I)
            }
            const g = {
              y: this.nextRow + o,
              height: 2 * o,
              width: p
            };
            return this.nextRow += u, this.dirty = !0, g
          }
          bind(e) {
            const a = e.gl;
            this.texture ? (a.bindTexture(a.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, this.width, this.height, a.ALPHA, a.UNSIGNED_BYTE, this.data))) : (this.texture = a.createTexture(), a.bindTexture(a.TEXTURE_2D, this.texture), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.REPEAT), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.REPEAT), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR), a.texImage2D(a.TEXTURE_2D, 0, a.ALPHA, this.width, this.height, 0, a.ALPHA, a.UNSIGNED_BYTE, this.data))
          }
        }
        const wt = "maplibre_preloaded_worker_pool";
        class Ct {
          constructor() {
            this.active = {}
          }
          acquire(e) {
            if (!this.workers)
              for (this.workers = []; this.workers.length < Ct.workerCount;) this.workers.push(new Worker(s.a.WORKER_URL));
            return this.active[e] = !0, this.workers.slice()
          }
          release(e) {
            delete this.active[e], this.numActive() === 0 && (this.workers.forEach((a => {
              a.terminate()
            })), this.workers = null)
          }
          isPreloaded() {
            return !!this.active[wt]
          }
          numActive() {
            return Object.keys(this.active).length
          }
        }
        const rr = Math.floor(re.hardwareConcurrency / 2);
        let Zt, lt;

        function ht() {
          return Zt || (Zt = new Ct), Zt
        }
        Ct.workerCount = s.J(globalThis) ? Math.max(Math.min(rr, 3), 1) : 1;
        class Dt {
          constructor(e, a) {
            this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = a;
            const o = this.workerPool.acquire(a);
            for (let u = 0; u < o.length; u++) {
              const p = new s.K(o[u], a);
              p.name = `Worker ${u}`, this.actors.push(p)
            }
            if (!this.actors.length) throw new Error("No actors found")
          }
          broadcast(e, a) {
            const o = [];
            for (const u of this.actors) o.push(u.sendAsync({
              type: e,
              data: a
            }));
            return Promise.all(o)
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor]
          }
          remove(e = !0) {
            this.actors.forEach((a => {
              a.remove()
            })), this.actors = [], e && this.workerPool.release(this.id)
          }
          registerMessageHandler(e, a) {
            for (const o of this.actors) o.registerMessageHandler(e, a)
          }
        }

        function Vt() {
          return lt || (lt = new Dt(ht(), s.L), lt.registerMessageHandler("GR", ((d, e, a) => s.m(e, a)))), lt
        }

        function Jt(d, e) {
          const a = s.M();
          return s.N(a, a, [1, 1, 0]), s.O(a, a, [.5 * d.width, .5 * d.height, 1]), d.calculatePosMatrix ? s.Q(a, a, d.calculatePosMatrix(e.toUnwrapped())) : a
        }

        function jt(d, e, a, o, u, p, g) {
          var w;
          const I = (function(R, H, $) {
              if (R)
                for (const ce of R) {
                  const ue = H[ce];
                  if (ue && ue.source === $ && ue.type === "fill-extrusion") return !0
                } else
                  for (const ce in H) {
                    const ue = H[ce];
                    if (ue.source === $ && ue.type === "fill-extrusion") return !0
                  }
              return !1
            })((w = u == null ? void 0 : u.layers) !== null && w !== void 0 ? w : null, e, d.id),
            A = p.maxPitchScaleFactor(),
            L = d.tilesIn(o, A, I);
          L.sort(nr);
          const O = [];
          for (const R of L) O.push({
            wrappedTileID: R.tileID.wrapped().key,
            queryResults: R.tile.queryRenderedFeatures(e, a, d.getState(), R.queryGeometry, R.cameraQueryGeometry, R.scale, u, p, A, Jt(p, R.tileID), g ? (H, $) => g(R.tileID, H, $) : void 0)
          });
          return (function(R, H) {
            for (const $ in R)
              for (const ce of R[$]) St(ce, H);
            return R
          })((function(R) {
            const H = {},
              $ = {};
            for (const ce of R) {
              const ue = ce.queryResults,
                de = ce.wrappedTileID,
                Ce = $[de] = $[de] || {};
              for (const Be in ue) {
                const Ie = ue[Be],
                  Oe = Ce[Be] = Ce[Be] || {},
                  He = H[Be] = H[Be] || [];
                for (const Le of Ie) Oe[Le.featureIndex] || (Oe[Le.featureIndex] = !0, He.push(Le))
              }
            }
            return H
          })(O), d)
        }

        function nr(d, e) {
          const a = d.tileID,
            o = e.tileID;
          return a.overscaledZ - o.overscaledZ || a.canonical.y - o.canonical.y || a.wrap - o.wrap || a.canonical.x - o.canonical.x
        }

        function St(d, e) {
          const a = d.feature,
            o = e.getFeatureState(a.layer["source-layer"], a.id);
          a.source = a.layer.source, a.layer["source-layer"] && (a.sourceLayer = a.layer["source-layer"]), a.state = o
        }

        function Et(d, e, a) {
          return s._(this, void 0, void 0, (function*() {
            let o = d;
            if (d.url ? o = (yield s.j(e.transformRequest(d.url, "Source"), a)).data : yield re.frameAsync(a), !o) return null;
            const u = s.S(s.e(o, d), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in o && o.vector_layers && (u.vectorLayerIds = o.vector_layers.map((p => p.id))), u
          }))
        }
        class Ut {
          constructor(e, a) {
            e && (a ? this.setSouthWest(e).setNorthEast(a) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])))
          }
          setNorthEast(e) {
            return this._ne = e instanceof s.U ? new s.U(e.lng, e.lat) : s.U.convert(e), this
          }
          setSouthWest(e) {
            return this._sw = e instanceof s.U ? new s.U(e.lng, e.lat) : s.U.convert(e), this
          }
          extend(e) {
            const a = this._sw,
              o = this._ne;
            let u, p;
            if (e instanceof s.U) u = e, p = e;
            else {
              if (!(e instanceof Ut)) return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(Ut.convert(e)) : this.extend(s.U.convert(e)) : e && ("lng" in e || "lon" in e) && "lat" in e ? this.extend(s.U.convert(e)) : this;
              if (u = e._sw, p = e._ne, !u || !p) return this
            }
            return a || o ? (a.lng = Math.min(u.lng, a.lng), a.lat = Math.min(u.lat, a.lat), o.lng = Math.max(p.lng, o.lng), o.lat = Math.max(p.lat, o.lat)) : (this._sw = new s.U(u.lng, u.lat), this._ne = new s.U(p.lng, p.lat)), this
          }
          getCenter() {
            return new s.U((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2)
          }
          getSouthWest() {
            return this._sw
          }
          getNorthEast() {
            return this._ne
          }
          getNorthWest() {
            return new s.U(this.getWest(), this.getNorth())
          }
          getSouthEast() {
            return new s.U(this.getEast(), this.getSouth())
          }
          getWest() {
            return this._sw.lng
          }
          getSouth() {
            return this._sw.lat
          }
          getEast() {
            return this._ne.lng
          }
          getNorth() {
            return this._ne.lat
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()]
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`
          }
          isEmpty() {
            return !(this._sw && this._ne)
          }
          contains(e) {
            const {
              lng: a,
              lat: o
            } = s.U.convert(e);
            let u = this._sw.lng <= a && a <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (u = this._sw.lng >= a && a >= this._ne.lng), this._sw.lat <= o && o <= this._ne.lat && u
          }
          intersects(e) {
            if ((e = Ut.convert(e)).getNorth() < this.getSouth() || e.getSouth() > this.getNorth()) return !1;
            const a = s.V(this.getWest(), -180, 180),
              o = s.V(this.getEast(), -180, 180),
              u = s.V(e.getWest(), -180, 180),
              p = s.V(e.getEast(), -180, 180),
              g = a > o,
              w = u > p;
            return !(!g || !w) || (g ? p >= a || u <= o : w ? o >= u || a <= p : !(u > o || p < a))
          }
          static convert(e) {
            return e instanceof Ut ? e : e && new Ut(e)
          }
          static fromLngLat(e, a = 0) {
            const o = 360 * a / 40075017,
              u = o / Math.cos(Math.PI / 180 * e.lat);
            return new Ut(new s.U(e.lng - u, e.lat - o), new s.U(e.lng + u, e.lat + o))
          }
          adjustAntiMeridian() {
            const e = new s.U(this._sw.lng, this._sw.lat),
              a = new s.U(this._ne.lng, this._ne.lat);
            return new Ut(e, e.lng > a.lng ? new s.U(a.lng + 360, a.lat) : a)
          }
        }
        class Gt {
          constructor(e, a, o) {
            this.bounds = Ut.convert(this.validateBounds(e)), this.minzoom = a || 0, this.maxzoom = o || 24
          }
          validateBounds(e) {
            return Array.isArray(e) && e.length === 4 ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90]
          }
          contains(e) {
            const a = Math.pow(2, e.z),
              o = Math.floor(s.X(this.bounds.getWest()) * a),
              u = Math.floor(s.W(this.bounds.getNorth()) * a),
              p = Math.ceil(s.X(this.bounds.getEast()) * a),
              g = Math.ceil(s.W(this.bounds.getSouth()) * a);
            return e.x >= o && e.x < p && e.y >= u && e.y < g
          }
        }
        class Rt extends s.E {
          constructor(e, a, o, u) {
            if (super(), this.id = e, this.dispatcher = o, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, s.e(this, s.S(a, ["url", "scheme", "tileSize", "promoteId"])), this._options = s.e({
                type: "vector"
              }, a), this._collectResourceTiming = a.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(u)
          }
          load() {
            return s._(this, void 0, void 0, (function*() {
              this._loaded = !1, this.fire(new s.l("dataloading", {
                dataType: "source"
              })), this._tileJSONRequest = new AbortController;
              try {
                const e = yield Et(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, this.map.style.tileManagers[this.id].clearTiles(), e && (s.e(this, e), e.bounds && (this.tileBounds = new Gt(e.bounds, this.minzoom, this.maxzoom)), this.fire(new s.l("data", {
                  dataType: "source",
                  sourceDataType: "metadata"
                })), this.fire(new s.l("data", {
                  dataType: "source",
                  sourceDataType: "content"
                })))
              } catch (e) {
                this._tileJSONRequest = null, this._loaded = !0, this.fire(new s.k(e))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical)
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          setSourceProperty(e) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load()
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e
            })), this
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e
            })), this
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null)
          }
          serialize() {
            return s.e({}, this._options)
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              const a = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme),
                o = {
                  request: this.map._requestManager.transformRequest(a, "Tile"),
                  uid: e.uid,
                  tileID: e.tileID,
                  zoom: e.tileID.overscaledZ,
                  tileSize: this.tileSize * e.tileID.overscaleFactor(),
                  type: this.type,
                  source: this.id,
                  pixelRatio: this.map.getPixelRatio(),
                  showCollisionBoxes: this.map.showCollisionBoxes,
                  promoteId: this.promoteId,
                  subdivisionGranularity: this.map.style.projection.subdivisionGranularity
                };
              o.request.collectResourceTiming = this._collectResourceTiming;
              let u = "RT";
              if (e.actor && e.state !== "expired") {
                if (e.state === "loading") return new Promise(((p, g) => {
                  e.reloadPromise = {
                    resolve: p,
                    reject: g
                  }
                }))
              } else e.actor = this.dispatcher.getActor(), u = "LT";
              e.abortController = new AbortController;
              try {
                const p = yield e.actor.sendAsync({
                  type: u,
                  data: o
                }, e.abortController);
                if (delete e.abortController, e.aborted) return;
                this._afterTileLoadWorkerResponse(e, p)
              } catch (p) {
                if (delete e.abortController, e.aborted) return;
                if (p && p.status !== 404) throw p;
                this._afterTileLoadWorkerResponse(e, null)
              }
            }))
          }
          _afterTileLoadWorkerResponse(e, a) {
            if (a && a.resourceTiming && (e.resourceTiming = a.resourceTiming), a && this.map._refreshExpiredTiles && e.setExpiryData(a), e.loadVectorData(a, this.map.painter), e.reloadPromise) {
              const o = e.reloadPromise;
              e.reloadPromise = null, this.loadTile(e).then(o.resolve).catch(o.reject)
            }
          }
          abortTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && (yield e.actor.sendAsync({
                type: "AT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              }))
            }))
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.unloadVectorData(), e.actor && (yield e.actor.sendAsync({
                type: "RMT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              }))
            }))
          }
          hasTransition() {
            return !1
          }
        }
        class ir extends s.E {
          constructor(e, a, o, u) {
            super(), this.id = e, this.dispatcher = o, this.setEventedParent(u), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = s.e({
              type: "raster"
            }, a), s.e(this, s.S(a, ["url", "scheme", "tileSize"]))
          }
          load() {
            return s._(this, arguments, void 0, (function*(e = !1) {
              this._loaded = !1, this.fire(new s.l("dataloading", {
                dataType: "source"
              })), this._tileJSONRequest = new AbortController;
              try {
                const a = yield Et(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, a && (s.e(this, a), a.bounds && (this.tileBounds = new Gt(a.bounds, this.minzoom, this.maxzoom)), this.fire(new s.l("data", {
                  dataType: "source",
                  sourceDataType: "metadata"
                })), this.fire(new s.l("data", {
                  dataType: "source",
                  sourceDataType: "content",
                  sourceDataChanged: e
                })))
              } catch (a) {
                this._tileJSONRequest = null, this._loaded = !0, this.fire(new s.k(a))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null)
          }
          setSourceProperty(e) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e(), this.load(!0)
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e
            })), this
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e
            })), this
          }
          serialize() {
            return s.e({}, this._options)
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical)
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              const a = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              e.abortController = new AbortController;
              try {
                const o = yield ze.getImage(this.map._requestManager.transformRequest(a, "Tile"), e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void(e.state = "unloaded");
                if (o && o.data) {
                  this.map._refreshExpiredTiles && (o.cacheControl || o.expires) && e.setExpiryData({
                    cacheControl: o.cacheControl,
                    expires: o.expires
                  });
                  const u = this.map.painter.context,
                    p = u.gl,
                    g = o.data;
                  e.texture = this.map.painter.getTileTexture(g.width), e.texture ? e.texture.update(g, {
                    useMipmap: !0
                  }) : (e.texture = new s.T(u, g, p.RGBA, {
                    useMipmap: !0
                  }), e.texture.bind(p.LINEAR, p.CLAMP_TO_EDGE, p.LINEAR_MIPMAP_NEAREST)), e.state = "loaded"
                }
              } catch (o) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (o) throw e.state = "errored", o
              }
            }))
          }
          abortTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController)
            }))
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.texture && this.map.painter.saveTileTexture(e.texture)
            }))
          }
          hasTransition() {
            return !1
          }
        }
        class kr extends ir {
          constructor(e, a, o, u) {
            super(e, a, o, u), this.type = "raster-dem", this.maxzoom = 22, this._options = s.e({
              type: "raster-dem"
            }, a), this.encoding = a.encoding || "mapbox", this.redFactor = a.redFactor, this.greenFactor = a.greenFactor, this.blueFactor = a.blueFactor, this.baseShift = a.baseShift
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              const a = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme),
                o = this.map._requestManager.transformRequest(a, "Tile");
              e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController;
              try {
                const u = yield ze.getImage(o, e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void(e.state = "unloaded");
                if (u && u.data) {
                  const p = u.data;
                  this.map._refreshExpiredTiles && (u.cacheControl || u.expires) && e.setExpiryData({
                    cacheControl: u.cacheControl,
                    expires: u.expires
                  });
                  const g = s.b(p) && s.Y() ? p : yield this.readImageNow(p), w = {
                    type: this.type,
                    uid: e.uid,
                    source: this.id,
                    rawImageData: g,
                    encoding: this.encoding,
                    redFactor: this.redFactor,
                    greenFactor: this.greenFactor,
                    blueFactor: this.blueFactor,
                    baseShift: this.baseShift
                  };
                  if (!e.actor || e.state === "expired") {
                    e.actor = this.dispatcher.getActor();
                    const I = yield e.actor.sendAsync({
                      type: "LDT",
                      data: w
                    });
                    e.dem = I, e.needsHillshadePrepare = !0, e.needsTerrainPrepare = !0, e.state = "loaded"
                  }
                }
              } catch (u) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (u) throw e.state = "errored", u
              }
            }))
          }
          readImageNow(e) {
            return s._(this, void 0, void 0, (function*() {
              if (typeof VideoFrame < "u" && s.Z()) {
                const a = e.width + 2,
                  o = e.height + 2;
                try {
                  return new s.R({
                    width: a,
                    height: o
                  }, yield s.$(e, -1, -1, a, o))
                } catch {}
              }
              return re.getImageData(e, 1)
            }))
          }
          _getNeighboringTiles(e) {
            const a = e.canonical,
              o = Math.pow(2, a.z),
              u = (a.x - 1 + o) % o,
              p = a.x === 0 ? e.wrap - 1 : e.wrap,
              g = (a.x + 1 + o) % o,
              w = a.x + 1 === o ? e.wrap + 1 : e.wrap,
              I = {};
            return I[new s.a0(e.overscaledZ, p, a.z, u, a.y).key] = {
              backfilled: !1
            }, I[new s.a0(e.overscaledZ, w, a.z, g, a.y).key] = {
              backfilled: !1
            }, a.y > 0 && (I[new s.a0(e.overscaledZ, p, a.z, u, a.y - 1).key] = {
              backfilled: !1
            }, I[new s.a0(e.overscaledZ, e.wrap, a.z, a.x, a.y - 1).key] = {
              backfilled: !1
            }, I[new s.a0(e.overscaledZ, w, a.z, g, a.y - 1).key] = {
              backfilled: !1
            }), a.y + 1 < o && (I[new s.a0(e.overscaledZ, p, a.z, u, a.y + 1).key] = {
              backfilled: !1
            }, I[new s.a0(e.overscaledZ, e.wrap, a.z, a.x, a.y + 1).key] = {
              backfilled: !1
            }, I[new s.a0(e.overscaledZ, w, a.z, g, a.y + 1).key] = {
              backfilled: !1
            }), I
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && (yield e.actor.sendAsync({
                type: "RDT",
                data: {
                  type: this.type,
                  uid: e.uid,
                  source: this.id
                }
              }))
            }))
          }
        }

        function _r(d) {
          return d.type === "GeometryCollection" ? d.geometries.map((e => e.coordinates)).flat(1 / 0) : d.coordinates.flat(1 / 0)
        }

        function fr(d) {
          const e = new Ut;
          let a;
          switch (d.type) {
            case "FeatureCollection":
              a = d.features.map((o => _r(o.geometry))).flat(1 / 0);
              break;
            case "Feature":
              a = _r(d.geometry);
              break;
            default:
              a = _r(d)
          }
          if (a.length == 0) return e;
          for (let o = 0; o < a.length - 1; o += 2) e.extend([a[o], a[o + 1]]);
          return e
        }
        class Yt extends s.E {
          constructor(e, a, o, u) {
            super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._isUpdatingWorker = !1, this._pendingWorkerUpdate = {
              data: a.data
            }, this.actor = o.getActor(), this.setEventedParent(u), this._data = a.data, this._options = s.e({}, a), this._collectResourceTiming = a.collectResourceTiming, a.maxzoom !== void 0 && (this.maxzoom = a.maxzoom), a.type && (this.type = a.type), a.attribution && (this.attribution = a.attribution), this.promoteId = a.promoteId, a.clusterMaxZoom !== void 0 && this.maxzoom <= a.clusterMaxZoom && s.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${a.clusterMaxZoom}".`), this.workerOptions = s.e({
              source: this.id,
              cluster: a.cluster || !1,
              geojsonVtOptions: {
                buffer: this._pixelsToTileUnits(a.buffer !== void 0 ? a.buffer : 128),
                tolerance: this._pixelsToTileUnits(a.tolerance !== void 0 ? a.tolerance : .375),
                extent: s.a3,
                maxZoom: this.maxzoom,
                lineMetrics: a.lineMetrics || !1,
                generateId: a.generateId || !1
              },
              superclusterOptions: {
                maxZoom: this._getClusterMaxZoom(a.clusterMaxZoom),
                minPoints: Math.max(2, a.clusterMinPoints || 2),
                extent: s.a3,
                radius: this._pixelsToTileUnits(a.clusterRadius || 50),
                log: !1,
                generateId: a.generateId || !1
              },
              clusterProperties: a.clusterProperties,
              filter: a.filter
            }, a.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId)
          }
          _hasPendingWorkerUpdate() {
            return this._pendingWorkerUpdate.data !== void 0 || this._pendingWorkerUpdate.diff !== void 0 || this._pendingWorkerUpdate.optionsChanged
          }
          _pixelsToTileUnits(e) {
            return e * (s.a3 / this.tileSize)
          }
          _getClusterMaxZoom(e) {
            const a = e ? Math.round(e) : this.maxzoom - 1;
            return Number.isInteger(e) || e === void 0 || s.w(`Integer expected for option 'clusterMaxZoom': provided value "${e}" rounded to "${a}"`), a
          }
          load() {
            return s._(this, void 0, void 0, (function*() {
              yield this._updateWorkerData()
            }))
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          setData(e) {
            return this._data = e, this._pendingWorkerUpdate = {
              data: e
            }, this._updateWorkerData(), this
          }
          updateData(e) {
            return this._pendingWorkerUpdate.diff = s.a4(this._pendingWorkerUpdate.diff, e), this._updateWorkerData(), this
          }
          getData() {
            return s._(this, void 0, void 0, (function*() {
              const e = s.e({
                type: this.type
              }, this.workerOptions);
              return this.actor.sendAsync({
                type: "GD",
                data: e
              })
            }))
          }
          getBounds() {
            return s._(this, void 0, void 0, (function*() {
              return fr(yield this.getData())
            }))
          }
          setClusterOptions(e) {
            return this.workerOptions.cluster = e.cluster, e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e.clusterRadius)), e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(e.clusterMaxZoom)), this._pendingWorkerUpdate.optionsChanged = !0, this._updateWorkerData(), this
          }
          getClusterExpansionZoom(e) {
            return this.actor.sendAsync({
              type: "GCEZ",
              data: {
                type: this.type,
                clusterId: e,
                source: this.id
              }
            })
          }
          getClusterChildren(e) {
            return this.actor.sendAsync({
              type: "GCC",
              data: {
                type: this.type,
                clusterId: e,
                source: this.id
              }
            })
          }
          getClusterLeaves(e, a, o) {
            return this.actor.sendAsync({
              type: "GCL",
              data: {
                type: this.type,
                source: this.id,
                clusterId: e,
                limit: a,
                offset: o
              }
            })
          }
          _updateWorkerData() {
            return s._(this, void 0, void 0, (function*() {
              if (this._isUpdatingWorker) return;
              if (!this._hasPendingWorkerUpdate()) return void s.w(`No pending worker updates for GeoJSONSource ${this.id}.`);
              const {
                data: e,
                diff: a
              } = this._pendingWorkerUpdate, o = s.e({
                type: this.type
              }, this.workerOptions);
              e ? (typeof e == "string" ? (o.request = this.map._requestManager.transformRequest(re.resolveURL(e), "Source"), o.request.collectResourceTiming = this._collectResourceTiming) : o.data = JSON.stringify(e), this._pendingWorkerUpdate.data = void 0) : a && (o.dataDiff = a, this._pendingWorkerUpdate.diff = void 0), this._pendingWorkerUpdate.optionsChanged = void 0, this._isUpdatingWorker = !0, this.fire(new s.l("dataloading", {
                dataType: "source"
              }));
              try {
                const u = yield this.actor.sendAsync({
                  type: "LD",
                  data: o
                });
                if (this._isUpdatingWorker = !1, this._removed || u.abandoned) return void this.fire(new s.l("dataabort", {
                  dataType: "source"
                }));
                this._data = u.data;
                let p = null;
                u.resourceTiming && u.resourceTiming[this.id] && (p = u.resourceTiming[this.id].slice(0));
                const g = {
                  dataType: "source"
                };
                this._collectResourceTiming && p && p.length > 0 && s.e(g, {
                  resourceTiming: p
                }), this.fire(new s.l("data", Object.assign(Object.assign({}, g), {
                  sourceDataType: "metadata"
                }))), this.fire(new s.l("data", Object.assign(Object.assign({}, g), {
                  sourceDataType: "content",
                  shouldReloadTileOptions: this._getShouldReloadTileOptions(a)
                })))
              } catch (u) {
                if (this._isUpdatingWorker = !1, this._removed) return void this.fire(new s.l("dataabort", {
                  dataType: "source"
                }));
                this.fire(new s.k(u))
              } finally {
                this._hasPendingWorkerUpdate() && this._updateWorkerData()
              }
            }))
          }
          _getShouldReloadTileOptions(e) {
            if (!e || e.removeAll) return;
            const {
              add: a = [],
              update: o = [],
              remove: u = []
            } = e || {}, p = new Set([...o.map((g => g.id)), ...u]);
            return {
              nextBounds: [...o.map((g => g.newGeometry)), ...a.map((g => g.geometry))].map((g => fr(g))),
              prevIds: p
            }
          }
          shouldReloadTile(e, {
            nextBounds: a,
            prevIds: o
          }) {
            const u = e.latestFeatureIndex.loadVTLayers();
            for (let I = 0; I < e.latestFeatureIndex.featureIndexArray.length; I++) {
              const A = e.latestFeatureIndex.featureIndexArray.get(I),
                L = u._geojsonTileLayer.feature(A.featureIndex);
              if (o.has(L.id)) return !0
            }
            const {
              buffer: p,
              extent: g
            } = this.workerOptions.geojsonVtOptions, w = (function({
              x: I,
              y: A,
              z: L
            }, O = 0) {
              const R = s.a1((I - O) / Math.pow(2, L)),
                H = s.a2((A + 1 + O) / Math.pow(2, L)),
                $ = s.a1((I + 1 + O) / Math.pow(2, L)),
                ce = s.a2((A - O) / Math.pow(2, L));
              return new Ut([R, H], [$, ce])
            })(e.tileID.canonical, p / g);
            for (const I of a)
              if (w.intersects(I)) return !0;
            return !1
          }
          loaded() {
            return !this._isUpdatingWorker && !this._hasPendingWorkerUpdate()
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              const a = e.actor ? "RT" : "LT";
              e.actor = this.actor;
              const o = {
                type: this.type,
                uid: e.uid,
                tileID: e.tileID,
                zoom: e.tileID.overscaledZ,
                maxZoom: this.maxzoom,
                tileSize: this.tileSize,
                source: this.id,
                pixelRatio: this.map.getPixelRatio(),
                showCollisionBoxes: this.map.showCollisionBoxes,
                promoteId: this.promoteId,
                subdivisionGranularity: this.map.style.projection.subdivisionGranularity
              };
              e.abortController = new AbortController;
              const u = yield this.actor.sendAsync({
                type: a,
                data: o
              }, e.abortController);
              delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(u, this.map.painter, a === "RT")
            }))
          }
          abortTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = !0
            }))
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              e.unloadVectorData(), yield this.actor.sendAsync({
                type: "RMT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              })
            }))
          }
          onRemove() {
            this._removed = !0, this.actor.sendAsync({
              type: "RS",
              data: {
                type: this.type,
                source: this.id
              }
            })
          }
          serialize() {
            return s.e({}, this._options, {
              type: this.type,
              data: this._data
            })
          }
          hasTransition() {
            return !1
          }
        }
        class sr extends s.E {
          constructor(e, a, o, u) {
            super(), this.flippedWindingOrder = !1, this.id = e, this.dispatcher = o, this.coordinates = a.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(u), this.options = a
          }
          load(e) {
            return s._(this, void 0, void 0, (function*() {
              this._loaded = !1, this.fire(new s.l("dataloading", {
                dataType: "source"
              })), this.url = this.options.url, this._request = new AbortController;
              try {
                const a = yield ze.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = !0, a && a.data && (this.image = a.data, e && (this.coordinates = e), this._finishLoading())
              } catch (a) {
                this._request = null, this._loaded = !0, this.fire(new s.k(a))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          updateImage(e) {
            return e.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e.url, this.load(e.coordinates).finally((() => {
              this.texture = null
            })), this) : this
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new s.l("data", {
              dataType: "source",
              sourceDataType: "metadata"
            })))
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null)
          }
          setCoordinates(e) {
            this.coordinates = e;
            const a = e.map(s.a5.fromLngLat);
            var o;
            return this.tileID = (function(u) {
              const p = s.a6.fromPoints(u),
                g = p.width(),
                w = p.height(),
                I = Math.max(g, w),
                A = Math.max(0, Math.floor(-Math.log(I) / Math.LN2)),
                L = Math.pow(2, A);
              return new s.a8(A, Math.floor((p.minX + p.maxX) / 2 * L), Math.floor((p.minY + p.maxY) / 2 * L))
            })(a), this.terrainTileRanges = this._getOverlappingTileRanges(a), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = a.map((u => this.tileID.getTilePoint(u)._round())), this.flippedWindingOrder = ((o = this.tileCoords)[1].x - o[0].x) * (o[2].y - o[0].y) - (o[1].y - o[0].y) * (o[2].x - o[0].x) < 0, this.fire(new s.l("data", {
              dataType: "source",
              sourceDataType: "content"
            })), this
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || !this.image) return;
            const e = this.map.painter.context,
              a = e.gl;
            this.texture || (this.texture = new s.T(e, this.image, a.RGBA), this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE));
            let o = !1;
            for (const u in this.tiles) {
              const p = this.tiles[u];
              p.state !== "loaded" && (p.state = "loaded", p.texture = this.texture, o = !0)
            }
            o && this.fire(new s.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function*() {
              this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}) : e.state = "errored"
            }))
          }
          serialize() {
            return {
              type: "image",
              url: this.options.url,
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return !1
          }
          _getOverlappingTileRanges(e) {
            const {
              minX: a,
              minY: o,
              maxX: u,
              maxY: p
            } = s.a6.fromPoints(e), g = {};
            for (let w = 0; w <= s.a7; w++) {
              const I = Math.pow(2, w),
                A = Math.floor(a * I),
                L = Math.floor(o * I),
                O = Math.floor(u * I),
                R = Math.floor(p * I);
              g[w] = {
                minTileX: A,
                minTileY: L,
                maxTileX: O,
                maxTileY: R
              }
            }
            return g
          }
        }
        class Kt extends sr {
          constructor(e, a, o, u) {
            super(e, a, o, u), this.roundZoom = !0, this.type = "video", this.options = a
          }
          load() {
            return s._(this, void 0, void 0, (function*() {
              this._loaded = !1;
              const e = this.options;
              this.urls = [];
              for (const a of e.urls) this.urls.push(this.map._requestManager.transformRequest(a, "Source").url);
              try {
                const a = yield s.a9(this.urls);
                if (this._loaded = !0, !a) return;
                this.video = a, this.video.loop = !0, this.video.addEventListener("playing", (() => {
                  this.map.triggerRepaint()
                })), this.map && this.video.play(), this._finishLoading()
              } catch (a) {
                this.fire(new s.k(a))
              }
            }))
          }
          pause() {
            this.video && this.video.pause()
          }
          play() {
            this.video && this.video.play()
          }
          seek(e) {
            if (this.video) {
              const a = this.video.seekable;
              e < a.start(0) || e > a.end(0) ? this.fire(new s.k(new s.aa(`sources.${this.id}`, null, `Playback for this video can be set only between the ${a.start(0)} and ${a.end(0)}-second mark.`))) : this.video.currentTime = e
            }
          }
          getVideo() {
            return this.video
          }
          onAdd(e) {
            this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)))
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
            const e = this.map.painter.context,
              a = e.gl;
            this.texture ? this.video.paused || (this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE), a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, a.RGBA, a.UNSIGNED_BYTE, this.video)) : (this.texture = new s.T(e, this.video, a.RGBA), this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE));
            let o = !1;
            for (const u in this.tiles) {
              const p = this.tiles[u];
              p.state !== "loaded" && (p.state = "loaded", p.texture = this.texture, o = !0)
            }
            o && this.fire(new s.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          serialize() {
            return {
              type: "video",
              urls: this.urls,
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return this.video && !this.video.paused
          }
        }
        class vr extends sr {
          constructor(e, a, o, u) {
            super(e, a, o, u), a.coordinates ? Array.isArray(a.coordinates) && a.coordinates.length === 4 && !a.coordinates.some((p => !Array.isArray(p) || p.length !== 2 || p.some((g => typeof g != "number")))) || this.fire(new s.k(new s.aa(`sources.${e}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new s.k(new s.aa(`sources.${e}`, null, 'missing required property "coordinates"'))), a.animate && typeof a.animate != "boolean" && this.fire(new s.k(new s.aa(`sources.${e}`, null, 'optional "animate" property must be a boolean value'))), a.canvas ? typeof a.canvas == "string" || a.canvas instanceof HTMLCanvasElement || this.fire(new s.k(new s.aa(`sources.${e}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new s.k(new s.aa(`sources.${e}`, null, 'missing required property "canvas"'))), this.options = a, this.animate = a.animate === void 0 || a.animate
          }
          load() {
            return s._(this, void 0, void 0, (function*() {
              this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new s.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = !0, this.map.triggerRepaint()
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = !1)
              }, this._finishLoading())
            }))
          }
          getCanvas() {
            return this.canvas
          }
          onAdd(e) {
            this.map = e, this.load(), this.canvas && this.animate && this.play()
          }
          onRemove() {
            this.pause()
          }
          prepare() {
            let e = !1;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
            const a = this.map.painter.context,
              o = a.gl;
            this.texture ? (e || this._playing) && this.texture.update(this.canvas, {
              premultiply: !0
            }) : this.texture = new s.T(a, this.canvas, o.RGBA, {
              premultiply: !0
            });
            let u = !1;
            for (const p in this.tiles) {
              const g = this.tiles[p];
              g.state !== "loaded" && (g.state = "loaded", g.texture = this.texture, u = !0)
            }
            u && this.fire(new s.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          serialize() {
            return {
              type: "canvas",
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return this._playing
          }
          _hasInvalidDimensions() {
            for (const e of [this.canvas.width, this.canvas.height])
              if (isNaN(e) || e <= 0) return !0;
            return !1
          }
        }
        const Lr = {},
          ii = d => {
            switch (d) {
              case "geojson":
                return Yt;
              case "image":
                return sr;
              case "raster":
                return ir;
              case "raster-dem":
                return kr;
              case "vector":
                return Rt;
              case "video":
                return Kt;
              case "canvas":
                return vr
            }
            return Lr[d]
          },
          mr = "RTLPluginLoaded";
        class ge extends s.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = Vt()
          }
          _syncState(e) {
            return this.status = e, this.dispatcher.broadcast("SRPS", {
              pluginStatus: e,
              pluginURL: this.url
            }).catch((a => {
              throw this.status = "error", a
            }))
          }
          getRTLTextPluginStatus() {
            return this.status
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null
          }
          setRTLTextPlugin(e) {
            return s._(this, arguments, void 0, (function*(a, o = !1) {
              if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (this.url = re.resolveURL(a), !this.url) throw new Error(`requested url ${a} is invalid`);
              if (this.status === "unavailable") {
                if (!o) return this._requestImport();
                this.status = "deferred", this._syncState(this.status)
              } else if (this.status === "requested") return this._requestImport()
            }))
          }
          _requestImport() {
            return s._(this, void 0, void 0, (function*() {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new s.l(mr))
            }))
          }
          lazyLoad() {
            this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport()
          }
        }
        let V = null;

        function U() {
          return V || (V = new ge), V
        }
        var J, se;
        (function(d) {
          d[d.Base = 0] = "Base", d[d.Parent = 1] = "Parent"
        })(J || (J = {})), (function(d) {
          d[d.Departing = 0] = "Departing", d[d.Incoming = 1] = "Incoming"
        })(se || (se = {}));
        class te {
          constructor(e, a) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.fadeOpacity = 1, this.tileID = e, this.uid = s.ab(), this.uses = 0, this.tileSize = a, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading"
          }
          isRenderable(e) {
            return this.hasData() && (!this.fadeEndTime || this.fadeOpacity > 0) && (e || !this.holdingForSymbolFade())
          }
          setCrossFadeLogic({
            fadingRole: e,
            fadingDirection: a,
            fadingParentID: o,
            fadeEndTime: u
          }) {
            this.resetFadeLogic(), this.fadingRole = e, this.fadingDirection = a, this.fadingParentID = o, this.fadeEndTime = u
          }
          setSelfFadeLogic(e) {
            this.resetFadeLogic(), this.selfFading = !0, this.fadeEndTime = e
          }
          resetFadeLogic() {
            this.fadingRole = null, this.fadingDirection = null, this.fadingParentID = null, this.selfFading = !1, this.timeAdded = me(), this.fadeEndTime = 0, this.fadeOpacity = 1
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading"
          }
          clearTextures(e) {
            this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null
          }
          loadVectorData(e, a, o) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e) {
              e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = (function(u, p) {
                const g = {};
                if (!p) return g;
                for (const w of u) {
                  const I = w.layerIds.map((A => p.getLayer(A))).filter(Boolean);
                  if (I.length !== 0) {
                    w.layers = I, w.stateDependentLayerIds && (w.stateDependentLayers = w.stateDependentLayerIds.map((A => I.filter((L => L.id === A))[0])));
                    for (const A of I) g[A.id] = w
                  }
                }
                return g
              })(e.buckets, a == null ? void 0 : a.style), this.hasSymbolBuckets = !1;
              for (const u in this.buckets) {
                const p = this.buckets[u];
                if (p instanceof s.ad) {
                  if (this.hasSymbolBuckets = !0, !o) break;
                  p.justReloaded = !0
                }
              }
              if (this.hasRTLText = !1, this.hasSymbolBuckets)
                for (const u in this.buckets) {
                  const p = this.buckets[u];
                  if (p instanceof s.ad && p.hasRTLText) {
                    this.hasRTLText = !0, U().lazyLoad();
                    break
                  }
                }
              this.queryPadding = 0;
              for (const u in this.buckets) {
                const p = this.buckets[u];
                this.queryPadding = Math.max(this.queryPadding, a.style.getLayer(u).queryRadius(p))
              }
              e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage), this.dashPositions = e.dashPositions
            } else this.collisionBoxArray = new s.ac
          }
          unloadVectorData() {
            for (const e in this.buckets) this.buckets[e].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.dashPositions && (this.dashPositions = null), this.latestFeatureIndex = null, this.state = "unloaded"
          }
          getBucket(e) {
            return this.buckets[e.id]
          }
          upload(e) {
            for (const o in this.buckets) {
              const u = this.buckets[o];
              u.uploadPending() && u.upload(e)
            }
            const a = e.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new s.T(e, this.imageAtlas.image, a.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new s.T(e, this.glyphAtlasImage, a.ALPHA), this.glyphAtlasImage = null)
          }
          prepare(e) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture)
          }
          queryRenderedFeatures(e, a, o, u, p, g, w, I, A, L, O) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
              queryGeometry: u,
              cameraQueryGeometry: p,
              scale: g,
              tileSize: this.tileSize,
              pixelPosMatrix: L,
              transform: I,
              params: w,
              queryPadding: this.queryPadding * A,
              getElevation: O
            }, e, a, o) : {}
          }
          querySourceFeatures(e, a) {
            const o = this.latestFeatureIndex;
            if (!o || !o.rawTileData) return;
            const u = o.loadVTLayers(),
              p = a && a.sourceLayer ? a.sourceLayer : "",
              g = u._geojsonTileLayer || u[p];
            if (!g) return;
            const w = s.ae(a == null ? void 0 : a.filter, a == null ? void 0 : a.globalState),
              {
                z: I,
                x: A,
                y: L
              } = this.tileID.canonical,
              O = {
                z: I,
                x: A,
                y: L
              };
            for (let R = 0; R < g.length; R++) {
              const H = g.feature(R);
              if (w.needGeometry) {
                const ue = s.af(H, !0);
                if (!w.filter(new s.G(this.tileID.overscaledZ), ue, this.tileID.canonical)) continue
              } else if (!w.filter(new s.G(this.tileID.overscaledZ), H)) continue;
              const $ = o.getId(H, p),
                ce = new s.ag(H, I, A, L, $);
              ce.tile = O, e.push(ce)
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired"
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length
          }
          setExpiryData(e) {
            const a = this.expirationTime;
            if (e.cacheControl) {
              const o = s.ah(e.cacheControl);
              o["max-age"] && (this.expirationTime = Date.now() + 1e3 * o["max-age"])
            } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
            if (this.expirationTime) {
              const o = Date.now();
              let u = !1;
              if (this.expirationTime > o) u = !1;
              else if (a)
                if (this.expirationTime < a) u = !0;
                else {
                  const p = this.expirationTime - a;
                  p ? this.expirationTime = o + Math.max(p, 3e4) : u = !0
                }
              else u = !0;
              u ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1)
          }
          setFeatureState(e, a) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0) return;
            const o = this.latestFeatureIndex.loadVTLayers();
            for (const u in this.buckets) {
              if (!a.style.hasLayer(u)) continue;
              const p = this.buckets[u],
                g = p.layers[0].sourceLayer || "_geojsonTileLayer",
                w = o[g],
                I = e[g];
              if (!w || !I || Object.keys(I).length === 0) continue;
              p.update(I, w, this.imageAtlas && this.imageAtlas.patternPositions || {}, this.dashPositions || {});
              const A = a && a.style && a.style.getLayer(u);
              A && (this.queryPadding = Math.max(this.queryPadding, A.queryRadius(p)))
            }
          }
          holdingForSymbolFade() {
            return this.symbolFadeHoldUntil !== void 0
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < me()
          }
          clearSymbolFadeHold() {
            this.symbolFadeHoldUntil = void 0
          }
          setSymbolHoldDuration(e) {
            this.symbolFadeHoldUntil = me() + e
          }
          setDependencies(e, a) {
            const o = {};
            for (const u of a) o[u] = !0;
            this.dependencies[e] = o
          }
          hasDependency(e, a) {
            for (const o of e) {
              const u = this.dependencies[o];
              if (u) {
                for (const p of a)
                  if (u[p]) return !0
              }
            }
            return !1
          }
        }
        class _e {
          constructor(e, a) {
            this.max = e, this.onRemove = a, this.reset()
          }
          reset() {
            for (const e in this.data)
              for (const a of this.data[e]) a.timeout && clearTimeout(a.timeout), this.onRemove(a.value);
            return this.data = {}, this.order = [], this
          }
          add(e, a, o) {
            const u = e.wrapped().key;
            this.data[u] === void 0 && (this.data[u] = []);
            const p = {
              value: a,
              timeout: void 0
            };
            if (o !== void 0 && (p.timeout = setTimeout((() => {
                this.remove(e, p)
              }), o)), this.data[u].push(p), this.order.push(u), this.order.length > this.max) {
              const g = this._getAndRemoveByKey(this.order[0]);
              g && this.onRemove(g)
            }
            return this
          }
          has(e) {
            return e.wrapped().key in this.data
          }
          getAndRemove(e) {
            return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null
          }
          _getAndRemoveByKey(e) {
            const a = this.data[e].shift();
            return a.timeout && clearTimeout(a.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), a.value
          }
          getByKey(e) {
            const a = this.data[e];
            return a ? a[0].value : null
          }
          get(e) {
            return this.has(e) ? this.data[e.wrapped().key][0].value : null
          }
          remove(e, a) {
            if (!this.has(e)) return this;
            const o = e.wrapped().key,
              u = a === void 0 ? 0 : this.data[o].indexOf(a),
              p = this.data[o][u];
            return this.data[o].splice(u, 1), p.timeout && clearTimeout(p.timeout), this.data[o].length === 0 && delete this.data[o], this.onRemove(p.value), this.order.splice(this.order.indexOf(o), 1), this
          }
          setMaxSize(e) {
            for (this.max = e; this.order.length > this.max;) {
              const a = this._getAndRemoveByKey(this.order[0]);
              a && this.onRemove(a)
            }
            return this
          }
          filter(e) {
            const a = [];
            for (const o in this.data)
              for (const u of this.data[o]) e(u.value) || a.push(u);
            for (const o of a) this.remove(o.value.tileID, o)
          }
        }
        class Re {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {}
          }
          updateState(e, a, o) {
            const u = String(a);
            if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][u] = this.stateChanges[e][u] || {}, s.e(this.stateChanges[e][u], o), this.deletedStates[e] === null) {
              this.deletedStates[e] = {};
              for (const p in this.state[e]) p !== u && (this.deletedStates[e][p] = null)
            } else if (this.deletedStates[e] && this.deletedStates[e][u] === null) {
              this.deletedStates[e][u] = {};
              for (const p in this.state[e][u]) o[p] || (this.deletedStates[e][u][p] = null)
            } else
              for (const p in o) this.deletedStates[e] && this.deletedStates[e][u] && this.deletedStates[e][u][p] === null && delete this.deletedStates[e][u][p]
          }
          removeFeatureState(e, a, o) {
            if (this.deletedStates[e] === null) return;
            const u = String(a);
            if (this.deletedStates[e] = this.deletedStates[e] || {}, o && a !== void 0) this.deletedStates[e][u] !== null && (this.deletedStates[e][u] = this.deletedStates[e][u] || {}, this.deletedStates[e][u][o] = null);
            else if (a !== void 0)
              if (this.stateChanges[e] && this.stateChanges[e][u])
                for (o in this.deletedStates[e][u] = {}, this.stateChanges[e][u]) this.deletedStates[e][u][o] = null;
              else this.deletedStates[e][u] = null;
            else this.deletedStates[e] = null
          }
          getState(e, a) {
            const o = String(a),
              u = s.e({}, (this.state[e] || {})[o], (this.stateChanges[e] || {})[o]);
            if (this.deletedStates[e] === null) return {};
            if (this.deletedStates[e]) {
              const p = this.deletedStates[e][a];
              if (p === null) return {};
              for (const g in p) delete u[g]
            }
            return u
          }
          initializeTileState(e, a) {
            e.setFeatureState(this.state, a)
          }
          coalesceChanges(e, a) {
            const o = {};
            for (const u in this.stateChanges) {
              this.state[u] = this.state[u] || {};
              const p = {};
              for (const g in this.stateChanges[u]) this.state[u][g] || (this.state[u][g] = {}), s.e(this.state[u][g], this.stateChanges[u][g]), p[g] = this.state[u][g];
              o[u] = p
            }
            for (const u in this.deletedStates) {
              this.state[u] = this.state[u] || {};
              const p = {};
              if (this.deletedStates[u] === null)
                for (const g in this.state[u]) p[g] = {}, this.state[u][g] = {};
              else
                for (const g in this.deletedStates[u]) {
                  if (this.deletedStates[u][g] === null) this.state[u][g] = {};
                  else
                    for (const w of Object.keys(this.deletedStates[u][g])) delete this.state[u][g][w];
                  p[g] = this.state[u][g]
                }
              o[u] = o[u] || {}, s.e(o[u], p)
            }
            if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(o).length !== 0)
              for (const u in e) e[u].setFeatureState(o, a)
          }
        }
        const ne = 89.25;

        function oe(d, e) {
          const a = s.ai(e.lat, -s.aj, s.aj);
          return new s.P(s.X(e.lng) * d, s.W(a) * d)
        }

        function fe(d, e) {
          return new s.a5(e.x / d, e.y / d).toLngLat()
        }

        function ve(d) {
          return d.cameraToCenterDistance * Math.min(.85 * Math.tan(s.ak(90 - d.pitch)), Math.tan(s.ak(ne - d.pitch)))
        }

        function ie(d, e) {
          const a = d.canonical,
            o = e / s.al(a.z),
            u = a.x + Math.pow(2, a.z) * d.wrap,
            p = s.am(new Float64Array(16));
          return s.N(p, p, [u * o, a.y * o, 0]), s.O(p, p, [o / s.a3, o / s.a3, 1]), p
        }

        function Y(d, e, a, o, u) {
          const p = s.a5.fromLngLat(d, e),
            g = u * s.an(1, d.lat),
            w = g * Math.cos(s.ak(a)),
            I = Math.sqrt(g * g - w * w),
            A = I * Math.sin(s.ak(-o)),
            L = I * Math.cos(s.ak(-o));
          return new s.a5(p.x + A, p.y + L, p.z + w)
        }

        function Fe(d, e, a) {
          const o = e.intersectsFrustum(d);
          if (!a || o === 0) return o;
          const u = e.intersectsPlane(a);
          return u === 0 ? 0 : o === 2 && u === 2 ? 2 : 1
        }

        function Ne(d, e, a) {
          let o = 0;
          const u = (a - e) / 10;
          for (let p = 0; p < 10; p++) o += u * Math.pow(Math.cos(e + (p + .5) / 10 * (a - e)), d);
          return o
        }

        function Ge(d, e) {
          return function(a, o, u, p, g) {
            const w = 2 * ((d - 1) / s.ao(Math.cos(s.ak(ne - g)) / Math.cos(s.ak(ne))) - 1),
              I = Math.acos(u / p),
              A = 2 * Ne(w - 1, 0, s.ak(g / 2)),
              L = Math.min(s.ak(ne), I + s.ak(g / 2)),
              O = Ne(w - 1, Math.min(L, I - s.ak(g / 2)), L),
              R = Math.atan(o / u),
              H = Math.hypot(o, u);
            let $ = a;
            return $ += s.ao(p / H / Math.max(.5, Math.cos(s.ak(g / 2)))), $ += w * s.ao(Math.cos(R)) / 2, $ -= s.ao(Math.max(1, O / A / e)) / 2, $
          }
        }
        const pe = Ge(9.314, 3);

        function Ve(d, e) {
          const a = (e.roundZoom ? Math.round : Math.floor)(d.zoom + s.ao(d.tileSize / e.tileSize));
          return Math.max(0, a)
        }

        function it(d, e) {
          const a = d.getCameraFrustum(),
            o = d.getClippingPlane(),
            u = d.screenPointToMercatorCoordinate(d.getCameraPoint()),
            p = s.a5.fromLngLat(d.center, d.elevation);
          u.z = p.z + Math.cos(d.pitchInRadians) * d.cameraToCenterDistance / d.worldSize;
          const g = d.getCoveringTilesDetailsProvider(),
            w = g.allowVariableZoom(d, e),
            I = Ve(d, e),
            A = e.minzoom || 0,
            L = e.maxzoom !== void 0 ? e.maxzoom : d.maxZoom,
            O = Math.min(Math.max(0, I), L),
            R = Math.pow(2, O),
            H = [R * u.x, R * u.y, 0],
            $ = [R * p.x, R * p.y, 0],
            ce = Math.hypot(p.x - u.x, p.y - u.y),
            ue = Math.abs(p.z - u.z),
            de = Math.hypot(ce, ue),
            Ce = Oe => ({
              zoom: 0,
              x: 0,
              y: 0,
              wrap: Oe,
              fullyVisible: !1
            }),
            Be = [],
            Ie = [];
          if (d.renderWorldCopies && g.allowWorldCopies())
            for (let Oe = 1; Oe <= 3; Oe++) Be.push(Ce(-Oe)), Be.push(Ce(Oe));
          for (Be.push(Ce(0)); Be.length > 0;) {
            const Oe = Be.pop(),
              He = Oe.x,
              Le = Oe.y;
            let $e = Oe.fullyVisible;
            const vt = {
                x: He,
                y: Le,
                z: Oe.zoom
              },
              ft = g.getTileBoundingVolume(vt, Oe.wrap, d.elevation, e);
            if (!$e) {
              const cr = Fe(a, ft, o);
              if (cr === 0) continue;
              $e = cr === 2
            }
            const gt = g.distanceToTile2d(u.x, u.y, vt, ft);
            let xt = I;
            w && (xt = (e.calculateTileZoom || pe)(d.zoom + s.ao(d.tileSize / e.tileSize), gt, ue, de, d.fov)), xt = (e.roundZoom ? Math.round : Math.floor)(xt), xt = Math.max(0, xt);
            const lr = Math.min(xt, L);
            if (Oe.wrap = g.getWrap(p, vt, Oe.wrap), Oe.zoom >= lr) {
              if (Oe.zoom < A) continue;
              const cr = O - Oe.zoom,
                Nt = H[0] - .5 - (He << cr),
                Nr = H[1] - .5 - (Le << cr),
                Pi = e.reparseOverscaled ? Math.max(Oe.zoom, xt) : Oe.zoom;
              Ie.push({
                tileID: new s.a0(Oe.zoom === L ? Pi : Oe.zoom, Oe.wrap, Oe.zoom, He, Le),
                distanceSq: s.ap([$[0] - .5 - He, $[1] - .5 - Le]),
                tileDistanceToCamera: Math.sqrt(Nt * Nt + Nr * Nr)
              })
            } else
              for (let cr = 0; cr < 4; cr++) Be.push({
                zoom: Oe.zoom + 1,
                x: (He << 1) + cr % 2,
                y: (Le << 1) + (cr >> 1),
                wrap: Oe.wrap,
                fullyVisible: $e
              })
          }
          return Ie.sort(((Oe, He) => Oe.distanceSq - He.distanceSq)).map((Oe => Oe.tileID))
        }
        const yt = s.a6.fromPoints([new s.P(0, 0), new s.P(s.a3, s.a3)]);
        class Lt extends s.E {
          constructor(e, a, o) {
            super(), this.id = e, this.dispatcher = o, this.on("data", (u => this._dataHandler(u))), this.on("dataloading", (() => {
              this._sourceErrored = !1
            })), this.on("error", (() => {
              this._sourceErrored = this._source.loaded()
            })), this._source = ((u, p, g, w) => {
              const I = new(ii(p.type))(u, p, g, w);
              if (I.id !== u) throw new Error(`Expected Source id to be ${u} instead of ${I.id}`);
              return I
            })(e, a, o, this), this._tiles = {}, this._cache = new _e(0, (u => this._unloadTile(u))), this._timers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._rasterFadeDuration = 0, this._maxFadingAncestorLevels = 5, this._state = new Re, this._didEmitContent = !1, this._updated = !1
          }
          onAdd(e) {
            this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e)
          }
          onRemove(e) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e)
          }
          loaded() {
            if (this._sourceErrored) return !0;
            if (!this._sourceLoaded || !this._source.loaded()) return !1;
            if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
            if (!this._updated) return !1;
            for (const e in this._tiles) {
              const a = this._tiles[e];
              if (a.state !== "loaded" && a.state !== "errored") return !1
            }
            return !0
          }
          getSource() {
            return this._source
          }
          getState() {
            return this._state
          }
          pause() {
            this._paused = !0
          }
          resume() {
            if (!this._paused) return;
            const e = this._shouldReloadOnResume;
            this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform, this.terrain)
          }
          _loadTile(e, a, o) {
            return s._(this, void 0, void 0, (function*() {
              try {
                yield this._source.loadTile(e), this._tileLoaded(e, a, o)
              } catch (u) {
                e.state = "errored", u.status !== 404 ? this._source.fire(new s.k(u, {
                  tile: e
                })) : this.update(this.transform, this.terrain)
              }
            }))
          }
          _unloadTile(e) {
            this._source.unloadTile && this._source.unloadTile(e)
          }
          _abortTile(e) {
            this._source.abortTile && this._source.abortTile(e), this._source.fire(new s.l("dataabort", {
              tile: e,
              coord: e.tileID,
              dataType: "source"
            }))
          }
          serialize() {
            return this._source.serialize()
          }
          prepare(e) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const a in this._tiles) {
              const o = this._tiles[a];
              o.upload(e), o.prepare(this.map.style.imageManager)
            }
          }
          getIds() {
            return Object.values(this._tiles).map((e => e.tileID)).sort(ct).map((e => e.key))
          }
          getRenderableIds(e) {
            const a = [];
            for (const o in this._tiles) this._isIdRenderable(o, e) && a.push(this._tiles[o]);
            return e ? a.sort(((o, u) => {
              const p = o.tileID,
                g = u.tileID,
                w = new s.P(p.canonical.x, p.canonical.y)._rotate(-this.transform.bearingInRadians),
                I = new s.P(g.canonical.x, g.canonical.y)._rotate(-this.transform.bearingInRadians);
              return p.overscaledZ - g.overscaledZ || I.y - w.y || I.x - w.x
            })).map((o => o.tileID.key)) : a.map((o => o.tileID)).sort(ct).map((o => o.key))
          }
          hasRenderableParent(e) {
            const a = e.overscaledZ - 1;
            if (a >= this._source.minzoom) {
              const o = this.getLoadedTile(e.scaledTo(a));
              if (o) return this._isIdRenderable(o.tileID.key)
            }
            return !1
          }
          _isIdRenderable(e, a = !1) {
            var o;
            return (o = this._tiles[e]) === null || o === void 0 ? void 0 : o.isRenderable(a)
          }
          reload(e, a = void 0) {
            if (this._paused) this._shouldReloadOnResume = !0;
            else {
              this._cache.reset();
              for (const o in this._tiles) a && this._source.shouldReloadTile && !this._source.shouldReloadTile(this._tiles[o], a) || (e ? this._reloadTile(o, "expired") : this._tiles[o].state !== "errored" && this._reloadTile(o, "reloading"))
            }
          }
          _reloadTile(e, a) {
            return s._(this, void 0, void 0, (function*() {
              const o = this._tiles[e];
              o && (o.state !== "loading" && (o.state = a), yield this._loadTile(o, e, a))
            }))
          }
          _tileLoaded(e, a, o) {
            e.timeAdded = me(), e.selfFading && (e.fadeEndTime = e.timeAdded + this._rasterFadeDuration), o === "expired" && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(a, e), this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new s.l("data", {
              dataType: "source",
              tile: e,
              coord: e.tileID
            }))
          }
          _backfillDEM(e) {
            const a = this.getRenderableIds();
            for (let u = 0; u < a.length; u++) {
              const p = a[u];
              if (e.neighboringTiles && e.neighboringTiles[p]) {
                const g = this.getTileByID(p);
                o(e, g), o(g, e)
              }
            }

            function o(u, p) {
              u.needsHillshadePrepare = !0, u.needsTerrainPrepare = !0;
              let g = p.tileID.canonical.x - u.tileID.canonical.x;
              const w = p.tileID.canonical.y - u.tileID.canonical.y,
                I = Math.pow(2, u.tileID.canonical.z),
                A = p.tileID.key;
              g === 0 && w === 0 || Math.abs(w) > 1 || (Math.abs(g) > 1 && (Math.abs(g + I) === 1 ? g += I : Math.abs(g - I) === 1 && (g -= I)), p.dem && u.dem && (u.dem.backfillBorder(p.dem, g, w), u.neighboringTiles && u.neighboringTiles[A] && (u.neighboringTiles[A].backfilled = !0)))
            }
          }
          getTile(e) {
            return this.getTileByID(e.key)
          }
          getTileByID(e) {
            return this._tiles[e]
          }
          _retainLoadedChildren(e, a) {
            const o = Object.values(e),
              u = this._getLoadedDescendents(o),
              p = {};
            for (const g of o) {
              const w = u[g.key];
              if (!(w != null && w.length)) {
                p[g.key] = g;
                continue
              }
              const I = g.overscaledZ + Lt.maxUnderzooming,
                A = w.filter((R => R.tileID.overscaledZ <= I));
              if (!A.length) {
                p[g.key] = g;
                continue
              }
              const L = Math.min(...A.map((R => R.tileID.overscaledZ))),
                O = A.filter((R => R.tileID.overscaledZ === L)).map((R => R.tileID));
              for (const R of O) a[R.key] = R;
              this._areDescendentsComplete(O, L, g.overscaledZ) || (p[g.key] = g)
            }
            return p
          }
          _getLoadedDescendents(e) {
            var a;
            const o = {};
            for (const u in this._tiles) {
              const p = this._tiles[u];
              if (p.hasData())
                for (const g of e) p.tileID.isChildOf(g) && (o[a = g.key] || (o[a] = [])).push(p)
            }
            return o
          }
          _areDescendentsComplete(e, a, o) {
            return e.length === 1 && e[0].isOverscaled() ? e[0].overscaledZ === a : Math.pow(4, a - o) === e.length
          }
          getLoadedTile(e) {
            const a = this._tiles[e.key];
            return a != null && a.hasData() ? a : null
          }
          updateCacheSize(e) {
            const a = Math.ceil(e.width / this._source.tileSize) + 1,
              o = Math.ceil(e.height / this._source.tileSize) + 1,
              u = Math.floor(a * o * (this._maxTileCacheZoomLevels === null ? s.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)),
              p = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, u) : u;
            this._cache.setMaxSize(p)
          }
          handleWrapJump(e) {
            const a = Math.round((e - (this._prevLng === void 0 ? e : this._prevLng)) / 360);
            if (this._prevLng = e, a) {
              const o = {};
              for (const u in this._tiles) {
                const p = this._tiles[u];
                p.tileID = p.tileID.unwrapTo(p.tileID.wrap + a), o[p.tileID.key] = p
              }
              this._tiles = o, this._resetTileReloadTimers()
            }
          }
          update(e, a) {
            if (!this._sourceLoaded || this._paused) return;
            let o;
            this.transform = e, this.terrain = a, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this.used || this.usedForTerrain ? this._source.tileID ? o = e.getVisibleUnwrappedCoordinates(this._source.tileID).map((I => new s.a0(I.canonical.z, I.wrap, I.canonical.z, I.canonical.x, I.canonical.y))) : (o = it(e, {
              tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize,
              minzoom: this._source.minzoom,
              maxzoom: this._source.maxzoom,
              roundZoom: !this.usedForTerrain && this._source.roundZoom,
              reparseOverscaled: this._source.reparseOverscaled,
              terrain: a,
              calculateTileZoom: this._source.calculateTileZoom
            }), this._source.hasTile && (o = o.filter((I => this._source.hasTile(I))))) : o = [], this.usedForTerrain && (o = this._addTerrainIdealTiles(o));
            const u = o.length === 0 && !this._updated && this._didEmitContent;
            this._updated = !0, u && this.fire(new s.l("data", {
              sourceDataType: "idle",
              dataType: "source",
              sourceId: this.id
            }));
            const p = Ve(e, this._source),
              g = this._updateRetainedTiles(o, p),
              w = At(this._source.type);
            w && this._rasterFadeDuration > 0 && !a && this._updateFadingTiles(o, g), w ? this._cleanUpRasterTiles(g) : this._cleanUpVectorTiles(g)
          }
          _cleanUpRasterTiles(e) {
            for (const a in this._tiles) e[a] || this._removeTile(a)
          }
          _cleanUpVectorTiles(e) {
            for (const a in this._tiles) {
              const o = this._tiles[a];
              e[a] ? o.clearSymbolFadeHold() : o.hasSymbolBuckets ? o.holdingForSymbolFade() ? o.symbolFadeFinished() && this._removeTile(a) : o.setSymbolHoldDuration(this.map._fadeDuration) : this._removeTile(a)
            }
          }
          _addTerrainIdealTiles(e) {
            const a = [];
            for (const o of e)
              if (o.canonical.z > this._source.minzoom) {
                const u = o.scaledTo(o.canonical.z - 1);
                a.push(u);
                const p = o.scaledTo(Math.max(this._source.minzoom, Math.min(o.canonical.z, 5)));
                a.push(p)
              } return e.concat(a)
          }
          releaseSymbolFadeTiles() {
            for (const e in this._tiles) this._tiles[e].holdingForSymbolFade() && this._removeTile(e)
          }
          _updateRetainedTiles(e, a) {
            var o;
            const u = {},
              p = {},
              g = Math.max(a - Lt.maxOverzooming, this._source.minzoom);
            let w = {};
            for (const I of e) {
              const A = this._addTile(I);
              u[I.key] = I, A.hasData() || (w[I.key] = I)
            }
            w = this._retainLoadedChildren(w, u);
            for (const I in w) {
              const A = w[I];
              let L = this._tiles[I],
                O = L == null ? void 0 : L.wasRequested();
              for (let R = A.overscaledZ - 1; R >= g; --R) {
                const H = A.scaledTo(R);
                if (p[H.key]) break;
                if (p[H.key] = !0, L = this.getTile(H), !L && O && (L = this._addTile(H)), L) {
                  const $ = L.hasData();
                  if (($ || !(!((o = this.map) === null || o === void 0) && o.cancelPendingTileRequestsWhileZooming) || O) && (u[H.key] = H), O = L.wasRequested(), $) break
                }
              }
            }
            return u
          }
          _updateFadingTiles(e, a) {
            const o = me(),
              u = s.aq(e);
            for (const p of e) {
              const g = this._tiles[p.key];
              g.fadingDirection !== se.Departing && g.fadeOpacity !== 0 || g.resetFadeLogic(), this._updateFadingAncestor(g, a, o) || this._updateFadingDescendents(g, a, o) || this._updateFadingEdge(g, u, o) || g.resetFadeLogic()
            }
          }
          _updateFadingAncestor(e, a, o) {
            if (!e.hasData()) return !1;
            const {
              tileID: u,
              fadingRole: p,
              fadingDirection: g,
              fadingParentID: w
            } = e;
            if (p === J.Base && g === se.Incoming && w) return a[w.key] = w, !0;
            const I = Math.max(u.overscaledZ - this._maxFadingAncestorLevels, this._source.minzoom);
            for (let A = u.overscaledZ - 1; A >= I; A--) {
              const L = u.scaledTo(A),
                O = this.getLoadedTile(L);
              if (O) return e.setCrossFadeLogic({
                fadingRole: J.Base,
                fadingDirection: se.Incoming,
                fadingParentID: O.tileID,
                fadeEndTime: o + this._rasterFadeDuration
              }), O.setCrossFadeLogic({
                fadingRole: J.Parent,
                fadingDirection: se.Departing,
                fadeEndTime: o + this._rasterFadeDuration
              }), a[L.key] = L, !0
            }
            return !1
          }
          _updateFadingDescendents(e, a, o) {
            if (!e.hasData()) return !1;
            const u = e.tileID.children(this._source.maxzoom);
            let p = this._updateFadingChildren(e, u, a, o);
            if (p) return !0;
            for (const g of u) {
              const w = g.children(this._source.maxzoom);
              this._updateFadingChildren(e, w, a, o) && (p = !0)
            }
            return p
          }
          _updateFadingChildren(e, a, o, u) {
            if (a[0].overscaledZ >= this._source.maxzoom) return !1;
            let p = !1;
            for (const g of a) {
              const w = this.getLoadedTile(g);
              if (!w) continue;
              const {
                fadingRole: I,
                fadingDirection: A,
                fadingParentID: L
              } = w;
              I === J.Base && A === se.Departing && L || (w.setCrossFadeLogic({
                fadingRole: J.Base,
                fadingDirection: se.Departing,
                fadingParentID: e.tileID,
                fadeEndTime: u + this._rasterFadeDuration
              }), e.setCrossFadeLogic({
                fadingRole: J.Parent,
                fadingDirection: se.Incoming,
                fadeEndTime: u + this._rasterFadeDuration
              })), o[g.key] = g, p = !0
            }
            return p
          }
          _updateFadingEdge(e, a, o) {
            const u = e.tileID;
            return !!e.selfFading || !e.hasData() && !!a.has(u) && (e.setSelfFadeLogic(o + this._rasterFadeDuration), !0)
          }
          _addTile(e) {
            let a = this._tiles[e.key];
            if (a) return a;
            a = this._cache.getAndRemove(e), a && (a.resetFadeLogic(), this._setTileReloadTimer(e.key, a), a.tileID = e, this._state.initializeTileState(a, this.map ? this.map.painter : null));
            const o = a;
            return a || (a = new te(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(a, e.key, a.state)), a.uses++, this._tiles[e.key] = a, o || this._source.fire(new s.l("dataloading", {
              tile: a,
              coord: a.tileID,
              dataType: "source"
            })), a
          }
          _setTileReloadTimer(e, a) {
            this._clearTileReloadTimer(e);
            const o = a.getExpiryTimeout();
            o && (this._timers[e] = setTimeout((() => {
              this._reloadTile(e, "expired"), delete this._timers[e]
            }), o))
          }
          _clearTileReloadTimer(e) {
            const a = this._timers[e];
            a && (clearTimeout(a), delete this._timers[e])
          }
          _resetTileReloadTimers() {
            for (const e in this._timers) clearTimeout(this._timers[e]), delete this._timers[e];
            for (const e in this._tiles) this._setTileReloadTimer(e, this._tiles[e])
          }
          refreshTiles(e) {
            for (const a in this._tiles)(this._isIdRenderable(a) || this._tiles[a].state == "errored") && e.some((o => o.equals(this._tiles[a].tileID.canonical))) && this._reloadTile(a, "expired")
          }
          _removeTile(e) {
            const a = this._tiles[e];
            a && (a.uses--, delete this._tiles[e], this._clearTileReloadTimer(e), a.uses > 0 || (a.hasData() && a.state !== "reloading" ? this._cache.add(a.tileID, a, a.getExpiryTimeout()) : (a.aborted = !0, this._abortTile(a), this._unloadTile(a))))
          }
          _dataHandler(e) {
            e.dataType === "source" && (e.sourceDataType !== "metadata" ? e.sourceDataType === "content" && this._sourceLoaded && !this._paused && (this.reload(e.sourceDataChanged, e.shouldReloadTileOptions), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0) : this._sourceLoaded = !0)
          }
          clearTiles() {
            this._shouldReloadOnResume = !1, this._paused = !1;
            for (const e in this._tiles) this._removeTile(e);
            this._cache.reset()
          }
          tilesIn(e, a, o) {
            const u = [],
              p = this.transform;
            if (!p) return u;
            const g = p.getCoveringTilesDetailsProvider().allowWorldCopies(),
              w = o ? p.getCameraQueryGeometry(e) : e,
              I = H => p.screenPointToMercatorCoordinate(H, this.terrain),
              A = this.transformBbox(e, I, !g),
              L = this.transformBbox(w, I, !g),
              O = this.getIds(),
              R = s.a6.fromPoints(L);
            for (let H = 0; H < O.length; H++) {
              const $ = this._tiles[O[H]];
              if ($.holdingForSymbolFade()) continue;
              const ce = g ? [$.tileID] : [$.tileID.unwrapTo(-1), $.tileID.unwrapTo(0)],
                ue = Math.pow(2, p.zoom - $.tileID.overscaledZ),
                de = a * $.queryPadding * s.a3 / $.tileSize / ue;
              for (const Ce of ce) {
                const Be = R.map((Ie => Ce.getTilePoint(new s.a5(Ie.x, Ie.y))));
                if (Be.expandBy(de), Be.intersects(yt)) {
                  const Ie = A.map((He => Ce.getTilePoint(He))),
                    Oe = L.map((He => Ce.getTilePoint(He)));
                  u.push({
                    tile: $,
                    tileID: g ? Ce : Ce.unwrapTo(0),
                    queryGeometry: Ie,
                    cameraQueryGeometry: Oe,
                    scale: ue
                  })
                }
              }
            }
            return u
          }
          transformBbox(e, a, o) {
            let u = e.map(a);
            if (o) {
              const p = s.a6.fromPoints(e);
              p.shrinkBy(.001 * Math.min(p.width(), p.height()));
              const g = p.map(a);
              s.a6.fromPoints(u).covers(g) || (u = u.map((w => w.x > .5 ? new s.a5(w.x - 1, w.y, w.z) : w)))
            }
            return u
          }
          getVisibleCoordinates(e) {
            const a = this.getRenderableIds(e).map((o => this._tiles[o].tileID));
            return this.transform && this.transform.populateCache(a), a
          }
          hasTransition() {
            if (this._source.hasTransition()) return !0;
            if (At(this._source.type) && this._rasterFadeDuration > 0) {
              const e = me();
              for (const a in this._tiles)
                if (this._tiles[a].fadeEndTime >= e) return !0
            }
            return !1
          }
          setRasterFadeDuration(e) {
            this._rasterFadeDuration = e
          }
          setFeatureState(e, a, o) {
            this._state.updateState(e = e || "_geojsonTileLayer", a, o)
          }
          removeFeatureState(e, a, o) {
            this._state.removeFeatureState(e = e || "_geojsonTileLayer", a, o)
          }
          getFeatureState(e, a) {
            return this._state.getState(e = e || "_geojsonTileLayer", a)
          }
          setDependencies(e, a, o) {
            const u = this._tiles[e];
            u && u.setDependencies(a, o)
          }
          reloadTilesForDependencies(e, a) {
            for (const o in this._tiles) this._tiles[o].hasDependency(e, a) && this._reloadTile(o, "reloading");
            this._cache.filter((o => !o.hasDependency(e, a)))
          }
        }

        function ct(d, e) {
          const a = Math.abs(2 * d.wrap) - +(d.wrap < 0),
            o = Math.abs(2 * e.wrap) - +(e.wrap < 0);
          return d.overscaledZ - e.overscaledZ || o - a || e.canonical.y - d.canonical.y || e.canonical.x - d.canonical.x
        }

        function At(d) {
          return d === "raster" || d === "image" || d === "video"
        }
        Lt.maxOverzooming = 10, Lt.maxUnderzooming = 3;
        class qt {
          constructor(e, a) {
            this.reset(e, a)
          }
          reset(e, a) {
            this.points = e || [], this._distances = [0];
            for (let o = 1; o < this.points.length; o++) this._distances[o] = this._distances[o - 1] + this.points[o].dist(this.points[o - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(a || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding
          }
          lerp(e) {
            if (this.points.length === 1) return this.points[0];
            e = s.ai(e, 0, 1);
            let a = 1,
              o = this._distances[a];
            const u = e * this.paddedLength + this.padding;
            for (; o < u && a < this._distances.length;) o = this._distances[++a];
            const p = a - 1,
              g = this._distances[p],
              w = o - g,
              I = w > 0 ? (u - g) / w : 0;
            return this.points[p].mult(1 - I).add(this.points[a].mult(I))
          }
        }

        function Ke(d, e) {
          let a = !0;
          return d === "always" || d !== "never" && e !== "never" || (a = !1), a
        }
        class Tt {
          constructor(e, a, o) {
            const u = this.boxCells = [],
              p = this.circleCells = [];
            this.xCellCount = Math.ceil(e / o), this.yCellCount = Math.ceil(a / o);
            for (let g = 0; g < this.xCellCount * this.yCellCount; g++) u.push([]), p.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = a, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / a, this.boxUid = 0, this.circleUid = 0
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length
          }
          insert(e, a, o, u, p) {
            this._forEachCell(a, o, u, p, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(a), this.bboxes.push(o), this.bboxes.push(u), this.bboxes.push(p)
          }
          insertCircle(e, a, o, u) {
            this._forEachCell(a - u, o - u, a + u, o + u, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(a), this.circles.push(o), this.circles.push(u)
          }
          _insertBoxCell(e, a, o, u, p, g) {
            this.boxCells[p].push(g)
          }
          _insertCircleCell(e, a, o, u, p, g) {
            this.circleCells[p].push(g)
          }
          _query(e, a, o, u, p, g, w) {
            if (o < 0 || e > this.width || u < 0 || a > this.height) return [];
            const I = [];
            if (e <= 0 && a <= 0 && this.width <= o && this.height <= u) {
              if (p) return [{
                key: null,
                x1: e,
                y1: a,
                x2: o,
                y2: u
              }];
              for (let A = 0; A < this.boxKeys.length; A++) I.push({
                key: this.boxKeys[A],
                x1: this.bboxes[4 * A],
                y1: this.bboxes[4 * A + 1],
                x2: this.bboxes[4 * A + 2],
                y2: this.bboxes[4 * A + 3]
              });
              for (let A = 0; A < this.circleKeys.length; A++) {
                const L = this.circles[3 * A],
                  O = this.circles[3 * A + 1],
                  R = this.circles[3 * A + 2];
                I.push({
                  key: this.circleKeys[A],
                  x1: L - R,
                  y1: O - R,
                  x2: L + R,
                  y2: O + R
                })
              }
            } else this._forEachCell(e, a, o, u, this._queryCell, I, {
              hitTest: p,
              overlapMode: g,
              seenUids: {
                box: {},
                circle: {}
              }
            }, w);
            return I
          }
          query(e, a, o, u) {
            return this._query(e, a, o, u, !1, null)
          }
          hitTest(e, a, o, u, p, g) {
            return this._query(e, a, o, u, !0, p, g).length > 0
          }
          hitTestCircle(e, a, o, u, p) {
            const g = e - o,
              w = e + o,
              I = a - o,
              A = a + o;
            if (w < 0 || g > this.width || A < 0 || I > this.height) return !1;
            const L = [];
            return this._forEachCell(g, I, w, A, this._queryCellCircle, L, {
              hitTest: !0,
              overlapMode: u,
              circle: {
                x: e,
                y: a,
                radius: o
              },
              seenUids: {
                box: {},
                circle: {}
              }
            }, p), L.length > 0
          }
          _queryCell(e, a, o, u, p, g, w, I) {
            const {
              seenUids: A,
              hitTest: L,
              overlapMode: O
            } = w, R = this.boxCells[p];
            if (R !== null) {
              const $ = this.bboxes;
              for (const ce of R)
                if (!A.box[ce]) {
                  A.box[ce] = !0;
                  const ue = 4 * ce,
                    de = this.boxKeys[ce];
                  if (e <= $[ue + 2] && a <= $[ue + 3] && o >= $[ue + 0] && u >= $[ue + 1] && (!I || I(de)) && (!L || !Ke(O, de.overlapMode)) && (g.push({
                      key: de,
                      x1: $[ue],
                      y1: $[ue + 1],
                      x2: $[ue + 2],
                      y2: $[ue + 3]
                    }), L)) return !0
                }
            }
            const H = this.circleCells[p];
            if (H !== null) {
              const $ = this.circles;
              for (const ce of H)
                if (!A.circle[ce]) {
                  A.circle[ce] = !0;
                  const ue = 3 * ce,
                    de = this.circleKeys[ce];
                  if (this._circleAndRectCollide($[ue], $[ue + 1], $[ue + 2], e, a, o, u) && (!I || I(de)) && (!L || !Ke(O, de.overlapMode))) {
                    const Ce = $[ue],
                      Be = $[ue + 1],
                      Ie = $[ue + 2];
                    if (g.push({
                        key: de,
                        x1: Ce - Ie,
                        y1: Be - Ie,
                        x2: Ce + Ie,
                        y2: Be + Ie
                      }), L) return !0
                  }
                }
            }
            return !1
          }
          _queryCellCircle(e, a, o, u, p, g, w, I) {
            const {
              circle: A,
              seenUids: L,
              overlapMode: O
            } = w, R = this.boxCells[p];
            if (R !== null) {
              const $ = this.bboxes;
              for (const ce of R)
                if (!L.box[ce]) {
                  L.box[ce] = !0;
                  const ue = 4 * ce,
                    de = this.boxKeys[ce];
                  if (this._circleAndRectCollide(A.x, A.y, A.radius, $[ue + 0], $[ue + 1], $[ue + 2], $[ue + 3]) && (!I || I(de)) && !Ke(O, de.overlapMode)) return g.push(!0), !0
                }
            }
            const H = this.circleCells[p];
            if (H !== null) {
              const $ = this.circles;
              for (const ce of H)
                if (!L.circle[ce]) {
                  L.circle[ce] = !0;
                  const ue = 3 * ce,
                    de = this.circleKeys[ce];
                  if (this._circlesCollide($[ue], $[ue + 1], $[ue + 2], A.x, A.y, A.radius) && (!I || I(de)) && !Ke(O, de.overlapMode)) return g.push(!0), !0
                }
            }
          }
          _forEachCell(e, a, o, u, p, g, w, I) {
            const A = this._convertToXCellCoord(e),
              L = this._convertToYCellCoord(a),
              O = this._convertToXCellCoord(o),
              R = this._convertToYCellCoord(u);
            for (let H = A; H <= O; H++)
              for (let $ = L; $ <= R; $++)
                if (p.call(this, e, a, o, u, this.xCellCount * $ + H, g, w, I)) return
          }
          _convertToXCellCoord(e) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)))
          }
          _convertToYCellCoord(e) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)))
          }
          _circlesCollide(e, a, o, u, p, g) {
            const w = u - e,
              I = p - a,
              A = o + g;
            return A * A > w * w + I * I
          }
          _circleAndRectCollide(e, a, o, u, p, g, w) {
            const I = (g - u) / 2,
              A = Math.abs(e - (u + I));
            if (A > I + o) return !1;
            const L = (w - p) / 2,
              O = Math.abs(a - (p + L));
            if (O > L + o) return !1;
            if (A <= I || O <= L) return !0;
            const R = A - I,
              H = O - L;
            return R * R + H * H <= o * o
          }
        }

        function Wt(d, e, a) {
          const o = s.M();
          if (!d) {
            const {
              vecSouth: O,
              vecEast: R
            } = or(e), H = Z();
            H[0] = R[0], H[1] = R[1], H[2] = O[0], H[3] = O[1], u = H, (L = (g = (p = H)[0]) * (A = p[3]) - (I = p[2]) * (w = p[1])) && (u[0] = A * (L = 1 / L), u[1] = -w * L, u[2] = -I * L, u[3] = g * L), o[0] = H[0], o[1] = H[1], o[4] = H[2], o[5] = H[3]
          }
          var u, p, g, w, I, A, L;
          return s.O(o, o, [1 / a, 1 / a, 1]), o
        }

        function Fr(d, e, a, o) {
          if (d) {
            const u = s.M();
            if (!e) {
              const {
                vecSouth: p,
                vecEast: g
              } = or(a);
              u[0] = g[0], u[1] = g[1], u[4] = p[0], u[5] = p[1]
            }
            return s.O(u, u, [o, o, 1]), u
          }
          return a.pixelsToClipSpaceMatrix
        }

        function or(d) {
          const e = Math.cos(d.rollInRadians),
            a = Math.sin(d.rollInRadians),
            o = Math.cos(d.pitchInRadians),
            u = Math.cos(d.bearingInRadians),
            p = Math.sin(d.bearingInRadians),
            g = s.av();
          g[0] = -u * o * a - p * e, g[1] = -p * o * a + u * e;
          const w = s.aw(g);
          w < 1e-9 ? s.ax(g) : s.ay(g, g, 1 / w);
          const I = s.av();
          I[0] = u * o * e - p * a, I[1] = p * o * e + u * a;
          const A = s.aw(I);
          return A < 1e-9 ? s.ax(I) : s.ay(I, I, 1 / A), {
            vecEast: I,
            vecSouth: g
          }
        }

        function tt(d, e, a, o) {
          let u;
          o ? (u = [d, e, o(d, e), 1], s.aA(u, u, a)) : (u = [d, e, 0, 1], ti(u, u, a));
          const p = u[3];
          return {
            point: new s.P(u[0] / p, u[1] / p),
            signedDistanceFromCamera: p,
            isOccluded: !1
          }
        }

        function Ht(d, e) {
          return .5 + d / e * .5
        }

        function Qt(d, e) {
          return d.x >= -e[0] && d.x <= e[0] && d.y >= -e[1] && d.y <= e[1]
        }

        function Sr(d, e, a, o, u, p, g, w, I, A, L, O, R) {
          const H = a ? d.textSizeData : d.iconSizeData,
            $ = s.ar(H, e.transform.zoom),
            ce = [256 / e.width * 2 + 1, 256 / e.height * 2 + 1],
            ue = a ? d.text.dynamicLayoutVertexArray : d.icon.dynamicLayoutVertexArray;
          ue.clear();
          const de = d.lineVertexArray,
            Ce = a ? d.text.placedSymbolArray : d.icon.placedSymbolArray,
            Be = e.transform.width / e.transform.height;
          let Ie = !1;
          for (let Oe = 0; Oe < Ce.length; Oe++) {
            const He = Ce.get(Oe);
            if (He.hidden || He.writingMode === s.as.vertical && !Ie) {
              di(He.numGlyphs, ue);
              continue
            }
            Ie = !1;
            const Le = new s.P(He.anchorX, He.anchorY),
              $e = {
                getElevation: R,
                pitchedLabelPlaneMatrix: o,
                lineVertexArray: de,
                pitchWithMap: p,
                projectionCache: {
                  projections: {},
                  offsets: {},
                  cachedAnchorPoint: void 0,
                  anyProjectionOccluded: !1
                },
                transform: e.transform,
                tileAnchorPoint: Le,
                unwrappedTileID: I,
                width: A,
                height: L,
                translation: O
              },
              vt = Pr(He.anchorX, He.anchorY, $e);
            if (!Qt(vt.point, ce)) {
              di(He.numGlyphs, ue);
              continue
            }
            const ft = Ht(e.transform.cameraToCenterDistance, vt.signedDistanceFromCamera),
              gt = s.at(H, $, He),
              xt = p ? gt * e.transform.getPitchedTextCorrection(He.anchorX, He.anchorY, I) / ft : gt * ft,
              lr = Dr({
                projectionContext: $e,
                pitchedLabelPlaneMatrixInverse: u,
                symbol: He,
                fontSize: xt,
                flip: !1,
                keepUpright: g,
                glyphOffsetArray: d.glyphOffsetArray,
                dynamicLayoutVertexArray: ue,
                aspectRatio: Be,
                rotateToLine: w
              });
            Ie = lr.useVertical, (lr.notEnoughRoom || Ie || lr.needsFlipping && Dr({
              projectionContext: $e,
              pitchedLabelPlaneMatrixInverse: u,
              symbol: He,
              fontSize: xt,
              flip: !0,
              keepUpright: g,
              glyphOffsetArray: d.glyphOffsetArray,
              dynamicLayoutVertexArray: ue,
              aspectRatio: Be,
              rotateToLine: w
            }).notEnoughRoom) && di(He.numGlyphs, ue)
          }
          a ? d.text.dynamicLayoutVertexBuffer.updateData(ue) : d.icon.dynamicLayoutVertexBuffer.updateData(ue)
        }

        function ei(d, e, a, o, u, p, g, w) {
          const I = p.glyphStartIndex + p.numGlyphs,
            A = p.lineStartIndex,
            L = p.lineStartIndex + p.lineLength,
            O = e.getoffsetX(p.glyphStartIndex),
            R = e.getoffsetX(I - 1),
            H = ur(d * O, a, o, u, p.segment, A, L, w, g);
          if (!H) return null;
          const $ = ur(d * R, a, o, u, p.segment, A, L, w, g);
          return $ ? w.projectionCache.anyProjectionOccluded ? null : {
            first: H,
            last: $
          } : null
        }

        function li(d, e, a, o) {
          return d === s.as.horizontal && Math.abs(a.y - e.y) > Math.abs(a.x - e.x) * o ? {
            useVertical: !0
          } : (d === s.as.vertical ? e.y < a.y : e.x > a.x) ? {
            needsFlipping: !0
          } : null
        }

        function Dr(d) {
          const {
            projectionContext: e,
            pitchedLabelPlaneMatrixInverse: a,
            symbol: o,
            fontSize: u,
            flip: p,
            keepUpright: g,
            glyphOffsetArray: w,
            dynamicLayoutVertexArray: I,
            aspectRatio: A,
            rotateToLine: L
          } = d, O = u / 24, R = o.lineOffsetX * O, H = o.lineOffsetY * O;
          let $;
          if (o.numGlyphs > 1) {
            const ce = o.glyphStartIndex + o.numGlyphs,
              ue = o.lineStartIndex,
              de = o.lineStartIndex + o.lineLength,
              Ce = ei(O, w, R, H, p, o, L, e);
            if (!Ce) return {
              notEnoughRoom: !0
            };
            const Be = er(Ce.first.point.x, Ce.first.point.y, e, a),
              Ie = er(Ce.last.point.x, Ce.last.point.y, e, a);
            if (g && !p) {
              const Oe = li(o.writingMode, Be, Ie, A);
              if (Oe) return Oe
            }
            $ = [Ce.first];
            for (let Oe = o.glyphStartIndex + 1; Oe < ce - 1; Oe++) {
              const He = ur(O * w.getoffsetX(Oe), R, H, p, o.segment, ue, de, e, L);
              if (!He) return {
                notEnoughRoom: !0
              };
              $.push(He)
            }
            $.push(Ce.last)
          } else {
            if (g && !p) {
              const ue = It(e.tileAnchorPoint.x, e.tileAnchorPoint.y, e).point,
                de = o.lineStartIndex + o.segment + 1,
                Ce = new s.P(e.lineVertexArray.getx(de), e.lineVertexArray.gety(de)),
                Be = It(Ce.x, Ce.y, e),
                Ie = Be.signedDistanceFromCamera > 0 ? Be.point : Oi(e.tileAnchorPoint, Ce, ue, 1, e),
                Oe = er(ue.x, ue.y, e, a),
                He = er(Ie.x, Ie.y, e, a),
                Le = li(o.writingMode, Oe, He, A);
              if (Le) return Le
            }
            const ce = ur(O * w.getoffsetX(o.glyphStartIndex), R, H, p, o.segment, o.lineStartIndex, o.lineStartIndex + o.lineLength, e, L);
            if (!ce || e.projectionCache.anyProjectionOccluded) return {
              notEnoughRoom: !0
            };
            $ = [ce]
          }
          for (const ce of $) s.az(I, ce.point, ce.angle);
          return {}
        }

        function Oi(d, e, a, o, u) {
          const p = d.add(d.sub(e)._unit()),
            g = It(p.x, p.y, u).point,
            w = a.sub(g);
          return a.add(w._mult(o / w.mag()))
        }

        function Jr(d, e, a) {
          const o = e.projectionCache;
          if (o.projections[d]) return o.projections[d];
          const u = new s.P(e.lineVertexArray.getx(d), e.lineVertexArray.gety(d)),
            p = It(u.x, u.y, e);
          if (p.signedDistanceFromCamera > 0) return o.projections[d] = p.point, o.anyProjectionOccluded = o.anyProjectionOccluded || p.isOccluded, p.point;
          const g = d - a.direction;
          return Oi(a.distanceFromAnchor === 0 ? e.tileAnchorPoint : new s.P(e.lineVertexArray.getx(g), e.lineVertexArray.gety(g)), u, a.previousVertex, a.absOffsetX - a.distanceFromAnchor + 1, e)
        }

        function It(d, e, a) {
          const o = d + a.translation[0],
            u = e + a.translation[1];
          let p;
          return a.pitchWithMap ? (p = tt(o, u, a.pitchedLabelPlaneMatrix, a.getElevation), p.isOccluded = !1) : (p = a.transform.projectTileCoordinates(o, u, a.unwrappedTileID, a.getElevation), p.point.x = (.5 * p.point.x + .5) * a.width, p.point.y = (.5 * -p.point.y + .5) * a.height), p
        }

        function er(d, e, a, o) {
          if (a.pitchWithMap) {
            const u = [d, e, 0, 1];
            return s.aA(u, u, o), a.transform.projectTileCoordinates(u[0] / u[3], u[1] / u[3], a.unwrappedTileID, a.getElevation).point
          }
          return {
            x: d / a.width * 2 - 1,
            y: 1 - e / a.height * 2
          }
        }

        function Pr(d, e, a) {
          return a.transform.projectTileCoordinates(d, e, a.unwrappedTileID, a.getElevation)
        }

        function pr(d, e, a) {
          return d._unit()._perp()._mult(e * a)
        }

        function qr(d, e, a, o, u, p, g, w, I) {
          if (w.projectionCache.offsets[d]) return w.projectionCache.offsets[d];
          const A = a.add(e);
          if (d + I.direction < o || d + I.direction >= u) return w.projectionCache.offsets[d] = A, A;
          const L = Jr(d + I.direction, w, I),
            O = pr(L.sub(a), g, I.direction),
            R = a.add(O),
            H = L.add(O);
          return w.projectionCache.offsets[d] = s.aB(p, A, R, H) || A, w.projectionCache.offsets[d]
        }

        function ur(d, e, a, o, u, p, g, w, I) {
          const A = o ? d - e : d + e;
          let L = A > 0 ? 1 : -1,
            O = 0;
          o && (L *= -1, O = Math.PI), L < 0 && (O += Math.PI);
          let R, H = L > 0 ? p + u : p + u + 1;
          w.projectionCache.cachedAnchorPoint ? R = w.projectionCache.cachedAnchorPoint : (R = It(w.tileAnchorPoint.x, w.tileAnchorPoint.y, w).point, w.projectionCache.cachedAnchorPoint = R);
          let $, ce, ue = R,
            de = R,
            Ce = 0,
            Be = 0;
          const Ie = Math.abs(A),
            Oe = [];
          let He;
          for (; Ce + Be <= Ie;) {
            if (H += L, H < p || H >= g) return null;
            Ce += Be, de = ue, ce = $;
            const vt = {
              absOffsetX: Ie,
              direction: L,
              distanceFromAnchor: Ce,
              previousVertex: de
            };
            if (ue = Jr(H, w, vt), a === 0) Oe.push(de), He = ue.sub(de);
            else {
              let ft;
              const gt = ue.sub(de);
              ft = gt.mag() === 0 ? pr(Jr(H + L, w, vt).sub(ue), a, L) : pr(gt, a, L), ce || (ce = de.add(ft)), $ = qr(H, ft, ue, p, g, ce, a, w, vt), Oe.push(ce), He = $.sub(ce)
            }
            Be = He.mag()
          }
          const Le = He._mult((Ie - Ce) / Be)._add(ce || de),
            $e = O + Math.atan2(ue.y - de.y, ue.x - de.x);
          return Oe.push(Le), {
            point: Le,
            angle: I ? $e : 0,
            path: Oe
          }
        }
        const Mr = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);

        function di(d, e) {
          for (let a = 0; a < d; a++) {
            const o = e.length;
            e.resize(o + 4), e.float32.set(Mr, 3 * o)
          }
        }

        function ti(d, e, a) {
          const o = e[0],
            u = e[1];
          return d[0] = a[0] * o + a[4] * u + a[12], d[1] = a[1] * o + a[5] * u + a[13], d[3] = a[3] * o + a[7] * u + a[15], d
        }
        const Vr = 100;
        class Rr {
          constructor(e, a = new Tt(e.width + 200, e.height + 200, 25), o = new Tt(e.width + 200, e.height + 200, 25)) {
            this.transform = e, this.grid = a, this.ignoredGrid = o, this.pitchFactor = Math.cos(e.pitch * Math.PI / 180) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + Vr, this.screenBottomBoundary = e.height + Vr, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.perspectiveRatioCutoff = .6
          }
          placeCollisionBox(e, a, o, u, p, g, w, I, A, L, O, R) {
            const H = this.projectAndGetPerspectiveRatio(e.anchorPointX + I[0], e.anchorPointY + I[1], p, L, R),
              $ = o * H.perspectiveRatio;
            let ce;
            if (g || w) ce = this._projectCollisionBox(e, $, u, p, g, w, I, H, L, O, R);
            else {
              const He = H.x + (O ? O.x * $ : 0),
                Le = H.y + (O ? O.y * $ : 0);
              ce = {
                allPointsOccluded: !1,
                box: [He + e.x1 * $, Le + e.y1 * $, He + e.x2 * $, Le + e.y2 * $]
              }
            }
            const [ue, de, Ce, Be] = ce.box, Ie = g ? ce.allPointsOccluded : H.isOccluded;
            let Oe = Ie;
            return Oe || (Oe = H.perspectiveRatio < this.perspectiveRatioCutoff), Oe || (Oe = !this.isInsideGrid(ue, de, Ce, Be)), Oe || a !== "always" && this.grid.hitTest(ue, de, Ce, Be, a, A) ? {
              box: [ue, de, Ce, Be],
              placeable: !1,
              offscreen: !1,
              occluded: Ie
            } : {
              box: [ue, de, Ce, Be],
              placeable: !0,
              offscreen: this.isOffscreen(ue, de, Ce, Be),
              occluded: Ie
            }
          }
          placeCollisionCircles(e, a, o, u, p, g, w, I, A, L, O, R, H, $) {
            const ce = [],
              ue = new s.P(a.anchorX, a.anchorY),
              de = this.getPerspectiveRatio(ue.x, ue.y, g, $),
              Ce = (A ? p * this.transform.getPitchedTextCorrection(a.anchorX, a.anchorY, g) / de : p * de) / s.aF,
              Be = {
                getElevation: $,
                pitchedLabelPlaneMatrix: w,
                lineVertexArray: o,
                pitchWithMap: A,
                projectionCache: {
                  projections: {},
                  offsets: {},
                  cachedAnchorPoint: void 0,
                  anyProjectionOccluded: !1
                },
                transform: this.transform,
                tileAnchorPoint: ue,
                unwrappedTileID: g,
                width: this.transform.width,
                height: this.transform.height,
                translation: H
              },
              Ie = ei(Ce, u, a.lineOffsetX * Ce, a.lineOffsetY * Ce, !1, a, !1, Be);
            let Oe = !1,
              He = !1,
              Le = !0;
            if (Ie) {
              const $e = .5 * O * de + R,
                vt = new s.P(-100, -100),
                ft = new s.P(this.screenRightBoundary, this.screenBottomBoundary),
                gt = new qt,
                xt = Ie.first,
                lr = Ie.last;
              let cr = [];
              for (let Pi = xt.path.length - 1; Pi >= 1; Pi--) cr.push(xt.path[Pi]);
              for (let Pi = 1; Pi < lr.path.length; Pi++) cr.push(lr.path[Pi]);
              const Nt = 2.5 * $e;
              if (A) {
                const Pi = this.projectPathToScreenSpace(cr, Be);
                cr = Pi.some((Qi => Qi.signedDistanceFromCamera <= 0)) ? [] : Pi.map((Qi => Qi.point))
              }
              let Nr = [];
              if (cr.length > 0) {
                const Pi = cr[0].clone(),
                  Qi = cr[0].clone();
                for (let Li = 1; Li < cr.length; Li++) Pi.x = Math.min(Pi.x, cr[Li].x), Pi.y = Math.min(Pi.y, cr[Li].y), Qi.x = Math.max(Qi.x, cr[Li].x), Qi.y = Math.max(Qi.y, cr[Li].y);
                Nr = Pi.x >= vt.x && Qi.x <= ft.x && Pi.y >= vt.y && Qi.y <= ft.y ? [cr] : Qi.x < vt.x || Pi.x > ft.x || Qi.y < vt.y || Pi.y > ft.y ? [] : s.aC([cr], vt.x, vt.y, ft.x, ft.y)
              }
              for (const Pi of Nr) {
                gt.reset(Pi, .25 * $e);
                let Qi = 0;
                Qi = gt.length <= .5 * $e ? 1 : Math.ceil(gt.paddedLength / Nt) + 1;
                for (let Li = 0; Li < Qi; Li++) {
                  const ra = Li / Math.max(Qi - 1, 1),
                    va = gt.lerp(ra),
                    na = va.x + Vr,
                    za = va.y + Vr;
                  ce.push(na, za, $e, 0);
                  const ha = na - $e,
                    Ua = za - $e,
                    da = na + $e,
                    Ca = za + $e;
                  if (Le = Le && this.isOffscreen(ha, Ua, da, Ca), He = He || this.isInsideGrid(ha, Ua, da, Ca), e !== "always" && this.grid.hitTestCircle(na, za, $e, e, L) && (Oe = !0, !I)) return {
                    circles: [],
                    offscreen: !1,
                    collisionDetected: Oe
                  }
                }
              }
            }
            return {
              circles: !I && Oe || !He || de < this.perspectiveRatioCutoff ? [] : ce,
              offscreen: Le,
              collisionDetected: Oe
            }
          }
          projectPathToScreenSpace(e, a) {
            const o = (function(u, p) {
              const g = s.M();
              return s.au(g, p.pitchedLabelPlaneMatrix), u.map((w => {
                const I = tt(w.x, w.y, g, p.getElevation),
                  A = p.transform.projectTileCoordinates(I.point.x, I.point.y, p.unwrappedTileID, p.getElevation);
                return A.point.x = (.5 * A.point.x + .5) * p.width, A.point.y = (.5 * -A.point.y + .5) * p.height, A
              }))
            })(e, a);
            return (function(u) {
              let p = 0,
                g = 0,
                w = 0,
                I = 0;
              for (let A = 0; A < u.length; A++) u[A].isOccluded ? (w = A + 1, I = 0) : (I++, I > g && (g = I, p = w));
              return u.slice(p, p + g)
            })(o)
          }
          queryRenderedSymbols(e) {
            if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
            const a = [],
              o = new s.a6;
            for (const O of e) {
              const R = new s.P(O.x + Vr, O.y + Vr);
              o.extend(R), a.push(R)
            }
            const {
              minX: u,
              minY: p,
              maxX: g,
              maxY: w
            } = o, I = this.grid.query(u, p, g, w).concat(this.ignoredGrid.query(u, p, g, w)), A = {}, L = {};
            for (const O of I) {
              const R = O.key;
              if (A[R.bucketInstanceId] === void 0 && (A[R.bucketInstanceId] = {}), A[R.bucketInstanceId][R.featureIndex]) continue;
              const H = [new s.P(O.x1, O.y1), new s.P(O.x2, O.y1), new s.P(O.x2, O.y2), new s.P(O.x1, O.y2)];
              s.aD(a, H) && (A[R.bucketInstanceId][R.featureIndex] = !0, L[R.bucketInstanceId] === void 0 && (L[R.bucketInstanceId] = []), L[R.bucketInstanceId].push(R.featureIndex))
            }
            return L
          }
          insertCollisionBox(e, a, o, u, p, g) {
            (o ? this.ignoredGrid : this.grid).insert({
              bucketInstanceId: u,
              featureIndex: p,
              collisionGroupID: g,
              overlapMode: a
            }, e[0], e[1], e[2], e[3])
          }
          insertCollisionCircles(e, a, o, u, p, g) {
            const w = o ? this.ignoredGrid : this.grid,
              I = {
                bucketInstanceId: u,
                featureIndex: p,
                collisionGroupID: g,
                overlapMode: a
              };
            for (let A = 0; A < e.length; A += 4) w.insertCircle(I, e[A], e[A + 1], e[A + 2])
          }
          projectAndGetPerspectiveRatio(e, a, o, u, p) {
            if (p) {
              let g;
              u ? (g = [e, a, u(e, a), 1], s.aA(g, g, p)) : (g = [e, a, 0, 1], ti(g, g, p));
              const w = g[3];
              return {
                x: (g[0] / w + 1) / 2 * this.transform.width + Vr,
                y: (-g[1] / w + 1) / 2 * this.transform.height + Vr,
                perspectiveRatio: .5 + this.transform.cameraToCenterDistance / w * .5,
                isOccluded: !1,
                signedDistanceFromCamera: w
              }
            } {
              const g = this.transform.projectTileCoordinates(e, a, o, u);
              return {
                x: (g.point.x + 1) / 2 * this.transform.width + Vr,
                y: (1 - g.point.y) / 2 * this.transform.height + Vr,
                perspectiveRatio: .5 + this.transform.cameraToCenterDistance / g.signedDistanceFromCamera * .5,
                isOccluded: g.isOccluded,
                signedDistanceFromCamera: g.signedDistanceFromCamera
              }
            }
          }
          getPerspectiveRatio(e, a, o, u) {
            const p = this.transform.projectTileCoordinates(e, a, o, u);
            return .5 + this.transform.cameraToCenterDistance / p.signedDistanceFromCamera * .5
          }
          isOffscreen(e, a, o, u) {
            return o < Vr || e >= this.screenRightBoundary || u < Vr || a > this.screenBottomBoundary
          }
          isInsideGrid(e, a, o, u) {
            return o >= 0 && e < this.gridRightBoundary && u >= 0 && a < this.gridBottomBoundary
          }
          getViewportMatrix() {
            const e = s.am([]);
            return s.N(e, e, [-100, -100, 0]), e
          }
          _projectCollisionBox(e, a, o, u, p, g, w, I, A, L, O) {
            let R = 1,
              H = 0,
              $ = 0,
              ce = 1;
            const ue = e.anchorPointX + w[0],
              de = e.anchorPointY + w[1];
            if (g && !p) {
              const cr = this.projectAndGetPerspectiveRatio(ue + 1, de, u, A, O),
                Nt = cr.x - I.x,
                Nr = Math.atan((cr.y - I.y) / Nt) + (Nt < 0 ? Math.PI : 0),
                Pi = Math.sin(Nr),
                Qi = Math.cos(Nr);
              R = Qi, H = Pi, $ = -Pi, ce = Qi
            } else if (!g && p) {
              const cr = or(this.transform);
              R = cr.vecEast[0], H = cr.vecEast[1], $ = cr.vecSouth[0], ce = cr.vecSouth[1]
            }
            let Ce = I.x,
              Be = I.y,
              Ie = a;
            p && (Ce = ue, Be = de, Ie = Math.pow(2, -(this.transform.zoom - o.overscaledZ)), Ie *= this.transform.getPitchedTextCorrection(ue, de, u), L || (Ie *= s.ai(.5 + I.signedDistanceFromCamera / this.transform.cameraToCenterDistance * .5, 0, 4))), L && (Ce += R * L.x * Ie + $ * L.y * Ie, Be += H * L.x * Ie + ce * L.y * Ie);
            const Oe = e.x1 * Ie,
              He = e.x2 * Ie,
              Le = (Oe + He) / 2,
              $e = e.y1 * Ie,
              vt = e.y2 * Ie,
              ft = ($e + vt) / 2,
              gt = [{
                offsetX: Oe,
                offsetY: $e
              }, {
                offsetX: Le,
                offsetY: $e
              }, {
                offsetX: He,
                offsetY: $e
              }, {
                offsetX: He,
                offsetY: ft
              }, {
                offsetX: He,
                offsetY: vt
              }, {
                offsetX: Le,
                offsetY: vt
              }, {
                offsetX: Oe,
                offsetY: vt
              }, {
                offsetX: Oe,
                offsetY: ft
              }];
            let xt = [];
            for (const {
                offsetX: cr,
                offsetY: Nt
              }
              of gt) xt.push(new s.P(Ce + R * cr + $ * Nt, Be + H * cr + ce * Nt));
            let lr = !1;
            if (p) {
              const cr = xt.map((Nt => this.projectAndGetPerspectiveRatio(Nt.x, Nt.y, u, A, O)));
              lr = cr.some((Nt => !Nt.isOccluded)), xt = cr.map((Nt => new s.P(Nt.x, Nt.y)))
            } else lr = !0;
            return {
              box: s.aE(xt),
              allPointsOccluded: !lr
            }
          }
        }
        class ni {
          constructor(e, a, o, u) {
            this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? a : -a))) : u && o ? 1 : 0, this.placed = o
          }
          isHidden() {
            return this.opacity === 0 && !this.placed
          }
        }
        class Ri {
          constructor(e, a, o, u, p) {
            this.text = new ni(e ? e.text : null, a, o, p), this.icon = new ni(e ? e.icon : null, a, u, p)
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden()
          }
        }
        class qi {
          constructor(e, a, o) {
            this.text = e, this.icon = a, this.skipFade = o
          }
        }
        class ai {
          constructor(e, a, o, u, p) {
            this.bucketInstanceId = e, this.featureIndex = a, this.sourceLayerIndex = o, this.bucketIndex = u, this.tileID = p
          }
        }
        class Pt {
          constructor(e) {
            this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {}
          }
          get(e) {
            if (this.crossSourceCollisions) return {
              ID: 0,
              predicate: null
            };
            if (!this.collisionGroups[e]) {
              const a = ++this.maxGroupID;
              this.collisionGroups[e] = {
                ID: a,
                predicate: o => o.collisionGroupID === a
              }
            }
            return this.collisionGroups[e]
          }
        }

        function tr(d, e, a, o, u) {
          const {
            horizontalAlign: p,
            verticalAlign: g
          } = s.aL(d);
          return new s.P(-(p - .5) * e + o[0] * u, -(g - .5) * a + o[1] * u)
        }
        class Br {
          constructor(e, a, o, u, p) {
            this.transform = e.clone(), this.terrain = a, this.collisionIndex = new Rr(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = o, this.retainedQueryData = {}, this.collisionGroups = new Pt(u), this.collisionCircleArrays = {}, this.collisionBoxArrays = new Map, this.prevPlacement = p, p && (p.prevPlacement = void 0), this.placedOrientations = {}
          }
          _getTerrainElevationFunc(e) {
            const a = this.terrain;
            return a ? (o, u) => a.getElevation(e, o, u) : null
          }
          getBucketParts(e, a, o, u) {
            const p = o.getBucket(a),
              g = o.latestFeatureIndex;
            if (!p || !g || a.id !== p.layerIds[0]) return;
            const w = o.collisionBoxArray,
              I = p.layers[0].layout,
              A = p.layers[0].paint,
              L = Math.pow(2, this.transform.zoom - o.tileID.overscaledZ),
              O = o.tileSize / s.a3,
              R = o.tileID.toUnwrapped(),
              H = I.get("text-rotation-alignment") === "map",
              $ = s.aG(o, 1, this.transform.zoom),
              ce = s.aH(this.collisionIndex.transform, o, A.get("text-translate"), A.get("text-translate-anchor")),
              ue = s.aH(this.collisionIndex.transform, o, A.get("icon-translate"), A.get("icon-translate-anchor")),
              de = Wt(H, this.transform, $);
            this.retainedQueryData[p.bucketInstanceId] = new ai(p.bucketInstanceId, g, p.sourceLayerIndex, p.index, o.tileID);
            const Ce = {
              bucket: p,
              layout: I,
              translationText: ce,
              translationIcon: ue,
              unwrappedTileID: R,
              pitchedLabelPlaneMatrix: de,
              scale: L,
              textPixelRatio: O,
              holdingForFade: o.holdingForSymbolFade(),
              collisionBoxArray: w,
              partiallyEvaluatedTextSize: s.ar(p.textSizeData, this.transform.zoom),
              collisionGroup: this.collisionGroups.get(p.sourceID)
            };
            if (u)
              for (const Be of p.sortKeyRanges) {
                const {
                  sortKey: Ie,
                  symbolInstanceStart: Oe,
                  symbolInstanceEnd: He
                } = Be;
                e.push({
                  sortKey: Ie,
                  symbolInstanceStart: Oe,
                  symbolInstanceEnd: He,
                  parameters: Ce
                })
              } else e.push({
                symbolInstanceStart: 0,
                symbolInstanceEnd: p.symbolInstances.length,
                parameters: Ce
              })
          }
          attemptAnchorPlacement(e, a, o, u, p, g, w, I, A, L, O, R, H, $, ce, ue, de, Ce, Be, Ie) {
            const Oe = s.aI[e.textAnchor],
              He = [e.textOffset0, e.textOffset1],
              Le = tr(Oe, o, u, He, p),
              $e = this.collisionIndex.placeCollisionBox(a, R, I, A, L, w, g, ue, O.predicate, Be, Le, Ie);
            if ((!Ce || this.collisionIndex.placeCollisionBox(Ce, R, I, A, L, w, g, de, O.predicate, Be, Le, Ie).placeable) && $e.placeable) {
              let vt;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[H.crossTileID] && this.prevPlacement.placements[H.crossTileID] && this.prevPlacement.placements[H.crossTileID].text && (vt = this.prevPlacement.variableOffsets[H.crossTileID].anchor), H.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[H.crossTileID] = {
                textOffset: He,
                width: o,
                height: u,
                anchor: Oe,
                textBoxScale: p,
                prevAnchor: vt
              }, this.markUsedJustification($, Oe, H, ce), $.allowVerticalPlacement && (this.markUsedOrientation($, ce, H), this.placedOrientations[H.crossTileID] = ce), {
                shift: Le,
                placedGlyphBoxes: $e
              }
            }
          }
          placeLayerBucketPart(e, a, o) {
            const {
              bucket: u,
              layout: p,
              translationText: g,
              translationIcon: w,
              unwrappedTileID: I,
              pitchedLabelPlaneMatrix: A,
              textPixelRatio: L,
              holdingForFade: O,
              collisionBoxArray: R,
              partiallyEvaluatedTextSize: H,
              collisionGroup: $
            } = e.parameters, ce = p.get("text-optional"), ue = p.get("icon-optional"), de = s.aJ(p, "text-overlap", "text-allow-overlap"), Ce = de === "always", Be = s.aJ(p, "icon-overlap", "icon-allow-overlap"), Ie = Be === "always", Oe = p.get("text-rotation-alignment") === "map", He = p.get("text-pitch-alignment") === "map", Le = p.get("icon-text-fit") !== "none", $e = p.get("symbol-z-order") === "viewport-y", vt = Ce && (Ie || !u.hasIconData() || ue), ft = Ie && (Ce || !u.hasTextData() || ce);
            !u.collisionArrays && R && u.deserializeCollisionBoxes(R);
            const gt = this.retainedQueryData[u.bucketInstanceId].tileID,
              xt = this._getTerrainElevationFunc(gt),
              lr = this.transform.getFastPathSimpleProjectionMatrix(gt),
              cr = (Nt, Nr, Pi) => {
                var Qi, Li;
                if (a[Nt.crossTileID]) return;
                if (O) return void(this.placements[Nt.crossTileID] = new qi(!1, !1, !1));
                let ra = !1,
                  va = !1,
                  na = !0,
                  za = null,
                  ha = {
                    box: null,
                    placeable: !1,
                    offscreen: null,
                    occluded: !1
                  },
                  Ua = {
                    placeable: !1
                  },
                  da = null,
                  Ca = null,
                  cn = null,
                  $s = 0,
                  ms = 0,
                  as = 0;
                Nr.textFeatureIndex ? $s = Nr.textFeatureIndex : Nt.useRuntimeCollisionCircles && ($s = Nt.featureIndex), Nr.verticalTextFeatureIndex && (ms = Nr.verticalTextFeatureIndex);
                const Qs = Nr.textBox;
                if (Qs) {
                  const un = Aa => {
                      let Ta = s.as.horizontal;
                      if (u.allowVerticalPlacement && !Aa && this.prevPlacement) {
                        const Za = this.prevPlacement.placedOrientations[Nt.crossTileID];
                        Za && (this.placedOrientations[Nt.crossTileID] = Za, Ta = Za, this.markUsedOrientation(u, Ta, Nt))
                      }
                      return Ta
                    },
                    gs = (Aa, Ta) => {
                      if (u.allowVerticalPlacement && Nt.numVerticalGlyphVertices > 0 && Nr.verticalTextBox) {
                        for (const Za of u.writingModes)
                          if (Za === s.as.vertical ? (ha = Ta(), Ua = ha) : ha = Aa(), ha && ha.placeable) break
                      } else ha = Aa()
                    },
                    Cs = Nt.textAnchorOffsetStartIndex,
                    ll = Nt.textAnchorOffsetEndIndex;
                  if (ll === Cs) {
                    const Aa = (Ta, Za) => {
                      const oa = this.collisionIndex.placeCollisionBox(Ta, de, L, gt, I, He, Oe, g, $.predicate, xt, void 0, lr);
                      return oa && oa.placeable && (this.markUsedOrientation(u, Za, Nt), this.placedOrientations[Nt.crossTileID] = Za), oa
                    };
                    gs((() => Aa(Qs, s.as.horizontal)), (() => {
                      const Ta = Nr.verticalTextBox;
                      return u.allowVerticalPlacement && Nt.numVerticalGlyphVertices > 0 && Ta ? Aa(Ta, s.as.vertical) : {
                        box: null,
                        offscreen: null
                      }
                    })), un(ha && ha.placeable)
                  } else {
                    let Aa = s.aI[(Li = (Qi = this.prevPlacement) === null || Qi === void 0 ? void 0 : Qi.variableOffsets[Nt.crossTileID]) === null || Li === void 0 ? void 0 : Li.anchor];
                    const Ta = (oa, Gn, As) => {
                      const Ed = oa.x2 - oa.x1,
                        Ld = oa.y2 - oa.y1,
                        Dd = Nt.textBoxScale,
                        to = Le && Be === "never" ? Gn : null;
                      let ro = null,
                        Cu = de === "never" ? 1 : 2,
                        ic = "never";
                      Aa && Cu++;
                      for (let Au = 0; Au < Cu; Au++) {
                        for (let _s = Cs; _s < ll; _s++) {
                          const ks = u.textAnchorOffsets.get(_s);
                          if (Aa && ks.textAnchor !== Aa) continue;
                          const ac = this.attemptAnchorPlacement(ks, oa, Ed, Ld, Dd, Oe, He, L, gt, I, $, ic, Nt, u, As, g, w, to, xt);
                          if (ac && (ro = ac.placedGlyphBoxes, ro && ro.placeable)) return ra = !0, za = ac.shift, ro
                        }
                        Aa ? Aa = null : ic = de
                      }
                      return o && !ro && (ro = {
                        box: this.collisionIndex.placeCollisionBox(Qs, "always", L, gt, I, He, Oe, g, $.predicate, xt, void 0, lr).box,
                        offscreen: !1,
                        placeable: !1,
                        occluded: !1
                      }), ro
                    };
                    gs((() => Ta(Qs, Nr.iconBox, s.as.horizontal)), (() => {
                      const oa = Nr.verticalTextBox;
                      return u.allowVerticalPlacement && (!ha || !ha.placeable) && Nt.numVerticalGlyphVertices > 0 && oa ? Ta(oa, Nr.verticalIconBox, s.as.vertical) : {
                        box: null,
                        occluded: !0,
                        offscreen: null
                      }
                    })), ha && (ra = ha.placeable, na = ha.offscreen);
                    const Za = un(ha && ha.placeable);
                    if (!ra && this.prevPlacement) {
                      const oa = this.prevPlacement.variableOffsets[Nt.crossTileID];
                      oa && (this.variableOffsets[Nt.crossTileID] = oa, this.markUsedJustification(u, oa.anchor, Nt, Za))
                    }
                  }
                }
                if (da = ha, ra = da && da.placeable, na = da && da.offscreen, Nt.useRuntimeCollisionCircles && Nt.centerJustifiedTextSymbolIndex >= 0) {
                  const un = u.text.placedSymbolArray.get(Nt.centerJustifiedTextSymbolIndex),
                    gs = s.at(u.textSizeData, H, un),
                    Cs = p.get("text-padding");
                  Ca = this.collisionIndex.placeCollisionCircles(de, un, u.lineVertexArray, u.glyphOffsetArray, gs, I, A, o, He, $.predicate, Nt.collisionCircleDiameter, Cs, g, xt), Ca.circles.length && Ca.collisionDetected && !o && s.w("Collisions detected, but collision boxes are not shown"), ra = Ce || Ca.circles.length > 0 && !Ca.collisionDetected, na = na && Ca.offscreen
                }
                if (Nr.iconFeatureIndex && (as = Nr.iconFeatureIndex), Nr.iconBox) {
                  const un = gs => this.collisionIndex.placeCollisionBox(gs, Be, L, gt, I, He, Oe, w, $.predicate, xt, Le && za ? za : void 0, lr);
                  Ua && Ua.placeable && Nr.verticalIconBox ? (cn = un(Nr.verticalIconBox), va = cn.placeable) : (cn = un(Nr.iconBox), va = cn.placeable), na = na && cn.offscreen
                }
                const zo = ce || Nt.numHorizontalGlyphVertices === 0 && Nt.numVerticalGlyphVertices === 0,
                  eo = ue || Nt.numIconVertices === 0;
                zo || eo ? eo ? zo || (va = va && ra) : ra = va && ra : va = ra = va && ra;
                const gn = va && cn.placeable;
                if (ra && da.placeable && this.collisionIndex.insertCollisionBox(da.box, de, p.get("text-ignore-placement"), u.bucketInstanceId, Ua && Ua.placeable && ms ? ms : $s, $.ID), gn && this.collisionIndex.insertCollisionBox(cn.box, Be, p.get("icon-ignore-placement"), u.bucketInstanceId, as, $.ID), Ca && ra && this.collisionIndex.insertCollisionCircles(Ca.circles, de, p.get("text-ignore-placement"), u.bucketInstanceId, $s, $.ID), o && this.storeCollisionData(u.bucketInstanceId, Pi, Nr, da, cn, Ca), Nt.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
                if (u.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
                this.placements[Nt.crossTileID] = new qi((ra || vt) && !(da != null && da.occluded), (va || ft) && !(cn != null && cn.occluded), na || u.justReloaded), a[Nt.crossTileID] = !0
              };
            if ($e) {
              if (e.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
              const Nt = u.getSortedSymbolIndexes(-this.transform.bearingInRadians);
              for (let Nr = Nt.length - 1; Nr >= 0; --Nr) {
                const Pi = Nt[Nr];
                cr(u.symbolInstances.get(Pi), u.collisionArrays[Pi], Pi)
              }
            } else
              for (let Nt = e.symbolInstanceStart; Nt < e.symbolInstanceEnd; Nt++) cr(u.symbolInstances.get(Nt), u.collisionArrays[Nt], Nt);
            u.justReloaded = !1
          }
          storeCollisionData(e, a, o, u, p, g) {
            if (o.textBox || o.iconBox) {
              let w, I;
              this.collisionBoxArrays.has(e) ? w = this.collisionBoxArrays.get(e) : (w = new Map, this.collisionBoxArrays.set(e, w)), w.has(a) ? I = w.get(a) : (I = {
                text: null,
                icon: null
              }, w.set(a, I)), o.textBox && (I.text = u.box), o.iconBox && (I.icon = p.box)
            }
            if (g) {
              let w = this.collisionCircleArrays[e];
              w === void 0 && (w = this.collisionCircleArrays[e] = []);
              for (let I = 0; I < g.circles.length; I += 4) w.push(g.circles[I + 0] - Vr), w.push(g.circles[I + 1] - Vr), w.push(g.circles[I + 2]), w.push(g.collisionDetected ? 1 : 0)
            }
          }
          markUsedJustification(e, a, o, u) {
            let p;
            p = u === s.as.vertical ? o.verticalPlacedTextSymbolIndex : {
              left: o.leftJustifiedTextSymbolIndex,
              center: o.centerJustifiedTextSymbolIndex,
              right: o.rightJustifiedTextSymbolIndex
            } [s.aK(a)];
            const g = [o.leftJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.rightJustifiedTextSymbolIndex, o.verticalPlacedTextSymbolIndex];
            for (const w of g) w >= 0 && (e.text.placedSymbolArray.get(w).crossTileID = p >= 0 && w !== p ? 0 : o.crossTileID)
          }
          markUsedOrientation(e, a, o) {
            const u = a === s.as.horizontal || a === s.as.horizontalOnly ? a : 0,
              p = a === s.as.vertical ? a : 0,
              g = [o.leftJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.rightJustifiedTextSymbolIndex];
            for (const w of g) e.text.placedSymbolArray.get(w).placedOrientation = u;
            o.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(o.verticalPlacedTextSymbolIndex).placedOrientation = p)
          }
          commit(e) {
            this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const a = this.prevPlacement;
            let o = !1;
            this.prevZoomAdjustment = a ? a.zoomAdjustment(this.transform.zoom) : 0;
            const u = a ? a.symbolFadeChange(e) : 1,
              p = a ? a.opacities : {},
              g = a ? a.variableOffsets : {},
              w = a ? a.placedOrientations : {};
            for (const I in this.placements) {
              const A = this.placements[I],
                L = p[I];
              L ? (this.opacities[I] = new Ri(L, u, A.text, A.icon), o = o || A.text !== L.text.placed || A.icon !== L.icon.placed) : (this.opacities[I] = new Ri(null, u, A.text, A.icon, A.skipFade), o = o || A.text || A.icon)
            }
            for (const I in p) {
              const A = p[I];
              if (!this.opacities[I]) {
                const L = new Ri(A, u, !1, !1);
                L.isHidden() || (this.opacities[I] = L, o = o || A.text.placed || A.icon.placed)
              }
            }
            for (const I in g) this.variableOffsets[I] || !this.opacities[I] || this.opacities[I].isHidden() || (this.variableOffsets[I] = g[I]);
            for (const I in w) this.placedOrientations[I] || !this.opacities[I] || this.opacities[I].isHidden() || (this.placedOrientations[I] = w[I]);
            if (a && a.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
            o ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = a ? a.lastPlacementChangeTime : e)
          }
          updateLayerOpacities(e, a) {
            const o = {};
            for (const u of a) {
              const p = u.getBucket(e);
              p && u.latestFeatureIndex && e.id === p.layerIds[0] && this.updateBucketOpacities(p, u.tileID, o, u.collisionBoxArray)
            }
          }
          updateBucketOpacities(e, a, o, u) {
            e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = !1), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = !1), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
            const p = e.layers[0],
              g = p.layout,
              w = new Ri(null, 0, !1, !1, !0),
              I = g.get("text-allow-overlap"),
              A = g.get("icon-allow-overlap"),
              L = p._unevaluatedLayout.hasValue("text-variable-anchor") || p._unevaluatedLayout.hasValue("text-variable-anchor-offset"),
              O = g.get("text-rotation-alignment") === "map",
              R = g.get("text-pitch-alignment") === "map",
              H = g.get("icon-text-fit") !== "none",
              $ = new Ri(null, 0, I && (A || !e.hasIconData() || g.get("icon-optional")), A && (I || !e.hasTextData() || g.get("text-optional")), !0);
            !e.collisionArrays && u && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(u);
            const ce = (de, Ce, Be) => {
                for (let Ie = 0; Ie < Ce / 4; Ie++) de.opacityVertexArray.emplaceBack(Be);
                de.hasVisibleVertices = de.hasVisibleVertices || Be !== Zi
              },
              ue = this.collisionBoxArrays.get(e.bucketInstanceId);
            for (let de = 0; de < e.symbolInstances.length; de++) {
              const Ce = e.symbolInstances.get(de),
                {
                  numHorizontalGlyphVertices: Be,
                  numVerticalGlyphVertices: Ie,
                  crossTileID: Oe
                } = Ce;
              let He = this.opacities[Oe];
              o[Oe] ? He = w : He || (He = $, this.opacities[Oe] = He), o[Oe] = !0;
              const Le = Ce.numIconVertices > 0,
                $e = this.placedOrientations[Ce.crossTileID],
                vt = $e === s.as.vertical,
                ft = $e === s.as.horizontal || $e === s.as.horizontalOnly;
              if (Be > 0 || Ie > 0) {
                const xt = Ji(He.text);
                ce(e.text, Be, vt ? Zi : xt), ce(e.text, Ie, ft ? Zi : xt);
                const lr = He.text.isHidden();
                [Ce.rightJustifiedTextSymbolIndex, Ce.centerJustifiedTextSymbolIndex, Ce.leftJustifiedTextSymbolIndex].forEach((Nr => {
                  Nr >= 0 && (e.text.placedSymbolArray.get(Nr).hidden = lr || vt ? 1 : 0)
                })), Ce.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(Ce.verticalPlacedTextSymbolIndex).hidden = lr || ft ? 1 : 0);
                const cr = this.variableOffsets[Ce.crossTileID];
                cr && this.markUsedJustification(e, cr.anchor, Ce, $e);
                const Nt = this.placedOrientations[Ce.crossTileID];
                Nt && (this.markUsedJustification(e, "left", Ce, Nt), this.markUsedOrientation(e, Nt, Ce))
              }
              if (Le) {
                const xt = Ji(He.icon),
                  lr = !(H && Ce.verticalPlacedIconSymbolIndex && vt);
                Ce.placedIconSymbolIndex >= 0 && (ce(e.icon, Ce.numIconVertices, lr ? xt : Zi), e.icon.placedSymbolArray.get(Ce.placedIconSymbolIndex).hidden = He.icon.isHidden()), Ce.verticalPlacedIconSymbolIndex >= 0 && (ce(e.icon, Ce.numVerticalIconVertices, lr ? Zi : xt), e.icon.placedSymbolArray.get(Ce.verticalPlacedIconSymbolIndex).hidden = He.icon.isHidden())
              }
              const gt = ue && ue.has(de) ? ue.get(de) : {
                text: null,
                icon: null
              };
              if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
                const xt = e.collisionArrays[de];
                if (xt) {
                  let lr = new s.P(0, 0);
                  if (xt.textBox || xt.verticalTextBox) {
                    let cr = !0;
                    if (L) {
                      const Nt = this.variableOffsets[Oe];
                      Nt ? (lr = tr(Nt.anchor, Nt.width, Nt.height, Nt.textOffset, Nt.textBoxScale), O && lr._rotate(R ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : cr = !1
                    }
                    if (xt.textBox || xt.verticalTextBox) {
                      let Nt;
                      xt.textBox && (Nt = vt), xt.verticalTextBox && (Nt = ft), Zr(e.textCollisionBox.collisionVertexArray, He.text.placed, !cr || Nt, gt.text, lr.x, lr.y)
                    }
                  }
                  if (xt.iconBox || xt.verticalIconBox) {
                    const cr = !!(!ft && xt.verticalIconBox);
                    let Nt;
                    xt.iconBox && (Nt = cr), xt.verticalIconBox && (Nt = !cr), Zr(e.iconCollisionBox.collisionVertexArray, He.icon.placed, Nt, gt.icon, H ? lr.x : 0, H ? lr.y : 0)
                  }
                }
              }
            }
            if (e.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`);
            if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`);
            e.bucketInstanceId in this.collisionCircleArrays && (e.collisionCircleArray = this.collisionCircleArrays[e.bucketInstanceId], delete this.collisionCircleArrays[e.bucketInstanceId])
          }
          symbolFadeChange(e) {
            return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment
          }
          zoomAdjustment(e) {
            return Math.max(0, (this.transform.zoom - e) / 1.5)
          }
          hasTransitions(e) {
            return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration
          }
          stillRecent(e, a) {
            const o = this.zoomAtLastRecencyCheck === a ? 1 - this.zoomAdjustment(a) : 1;
            return this.zoomAtLastRecencyCheck = a, this.commitTime + this.fadeDuration * o > e
          }
          setStale() {
            this.stale = !0
          }
        }

        function Zr(d, e, a, o, u, p) {
          o && o.length !== 0 || (o = [0, 0, 0, 0]);
          const g = o[0] - Vr,
            w = o[1] - Vr,
            I = o[2] - Vr,
            A = o[3] - Vr;
          d.emplaceBack(e ? 1 : 0, a ? 1 : 0, u || 0, p || 0, g, w), d.emplaceBack(e ? 1 : 0, a ? 1 : 0, u || 0, p || 0, I, w), d.emplaceBack(e ? 1 : 0, a ? 1 : 0, u || 0, p || 0, I, A), d.emplaceBack(e ? 1 : 0, a ? 1 : 0, u || 0, p || 0, g, A)
        }
        const ci = Math.pow(2, 25),
          ui = Math.pow(2, 24),
          pt = Math.pow(2, 17),
          kt = Math.pow(2, 16),
          dr = Math.pow(2, 9),
          pi = Math.pow(2, 8),
          vi = Math.pow(2, 1);

        function Ji(d) {
          if (d.opacity === 0 && !d.placed) return 0;
          if (d.opacity === 1 && d.placed) return 4294967295;
          const e = d.placed ? 1 : 0,
            a = Math.floor(127 * d.opacity);
          return a * ci + e * ui + a * pt + e * kt + a * dr + e * pi + a * vi + e
        }
        const Zi = 0;
        class Ei {
          constructor(e) {
            this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = []
          }
          continuePlacement(e, a, o, u, p) {
            const g = this._bucketParts;
            for (; this._currentTileIndex < e.length;)
              if (a.getBucketParts(g, u, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, p()) return !0;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, g.sort(((w, I) => w.sortKey - I.sortKey))); this._currentPartIndex < g.length;)
              if (a.placeLayerBucketPart(g[this._currentPartIndex], this._seenCrossTileIDs, o), this._currentPartIndex++, p()) return !0;
            return !1
          }
        }
        class ca {
          constructor(e, a, o, u, p, g, w, I) {
            this.placement = new Br(e, a, g, w, I), this._currentPlacementIndex = o.length - 1, this._forceFullPlacement = u, this._showCollisionBoxes = p, this._done = !1
          }
          isDone() {
            return this._done
          }
          continuePlacement(e, a, o) {
            const u = me(),
              p = () => !this._forceFullPlacement && me() - u > 2;
            for (; this._currentPlacementIndex >= 0;) {
              const g = a[e[this._currentPlacementIndex]],
                w = this.placement.collisionIndex.transform.zoom;
              if (g.type === "symbol" && (!g.minzoom || g.minzoom <= w) && (!g.maxzoom || g.maxzoom > w)) {
                if (this._inProgressLayer || (this._inProgressLayer = new Ei(g)), this._inProgressLayer.continuePlacement(o[g.source], this.placement, this._showCollisionBoxes, g, p)) return;
                delete this._inProgressLayer
              }
              this._currentPlacementIndex--
            }
            this._done = !0
          }
          commit(e) {
            return this.placement.commit(e), this.placement
          }
        }
        const Ir = 512 / s.a3 / 2;
        class wr {
          constructor(e, a, o) {
            this.tileID = e, this.bucketInstanceId = o, this._symbolsByKey = {};
            const u = new Map;
            for (let p = 0; p < a.length; p++) {
              const g = a.get(p),
                w = g.key,
                I = u.get(w);
              I ? I.push(g) : u.set(w, [g])
            }
            for (const [p, g] of u) {
              const w = {
                positions: g.map((I => ({
                  x: Math.floor(I.anchorX * Ir),
                  y: Math.floor(I.anchorY * Ir)
                }))),
                crossTileIDs: g.map((I => I.crossTileID))
              };
              if (w.positions.length > 128) {
                const I = new s.aM(w.positions.length, 16, Uint16Array);
                for (const {
                    x: A,
                    y: L
                  }
                  of w.positions) I.add(A, L);
                I.finish(), delete w.positions, w.index = I
              }
              this._symbolsByKey[p] = w
            }
          }
          getScaledCoordinates(e, a) {
            const {
              x: o,
              y: u,
              z: p
            } = this.tileID.canonical, {
              x: g,
              y: w,
              z: I
            } = a.canonical, A = Ir / Math.pow(2, I - p), L = (w * s.a3 + e.anchorY) * A, O = u * s.a3 * Ir;
            return {
              x: Math.floor((g * s.a3 + e.anchorX) * A - o * s.a3 * Ir),
              y: Math.floor(L - O)
            }
          }
          findMatches(e, a, o) {
            const u = this.tileID.canonical.z < a.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - a.canonical.z);
            for (let p = 0; p < e.length; p++) {
              const g = e.get(p);
              if (g.crossTileID) continue;
              const w = this._symbolsByKey[g.key];
              if (!w) continue;
              const I = this.getScaledCoordinates(g, a);
              if (w.index) {
                const A = w.index.range(I.x - u, I.y - u, I.x + u, I.y + u).sort();
                for (const L of A) {
                  const O = w.crossTileIDs[L];
                  if (!o[O]) {
                    o[O] = !0, g.crossTileID = O;
                    break
                  }
                }
              } else if (w.positions)
                for (let A = 0; A < w.positions.length; A++) {
                  const L = w.positions[A],
                    O = w.crossTileIDs[A];
                  if (Math.abs(L.x - I.x) <= u && Math.abs(L.y - I.y) <= u && !o[O]) {
                    o[O] = !0, g.crossTileID = O;
                    break
                  }
                }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map((({
              crossTileIDs: e
            }) => e))
          }
        }
        class Ai {
          constructor() {
            this.maxCrossTileID = 0
          }
          generate() {
            return ++this.maxCrossTileID
          }
        }
        class gi {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0
          }
          handleWrapJump(e) {
            const a = Math.round((e - this.lng) / 360);
            if (a !== 0)
              for (const o in this.indexes) {
                const u = this.indexes[o],
                  p = {};
                for (const g in u) {
                  const w = u[g];
                  w.tileID = w.tileID.unwrapTo(w.tileID.wrap + a), p[w.tileID.key] = w
                }
                this.indexes[o] = p
              }
            this.lng = e
          }
          addBucket(e, a, o) {
            if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
              if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === a.bucketInstanceId) return !1;
              this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key])
            }
            for (let p = 0; p < a.symbolInstances.length; p++) a.symbolInstances.get(p).crossTileID = 0;
            this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
            const u = this.usedCrossTileIDs[e.overscaledZ];
            for (const p in this.indexes) {
              const g = this.indexes[p];
              if (Number(p) > e.overscaledZ)
                for (const w in g) {
                  const I = g[w];
                  I.tileID.isChildOf(e) && I.findMatches(a.symbolInstances, e, u)
                } else {
                  const w = g[e.scaledTo(Number(p)).key];
                  w && w.findMatches(a.symbolInstances, e, u)
                }
            }
            for (let p = 0; p < a.symbolInstances.length; p++) {
              const g = a.symbolInstances.get(p);
              g.crossTileID || (g.crossTileID = o.generate(), u[g.crossTileID] = !0)
            }
            return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new wr(e, a.symbolInstances, a.bucketInstanceId), !0
          }
          removeBucketCrossTileIDs(e, a) {
            for (const o of a.getCrossTileIDsLists())
              for (const u of o) delete this.usedCrossTileIDs[e][u]
          }
          removeStaleBuckets(e) {
            let a = !1;
            for (const o in this.indexes) {
              const u = this.indexes[o];
              for (const p in u) e[u[p].bucketInstanceId] || (this.removeBucketCrossTileIDs(o, u[p]), delete u[p], a = !0)
            }
            return a
          }
        }
        class Cr {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new Ai, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {}
          }
          addLayer(e, a, o) {
            let u = this.layerIndexes[e.id];
            u === void 0 && (u = this.layerIndexes[e.id] = new gi);
            let p = !1;
            const g = {};
            u.handleWrapJump(o);
            for (const w of a) {
              const I = w.getBucket(e);
              I && e.id === I.layerIds[0] && (I.bucketInstanceId || (I.bucketInstanceId = ++this.maxBucketInstanceId), u.addBucket(w.tileID, I, this.crossTileIDs) && (p = !0), g[I.bucketInstanceId] = !0)
            }
            return u.removeStaleBuckets(g) && (p = !0), p
          }
          pruneUnusedLayers(e) {
            const a = {};
            e.forEach((o => {
              a[o] = !0
            }));
            for (const o in this.layerIndexes) a[o] || delete this.layerIndexes[o]
          }
        }
        var _i = "void main() {fragColor=vec4(1.0);}";
        const Ar = {
          prelude: ri(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`),
          projectionMercator: ri("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"),
          projectionGlobe: ri("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`),
          background: ri(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
          backgroundPattern: ri(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"),
          circle: ri(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`),
          clippingMask: ri(_i, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
          heatmap: ri(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`),
          heatmapTexture: ri(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"),
          collisionBox: ri("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
          collisionCircle: ri("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
          colorRelief: ri(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
          debug: ri("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"),
          depth: ri(_i, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`),
          fill: ri(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`),
          fillOutline: ri(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`),
          fillOutlinePattern: ri(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`),
          fillPattern: ri(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`),
          fillExtrusion: ri(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`),
          fillExtrusionPattern: ri(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`),
          hillshadePrepare: ri(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
          hillshade: ri(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
          line: ri(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
          lineGradient: ri(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
          linePattern: ri(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`),
          lineSDF: ri(`uniform lowp float u_device_pixel_ratio;uniform lowp float u_lineatlas_width;uniform sampler2D u_image;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0/u_device_pixel_ratio)/min(dasharray_from.w,dasharray_to.w);alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`),
          lineGradientSDF: ri(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform sampler2D u_image_dash;uniform float u_mix;uniform lowp float u_lineatlas_width;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);float sdfdist_a=texture(u_image_dash,v_tex_a).a;float sdfdist_b=texture(u_image_dash,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0)/min(dasharray_from.w,dasharray_to.w);float dash_alpha=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*dash_alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;out vec2 v_tex_a;out vec2 v_tex_b;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;float texel_height=1.0/u_image_height;float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`),
          raster: ri(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`),
          symbolIcon: ri(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`),
          symbolSDF: ri(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`),
          symbolTextAndIcon: ri(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`),
          terrain: ri("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"),
          terrainDepth: ri("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"),
          terrainCoords: ri("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"),
          projectionErrorMeasurement: ri("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"),
          atmosphere: ri(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"),
          sky: ri("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}")
        };

        function ri(d, e) {
          const a = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g,
            o = e.match(/in ([\w]+) ([\w]+)/g),
            u = d.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
            p = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
            g = p ? p.concat(u) : u,
            w = {};
          return {
            fragmentSource: d = d.replace(a, ((I, A, L, O, R) => (w[R] = !0, A === "define" ? `
#ifndef HAS_UNIFORM_u_${R}
in ${L} ${O} ${R};
#else
uniform ${L} ${O} u_${R};
#endif
` : `
#ifdef HAS_UNIFORM_u_${R}
    ${L} ${O} ${R} = u_${R};
#endif
`))),
            vertexSource: e = e.replace(a, ((I, A, L, O, R) => {
              const H = O === "float" ? "vec2" : "vec4",
                $ = R.match(/color/) ? "color" : H;
              return w[R] ? A === "define" ? `
#ifndef HAS_UNIFORM_u_${R}
uniform lowp float u_${R}_t;
in ${L} ${H} a_${R};
out ${L} ${O} ${R};
#else
uniform ${L} ${O} u_${R};
#endif
` : $ === "vec4" ? `
#ifndef HAS_UNIFORM_u_${R}
    ${R} = a_${R};
#else
    ${L} ${O} ${R} = u_${R};
#endif
` : `
#ifndef HAS_UNIFORM_u_${R}
    ${R} = unpack_mix_${$}(a_${R}, u_${R}_t);
#else
    ${L} ${O} ${R} = u_${R};
#endif
` : A === "define" ? `
#ifndef HAS_UNIFORM_u_${R}
uniform lowp float u_${R}_t;
in ${L} ${H} a_${R};
#else
uniform ${L} ${O} u_${R};
#endif
` : $ === "vec4" ? `
#ifndef HAS_UNIFORM_u_${R}
    ${L} ${O} ${R} = a_${R};
#else
    ${L} ${O} ${R} = u_${R};
#endif
` : `
#ifndef HAS_UNIFORM_u_${R}
    ${L} ${O} ${R} = unpack_mix_${$}(a_${R}, u_${R}_t);
#else
    ${L} ${O} ${R} = u_${R};
#endif
`
            })),
            staticAttributes: o,
            staticUniforms: g
          }
        }
        class Xi {
          constructor(e, a, o) {
            this.vertexBuffer = e, this.indexBuffer = a, this.segments = o
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null
          }
        }
        var Vi = s.aN([{
          name: "a_pos",
          type: "Int16",
          components: 2
        }]);
        const Di = "#define PROJECTION_MERCATOR",
          ki = "mercator";
        class zi {
          constructor() {
            this._cachedMesh = null
          }
          get name() {
            return "mercator"
          }
          get useSubdivision() {
            return !1
          }
          get shaderVariantName() {
            return ki
          }
          get shaderDefine() {
            return Di
          }
          get shaderPreludeCode() {
            return Ar.projectionMercator
          }
          get vertexShaderPreludeCode() {
            return Ar.projectionMercator.vertexSource
          }
          get subdivisionGranularity() {
            return s.aO.noSubdivision
          }
          get useGlobeControls() {
            return !1
          }
          get transitionState() {
            return 0
          }
          get latitudeErrorCorrectionRadians() {
            return 0
          }
          destroy() {}
          updateGPUdependent(e) {}
          getMeshFromTileID(e, a, o, u, p) {
            if (this._cachedMesh) return this._cachedMesh;
            const g = new s.aP;
            g.emplaceBack(0, 0), g.emplaceBack(s.a3, 0), g.emplaceBack(0, s.a3), g.emplaceBack(s.a3, s.a3);
            const w = e.createVertexBuffer(g, Vi.members),
              I = s.aQ.simpleSegment(0, 0, 4, 2),
              A = new s.aR;
            A.emplaceBack(1, 0, 2), A.emplaceBack(1, 2, 3);
            const L = e.createIndexBuffer(A);
            return this._cachedMesh = new Xi(w, L, I), this._cachedMesh
          }
          recalculate() {}
          hasTransition() {
            return !1
          }
          setErrorQueryLatitudeDegrees(e) {}
        }
        class yi {
          constructor(e = 0, a = 0, o = 0, u = 0) {
            if (isNaN(e) || e < 0 || isNaN(a) || a < 0 || isNaN(o) || o < 0 || isNaN(u) || u < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = e, this.bottom = a, this.left = o, this.right = u
          }
          interpolate(e, a, o) {
            return a.top != null && e.top != null && (this.top = s.F.number(e.top, a.top, o)), a.bottom != null && e.bottom != null && (this.bottom = s.F.number(e.bottom, a.bottom, o)), a.left != null && e.left != null && (this.left = s.F.number(e.left, a.left, o)), a.right != null && e.right != null && (this.right = s.F.number(e.right, a.right, o)), this
          }
          getCenter(e, a) {
            const o = s.ai((this.left + e - this.right) / 2, 0, e),
              u = s.ai((this.top + a - this.bottom) / 2, 0, a);
            return new s.P(o, u)
          }
          equals(e) {
            return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right
          }
          clone() {
            return new yi(this.top, this.bottom, this.left, this.right)
          }
          toJSON() {
            return {
              top: this.top,
              bottom: this.bottom,
              left: this.left,
              right: this.right
            }
          }
        }

        function fi(d, e) {
          if (!d.renderWorldCopies || d.lngRange) return;
          const a = e.lng - d.center.lng;
          e.lng += a > 180 ? -360 : a < -180 ? 360 : 0
        }

        function tn(d) {
          return Math.max(0, Math.floor(d))
        }
        class Yi {
          constructor(e, a) {
            var o;
            this._callbacks = e, this._tileSize = 512, this._renderWorldCopies = (a == null ? void 0 : a.renderWorldCopies) === void 0 || !!(a != null && a.renderWorldCopies), this._minZoom = (a == null ? void 0 : a.minZoom) || 0, this._maxZoom = (a == null ? void 0 : a.maxZoom) || 22, this._minPitch = (a == null ? void 0 : a.minPitch) == null ? 0 : a == null ? void 0 : a.minPitch, this._maxPitch = (a == null ? void 0 : a.maxPitch) == null ? 60 : a == null ? void 0 : a.maxPitch, this._constrain = (o = a == null ? void 0 : a.constrain) !== null && o !== void 0 ? o : this._callbacks.constrain, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new s.U(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = tn(this._zoom), this._scale = s.al(this._zoom), this._bearingInRadians = 0, this._fovInRadians = .6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new yi, this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0
          }
          apply(e, a, o) {
            this._latRange = e.latRange, this._lngRange = e.lngRange, this._width = e.width, this._height = e.height, this._center = e.center, this._elevation = e.elevation, this._minElevationForCurrentTile = e.minElevationForCurrentTile, this._zoom = e.zoom, this._tileZoom = tn(this._zoom), this._scale = s.al(this._zoom), this._bearingInRadians = e.bearingInRadians, this._fovInRadians = e.fovInRadians, this._pitchInRadians = e.pitchInRadians, this._rollInRadians = e.rollInRadians, this._unmodified = e.unmodified, this._edgeInsets = new yi(e.padding.top, e.padding.bottom, e.padding.left, e.padding.right), this._minZoom = e.minZoom, this._maxZoom = e.maxZoom, this._minPitch = e.minPitch, this._maxPitch = e.maxPitch, this._renderWorldCopies = e.renderWorldCopies, this._cameraToCenterDistance = e.cameraToCenterDistance, this._nearZ = e.nearZ, this._farZ = e.farZ, this._autoCalculateNearFarZ = !o && e.autoCalculateNearFarZ, a && this.constrainInternal(), this._calcMatrices()
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile
          }
          setMinElevationForCurrentTile(e) {
            this._minElevationForCurrentTile = e
          }
          get tileSize() {
            return this._tileSize
          }
          get tileZoom() {
            return this._tileZoom
          }
          get scale() {
            return this._scale
          }
          get width() {
            return this._width
          }
          get height() {
            return this._height
          }
          get bearingInRadians() {
            return this._bearingInRadians
          }
          get lngRange() {
            return this._lngRange
          }
          get latRange() {
            return this._latRange
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits
          }
          get minZoom() {
            return this._minZoom
          }
          setMinZoom(e) {
            this._minZoom !== e && (this._minZoom = e, this.setZoom(this.constrain(this._center, this.zoom).zoom))
          }
          get maxZoom() {
            return this._maxZoom
          }
          setMaxZoom(e) {
            this._maxZoom !== e && (this._maxZoom = e, this.setZoom(this.constrain(this._center, this.zoom).zoom))
          }
          get minPitch() {
            return this._minPitch
          }
          setMinPitch(e) {
            this._minPitch !== e && (this._minPitch = e, this.setPitch(Math.max(this.pitch, e)))
          }
          get maxPitch() {
            return this._maxPitch
          }
          setMaxPitch(e) {
            this._maxPitch !== e && (this._maxPitch = e, this.setPitch(Math.min(this.pitch, e)))
          }
          get renderWorldCopies() {
            return this._renderWorldCopies
          }
          setRenderWorldCopies(e) {
            e === void 0 ? e = !0 : e === null && (e = !1), this._renderWorldCopies = e
          }
          get constrain() {
            return this._constrain
          }
          setConstrain(e) {
            e || (e = this._callbacks.constrain), this._constrain = e, this.constrainInternal(), this._calcMatrices()
          }
          get worldSize() {
            return this._tileSize * this._scale
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2))
          }
          get size() {
            return new s.P(this._width, this._height)
          }
          get bearing() {
            return this._bearingInRadians / Math.PI * 180
          }
          setBearing(e) {
            const a = s.V(e, -180, 180) * Math.PI / 180;
            var o, u, p, g, w, I, A, L, O;
            this._bearingInRadians !== a && (this._unmodified = !1, this._bearingInRadians = a, this._calcMatrices(), this._rotationMatrix = Z(), o = this._rotationMatrix, p = -this._bearingInRadians, g = (u = this._rotationMatrix)[0], w = u[1], I = u[2], A = u[3], L = Math.sin(p), O = Math.cos(p), o[0] = g * O + I * L, o[1] = w * O + A * L, o[2] = g * -L + I * O, o[3] = w * -L + A * O)
          }
          get rotationMatrix() {
            return this._rotationMatrix
          }
          get pitchInRadians() {
            return this._pitchInRadians
          }
          get pitch() {
            return this._pitchInRadians / Math.PI * 180
          }
          setPitch(e) {
            const a = s.ai(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitchInRadians !== a && (this._unmodified = !1, this._pitchInRadians = a, this._calcMatrices())
          }
          get rollInRadians() {
            return this._rollInRadians
          }
          get roll() {
            return this._rollInRadians / Math.PI * 180
          }
          setRoll(e) {
            const a = e / 180 * Math.PI;
            this._rollInRadians !== a && (this._unmodified = !1, this._rollInRadians = a, this._calcMatrices())
          }
          get fovInRadians() {
            return this._fovInRadians
          }
          get fov() {
            return s.aS(this._fovInRadians)
          }
          setFov(e) {
            e = s.ai(e, .1, 150), this.fov !== e && (this._unmodified = !1, this._fovInRadians = s.ak(e), this._calcMatrices())
          }
          get zoom() {
            return this._zoom
          }
          setZoom(e) {
            const a = this.constrain(this._center, e).zoom;
            this._zoom !== a && (this._unmodified = !1, this._zoom = a, this._tileZoom = Math.max(0, Math.floor(a)), this._scale = s.al(a), this.constrainInternal(), this._calcMatrices())
          }
          get center() {
            return this._center
          }
          setCenter(e) {
            e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this.constrainInternal(), this._calcMatrices())
          }
          get elevation() {
            return this._elevation
          }
          setElevation(e) {
            e !== this._elevation && (this._elevation = e, this.constrainInternal(), this._calcMatrices())
          }
          get padding() {
            return this._edgeInsets.toJSON()
          }
          setPadding(e) {
            this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices())
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height)
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter
          }
          get unmodified() {
            return this._unmodified
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance
          }
          get nearZ() {
            return this._nearZ
          }
          get farZ() {
            return this._farZ
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ
          }
          overrideNearFarZ(e, a) {
            this._autoCalculateNearFarZ = !1, this._nearZ = e, this._farZ = a, this._calcMatrices()
          }
          clearNearFarZOverride() {
            this._autoCalculateNearFarZ = !0, this._calcMatrices()
          }
          isPaddingEqual(e) {
            return this._edgeInsets.equals(e)
          }
          interpolatePadding(e, a, o) {
            this._unmodified = !1, this._edgeInsets.interpolate(e, a, o), this.constrainInternal(), this._calcMatrices()
          }
          resize(e, a, o = !0) {
            this._width = e, this._height = a, o && this.constrainInternal(), this._calcMatrices()
          }
          getMaxBounds() {
            return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new Ut([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null
          }
          setMaxBounds(e) {
            e ? (this._lngRange = [e.getWest(), e.getEast()], this._latRange = [e.getSouth(), e.getNorth()], this.constrainInternal()) : (this._lngRange = null, this._latRange = [-s.aj, s.aj])
          }
          getCameraQueryGeometry(e, a) {
            if (a.length === 1) return [a[0], e];
            {
              const {
                minX: o,
                minY: u,
                maxX: p,
                maxY: g
              } = s.a6.fromPoints(a).extend(e);
              return [new s.P(o, u), new s.P(p, u), new s.P(p, g), new s.P(o, g), new s.P(o, u)]
            }
          }
          constrainInternal() {
            if (!this.center || !this._width || !this._height || this._constraining) return;
            this._constraining = !0;
            const e = this._unmodified,
              {
                center: a,
                zoom: o
              } = this.constrain(this.center, this.zoom);
            this.setCenter(a), this.setZoom(o), this._unmodified = e, this._constraining = !1
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let e = s.am(new Float64Array(16));
              s.O(e, e, [this._width / 2, -this._height / 2, 1]), s.N(e, e, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e, e = s.am(new Float64Array(16)), s.O(e, e, [1, -1, 1]), s.N(e, e, [-1, -1, 0]), s.O(e, e, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e, this._cameraToCenterDistance = .5 / Math.tan(this.fovInRadians / 2) * this._height
            }
            this._callbacks.calcMatrices()
          }
          calculateCenterFromCameraLngLatAlt(e, a, o, u) {
            const p = o !== void 0 ? o : this.bearing,
              g = u = u !== void 0 ? u : this.pitch,
              w = s.a5.fromLngLat(e, a),
              I = -Math.cos(s.ak(g)),
              A = Math.sin(s.ak(g)),
              L = A * Math.sin(s.ak(p)),
              O = -A * Math.cos(s.ak(p));
            let R = this.elevation;
            const H = a - R;
            let $;
            I * H >= 0 || Math.abs(I) < .1 ? ($ = 1e4, R = a + $ * I) : $ = -H / I;
            let ce, ue, de = s.aT(1, w.y),
              Ce = 0;
            do {
              if (Ce += 1, Ce > 10) break;
              ue = $ / de, ce = new s.a5(w.x + L * ue, w.y + O * ue), de = 1 / ce.meterInMercatorCoordinateUnits()
            } while (Math.abs($ - ue * de) > 1e-12);
            return {
              center: ce.toLngLat(),
              elevation: R,
              zoom: s.ao(this.height / 2 / Math.tan(this.fovInRadians / 2) / ue / this.tileSize)
            }
          }
          recalculateZoomAndCenter(e) {
            if (this.elevation - e == 0) return;
            const a = s.an(1, this.center.lat) * this.worldSize,
              o = this.cameraToCenterDistance / a,
              u = s.a5.fromLngLat(this.center, this.elevation),
              p = Y(this.center, this.elevation, this.pitch, this.bearing, o);
            this._elevation = e;
            const g = this.calculateCenterFromCameraLngLatAlt(p.toLngLat(), s.aT(p.z, u.y), this.bearing, this.pitch);
            this._elevation = g.elevation, this._center = g.center, this.setZoom(g.zoom)
          }
          getCameraPoint() {
            const e = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new s.P(e * Math.sin(this.rollInRadians), e * Math.cos(this.rollInRadians)))
          }
          getCameraAltitude() {
            return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation
          }
          getCameraLngLat() {
            const e = s.an(1, this.center.lat) * this.worldSize;
            return Y(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e).toLngLat()
          }
          getMercatorTileCoordinates(e) {
            if (!e) return [0, 0, 1, 1];
            const a = e.canonical.z >= 0 ? 1 << e.canonical.z : Math.pow(2, e.canonical.z);
            return [e.canonical.x / a, e.canonical.y / a, 1 / a / s.a3, 1 / a / s.a3]
          }
        }
        class sa {
          constructor(e, a) {
            this.min = e, this.max = a, this.center = s.aU([], s.aV([], this.min, this.max), .5)
          }
          quadrant(e) {
            const a = [e % 2 == 0, e < 2],
              o = s.aW(this.min),
              u = s.aW(this.max);
            for (let p = 0; p < a.length; p++) o[p] = a[p] ? this.min[p] : this.center[p], u[p] = a[p] ? this.center[p] : this.max[p];
            return u[2] = this.max[2], new sa(o, u)
          }
          distanceX(e) {
            return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0]
          }
          distanceY(e) {
            return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1]
          }
          intersectsFrustum(e) {
            let a = !0;
            for (let o = 0; o < e.planes.length; o++) {
              const u = this.intersectsPlane(e.planes[o]);
              if (u === 0) return 0;
              u === 1 && (a = !1)
            }
            return a ? 2 : e.aabb.min[0] > this.max[0] || e.aabb.min[1] > this.max[1] || e.aabb.min[2] > this.max[2] || e.aabb.max[0] < this.min[0] || e.aabb.max[1] < this.min[1] || e.aabb.max[2] < this.min[2] ? 0 : 1
          }
          intersectsPlane(e) {
            let a = e[3],
              o = e[3];
            for (let u = 0; u < 3; u++) e[u] > 0 ? (a += e[u] * this.min[u], o += e[u] * this.max[u]) : (o += e[u] * this.min[u], a += e[u] * this.max[u]);
            return a >= 0 ? 2 : o < 0 ? 0 : 1
          }
        }
        class ua {
          distanceToTile2d(e, a, o, u) {
            const p = u.distanceX([e, a]),
              g = u.distanceY([e, a]);
            return Math.hypot(p, g)
          }
          getWrap(e, a, o) {
            return o
          }
          getTileBoundingVolume(e, a, o, u) {
            var p, g;
            let w = 0,
              I = 0;
            if (u != null && u.terrain) {
              const L = new s.a0(e.z, a, e.z, e.x, e.y),
                O = u.terrain.getMinMaxElevation(L);
              w = (p = O.minElevation) !== null && p !== void 0 ? p : Math.min(0, o), I = (g = O.maxElevation) !== null && g !== void 0 ? g : Math.max(0, o)
            }
            const A = 1 << e.z;
            return new sa([a + e.x / A, e.y / A, w], [a + (e.x + 1) / A, (e.y + 1) / A, I])
          }
          allowVariableZoom(e, a) {
            const o = e.fov * (Math.abs(Math.cos(e.rollInRadians)) * e.height + Math.abs(Math.sin(e.rollInRadians)) * e.width) / e.height,
              u = s.ai(78.5 - o / 2, 0, 60);
            return !!a.terrain || e.pitch > u
          }
          allowWorldCopies() {
            return !0
          }
          prepareNextFrame() {}
        }
        class Da {
          constructor(e, a, o) {
            this.points = e, this.planes = a, this.aabb = o
          }
          static fromInvProjectionMatrix(e, a = 1, o = 0, u, p) {
            const g = p ? [
                [6, 5, 4],
                [0, 1, 2],
                [0, 3, 7],
                [2, 1, 5],
                [3, 2, 6],
                [0, 4, 5]
              ] : [
                [0, 1, 2],
                [6, 5, 4],
                [0, 3, 7],
                [2, 1, 5],
                [3, 2, 6],
                [0, 4, 5]
              ],
              w = Math.pow(2, o),
              I = [
                [-1, 1, -1, 1],
                [1, 1, -1, 1],
                [1, -1, -1, 1],
                [-1, -1, -1, 1],
                [-1, 1, 1, 1],
                [1, 1, 1, 1],
                [1, -1, 1, 1],
                [-1, -1, 1, 1]
              ].map((R => (function(H, $, ce, ue) {
                const de = s.aA([], H, $),
                  Ce = 1 / de[3] / ce * ue;
                return s.a$(de, de, [Ce, Ce, 1 / de[3], Ce])
              })(R, e, a, w)));
            u && (function(R, H, $, ce) {
              const ue = ce ? 4 : 0,
                de = ce ? 0 : 4;
              let Ce = 0;
              const Be = [],
                Ie = [];
              for (let Le = 0; Le < 4; Le++) {
                const $e = s.aX([], R[Le + de], R[Le + ue]),
                  vt = s.b0($e);
                s.aU($e, $e, 1 / vt), Be.push(vt), Ie.push($e)
              }
              for (let Le = 0; Le < 4; Le++) {
                const $e = s.b1(R[Le + ue], Ie[Le], $);
                Ce = $e !== null && $e >= 0 ? Math.max(Ce, $e) : Math.max(Ce, Be[Le])
              }
              const Oe = (function(Le, $e) {
                  const vt = s.aX([], Le[$e[0]], Le[$e[1]]),
                    ft = s.aX([], Le[$e[2]], Le[$e[1]]),
                    gt = [0, 0, 0, 0];
                  return s.aY(gt, s.aZ([], vt, ft)), gt[3] = -s.a_(gt, Le[$e[0]]), gt
                })(R, H),
                He = (function(Le, $e) {
                  const vt = s.b2(Le),
                    ft = s.b3([], Le, 1 / vt),
                    gt = s.aX([], $e, s.aU([], ft, s.a_($e, ft))),
                    xt = s.b2(gt);
                  if (xt > 0) {
                    const lr = Math.sqrt(1 - ft[3] * ft[3]),
                      cr = s.aU([], ft, -ft[3]),
                      Nt = s.aV([], cr, s.aU([], gt, lr / xt));
                    return s.b4($e, Nt)
                  }
                  return null
                })($, Oe);
              if (He !== null) {
                const Le = He / s.a_(Ie[0], Oe);
                Ce = Math.min(Ce, Le)
              }
              for (let Le = 0; Le < 4; Le++) {
                const $e = Math.min(Ce, Be[Le]);
                R[Le + de] = [R[Le + ue][0] + Ie[Le][0] * $e, R[Le + ue][1] + Ie[Le][1] * $e, R[Le + ue][2] + Ie[Le][2] * $e, 1]
              }
            })(I, g[0], u, p);
            const A = g.map((R => {
                const H = s.aX([], I[R[0]], I[R[1]]),
                  $ = s.aX([], I[R[2]], I[R[1]]),
                  ce = s.aY([], s.aZ([], H, $)),
                  ue = -s.a_(ce, I[R[1]]);
                return ce.concat(ue)
              })),
              L = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],
              O = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
            for (const R of I)
              for (let H = 0; H < 3; H++) L[H] = Math.min(L[H], R[H]), O[H] = Math.max(O[H], R[H]);
            return new Da(I, A, new sa(L, O))
          }
        }
        class Pa {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, a, o) {
            return this._helper.interpolatePadding(e, a, o)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, a, o = !0) {
            this._helper.resize(e, a, o)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          setConstrain(e) {
            this._helper.setConstrain(e)
          }
          overrideNearFarZ(e, a) {
            this._helper.overrideNearFarZ(e, a)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          get constrain() {
            return this._helper.constrain
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          setTransitionState(e, a) {}
          constructor(e) {
            this._posMatrixCache = new Map, this._alignedPosMatrixCache = new Map, this._fogMatrixCacheF32 = new Map, this.defaultConstrain = (a, o) => {
              o = s.ai(+o, this.minZoom, this.maxZoom);
              const u = {
                center: new s.U(a.lng, a.lat),
                zoom: o
              };
              let p = this._helper._lngRange;
              if (!this._helper._renderWorldCopies && p === null) {
                const Ie = 179.9999999999;
                p = [-Ie, Ie]
              }
              const g = this.tileSize * s.al(u.zoom);
              let w = 0,
                I = g,
                A = 0,
                L = g,
                O = 0,
                R = 0;
              const {
                x: H,
                y: $
              } = this.size;
              if (this._helper._latRange) {
                const Ie = this._helper._latRange;
                w = s.W(Ie[1]) * g, I = s.W(Ie[0]) * g, I - w < $ && (O = $ / (I - w))
              }
              p && (A = s.V(s.X(p[0]) * g, 0, g), L = s.V(s.X(p[1]) * g, 0, g), L < A && (L += g), L - A < H && (R = H / (L - A)));
              const {
                x: ce,
                y: ue
              } = oe(g, a);
              let de, Ce;
              const Be = Math.max(R || 0, O || 0);
              if (Be) {
                const Ie = new s.P(R ? (L + A) / 2 : ce, O ? (I + w) / 2 : ue);
                return u.center = fe(g, Ie).wrap(), u.zoom += s.ao(Be), u
              }
              if (this._helper._latRange) {
                const Ie = $ / 2;
                ue - Ie < w && (Ce = w + Ie), ue + Ie > I && (Ce = I - Ie)
              }
              if (p) {
                const Ie = (A + L) / 2;
                let Oe = ce;
                this._helper._renderWorldCopies && (Oe = s.V(ce, Ie - g / 2, Ie + g / 2));
                const He = H / 2;
                Oe - He < A && (de = A + He), Oe + He > L && (de = L - He)
              }
              if (de !== void 0 || Ce !== void 0) {
                const Ie = new s.P(de ?? ce, Ce ?? ue);
                u.center = fe(g, Ie).wrap()
              }
              return u
            }, this._helper = new Yi({
              calcMatrices: () => {
                this._calcMatrices()
              },
              constrain: (a, o) => this.defaultConstrain(a, o)
            }, e), this._coveringTilesDetailsProvider = new ua
          }
          clone() {
            const e = new Pa;
            return e.apply(this), e
          }
          apply(e, a, o) {
            this._helper.apply(e, a, o)
          }
          get cameraPosition() {
            return this._cameraPosition
          }
          get projectionMatrix() {
            return this._projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix
          }
          get mercatorMatrix() {
            return this._mercatorMatrix
          }
          getVisibleUnwrappedCoordinates(e) {
            const a = [new s.b5(0, e)];
            if (this._helper._renderWorldCopies) {
              const o = this.screenPointToMercatorCoordinate(new s.P(0, 0)),
                u = this.screenPointToMercatorCoordinate(new s.P(this._helper._width, 0)),
                p = this.screenPointToMercatorCoordinate(new s.P(this._helper._width, this._helper._height)),
                g = this.screenPointToMercatorCoordinate(new s.P(0, this._helper._height)),
                w = Math.floor(Math.min(o.x, u.x, p.x, g.x)),
                I = Math.floor(Math.max(o.x, u.x, p.x, g.x)),
                A = 1;
              for (let L = w - A; L <= I + A; L++) L !== 0 && a.push(new s.b5(L, e))
            }
            return a
          }
          getCameraFrustum() {
            return Da.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize)
          }
          getClippingPlane() {
            return null
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider
          }
          recalculateZoomAndCenter(e) {
            const a = this.screenPointToLocation(this.centerPoint, e),
              o = e ? e.getElevationForLngLatZoom(a, this._helper._tileZoom) : 0;
            this._helper.recalculateZoomAndCenter(o)
          }
          setLocationAtPoint(e, a) {
            const o = s.an(this.elevation, this.center.lat),
              u = this.screenPointToMercatorCoordinateAtZ(a, o),
              p = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, o),
              g = s.a5.fromLngLat(e),
              w = new s.a5(g.x - (u.x - p.x), g.y - (u.y - p.y));
            this.setCenter(w == null ? void 0 : w.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap())
          }
          locationToScreenPoint(e, a) {
            return a ? this.coordinatePoint(s.a5.fromLngLat(e), a.getElevationForLngLatZoom(e, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(s.a5.fromLngLat(e))
          }
          screenPointToLocation(e, a) {
            var o;
            return (o = this.screenPointToMercatorCoordinate(e, a)) === null || o === void 0 ? void 0 : o.toLngLat()
          }
          screenPointToMercatorCoordinate(e, a) {
            if (a) {
              const o = a.pointCoordinate(e);
              if (o != null) return o
            }
            return this.screenPointToMercatorCoordinateAtZ(e)
          }
          screenPointToMercatorCoordinateAtZ(e, a) {
            const o = a || 0,
              u = [e.x, e.y, 0, 1],
              p = [e.x, e.y, 1, 1];
            s.aA(u, u, this._pixelMatrixInverse), s.aA(p, p, this._pixelMatrixInverse);
            const g = u[3],
              w = p[3],
              I = u[1] / g,
              A = p[1] / w,
              L = u[2] / g,
              O = p[2] / w,
              R = L === O ? 0 : (o - L) / (O - L);
            return new s.a5(s.F.number(u[0] / g, p[0] / w, R) / this.worldSize, s.F.number(I, A, R) / this.worldSize, o)
          }
          coordinatePoint(e, a = 0, o = this._pixelMatrix) {
            const u = [e.x * this.worldSize, e.y * this.worldSize, a, 1];
            return s.aA(u, u, o), new s.P(u[0] / u[3], u[1] / u[3])
          }
          getBounds() {
            const e = Math.max(0, this._helper._height / 2 - ve(this));
            return new Ut().extend(this.screenPointToLocation(new s.P(0, e))).extend(this.screenPointToLocation(new s.P(this._helper._width, e))).extend(this.screenPointToLocation(new s.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new s.P(0, this._helper._height)))
          }
          isPointOnMapSurface(e, a) {
            return a ? a.pointCoordinate(e) != null : e.y > this.height / 2 - ve(this)
          }
          calculatePosMatrix(e, a = !1, o) {
            var u;
            const p = (u = e.key) !== null && u !== void 0 ? u : s.b6(e.wrap, e.canonical.z, e.canonical.z, e.canonical.x, e.canonical.y),
              g = a ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (g.has(p)) {
              const A = g.get(p);
              return o ? A.f32 : A.f64
            }
            const w = ie(e, this.worldSize);
            s.Q(w, a ? this._alignedProjMatrix : this._viewProjMatrix, w);
            const I = {
              f64: w,
              f32: new Float32Array(w)
            };
            return g.set(p, I), o ? I.f32 : I.f64
          }
          calculateFogMatrix(e) {
            const a = e.key,
              o = this._fogMatrixCacheF32;
            if (o.has(a)) return o.get(a);
            const u = ie(e, this.worldSize);
            return s.Q(u, this._fogMatrix, u), o.set(a, new Float32Array(u)), o.get(a)
          }
          calculateCenterFromCameraLngLatAlt(e, a, o, u) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, a, o, u)
          }
          _calculateNearFarZIfNeeded(e, a, o) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const u = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100),
              p = e - u * this._helper._pixelPerMeter / Math.cos(a),
              g = u < 0 ? p : e,
              w = Math.PI / 2 + this.pitchInRadians,
              I = s.ak(this.fov) * (Math.abs(Math.cos(s.ak(this.roll))) * this.height + Math.abs(Math.sin(s.ak(this.roll))) * this.width) / this.height * (.5 + o.y / this.height),
              A = Math.sin(I) * g / Math.sin(s.ai(Math.PI - w - I, .01, Math.PI - .01)),
              L = ve(this),
              O = Math.atan(L / this._helper.cameraToCenterDistance),
              R = s.ak(.75),
              H = O > R ? 2 * O * (.5 + o.y / (2 * L)) : R,
              $ = Math.sin(H) * g / Math.sin(s.ai(Math.PI - w - H, .01, Math.PI - .01)),
              ce = Math.min(A, $);
            this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - a) * ce + g), this._helper._nearZ = this._helper._height / 50
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const e = this.centerOffset,
              a = oe(this.worldSize, this.center),
              o = a.x,
              u = a.y;
            this._helper._pixelPerMeter = s.an(1, this.center.lat) * this.worldSize;
            const p = s.ak(Math.min(this.pitch, ne)),
              g = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(p));
            let w;
            this._calculateNearFarZIfNeeded(g, p, e), w = new Float64Array(16), s.b7(w, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), s.au(this._invProjMatrix, w), w[8] = 2 * -e.x / this._helper._width, w[9] = 2 * e.y / this._helper._height, this._projectionMatrix = s.b8(w), s.O(w, w, [1, -1, 1]), s.N(w, w, [0, 0, -this._helper.cameraToCenterDistance]), s.b9(w, w, -this.rollInRadians), s.ba(w, w, this.pitchInRadians), s.b9(w, w, -this.bearingInRadians), s.N(w, w, [-o, -u, 0]), this._mercatorMatrix = s.O([], w, [this.worldSize, this.worldSize, this.worldSize]), s.O(w, w, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = s.Q(new Float64Array(16), this.clipSpaceToPixelsMatrix, w), s.N(w, w, [0, 0, -this.elevation]), this._viewProjMatrix = w, this._invViewProjMatrix = s.au([], w);
            const I = [0, 0, -1, 1];
            s.aA(I, I, this._invViewProjMatrix), this._cameraPosition = [I[0] / I[3], I[1] / I[3], I[2] / I[3]], this._fogMatrix = new Float64Array(16), s.b7(this._fogMatrix, this.fovInRadians, this.width / this.height, g, this._helper._farZ), this._fogMatrix[8] = 2 * -e.x / this.width, this._fogMatrix[9] = 2 * e.y / this.height, s.O(this._fogMatrix, this._fogMatrix, [1, -1, 1]), s.N(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), s.b9(this._fogMatrix, this._fogMatrix, -this.rollInRadians), s.ba(this._fogMatrix, this._fogMatrix, this.pitchInRadians), s.b9(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), s.N(this._fogMatrix, this._fogMatrix, [-o, -u, 0]), s.O(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), s.N(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = s.Q(new Float64Array(16), this.clipSpaceToPixelsMatrix, w);
            const A = this._helper._width % 2 / 2,
              L = this._helper._height % 2 / 2,
              O = Math.cos(this.bearingInRadians),
              R = Math.sin(-this.bearingInRadians),
              H = o - Math.round(o) + O * A + R * L,
              $ = u - Math.round(u) + O * L + R * A,
              ce = new Float64Array(w);
            if (s.N(ce, ce, [H > .5 ? H - 1 : H, $ > .5 ? $ - 1 : $, 0]), this._alignedProjMatrix = ce, w = s.au(new Float64Array(16), this._pixelMatrix), !w) throw new Error("failed to invert matrix");
            this._pixelMatrixInverse = w, this._clearMatrixCaches()
          }
          _clearMatrixCaches() {
            this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear()
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const e = this.screenPointToMercatorCoordinate(new s.P(0, 0)),
              a = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
            return s.aA(a, a, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            const e = s.an(1, this.center.lat) * this.worldSize;
            return Y(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e).toLngLat()
          }
          lngLatToCameraDepth(e, a) {
            const o = s.a5.fromLngLat(e),
              u = [o.x * this.worldSize, o.y * this.worldSize, a, 1];
            return s.aA(u, u, this._viewProjMatrix), u[2] / u[3]
          }
          getProjectionData(e) {
            const {
              overscaledTileID: a,
              aligned: o,
              applyTerrainMatrix: u
            } = e, p = this._helper.getMercatorTileCoordinates(a), g = a ? this.calculatePosMatrix(a, o, !0) : null;
            let w;
            return w = a && a.terrainRttPosMatrix32f && u ? a.terrainRttPosMatrix32f : g || s.bb(), {
              mainMatrix: w,
              tileMercatorCoords: p,
              clippingPlane: [0, 0, 0, 0],
              projectionTransition: 0,
              fallbackMatrix: w
            }
          }
          isLocationOccluded(e) {
            return !1
          }
          getPixelScale() {
            return 1
          }
          getCircleRadiusCorrection() {
            return 1
          }
          getPitchedTextCorrection(e, a, o) {
            return 1
          }
          transformLightDirection(e) {
            return s.aW(e)
          }
          getRayDirectionFromPixel(e) {
            throw new Error("Not implemented.")
          }
          projectTileCoordinates(e, a, o, u) {
            const p = this.calculatePosMatrix(o);
            let g;
            u ? (g = [e, a, u(e, a), 1], s.aA(g, g, p)) : (g = [e, a, 0, 1], ti(g, g, p));
            const w = g[3];
            return {
              point: new s.P(g[0] / w, g[1] / w),
              signedDistanceFromCamera: w,
              isOccluded: !1
            }
          }
          populateCache(e) {
            for (const a of e) this.calculatePosMatrix(a)
          }
          getMatrixForModel(e, a) {
            const o = s.a5.fromLngLat(e, a),
              u = o.meterInMercatorCoordinateUnits(),
              p = s.bc();
            return s.N(p, p, [o.x, o.y, o.z]), s.b9(p, p, Math.PI), s.ba(p, p, Math.PI / 2), s.O(p, p, [-u, u, u]), p
          }
          getProjectionDataForCustomLayer(e = !0) {
            const a = new s.a0(0, 0, 0, 0, 0),
              o = this.getProjectionData({
                overscaledTileID: a,
                applyGlobeMatrix: e
              }),
              u = ie(a, this.worldSize);
            s.Q(u, this._viewProjMatrix, u), o.tileMercatorCoords = [0, 0, 1, 1];
            const p = [s.a3, s.a3, this.worldSize / this._helper.pixelsPerMeter],
              g = s.bd();
            return s.O(g, u, p), o.fallbackMatrix = g, o.mainMatrix = g, o
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.calculatePosMatrix(e)
          }
        }

        function ea() {
          s.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.")
        }

        function pa(d) {
          if (d.useSlerp)
            if (d.k < 1) {
              const e = s.be(d.startEulerAngles.roll, d.startEulerAngles.pitch, d.startEulerAngles.bearing),
                a = s.be(d.endEulerAngles.roll, d.endEulerAngles.pitch, d.endEulerAngles.bearing),
                o = new Float64Array(4);
              s.bf(o, e, a, d.k);
              const u = s.bg(o);
              d.tr.setRoll(u.roll), d.tr.setPitch(u.pitch), d.tr.setBearing(u.bearing)
            } else d.tr.setRoll(d.endEulerAngles.roll), d.tr.setPitch(d.endEulerAngles.pitch), d.tr.setBearing(d.endEulerAngles.bearing);
          else d.tr.setRoll(s.F.number(d.startEulerAngles.roll, d.endEulerAngles.roll, d.k)), d.tr.setPitch(s.F.number(d.startEulerAngles.pitch, d.endEulerAngles.pitch, d.k)), d.tr.setBearing(s.F.number(d.startEulerAngles.bearing, d.endEulerAngles.bearing, d.k))
        }

        function Ia(d, e, a, o, u) {
          const p = u.padding,
            g = oe(u.worldSize, a.getNorthWest()),
            w = oe(u.worldSize, a.getNorthEast()),
            I = oe(u.worldSize, a.getSouthEast()),
            A = oe(u.worldSize, a.getSouthWest()),
            L = s.ak(-o),
            O = g.rotate(L),
            R = w.rotate(L),
            H = I.rotate(L),
            $ = A.rotate(L),
            ce = new s.P(Math.max(O.x, R.x, $.x, H.x), Math.max(O.y, R.y, $.y, H.y)),
            ue = new s.P(Math.min(O.x, R.x, $.x, H.x), Math.min(O.y, R.y, $.y, H.y)),
            de = ce.sub(ue),
            Ce = (u.width - (p.left + p.right + e.left + e.right)) / de.x,
            Be = (u.height - (p.top + p.bottom + e.top + e.bottom)) / de.y;
          if (Be < 0 || Ce < 0) return void ea();
          const Ie = Math.min(s.ao(u.scale * Math.min(Ce, Be)), d.maxZoom),
            Oe = s.P.convert(d.offset),
            He = new s.P((e.left - e.right) / 2, (e.top - e.bottom) / 2).rotate(s.ak(o)),
            Le = Oe.add(He).mult(u.scale / s.al(Ie));
          return {
            center: fe(u.worldSize, g.add(I).div(2).sub(Le)),
            zoom: Ie,
            bearing: o
          }
        }
        class Na {
          get useGlobeControls() {
            return !1
          }
          handlePanInertia(e, a) {
            const o = e.mag(),
              u = Math.abs(ve(a));
            return {
              easingOffset: e.mult(Math.min(.75 * u / o, 1)),
              easingCenter: a.center
            }
          }
          handleMapControlsRollPitchBearingZoom(e, a) {
            e.bearingDelta && a.setBearing(a.bearing + e.bearingDelta), e.pitchDelta && a.setPitch(a.pitch + e.pitchDelta), e.rollDelta && a.setRoll(a.roll + e.rollDelta), e.zoomDelta && a.setZoom(a.zoom + e.zoomDelta)
          }
          handleMapControlsPan(e, a, o) {
            e.around.distSqr(a.centerPoint) < .01 || a.setLocationAtPoint(o, e.around)
          }
          cameraForBoxAndBearing(e, a, o, u, p) {
            return Ia(e, a, o, u, p)
          }
          handleJumpToCenterZoom(e, a) {
            e.zoom !== (a.zoom !== void 0 ? +a.zoom : e.zoom) && e.setZoom(+a.zoom), a.center !== void 0 && e.setCenter(s.U.convert(a.center))
          }
          handleEaseTo(e, a) {
            const o = e.zoom,
              u = e.padding,
              p = {
                roll: e.roll,
                pitch: e.pitch,
                bearing: e.bearing
              },
              g = {
                roll: a.roll === void 0 ? e.roll : a.roll,
                pitch: a.pitch === void 0 ? e.pitch : a.pitch,
                bearing: a.bearing === void 0 ? e.bearing : a.bearing
              },
              w = a.zoom !== void 0,
              I = !e.isPaddingEqual(a.padding);
            let A = !1;
            const L = w ? +a.zoom : e.zoom;
            let O = e.centerPoint.add(a.offsetAsPoint);
            const R = e.screenPointToLocation(O),
              {
                center: H,
                zoom: $
              } = e.constrain(s.U.convert(a.center || R), L ?? o);
            fi(e, H);
            const ce = oe(e.worldSize, R),
              ue = oe(e.worldSize, H).sub(ce),
              de = s.al($ - o);
            return A = $ !== o, {
              easeFunc: Ce => {
                if (A && e.setZoom(s.F.number(o, $, Ce)), s.bh(p, g) || pa({
                    startEulerAngles: p,
                    endEulerAngles: g,
                    tr: e,
                    k: Ce,
                    useSlerp: p.roll != g.roll
                  }), I && (e.interpolatePadding(u, a.padding, Ce), O = e.centerPoint.add(a.offsetAsPoint)), a.around) e.setLocationAtPoint(a.around, a.aroundPoint);
                else {
                  const Be = s.al(e.zoom - o),
                    Ie = $ > o ? Math.min(2, de) : Math.max(.5, de),
                    Oe = Math.pow(Ie, 1 - Ce),
                    He = fe(e.worldSize, ce.add(ue.mult(Ce * Oe)).mult(Be));
                  e.setLocationAtPoint(e.renderWorldCopies ? He.wrap() : He, O)
                }
              },
              isZooming: A,
              elevationCenter: H
            }
          }
          handleFlyTo(e, a) {
            const o = a.zoom !== void 0,
              u = e.zoom,
              p = e.constrain(s.U.convert(a.center || a.locationAtOffset), o ? +a.zoom : u),
              g = p.center,
              w = p.zoom;
            fi(e, g);
            const I = oe(e.worldSize, a.locationAtOffset),
              A = oe(e.worldSize, g).sub(I),
              L = A.mag(),
              O = s.al(w - u);
            let R;
            if (a.minZoom !== void 0) {
              const H = Math.min(+a.minZoom, u, w),
                $ = e.constrain(g, H).zoom;
              R = s.al($ - u)
            }
            return {
              easeFunc: (H, $, ce, ue) => {
                e.setZoom(H === 1 ? w : u + s.ao($));
                const de = H === 1 ? g : fe(e.worldSize, I.add(A.mult(ce)).mult($));
                e.setLocationAtPoint(e.renderWorldCopies ? de.wrap() : de, ue)
              },
              scaleOfZoom: O,
              targetCenter: g,
              scaleOfMinZoom: R,
              pixelPathLength: L
            }
          }
        }
        class Mi {
          constructor(e, a, o) {
            this.blendFunction = e, this.blendColor = a, this.mask = o
          }
        }
        Mi.Replace = [1, 0], Mi.disabled = new Mi(Mi.Replace, s.bi.transparent, [!1, !1, !1, !1]), Mi.unblended = new Mi(Mi.Replace, s.bi.transparent, [!0, !0, !0, !0]), Mi.alphaBlended = new Mi([1, 771], s.bi.transparent, [!0, !0, !0, !0]);
        const wn = 2305;
        class Ti {
          constructor(e, a, o) {
            this.enable = e, this.mode = a, this.frontFace = o
          }
        }
        Ti.disabled = new Ti(!1, 1029, wn), Ti.backCCW = new Ti(!0, 1029, wn), Ti.frontCCW = new Ti(!0, 1028, wn);
        class Si {
          constructor(e, a, o) {
            this.func = e, this.mask = a, this.range = o
          }
        }
        Si.ReadOnly = !1, Si.ReadWrite = !0, Si.disabled = new Si(519, Si.ReadOnly, [0, 1]);
        const Bn = 7680;
        class Fi {
          constructor(e, a, o, u, p, g) {
            this.test = e, this.ref = a, this.mask = o, this.fail = u, this.depthFail = p, this.pass = g
          }
        }
        Fi.disabled = new Fi({
          func: 519,
          mask: 0
        }, 0, 0, Bn, Bn, Bn);
        const On = new WeakMap;

        function Va(d) {
          var e;
          if (On.has(d)) return On.get(d);
          {
            const a = (e = d.getParameter(d.VERSION)) === null || e === void 0 ? void 0 : e.startsWith("WebGL 2.0");
            return On.set(d, a), a
          }
        }
        class es {
          get awaitingQuery() {
            return !!this._readbackQueue
          }
          constructor(e) {
            this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e;
            const a = e.context,
              o = a.gl;
            this._texFormat = o.RGBA, this._texType = o.UNSIGNED_BYTE;
            const u = new s.aP;
            u.emplaceBack(-1, -1), u.emplaceBack(2, -1), u.emplaceBack(-1, 2);
            const p = new s.aR;
            p.emplaceBack(0, 1, 2), this._fullscreenTriangle = new Xi(a.createVertexBuffer(u, Vi.members), a.createIndexBuffer(p), s.aQ.simpleSegment(0, 0, u.length, p.length)), this._resultBuffer = new Uint8Array(4), a.activeTexture.set(o.TEXTURE1);
            const g = o.createTexture();
            o.bindTexture(o.TEXTURE_2D, g), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, o.CLAMP_TO_EDGE), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, o.CLAMP_TO_EDGE), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, o.NEAREST), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, o.NEAREST), o.texImage2D(o.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = a.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(g), Va(o) && (this._pbo = o.createBuffer(), o.bindBuffer(o.PIXEL_PACK_BUFFER, this._pbo), o.bufferData(o.PIXEL_PACK_BUFFER, 4, o.STREAM_READ), o.bindBuffer(o.PIXEL_PACK_BUFFER, null))
          }
          destroy() {
            const e = this._cachedRenderContext.context.gl;
            this._fullscreenTriangle.destroy(), this._fbo.destroy(), e.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null
          }
          updateErrorLoop(e, a) {
            const o = this._updateCount;
            return this._readbackQueue ? o >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : o >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e, a), this._updateCount++, this._measuredError
          }
          _bindFramebuffer() {
            const e = this._cachedRenderContext.context,
              a = e.gl;
            e.activeTexture.set(a.TEXTURE1), a.bindTexture(a.TEXTURE_2D, this._fbo.colorAttachment.get()), e.bindFramebuffer.set(this._fbo.framebuffer)
          }
          _renderErrorTexture(e, a) {
            const o = this._cachedRenderContext.context,
              u = o.gl;
            if (this._bindFramebuffer(), o.viewport.set([0, 0, this._texWidth, this._texHeight]), o.clear({
                color: s.bi.transparent
              }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(o, u.TRIANGLES, Si.disabled, Fi.disabled, Mi.unblended, Ti.disabled, ((p, g) => ({
                u_input: p,
                u_output_expected: g
              }))(e, a), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && Va(u)) {
              u.bindBuffer(u.PIXEL_PACK_BUFFER, this._pbo), u.readBuffer(u.COLOR_ATTACHMENT0), u.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), u.bindBuffer(u.PIXEL_PACK_BUFFER, null);
              const p = u.fenceSync(u.SYNC_GPU_COMMANDS_COMPLETE, 0);
              u.flush(), this._readbackQueue = {
                frameNumberIssued: this._updateCount,
                sync: p
              }
            } else this._readbackQueue = {
              frameNumberIssued: this._updateCount,
              sync: null
            }
          }
          _tryReadback() {
            const e = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && Va(e)) {
              const a = e.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (a === e.WAIT_FAILED) return s.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void(this._lastReadbackFrame = this._updateCount);
              if (a === e.TIMEOUT_EXPIRED) return;
              e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo), e.getBufferSubData(e.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e.bindBuffer(e.PIXEL_PACK_BUFFER, null)
            } else this._bindFramebuffer(), e.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
            this._readbackQueue = null, this._measuredError = es._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount
          }
          static _parseRGBA8float(e) {
            let a = 0;
            return a += e[0] / 256, a += e[1] / 65536, a += e[2] / 16777216, e[3] < 127 && (a = -a), a / 128
          }
        }
        const jn = s.a3 / 128;

        function Tn(d, e) {
          const a = d.granularity !== void 0 ? Math.max(d.granularity, 1) : 1,
            o = a + (d.generateBorders ? 2 : 0),
            u = a + (d.extendToNorthPole || d.generateBorders ? 1 : 0) + (d.extendToSouthPole || d.generateBorders ? 1 : 0),
            p = o + 1,
            g = u + 1,
            w = d.generateBorders ? -1 : 0,
            I = d.generateBorders || d.extendToNorthPole ? -1 : 0,
            A = a + (d.generateBorders ? 1 : 0),
            L = a + (d.generateBorders || d.extendToSouthPole ? 1 : 0),
            O = p * g,
            R = o * u * 6,
            H = p * g > 65536;
          if (H && e === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
          const $ = H || e === "32bit",
            ce = new Int16Array(2 * O);
          let ue = 0;
          for (let Be = I; Be <= L; Be++)
            for (let Ie = w; Ie <= A; Ie++) {
              let Oe = Ie / a * s.a3;
              Ie === -1 && (Oe = -jn), Ie === a + 1 && (Oe = s.a3 + jn);
              let He = Be / a * s.a3;
              Be === -1 && (He = d.extendToNorthPole ? s.bk : -jn), Be === a + 1 && (He = d.extendToSouthPole ? s.bl : s.a3 + jn), ce[ue++] = Oe, ce[ue++] = He
            }
          const de = $ ? new Uint32Array(R) : new Uint16Array(R);
          let Ce = 0;
          for (let Be = 0; Be < u; Be++)
            for (let Ie = 0; Ie < o; Ie++) {
              const Oe = Ie + 1 + Be * p,
                He = Ie + (Be + 1) * p,
                Le = Ie + 1 + (Be + 1) * p;
              de[Ce++] = Ie + Be * p, de[Ce++] = He, de[Ce++] = Oe, de[Ce++] = Oe, de[Ce++] = He, de[Ce++] = Le
            }
          return {
            vertices: ce.buffer.slice(0),
            indices: de.buffer.slice(0),
            uses32bitIndices: $
          }
        }
        const os = new s.aO({
          fill: new s.bm(128, 2),
          line: new s.bm(512, 0),
          tile: new s.bm(128, 32),
          stencil: new s.bm(128, 1),
          circle: 3
        });
        class qn {
          constructor() {
            this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3
          }
          get name() {
            return "vertical-perspective"
          }
          get transitionState() {
            return 1
          }
          get useSubdivision() {
            return !0
          }
          get shaderVariantName() {
            return "globe"
          }
          get shaderDefine() {
            return "#define GLOBE"
          }
          get shaderPreludeCode() {
            return Ar.projectionGlobe
          }
          get vertexShaderPreludeCode() {
            return Ar.projectionMercator.vertexSource
          }
          get subdivisionGranularity() {
            return os
          }
          get useGlobeControls() {
            return !0
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy()
          }
          updateGPUdependent(e) {
            this._errorMeasurement || (this._errorMeasurement = new es(e));
            const a = s.W(this._errorQueryLatitudeDegrees),
              o = 2 * Math.atan(Math.exp(Math.PI - a * Math.PI * 2)) - .5 * Math.PI,
              u = this._errorMeasurement.updateErrorLoop(a, o),
              p = me();
            u !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = u, this._errorMeasurementLastChangeTime = p);
            const g = Math.min(Math.max((p - this._errorMeasurementLastChangeTime) / 1e3 / .5, 0), 1);
            this._errorCorrectionUsable = s.bn(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, s.bo(g))
          }
          _getMeshKey(e) {
            return `${e.granularity.toString(36)}_${e.generateBorders?"b":""}${e.extendToNorthPole?"n":""}${e.extendToSouthPole?"s":""}`
          }
          getMeshFromTileID(e, a, o, u, p) {
            const g = (p === "stencil" ? os.stencil : os.tile).getGranularityForZoomLevel(a.z);
            return this._getMesh(e, {
              granularity: g,
              generateBorders: o,
              extendToNorthPole: a.y === 0 && u,
              extendToSouthPole: a.y === (1 << a.z) - 1 && u
            })
          }
          _getMesh(e, a) {
            const o = this._getMeshKey(a);
            if (o in this._tileMeshCache) return this._tileMeshCache[o];
            const u = (function(p, g) {
              const w = Tn(g, "16bit"),
                I = s.aP.deserialize({
                  arrayBuffer: w.vertices,
                  length: w.vertices.byteLength / 2 / 2
                }),
                A = s.aR.deserialize({
                  arrayBuffer: w.indices,
                  length: w.indices.byteLength / 2 / 3
                });
              return new Xi(p.createVertexBuffer(I, Vi.members), p.createIndexBuffer(A), s.aQ.simpleSegment(0, 0, I.length, A.length))
            })(e, a);
            return this._tileMeshCache[o] = u, u
          }
          recalculate(e) {}
          hasTransition() {
            const e = me();
            let a = !1;
            return a = a || (e - this._errorMeasurementLastChangeTime) / 1e3 < .7, a = a || this._errorMeasurement && this._errorMeasurement.awaitingQuery, a
          }
          setErrorQueryLatitudeDegrees(e) {
            this._errorQueryLatitudeDegrees = e
          }
        }
        const ts = new s.r({
          type: new s.D(s.t.projection.type)
        });
        class fa extends s.E {
          constructor(e) {
            super(), this._transitionable = new s.x(ts, void 0), this.setProjection(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new s.G(0)), this._mercatorProjection = new zi, this._verticalPerspectiveProjection = new qn
          }
          get transitionState() {
            const e = this.properties.get("type");
            if (typeof e == "string" && e === "mercator") return 0;
            if (typeof e == "string" && e === "vertical-perspective") return 1;
            if (e instanceof s.bp) {
              if (e.from === "vertical-perspective" && e.to === "mercator") return 1 - e.transition;
              if (e.from === "mercator" && e.to === "vertical-perspective") return e.transition
            }
            return 1
          }
          get useGlobeRendering() {
            return this.transitionState > 0
          }
          get latitudeErrorCorrectionRadians() {
            return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians
          }
          get currentProjection() {
            return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection
          }
          get name() {
            return "globe"
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity
          }
          get useGlobeControls() {
            return this.transitionState > 0
          }
          destroy() {
            this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy()
          }
          updateGPUdependent(e) {
            this._mercatorProjection.updateGPUdependent(e), this._verticalPerspectiveProjection.updateGPUdependent(e)
          }
          getMeshFromTileID(e, a, o, u, p) {
            return this.currentProjection.getMeshFromTileID(e, a, o, u, p)
          }
          setProjection(e) {
            this._transitionable.setValue("type", (e == null ? void 0 : e.type) || "mercator")
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition() || this.currentProjection.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          setErrorQueryLatitudeDegrees(e) {
            this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e), this._mercatorProjection.setErrorQueryLatitudeDegrees(e)
          }
        }

        function Ma(d) {
          const e = Nn(d.worldSize, d.center.lat);
          return 2 * Math.PI * e
        }

        function pn(d, e, a, o, u) {
          const p = 1 / (1 << u),
            g = e / s.a3 * p + o * p,
            w = s.br((d / s.a3 * p + a * p) * Math.PI * 2 + Math.PI, 2 * Math.PI),
            I = 2 * Math.atan(Math.exp(Math.PI - g * Math.PI * 2)) - .5 * Math.PI,
            A = Math.cos(I),
            L = new Float64Array(3);
          return L[0] = Math.sin(w) * A, L[1] = Math.sin(I), L[2] = Math.cos(w) * A, L
        }

        function ma(d) {
          return (function(e, a) {
            const o = Math.cos(a),
              u = new Float64Array(3);
            return u[0] = Math.sin(e) * o, u[1] = Math.sin(a), u[2] = Math.cos(e) * o, u
          })(d.lng * Math.PI / 180, d.lat * Math.PI / 180)
        }

        function Nn(d, e) {
          return d / (2 * Math.PI) / Math.cos(e * Math.PI / 180)
        }

        function Bs(d) {
          const e = Math.asin(d[1]) / Math.PI * 180,
            a = Math.sqrt(d[0] * d[0] + d[2] * d[2]);
          if (a > 1e-6) {
            const o = d[0] / a,
              u = Math.acos(d[2] / a),
              p = (o > 0 ? u : -u) / Math.PI * 180;
            return new s.U(s.V(p, -180, 180), e)
          }
          return new s.U(0, e)
        }

        function yo(d) {
          return Math.cos(d * Math.PI / 180)
        }

        function Ki(d, e) {
          const a = yo(d),
            o = yo(e);
          return s.ao(o / a)
        }

        function Pl(d, e) {
          const a = d.rotate(e.bearingInRadians),
            o = e.zoom + Ki(e.center.lat, 0),
            u = s.bn(1 / yo(e.center.lat), 1 / yo(Math.min(Math.abs(e.center.lat), 60)), s.bq(o, 7, 3, 0, 1)),
            p = 360 / Ma({
              worldSize: e.worldSize,
              center: {
                lat: e.center.lat
              }
            });
          return new s.U(e.center.lng - a.x * p * u, s.ai(e.center.lat + a.y * p, -s.aj, s.aj))
        }

        function En(d) {
          const e = .5 * d,
            a = Math.sin(e),
            o = Math.cos(e);
          return Math.log(a + o) - Math.log(o - a)
        }

        function Uo(d, e, a, o) {
          const u = d.lat + a * o;
          if (Math.abs(a) > 1) {
            const p = (Math.sign(d.lat + a) !== Math.sign(d.lat) ? -Math.abs(d.lat) : Math.abs(d.lat)) * Math.PI / 180,
              g = Math.abs(d.lat + a) * Math.PI / 180,
              w = En(p + o * (g - p)),
              I = En(p),
              A = En(g);
            return new s.U(d.lng + e * ((w - I) / (A - I)), u)
          }
          return new s.U(d.lng + e * o, u)
        }
        class Oh {
          constructor(e) {
            this._cachePrevious = new Map, this._cache = new Map, this._hadAnyChanges = !1, this._boundingVolumeFactory = e
          }
          swapBuffers() {
            if (!this._hadAnyChanges) return;
            const e = this._cachePrevious;
            this._cachePrevious = this._cache, this._cache = e, this._cache.clear(), this._hadAnyChanges = !1
          }
          getTileBoundingVolume(e, a, o, u) {
            const p = `${e.z}_${e.x}_${e.y}_${u!=null&&u.terrain?"t":""}`,
              g = this._cache.get(p);
            if (g) return g;
            const w = this._cachePrevious.get(p);
            if (w) return this._cache.set(p, w), w;
            const I = this._boundingVolumeFactory(e, a, o, u);
            return this._cache.set(p, I), this._hadAnyChanges = !0, I
          }
        }
        class Os {
          constructor(e, a, o, u) {
            this.min = o, this.max = u, this.points = e, this.planes = a
          }
          static fromAabb(e, a) {
            const o = [];
            for (let u = 0; u < 8; u++) o.push([1 & ~u ? e[0] : a[0], (u >> 1 & 1) == 1 ? a[1] : e[1], (u >> 2 & 1) == 1 ? a[2] : e[2]]);
            return new Os(o, [
              [-1, 0, 0, a[0]],
              [1, 0, 0, -e[0]],
              [0, -1, 0, a[1]],
              [0, 1, 0, -e[1]],
              [0, 0, -1, a[2]],
              [0, 0, 1, -e[2]]
            ], e, a)
          }
          static fromCenterSizeAngles(e, a, o) {
            const u = s.bu([], o[0], o[1], o[2]),
              p = s.bv([], [a[0], 0, 0], u),
              g = s.bv([], [0, a[1], 0], u),
              w = s.bv([], [0, 0, a[2]], u),
              I = [...e],
              A = [...e];
            for (let O = 0; O < 8; O++)
              for (let R = 0; R < 3; R++) {
                const H = e[R] + p[R] * (1 & ~O ? -1 : 1) + g[R] * ((O >> 1 & 1) == 1 ? 1 : -1) + w[R] * ((O >> 2 & 1) == 1 ? 1 : -1);
                I[R] = Math.min(I[R], H), A[R] = Math.max(A[R], H)
              }
            const L = [];
            for (let O = 0; O < 8; O++) {
              const R = [...e];
              s.aV(R, R, s.aU([], p, 1 & ~O ? -1 : 1)), s.aV(R, R, s.aU([], g, (O >> 1 & 1) == 1 ? 1 : -1)), s.aV(R, R, s.aU([], w, (O >> 2 & 1) == 1 ? 1 : -1)), L.push(R)
            }
            return new Os(L, [
              [...p, -s.a_(p, L[0])],
              [...g, -s.a_(g, L[0])],
              [...w, -s.a_(w, L[0])],
              [-p[0], -p[1], -p[2], -s.a_(p, L[7])],
              [-g[0], -g[1], -g[2], -s.a_(g, L[7])],
              [-w[0], -w[1], -w[2], -s.a_(w, L[7])]
            ], I, A)
          }
          intersectsFrustum(e) {
            let a = !0;
            const o = this.points.length,
              u = this.planes.length,
              p = e.planes.length,
              g = e.points.length;
            for (let w = 0; w < p; w++) {
              const I = e.planes[w];
              let A = 0;
              for (let L = 0; L < o; L++) {
                const O = this.points[L];
                I[0] * O[0] + I[1] * O[1] + I[2] * O[2] + I[3] >= 0 && A++
              }
              if (A === 0) return 0;
              A < o && (a = !1)
            }
            if (a) return 2;
            for (let w = 0; w < u; w++) {
              const I = this.planes[w];
              let A = 0;
              for (let L = 0; L < g; L++) {
                const O = e.points[L];
                I[0] * O[0] + I[1] * O[1] + I[2] * O[2] + I[3] >= 0 && A++
              }
              if (A === 0) return 0
            }
            return 1
          }
          intersectsPlane(e) {
            const a = this.points.length;
            let o = 0;
            for (let u = 0; u < a; u++) {
              const p = this.points[u];
              e[0] * p[0] + e[1] * p[1] + e[2] * p[2] + e[3] >= 0 && o++
            }
            return o === a ? 2 : o === 0 ? 0 : 1
          }
        }

        function ls(d, e, a) {
          const o = d - e;
          return o < 0 ? -o : Math.max(0, o - a)
        }

        function jc(d, e, a, o, u) {
          const p = d - a;
          let g;
          return g = p < 0 ? Math.min(-p, 1 + p - u) : p > 1 ? Math.min(Math.max(p - u, 0), 1 - p) : 0, Math.max(g, ls(e, o, u))
        }
        class Zp {
          constructor() {
            this._boundingVolumeCache = new Oh(this._computeTileBoundingVolume)
          }
          prepareNextFrame() {
            this._boundingVolumeCache.swapBuffers()
          }
          distanceToTile2d(e, a, o, u) {
            const p = 1 << o.z,
              g = 1 / p,
              w = o.x / p,
              I = o.y / p;
            let A = 2;
            return A = Math.min(A, jc(e, a, w, I, g)), A = Math.min(A, jc(e, a, w + .5, -I - g, g)), A = Math.min(A, jc(e, a, w + .5, 2 - I - g, g)), A
          }
          getWrap(e, a, o) {
            const u = 1 << a.z,
              p = 1 / u,
              g = a.x / u,
              w = ls(e.x, g, p),
              I = ls(e.x, g - 1, p),
              A = ls(e.x, g + 1, p),
              L = Math.min(w, I, A);
            return L === A ? 1 : L === I ? -1 : 0
          }
          allowVariableZoom(e, a) {
            return Ve(e, a) > 4
          }
          allowWorldCopies() {
            return !1
          }
          getTileBoundingVolume(e, a, o, u) {
            return this._boundingVolumeCache.getTileBoundingVolume(e, a, o, u)
          }
          _computeTileBoundingVolume(e, a, o, u) {
            var p, g;
            let w = 0,
              I = 0;
            if (u != null && u.terrain) {
              const A = new s.a0(e.z, a, e.z, e.x, e.y),
                L = u.terrain.getMinMaxElevation(A);
              w = (p = L.minElevation) !== null && p !== void 0 ? p : Math.min(0, o), I = (g = L.maxElevation) !== null && g !== void 0 ? g : Math.max(0, o)
            }
            if (w /= s.bx, I /= s.bx, w += 1, I += 1, e.z <= 0) return Os.fromAabb([-I, -I, -I], [I, I, I]);
            if (e.z === 1) return Os.fromAabb([e.x === 0 ? -I : 0, e.y === 0 ? 0 : -I, -I], [e.x === 0 ? 0 : I, e.y === 0 ? I : 0, I]);
            {
              const A = [pn(0, 0, e.x, e.y, e.z), pn(s.a3, 0, e.x, e.y, e.z), pn(s.a3, s.a3, e.x, e.y, e.z), pn(0, s.a3, e.x, e.y, e.z)],
                L = [];
              for (const gt of A) L.push(s.aU([], gt, I));
              if (I !== w)
                for (const gt of A) L.push(s.aU([], gt, w));
              e.y === 0 && L.push([0, 1, 0]), e.y === (1 << e.z) - 1 && L.push([0, -1, 0]);
              const O = [1, 1, 1],
                R = [-1, -1, -1];
              for (const gt of L)
                for (let xt = 0; xt < 3; xt++) O[xt] = Math.min(O[xt], gt[xt]), R[xt] = Math.max(R[xt], gt[xt]);
              const H = pn(s.a3 / 2, s.a3 / 2, e.x, e.y, e.z),
                $ = s.aZ([], [0, 1, 0], H);
              s.aY($, $);
              const ce = s.aZ([], H, $);
              s.aY(ce, ce);
              const ue = s.aZ([], A[2], A[1]);
              s.aY(ue, ue);
              const de = s.aZ([], A[0], A[3]);
              s.aY(de, de), L.push(s.aU([], H, I)), e.y >= (1 << e.z) / 2 && L.push(s.aU([], pn(s.a3 / 2, 0, e.x, e.y, e.z), I)), e.y < (1 << e.z) / 2 && L.push(s.aU([], pn(s.a3 / 2, s.a3, e.x, e.y, e.z), I));
              const Ce = jh(H, L),
                Be = jh(ce, L),
                Ie = [-H[0], -H[1], -H[2], Ce.max],
                Oe = [H[0], H[1], H[2], -Ce.min],
                He = [-ce[0], -ce[1], -ce[2], Be.max],
                Le = [ce[0], ce[1], ce[2], -Be.min],
                $e = [...ue, 0],
                vt = [...de, 0],
                ft = [];
              return e.y === 0 ? ft.push(s.bw(vt, $e, Ie), s.bw(vt, $e, Oe)) : ft.push(s.bw(He, $e, Ie), s.bw(He, $e, Oe), s.bw(He, vt, Ie), s.bw(He, vt, Oe)), e.y === (1 << e.z) - 1 ? ft.push(s.bw(vt, $e, Ie), s.bw(vt, $e, Oe)) : ft.push(s.bw(Le, $e, Ie), s.bw(Le, $e, Oe), s.bw(Le, vt, Ie), s.bw(Le, vt, Oe)), new Os(ft, [Ie, Oe, He, Le, $e, vt], O, R)
            }
          }
        }

        function jh(d, e) {
          let a = 1 / 0,
            o = -1 / 0;
          for (const u of e) {
            const p = s.a_(d, u);
            a = Math.min(a, p), o = Math.max(o, p)
          }
          return {
            min: a,
            max: o
          }
        }
        class Il {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, a, o) {
            return this._helper.interpolatePadding(e, a, o)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, a) {
            this._helper.resize(e, a)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          setConstrain(e) {
            this._helper.setConstrain(e)
          }
          overrideNearFarZ(e, a) {
            this._helper.overrideNearFarZ(e, a)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get constrain() {
            return this._helper.constrain
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          setTransitionState(e) {}
          constructor(e) {
            this._cachedClippingPlane = s.by(), this._projectionMatrix = s.bc(), this._globeViewProjMatrix32f = s.bb(), this._globeViewProjMatrixNoCorrection = s.bc(), this._globeViewProjMatrixNoCorrectionInverted = s.bc(), this._globeProjMatrixInverted = s.bc(), this._cameraPosition = s.bs(), this._globeLatitudeErrorCorrectionRadians = 0, this.defaultConstrain = (a, o) => {
              const u = s.ai(a.lat, -s.aj, s.aj),
                p = s.ai(+o, this.minZoom + Ki(0, u), this.maxZoom);
              return {
                center: new s.U(a.lng, u),
                zoom: p
              }
            }, this._helper = new Yi({
              calcMatrices: () => {
                this._calcMatrices()
              },
              constrain: (a, o) => this.defaultConstrain(a, o)
            }, e), this._coveringTilesDetailsProvider = new Zp
          }
          clone() {
            const e = new Il;
            return e.apply(this), e
          }
          apply(e, a) {
            this._globeLatitudeErrorCorrectionRadians = a || 0, this._helper.apply(e)
          }
          get projectionMatrix() {
            return this._projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted
          }
          get cameraPosition() {
            const e = s.bs();
            return e[0] = this._cameraPosition[0], e[1] = this._cameraPosition[1], e[2] = this._cameraPosition[2], e
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          getProjectionData(e) {
            const {
              overscaledTileID: a,
              applyGlobeMatrix: o
            } = e, u = this._helper.getMercatorTileCoordinates(a);
            return {
              mainMatrix: this._globeViewProjMatrix32f,
              tileMercatorCoords: u,
              clippingPlane: this._cachedClippingPlane,
              projectionTransition: o ? 1 : 0,
              fallbackMatrix: this._globeViewProjMatrix32f
            }
          }
          _computeClippingPlane(e) {
            const a = this.pitchInRadians,
              o = this.cameraToCenterDistance / e,
              u = Math.sin(a) * o,
              p = Math.cos(a) * o + 1,
              g = 1 / Math.sqrt(u * u + p * p) * 1;
            let w = -u,
              I = p;
            const A = Math.sqrt(w * w + I * I);
            w /= A, I /= A;
            const L = [0, w, I];
            s.bz(L, L, [0, 0, 0], -this.bearingInRadians), s.bA(L, L, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), s.bB(L, L, [0, 0, 0], this.center.lng * Math.PI / 180);
            const O = 1 / s.b0(L);
            return s.aU(L, L, O), [...L, -g * O]
          }
          isLocationOccluded(e) {
            return !this.isSurfacePointVisible(ma(e))
          }
          transformLightDirection(e) {
            const a = this._helper._center.lng * Math.PI / 180,
              o = this._helper._center.lat * Math.PI / 180,
              u = Math.cos(o),
              p = [Math.sin(a) * u, Math.sin(o), Math.cos(a) * u],
              g = [p[2], 0, -p[0]],
              w = [0, 0, 0];
            s.aZ(w, g, p), s.aY(g, g), s.aY(w, w);
            const I = [0, 0, 0];
            return s.aY(I, [g[0] * e[0] + w[0] * e[1] + p[0] * e[2], g[1] * e[0] + w[1] * e[1] + p[1] * e[2], g[2] * e[0] + w[2] * e[1] + p[2] * e[2]]), I
          }
          getPixelScale() {
            return 1 / Math.cos(this._helper._center.lat * Math.PI / 180)
          }
          getCircleRadiusCorrection() {
            return Math.cos(this._helper._center.lat * Math.PI / 180)
          }
          getPitchedTextCorrection(e, a, o) {
            const u = (function(w, I, A) {
                const L = 1 / (1 << A.z);
                return new s.a5(w / s.a3 * L + A.x * L, I / s.a3 * L + A.y * L)
              })(e, a, o.canonical),
              p = (g = u.y, [s.br(u.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - g * Math.PI * 2)) - .5 * Math.PI]);
            var g;
            return this.getCircleRadiusCorrection() / Math.cos(p[1])
          }
          projectTileCoordinates(e, a, o, u) {
            const p = o.canonical,
              g = pn(e, a, p.x, p.y, p.z),
              w = 1 + (u ? u(e, a) : 0) / s.bx,
              I = [g[0] * w, g[1] * w, g[2] * w, 1];
            s.aA(I, I, this._globeViewProjMatrixNoCorrection);
            const A = this._cachedClippingPlane,
              L = A[0] * g[0] + A[1] * g[1] + A[2] * g[2] + A[3] < 0;
            return {
              point: new s.P(I[0] / I[3], I[1] / I[3]),
              signedDistanceFromCamera: I[3],
              isOccluded: L
            }
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const e = Nn(this.worldSize, this.center.lat),
              a = s.bd(),
              o = s.bd();
            this._helper.autoCalculateNearFarZ && (this._helper._nearZ = .5, this._helper._farZ = this.cameraToCenterDistance + 2 * e), s.b7(a, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
            const u = this.centerOffset;
            a[8] = 2 * -u.x / this._helper._width, a[9] = 2 * u.y / this._helper._height, this._projectionMatrix = s.b8(a), this._globeProjMatrixInverted = s.bd(), s.au(this._globeProjMatrixInverted, a), s.N(a, a, [0, 0, -this.cameraToCenterDistance]), s.b9(a, a, this.rollInRadians), s.ba(a, a, -this.pitchInRadians), s.b9(a, a, this.bearingInRadians), s.N(a, a, [0, 0, -e]);
            const p = s.bs();
            p[0] = e, p[1] = e, p[2] = e, s.ba(o, a, this.center.lat * Math.PI / 180), s.bC(o, o, -this.center.lng * Math.PI / 180), s.O(o, o, p), this._globeViewProjMatrixNoCorrection = o, s.ba(a, a, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), s.bC(a, a, -this.center.lng * Math.PI / 180), s.O(a, a, p), this._globeViewProjMatrix32f = new Float32Array(a), this._globeViewProjMatrixNoCorrectionInverted = s.bd(), s.au(this._globeViewProjMatrixNoCorrectionInverted, o);
            const g = s.bs();
            this._cameraPosition = s.bs(), this._cameraPosition[2] = this.cameraToCenterDistance / e, s.bz(this._cameraPosition, this._cameraPosition, g, -this.rollInRadians), s.bA(this._cameraPosition, this._cameraPosition, g, this.pitchInRadians), s.bz(this._cameraPosition, this._cameraPosition, g, -this.bearingInRadians), s.aV(this._cameraPosition, this._cameraPosition, [0, 0, 1]), s.bA(this._cameraPosition, this._cameraPosition, g, -this.center.lat * Math.PI / 180), s.bB(this._cameraPosition, this._cameraPosition, g, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e);
            const w = s.b8(this._globeViewProjMatrixNoCorrectionInverted);
            s.O(w, w, [1, 1, -1]), this._cachedFrustum = Da.fromInvProjectionMatrix(w, 1, 0, this._cachedClippingPlane, !0)
          }
          calculateFogMatrix(e) {
            s.w("calculateFogMatrix is not supported on globe projection.");
            const a = s.bd();
            return s.am(a), a
          }
          getVisibleUnwrappedCoordinates(e) {
            return [new s.b5(0, e)]
          }
          getCameraFrustum() {
            return this._cachedFrustum
          }
          getClippingPlane() {
            return this._cachedClippingPlane
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider
          }
          recalculateZoomAndCenter(e) {
            e && s.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0)
          }
          maxPitchScaleFactor() {
            return 1
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat()
          }
          lngLatToCameraDepth(e, a) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const o = ma(e);
            s.aU(o, o, 1 + a / s.bx);
            const u = s.by();
            return s.aA(u, [o[0], o[1], o[2], 1], this._globeViewProjMatrixNoCorrection), u[2] / u[3]
          }
          populateCache(e) {}
          getBounds() {
            const e = .5 * this.width,
              a = .5 * this.height,
              o = [new s.P(0, 0), new s.P(e, 0), new s.P(this.width, 0), new s.P(this.width, a), new s.P(this.width, this.height), new s.P(e, this.height), new s.P(0, this.height), new s.P(0, a)],
              u = [];
            for (const O of o) u.push(this.unprojectScreenPoint(O));
            let p = 0,
              g = 0,
              w = 0,
              I = 0;
            const A = this.center;
            for (const O of u) {
              const R = s.bD(A.lng, O.lng),
                H = s.bD(A.lat, O.lat);
              R < g && (g = R), R > p && (p = R), H < I && (I = H), H > w && (w = H)
            }
            const L = [A.lng + g, A.lat + I, A.lng + p, A.lat + w];
            return this.isSurfacePointOnScreen([0, 1, 0]) && (L[3] = 90, L[0] = -180, L[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (L[1] = -90, L[0] = -180, L[2] = 180), new Ut(L)
          }
          calculateCenterFromCameraLngLatAlt(e, a, o, u) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, a, o, u)
          }
          setLocationAtPoint(e, a) {
            const o = ma(this.unprojectScreenPoint(a)),
              u = ma(e),
              p = s.bs();
            s.bE(p);
            const g = s.bs();
            s.bB(g, o, p, -this.center.lng * Math.PI / 180), s.bA(g, g, p, this.center.lat * Math.PI / 180);
            const w = u[0] * u[0] + u[2] * u[2],
              I = g[0] * g[0];
            if (w < I) return;
            const A = Math.sqrt(w - I),
              L = -A,
              O = s.bF(u[0], u[2], g[0], A),
              R = s.bF(u[0], u[2], g[0], L),
              H = s.bs();
            s.bB(H, u, p, -O);
            const $ = s.bF(H[1], H[2], g[1], g[2]),
              ce = s.bs();
            s.bB(ce, u, p, -R);
            const ue = s.bF(ce[1], ce[2], g[1], g[2]),
              de = .5 * Math.PI,
              Ce = $ >= -de && $ <= de,
              Be = ue >= -de && ue <= de;
            let Ie, Oe;
            if (Ce && Be) {
              const vt = this.center.lng * Math.PI / 180,
                ft = this.center.lat * Math.PI / 180;
              s.bG(O, vt) + s.bG($, ft) < s.bG(R, vt) + s.bG(ue, ft) ? (Ie = O, Oe = $) : (Ie = R, Oe = ue)
            } else if (Ce) Ie = O, Oe = $;
            else {
              if (!Be) return;
              Ie = R, Oe = ue
            }
            const He = Ie / Math.PI * 180,
              Le = Oe / Math.PI * 180,
              $e = this.center.lat;
            this.setCenter(new s.U(He, s.ai(Le, -90, 90))), this.setZoom(this.zoom + Ki($e, this.center.lat))
          }
          locationToScreenPoint(e, a) {
            const o = ma(e);
            if (a) {
              const u = a.getElevationForLngLatZoom(e, this._helper._tileZoom);
              s.aU(o, o, 1 + u / s.bx)
            }
            return this._projectSurfacePointToScreen(o)
          }
          _projectSurfacePointToScreen(e) {
            const a = s.by();
            return s.aA(a, [...e, 1], this._globeViewProjMatrixNoCorrection), a[0] /= a[3], a[1] /= a[3], new s.P((.5 * a[0] + .5) * this.width, (.5 * -a[1] + .5) * this.height)
          }
          screenPointToMercatorCoordinate(e, a) {
            if (a) {
              const o = a.pointCoordinate(e);
              if (o) return o
            }
            return s.a5.fromLngLat(this.unprojectScreenPoint(e))
          }
          screenPointToLocation(e, a) {
            var o;
            return (o = this.screenPointToMercatorCoordinate(e, a)) === null || o === void 0 ? void 0 : o.toLngLat()
          }
          isPointOnMapSurface(e, a) {
            const o = this._cameraPosition,
              u = this.getRayDirectionFromPixel(e);
            return !!this.rayPlanetIntersection(o, u)
          }
          getRayDirectionFromPixel(e) {
            const a = s.by();
            a[0] = e.x / this.width * 2 - 1, a[1] = -1 * (e.y / this.height * 2 - 1), a[2] = 1, a[3] = 1, s.aA(a, a, this._globeViewProjMatrixNoCorrectionInverted), a[0] /= a[3], a[1] /= a[3], a[2] /= a[3];
            const o = s.bs();
            o[0] = a[0] - this._cameraPosition[0], o[1] = a[1] - this._cameraPosition[1], o[2] = a[2] - this._cameraPosition[2];
            const u = s.bs();
            return s.aY(u, o), u
          }
          isSurfacePointVisible(e) {
            const a = this._cachedClippingPlane;
            return a[0] * e[0] + a[1] * e[1] + a[2] * e[2] + a[3] >= 0
          }
          isSurfacePointOnScreen(e) {
            if (!this.isSurfacePointVisible(e)) return !1;
            const a = s.by();
            return s.aA(a, [...e, 1], this._globeViewProjMatrixNoCorrection), a[0] /= a[3], a[1] /= a[3], a[2] /= a[3], a[0] > -1 && a[0] < 1 && a[1] > -1 && a[1] < 1 && a[2] > -1 && a[2] < 1
          }
          rayPlanetIntersection(e, a) {
            const o = s.a_(e, a),
              u = s.bs(),
              p = s.bs();
            s.aU(p, a, o), s.aX(u, e, p);
            const g = 1 - s.a_(u, u);
            if (g < 0) return null;
            const w = s.a_(e, e) - 1,
              I = -o + (o < 0 ? 1 : -1) * Math.sqrt(g),
              A = w / I,
              L = I;
            return {
              tMin: Math.min(A, L),
              tMax: Math.max(A, L)
            }
          }
          unprojectScreenPoint(e) {
            const a = this._cameraPosition,
              o = this.getRayDirectionFromPixel(e),
              u = this.rayPlanetIntersection(a, o);
            if (u) {
              const L = s.bs();
              s.aV(L, a, [o[0] * u.tMin, o[1] * u.tMin, o[2] * u.tMin]);
              const O = s.bs();
              return s.aY(O, L), Bs(O)
            }
            const p = this._cachedClippingPlane,
              g = p[0] * o[0] + p[1] * o[1] + p[2] * o[2],
              w = -s.b4(p, a) / g,
              I = s.bs();
            if (w > 0) s.aV(I, a, [o[0] * w, o[1] * w, o[2] * w]);
            else {
              const L = s.bs();
              s.aV(L, a, [2 * o[0], 2 * o[1], 2 * o[2]]);
              const O = s.b4(this._cachedClippingPlane, L);
              s.aX(I, L, [this._cachedClippingPlane[0] * O, this._cachedClippingPlane[1] * O, this._cachedClippingPlane[2] * O])
            }
            const A = (function(L) {
              const O = s.bs();
              return O[0] = L[0] * -L[3], O[1] = L[1] * -L[3], O[2] = L[2] * -L[3], {
                center: O,
                radius: Math.sqrt(1 - L[3] * L[3])
              }
            })(p);
            return Bs((function(L, O, R) {
              const H = s.bs();
              s.aX(H, R, L);
              const $ = s.bs();
              return s.bt($, L, H, O / s.b2(H)), $
            })(A.center, A.radius, I))
          }
          getMatrixForModel(e, a) {
            const o = s.U.convert(e),
              u = 1 / s.bx,
              p = s.bc();
            return s.bC(p, p, o.lng / 180 * Math.PI), s.ba(p, p, -o.lat / 180 * Math.PI), s.N(p, p, [0, 0, 1 + a / s.bx]), s.ba(p, p, .5 * Math.PI), s.O(p, p, [u, u, u]), p
          }
          getProjectionDataForCustomLayer(e = !0) {
            const a = this.getProjectionData({
              overscaledTileID: new s.a0(0, 0, 0, 0, 0),
              applyGlobeMatrix: e
            });
            return a.tileMercatorCoords = [0, 0, 1, 1], a
          }
          getFastPathSimpleProjectionMatrix(e) {}
        }
        class Ml {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, a, o) {
            return this._helper.interpolatePadding(e, a, o)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, a, o = !0) {
            this._helper.resize(e, a, o)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          setConstrain(e) {
            this._helper.setConstrain(e)
          }
          overrideNearFarZ(e, a) {
            this._helper.overrideNearFarZ(e, a)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          get constrain() {
            return this._helper.constrain
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          get isGlobeRendering() {
            return this._globeness > 0
          }
          setTransitionState(e, a) {
            this._globeness = e, this._globeLatitudeErrorCorrectionRadians = a, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame()
          }
          get currentTransform() {
            return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform
          }
          constructor(e) {
            this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this.defaultConstrain = (a, o) => this.currentTransform.defaultConstrain(a, o), this._helper = new Yi({
              calcMatrices: () => {
                this._calcMatrices()
              },
              constrain: (a, o) => this.defaultConstrain(a, o)
            }, e), this._globeness = 1, this._mercatorTransform = new Pa, this._verticalPerspectiveTransform = new Il
          }
          clone() {
            const e = new Ml;
            return e._globeness = this._globeness, e._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e.apply(this), e
          }
          apply(e) {
            this._helper.apply(e), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians)
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition
          }
          getProjectionData(e) {
            const a = this._mercatorTransform.getProjectionData(e),
              o = this._verticalPerspectiveTransform.getProjectionData(e);
            return {
              mainMatrix: this.isGlobeRendering ? o.mainMatrix : a.mainMatrix,
              clippingPlane: o.clippingPlane,
              tileMercatorCoords: o.tileMercatorCoords,
              projectionTransition: e.applyGlobeMatrix ? this._globeness : 0,
              fallbackMatrix: a.fallbackMatrix
            }
          }
          isLocationOccluded(e) {
            return this.currentTransform.isLocationOccluded(e)
          }
          transformLightDirection(e) {
            return this.currentTransform.transformLightDirection(e)
          }
          getPixelScale() {
            return s.bn(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness)
          }
          getCircleRadiusCorrection() {
            return s.bn(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness)
          }
          getPitchedTextCorrection(e, a, o) {
            const u = this._mercatorTransform.getPitchedTextCorrection(e, a, o),
              p = this._verticalPerspectiveTransform.getPitchedTextCorrection(e, a, o);
            return s.bn(u, p, this._globeness)
          }
          projectTileCoordinates(e, a, o, u) {
            return this.currentTransform.projectTileCoordinates(e, a, o, u)
          }
          _calcMatrices() {
            this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ)
          }
          calculateFogMatrix(e) {
            return this.currentTransform.calculateFogMatrix(e)
          }
          getVisibleUnwrappedCoordinates(e) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(e)
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum()
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane()
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider()
          }
          recalculateZoomAndCenter(e) {
            this._mercatorTransform.recalculateZoomAndCenter(e), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e)
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor()
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat()
          }
          lngLatToCameraDepth(e, a) {
            return this.currentTransform.lngLatToCameraDepth(e, a)
          }
          populateCache(e) {
            this._mercatorTransform.populateCache(e), this._verticalPerspectiveTransform.populateCache(e)
          }
          getBounds() {
            return this.currentTransform.getBounds()
          }
          calculateCenterFromCameraLngLatAlt(e, a, o, u) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, a, o, u)
          }
          setLocationAtPoint(e, a) {
            if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e, a), void this.apply(this._mercatorTransform);
            this._verticalPerspectiveTransform.setLocationAtPoint(e, a), this.apply(this._verticalPerspectiveTransform)
          }
          locationToScreenPoint(e, a) {
            return this.currentTransform.locationToScreenPoint(e, a)
          }
          screenPointToMercatorCoordinate(e, a) {
            return this.currentTransform.screenPointToMercatorCoordinate(e, a)
          }
          screenPointToLocation(e, a) {
            return this.currentTransform.screenPointToLocation(e, a)
          }
          isPointOnMapSurface(e, a) {
            return this.currentTransform.isPointOnMapSurface(e, a)
          }
          getRayDirectionFromPixel(e) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e)
          }
          getMatrixForModel(e, a) {
            return this.currentTransform.getMatrixForModel(e, a)
          }
          getProjectionDataForCustomLayer(e = !0) {
            const a = this._mercatorTransform.getProjectionDataForCustomLayer(e);
            if (!this.isGlobeRendering) return a;
            const o = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e);
            return o.fallbackMatrix = a.mainMatrix, o
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(e)
          }
        }
        class Vn {
          get useGlobeControls() {
            return !0
          }
          handlePanInertia(e, a) {
            const o = Pl(e, a);
            return Math.abs(o.lng - a.center.lng) > 180 && (o.lng = a.center.lng + 179.5 * Math.sign(o.lng - a.center.lng)), {
              easingCenter: o,
              easingOffset: new s.P(0, 0)
            }
          }
          handleMapControlsRollPitchBearingZoom(e, a) {
            const o = e.around,
              u = a.screenPointToLocation(o);
            e.bearingDelta && a.setBearing(a.bearing + e.bearingDelta), e.pitchDelta && a.setPitch(a.pitch + e.pitchDelta), e.rollDelta && a.setRoll(a.roll + e.rollDelta);
            const p = a.zoom;
            e.zoomDelta && a.setZoom(a.zoom + e.zoomDelta);
            const g = a.zoom - p;
            if (g === 0) return;
            const w = s.bD(a.center.lng, u.lng),
              I = w / (Math.abs(w / 180) + 1),
              A = s.bD(a.center.lat, u.lat),
              L = a.getRayDirectionFromPixel(o),
              O = a.cameraPosition,
              R = -1 * s.a_(O, L),
              H = s.bs();
            s.aV(H, O, [L[0] * R, L[1] * R, L[2] * R]);
            const $ = s.b0(H) - 1,
              ce = Math.exp(.5 * -Math.max($ - .3, 0)),
              ue = Nn(a.worldSize, a.center.lat) / Math.min(a.width, a.height),
              de = s.bq(ue, .9, .5, 1, .25),
              Ce = (1 - s.al(-g)) * Math.min(ce, de),
              Be = a.center.lat,
              Ie = a.zoom,
              Oe = new s.U(a.center.lng + I * Ce, s.ai(a.center.lat + A * Ce, -s.aj, s.aj));
            a.setLocationAtPoint(u, o);
            const He = a.center,
              Le = s.bq(Math.abs(w), 45, 85, 0, 1),
              $e = s.bq(ue, .75, .35, 0, 1),
              vt = Math.pow(Math.max(Le, $e), .25),
              ft = s.bD(He.lng, Oe.lng),
              gt = s.bD(He.lat, Oe.lat);
            a.setCenter(new s.U(He.lng + ft * vt, He.lat + gt * vt).wrap()), a.setZoom(Ie + Ki(Be, a.center.lat))
          }
          handleMapControlsPan(e, a, o) {
            if (!e.panDelta) return;
            const u = a.center.lat,
              p = a.zoom;
            a.setCenter(Pl(e.panDelta, a).wrap()), a.setZoom(p + Ki(u, a.center.lat))
          }
          cameraForBoxAndBearing(e, a, o, u, p) {
            const g = Ia(e, a, o, u, p),
              w = a.left / p.width * 2 - 1,
              I = (p.width - a.right) / p.width * 2 - 1,
              A = a.top / p.height * -2 + 1,
              L = (p.height - a.bottom) / p.height * -2 + 1,
              O = s.bD(o.getWest(), o.getEast()) < 0,
              R = O ? o.getEast() : o.getWest(),
              H = O ? o.getWest() : o.getEast(),
              $ = Math.max(o.getNorth(), o.getSouth()),
              ce = Math.min(o.getNorth(), o.getSouth()),
              ue = R + .5 * s.bD(R, H),
              de = $ + .5 * s.bD($, ce),
              Ce = p.clone();
            Ce.setCenter(g.center), Ce.setBearing(g.bearing), Ce.setPitch(0), Ce.setRoll(0), Ce.setZoom(g.zoom);
            const Be = Ce.modelViewProjectionMatrix,
              Ie = [ma(o.getNorthWest()), ma(o.getNorthEast()), ma(o.getSouthWest()), ma(o.getSouthEast()), ma(new s.U(H, de)), ma(new s.U(R, de)), ma(new s.U(ue, $)), ma(new s.U(ue, ce))],
              Oe = ma(g.center);
            let He = Number.POSITIVE_INFINITY;
            for (const Le of Ie) w < 0 && (He = Vn.getLesserNonNegativeNonNull(He, Vn.solveVectorScale(Le, Oe, Be, "x", w))), I > 0 && (He = Vn.getLesserNonNegativeNonNull(He, Vn.solveVectorScale(Le, Oe, Be, "x", I))), A > 0 && (He = Vn.getLesserNonNegativeNonNull(He, Vn.solveVectorScale(Le, Oe, Be, "y", A))), L < 0 && (He = Vn.getLesserNonNegativeNonNull(He, Vn.solveVectorScale(Le, Oe, Be, "y", L)));
            if (Number.isFinite(He) && He !== 0) return g.zoom = Ce.zoom + s.ao(He), g;
            ea()
          }
          handleJumpToCenterZoom(e, a) {
            const o = e.center.lat,
              u = e.constrain(a.center ? s.U.convert(a.center) : e.center, e.zoom).center;
            e.setCenter(u.wrap());
            const p = a.zoom !== void 0 ? +a.zoom : e.zoom + Ki(o, u.lat);
            e.zoom !== p && e.setZoom(p)
          }
          handleEaseTo(e, a) {
            const o = e.zoom,
              u = e.center,
              p = e.padding,
              g = {
                roll: e.roll,
                pitch: e.pitch,
                bearing: e.bearing
              },
              w = {
                roll: a.roll === void 0 ? e.roll : a.roll,
                pitch: a.pitch === void 0 ? e.pitch : a.pitch,
                bearing: a.bearing === void 0 ? e.bearing : a.bearing
              },
              I = a.zoom !== void 0,
              A = !e.isPaddingEqual(a.padding);
            let L = !1;
            const O = a.center ? s.U.convert(a.center) : u,
              R = e.constrain(O, o).center;
            fi(e, R);
            const H = e.clone();
            H.setCenter(R), H.setZoom(I ? +a.zoom : o + Ki(u.lat, O.lat)), H.setBearing(a.bearing);
            const $ = new s.P(s.ai(e.centerPoint.x + a.offsetAsPoint.x, 0, e.width), s.ai(e.centerPoint.y + a.offsetAsPoint.y, 0, e.height));
            H.setLocationAtPoint(R, $);
            const ce = (a.offset && a.offsetAsPoint.mag()) > 0 ? H.center : R,
              ue = I ? +a.zoom : o + Ki(u.lat, ce.lat),
              de = o + Ki(u.lat, 0),
              Ce = ue + Ki(ce.lat, 0),
              Be = s.bD(u.lng, ce.lng),
              Ie = s.bD(u.lat, ce.lat),
              Oe = s.al(Ce - de);
            return L = ue !== o, {
              easeFunc: He => {
                if (s.bh(g, w) || pa({
                    startEulerAngles: g,
                    endEulerAngles: w,
                    tr: e,
                    k: He,
                    useSlerp: g.roll != w.roll
                  }), A && e.interpolatePadding(p, a.padding, He), a.around) s.w("Easing around a point is not supported under globe projection."), e.setLocationAtPoint(a.around, a.aroundPoint);
                else {
                  const Le = Ce > de ? Math.min(2, Oe) : Math.max(.5, Oe),
                    $e = Math.pow(Le, 1 - He),
                    vt = Uo(u, Be, Ie, He * $e);
                  e.setCenter(vt.wrap())
                }
                if (L) {
                  const Le = s.F.number(de, Ce, He) + Ki(0, e.center.lat);
                  e.setZoom(Le)
                }
              },
              isZooming: L,
              elevationCenter: ce
            }
          }
          handleFlyTo(e, a) {
            const o = a.zoom !== void 0,
              u = e.center,
              p = e.zoom,
              g = e.padding,
              w = !e.isPaddingEqual(a.padding),
              I = e.constrain(s.U.convert(a.center || a.locationAtOffset), p).center,
              A = o ? +a.zoom : e.zoom + Ki(e.center.lat, I.lat),
              L = e.clone();
            L.setCenter(I), L.setZoom(A), L.setBearing(a.bearing);
            const O = new s.P(s.ai(e.centerPoint.x + a.offsetAsPoint.x, 0, e.width), s.ai(e.centerPoint.y + a.offsetAsPoint.y, 0, e.height));
            L.setLocationAtPoint(I, O);
            const R = L.center;
            fi(e, R);
            const H = (function(Ie, Oe, He) {
                const Le = ma(Oe),
                  $e = ma(He),
                  vt = s.a_(Le, $e),
                  ft = Math.acos(vt),
                  gt = Ma(Ie);
                return ft / (2 * Math.PI) * gt
              })(e, u, R),
              $ = p + Ki(u.lat, 0),
              ce = A + Ki(R.lat, 0),
              ue = s.al(ce - $);
            let de;
            if (typeof a.minZoom == "number") {
              const Ie = +a.minZoom + Ki(R.lat, 0),
                Oe = Math.min(Ie, $, ce) + Ki(0, R.lat),
                He = e.constrain(R, Oe).zoom + Ki(R.lat, 0);
              de = s.al(He - $)
            }
            const Ce = s.bD(u.lng, R.lng),
              Be = s.bD(u.lat, R.lat);
            return {
              easeFunc: (Ie, Oe, He, Le) => {
                const $e = Uo(u, Ce, Be, He);
                w && e.interpolatePadding(g, a.padding, Ie);
                const vt = Ie === 1 ? R : $e;
                e.setCenter(vt.wrap());
                const ft = $ + s.ao(Oe);
                e.setZoom(Ie === 1 ? A : ft + Ki(0, vt.lat))
              },
              scaleOfZoom: ue,
              targetCenter: R,
              scaleOfMinZoom: de,
              pixelPathLength: H
            }
          }
          static solveVectorScale(e, a, o, u, p) {
            const g = u === "x" ? [o[0], o[4], o[8], o[12]] : [o[1], o[5], o[9], o[13]],
              w = [o[3], o[7], o[11], o[15]],
              I = e[0] * g[0] + e[1] * g[1] + e[2] * g[2],
              A = e[0] * w[0] + e[1] * w[1] + e[2] * w[2],
              L = a[0] * g[0] + a[1] * g[1] + a[2] * g[2],
              O = a[0] * w[0] + a[1] * w[1] + a[2] * w[2];
            return L + p * A === I + p * O || w[3] * (I - L) + g[3] * (O - A) + I * O == L * A ? null : (L + g[3] - p * O - p * w[3]) / (L - I - p * O + p * A)
          }
          static getLesserNonNegativeNonNull(e, a) {
            return a !== null && a >= 0 && a < e ? a : e
          }
        }
        class Zo {
          constructor(e) {
            this._globe = e, this._mercatorCameraHelper = new Na, this._verticalPerspectiveCameraHelper = new Vn
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering
          }
          get currentHelper() {
            return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper
          }
          handlePanInertia(e, a) {
            return this.currentHelper.handlePanInertia(e, a)
          }
          handleMapControlsRollPitchBearingZoom(e, a) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(e, a)
          }
          handleMapControlsPan(e, a, o) {
            this.currentHelper.handleMapControlsPan(e, a, o)
          }
          cameraForBoxAndBearing(e, a, o, u, p) {
            return this.currentHelper.cameraForBoxAndBearing(e, a, o, u, p)
          }
          handleJumpToCenterZoom(e, a) {
            this.currentHelper.handleJumpToCenterZoom(e, a)
          }
          handleEaseTo(e, a) {
            return this.currentHelper.handleEaseTo(e, a)
          }
          handleFlyTo(e, a) {
            return this.currentHelper.handleFlyTo(e, a)
          }
        }
        const xo = (d, e) => s.z(d, e && e.filter((a => a.identifier !== "source.canvas"))),
          Cl = s.bH();
        class Go extends s.E {
          constructor(e, a = {}) {
            var o, u;
            super(), this._rtlPluginLoaded = () => {
              for (const g in this.tileManagers) {
                const w = this.tileManagers[g].getSource().type;
                w !== "vector" && w !== "geojson" || this.tileManagers[g].reload()
              }
            }, this.map = e, this.dispatcher = new Dt(ht(), e._getMapId()), this.dispatcher.registerMessageHandler("GG", ((g, w) => this.getGlyphs(g, w))), this.dispatcher.registerMessageHandler("GI", ((g, w) => this.getImages(g, w))), this.dispatcher.registerMessageHandler("GDA", ((g, w) => this.getDashes(g, w))), this.imageManager = new Ee, this.imageManager.setEventedParent(this);
            const p = ((o = e._container) === null || o === void 0 ? void 0 : o.lang) || typeof document < "u" && ((u = document.documentElement) === null || u === void 0 ? void 0 : u.lang) || void 0;
            this.glyphManager = new _t(e._requestManager, a.localIdeographFontFamily, p), this.lineAtlas = new st(256, 512), this.crossTileSymbolIndex = new Cr, this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.tileManagers = {}, this.zoomHistory = new s.bI, this._loaded = !1, this._availableImages = [], this._globalState = {}, this._resetUpdates(), this.dispatcher.broadcast("SR", s.bJ()), U().on(mr, this._rtlPluginLoaded), this.on("data", (g => {
              if (g.dataType !== "source" || g.sourceDataType !== "metadata") return;
              const w = this.tileManagers[g.sourceId];
              if (!w) return;
              const I = w.getSource();
              if (I && I.vectorLayerIds)
                for (const A in this._layers) {
                  const L = this._layers[A];
                  L.source === I.id && this._validateLayer(L)
                }
            }))
          }
          setGlobalStateProperty(e, a) {
            var o, u, p;
            this._checkLoaded();
            const g = a === null ? (p = (u = (o = this.stylesheet.state) === null || o === void 0 ? void 0 : o[e]) === null || u === void 0 ? void 0 : u.default) !== null && p !== void 0 ? p : null : a;
            if (s.bK(g, this._globalState[e])) return this;
            this._globalState[e] = g, this._applyGlobalStateChanges([e])
          }
          getGlobalState() {
            return this._globalState
          }
          setGlobalState(e) {
            this._checkLoaded();
            const a = [];
            for (const o in e) !s.bK(this._globalState[o], e[o].default) && (a.push(o), this._globalState[o] = e[o].default);
            this._applyGlobalStateChanges(a)
          }
          _applyGlobalStateChanges(e) {
            if (e.length === 0) return;
            const a = new Set,
              o = {};
            for (const u of e) {
              o[u] = this._globalState[u];
              for (const p in this._layers) {
                const g = this._layers[p],
                  w = g.getLayoutAffectingGlobalStateRefs(),
                  I = g.getPaintAffectingGlobalStateRefs();
                if (w.has(u) && a.add(g.source), I.has(u))
                  for (const {
                      name: A,
                      value: L
                    }
                    of I.get(u)) this._updatePaintProperty(g, A, L)
              }
            }
            this.dispatcher.broadcast("UGS", o);
            for (const u in this.tileManagers) a.has(u) && (this._reloadSource(u), this._changed = !0)
          }
          loadURL(e, a = {}, o) {
            this.fire(new s.l("dataloading", {
              dataType: "style"
            })), a.validate = typeof a.validate != "boolean" || a.validate;
            const u = this.map._requestManager.transformRequest(e, "Style");
            this._loadStyleRequest = new AbortController;
            const p = this._loadStyleRequest;
            s.j(u, this._loadStyleRequest).then((g => {
              this._loadStyleRequest = null, this._load(g.data, a, o)
            })).catch((g => {
              this._loadStyleRequest = null, g && !p.signal.aborted && this.fire(new s.k(g))
            }))
          }
          loadJSON(e, a = {}, o) {
            this.fire(new s.l("dataloading", {
              dataType: "style"
            })), this._frameRequest = new AbortController, re.frameAsync(this._frameRequest).then((() => {
              this._frameRequest = null, a.validate = a.validate !== !1, this._load(e, a, o)
            })).catch((() => {}))
          }
          loadEmpty() {
            this.fire(new s.l("dataloading", {
              dataType: "style"
            })), this._load(Cl, {
              validate: !1
            })
          }
          _load(e, a, o) {
            var u, p;
            let g = a.transformStyle ? a.transformStyle(o, e) : e;
            if (!a.validate || !xo(this, s.B(g))) {
              g = Object.assign({}, g), this._loaded = !0, this.stylesheet = g;
              for (const w in g.sources) this.addSource(w, g.sources[w], {
                validate: !1
              });
              g.sprite ? this._loadSprite(g.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(g.glyphs), this._createLayers(), this.light = new nt(this.stylesheet.light), this._setProjectionInternal(((u = this.stylesheet.projection) === null || u === void 0 ? void 0 : u.type) || "mercator"), this.sky = new ut(this.stylesheet.sky), this.map.setTerrain((p = this.stylesheet.terrain) !== null && p !== void 0 ? p : null), this.fire(new s.l("data", {
                dataType: "style"
              })), this.fire(new s.l("style.load"))
            }
          }
          _createLayers() {
            var e, a, o;
            const u = s.bL(this.stylesheet.layers);
            this.setGlobalState((e = this.stylesheet.state) !== null && e !== void 0 ? e : null), this.dispatcher.broadcast("SL", u), this._order = u.map((p => p.id)), this._layers = {}, this._serializedLayers = null;
            for (const p of u) {
              const g = s.bM(p, this._globalState);
              if (g.setEventedParent(this, {
                  layer: {
                    id: p.id
                  }
                }), this._layers[p.id] = g, s.bN(g) && this.tileManagers[g.source]) {
                const w = (o = (a = p.paint) === null || a === void 0 ? void 0 : a["raster-fade-duration"]) !== null && o !== void 0 ? o : g.paint.get("raster-fade-duration");
                this.tileManagers[g.source].setRasterFadeDuration(w)
              }
            }
          }
          _loadSprite(e, a = !1, o = void 0) {
            let u;
            this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController, (function(p, g, w, I) {
              return s._(this, void 0, void 0, (function*() {
                const A = Pe(p),
                  L = w > 1 ? "@2x" : "",
                  O = {},
                  R = {};
                for (const {
                    id: H,
                    url: $
                  }
                  of A) {
                  const ce = g.transformRequest(Ae($, L, ".json"), "SpriteJSON");
                  O[H] = s.j(ce, I);
                  const ue = g.transformRequest(Ae($, L, ".png"), "SpriteImage");
                  R[H] = ze.getImage(ue, I)
                }
                return yield Promise.all([...Object.values(O), ...Object.values(R)]), (function(H, $) {
                  return s._(this, void 0, void 0, (function*() {
                    const ce = {};
                    for (const ue in H) {
                      ce[ue] = {};
                      const de = re.getImageCanvasContext((yield $[ue]).data),
                        Ce = (yield H[ue]).data;
                      for (const Be in Ce) {
                        const {
                          width: Ie,
                          height: Oe,
                          x: He,
                          y: Le,
                          sdf: $e,
                          pixelRatio: vt,
                          stretchX: ft,
                          stretchY: gt,
                          content: xt,
                          textFitWidth: lr,
                          textFitHeight: cr
                        } = Ce[Be];
                        ce[ue][Be] = {
                          data: null,
                          pixelRatio: vt,
                          sdf: $e,
                          stretchX: ft,
                          stretchY: gt,
                          content: xt,
                          textFitWidth: lr,
                          textFitHeight: cr,
                          spriteData: {
                            width: Ie,
                            height: Oe,
                            x: He,
                            y: Le,
                            context: de
                          }
                        }
                      }
                    }
                    return ce
                  }))
                })(O, R)
              }))
            })(e, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((p => {
              if (this._spriteRequest = null, p)
                for (const g in p) {
                  this._spritesImagesIds[g] = [];
                  const w = this._spritesImagesIds[g] ? this._spritesImagesIds[g].filter((I => !(I in p))) : [];
                  for (const I of w) this.imageManager.removeImage(I), this._changedImages[I] = !0;
                  for (const I in p[g]) {
                    const A = g === "default" ? I : `${g}:${I}`;
                    this._spritesImagesIds[g].push(A), A in this.imageManager.images ? this.imageManager.updateImage(A, p[g][I], !1) : this.imageManager.addImage(A, p[g][I]), a && (this._changedImages[A] = !0)
                  }
                }
            })).catch((p => {
              this._spriteRequest = null, u = p, this.fire(new s.k(u))
            })).finally((() => {
              this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), a && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", {
                dataType: "style"
              })), o && o(u)
            }))
          }
          _unloadSprite() {
            for (const e of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e), this._changedImages[e] = !0;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", {
              dataType: "style"
            }))
          }
          _validateLayer(e) {
            const a = this.tileManagers[e.source];
            if (!a) return;
            const o = e.sourceLayer;
            if (!o) return;
            const u = a.getSource();
            (u.type === "geojson" || u.vectorLayerIds && u.vectorLayerIds.indexOf(o) === -1) && this.fire(new s.k(new Error(`Source layer "${o}" does not exist on source "${u.id}" as specified by style layer "${e.id}".`)))
          }
          loaded() {
            if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
            for (const e in this.tileManagers)
              if (!this.tileManagers[e].loaded()) return !1;
            return !!this.imageManager.isLoaded()
          }
          _serializeByIds(e, a = !1) {
            const o = this._serializedAllLayers();
            if (!e || e.length === 0) return Object.values(a ? s.bO(o) : o);
            const u = [];
            for (const p of e)
              if (o[p]) {
                const g = a ? s.bO(o[p]) : o[p];
                u.push(g)
              } return u
          }
          _serializedAllLayers() {
            let e = this._serializedLayers;
            if (e) return e;
            e = this._serializedLayers = {};
            const a = Object.keys(this._layers);
            for (const o of a) {
              const u = this._layers[o];
              u.type !== "custom" && (e[o] = u.serialize())
            }
            return e
          }
          hasTransitions() {
            var e, a, o;
            if (!((e = this.light) === null || e === void 0) && e.hasTransition() || !((a = this.sky) === null || a === void 0) && a.hasTransition() || !((o = this.projection) === null || o === void 0) && o.hasTransition()) return !0;
            for (const u in this.tileManagers)
              if (this.tileManagers[u].hasTransition()) return !0;
            for (const u in this._layers)
              if (this._layers[u].hasTransition()) return !0;
            return !1
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.")
          }
          update(e) {
            if (!this._loaded) return;
            const a = this._changed;
            if (a) {
              const u = Object.keys(this._updatedLayers),
                p = Object.keys(this._removedLayers);
              (u.length || p.length) && this._updateWorkerLayers(u, p);
              for (const g in this._updatedSources) {
                const w = this._updatedSources[g];
                if (w === "reload") this._reloadSource(g);
                else {
                  if (w !== "clear") throw new Error(`Invalid action ${w}`);
                  this._clearSource(g)
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const g in this._updatedPaintProps) this._layers[g].updateTransitions(e);
              this.light.updateTransitions(e), this.sky.updateTransitions(e), this._resetUpdates()
            }
            const o = {};
            for (const u in this.tileManagers) {
              const p = this.tileManagers[u];
              o[u] = p.used, p.used = !1
            }
            for (const u of this._order) {
              const p = this._layers[u];
              p.recalculate(e, this._availableImages), !p.isHidden(e.zoom) && p.source && (this.tileManagers[p.source].used = !0)
            }
            for (const u in o) {
              const p = this.tileManagers[u];
              !!o[u] != !!p.used && p.fire(new s.l("data", {
                sourceDataType: "visibility",
                dataType: "source",
                sourceId: u
              }))
            }
            this.light.recalculate(e), this.sky.recalculate(e), this.projection.recalculate(e), this.z = e.zoom, a && this.fire(new s.l("data", {
              dataType: "style"
            }))
          }
          _updateTilesForChangedImages() {
            const e = Object.keys(this._changedImages);
            if (e.length) {
              for (const a in this.tileManagers) this.tileManagers[a].reloadTilesForDependencies(["icons", "patterns"], e);
              this._changedImages = {}
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const e in this.tileManagers) this.tileManagers[e].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = !1
            }
          }
          _updateWorkerLayers(e, a) {
            this.dispatcher.broadcast("UL", {
              layers: this._serializeByIds(e, !1),
              removedIds: a
            })
          }
          _resetUpdates() {
            this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1
          }
          setState(e, a = {}) {
            var o;
            this._checkLoaded();
            const u = this.serialize();
            if (e = a.transformStyle ? a.transformStyle(u, e) : e, ((o = a.validate) === null || o === void 0 || o) && xo(this, s.B(e))) return !1;
            (e = s.bO(e)).layers = s.bL(e.layers);
            const p = s.bP(u, e),
              g = this._getOperationsToPerform(p);
            if (g.unimplemented.length > 0) throw new Error(`Unimplemented: ${g.unimplemented.join(", ")}.`);
            if (g.operations.length === 0) return !1;
            for (const w of g.operations) w();
            return this.stylesheet = e, this._serializedLayers = null, !0
          }
          _getOperationsToPerform(e) {
            const a = [],
              o = [];
            for (const u of e) switch (u.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
              case "setRoll":
                continue;
              case "addLayer":
                a.push((() => this.addLayer.apply(this, u.args)));
                break;
              case "removeLayer":
                a.push((() => this.removeLayer.apply(this, u.args)));
                break;
              case "setPaintProperty":
                a.push((() => this.setPaintProperty.apply(this, u.args)));
                break;
              case "setLayoutProperty":
                a.push((() => this.setLayoutProperty.apply(this, u.args)));
                break;
              case "setFilter":
                a.push((() => this.setFilter.apply(this, u.args)));
                break;
              case "addSource":
                a.push((() => this.addSource.apply(this, u.args)));
                break;
              case "removeSource":
                a.push((() => this.removeSource.apply(this, u.args)));
                break;
              case "setLayerZoomRange":
                a.push((() => this.setLayerZoomRange.apply(this, u.args)));
                break;
              case "setLight":
                a.push((() => this.setLight.apply(this, u.args)));
                break;
              case "setGeoJSONSourceData":
                a.push((() => this.setGeoJSONSourceData.apply(this, u.args)));
                break;
              case "setGlyphs":
                a.push((() => this.setGlyphs.apply(this, u.args)));
                break;
              case "setSprite":
                a.push((() => this.setSprite.apply(this, u.args)));
                break;
              case "setTerrain":
                a.push((() => this.map.setTerrain.apply(this, u.args)));
                break;
              case "setSky":
                a.push((() => this.setSky.apply(this, u.args)));
                break;
              case "setProjection":
                this.setProjection.apply(this, u.args);
                break;
              case "setGlobalState":
                a.push((() => this.setGlobalState.apply(this, u.args)));
                break;
              case "setTransition":
                a.push((() => {}));
                break;
              default:
                o.push(u.command)
            }
            return {
              operations: a,
              unimplemented: o
            }
          }
          addImage(e, a) {
            if (this.getImage(e)) return this.fire(new s.k(new Error(`An image named "${e}" already exists.`)));
            this.imageManager.addImage(e, a), this._afterImageUpdated(e)
          }
          updateImage(e, a) {
            this.imageManager.updateImage(e, a)
          }
          getImage(e) {
            return this.imageManager.getImage(e)
          }
          removeImage(e) {
            if (!this.getImage(e)) return this.fire(new s.k(new Error(`An image named "${e}" does not exist.`)));
            this.imageManager.removeImage(e), this._afterImageUpdated(e)
          }
          _afterImageUpdated(e) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[e] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", {
              dataType: "style"
            }))
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages()
          }
          addSource(e, a, o = {}) {
            if (this._checkLoaded(), this.tileManagers[e] !== void 0) throw new Error(`Source "${e}" already exists.`);
            if (!a.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(a).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(a.type) >= 0 && this._validate(s.B.source, `sources.${e}`, a, null, o)) return;
            this.map && this.map._collectResourceTiming && (a.collectResourceTiming = !0);
            const u = this.tileManagers[e] = new Lt(e, a, this.dispatcher);
            u.style = this, u.setEventedParent(this, (() => ({
              isSourceLoaded: u.loaded(),
              source: u.serialize(),
              sourceId: e
            }))), u.onAdd(this.map), this._changed = !0
          }
          removeSource(e) {
            if (this._checkLoaded(), this.tileManagers[e] === void 0) throw new Error("There is no source with this ID");
            for (const o in this._layers)
              if (this._layers[o].source === e) return this.fire(new s.k(new Error(`Source "${e}" cannot be removed while layer "${o}" is using it.`)));
            const a = this.tileManagers[e];
            delete this.tileManagers[e], delete this._updatedSources[e], a.fire(new s.l("data", {
              sourceDataType: "metadata",
              dataType: "source",
              sourceId: e
            })), a.setEventedParent(null), a.onRemove(this.map), this._changed = !0
          }
          setGeoJSONSourceData(e, a) {
            if (this._checkLoaded(), this.tileManagers[e] === void 0) throw new Error(`There is no source with this ID=${e}`);
            const o = this.tileManagers[e].getSource();
            if (o.type !== "geojson") throw new Error(`geojsonSource.type is ${o.type}, which is !== 'geojson`);
            o.setData(a), this._changed = !0
          }
          getSource(e) {
            return this.tileManagers[e] && this.tileManagers[e].getSource()
          }
          addLayer(e, a, o = {}) {
            this._checkLoaded();
            const u = e.id;
            if (this.getLayer(u)) return void this.fire(new s.k(new Error(`Layer "${u}" already exists on this map.`)));
            let p;
            if (e.type === "custom") {
              if (xo(this, s.bQ(e))) return;
              p = s.bM(e, this._globalState)
            } else {
              if ("source" in e && typeof e.source == "object" && (this.addSource(u, e.source), e = s.bO(e), e = s.e(e, {
                  source: u
                })), this._validate(s.B.layer, `layers.${u}`, e, {
                  arrayIndex: -1
                }, o)) return;
              p = s.bM(e, this._globalState), this._validateLayer(p), p.setEventedParent(this, {
                layer: {
                  id: u
                }
              })
            }
            const g = a ? this._order.indexOf(a) : this._order.length;
            if (a && g === -1) this.fire(new s.k(new Error(`Cannot add layer "${u}" before non-existing layer "${a}".`)));
            else {
              if (this._order.splice(g, 0, u), this._layerOrderChanged = !0, this._layers[u] = p, this._removedLayers[u] && p.source && p.type !== "custom") {
                const w = this._removedLayers[u];
                delete this._removedLayers[u], w.type !== p.type ? this._updatedSources[p.source] = "clear" : (this._updatedSources[p.source] = "reload", this.tileManagers[p.source].pause())
              }
              this._updateLayer(p), p.onAdd && p.onAdd(this.map)
            }
          }
          moveLayer(e, a) {
            if (this._checkLoaded(), this._changed = !0, !this._layers[e]) return void this.fire(new s.k(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
            if (e === a) return;
            const o = this._order.indexOf(e);
            this._order.splice(o, 1);
            const u = a ? this._order.indexOf(a) : this._order.length;
            a && u === -1 ? this.fire(new s.k(new Error(`Cannot move layer "${e}" before non-existing layer "${a}".`))) : (this._order.splice(u, 0, e), this._layerOrderChanged = !0)
          }
          removeLayer(e) {
            this._checkLoaded();
            const a = this._layers[e];
            if (!a) return void this.fire(new s.k(new Error(`Cannot remove non-existing layer "${e}".`)));
            a.setEventedParent(null);
            const o = this._order.indexOf(e);
            this._order.splice(o, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e] = a, delete this._layers[e], this._serializedLayers && delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], a.onRemove && a.onRemove(this.map)
          }
          getLayer(e) {
            return this._layers[e]
          }
          getLayersOrder() {
            return [...this._order]
          }
          hasLayer(e) {
            return e in this._layers
          }
          setLayerZoomRange(e, a, o) {
            this._checkLoaded();
            const u = this.getLayer(e);
            u ? u.minzoom === a && u.maxzoom === o || (a != null && (u.minzoom = a), o != null && (u.maxzoom = o), this._updateLayer(u)) : this.fire(new s.k(new Error(`Cannot set the zoom range of non-existing layer "${e}".`)))
          }
          setFilter(e, a, o = {}) {
            this._checkLoaded();
            const u = this.getLayer(e);
            if (u) {
              if (!s.bK(u.filter, a)) return a == null ? (u.setFilter(void 0), void this._updateLayer(u)) : void(this._validate(s.B.filter, `layers.${u.id}.filter`, a, null, o) || (u.setFilter(s.bO(a)), this._updateLayer(u)))
            } else this.fire(new s.k(new Error(`Cannot filter non-existing layer "${e}".`)))
          }
          getFilter(e) {
            return s.bO(this.getLayer(e).filter)
          }
          setLayoutProperty(e, a, o, u = {}) {
            this._checkLoaded();
            const p = this.getLayer(e);
            p ? s.bK(p.getLayoutProperty(a), o) || (p.setLayoutProperty(a, o, u), this._updateLayer(p)) : this.fire(new s.k(new Error(`Cannot style non-existing layer "${e}".`)))
          }
          getLayoutProperty(e, a) {
            const o = this.getLayer(e);
            if (o) return o.getLayoutProperty(a);
            this.fire(new s.k(new Error(`Cannot get style of non-existing layer "${e}".`)))
          }
          setPaintProperty(e, a, o, u = {}) {
            this._checkLoaded();
            const p = this.getLayer(e);
            p ? s.bK(p.getPaintProperty(a), o) || this._updatePaintProperty(p, a, o, u) : this.fire(new s.k(new Error(`Cannot style non-existing layer "${e}".`)))
          }
          _updatePaintProperty(e, a, o, u = {}) {
            e.setPaintProperty(a, o, u) && this._updateLayer(e), s.bN(e) && a === "raster-fade-duration" && this.tileManagers[e.source].setRasterFadeDuration(o), this._changed = !0, this._updatedPaintProps[e.id] = !0, this._serializedLayers = null
          }
          getPaintProperty(e, a) {
            return this.getLayer(e).getPaintProperty(a)
          }
          setFeatureState(e, a) {
            this._checkLoaded();
            const o = e.source,
              u = e.sourceLayer,
              p = this.tileManagers[o];
            if (p === void 0) return void this.fire(new s.k(new Error(`The source '${o}' does not exist in the map's style.`)));
            const g = p.getSource().type;
            g === "geojson" && u ? this.fire(new s.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : g !== "vector" || u ? (e.id === void 0 && this.fire(new s.k(new Error("The feature id parameter must be provided."))), p.setFeatureState(u, e.id, a)) : this.fire(new s.k(new Error("The sourceLayer parameter must be provided for vector source types.")))
          }
          removeFeatureState(e, a) {
            this._checkLoaded();
            const o = e.source,
              u = this.tileManagers[o];
            if (u === void 0) return void this.fire(new s.k(new Error(`The source '${o}' does not exist in the map's style.`)));
            const p = u.getSource().type,
              g = p === "vector" ? e.sourceLayer : void 0;
            p !== "vector" || g ? a && typeof e.id != "string" && typeof e.id != "number" ? this.fire(new s.k(new Error("A feature id is required to remove its specific state property."))) : u.removeFeatureState(g, e.id, a) : this.fire(new s.k(new Error("The sourceLayer parameter must be provided for vector source types.")))
          }
          getFeatureState(e) {
            this._checkLoaded();
            const a = e.source,
              o = e.sourceLayer,
              u = this.tileManagers[a];
            if (u !== void 0) return u.getSource().type !== "vector" || o ? (e.id === void 0 && this.fire(new s.k(new Error("The feature id parameter must be provided."))), u.getFeatureState(o, e.id)) : void this.fire(new s.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new s.k(new Error(`The source '${a}' does not exist in the map's style.`)))
          }
          getTransition() {
            return s.e({
              duration: 300,
              delay: 0
            }, this.stylesheet && this.stylesheet.transition)
          }
          serialize() {
            if (!this._loaded) return;
            const e = s.bR(this.tileManagers, (p => p.serialize())),
              a = this._serializeByIds(this._order, !0),
              o = this.map.getTerrain() || void 0,
              u = this.stylesheet;
            return s.bS({
              version: u.version,
              name: u.name,
              metadata: u.metadata,
              light: u.light,
              sky: u.sky,
              center: u.center,
              zoom: u.zoom,
              bearing: u.bearing,
              pitch: u.pitch,
              sprite: u.sprite,
              glyphs: u.glyphs,
              transition: u.transition,
              projection: u.projection,
              sources: e,
              layers: a,
              terrain: o
            }, (p => p !== void 0))
          }
          _updateLayer(e) {
            this._updatedLayers[e.id] = !0, e.source && !this._updatedSources[e.source] && this.tileManagers[e.source].getSource().type !== "raster" && (this._updatedSources[e.source] = "reload", this.tileManagers[e.source].pause()), this._serializedLayers = null, this._changed = !0
          }
          _flattenAndSortRenderedFeatures(e) {
            const a = g => this._layers[g].type === "fill-extrusion",
              o = {},
              u = [];
            for (let g = this._order.length - 1; g >= 0; g--) {
              const w = this._order[g];
              if (a(w)) {
                o[w] = g;
                for (const I of e) {
                  const A = I[w];
                  if (A)
                    for (const L of A) u.push(L)
                }
              }
            }
            u.sort(((g, w) => w.intersectionZ - g.intersectionZ));
            const p = [];
            for (let g = this._order.length - 1; g >= 0; g--) {
              const w = this._order[g];
              if (a(w))
                for (let I = u.length - 1; I >= 0; I--) {
                  const A = u[I].feature;
                  if (o[A.layer.id] < g) break;
                  p.push(A), u.pop()
                } else
                  for (const I of e) {
                    const A = I[w];
                    if (A)
                      for (const L of A) p.push(L.feature)
                  }
            }
            return p
          }
          queryRenderedFeatures(e, a, o) {
            a && a.filter && this._validate(s.B.filter, "queryRenderedFeatures.filter", a.filter, null, a);
            const u = {};
            if (a && a.layers) {
              if (!(Array.isArray(a.layers) || a.layers instanceof Set)) return this.fire(new s.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
              for (const A of a.layers) {
                const L = this._layers[A];
                if (!L) return this.fire(new s.k(new Error(`The layer '${A}' does not exist in the map's style and cannot be queried for features.`))), [];
                u[L.source] = !0
              }
            }
            const p = [];
            a.availableImages = this._availableImages;
            const g = this._serializedAllLayers(),
              w = a.layers instanceof Set ? a.layers : Array.isArray(a.layers) ? new Set(a.layers) : null,
              I = Object.assign(Object.assign({}, a), {
                layers: w,
                globalState: this._globalState
              });
            for (const A in this.tileManagers) a.layers && !u[A] || p.push(jt(this.tileManagers[A], this._layers, g, e, I, o, this.map.terrain ? (L, O, R) => this.map.terrain.getElevation(L, O, R) : void 0));
            return this.placement && p.push((function(A, L, O, R, H, $, ce) {
              const ue = {},
                de = $.queryRenderedSymbols(R),
                Ce = [];
              for (const Be of Object.keys(de).map(Number)) Ce.push(ce[Be]);
              Ce.sort(nr);
              for (const Be of Ce) {
                const Ie = Be.featureIndex.lookupSymbolFeatures(de[Be.bucketInstanceId], L, Be.bucketIndex, Be.sourceLayerIndex, {
                  filterSpec: H.filter,
                  globalState: H.globalState
                }, H.layers, H.availableImages, A);
                for (const Oe in Ie) {
                  const He = ue[Oe] = ue[Oe] || [],
                    Le = Ie[Oe];
                  Le.sort((($e, vt) => {
                    const ft = Be.featureSortOrder;
                    if (ft) {
                      const gt = ft.indexOf($e.featureIndex);
                      return ft.indexOf(vt.featureIndex) - gt
                    }
                    return vt.featureIndex - $e.featureIndex
                  }));
                  for (const $e of Le) He.push($e)
                }
              }
              return (function(Be, Ie, Oe) {
                for (const He in Be)
                  for (const Le of Be[He]) St(Le, Oe[Ie[He].source]);
                return Be
              })(ue, A, O)
            })(this._layers, g, this.tileManagers, e, I, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(p)
          }
          querySourceFeatures(e, a) {
            a != null && a.filter && this._validate(s.B.filter, "querySourceFeatures.filter", a.filter, null, a);
            const o = this.tileManagers[e];
            return o ? (function(u, p) {
              const g = u.getRenderableIds().map((A => u.getTileByID(A))),
                w = [],
                I = {};
              for (let A = 0; A < g.length; A++) {
                const L = g[A],
                  O = L.tileID.canonical.key;
                I[O] || (I[O] = !0, L.querySourceFeatures(w, p))
              }
              return w
            })(o, a ? Object.assign(Object.assign({}, a), {
              globalState: this._globalState
            }) : {
              globalState: this._globalState
            }) : []
          }
          getLight() {
            return this.light.getLight()
          }
          setLight(e, a = {}) {
            this._checkLoaded();
            const o = this.light.getLight();
            let u = !1;
            for (const g in e)
              if (!s.bK(e[g], o[g])) {
                u = !0;
                break
              } if (!u) return;
            const p = {
              now: me(),
              transition: s.e({
                duration: 300,
                delay: 0
              }, this.stylesheet.transition)
            };
            this.light.setLight(e, a), this.light.updateTransitions(p)
          }
          getProjection() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.projection
          }
          setProjection(e) {
            if (this._checkLoaded(), this.projection) {
              if (this.projection.name === e.type) return;
              this.projection.destroy(), delete this.projection
            }
            this.stylesheet.projection = e, this._setProjectionInternal(e.type)
          }
          getSky() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.sky
          }
          setSky(e, a = {}) {
            this._checkLoaded();
            const o = this.getSky();
            let u = !1;
            if (!e && !o) return;
            if (e && !o) u = !0;
            else if (!e && o) u = !0;
            else
              for (const g in e)
                if (!s.bK(e[g], o[g])) {
                  u = !0;
                  break
                } if (!u) return;
            const p = {
              now: me(),
              transition: s.e({
                duration: 300,
                delay: 0
              }, this.stylesheet.transition)
            };
            this.stylesheet.sky = e, this.sky.setSky(e, a), this.sky.updateTransitions(p)
          }
          _setProjectionInternal(e) {
            const a = (function(o, u) {
              const p = {
                constrain: u
              };
              if (Array.isArray(o)) {
                const g = new fa({
                  type: o
                });
                return {
                  projection: g,
                  transform: new Ml(p),
                  cameraHelper: new Zo(g)
                }
              }
              switch (o) {
                case "mercator":
                  return {
                    projection: new zi, transform: new Pa(p), cameraHelper: new Na
                  };
                case "globe": {
                  const g = new fa({
                    type: ["interpolate", ["linear"],
                      ["zoom"], 11, "vertical-perspective", 12, "mercator"
                    ]
                  });
                  return {
                    projection: g,
                    transform: new Ml(p),
                    cameraHelper: new Zo(g)
                  }
                }
                case "vertical-perspective":
                  return {
                    projection: new qn, transform: new Il(p), cameraHelper: new Vn
                  };
                default:
                  return s.w(`Unknown projection name: ${o}. Falling back to mercator projection.`), {
                    projection: new zi,
                    transform: new Pa(p),
                    cameraHelper: new Na
                  }
              }
            })(e, this.map.transformConstrain);
            this.projection = a.projection, this.map.migrateProjection(a.transform, a.cameraHelper);
            for (const o in this.tileManagers) this.tileManagers[o].reload()
          }
          _validate(e, a, o, u, p = {}) {
            return (!p || p.validate !== !1) && xo(this, e.call(s.B, s.e({
              key: a,
              style: this.serialize(),
              value: o,
              styleSpec: s.t
            }, u)))
          }
          _remove(e = !0) {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), U().off(mr, this._rtlPluginLoaded);
            for (const a in this._layers) this._layers[a].setEventedParent(null);
            for (const a in this.tileManagers) {
              const o = this.tileManagers[a];
              o.setEventedParent(null), o.onRemove(this.map)
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), e && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e)
          }
          _clearSource(e) {
            this.tileManagers[e].clearTiles()
          }
          _reloadSource(e) {
            this.tileManagers[e].resume(), this.tileManagers[e].reload()
          }
          _updateSources(e) {
            for (const a in this.tileManagers) this.tileManagers[a].update(e, this.map.terrain)
          }
          _generateCollisionBoxes() {
            for (const e in this.tileManagers) this._reloadSource(e)
          }
          _updatePlacement(e, a, o, u, p = !1) {
            let g = !1,
              w = !1;
            const I = {};
            for (const A of this._order) {
              const L = this._layers[A];
              if (L.type !== "symbol") continue;
              if (!I[L.source]) {
                const R = this.tileManagers[L.source];
                I[L.source] = R.getRenderableIds(!0).map((H => R.getTileByID(H))).sort(((H, $) => $.tileID.overscaledZ - H.tileID.overscaledZ || (H.tileID.isLessThan($.tileID) ? -1 : 1)))
              }
              const O = this.crossTileSymbolIndex.addLayer(L, I[L.source], e.center.lng);
              g = g || O
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((p = p || this._layerOrderChanged || o === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(me(), e.zoom)) && (this.pauseablePlacement = new ca(e, this.map.terrain, this._order, p, a, o, u, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, I), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(me()), w = !0), g && this.pauseablePlacement.placement.setStale()), w || g)
              for (const A of this._order) {
                const L = this._layers[A];
                L.type === "symbol" && this.placement.updateLayerOpacities(L, I[L.source])
              }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(me())
          }
          _releaseSymbolFadeTiles() {
            for (const e in this.tileManagers) this.tileManagers[e].releaseSymbolFadeTiles()
          }
          getImages(e, a) {
            return s._(this, void 0, void 0, (function*() {
              const o = yield this.imageManager.getImages(a.icons);
              this._updateTilesForChangedImages();
              const u = this.tileManagers[a.source];
              return u && u.setDependencies(a.tileID.key, a.type, a.icons), o
            }))
          }
          getGlyphs(e, a) {
            return s._(this, void 0, void 0, (function*() {
              const o = yield this.glyphManager.getGlyphs(a.stacks), u = this.tileManagers[a.source];
              return u && u.setDependencies(a.tileID.key, a.type, [""]), o
            }))
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null
          }
          setGlyphs(e, a = {}) {
            this._checkLoaded(), e && this._validate(s.B.glyphs, "glyphs", e, null, a) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = e, this.glyphManager.entries = {}, this.glyphManager.setURL(e))
          }
          getDashes(e, a) {
            return s._(this, void 0, void 0, (function*() {
              const o = {};
              for (const [u, p] of Object.entries(a.dashes)) o[u] = this.lineAtlas.getDash(p.dasharray, p.round);
              return o
            }))
          }
          addSprite(e, a, o = {}, u) {
            this._checkLoaded();
            const p = [{
                id: e,
                url: a
              }],
              g = [...Pe(this.stylesheet.sprite), ...p];
            this._validate(s.B.sprite, "sprite", g, null, o) || (this.stylesheet.sprite = g, this._loadSprite(p, !0, u))
          }
          removeSprite(e) {
            this._checkLoaded();
            const a = Pe(this.stylesheet.sprite);
            if (a.find((o => o.id === e))) {
              if (this._spritesImagesIds[e])
                for (const o of this._spritesImagesIds[e]) this.imageManager.removeImage(o), this._changedImages[o] = !0;
              a.splice(a.findIndex((o => o.id === e)), 1), this.stylesheet.sprite = a.length > 0 ? a : void 0, delete this._spritesImagesIds[e], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", {
                dataType: "style"
              }))
            } else this.fire(new s.k(new Error(`Sprite "${e}" doesn't exists on this map.`)))
          }
          getSprite() {
            return Pe(this.stylesheet.sprite)
          }
          setSprite(e, a = {}, o) {
            this._checkLoaded(), e && this._validate(s.B.sprite, "sprite", e, null, a) || (this.stylesheet.sprite = e, e ? this._loadSprite(e, !0, o) : (this._unloadSprite(), o && o(null)))
          }
        }
        var qc = s.aN([{
          name: "a_pos",
          type: "Int16",
          components: 2
        }, {
          name: "a_texture_pos",
          type: "Int16",
          components: 2
        }]);
        class rs {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null
          }
          bind(e, a, o, u, p, g, w, I, A) {
            this.context = e;
            let L = this.boundPaintVertexBuffers.length !== u.length;
            for (let O = 0; !L && O < u.length; O++) this.boundPaintVertexBuffers[O] !== u[O] && (L = !0);
            !this.vao || this.boundProgram !== a || this.boundLayoutVertexBuffer !== o || L || this.boundIndexBuffer !== p || this.boundVertexOffset !== g || this.boundDynamicVertexBuffer !== w || this.boundDynamicVertexBuffer2 !== I || this.boundDynamicVertexBuffer3 !== A ? this.freshBind(a, o, u, p, g, w, I, A) : (e.bindVertexArray.set(this.vao), w && w.bind(), p && p.dynamicDraw && p.bind(), I && I.bind(), A && A.bind())
          }
          freshBind(e, a, o, u, p, g, w, I) {
            const A = e.numAttributes,
              L = this.context,
              O = L.gl;
            this.vao && this.destroy(), this.vao = L.createVertexArray(), L.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = a, this.boundPaintVertexBuffers = o, this.boundIndexBuffer = u, this.boundVertexOffset = p, this.boundDynamicVertexBuffer = g, this.boundDynamicVertexBuffer2 = w, this.boundDynamicVertexBuffer3 = I, a.enableAttributes(O, e);
            for (const R of o) R.enableAttributes(O, e);
            g && g.enableAttributes(O, e), w && w.enableAttributes(O, e), I && I.enableAttributes(O, e), a.bind(), a.setVertexAttribPointers(O, e, p);
            for (const R of o) R.bind(), R.setVertexAttribPointers(O, e, p);
            g && (g.bind(), g.setVertexAttribPointers(O, e, p)), u && u.bind(), w && (w.bind(), w.setVertexAttribPointers(O, e, p)), I && (I.bind(), I.setVertexAttribPointers(O, e, p)), L.currentNumAttributes = A
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null)
          }
        }
        const Gp = (d, e, a, o, u) => ({
            u_texture: 0,
            u_ele_delta: d,
            u_fog_matrix: e,
            u_fog_color: a ? a.properties.get("fog-color") : s.bi.white,
            u_fog_ground_blend: a ? a.properties.get("fog-ground-blend") : 1,
            u_fog_ground_blend_opacity: u ? 0 : a ? a.calculateFogBlendOpacity(o) : 0,
            u_horizon_color: a ? a.properties.get("horizon-color") : s.bi.white,
            u_horizon_fog_blend: a ? a.properties.get("horizon-fog-blend") : 1,
            u_is_globe_mode: u ? 1 : 0
          }),
          Nc = {
            mainMatrix: "u_projection_matrix",
            tileMercatorCoords: "u_projection_tile_mercator_coords",
            clippingPlane: "u_projection_clipping_plane",
            projectionTransition: "u_projection_transition",
            fallbackMatrix: "u_projection_fallback_matrix"
          };

        function Ps(d) {
          const e = [];
          for (let a = 0; a < d.length; a++) {
            if (d[a] === null) continue;
            const o = d[a].split(" ");
            e.push(o.pop())
          }
          return e
        }
        class Wo {
          constructor(e, a, o, u, p, g, w, I, A = []) {
            const L = e.gl;
            this.program = L.createProgram();
            const O = Ps(a.staticAttributes),
              R = o ? o.getBinderAttributes() : [],
              H = O.concat(R),
              $ = Ar.prelude.staticUniforms ? Ps(Ar.prelude.staticUniforms) : [],
              ce = w.staticUniforms ? Ps(w.staticUniforms) : [],
              ue = a.staticUniforms ? Ps(a.staticUniforms) : [],
              de = o ? o.getBinderUniforms() : [],
              Ce = $.concat(ce).concat(ue).concat(de),
              Be = [];
            for (const ft of Ce) Be.indexOf(ft) < 0 && Be.push(ft);
            const Ie = o ? o.defines() : [];
            Va(L) && Ie.unshift("#version 300 es"), p && Ie.push("#define OVERDRAW_INSPECTOR;"), g && Ie.push("#define TERRAIN3D;"), I && Ie.push(I), A && Ie.push(...A);
            let Oe = Ie.concat(Ar.prelude.fragmentSource, w.fragmentSource, a.fragmentSource).join(`
`),
              He = Ie.concat(Ar.prelude.vertexSource, w.vertexSource, a.vertexSource).join(`
`);
            Va(L) || (Oe = (function(ft) {
              return ft.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(")
            })(Oe), He = (function(ft) {
              return ft.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(")
            })(He));
            const Le = L.createShader(L.FRAGMENT_SHADER);
            if (L.isContextLost()) return void(this.failedToCreate = !0);
            if (L.shaderSource(Le, Oe), L.compileShader(Le), !L.getShaderParameter(Le, L.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${L.getShaderInfoLog(Le)}`);
            L.attachShader(this.program, Le);
            const $e = L.createShader(L.VERTEX_SHADER);
            if (L.isContextLost()) return void(this.failedToCreate = !0);
            if (L.shaderSource($e, He), L.compileShader($e), !L.getShaderParameter($e, L.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${L.getShaderInfoLog($e)}`);
            L.attachShader(this.program, $e), this.attributes = {};
            const vt = {};
            this.numAttributes = H.length;
            for (let ft = 0; ft < this.numAttributes; ft++) H[ft] && (L.bindAttribLocation(this.program, ft, H[ft]), this.attributes[H[ft]] = ft);
            if (L.linkProgram(this.program), !L.getProgramParameter(this.program, L.LINK_STATUS)) throw new Error(`Program failed to link: ${L.getProgramInfoLog(this.program)}`);
            L.deleteShader($e), L.deleteShader(Le);
            for (let ft = 0; ft < Be.length; ft++) {
              const gt = Be[ft];
              if (gt && !vt[gt]) {
                const xt = L.getUniformLocation(this.program, gt);
                xt && (vt[gt] = xt)
              }
            }
            this.fixedUniforms = u(e, vt), this.terrainUniforms = ((ft, gt) => ({
              u_depth: new s.bT(ft, gt.u_depth),
              u_terrain: new s.bT(ft, gt.u_terrain),
              u_terrain_dim: new s.bj(ft, gt.u_terrain_dim),
              u_terrain_matrix: new s.bV(ft, gt.u_terrain_matrix),
              u_terrain_unpack: new s.bW(ft, gt.u_terrain_unpack),
              u_terrain_exaggeration: new s.bj(ft, gt.u_terrain_exaggeration)
            }))(e, vt), this.projectionUniforms = ((ft, gt) => ({
              u_projection_matrix: new s.bV(ft, gt.u_projection_matrix),
              u_projection_tile_mercator_coords: new s.bW(ft, gt.u_projection_tile_mercator_coords),
              u_projection_clipping_plane: new s.bW(ft, gt.u_projection_clipping_plane),
              u_projection_transition: new s.bj(ft, gt.u_projection_transition),
              u_projection_fallback_matrix: new s.bV(ft, gt.u_projection_fallback_matrix)
            }))(e, vt), this.binderUniforms = o ? o.getUniforms(e, vt) : []
          }
          draw(e, a, o, u, p, g, w, I, A, L, O, R, H, $, ce, ue, de, Ce, Be) {
            const Ie = e.gl;
            if (this.failedToCreate) return;
            if (e.program.set(this.program), e.setDepthMode(o), e.setStencilMode(u), e.setColorMode(p), e.setCullFace(g), I) {
              e.activeTexture.set(Ie.TEXTURE2), Ie.bindTexture(Ie.TEXTURE_2D, I.depthTexture), e.activeTexture.set(Ie.TEXTURE3), Ie.bindTexture(Ie.TEXTURE_2D, I.texture);
              for (const He in this.terrainUniforms) this.terrainUniforms[He].set(I[He])
            }
            if (A)
              for (const He in A) this.projectionUniforms[Nc[He]].set(A[He]);
            if (w)
              for (const He in this.fixedUniforms) this.fixedUniforms[He].set(w[He]);
            ue && ue.setUniforms(e, this.binderUniforms, $, {
              zoom: ce
            });
            let Oe = 0;
            switch (a) {
              case Ie.LINES:
                Oe = 2;
                break;
              case Ie.TRIANGLES:
                Oe = 3;
                break;
              case Ie.LINE_STRIP:
                Oe = 1
            }
            for (const He of H.get()) {
              const Le = He.vaos || (He.vaos = {});
              (Le[L] || (Le[L] = new rs)).bind(e, this, O, ue ? ue.getPaintVertexBuffers() : [], R, He.vertexOffset, de, Ce, Be), Ie.drawElements(a, He.primitiveLength * Oe, Ie.UNSIGNED_SHORT, He.primitiveOffset * Oe * 2)
            }
          }
        }

        function qh(d, e, a) {
          const o = 1 / s.aG(a, 1, e.transform.tileZoom),
            u = Math.pow(2, a.tileID.overscaledZ),
            p = a.tileSize * Math.pow(2, e.transform.tileZoom) / u,
            g = p * (a.tileID.canonical.x + a.tileID.wrap * u),
            w = p * a.tileID.canonical.y;
          return {
            u_image: 0,
            u_texsize: a.imageAtlasTexture.size,
            u_scale: [o, d.fromScale, d.toScale],
            u_fade: d.t,
            u_pixel_coord_upper: [g >> 16, w >> 16],
            u_pixel_coord_lower: [65535 & g, 65535 & w]
          }
        }
        const Ho = (d, e, a, o) => {
            const u = d.style.light,
              p = u.properties.get("position"),
              g = [p.x, p.y, p.z],
              w = s.bZ();
            u.properties.get("anchor") === "viewport" && s.b_(w, d.transform.bearingInRadians), s.b$(g, g, w);
            const I = d.transform.transformLightDirection(g),
              A = u.properties.get("color");
            return {
              u_lightpos: g,
              u_lightpos_globe: I,
              u_lightintensity: u.properties.get("intensity"),
              u_lightcolor: [A.r, A.g, A.b],
              u_vertical_gradient: +e,
              u_opacity: a,
              u_fill_translate: o
            }
          },
          Wp = (d, e, a, o, u, p, g) => s.e(Ho(d, e, a, o), qh(p, d, g), {
            u_height_factor: -Math.pow(2, u.overscaledZ) / g.tileSize / 8
          }),
          js = (d, e, a, o) => s.e(qh(e, d, a), {
            u_fill_translate: o
          }),
          Hp = (d, e) => ({
            u_world: d,
            u_fill_translate: e
          }),
          Nh = (d, e, a, o, u) => s.e(js(d, e, a, u), {
            u_world: o
          }),
          Xp = (d, e, a, o, u) => {
            const p = d.transform;
            let g, w, I = 0;
            if (a.paint.get("circle-pitch-alignment") === "map") {
              const A = s.aG(e, 1, p.zoom);
              g = !0, w = [A, A], I = A / (s.a3 * Math.pow(2, e.tileID.overscaledZ)) * 2 * Math.PI * u
            } else g = !1, w = p.pixelsToGLUnits;
            return {
              u_camera_to_center_distance: p.cameraToCenterDistance,
              u_scale_with_map: +(a.paint.get("circle-pitch-scale") === "map"),
              u_pitch_with_map: +g,
              u_device_pixel_ratio: d.pixelRatio,
              u_extrude_scale: w,
              u_globe_extrude_scale: I,
              u_translate: o
            }
          },
          Vh = d => ({
            u_pixel_extrude_scale: [1 / d.width, 1 / d.height]
          }),
          Vc = d => ({
            u_viewport_size: [d.width, d.height]
          }),
          Uc = (d, e = 1) => ({
            u_color: d,
            u_overlay: 0,
            u_overlay_scale: e
          }),
          Zc = (d, e, a, o) => {
            const u = s.aG(d, 1, e) / (s.a3 * Math.pow(2, d.tileID.overscaledZ)) * 2 * Math.PI * o;
            return {
              u_extrude_scale: s.aG(d, 1, e),
              u_intensity: a,
              u_globe_extrude_scale: u
            }
          },
          Gc = (d, e, a, o) => {
            const u = s.M();
            s.c0(u, 0, d.width, d.height, 0, 0, 1);
            const p = d.context.gl;
            return {
              u_matrix: u,
              u_world: [p.drawingBufferWidth, p.drawingBufferHeight],
              u_image: a,
              u_color_ramp: o,
              u_opacity: e.paint.get("heatmap-opacity")
            }
          },
          Uh = (d, e, a) => {
            const o = a.paint.get("hillshade-accent-color");
            let u;
            switch (a.paint.get("hillshade-method")) {
              case "basic":
                u = 4;
                break;
              case "combined":
                u = 1;
                break;
              case "igor":
                u = 2;
                break;
              case "multidirectional":
                u = 3;
                break;
              default:
                u = 0
            }
            const p = a.getIlluminationProperties();
            for (let g = 0; g < p.directionRadians.length; g++) a.paint.get("hillshade-illumination-anchor") === "viewport" && (p.directionRadians[g] += d.transform.bearingInRadians);
            return {
              u_image: 0,
              u_latrange: Zh(0, e.tileID),
              u_exaggeration: a.paint.get("hillshade-exaggeration"),
              u_altitudes: p.altitudeRadians,
              u_azimuths: p.directionRadians,
              u_accent: o,
              u_method: u,
              u_highlights: p.highlightColor,
              u_shadows: p.shadowColor
            }
          },
          qs = (d, e) => {
            const a = e.stride,
              o = s.M();
            return s.c0(o, 0, s.a3, -s.a3, 0, 0, 1), s.N(o, o, [0, -s.a3, 0]), {
              u_matrix: o,
              u_image: 1,
              u_dimension: [a, a],
              u_zoom: d.overscaledZ,
              u_unpack: e.getUnpackVector()
            }
          };

        function Zh(d, e) {
          const a = Math.pow(2, e.canonical.z),
            o = e.canonical.y;
          return [new s.a5(0, o / a).toLngLat().lat, new s.a5(0, (o + 1) / a).toLngLat().lat]
        }
        const Gh = (d, e, a = 0) => ({
            u_image: 0,
            u_unpack: e.getUnpackVector(),
            u_dimension: [e.stride, e.stride],
            u_elevation_stops: 1,
            u_color_stops: 4,
            u_color_ramp_size: a,
            u_opacity: d.paint.get("color-relief-opacity")
          }),
          Is = (d, e, a, o) => {
            const u = d.transform;
            return {
              u_translation: Wc(d, e, a),
              u_ratio: o / s.aG(e, 1, u.zoom),
              u_device_pixel_ratio: d.pixelRatio,
              u_units_to_pixels: [1 / u.pixelsToGLUnits[0], 1 / u.pixelsToGLUnits[1]]
            }
          },
          Yp = (d, e, a, o, u) => s.e(Is(d, e, a, o), {
            u_image: 0,
            u_image_height: u
          }),
          Al = (d, e, a, o, u) => {
            const p = d.transform,
              g = kl(e, p);
            return {
              u_translation: Wc(d, e, a),
              u_texsize: e.imageAtlasTexture.size,
              u_ratio: o / s.aG(e, 1, p.zoom),
              u_device_pixel_ratio: d.pixelRatio,
              u_image: 0,
              u_scale: [g, u.fromScale, u.toScale],
              u_fade: u.t,
              u_units_to_pixels: [1 / p.pixelsToGLUnits[0], 1 / p.pixelsToGLUnits[1]]
            }
          },
          Kp = (d, e, a, o, u) => {
            const p = kl(e, d.transform);
            return s.e(Is(d, e, a, o), {
              u_tileratio: p,
              u_crossfade_from: u.fromScale,
              u_crossfade_to: u.toScale,
              u_image: 0,
              u_mix: u.t,
              u_lineatlas_width: d.lineAtlas.width,
              u_lineatlas_height: d.lineAtlas.height
            })
          },
          Jp = (d, e, a, o, u, p) => {
            const g = kl(e, d.transform);
            return s.e(Is(d, e, a, o), {
              u_image: 0,
              u_image_height: p,
              u_tileratio: g,
              u_crossfade_from: u.fromScale,
              u_crossfade_to: u.toScale,
              u_image_dash: 1,
              u_mix: u.t,
              u_lineatlas_width: d.lineAtlas.width,
              u_lineatlas_height: d.lineAtlas.height
            })
          };

        function kl(d, e) {
          return 1 / s.aG(d, 1, e.tileZoom)
        }

        function Wc(d, e, a) {
          return s.aH(d.transform, e, a.paint.get("line-translate"), a.paint.get("line-translate-anchor"))
        }
        const Wh = (d, e, a, o, u) => {
          return {
            u_tl_parent: d,
            u_scale_parent: e,
            u_buffer_scale: 1,
            u_fade_t: a.mix,
            u_opacity: a.opacity * o.paint.get("raster-opacity"),
            u_image0: 0,
            u_image1: 1,
            u_brightness_low: o.paint.get("raster-brightness-min"),
            u_brightness_high: o.paint.get("raster-brightness-max"),
            u_saturation_factor: (g = o.paint.get("raster-saturation"), g > 0 ? 1 - 1 / (1.001 - g) : -g),
            u_contrast_factor: (p = o.paint.get("raster-contrast"), p > 0 ? 1 / (1 - p) : 1 + p),
            u_spin_weights: Hc(o.paint.get("raster-hue-rotate")),
            u_coords_top: [u[0].x, u[0].y, u[1].x, u[1].y],
            u_coords_bottom: [u[3].x, u[3].y, u[2].x, u[2].y]
          };
          var p, g
        };

        function Hc(d) {
          d *= Math.PI / 180;
          const e = Math.sin(d),
            a = Math.cos(d);
          return [(2 * a + 1) / 3, (-Math.sqrt(3) * e - a + 1) / 3, (Math.sqrt(3) * e - a + 1) / 3]
        }
        const Xc = (d, e, a, o, u, p, g, w, I, A, L, O, R) => {
            const H = g.transform;
            return {
              u_is_size_zoom_constant: +(d === "constant" || d === "source"),
              u_is_size_feature_constant: +(d === "constant" || d === "camera"),
              u_size_t: e ? e.uSizeT : 0,
              u_size: e ? e.uSize : 0,
              u_camera_to_center_distance: H.cameraToCenterDistance,
              u_pitch: H.pitch / 360 * 2 * Math.PI,
              u_rotate_symbol: +a,
              u_aspect_ratio: H.width / H.height,
              u_fade_change: g.options.fadeDuration ? g.symbolFadeChange : 1,
              u_label_plane_matrix: w,
              u_coord_matrix: I,
              u_is_text: +L,
              u_pitch_with_map: +o,
              u_is_along_line: u,
              u_is_variable_anchor: p,
              u_texsize: O,
              u_texture: 0,
              u_translation: A,
              u_pitched_scale: R
            }
          },
          Xo = (d, e, a, o, u, p, g, w, I, A, L, O, R, H) => {
            const $ = g.transform;
            return s.e(Xc(d, e, a, o, u, p, g, w, I, A, L, O, H), {
              u_gamma_scale: o ? Math.cos($.pitch * Math.PI / 180) * $.cameraToCenterDistance : 1,
              u_device_pixel_ratio: g.pixelRatio,
              u_is_halo: 1
            })
          },
          cs = (d, e, a, o, u, p, g, w, I, A, L, O, R) => s.e(Xo(d, e, a, o, u, p, g, w, I, A, !0, L, 0, R), {
            u_texsize_icon: O,
            u_texture_icon: 1
          }),
          Yc = (d, e) => ({
            u_opacity: d,
            u_color: e
          }),
          Kc = (d, e, a, o, u) => s.e((function(p, g, w, I) {
            const A = w.imageManager.getPattern(p.from.toString()),
              L = w.imageManager.getPattern(p.to.toString()),
              {
                width: O,
                height: R
              } = w.imageManager.getPixelSize(),
              H = Math.pow(2, I.tileID.overscaledZ),
              $ = I.tileSize * Math.pow(2, w.transform.tileZoom) / H,
              ce = $ * (I.tileID.canonical.x + I.tileID.wrap * H),
              ue = $ * I.tileID.canonical.y;
            return {
              u_image: 0,
              u_pattern_tl_a: A.tl,
              u_pattern_br_a: A.br,
              u_pattern_tl_b: L.tl,
              u_pattern_br_b: L.br,
              u_texsize: [O, R],
              u_mix: g.t,
              u_pattern_size_a: A.displaySize,
              u_pattern_size_b: L.displaySize,
              u_scale_a: g.fromScale,
              u_scale_b: g.toScale,
              u_tile_units_to_pixels: 1 / s.aG(I, 1, w.transform.tileZoom),
              u_pixel_coord_upper: [ce >> 16, ue >> 16],
              u_pixel_coord_lower: [65535 & ce, 65535 & ue]
            }
          })(a, u, e, o), {
            u_opacity: d
          }),
          zl = (d, e) => {},
          Hh = {
            fillExtrusion: (d, e) => ({
              u_lightpos: new s.bX(d, e.u_lightpos),
              u_lightpos_globe: new s.bX(d, e.u_lightpos_globe),
              u_lightintensity: new s.bj(d, e.u_lightintensity),
              u_lightcolor: new s.bX(d, e.u_lightcolor),
              u_vertical_gradient: new s.bj(d, e.u_vertical_gradient),
              u_opacity: new s.bj(d, e.u_opacity),
              u_fill_translate: new s.bY(d, e.u_fill_translate)
            }),
            fillExtrusionPattern: (d, e) => ({
              u_lightpos: new s.bX(d, e.u_lightpos),
              u_lightpos_globe: new s.bX(d, e.u_lightpos_globe),
              u_lightintensity: new s.bj(d, e.u_lightintensity),
              u_lightcolor: new s.bX(d, e.u_lightcolor),
              u_vertical_gradient: new s.bj(d, e.u_vertical_gradient),
              u_height_factor: new s.bj(d, e.u_height_factor),
              u_opacity: new s.bj(d, e.u_opacity),
              u_fill_translate: new s.bY(d, e.u_fill_translate),
              u_image: new s.bT(d, e.u_image),
              u_texsize: new s.bY(d, e.u_texsize),
              u_pixel_coord_upper: new s.bY(d, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new s.bY(d, e.u_pixel_coord_lower),
              u_scale: new s.bX(d, e.u_scale),
              u_fade: new s.bj(d, e.u_fade)
            }),
            fill: (d, e) => ({
              u_fill_translate: new s.bY(d, e.u_fill_translate)
            }),
            fillPattern: (d, e) => ({
              u_image: new s.bT(d, e.u_image),
              u_texsize: new s.bY(d, e.u_texsize),
              u_pixel_coord_upper: new s.bY(d, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new s.bY(d, e.u_pixel_coord_lower),
              u_scale: new s.bX(d, e.u_scale),
              u_fade: new s.bj(d, e.u_fade),
              u_fill_translate: new s.bY(d, e.u_fill_translate)
            }),
            fillOutline: (d, e) => ({
              u_world: new s.bY(d, e.u_world),
              u_fill_translate: new s.bY(d, e.u_fill_translate)
            }),
            fillOutlinePattern: (d, e) => ({
              u_world: new s.bY(d, e.u_world),
              u_image: new s.bT(d, e.u_image),
              u_texsize: new s.bY(d, e.u_texsize),
              u_pixel_coord_upper: new s.bY(d, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new s.bY(d, e.u_pixel_coord_lower),
              u_scale: new s.bX(d, e.u_scale),
              u_fade: new s.bj(d, e.u_fade),
              u_fill_translate: new s.bY(d, e.u_fill_translate)
            }),
            circle: (d, e) => ({
              u_camera_to_center_distance: new s.bj(d, e.u_camera_to_center_distance),
              u_scale_with_map: new s.bT(d, e.u_scale_with_map),
              u_pitch_with_map: new s.bT(d, e.u_pitch_with_map),
              u_extrude_scale: new s.bY(d, e.u_extrude_scale),
              u_device_pixel_ratio: new s.bj(d, e.u_device_pixel_ratio),
              u_globe_extrude_scale: new s.bj(d, e.u_globe_extrude_scale),
              u_translate: new s.bY(d, e.u_translate)
            }),
            collisionBox: (d, e) => ({
              u_pixel_extrude_scale: new s.bY(d, e.u_pixel_extrude_scale)
            }),
            collisionCircle: (d, e) => ({
              u_viewport_size: new s.bY(d, e.u_viewport_size)
            }),
            debug: (d, e) => ({
              u_color: new s.bU(d, e.u_color),
              u_overlay: new s.bT(d, e.u_overlay),
              u_overlay_scale: new s.bj(d, e.u_overlay_scale)
            }),
            depth: zl,
            clippingMask: zl,
            heatmap: (d, e) => ({
              u_extrude_scale: new s.bj(d, e.u_extrude_scale),
              u_intensity: new s.bj(d, e.u_intensity),
              u_globe_extrude_scale: new s.bj(d, e.u_globe_extrude_scale)
            }),
            heatmapTexture: (d, e) => ({
              u_matrix: new s.bV(d, e.u_matrix),
              u_world: new s.bY(d, e.u_world),
              u_image: new s.bT(d, e.u_image),
              u_color_ramp: new s.bT(d, e.u_color_ramp),
              u_opacity: new s.bj(d, e.u_opacity)
            }),
            hillshade: (d, e) => ({
              u_image: new s.bT(d, e.u_image),
              u_latrange: new s.bY(d, e.u_latrange),
              u_exaggeration: new s.bj(d, e.u_exaggeration),
              u_altitudes: new s.c2(d, e.u_altitudes),
              u_azimuths: new s.c2(d, e.u_azimuths),
              u_accent: new s.bU(d, e.u_accent),
              u_method: new s.bT(d, e.u_method),
              u_shadows: new s.c1(d, e.u_shadows),
              u_highlights: new s.c1(d, e.u_highlights)
            }),
            hillshadePrepare: (d, e) => ({
              u_matrix: new s.bV(d, e.u_matrix),
              u_image: new s.bT(d, e.u_image),
              u_dimension: new s.bY(d, e.u_dimension),
              u_zoom: new s.bj(d, e.u_zoom),
              u_unpack: new s.bW(d, e.u_unpack)
            }),
            colorRelief: (d, e) => ({
              u_image: new s.bT(d, e.u_image),
              u_unpack: new s.bW(d, e.u_unpack),
              u_dimension: new s.bY(d, e.u_dimension),
              u_elevation_stops: new s.bT(d, e.u_elevation_stops),
              u_color_stops: new s.bT(d, e.u_color_stops),
              u_color_ramp_size: new s.bT(d, e.u_color_ramp_size),
              u_opacity: new s.bj(d, e.u_opacity)
            }),
            line: (d, e) => ({
              u_translation: new s.bY(d, e.u_translation),
              u_ratio: new s.bj(d, e.u_ratio),
              u_device_pixel_ratio: new s.bj(d, e.u_device_pixel_ratio),
              u_units_to_pixels: new s.bY(d, e.u_units_to_pixels)
            }),
            lineGradient: (d, e) => ({
              u_translation: new s.bY(d, e.u_translation),
              u_ratio: new s.bj(d, e.u_ratio),
              u_device_pixel_ratio: new s.bj(d, e.u_device_pixel_ratio),
              u_units_to_pixels: new s.bY(d, e.u_units_to_pixels),
              u_image: new s.bT(d, e.u_image),
              u_image_height: new s.bj(d, e.u_image_height)
            }),
            linePattern: (d, e) => ({
              u_translation: new s.bY(d, e.u_translation),
              u_texsize: new s.bY(d, e.u_texsize),
              u_ratio: new s.bj(d, e.u_ratio),
              u_device_pixel_ratio: new s.bj(d, e.u_device_pixel_ratio),
              u_image: new s.bT(d, e.u_image),
              u_units_to_pixels: new s.bY(d, e.u_units_to_pixels),
              u_scale: new s.bX(d, e.u_scale),
              u_fade: new s.bj(d, e.u_fade)
            }),
            lineSDF: (d, e) => ({
              u_translation: new s.bY(d, e.u_translation),
              u_ratio: new s.bj(d, e.u_ratio),
              u_device_pixel_ratio: new s.bj(d, e.u_device_pixel_ratio),
              u_units_to_pixels: new s.bY(d, e.u_units_to_pixels),
              u_image: new s.bT(d, e.u_image),
              u_mix: new s.bj(d, e.u_mix),
              u_tileratio: new s.bj(d, e.u_tileratio),
              u_crossfade_from: new s.bj(d, e.u_crossfade_from),
              u_crossfade_to: new s.bj(d, e.u_crossfade_to),
              u_lineatlas_width: new s.bj(d, e.u_lineatlas_width),
              u_lineatlas_height: new s.bj(d, e.u_lineatlas_height)
            }),
            lineGradientSDF: (d, e) => ({
              u_translation: new s.bY(d, e.u_translation),
              u_ratio: new s.bj(d, e.u_ratio),
              u_device_pixel_ratio: new s.bj(d, e.u_device_pixel_ratio),
              u_units_to_pixels: new s.bY(d, e.u_units_to_pixels),
              u_image: new s.bT(d, e.u_image),
              u_image_height: new s.bj(d, e.u_image_height),
              u_tileratio: new s.bj(d, e.u_tileratio),
              u_crossfade_from: new s.bj(d, e.u_crossfade_from),
              u_crossfade_to: new s.bj(d, e.u_crossfade_to),
              u_image_dash: new s.bT(d, e.u_image_dash),
              u_mix: new s.bj(d, e.u_mix),
              u_lineatlas_width: new s.bj(d, e.u_lineatlas_width),
              u_lineatlas_height: new s.bj(d, e.u_lineatlas_height)
            }),
            raster: (d, e) => ({
              u_tl_parent: new s.bY(d, e.u_tl_parent),
              u_scale_parent: new s.bj(d, e.u_scale_parent),
              u_buffer_scale: new s.bj(d, e.u_buffer_scale),
              u_fade_t: new s.bj(d, e.u_fade_t),
              u_opacity: new s.bj(d, e.u_opacity),
              u_image0: new s.bT(d, e.u_image0),
              u_image1: new s.bT(d, e.u_image1),
              u_brightness_low: new s.bj(d, e.u_brightness_low),
              u_brightness_high: new s.bj(d, e.u_brightness_high),
              u_saturation_factor: new s.bj(d, e.u_saturation_factor),
              u_contrast_factor: new s.bj(d, e.u_contrast_factor),
              u_spin_weights: new s.bX(d, e.u_spin_weights),
              u_coords_top: new s.bW(d, e.u_coords_top),
              u_coords_bottom: new s.bW(d, e.u_coords_bottom)
            }),
            symbolIcon: (d, e) => ({
              u_is_size_zoom_constant: new s.bT(d, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new s.bT(d, e.u_is_size_feature_constant),
              u_size_t: new s.bj(d, e.u_size_t),
              u_size: new s.bj(d, e.u_size),
              u_camera_to_center_distance: new s.bj(d, e.u_camera_to_center_distance),
              u_pitch: new s.bj(d, e.u_pitch),
              u_rotate_symbol: new s.bT(d, e.u_rotate_symbol),
              u_aspect_ratio: new s.bj(d, e.u_aspect_ratio),
              u_fade_change: new s.bj(d, e.u_fade_change),
              u_label_plane_matrix: new s.bV(d, e.u_label_plane_matrix),
              u_coord_matrix: new s.bV(d, e.u_coord_matrix),
              u_is_text: new s.bT(d, e.u_is_text),
              u_pitch_with_map: new s.bT(d, e.u_pitch_with_map),
              u_is_along_line: new s.bT(d, e.u_is_along_line),
              u_is_variable_anchor: new s.bT(d, e.u_is_variable_anchor),
              u_texsize: new s.bY(d, e.u_texsize),
              u_texture: new s.bT(d, e.u_texture),
              u_translation: new s.bY(d, e.u_translation),
              u_pitched_scale: new s.bj(d, e.u_pitched_scale)
            }),
            symbolSDF: (d, e) => ({
              u_is_size_zoom_constant: new s.bT(d, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new s.bT(d, e.u_is_size_feature_constant),
              u_size_t: new s.bj(d, e.u_size_t),
              u_size: new s.bj(d, e.u_size),
              u_camera_to_center_distance: new s.bj(d, e.u_camera_to_center_distance),
              u_pitch: new s.bj(d, e.u_pitch),
              u_rotate_symbol: new s.bT(d, e.u_rotate_symbol),
              u_aspect_ratio: new s.bj(d, e.u_aspect_ratio),
              u_fade_change: new s.bj(d, e.u_fade_change),
              u_label_plane_matrix: new s.bV(d, e.u_label_plane_matrix),
              u_coord_matrix: new s.bV(d, e.u_coord_matrix),
              u_is_text: new s.bT(d, e.u_is_text),
              u_pitch_with_map: new s.bT(d, e.u_pitch_with_map),
              u_is_along_line: new s.bT(d, e.u_is_along_line),
              u_is_variable_anchor: new s.bT(d, e.u_is_variable_anchor),
              u_texsize: new s.bY(d, e.u_texsize),
              u_texture: new s.bT(d, e.u_texture),
              u_gamma_scale: new s.bj(d, e.u_gamma_scale),
              u_device_pixel_ratio: new s.bj(d, e.u_device_pixel_ratio),
              u_is_halo: new s.bT(d, e.u_is_halo),
              u_translation: new s.bY(d, e.u_translation),
              u_pitched_scale: new s.bj(d, e.u_pitched_scale)
            }),
            symbolTextAndIcon: (d, e) => ({
              u_is_size_zoom_constant: new s.bT(d, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new s.bT(d, e.u_is_size_feature_constant),
              u_size_t: new s.bj(d, e.u_size_t),
              u_size: new s.bj(d, e.u_size),
              u_camera_to_center_distance: new s.bj(d, e.u_camera_to_center_distance),
              u_pitch: new s.bj(d, e.u_pitch),
              u_rotate_symbol: new s.bT(d, e.u_rotate_symbol),
              u_aspect_ratio: new s.bj(d, e.u_aspect_ratio),
              u_fade_change: new s.bj(d, e.u_fade_change),
              u_label_plane_matrix: new s.bV(d, e.u_label_plane_matrix),
              u_coord_matrix: new s.bV(d, e.u_coord_matrix),
              u_is_text: new s.bT(d, e.u_is_text),
              u_pitch_with_map: new s.bT(d, e.u_pitch_with_map),
              u_is_along_line: new s.bT(d, e.u_is_along_line),
              u_is_variable_anchor: new s.bT(d, e.u_is_variable_anchor),
              u_texsize: new s.bY(d, e.u_texsize),
              u_texsize_icon: new s.bY(d, e.u_texsize_icon),
              u_texture: new s.bT(d, e.u_texture),
              u_texture_icon: new s.bT(d, e.u_texture_icon),
              u_gamma_scale: new s.bj(d, e.u_gamma_scale),
              u_device_pixel_ratio: new s.bj(d, e.u_device_pixel_ratio),
              u_is_halo: new s.bT(d, e.u_is_halo),
              u_translation: new s.bY(d, e.u_translation),
              u_pitched_scale: new s.bj(d, e.u_pitched_scale)
            }),
            background: (d, e) => ({
              u_opacity: new s.bj(d, e.u_opacity),
              u_color: new s.bU(d, e.u_color)
            }),
            backgroundPattern: (d, e) => ({
              u_opacity: new s.bj(d, e.u_opacity),
              u_image: new s.bT(d, e.u_image),
              u_pattern_tl_a: new s.bY(d, e.u_pattern_tl_a),
              u_pattern_br_a: new s.bY(d, e.u_pattern_br_a),
              u_pattern_tl_b: new s.bY(d, e.u_pattern_tl_b),
              u_pattern_br_b: new s.bY(d, e.u_pattern_br_b),
              u_texsize: new s.bY(d, e.u_texsize),
              u_mix: new s.bj(d, e.u_mix),
              u_pattern_size_a: new s.bY(d, e.u_pattern_size_a),
              u_pattern_size_b: new s.bY(d, e.u_pattern_size_b),
              u_scale_a: new s.bj(d, e.u_scale_a),
              u_scale_b: new s.bj(d, e.u_scale_b),
              u_pixel_coord_upper: new s.bY(d, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new s.bY(d, e.u_pixel_coord_lower),
              u_tile_units_to_pixels: new s.bj(d, e.u_tile_units_to_pixels)
            }),
            terrain: (d, e) => ({
              u_texture: new s.bT(d, e.u_texture),
              u_ele_delta: new s.bj(d, e.u_ele_delta),
              u_fog_matrix: new s.bV(d, e.u_fog_matrix),
              u_fog_color: new s.bU(d, e.u_fog_color),
              u_fog_ground_blend: new s.bj(d, e.u_fog_ground_blend),
              u_fog_ground_blend_opacity: new s.bj(d, e.u_fog_ground_blend_opacity),
              u_horizon_color: new s.bU(d, e.u_horizon_color),
              u_horizon_fog_blend: new s.bj(d, e.u_horizon_fog_blend),
              u_is_globe_mode: new s.bj(d, e.u_is_globe_mode)
            }),
            terrainDepth: (d, e) => ({
              u_ele_delta: new s.bj(d, e.u_ele_delta)
            }),
            terrainCoords: (d, e) => ({
              u_texture: new s.bT(d, e.u_texture),
              u_terrain_coords_id: new s.bj(d, e.u_terrain_coords_id),
              u_ele_delta: new s.bj(d, e.u_ele_delta)
            }),
            projectionErrorMeasurement: (d, e) => ({
              u_input: new s.bj(d, e.u_input),
              u_output_expected: new s.bj(d, e.u_output_expected)
            }),
            atmosphere: (d, e) => ({
              u_sun_pos: new s.bX(d, e.u_sun_pos),
              u_atmosphere_blend: new s.bj(d, e.u_atmosphere_blend),
              u_globe_position: new s.bX(d, e.u_globe_position),
              u_globe_radius: new s.bj(d, e.u_globe_radius),
              u_inv_proj_matrix: new s.bV(d, e.u_inv_proj_matrix)
            }),
            sky: (d, e) => ({
              u_sky_color: new s.bU(d, e.u_sky_color),
              u_horizon_color: new s.bU(d, e.u_horizon_color),
              u_horizon: new s.bY(d, e.u_horizon),
              u_horizon_normal: new s.bY(d, e.u_horizon_normal),
              u_sky_horizon_blend: new s.bj(d, e.u_sky_horizon_blend),
              u_sky_blend: new s.bj(d, e.u_sky_blend)
            })
          };
        class Jc {
          constructor(e, a, o) {
            this.context = e;
            const u = e.gl;
            this.buffer = u.createBuffer(), this.dynamicDraw = !!o, this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), u.bufferData(u.ELEMENT_ARRAY_BUFFER, a.arrayBuffer, this.dynamicDraw ? u.DYNAMIC_DRAW : u.STATIC_DRAW), this.dynamicDraw || delete a.arrayBuffer
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer)
          }
          updateData(e) {
            const a = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), a.bufferSubData(a.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer)
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer)
          }
        }
        const Ns = {
          Int8: "BYTE",
          Uint8: "UNSIGNED_BYTE",
          Int16: "SHORT",
          Uint16: "UNSIGNED_SHORT",
          Int32: "INT",
          Uint32: "UNSIGNED_INT",
          Float32: "FLOAT"
        };
        class $c {
          constructor(e, a, o, u) {
            this.length = a.length, this.attributes = o, this.itemSize = a.bytesPerElement, this.dynamicDraw = u, this.context = e;
            const p = e.gl;
            this.buffer = p.createBuffer(), e.bindVertexBuffer.set(this.buffer), p.bufferData(p.ARRAY_BUFFER, a.arrayBuffer, this.dynamicDraw ? p.DYNAMIC_DRAW : p.STATIC_DRAW), this.dynamicDraw || delete a.arrayBuffer
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer)
          }
          updateData(e) {
            if (e.length !== this.length) throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`);
            const a = this.context.gl;
            this.bind(), a.bufferSubData(a.ARRAY_BUFFER, 0, e.arrayBuffer)
          }
          enableAttributes(e, a) {
            for (let o = 0; o < this.attributes.length; o++) {
              const u = a.attributes[this.attributes[o].name];
              u !== void 0 && e.enableVertexAttribArray(u)
            }
          }
          setVertexAttribPointers(e, a, o) {
            for (let u = 0; u < this.attributes.length; u++) {
              const p = this.attributes[u],
                g = a.attributes[p.name];
              g !== void 0 && e.vertexAttribPointer(g, p.components, e[Ns[p.type]], !1, this.itemSize, p.offset + this.itemSize * (o || 0))
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer)
          }
        }
        class $i {
          constructor(e) {
            this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1
          }
          get() {
            return this.current
          }
          set(e) {}
          getDefault() {
            return this.default
          }
          setDefault() {
            this.set(this.default)
          }
        }
        class $p extends $i {
          getDefault() {
            return s.bi.transparent
          }
          set(e) {
            const a = this.current;
            (e.r !== a.r || e.g !== a.g || e.b !== a.b || e.a !== a.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1)
          }
        }
        class Qp extends $i {
          getDefault() {
            return 1
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1)
          }
        }
        class ef extends $i {
          getDefault() {
            return 0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1)
          }
        }
        class Xh extends $i {
          getDefault() {
            return [!0, !0, !0, !0]
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || e[2] !== a[2] || e[3] !== a[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1)
          }
        }
        class tf extends $i {
          getDefault() {
            return !0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1)
          }
        }
        class Yh extends $i {
          getDefault() {
            return 255
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1)
          }
        }
        class El extends $i {
          getDefault() {
            return {
              func: this.gl.ALWAYS,
              ref: 0,
              mask: 255
            }
          }
          set(e) {
            const a = this.current;
            (e.func !== a.func || e.ref !== a.ref || e.mask !== a.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1)
          }
        }
        class Ll extends $i {
          getDefault() {
            const e = this.gl;
            return [e.KEEP, e.KEEP, e.KEEP]
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || e[2] !== a[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1)
          }
        }
        class Dl extends $i {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.STENCIL_TEST) : a.disable(a.STENCIL_TEST), this.current = e, this.dirty = !1
          }
        }
        class Qc extends $i {
          getDefault() {
            return [0, 1]
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1)
          }
        }
        class Vs extends $i {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.DEPTH_TEST) : a.disable(a.DEPTH_TEST), this.current = e, this.dirty = !1
          }
        }
        class Yo extends $i {
          getDefault() {
            return this.gl.LESS
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1)
          }
        }
        class bo extends $i {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.BLEND) : a.disable(a.BLEND), this.current = e, this.dirty = !1
          }
        }
        class Ln extends $i {
          getDefault() {
            const e = this.gl;
            return [e.ONE, e.ZERO]
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1)
          }
        }
        class Kh extends $i {
          getDefault() {
            return s.bi.transparent
          }
          set(e) {
            const a = this.current;
            (e.r !== a.r || e.g !== a.g || e.b !== a.b || e.a !== a.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1)
          }
        }
        class Jh extends $i {
          getDefault() {
            return this.gl.FUNC_ADD
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = !1)
          }
        }
        class eu extends $i {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.CULL_FACE) : a.disable(a.CULL_FACE), this.current = e, this.dirty = !1
          }
        }
        class Us extends $i {
          getDefault() {
            return this.gl.BACK
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1)
          }
        }
        class Rl extends $i {
          getDefault() {
            return this.gl.CCW
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1)
          }
        }
        class Fl extends $i {
          getDefault() {
            return null
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1)
          }
        }
        class Ko extends $i {
          getDefault() {
            return this.gl.TEXTURE0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1)
          }
        }
        class Bl extends $i {
          getDefault() {
            const e = this.gl;
            return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight]
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || e[2] !== a[2] || e[3] !== a[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1)
          }
        }
        class $h extends $i {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindFramebuffer(a.FRAMEBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class wo extends $i {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindRenderbuffer(a.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class To extends $i {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindTexture(a.TEXTURE_2D, e), this.current = e, this.dirty = !1
          }
        }
        class Qh extends $i {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindBuffer(a.ARRAY_BUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class tu extends $i {
          getDefault() {
            return null
          }
          set(e) {
            const a = this.gl;
            a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class ji extends $i {
          getDefault() {
            return null
          }
          set(e) {
            var a;
            if (e === this.current && !this.dirty) return;
            const o = this.gl;
            Va(o) ? o.bindVertexArray(e) : (a = o.getExtension("OES_vertex_array_object")) === null || a === void 0 || a.bindVertexArrayOES(e), this.current = e, this.dirty = !1
          }
        }
        class Ol extends $i {
          getDefault() {
            return 4
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.pixelStorei(a.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1
          }
        }
        class rf extends $i {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1
          }
        }
        class ed extends $i {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1
          }
        }
        class Zs extends $i {
          constructor(e, a) {
            super(e), this.context = e, this.parent = a
          }
          getDefault() {
            return null
          }
        }
        class af extends Zs {
          setDirty() {
            this.dirty = !0
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const a = this.gl;
            a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1
          }
        }
        class nf extends Zs {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const a = this.gl;
            a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class td extends Zs {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const a = this.gl;
            a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        const rd = "Framebuffer is not complete";
        class ru {
          constructor(e, a, o, u, p) {
            this.context = e, this.width = a, this.height = o;
            const g = e.gl,
              w = this.framebuffer = g.createFramebuffer();
            if (this.colorAttachment = new af(e, w), u) this.depthAttachment = p ? new td(e, w) : new nf(e, w);
            else if (p) throw new Error("Stencil cannot be set without depth");
            if (g.checkFramebufferStatus(g.FRAMEBUFFER) !== g.FRAMEBUFFER_COMPLETE) throw new Error(rd)
          }
          destroy() {
            const e = this.context.gl,
              a = this.colorAttachment.get();
            if (a && e.deleteTexture(a), this.depthAttachment) {
              const o = this.depthAttachment.get();
              o && e.deleteRenderbuffer(o)
            }
            e.deleteFramebuffer(this.framebuffer)
          }
        }
        class jl {
          constructor(e) {
            var a, o;
            if (this.gl = e, this.clearColor = new $p(this), this.clearDepth = new Qp(this), this.clearStencil = new ef(this), this.colorMask = new Xh(this), this.depthMask = new tf(this), this.stencilMask = new Yh(this), this.stencilFunc = new El(this), this.stencilOp = new Ll(this), this.stencilTest = new Dl(this), this.depthRange = new Qc(this), this.depthTest = new Vs(this), this.depthFunc = new Yo(this), this.blend = new bo(this), this.blendFunc = new Ln(this), this.blendColor = new Kh(this), this.blendEquation = new Jh(this), this.cullFace = new eu(this), this.cullFaceSide = new Us(this), this.frontFace = new Rl(this), this.program = new Fl(this), this.activeTexture = new Ko(this), this.viewport = new Bl(this), this.bindFramebuffer = new $h(this), this.bindRenderbuffer = new wo(this), this.bindTexture = new To(this), this.bindVertexBuffer = new Qh(this), this.bindElementBuffer = new tu(this), this.bindVertexArray = new ji(this), this.pixelStoreUnpack = new Ol(this), this.pixelStoreUnpackPremultiplyAlpha = new rf(this), this.pixelStoreUnpackFlipY = new ed(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), Va(e)) {
              this.HALF_FLOAT = e.HALF_FLOAT;
              const u = e.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = (a = e.RGBA16F) !== null && a !== void 0 ? a : u == null ? void 0 : u.RGBA16F_EXT, this.RGB16F = (o = e.RGB16F) !== null && o !== void 0 ? o : u == null ? void 0 : u.RGB16F_EXT, e.getExtension("EXT_color_buffer_float")
            } else {
              e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear");
              const u = e.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = u == null ? void 0 : u.HALF_FLOAT_OES
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault()
          }
          setDirty() {
            this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0
          }
          createIndexBuffer(e, a) {
            return new Jc(this, e, a)
          }
          createVertexBuffer(e, a, o) {
            return new $c(this, e, a, o)
          }
          createRenderbuffer(e, a, o) {
            const u = this.gl,
              p = u.createRenderbuffer();
            return this.bindRenderbuffer.set(p), u.renderbufferStorage(u.RENDERBUFFER, e, a, o), this.bindRenderbuffer.set(null), p
          }
          createFramebuffer(e, a, o, u) {
            return new ru(this, e, a, o, u)
          }
          clear({
            color: e,
            depth: a,
            stencil: o
          }) {
            const u = this.gl;
            let p = 0;
            e && (p |= u.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), a !== void 0 && (p |= u.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(a), this.depthMask.set(!0)), o !== void 0 && (p |= u.STENCIL_BUFFER_BIT, this.clearStencil.set(o), this.stencilMask.set(255)), u.clear(p)
          }
          setCullFace(e) {
            e.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace))
          }
          setDepthMode(e) {
            e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1)
          }
          setStencilMode(e) {
            e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({
              func: e.test.func,
              ref: e.ref,
              mask: e.test.mask
            })) : this.stencilTest.set(!1)
          }
          setColorMode(e) {
            s.bK(e.blendFunction, Mi.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask)
          }
          createVertexArray() {
            var e;
            return Va(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) === null || e === void 0 ? void 0 : e.createVertexArrayOES()
          }
          deleteVertexArray(e) {
            var a;
            return Va(this.gl) ? this.gl.deleteVertexArray(e) : (a = this.gl.getExtension("OES_vertex_array_object")) === null || a === void 0 ? void 0 : a.deleteVertexArrayOES(e)
          }
          unbindVAO() {
            this.bindVertexArray.set(null)
          }
        }
        let Gs;

        function Jo(d, e, a, o, u) {
          const p = d.context,
            g = d.transform,
            w = p.gl,
            I = d.useProgram("collisionBox"),
            A = [];
          let L = 0,
            O = 0;
          for (let de = 0; de < o.length; de++) {
            const Ce = o[de],
              Be = e.getTile(Ce).getBucket(a);
            if (!Be) continue;
            const Ie = u ? Be.textCollisionBox : Be.iconCollisionBox,
              Oe = Be.collisionCircleArray;
            Oe.length > 0 && (A.push({
              circleArray: Oe,
              circleOffset: O,
              coord: Ce
            }), L += Oe.length / 4, O = L), Ie && I.draw(p, w.LINES, Si.disabled, Fi.disabled, d.colorModeForRenderPass(), Ti.disabled, Vh(d.transform), d.style.map.terrain && d.style.map.terrain.getTerrainData(Ce), g.getProjectionData({
              overscaledTileID: Ce,
              applyGlobeMatrix: !0,
              applyTerrainMatrix: !0
            }), a.id, Ie.layoutVertexBuffer, Ie.indexBuffer, Ie.segments, null, d.transform.zoom, null, null, Ie.collisionVertexBuffer)
          }
          if (!u || !A.length) return;
          const R = d.useProgram("collisionCircle"),
            H = new s.c3;
          H.resize(4 * L), H._trim();
          let $ = 0;
          for (const de of A)
            for (let Ce = 0; Ce < de.circleArray.length / 4; Ce++) {
              const Be = 4 * Ce,
                Ie = de.circleArray[Be + 0],
                Oe = de.circleArray[Be + 1],
                He = de.circleArray[Be + 2],
                Le = de.circleArray[Be + 3];
              H.emplace($++, Ie, Oe, He, Le, 0), H.emplace($++, Ie, Oe, He, Le, 1), H.emplace($++, Ie, Oe, He, Le, 2), H.emplace($++, Ie, Oe, He, Le, 3)
            }(!Gs || Gs.length < 2 * L) && (Gs = (function(de) {
              const Ce = 2 * de,
                Be = new s.c5;
              Be.resize(Ce), Be._trim();
              for (let Ie = 0; Ie < Ce; Ie++) {
                const Oe = 6 * Ie;
                Be.uint16[Oe + 0] = 4 * Ie + 0, Be.uint16[Oe + 1] = 4 * Ie + 1, Be.uint16[Oe + 2] = 4 * Ie + 2, Be.uint16[Oe + 3] = 4 * Ie + 2, Be.uint16[Oe + 4] = 4 * Ie + 3, Be.uint16[Oe + 5] = 4 * Ie + 0
              }
              return Be
            })(L));
          const ce = p.createIndexBuffer(Gs, !0),
            ue = p.createVertexBuffer(H, s.c4.members, !0);
          for (const de of A) {
            const Ce = Vc(d.transform);
            R.draw(p, w.TRIANGLES, Si.disabled, Fi.disabled, d.colorModeForRenderPass(), Ti.disabled, Ce, d.style.map.terrain && d.style.map.terrain.getTerrainData(de.coord), null, a.id, ue, ce, s.aQ.simpleSegment(0, 2 * de.circleOffset, de.circleArray.length, de.circleArray.length / 2), null, d.transform.zoom, null, null, null)
          }
          ue.destroy(), ce.destroy()
        }
        const iu = s.am(new Float32Array(16));

        function id(d, e, a, o, u, p) {
          const {
            horizontalAlign: g,
            verticalAlign: w
          } = s.aL(d);
          return new s.P((-(g - .5) * e / u + o[0]) * p, (-(w - .5) * a / u + o[1]) * p)
        }

        function ql(d, e, a, o, u, p) {
          const g = e.tileAnchorPoint.add(new s.P(e.translation[0], e.translation[1]));
          if (e.pitchWithMap) {
            let w = o.mult(p);
            a || (w = w.rotate(-u));
            const I = g.add(w);
            return tt(I.x, I.y, e.pitchedLabelPlaneMatrix, e.getElevation).point
          }
          if (a) {
            const w = It(e.tileAnchorPoint.x + 1, e.tileAnchorPoint.y, e).point.sub(d),
              I = Math.atan(w.y / w.x) + (w.x < 0 ? Math.PI : 0);
            return d.add(o.rotate(I))
          }
          return d.add(o)
        }

        function Nl(d, e, a, o, u, p, g, w, I, A, L, O) {
          const R = d.text.placedSymbolArray,
            H = d.text.dynamicLayoutVertexArray,
            $ = d.icon.dynamicLayoutVertexArray,
            ce = {};
          H.clear();
          for (let ue = 0; ue < R.length; ue++) {
            const de = R.get(ue),
              Ce = de.hidden || !de.crossTileID || d.allowVerticalPlacement && !de.placedOrientation ? null : o[de.crossTileID];
            if (Ce) {
              const Be = new s.P(de.anchorX, de.anchorY),
                Ie = {
                  getElevation: O,
                  width: u.width,
                  height: u.height,
                  pitchedLabelPlaneMatrix: p,
                  pitchWithMap: a,
                  transform: u,
                  tileAnchorPoint: Be,
                  translation: A,
                  unwrappedTileID: L
                },
                Oe = a ? Pr(Be.x, Be.y, Ie) : It(Be.x, Be.y, Ie),
                He = Ht(u.cameraToCenterDistance, Oe.signedDistanceFromCamera);
              let Le = s.at(d.textSizeData, w, de) * He / s.aF;
              a && (Le *= d.tilePixelRatio / g);
              const {
                width: $e,
                height: vt,
                anchor: ft,
                textOffset: gt,
                textBoxScale: xt
              } = Ce, lr = id(ft, $e, vt, gt, xt, Le), cr = u.getPitchedTextCorrection(Be.x + A[0], Be.y + A[1], L), Nt = ql(Oe.point, Ie, e, lr, -u.bearingInRadians, cr), Nr = d.allowVerticalPlacement && de.placedOrientation === s.as.vertical ? Math.PI / 2 : 0;
              for (let Pi = 0; Pi < de.numGlyphs; Pi++) s.az(H, Nt, Nr);
              I && de.associatedIconIndex >= 0 && (ce[de.associatedIconIndex] = {
                shiftedAnchor: Nt,
                angle: Nr
              })
            } else di(de.numGlyphs, H)
          }
          if (I) {
            $.clear();
            const ue = d.icon.placedSymbolArray;
            for (let de = 0; de < ue.length; de++) {
              const Ce = ue.get(de);
              if (Ce.hidden) di(Ce.numGlyphs, $);
              else {
                const Be = ce[de];
                if (Be)
                  for (let Ie = 0; Ie < Ce.numGlyphs; Ie++) s.az($, Be.shiftedAnchor, Be.angle);
                else di(Ce.numGlyphs, $)
              }
            }
            d.icon.dynamicLayoutVertexBuffer.updateData($)
          }
          d.text.dynamicLayoutVertexBuffer.updateData(H)
        }

        function Vl(d, e, a) {
          return a.iconsInText && e ? "symbolTextAndIcon" : d ? "symbolSDF" : "symbolIcon"
        }

        function Ws(d, e, a, o, u, p, g, w, I, A, L, O, R) {
          const H = d.context,
            $ = H.gl,
            ce = d.transform,
            ue = w === "map",
            de = I === "map",
            Ce = w !== "viewport" && a.layout.get("symbol-placement") !== "point",
            Be = ue && !de && !Ce,
            Ie = !a.layout.get("symbol-sort-key").isConstant();
          let Oe = !1;
          const He = d.getDepthModeForSublayer(0, Si.ReadOnly),
            Le = a._unevaluatedLayout.hasValue("text-variable-anchor") || a._unevaluatedLayout.hasValue("text-variable-anchor-offset"),
            $e = [],
            vt = ce.getCircleRadiusCorrection();
          for (const ft of o) {
            const gt = e.getTile(ft),
              xt = gt.getBucket(a);
            if (!xt) continue;
            const lr = u ? xt.text : xt.icon;
            if (!lr || !lr.segments.get().length || !lr.hasVisibleVertices) continue;
            const cr = lr.programConfigurations.get(a.id),
              Nt = u || xt.sdfIcons,
              Nr = u ? xt.textSizeData : xt.iconSizeData,
              Pi = de || ce.pitch !== 0,
              Qi = d.useProgram(Vl(Nt, u, xt), cr),
              Li = s.ar(Nr, ce.zoom),
              ra = d.style.map.terrain && d.style.map.terrain.getTerrainData(ft);
            let va, na, za, ha, Ua = [0, 0],
              da = null;
            if (u) na = gt.glyphAtlasTexture, za = $.LINEAR, va = gt.glyphAtlasTexture.size, xt.iconsInText && (Ua = gt.imageAtlasTexture.size, da = gt.imageAtlasTexture, ha = Pi || d.options.rotating || d.options.zooming || Nr.kind === "composite" || Nr.kind === "camera" ? $.LINEAR : $.NEAREST);
            else {
              const Aa = a.layout.get("icon-size").constantOr(0) !== 1 || xt.iconsNeedLinear;
              na = gt.imageAtlasTexture, za = Nt || d.options.rotating || d.options.zooming || Aa || Pi ? $.LINEAR : $.NEAREST, va = gt.imageAtlasTexture.size
            }
            const Ca = s.aG(gt, 1, d.transform.zoom),
              cn = Wt(ue, d.transform, Ca),
              $s = s.M();
            s.au($s, cn);
            const ms = Fr(de, ue, d.transform, Ca),
              as = s.aH(ce, gt, p, g),
              Qs = ce.getProjectionData({
                overscaledTileID: ft,
                applyGlobeMatrix: !R,
                applyTerrainMatrix: !0
              }),
              zo = Le && xt.hasTextData(),
              eo = a.layout.get("icon-text-fit") !== "none" && zo && xt.hasIconData();
            if (Ce) {
              const Aa = d.style.map.terrain ? (Za, oa) => d.style.map.terrain.getElevation(ft, Za, oa) : null,
                Ta = a.layout.get("text-rotation-alignment") === "map";
              Sr(xt, d, u, cn, $s, de, A, Ta, ft.toUnwrapped(), ce.width, ce.height, as, Aa)
            }
            const gn = u && Le || eo,
              un = Ce || gn ? iu : de ? cn : d.transform.clipSpaceToPixelsMatrix,
              gs = Nt && a.paint.get(u ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
            let Cs;
            Cs = Nt ? xt.iconsInText ? cs(Nr.kind, Li, Be, de, Ce, gn, d, un, ms, as, va, Ua, vt) : Xo(Nr.kind, Li, Be, de, Ce, gn, d, un, ms, as, u, va, 0, vt) : Xc(Nr.kind, Li, Be, de, Ce, gn, d, un, ms, as, u, va, vt);
            const ll = {
              program: Qi,
              buffers: lr,
              uniformValues: Cs,
              projectionData: Qs,
              atlasTexture: na,
              atlasTextureIcon: da,
              atlasInterpolation: za,
              atlasInterpolationIcon: ha,
              isSDF: Nt,
              hasHalo: gs
            };
            if (Ie && xt.canOverlap) {
              Oe = !0;
              const Aa = lr.segments.get();
              for (const Ta of Aa) $e.push({
                segments: new s.aQ([Ta]),
                sortKey: Ta.sortKey,
                state: ll,
                terrainData: ra
              })
            } else $e.push({
              segments: lr.segments,
              sortKey: 0,
              state: ll,
              terrainData: ra
            })
          }
          Oe && $e.sort(((ft, gt) => ft.sortKey - gt.sortKey));
          for (const ft of $e) {
            const gt = ft.state;
            if (H.activeTexture.set($.TEXTURE0), gt.atlasTexture.bind(gt.atlasInterpolation, $.CLAMP_TO_EDGE), gt.atlasTextureIcon && (H.activeTexture.set($.TEXTURE1), gt.atlasTextureIcon && gt.atlasTextureIcon.bind(gt.atlasInterpolationIcon, $.CLAMP_TO_EDGE)), gt.isSDF) {
              const xt = gt.uniformValues;
              gt.hasHalo && (xt.u_is_halo = 1, Ul(gt.buffers, ft.segments, a, d, gt.program, He, L, O, xt, gt.projectionData, ft.terrainData)), xt.u_is_halo = 0
            }
            Ul(gt.buffers, ft.segments, a, d, gt.program, He, L, O, gt.uniformValues, gt.projectionData, ft.terrainData)
          }
        }

        function Ul(d, e, a, o, u, p, g, w, I, A, L) {
          const O = o.context;
          u.draw(O, O.gl.TRIANGLES, p, g, w, Ti.backCCW, I, L, A, a.id, d.layoutVertexBuffer, d.indexBuffer, e, a.paint, o.transform.zoom, d.programConfigurations.get(a.id), d.dynamicLayoutVertexBuffer, d.opacityVertexBuffer)
        }

        function sf(d, e, a, o, u) {
          const p = d.context,
            g = p.gl,
            w = Fi.disabled,
            I = new Mi([g.ONE, g.ONE], s.bi.transparent, [!0, !0, !0, !0]),
            A = e.getBucket(a);
          if (!A) return;
          const L = o.key;
          let O = a.heatmapFbos.get(L);
          O || (O = ad(p, e.tileSize, e.tileSize), a.heatmapFbos.set(L, O)), p.bindFramebuffer.set(O.framebuffer), p.viewport.set([0, 0, e.tileSize, e.tileSize]), p.clear({
            color: s.bi.transparent
          });
          const R = A.programConfigurations.get(a.id),
            H = d.useProgram("heatmap", R, !u),
            $ = d.transform.getProjectionData({
              overscaledTileID: e.tileID,
              applyGlobeMatrix: !0,
              applyTerrainMatrix: !0
            }),
            ce = d.style.map.terrain.getTerrainData(o);
          H.draw(p, g.TRIANGLES, Si.disabled, w, I, Ti.disabled, Zc(e, d.transform.zoom, a.paint.get("heatmap-intensity"), 1), ce, $, a.id, A.layoutVertexBuffer, A.indexBuffer, A.segments, a.paint, d.transform.zoom, R)
        }

        function $o(d, e, a, o, u) {
          const p = d.context,
            g = p.gl,
            w = d.transform;
          p.setColorMode(d.colorModeForRenderPass());
          const I = au(p, e),
            A = a.key,
            L = e.heatmapFbos.get(A);
          if (!L) return;
          p.activeTexture.set(g.TEXTURE0), g.bindTexture(g.TEXTURE_2D, L.colorAttachment.get()), p.activeTexture.set(g.TEXTURE1), I.bind(g.LINEAR, g.CLAMP_TO_EDGE);
          const O = w.getProjectionData({
            overscaledTileID: a,
            applyTerrainMatrix: u,
            applyGlobeMatrix: !o
          });
          d.useProgram("heatmapTexture").draw(p, g.TRIANGLES, Si.disabled, Fi.disabled, d.colorModeForRenderPass(), Ti.disabled, Gc(d, e, 0, 1), null, O, e.id, d.rasterBoundsBuffer, d.quadTriangleIndexBuffer, d.rasterBoundsSegments, e.paint, w.zoom), L.destroy(), e.heatmapFbos.delete(A)
        }

        function ad(d, e, a) {
          var o, u;
          const p = d.gl,
            g = p.createTexture();
          p.bindTexture(p.TEXTURE_2D, g), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, p.CLAMP_TO_EDGE), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, p.CLAMP_TO_EDGE), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, p.LINEAR), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, p.LINEAR);
          const w = (o = d.HALF_FLOAT) !== null && o !== void 0 ? o : p.UNSIGNED_BYTE,
            I = (u = d.RGBA16F) !== null && u !== void 0 ? u : p.RGBA;
          p.texImage2D(p.TEXTURE_2D, 0, I, e, a, 0, p.RGBA, w, null);
          const A = d.createFramebuffer(e, a, !1, !1);
          return A.colorAttachment.set(g), A
        }

        function au(d, e) {
          return e.colorRampTexture || (e.colorRampTexture = new s.T(d, e.colorRamp, d.gl.RGBA)), e.colorRampTexture
        }

        function Qo(d, e, a, o, u, p, g, w) {
          let I = 256;
          if (u.stepInterpolant) {
            const A = e.getSource().maxzoom,
              L = g.canonical.z === A ? Math.ceil(1 << d.transform.maxZoom - g.canonical.z) : 1;
            I = s.ai(s.c7(p.maxLineLength / s.a3 * 1024 * L), 256, a.maxTextureSize)
          }
          return w.gradient = s.c8({
            expression: u.gradientExpression(),
            evaluationKey: "lineProgress",
            resolution: I,
            image: w.gradient || void 0,
            clips: p.lineClipsArray
          }), w.texture ? w.texture.update(w.gradient) : w.texture = new s.T(a, w.gradient, o.RGBA), w.version = u.gradientVersion, w.texture
        }

        function nu(d, e, a, o, u) {
          d.activeTexture.set(e.TEXTURE0), a.imageAtlasTexture.bind(e.LINEAR, e.CLAMP_TO_EDGE), o.updatePaintBuffers(u)
        }

        function nd(d, e, a, o, u, p) {
          (u || d.lineAtlas.dirty) && (e.activeTexture.set(a.TEXTURE0), d.lineAtlas.bind(e)), o.updatePaintBuffers(p)
        }

        function sd(d, e, a, o, u, p, g) {
          const w = p.gradients[u.id];
          let I = w.texture;
          u.gradientVersion !== w.version && (I = Qo(d, e, a, o, u, p, g, w)), a.activeTexture.set(o.TEXTURE0), I.bind(u.stepInterpolant ? o.NEAREST : o.LINEAR, o.CLAMP_TO_EDGE)
        }

        function Zl(d, e, a, o, u, p, g, w, I) {
          const A = p.gradients[u.id];
          let L = A.texture;
          u.gradientVersion !== A.version && (L = Qo(d, e, a, o, u, p, g, A)), a.activeTexture.set(o.TEXTURE0), L.bind(u.stepInterpolant ? o.NEAREST : o.LINEAR, o.CLAMP_TO_EDGE), a.activeTexture.set(o.TEXTURE1), d.lineAtlas.bind(a), w.updatePaintBuffers(I)
        }

        function Gl(d, e, a, o, u) {
          if (!a || !o || !o.imageAtlas) return;
          const p = o.imageAtlas.patternPositions;
          let g = p[a.to.toString()],
            w = p[a.from.toString()];
          if (!g && w && (g = w), !w && g && (w = g), !g || !w) {
            const I = u.getPaintProperty(e);
            g = p[I], w = p[I]
          }
          g && w && d.setConstantPatternPositions(g, w)
        }

        function od(d, e, a, o, u, p, g, w) {
          const I = d.context.gl,
            A = "fill-pattern",
            L = a.paint.get(A),
            O = L && L.constantOr(1),
            R = a.getCrossfadeParameters();
          let H, $, ce, ue, de;
          const Ce = d.transform,
            Be = a.paint.get("fill-translate"),
            Ie = a.paint.get("fill-translate-anchor");
          g ? ($ = O && !a.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", H = I.LINES) : ($ = O ? "fillPattern" : "fill", H = I.TRIANGLES);
          const Oe = L.constantOr(null);
          for (const He of o) {
            const Le = e.getTile(He);
            if (O && !Le.patternsLoaded()) continue;
            const $e = Le.getBucket(a);
            if (!$e) continue;
            const vt = $e.programConfigurations.get(a.id),
              ft = d.useProgram($, vt),
              gt = d.style.map.terrain && d.style.map.terrain.getTerrainData(He);
            O && (d.context.activeTexture.set(I.TEXTURE0), Le.imageAtlasTexture.bind(I.LINEAR, I.CLAMP_TO_EDGE), vt.updatePaintBuffers(R)), Gl(vt, A, Oe, Le, a);
            const xt = Ce.getProjectionData({
                overscaledTileID: He,
                applyGlobeMatrix: !w,
                applyTerrainMatrix: !0
              }),
              lr = s.aH(Ce, Le, Be, Ie);
            if (g) {
              ue = $e.indexBuffer2, de = $e.segments2;
              const Nt = [I.drawingBufferWidth, I.drawingBufferHeight];
              ce = $ === "fillOutlinePattern" && O ? Nh(d, R, Le, Nt, lr) : Hp(Nt, lr)
            } else ue = $e.indexBuffer, de = $e.segments, ce = O ? js(d, R, Le, lr) : {
              u_fill_translate: lr
            };
            const cr = d.stencilModeForClipping(He);
            ft.draw(d.context, H, u, cr, p, Ti.backCCW, ce, gt, xt, a.id, $e.layoutVertexBuffer, ue, de, a.paint, d.transform.zoom, vt)
          }
        }

        function Wl(d, e, a, o, u, p, g, w) {
          const I = d.context,
            A = I.gl,
            L = "fill-extrusion-pattern",
            O = a.paint.get(L),
            R = O.constantOr(1),
            H = a.getCrossfadeParameters(),
            $ = a.paint.get("fill-extrusion-opacity"),
            ce = O.constantOr(null),
            ue = d.transform;
          for (const de of o) {
            const Ce = e.getTile(de),
              Be = Ce.getBucket(a);
            if (!Be) continue;
            const Ie = d.style.map.terrain && d.style.map.terrain.getTerrainData(de),
              Oe = Be.programConfigurations.get(a.id),
              He = d.useProgram(R ? "fillExtrusionPattern" : "fillExtrusion", Oe);
            R && (d.context.activeTexture.set(A.TEXTURE0), Ce.imageAtlasTexture.bind(A.LINEAR, A.CLAMP_TO_EDGE), Oe.updatePaintBuffers(H));
            const Le = ue.getProjectionData({
              overscaledTileID: de,
              applyGlobeMatrix: !w,
              applyTerrainMatrix: !0
            });
            Gl(Oe, L, ce, Ce, a);
            const $e = s.aH(ue, Ce, a.paint.get("fill-extrusion-translate"), a.paint.get("fill-extrusion-translate-anchor")),
              vt = a.paint.get("fill-extrusion-vertical-gradient"),
              ft = R ? Wp(d, vt, $, $e, de, H, Ce) : Ho(d, vt, $, $e);
            He.draw(I, I.gl.TRIANGLES, u, p, g, Ti.backCCW, ft, Ie, Le, a.id, Be.layoutVertexBuffer, Be.indexBuffer, Be.segments, a.paint, d.transform.zoom, Oe, d.style.map.terrain && Be.centroidVertexBuffer)
          }
        }

        function ga(d, e, a, o, u, p, g, w, I) {
          var A;
          const L = d.style.projection,
            O = d.context,
            R = d.transform,
            H = O.gl,
            $ = [`#define NUM_ILLUMINATION_SOURCES ${a.paint.get("hillshade-highlight-color").values.length}`],
            ce = d.useProgram("hillshade", null, !1, $),
            ue = !d.options.moving;
          for (const de of o) {
            const Ce = e.getTile(de),
              Be = Ce.fbo;
            if (!Be) continue;
            const Ie = L.getMeshFromTileID(O, de.canonical, w, !0, "raster"),
              Oe = (A = d.style.map.terrain) === null || A === void 0 ? void 0 : A.getTerrainData(de);
            O.activeTexture.set(H.TEXTURE0), H.bindTexture(H.TEXTURE_2D, Be.colorAttachment.get());
            const He = R.getProjectionData({
              overscaledTileID: de,
              aligned: ue,
              applyGlobeMatrix: !I,
              applyTerrainMatrix: !0
            });
            ce.draw(O, H.TRIANGLES, p, u[de.overscaledZ], g, Ti.backCCW, Uh(d, Ce, a), Oe, He, a.id, Ie.vertexBuffer, Ie.indexBuffer, Ie.segments)
          }
        }

        function us(d, e, a, o, u, p, g, w, I) {
          var A;
          const L = d.style.projection,
            O = d.context,
            R = d.transform,
            H = O.gl,
            $ = d.useProgram("colorRelief"),
            ce = !d.options.moving;
          let ue = !0,
            de = 0;
          for (const Ce of o) {
            const Be = e.getTile(Ce),
              Ie = Be.dem;
            if (ue) {
              const ft = H.getParameter(H.MAX_TEXTURE_SIZE),
                {
                  elevationTexture: gt,
                  colorTexture: xt
                } = a.getColorRampTextures(O, ft, Ie.getUnpackVector());
              O.activeTexture.set(H.TEXTURE1), gt.bind(H.NEAREST, H.CLAMP_TO_EDGE), O.activeTexture.set(H.TEXTURE4), xt.bind(H.LINEAR, H.CLAMP_TO_EDGE), ue = !1, de = gt.size[0]
            }
            if (!Ie || !Ie.data) continue;
            const Oe = Ie.stride,
              He = Ie.getPixels();
            if (O.activeTexture.set(H.TEXTURE0), O.pixelStoreUnpackPremultiplyAlpha.set(!1), Be.demTexture = Be.demTexture || d.getTileTexture(Oe), Be.demTexture) {
              const ft = Be.demTexture;
              ft.update(He, {
                premultiply: !1
              }), ft.bind(H.LINEAR, H.CLAMP_TO_EDGE)
            } else Be.demTexture = new s.T(O, He, H.RGBA, {
              premultiply: !1
            }), Be.demTexture.bind(H.LINEAR, H.CLAMP_TO_EDGE);
            const Le = L.getMeshFromTileID(O, Ce.canonical, w, !0, "raster"),
              $e = (A = d.style.map.terrain) === null || A === void 0 ? void 0 : A.getTerrainData(Ce),
              vt = R.getProjectionData({
                overscaledTileID: Ce,
                aligned: ce,
                applyGlobeMatrix: !I,
                applyTerrainMatrix: !0
              });
            $.draw(O, H.TRIANGLES, p, u[Ce.overscaledZ], g, Ti.backCCW, Gh(a, Be.dem, de), $e, vt, a.id, Le.vertexBuffer, Le.indexBuffer, Le.segments)
          }
        }
        const fn = [new s.P(0, 0), new s.P(s.a3, 0), new s.P(s.a3, s.a3), new s.P(0, s.a3)];

        function So(d, e, a, o, u, p, g, w, I = !1, A = !1) {
          const L = o[o.length - 1].overscaledZ,
            O = d.context,
            R = O.gl,
            H = d.useProgram("raster"),
            $ = d.transform,
            ce = d.style.projection,
            ue = d.colorModeForRenderPass(),
            de = !d.options.moving,
            Ce = a.paint.get("raster-opacity"),
            Be = a.paint.get("raster-resampling"),
            Ie = a.paint.get("raster-fade-duration"),
            Oe = !!d.style.map.terrain;
          for (const He of o) {
            const Le = d.getDepthModeForSublayer(He.overscaledZ - L, Ce === 1 ? Si.ReadWrite : Si.ReadOnly, R.LESS),
              $e = e.getTile(He),
              vt = Be === "nearest" ? R.NEAREST : R.LINEAR;
            O.activeTexture.set(R.TEXTURE0), $e.texture.bind(vt, R.CLAMP_TO_EDGE, R.LINEAR_MIPMAP_NEAREST), O.activeTexture.set(R.TEXTURE1);
            const {
              parentTile: ft,
              parentScaleBy: gt,
              parentTopLeft: xt,
              fadeValues: lr
            } = Hl($e, e, Ie, Oe);
            $e.fadeOpacity = lr.tileOpacity, ft ? (ft.fadeOpacity = lr.parentTileOpacity, ft.texture.bind(vt, R.CLAMP_TO_EDGE, R.LINEAR_MIPMAP_NEAREST)) : $e.texture.bind(vt, R.CLAMP_TO_EDGE, R.LINEAR_MIPMAP_NEAREST), $e.texture.useMipmap && O.extTextureFilterAnisotropic && d.transform.pitch > 20 && R.texParameterf(R.TEXTURE_2D, O.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, O.extTextureFilterAnisotropicMax);
            const cr = d.style.map.terrain && d.style.map.terrain.getTerrainData(He),
              Nt = $.getProjectionData({
                overscaledTileID: He,
                aligned: de,
                applyGlobeMatrix: !A,
                applyTerrainMatrix: !0
              }),
              Nr = Wh(xt, gt, lr.fadeMix, a, w),
              Pi = ce.getMeshFromTileID(O, He.canonical, p, g, "raster");
            H.draw(O, R.TRIANGLES, Le, u ? u[He.overscaledZ] : Fi.disabled, ue, I ? Ti.frontCCW : Ti.backCCW, Nr, cr, Nt, a.id, Pi.vertexBuffer, Pi.indexBuffer, Pi.segments)
          }
        }

        function Hl(d, e, a, o) {
          const u = {
            parentTile: null,
            parentScaleBy: 1,
            parentTopLeft: [0, 0],
            fadeValues: {
              tileOpacity: 1,
              parentTileOpacity: 1,
              fadeMix: {
                opacity: 1,
                mix: 0
              }
            }
          };
          if (a === 0 || o) return u;
          if (d.fadingParentID) {
            const p = e.getLoadedTile(d.fadingParentID);
            if (!p) return u;
            const g = Math.pow(2, p.tileID.overscaledZ - d.tileID.overscaledZ),
              w = [d.tileID.canonical.x * g % 1, d.tileID.canonical.y * g % 1],
              I = (function(A, L, O) {
                const R = me(),
                  H = (R - L.timeAdded) / O,
                  $ = A.fadingDirection === se.Incoming,
                  ce = s.ai((R - A.timeAdded) / O, 0, 1),
                  ue = s.ai(1 - H, 0, 1),
                  de = $ ? ce : ue;
                return {
                  tileOpacity: de,
                  parentTileOpacity: $ ? ue : ce,
                  fadeMix: {
                    opacity: 1,
                    mix: 1 - de
                  }
                }
              })(d, p, a);
            return {
              parentTile: p,
              parentScaleBy: g,
              parentTopLeft: w,
              fadeValues: I
            }
          }
          if (d.selfFading) {
            const p = (function(g, w) {
              const I = (me() - g.timeAdded) / w,
                A = s.ai(I, 0, 1);
              return {
                tileOpacity: A,
                fadeMix: {
                  opacity: A,
                  mix: 0
                }
              }
            })(d, a);
            return {
              parentTile: null,
              parentScaleBy: 1,
              parentTopLeft: [0, 0],
              fadeValues: p
            }
          }
          return u
        }
        const ld = new s.bi(1, 0, 0, 1),
          Po = new s.bi(0, 1, 0, 1),
          su = new s.bi(0, 0, 1, 1),
          el = new s.bi(1, 0, 1, 1),
          ou = new s.bi(0, 1, 1, 1);

        function lu(d, e, a, o) {
          tl(d, 0, e + a / 2, d.transform.width, a, o)
        }

        function cu(d, e, a, o) {
          tl(d, e - a / 2, 0, a, d.transform.height, o)
        }

        function tl(d, e, a, o, u, p) {
          const g = d.context,
            w = g.gl;
          w.enable(w.SCISSOR_TEST), w.scissor(e * d.pixelRatio, a * d.pixelRatio, o * d.pixelRatio, u * d.pixelRatio), g.clear({
            color: p
          }), w.disable(w.SCISSOR_TEST)
        }

        function cd(d, e, a) {
          const o = d.context,
            u = o.gl,
            p = d.useProgram("debug"),
            g = Si.disabled,
            w = Fi.disabled,
            I = d.colorModeForRenderPass(),
            A = "$debug",
            L = d.style.map.terrain && d.style.map.terrain.getTerrainData(a);
          o.activeTexture.set(u.TEXTURE0);
          const O = e.getTileByID(a.key).latestRawTileData,
            R = Math.floor((O && O.byteLength || 0) / 1024),
            H = e.getTile(a).tileSize,
            $ = 512 / Math.min(H, 512) * (a.overscaledZ / d.transform.zoom) * .5;
          let ce = a.canonical.toString();
          a.overscaledZ !== a.canonical.z && (ce += ` => ${a.overscaledZ}`), (function(de, Ce) {
            de.initDebugOverlayCanvas();
            const Be = de.debugOverlayCanvas,
              Ie = de.context.gl,
              Oe = de.debugOverlayCanvas.getContext("2d");
            Oe.clearRect(0, 0, Be.width, Be.height), Oe.shadowColor = "white", Oe.shadowBlur = 2, Oe.lineWidth = 1.5, Oe.strokeStyle = "white", Oe.textBaseline = "top", Oe.font = "bold 36px Open Sans, sans-serif", Oe.fillText(Ce, 5, 5), Oe.strokeText(Ce, 5, 5), de.debugOverlayTexture.update(Be), de.debugOverlayTexture.bind(Ie.LINEAR, Ie.CLAMP_TO_EDGE)
          })(d, `${ce} ${R}kB`);
          const ue = d.transform.getProjectionData({
            overscaledTileID: a,
            applyGlobeMatrix: !0,
            applyTerrainMatrix: !0
          });
          p.draw(o, u.TRIANGLES, g, w, Mi.alphaBlended, Ti.disabled, Uc(s.bi.transparent, $), null, ue, A, d.debugBuffer, d.quadTriangleIndexBuffer, d.debugSegments), p.draw(o, u.LINE_STRIP, g, w, I, Ti.disabled, Uc(s.bi.red), L, ue, A, d.debugBuffer, d.tileBorderIndexBuffer, d.debugSegments)
        }

        function uu(d, e, a, o) {
          const {
            isRenderingGlobe: u
          } = o, p = d.context, g = p.gl, w = d.transform, I = d.colorModeForRenderPass(), A = d.getDepthModeFor3D(), L = d.useProgram("terrain");
          p.bindFramebuffer.set(null), p.viewport.set([0, 0, d.width, d.height]);
          for (const O of a) {
            const R = e.getTerrainMesh(O.tileID),
              H = d.renderToTexture.getTexture(O),
              $ = e.getTerrainData(O.tileID);
            p.activeTexture.set(g.TEXTURE0), g.bindTexture(g.TEXTURE_2D, H.texture);
            const ce = e.getMeshFrameDelta(w.zoom),
              ue = w.calculateFogMatrix(O.tileID.toUnwrapped()),
              de = Gp(ce, ue, d.style.sky, w.pitch, u),
              Ce = w.getProjectionData({
                overscaledTileID: O.tileID,
                applyTerrainMatrix: !1,
                applyGlobeMatrix: !0
              });
            L.draw(p, g.TRIANGLES, A, Fi.disabled, I, Ti.backCCW, de, $, Ce, "terrain", R.vertexBuffer, R.indexBuffer, R.segments)
          }
        }

        function Ms(d, e) {
          if (!e.mesh) {
            const a = new s.aP;
            a.emplaceBack(-1, -1), a.emplaceBack(1, -1), a.emplaceBack(1, 1), a.emplaceBack(-1, 1);
            const o = new s.aR;
            o.emplaceBack(0, 1, 2), o.emplaceBack(0, 2, 3), e.mesh = new Xi(d.createVertexBuffer(a, Vi.members), d.createIndexBuffer(o), s.aQ.simpleSegment(0, 0, a.length, o.length))
          }
          return e.mesh
        }
        class ud {
          constructor(e, a) {
            this.context = new jl(e), this.transform = a, this._tileTextures = {}, this.terrainFacilitator = {
              dirty: !0,
              matrix: s.am(new Float64Array(16)),
              renderTime: 0
            }, this.setup(), this.numSublayers = Lt.maxUnderzooming + Lt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Cr
          }
          resize(e, a, o) {
            if (this.width = Math.floor(e * o), this.height = Math.floor(a * o), this.pixelRatio = o, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
              for (const u of this.style._order) this.style._layers[u].resize()
          }
          setup() {
            const e = this.context,
              a = new s.aP;
            a.emplaceBack(0, 0), a.emplaceBack(s.a3, 0), a.emplaceBack(0, s.a3), a.emplaceBack(s.a3, s.a3), this.tileExtentBuffer = e.createVertexBuffer(a, Vi.members), this.tileExtentSegments = s.aQ.simpleSegment(0, 0, 4, 2);
            const o = new s.aP;
            o.emplaceBack(0, 0), o.emplaceBack(s.a3, 0), o.emplaceBack(0, s.a3), o.emplaceBack(s.a3, s.a3), this.debugBuffer = e.createVertexBuffer(o, Vi.members), this.debugSegments = s.aQ.simpleSegment(0, 0, 4, 5);
            const u = new s.ca;
            u.emplaceBack(0, 0, 0, 0), u.emplaceBack(s.a3, 0, s.a3, 0), u.emplaceBack(0, s.a3, 0, s.a3), u.emplaceBack(s.a3, s.a3, s.a3, s.a3), this.rasterBoundsBuffer = e.createVertexBuffer(u, qc.members), this.rasterBoundsSegments = s.aQ.simpleSegment(0, 0, 4, 2);
            const p = new s.aP;
            p.emplaceBack(0, 0), p.emplaceBack(s.a3, 0), p.emplaceBack(0, s.a3), p.emplaceBack(s.a3, s.a3), this.rasterBoundsBufferPosOnly = e.createVertexBuffer(p, Vi.members), this.rasterBoundsSegmentsPosOnly = s.aQ.simpleSegment(0, 0, 4, 5);
            const g = new s.aP;
            g.emplaceBack(0, 0), g.emplaceBack(1, 0), g.emplaceBack(0, 1), g.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(g, Vi.members), this.viewportSegments = s.aQ.simpleSegment(0, 0, 4, 2);
            const w = new s.cb;
            w.emplaceBack(0), w.emplaceBack(1), w.emplaceBack(3), w.emplaceBack(2), w.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(w);
            const I = new s.aR;
            I.emplaceBack(1, 0, 2), I.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(I);
            const A = this.context.gl;
            this.stencilClearMode = new Fi({
              func: A.ALWAYS,
              mask: 0
            }, 0, 255, A.ZERO, A.ZERO, A.ZERO), this.tileExtentMesh = new Xi(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments)
          }
          clearStencil() {
            const e = this.context,
              a = e.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const o = s.M();
            s.c0(o, 0, this.width, this.height, 0, 0, 1), s.O(o, o, [a.drawingBufferWidth, a.drawingBufferHeight, 0]);
            const u = {
              mainMatrix: o,
              tileMercatorCoords: [0, 0, 1, 1],
              clippingPlane: [0, 0, 0, 0],
              projectionTransition: 0,
              fallbackMatrix: o
            };
            this.useProgram("clippingMask", null, !0).draw(e, a.TRIANGLES, Si.disabled, this.stencilClearMode, Mi.disabled, Ti.disabled, null, null, u, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments)
          }
          _renderTileClippingMasks(e, a, o) {
            if (this.currentStencilSource === e.source || !e.isTileClipped() || !a || !a.length) return;
            this.currentStencilSource = e.source, this.nextStencilID + a.length > 256 && this.clearStencil();
            const u = this.context;
            u.setColorMode(Mi.disabled), u.setDepthMode(Si.disabled);
            const p = {};
            for (const g of a) p[g.key] = this.nextStencilID++;
            this._renderTileMasks(p, a, o, !0), this._renderTileMasks(p, a, o, !1), this._tileClippingMaskIDs = p
          }
          _renderTileMasks(e, a, o, u) {
            const p = this.context,
              g = p.gl,
              w = this.style.projection,
              I = this.transform,
              A = this.useProgram("clippingMask");
            for (const L of a) {
              const O = e[L.key],
                R = this.style.map.terrain && this.style.map.terrain.getTerrainData(L),
                H = w.getMeshFromTileID(this.context, L.canonical, u, !0, "stencil"),
                $ = I.getProjectionData({
                  overscaledTileID: L,
                  applyGlobeMatrix: !o,
                  applyTerrainMatrix: !0
                });
              A.draw(p, g.TRIANGLES, Si.disabled, new Fi({
                func: g.ALWAYS,
                mask: 0
              }, O, 255, g.KEEP, g.KEEP, g.REPLACE), Mi.disabled, o ? Ti.disabled : Ti.backCCW, null, R, $, "$clipping", H.vertexBuffer, H.indexBuffer, H.segments)
            }
          }
          _renderTilesDepthBuffer() {
            const e = this.context,
              a = e.gl,
              o = this.style.projection,
              u = this.transform,
              p = this.useProgram("depth"),
              g = this.getDepthModeFor3D(),
              w = it(u, {
                tileSize: u.tileSize
              });
            for (const I of w) {
              const A = this.style.map.terrain && this.style.map.terrain.getTerrainData(I),
                L = o.getMeshFromTileID(this.context, I.canonical, !0, !0, "raster"),
                O = u.getProjectionData({
                  overscaledTileID: I,
                  applyGlobeMatrix: !0,
                  applyTerrainMatrix: !0
                });
              p.draw(e, a.TRIANGLES, g, Fi.disabled, Mi.disabled, Ti.backCCW, null, A, O, "$clipping", L.vertexBuffer, L.indexBuffer, L.segments)
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const e = this.nextStencilID++,
              a = this.context.gl;
            return new Fi({
              func: a.NOTEQUAL,
              mask: 255
            }, e, 255, a.KEEP, a.KEEP, a.REPLACE)
          }
          stencilModeForClipping(e) {
            const a = this.context.gl;
            return new Fi({
              func: a.EQUAL,
              mask: 255
            }, this._tileClippingMaskIDs[e.key], 0, a.KEEP, a.KEEP, a.REPLACE)
          }
          getStencilConfigForOverlapAndUpdateStencilID(e) {
            const a = this.context.gl,
              o = e.sort(((g, w) => w.overscaledZ - g.overscaledZ)),
              u = o[o.length - 1].overscaledZ,
              p = o[0].overscaledZ - u + 1;
            if (p > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + p > 256 && this.clearStencil();
              const g = {};
              for (let w = 0; w < p; w++) g[w + u] = new Fi({
                func: a.GEQUAL,
                mask: 255
              }, w + this.nextStencilID, 255, a.KEEP, a.KEEP, a.REPLACE);
              return this.nextStencilID += p, [g, o]
            }
            return [{
              [u]: Fi.disabled
            }, o]
          }
          stencilConfigForOverlapTwoPass(e) {
            const a = this.context.gl,
              o = e.sort(((g, w) => w.overscaledZ - g.overscaledZ)),
              u = o[o.length - 1].overscaledZ,
              p = o[0].overscaledZ - u + 1;
            if (this.clearStencil(), p > 1) {
              const g = {},
                w = {};
              for (let I = 0; I < p; I++) g[I + u] = new Fi({
                func: a.GREATER,
                mask: 255
              }, p + 1 + I, 255, a.KEEP, a.KEEP, a.REPLACE), w[I + u] = new Fi({
                func: a.GREATER,
                mask: 255
              }, 1 + I, 255, a.KEEP, a.KEEP, a.REPLACE);
              return this.nextStencilID = 2 * p + 1, [g, w, o]
            }
            return this.nextStencilID = 3, [{
              [u]: new Fi({
                func: a.GREATER,
                mask: 255
              }, 2, 255, a.KEEP, a.KEEP, a.REPLACE)
            }, {
              [u]: new Fi({
                func: a.GREATER,
                mask: 255
              }, 1, 255, a.KEEP, a.KEEP, a.REPLACE)
            }, o]
          }
          colorModeForRenderPass() {
            const e = this.context.gl;
            return this._showOverdrawInspector ? new Mi([e.CONSTANT_COLOR, e.ONE], new s.bi(.125, .125, .125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? Mi.unblended : Mi.alphaBlended
          }
          getDepthModeForSublayer(e, a, o) {
            if (!this.opaquePassEnabledForLayer()) return Si.disabled;
            const u = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
            return new Si(o || this.context.gl.LEQUAL, a, [u, u])
          }
          getDepthModeFor3D() {
            return new Si(this.context.gl.LEQUAL, Si.ReadWrite, this.depthRangeFor3D)
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff
          }
          render(e, a) {
            var o, u;
            this.style = e, this.options = a, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(me()), this.imageManager.beginFrame();
            const p = this.style._order,
              g = this.style.tileManagers,
              w = {},
              I = {},
              A = {},
              L = {
                isRenderingToTexture: !1,
                isRenderingGlobe: ((o = e.projection) === null || o === void 0 ? void 0 : o.transitionState) > 0
              };
            for (const R in g) {
              const H = g[R];
              H.used && H.prepare(this.context), w[R] = H.getVisibleCoordinates(!1), I[R] = w[R].slice().reverse(), A[R] = H.getVisibleCoordinates(!0).reverse()
            }
            this.opaquePassCutoff = 1 / 0;
            for (let R = 0; R < p.length; R++)
              if (this.style._layers[p[R]].is3D()) {
                this.opaquePassCutoff = R;
                break
              } this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const R of p) {
              const H = this.style._layers[R];
              if (!H.hasOffscreenPass() || H.isHidden(this.transform.zoom)) continue;
              const $ = I[H.source];
              (H.type === "custom" || $.length) && this.renderLayer(this, g[H.source], H, $, L)
            }
            if ((u = this.style.projection) === null || u === void 0 || u.updateGPUdependent({
                context: this.context,
                useProgram: R => this.useProgram(R)
              }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({
                color: a.showOverdrawInspector ? s.bi.black : s.bi.transparent,
                depth: 1
              }), this.clearStencil(), this.style.sky && (function(R, H) {
                const $ = R.context,
                  ce = $.gl,
                  ue = ((He, Le, $e) => {
                    const vt = Math.cos(Le.rollInRadians),
                      ft = Math.sin(Le.rollInRadians),
                      gt = ve(Le),
                      xt = Le.getProjectionData({
                        overscaledTileID: null,
                        applyGlobeMatrix: !0,
                        applyTerrainMatrix: !0
                      }).projectionTransition;
                    return {
                      u_sky_color: He.properties.get("sky-color"),
                      u_horizon_color: He.properties.get("horizon-color"),
                      u_horizon: [(Le.width / 2 - gt * ft) * $e, (Le.height / 2 + gt * vt) * $e],
                      u_horizon_normal: [-ft, vt],
                      u_sky_horizon_blend: He.properties.get("sky-horizon-blend") * Le.height / 2 * $e,
                      u_sky_blend: xt
                    }
                  })(H, R.style.map.transform, R.pixelRatio),
                  de = new Si(ce.LEQUAL, Si.ReadWrite, [0, 1]),
                  Ce = Fi.disabled,
                  Be = R.colorModeForRenderPass(),
                  Ie = R.useProgram("sky"),
                  Oe = Ms($, H);
                Ie.draw($, ce.TRIANGLES, de, Ce, Be, Ti.disabled, ue, null, void 0, "sky", Oe.vertexBuffer, Oe.indexBuffer, Oe.segments)
              })(this, this.style.sky), this._showOverdrawInspector = a.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture)
              for (this.renderPass = "opaque", this.currentLayer = p.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                const R = this.style._layers[p[this.currentLayer]],
                  H = g[R.source],
                  $ = w[R.source];
                this._renderTileClippingMasks(R, $, !1), this.renderLayer(this, H, R, $, L)
              }
            this.renderPass = "translucent";
            let O = !1;
            for (this.currentLayer = 0; this.currentLayer < p.length; this.currentLayer++) {
              const R = this.style._layers[p[this.currentLayer]],
                H = g[R.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer(R, L)) continue;
              this.opaquePassEnabledForLayer() || O || (O = !0, L.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
              const $ = (R.type === "symbol" ? A : I)[R.source];
              this._renderTileClippingMasks(R, w[R.source], !!this.renderToTexture), this.renderLayer(this, H, R, $, L)
            }
            if (L.isRenderingGlobe && (function(R, H, $) {
                const ce = R.context,
                  ue = ce.gl,
                  de = R.useProgram("atmosphere"),
                  Ce = new Si(ue.LEQUAL, Si.ReadOnly, [0, 1]),
                  Be = R.transform,
                  Ie = (function(xt, lr) {
                    const cr = xt.properties.get("position"),
                      Nt = [-cr.x, -cr.y, -cr.z],
                      Nr = s.am(new Float64Array(16));
                    return xt.properties.get("anchor") === "map" && (s.b9(Nr, Nr, lr.rollInRadians), s.ba(Nr, Nr, -lr.pitchInRadians), s.b9(Nr, Nr, lr.bearingInRadians), s.ba(Nr, Nr, lr.center.lat * Math.PI / 180), s.bC(Nr, Nr, -lr.center.lng * Math.PI / 180)), s.c9(Nt, Nt, Nr), Nt
                  })($, R.transform),
                  Oe = Be.getProjectionData({
                    overscaledTileID: null,
                    applyGlobeMatrix: !0,
                    applyTerrainMatrix: !0
                  }),
                  He = H.properties.get("atmosphere-blend") * Oe.projectionTransition;
                if (He === 0) return;
                const Le = Nn(Be.worldSize, Be.center.lat),
                  $e = Be.inverseProjectionMatrix,
                  vt = new Float64Array(4);
                vt[3] = 1, s.aA(vt, vt, Be.modelViewProjectionMatrix), vt[0] /= vt[3], vt[1] /= vt[3], vt[2] /= vt[3], vt[3] = 1, s.aA(vt, vt, $e), vt[0] /= vt[3], vt[1] /= vt[3], vt[2] /= vt[3], vt[3] = 1;
                const ft = ((xt, lr, cr, Nt, Nr) => ({
                    u_sun_pos: xt,
                    u_atmosphere_blend: lr,
                    u_globe_position: cr,
                    u_globe_radius: Nt,
                    u_inv_proj_matrix: Nr
                  }))(Ie, He, [vt[0], vt[1], vt[2]], Le, $e),
                  gt = Ms(ce, H);
                de.draw(ce, ue.TRIANGLES, Ce, Fi.disabled, Mi.alphaBlended, Ti.disabled, ft, null, null, "atmosphere", gt.vertexBuffer, gt.indexBuffer, gt.segments)
              })(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
              const R = (function(H, $) {
                let ce = null;
                const ue = Object.values(H._layers).flatMap((Ie => Ie.source && !Ie.isHidden($) ? [H.tileManagers[Ie.source]] : [])),
                  de = ue.filter((Ie => Ie.getSource().type === "vector")),
                  Ce = ue.filter((Ie => Ie.getSource().type !== "vector")),
                  Be = Ie => {
                    (!ce || ce.getSource().maxzoom < Ie.getSource().maxzoom) && (ce = Ie)
                  };
                return de.forEach((Ie => Be(Ie))), ce || Ce.forEach((Ie => Be(Ie))), ce
              })(this.style, this.transform.zoom);
              R && (function(H, $, ce) {
                for (let ue = 0; ue < ce.length; ue++) cd(H, $, ce[ue])
              })(this, R, R.getVisibleCoordinates())
            }
            this.options.showPadding && (function(R) {
              const H = R.transform.padding;
              lu(R, R.transform.height - (H.top || 0), 3, ld), lu(R, H.bottom || 0, 3, Po), cu(R, H.left || 0, 3, su), cu(R, R.transform.width - (H.right || 0), 3, el);
              const $ = R.transform.centerPoint;
              (function(ce, ue, de, Ce) {
                tl(ce, ue - 1, de - 10, 2, 20, Ce), tl(ce, ue - 10, de - 1, 20, 2, Ce)
              })(R, $.x, R.transform.height - $.y, ou)
            })(this), this.context.setDefault()
          }
          maybeDrawDepthAndCoords(e) {
            if (!this.style || !this.style.map || !this.style.map.terrain) return;
            const a = this.terrainFacilitator.matrix,
              o = this.transform.modelViewProjectionMatrix;
            let u = this.terrainFacilitator.dirty;
            u || (u = e ? !s.cc(a, o) : !s.cd(a, o)), u || (u = this.style.map.terrain.tileManager.anyTilesAfterTime(this.terrainFacilitator.renderTime)), u && (s.ce(a, o), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, (function(p, g) {
              const w = p.context,
                I = w.gl,
                A = p.transform,
                L = Mi.unblended,
                O = new Si(I.LEQUAL, Si.ReadWrite, [0, 1]),
                R = g.tileManager.getRenderableTiles(),
                H = p.useProgram("terrainDepth");
              w.bindFramebuffer.set(g.getFramebuffer("depth").framebuffer), w.viewport.set([0, 0, p.width / devicePixelRatio, p.height / devicePixelRatio]), w.clear({
                color: s.bi.transparent,
                depth: 1
              });
              for (const $ of R) {
                const ce = g.getTerrainMesh($.tileID),
                  ue = g.getTerrainData($.tileID),
                  de = A.getProjectionData({
                    overscaledTileID: $.tileID,
                    applyTerrainMatrix: !1,
                    applyGlobeMatrix: !0
                  }),
                  Ce = {
                    u_ele_delta: g.getMeshFrameDelta(A.zoom)
                  };
                H.draw(w, I.TRIANGLES, O, Fi.disabled, L, Ti.backCCW, Ce, ue, de, "terrain", ce.vertexBuffer, ce.indexBuffer, ce.segments)
              }
              w.bindFramebuffer.set(null), w.viewport.set([0, 0, p.width, p.height])
            })(this, this.style.map.terrain), (function(p, g) {
              const w = p.context,
                I = w.gl,
                A = p.transform,
                L = Mi.unblended,
                O = new Si(I.LEQUAL, Si.ReadWrite, [0, 1]),
                R = g.getCoordsTexture(),
                H = g.tileManager.getRenderableTiles(),
                $ = p.useProgram("terrainCoords");
              w.bindFramebuffer.set(g.getFramebuffer("coords").framebuffer), w.viewport.set([0, 0, p.width / devicePixelRatio, p.height / devicePixelRatio]), w.clear({
                color: s.bi.transparent,
                depth: 1
              }), g.coordsIndex = [];
              for (const ce of H) {
                const ue = g.getTerrainMesh(ce.tileID),
                  de = g.getTerrainData(ce.tileID);
                w.activeTexture.set(I.TEXTURE0), I.bindTexture(I.TEXTURE_2D, R.texture);
                const Ce = {
                    u_terrain_coords_id: (255 - g.coordsIndex.length) / 255,
                    u_texture: 0,
                    u_ele_delta: g.getMeshFrameDelta(A.zoom)
                  },
                  Be = A.getProjectionData({
                    overscaledTileID: ce.tileID,
                    applyTerrainMatrix: !1,
                    applyGlobeMatrix: !0
                  });
                $.draw(w, I.TRIANGLES, O, Fi.disabled, L, Ti.backCCW, Ce, de, Be, "terrain", ue.vertexBuffer, ue.indexBuffer, ue.segments), g.coordsIndex.push(ce.tileID.key)
              }
              w.bindFramebuffer.set(null), w.viewport.set([0, 0, p.width, p.height])
            })(this, this.style.map.terrain))
          }
          renderLayer(e, a, o, u, p) {
            o.isHidden(this.transform.zoom) || (o.type === "background" || o.type === "custom" || (u || []).length) && (this.id = o.id, s.cf(o) ? (function(g, w, I, A, L, O) {
              if (g.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: R
              } = O, H = Fi.disabled, $ = g.colorModeForRenderPass();
              (I._unevaluatedLayout.hasValue("text-variable-anchor") || I._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && (function(ce, ue, de, Ce, Be, Ie, Oe, He, Le) {
                const $e = ue.transform,
                  vt = ue.style.map.terrain,
                  ft = Be === "map",
                  gt = Ie === "map";
                for (const xt of ce) {
                  const lr = Ce.getTile(xt),
                    cr = lr.getBucket(de);
                  if (!cr || !cr.text || !cr.text.segments.get().length) continue;
                  const Nt = s.ar(cr.textSizeData, $e.zoom),
                    Nr = s.aG(lr, 1, ue.transform.zoom),
                    Pi = Wt(ft, ue.transform, Nr),
                    Qi = de.layout.get("icon-text-fit") !== "none" && cr.hasIconData();
                  if (Nt) {
                    const Li = Math.pow(2, $e.zoom - lr.tileID.overscaledZ),
                      ra = vt ? (va, na) => vt.getElevation(xt, va, na) : null;
                    Nl(cr, ft, gt, Le, $e, Pi, Li, Nt, Qi, s.aH($e, lr, Oe, He), xt.toUnwrapped(), ra)
                  }
                }
              })(A, g, I, w, I.layout.get("text-rotation-alignment"), I.layout.get("text-pitch-alignment"), I.paint.get("text-translate"), I.paint.get("text-translate-anchor"), L), I.paint.get("icon-opacity").constantOr(1) !== 0 && Ws(g, w, I, A, !1, I.paint.get("icon-translate"), I.paint.get("icon-translate-anchor"), I.layout.get("icon-rotation-alignment"), I.layout.get("icon-pitch-alignment"), I.layout.get("icon-keep-upright"), H, $, R), I.paint.get("text-opacity").constantOr(1) !== 0 && Ws(g, w, I, A, !0, I.paint.get("text-translate"), I.paint.get("text-translate-anchor"), I.layout.get("text-rotation-alignment"), I.layout.get("text-pitch-alignment"), I.layout.get("text-keep-upright"), H, $, R), w.map.showCollisionBoxes && (Jo(g, w, I, A, !0), Jo(g, w, I, A, !1))
            })(e, a, o, u, this.style.placement.variableOffsets, p) : s.cg(o) ? (function(g, w, I, A, L) {
              if (g.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: O
              } = L, R = I.paint.get("circle-opacity"), H = I.paint.get("circle-stroke-width"), $ = I.paint.get("circle-stroke-opacity"), ce = !I.layout.get("circle-sort-key").isConstant();
              if (R.constantOr(1) === 0 && (H.constantOr(1) === 0 || $.constantOr(1) === 0)) return;
              const ue = g.context,
                de = ue.gl,
                Ce = g.transform,
                Be = g.getDepthModeForSublayer(0, Si.ReadOnly),
                Ie = Fi.disabled,
                Oe = g.colorModeForRenderPass(),
                He = [],
                Le = Ce.getCircleRadiusCorrection();
              for (let $e = 0; $e < A.length; $e++) {
                const vt = A[$e],
                  ft = w.getTile(vt),
                  gt = ft.getBucket(I);
                if (!gt) continue;
                const xt = I.paint.get("circle-translate"),
                  lr = I.paint.get("circle-translate-anchor"),
                  cr = s.aH(Ce, ft, xt, lr),
                  Nt = gt.programConfigurations.get(I.id),
                  Nr = g.useProgram("circle", Nt),
                  Pi = gt.layoutVertexBuffer,
                  Qi = gt.indexBuffer,
                  Li = g.style.map.terrain && g.style.map.terrain.getTerrainData(vt),
                  ra = {
                    programConfiguration: Nt,
                    program: Nr,
                    layoutVertexBuffer: Pi,
                    indexBuffer: Qi,
                    uniformValues: Xp(g, ft, I, cr, Le),
                    terrainData: Li,
                    projectionData: Ce.getProjectionData({
                      overscaledTileID: vt,
                      applyGlobeMatrix: !O,
                      applyTerrainMatrix: !0
                    })
                  };
                if (ce) {
                  const va = gt.segments.get();
                  for (const na of va) He.push({
                    segments: new s.aQ([na]),
                    sortKey: na.sortKey,
                    state: ra
                  })
                } else He.push({
                  segments: gt.segments,
                  sortKey: 0,
                  state: ra
                })
              }
              ce && He.sort((($e, vt) => $e.sortKey - vt.sortKey));
              for (const $e of He) {
                const {
                  programConfiguration: vt,
                  program: ft,
                  layoutVertexBuffer: gt,
                  indexBuffer: xt,
                  uniformValues: lr,
                  terrainData: cr,
                  projectionData: Nt
                } = $e.state;
                ft.draw(ue, de.TRIANGLES, Be, Ie, Oe, Ti.backCCW, lr, cr, Nt, I.id, gt, xt, $e.segments, I.paint, g.transform.zoom, vt)
              }
            })(e, a, o, u, p) : s.ch(o) ? (function(g, w, I, A, L) {
              if (I.paint.get("heatmap-opacity") === 0) return;
              const O = g.context,
                {
                  isRenderingToTexture: R,
                  isRenderingGlobe: H
                } = L;
              if (g.style.map.terrain) {
                for (const $ of A) {
                  const ce = w.getTile($);
                  w.hasRenderableParent($) || (g.renderPass === "offscreen" ? sf(g, ce, I, $, H) : g.renderPass === "translucent" && $o(g, I, $, R, H))
                }
                O.viewport.set([0, 0, g.width, g.height])
              } else g.renderPass === "offscreen" ? (function($, ce, ue, de) {
                const Ce = $.context,
                  Be = Ce.gl,
                  Ie = $.transform,
                  Oe = Fi.disabled,
                  He = new Mi([Be.ONE, Be.ONE], s.bi.transparent, [!0, !0, !0, !0]);
                (function(Le, $e, vt) {
                  const ft = Le.gl;
                  Le.activeTexture.set(ft.TEXTURE1), Le.viewport.set([0, 0, $e.width / 4, $e.height / 4]);
                  let gt = vt.heatmapFbos.get(s.c6);
                  gt ? (ft.bindTexture(ft.TEXTURE_2D, gt.colorAttachment.get()), Le.bindFramebuffer.set(gt.framebuffer)) : (gt = ad(Le, $e.width / 4, $e.height / 4), vt.heatmapFbos.set(s.c6, gt))
                })(Ce, $, ue), Ce.clear({
                  color: s.bi.transparent
                });
                for (let Le = 0; Le < de.length; Le++) {
                  const $e = de[Le];
                  if (ce.hasRenderableParent($e)) continue;
                  const vt = ce.getTile($e),
                    ft = vt.getBucket(ue);
                  if (!ft) continue;
                  const gt = ft.programConfigurations.get(ue.id),
                    xt = $.useProgram("heatmap", gt),
                    lr = Ie.getProjectionData({
                      overscaledTileID: $e,
                      applyGlobeMatrix: !0,
                      applyTerrainMatrix: !1
                    }),
                    cr = Ie.getCircleRadiusCorrection();
                  xt.draw(Ce, Be.TRIANGLES, Si.disabled, Oe, He, Ti.backCCW, Zc(vt, Ie.zoom, ue.paint.get("heatmap-intensity"), cr), null, lr, ue.id, ft.layoutVertexBuffer, ft.indexBuffer, ft.segments, ue.paint, Ie.zoom, gt)
                }
                Ce.viewport.set([0, 0, $.width, $.height])
              })(g, w, I, A) : g.renderPass === "translucent" && (function($, ce) {
                const ue = $.context,
                  de = ue.gl;
                ue.setColorMode($.colorModeForRenderPass());
                const Ce = ce.heatmapFbos.get(s.c6);
                Ce && (ue.activeTexture.set(de.TEXTURE0), de.bindTexture(de.TEXTURE_2D, Ce.colorAttachment.get()), ue.activeTexture.set(de.TEXTURE1), au(ue, ce).bind(de.LINEAR, de.CLAMP_TO_EDGE), $.useProgram("heatmapTexture").draw(ue, de.TRIANGLES, Si.disabled, Fi.disabled, $.colorModeForRenderPass(), Ti.disabled, Gc($, ce, 0, 1), null, null, ce.id, $.viewportBuffer, $.quadTriangleIndexBuffer, $.viewportSegments, ce.paint, $.transform.zoom))
              })(g, I)
            })(e, a, o, u, p) : s.ci(o) ? (function(g, w, I, A, L) {
              if (g.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: O
              } = L, R = I.paint.get("line-opacity"), H = I.paint.get("line-width");
              if (R.constantOr(1) === 0 || H.constantOr(1) === 0) return;
              const $ = g.getDepthModeForSublayer(0, Si.ReadOnly),
                ce = g.colorModeForRenderPass(),
                ue = I.paint.get("line-dasharray"),
                de = ue.constantOr(1),
                Ce = I.paint.get("line-pattern"),
                Be = Ce.constantOr(1),
                Ie = I.paint.get("line-gradient"),
                Oe = I.getCrossfadeParameters();
              let He;
              He = Be ? "linePattern" : de && Ie ? "lineGradientSDF" : de ? "lineSDF" : Ie ? "lineGradient" : "line";
              const Le = g.context,
                $e = Le.gl,
                vt = g.transform;
              let ft = !0;
              for (const gt of A) {
                const xt = w.getTile(gt);
                if (Be && !xt.patternsLoaded()) continue;
                const lr = xt.getBucket(I);
                if (!lr) continue;
                const cr = lr.programConfigurations.get(I.id),
                  Nt = g.context.program.get(),
                  Nr = g.useProgram(He, cr),
                  Pi = ft || Nr.program !== Nt,
                  Qi = g.style.map.terrain && g.style.map.terrain.getTerrainData(gt),
                  Li = Ce.constantOr(null),
                  ra = ue && ue.constantOr(null);
                if (Li && xt.imageAtlas) {
                  const Ua = xt.imageAtlas,
                    da = Ua.patternPositions[Li.to.toString()],
                    Ca = Ua.patternPositions[Li.from.toString()];
                  da && Ca && cr.setConstantPatternPositions(da, Ca)
                } else if (ra) {
                  const Ua = I.layout.get("line-cap") === "round",
                    da = g.lineAtlas.getDash(ra.to, Ua),
                    Ca = g.lineAtlas.getDash(ra.from, Ua);
                  cr.setConstantDashPositions(da, Ca)
                }
                const va = vt.getProjectionData({
                    overscaledTileID: gt,
                    applyGlobeMatrix: !O,
                    applyTerrainMatrix: !0
                  }),
                  na = vt.getPixelScale();
                let za;
                Be ? (za = Al(g, xt, I, na, Oe), nu(Le, $e, xt, cr, Oe)) : de && Ie ? (za = Jp(g, xt, I, na, Oe, lr.lineClipsArray.length), Zl(g, w, Le, $e, I, lr, gt, cr, Oe)) : de ? (za = Kp(g, xt, I, na, Oe), nd(g, Le, $e, cr, Pi, Oe)) : Ie ? (za = Yp(g, xt, I, na, lr.lineClipsArray.length), sd(g, w, Le, $e, I, lr, gt)) : za = Is(g, xt, I, na);
                const ha = g.stencilModeForClipping(gt);
                Nr.draw(Le, $e.TRIANGLES, $, ha, ce, Ti.disabled, za, Qi, va, I.id, lr.layoutVertexBuffer, lr.indexBuffer, lr.segments, I.paint, g.transform.zoom, cr, lr.layoutVertexBuffer2), ft = !1
              }
            })(e, a, o, u, p) : s.cj(o) ? (function(g, w, I, A, L) {
              const O = I.paint.get("fill-color"),
                R = I.paint.get("fill-opacity");
              if (R.constantOr(1) === 0) return;
              const {
                isRenderingToTexture: H
              } = L, $ = g.colorModeForRenderPass(), ce = I.paint.get("fill-pattern"), ue = g.opaquePassEnabledForLayer() && !ce.constantOr(1) && O.constantOr(s.bi.transparent).a === 1 && R.constantOr(0) === 1 ? "opaque" : "translucent";
              if (g.renderPass === ue) {
                const de = g.getDepthModeForSublayer(1, g.renderPass === "opaque" ? Si.ReadWrite : Si.ReadOnly);
                od(g, w, I, A, de, $, !1, H)
              }
              if (g.renderPass === "translucent" && I.paint.get("fill-antialias")) {
                const de = g.getDepthModeForSublayer(I.getPaintProperty("fill-outline-color") ? 2 : 0, Si.ReadOnly);
                od(g, w, I, A, de, $, !0, H)
              }
            })(e, a, o, u, p) : s.ck(o) ? (function(g, w, I, A, L) {
              const O = I.paint.get("fill-extrusion-opacity");
              if (O === 0) return;
              const {
                isRenderingToTexture: R
              } = L;
              if (g.renderPass === "translucent") {
                const H = new Si(g.context.gl.LEQUAL, Si.ReadWrite, g.depthRangeFor3D);
                if (O !== 1 || I.paint.get("fill-extrusion-pattern").constantOr(1)) Wl(g, w, I, A, H, Fi.disabled, Mi.disabled, R), Wl(g, w, I, A, H, g.stencilModeFor3D(), g.colorModeForRenderPass(), R);
                else {
                  const $ = g.colorModeForRenderPass();
                  Wl(g, w, I, A, H, Fi.disabled, $, R)
                }
              }
            })(e, a, o, u, p) : s.cl(o) ? (function(g, w, I, A, L) {
              if (g.renderPass !== "offscreen" && g.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: O
              } = L, R = g.context, H = g.style.projection.useSubdivision, $ = g.getDepthModeForSublayer(0, Si.ReadOnly), ce = g.colorModeForRenderPass();
              if (g.renderPass === "offscreen")(function(ue, de, Ce, Be, Ie, Oe, He) {
                const Le = ue.context,
                  $e = Le.gl;
                for (const vt of Ce) {
                  const ft = de.getTile(vt),
                    gt = ft.dem;
                  if (!gt || !gt.data || !ft.needsHillshadePrepare) continue;
                  const xt = gt.dim,
                    lr = gt.stride,
                    cr = gt.getPixels();
                  if (Le.activeTexture.set($e.TEXTURE1), Le.pixelStoreUnpackPremultiplyAlpha.set(!1), ft.demTexture = ft.demTexture || ue.getTileTexture(lr), ft.demTexture) {
                    const Nr = ft.demTexture;
                    Nr.update(cr, {
                      premultiply: !1
                    }), Nr.bind($e.NEAREST, $e.CLAMP_TO_EDGE)
                  } else ft.demTexture = new s.T(Le, cr, $e.RGBA, {
                    premultiply: !1
                  }), ft.demTexture.bind($e.NEAREST, $e.CLAMP_TO_EDGE);
                  Le.activeTexture.set($e.TEXTURE0);
                  let Nt = ft.fbo;
                  if (!Nt) {
                    const Nr = new s.T(Le, {
                      width: xt,
                      height: xt,
                      data: null
                    }, $e.RGBA);
                    Nr.bind($e.LINEAR, $e.CLAMP_TO_EDGE), Nt = ft.fbo = Le.createFramebuffer(xt, xt, !0, !1), Nt.colorAttachment.set(Nr.texture)
                  }
                  Le.bindFramebuffer.set(Nt.framebuffer), Le.viewport.set([0, 0, xt, xt]), ue.useProgram("hillshadePrepare").draw(Le, $e.TRIANGLES, Ie, Oe, He, Ti.disabled, qs(ft.tileID, gt), null, null, Be.id, ue.rasterBoundsBuffer, ue.quadTriangleIndexBuffer, ue.rasterBoundsSegments), ft.needsHillshadePrepare = !1
                }
              })(g, w, A, I, $, Fi.disabled, ce), R.viewport.set([0, 0, g.width, g.height]);
              else if (g.renderPass === "translucent")
                if (H) {
                  const [ue, de, Ce] = g.stencilConfigForOverlapTwoPass(A);
                  ga(g, w, I, Ce, ue, $, ce, !1, O), ga(g, w, I, Ce, de, $, ce, !0, O)
                } else {
                  const [ue, de] = g.getStencilConfigForOverlapAndUpdateStencilID(A);
                  ga(g, w, I, de, ue, $, ce, !1, O)
                }
            })(e, a, o, u, p) : s.cm(o) ? (function(g, w, I, A, L) {
              if (g.renderPass !== "translucent" || !A.length) return;
              const {
                isRenderingToTexture: O
              } = L, R = g.style.projection.useSubdivision, H = g.getDepthModeForSublayer(0, Si.ReadOnly), $ = g.colorModeForRenderPass();
              if (R) {
                const [ce, ue, de] = g.stencilConfigForOverlapTwoPass(A);
                us(g, w, I, de, ce, H, $, !1, O), us(g, w, I, de, ue, H, $, !0, O)
              } else {
                const [ce, ue] = g.getStencilConfigForOverlapAndUpdateStencilID(A);
                us(g, w, I, ue, ce, H, $, !1, O)
              }
            })(e, a, o, u, p) : s.bN(o) ? (function(g, w, I, A, L) {
              if (g.renderPass !== "translucent" || I.paint.get("raster-opacity") === 0 || !A.length) return;
              const {
                isRenderingToTexture: O
              } = L, R = w.getSource(), H = g.style.projection.useSubdivision;
              if (R instanceof sr) So(g, w, I, A, null, !1, !1, R.tileCoords, R.flippedWindingOrder, O);
              else if (H) {
                const [$, ce, ue] = g.stencilConfigForOverlapTwoPass(A);
                So(g, w, I, ue, $, !1, !0, fn, !1, O), So(g, w, I, ue, ce, !0, !0, fn, !1, O)
              } else {
                const [$, ce] = g.getStencilConfigForOverlapAndUpdateStencilID(A);
                So(g, w, I, ce, $, !1, !0, fn, !1, O)
              }
            })(e, a, o, u, p) : s.cn(o) ? (function(g, w, I, A, L) {
              const O = I.paint.get("background-color"),
                R = I.paint.get("background-opacity");
              if (R === 0) return;
              const {
                isRenderingToTexture: H
              } = L, $ = g.context, ce = $.gl, ue = g.style.projection, de = g.transform, Ce = de.tileSize, Be = I.paint.get("background-pattern");
              if (g.isPatternMissing(Be)) return;
              const Ie = !Be && O.a === 1 && R === 1 && g.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (g.renderPass !== Ie) return;
              const Oe = Fi.disabled,
                He = g.getDepthModeForSublayer(0, Ie === "opaque" ? Si.ReadWrite : Si.ReadOnly),
                Le = g.colorModeForRenderPass(),
                $e = g.useProgram(Be ? "backgroundPattern" : "background"),
                vt = A || it(de, {
                  tileSize: Ce,
                  terrain: g.style.map.terrain
                });
              Be && ($.activeTexture.set(ce.TEXTURE0), g.imageManager.bind(g.context));
              const ft = I.getCrossfadeParameters();
              for (const gt of vt) {
                const xt = de.getProjectionData({
                    overscaledTileID: gt,
                    applyGlobeMatrix: !H,
                    applyTerrainMatrix: !0
                  }),
                  lr = Be ? Kc(R, g, Be, {
                    tileID: gt,
                    tileSize: Ce
                  }, ft) : Yc(R, O),
                  cr = g.style.map.terrain && g.style.map.terrain.getTerrainData(gt),
                  Nt = ue.getMeshFromTileID($, gt.canonical, !1, !0, "raster");
                $e.draw($, ce.TRIANGLES, He, Oe, Le, Ti.backCCW, lr, cr, xt, I.id, Nt.vertexBuffer, Nt.indexBuffer, Nt.segments)
              }
            })(e, 0, o, u, p) : s.co(o) && (function(g, w, I, A) {
              const {
                isRenderingGlobe: L
              } = A, O = g.context, R = I.implementation, H = g.style.projection, $ = g.transform, ce = $.getProjectionDataForCustomLayer(L), ue = {
                farZ: $.farZ,
                nearZ: $.nearZ,
                fov: $.fov * Math.PI / 180,
                modelViewProjectionMatrix: $.modelViewProjectionMatrix,
                projectionMatrix: $.projectionMatrix,
                shaderData: {
                  variantName: H.shaderVariantName,
                  vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${H.shaderPreludeCode.vertexSource}`,
                  define: H.shaderDefine
                },
                defaultProjectionData: ce
              }, de = R.renderingMode ? R.renderingMode : "2d";
              if (g.renderPass === "offscreen") {
                const Ce = R.prerender;
                Ce && (g.setCustomLayerDefaults(), O.setColorMode(g.colorModeForRenderPass()), Ce.call(R, O.gl, ue), O.setDirty(), g.setBaseState())
              } else if (g.renderPass === "translucent") {
                g.setCustomLayerDefaults(), O.setColorMode(g.colorModeForRenderPass()), O.setStencilMode(Fi.disabled);
                const Ce = de === "3d" ? g.getDepthModeFor3D() : g.getDepthModeForSublayer(0, Si.ReadOnly);
                O.setDepthMode(Ce), R.render(O.gl, ue), O.setDirty(), g.setBaseState(), O.bindFramebuffer.set(null)
              }
            })(e, 0, o, p))
          }
          saveTileTexture(e) {
            const a = this._tileTextures[e.size[0]];
            a ? a.push(e) : this._tileTextures[e.size[0]] = [e]
          }
          getTileTexture(e) {
            const a = this._tileTextures[e];
            return a && a.length > 0 ? a.pop() : null
          }
          isPatternMissing(e) {
            if (!e) return !1;
            if (!e.from || !e.to) return !0;
            const a = this.imageManager.getPattern(e.from.toString()),
              o = this.imageManager.getPattern(e.to.toString());
            return !a || !o
          }
          useProgram(e, a, o = !1, u = []) {
            this.cache = this.cache || {};
            const p = !!this.style.map.terrain,
              g = this.style.projection,
              w = o ? Ar.projectionMercator : g.shaderPreludeCode,
              I = o ? Di : g.shaderDefine,
              A = e + (a ? a.cacheKey : "") + `/${o?ki:g.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (p ? "/terrain" : "") + (u ? `/${u.join("/")}` : "");
            return this.cache[A] || (this.cache[A] = new Wo(this.context, Ar[e], a, Hh[e], this._showOverdrawInspector, p, w, I, u)), this.cache[A]
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault()
          }
          setBaseState() {
            const e = this.context.gl;
            this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD)
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new s.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA))
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy()
          }
          overLimit() {
            const {
              drawingBufferWidth: e,
              drawingBufferHeight: a
            } = this.context.gl;
            return this.width !== e || this.height !== a
          }
        }

        function hu(d, e) {
          let a, o = !1,
            u = null,
            p = null;
          const g = () => {
            u = null, o && (d.apply(p, a), u = setTimeout(g, e), o = !1)
          };
          return (...w) => (o = !0, p = this, a = w, u || g(), u)
        }
        class du {
          constructor(e) {
            this._getCurrentHash = () => {
              const a = window.location.hash.replace("#", "");
              if (this._hashName) {
                let o;
                return a.split("&").map((u => u.split("="))).forEach((u => {
                  u[0] === this._hashName && (o = u)
                })), (o && o[1] || "").split("/")
              }
              return a.split("/")
            }, this._onHashChange = () => {
              const a = this._getCurrentHash();
              if (!this._isValidHash(a)) return !1;
              const o = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(a[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({
                center: [+a[2], +a[1]],
                zoom: +a[0],
                bearing: o,
                pitch: +(a[4] || 0)
              }), !0
            }, this._updateHashUnthrottled = () => {
              const a = window.location.href.replace(/(#.*)?$/, this.getHashString());
              window.history.replaceState(window.history.state, null, a)
            }, this._removeHash = () => {
              const a = this._getCurrentHash();
              if (a.length === 0) return;
              const o = a.join("/");
              let u = o;
              u.split("&").length > 0 && (u = u.split("&")[0]), this._hashName && (u = `${this._hashName}=${o}`);
              let p = window.location.hash.replace(u, "");
              p.startsWith("#&") ? p = p.slice(0, 1) + p.slice(2) : p === "#" && (p = "");
              let g = window.location.href.replace(/(#.+)?$/, p);
              g = g.replace("&&", "&"), window.history.replaceState(window.history.state, null, g)
            }, this._updateHash = hu(this._updateHashUnthrottled, 300), this._hashName = e && encodeURIComponent(e)
          }
          addTo(e) {
            return this._map = e, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this
          }
          getHashString(e) {
            const a = this._map.getCenter(),
              o = Math.round(100 * this._map.getZoom()) / 100,
              u = Math.ceil((o * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10),
              p = Math.pow(10, u),
              g = Math.round(a.lng * p) / p,
              w = Math.round(a.lat * p) / p,
              I = this._map.getBearing(),
              A = this._map.getPitch();
            let L = "";
            if (L += e ? `/${g}/${w}/${o}` : `${o}/${w}/${g}`, (I || A) && (L += "/" + Math.round(10 * I) / 10), A && (L += `/${Math.round(A)}`), this._hashName) {
              const O = this._hashName;
              let R = !1;
              const H = window.location.hash.slice(1).split("&").map(($ => {
                const ce = $.split("=")[0];
                return ce === O ? (R = !0, `${ce}=${L}`) : $
              })).filter(($ => $));
              return R || H.push(`${O}=${L}`), `#${H.join("&")}`
            }
            return `#${L}`
          }
          _isValidHash(e) {
            if (e.length < 3 || e.some(isNaN)) return !1;
            try {
              new s.U(+e[2], +e[1])
            } catch {
              return !1
            }
            const a = +e[0],
              o = +(e[3] || 0),
              u = +(e[4] || 0);
            return a >= this._map.getMinZoom() && a <= this._map.getMaxZoom() && o >= -180 && o <= 180 && u >= this._map.getMinPitch() && u <= this._map.getMaxPitch()
          }
        }
        const Io = {
            linearity: .3,
            easing: s.cp(0, 0, .3, 1)
          },
          hd = s.e({
            deceleration: 2500,
            maxSpeed: 1400
          }, Io),
          dd = s.e({
            deceleration: 20,
            maxSpeed: 1400
          }, Io),
          pd = s.e({
            deceleration: 1e3,
            maxSpeed: 360
          }, Io),
          fd = s.e({
            deceleration: 1e3,
            maxSpeed: 90
          }, Io),
          Xl = s.e({
            deceleration: 1e3,
            maxSpeed: 360
          }, Io);
        class md {
          constructor(e) {
            this._map = e, this.clear()
          }
          clear() {
            this._inertiaBuffer = []
          }
          record(e) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({
              time: me(),
              settings: e
            })
          }
          _drainInertiaBuffer() {
            const e = this._inertiaBuffer,
              a = me();
            for (; e.length > 0 && a - e[0].time > 160;) e.shift()
          }
          _onMoveEnd(e) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const a = {
              zoom: 0,
              bearing: 0,
              pitch: 0,
              roll: 0,
              pan: new s.P(0, 0),
              pinchAround: void 0,
              around: void 0
            };
            for (const {
                settings: p
              }
              of this._inertiaBuffer) a.zoom += p.zoomDelta || 0, a.bearing += p.bearingDelta || 0, a.pitch += p.pitchDelta || 0, a.roll += p.rollDelta || 0, p.panDelta && a.pan._add(p.panDelta), p.around && (a.around = p.around), p.pinchAround && (a.pinchAround = p.pinchAround);
            const o = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time,
              u = {};
            if (a.pan.mag()) {
              const p = on(a.pan.mag(), o, s.e({}, hd, e || {})),
                g = a.pan.mult(p.amount / a.pan.mag()),
                w = this._map.cameraHelper.handlePanInertia(g, this._map.transform);
              u.center = w.easingCenter, u.offset = w.easingOffset, rn(u, p)
            }
            if (a.zoom) {
              const p = on(a.zoom, o, dd);
              u.zoom = this._map.transform.zoom + p.amount, rn(u, p)
            }
            if (a.bearing) {
              const p = on(a.bearing, o, pd);
              u.bearing = this._map.transform.bearing + s.ai(p.amount, -179, 179), rn(u, p)
            }
            if (a.pitch) {
              const p = on(a.pitch, o, fd);
              u.pitch = this._map.transform.pitch + p.amount, rn(u, p)
            }
            if (a.roll) {
              const p = on(a.roll, o, Xl);
              u.roll = this._map.transform.roll + s.ai(p.amount, -179, 179), rn(u, p)
            }
            if (u.zoom || u.bearing) {
              const p = a.pinchAround === void 0 ? a.around : a.pinchAround;
              u.around = p ? this._map.unproject(p) : this._map.getCenter()
            }
            return this.clear(), s.e(u, {
              noMoveStart: !0
            })
          }
        }

        function rn(d, e) {
          (!d.duration || d.duration < e.duration) && (d.duration = e.duration, d.easing = e.easing)
        }

        function on(d, e, a) {
          const {
            maxSpeed: o,
            linearity: u,
            deceleration: p
          } = a, g = s.ai(d * u / (e / 1e3), -o, o), w = Math.abs(g) / (p * u);
          return {
            easing: a.easing,
            duration: 1e3 * w,
            amount: g * (w / 2)
          }
        }
        class mn extends s.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, a, o, u = {}) {
            o = o instanceof MouseEvent ? o : new MouseEvent(e, o);
            const p = q.mousePos(a.getCanvas(), o),
              g = a.unproject(p);
            super(e, s.e({
              point: p,
              lngLat: g,
              originalEvent: o
            }, u)), this._defaultPrevented = !1, this.target = a
          }
        }
        class ln extends s.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, a, o) {
            const u = e === "touchend" ? o.changedTouches : o.touches,
              p = q.touchPos(a.getCanvasContainer(), u),
              g = p.map((I => a.unproject(I))),
              w = p.reduce(((I, A, L, O) => I.add(A.div(O.length))), new s.P(0, 0));
            super(e, {
              points: p,
              point: w,
              lngLats: g,
              lngLat: a.unproject(w),
              originalEvent: o
            }), this._defaultPrevented = !1
          }
        }
        class gd extends s.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, a, o) {
            super(e, {
              originalEvent: o
            }), this._defaultPrevented = !1
          }
        }
        class Mo {
          constructor(e, a) {
            this._map = e, this._clickTolerance = a.clickTolerance
          }
          reset() {
            delete this._mousedownPos
          }
          wheel(e) {
            return this._firePreventable(new gd(e.type, this._map, e))
          }
          mousedown(e, a) {
            return this._mousedownPos = a, this._firePreventable(new mn(e.type, this._map, e))
          }
          mouseup(e) {
            this._map.fire(new mn(e.type, this._map, e))
          }
          click(e, a) {
            this._mousedownPos && this._mousedownPos.dist(a) >= this._clickTolerance || this._map.fire(new mn(e.type, this._map, e))
          }
          dblclick(e) {
            return this._firePreventable(new mn(e.type, this._map, e))
          }
          mouseover(e) {
            this._map.fire(new mn(e.type, this._map, e))
          }
          mouseout(e) {
            this._map.fire(new mn(e.type, this._map, e))
          }
          touchstart(e) {
            return this._firePreventable(new ln(e.type, this._map, e))
          }
          touchmove(e) {
            this._map.fire(new ln(e.type, this._map, e))
          }
          touchend(e) {
            this._map.fire(new ln(e.type, this._map, e))
          }
          touchcancel(e) {
            this._map.fire(new ln(e.type, this._map, e))
          }
          _firePreventable(e) {
            if (this._map.fire(e), e.defaultPrevented) return {}
          }
          isEnabled() {
            return !0
          }
          isActive() {
            return !1
          }
          enable() {}
          disable() {}
        }
        class of {
          constructor(e) {
            this._map = e
          }
          reset() {
            this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent
          }
          mousemove(e) {
            this._map.fire(new mn(e.type, this._map, e))
          }
          mousedown() {
            this._delayContextMenu = !0, this._ignoreContextMenu = !1
          }
          mouseup() {
            this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new mn("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent)
          }
          contextmenu(e) {
            this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new mn(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault()
          }
          isEnabled() {
            return !0
          }
          isActive() {
            return !1
          }
          enable() {}
          disable() {}
        }
        class rl {
          constructor(e) {
            this._map = e
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform
          }
          get center() {
            return {
              lng: this.transform.center.lng,
              lat: this.transform.center.lat
            }
          }
          get zoom() {
            return this.transform.zoom
          }
          get pitch() {
            return this.transform.pitch
          }
          get bearing() {
            return this.transform.bearing
          }
          unproject(e) {
            return this.transform.screenPointToLocation(s.P.convert(e), this._map.terrain)
          }
        }
        class _d {
          constructor(e, a) {
            this._map = e, this._tr = new rl(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = a.clickTolerance || 1
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active
          }
          enable() {
            this.isEnabled() || (this._enabled = !0)
          }
          disable() {
            this.isEnabled() && (this._enabled = !1)
          }
          mousedown(e, a) {
            this.isEnabled() && e.shiftKey && e.button === 0 && (q.disableDrag(), this._startPos = this._lastPos = a, this._active = !0)
          }
          mousemoveWindow(e, a) {
            if (!this._active) return;
            const o = a;
            if (this._lastPos.equals(o) || !this._box && o.dist(this._startPos) < this._clickTolerance) return;
            const u = this._startPos;
            this._lastPos = o, this._box || (this._box = q.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e));
            const p = Math.min(u.x, o.x),
              g = Math.max(u.x, o.x),
              w = Math.min(u.y, o.y),
              I = Math.max(u.y, o.y);
            q.setTransform(this._box, `translate(${p}px,${w}px)`), this._box.style.width = g - p + "px", this._box.style.height = I - w + "px"
          }
          mouseupWindow(e, a) {
            if (!this._active || e.button !== 0) return;
            const o = this._startPos,
              u = a;
            if (this.reset(), q.suppressClick(), o.x !== u.x || o.y !== u.y) return this._map.fire(new s.l("boxzoomend", {
              originalEvent: e
            })), {
              cameraAnimation: p => p.fitScreenCoordinates(o, u, this._tr.bearing, {
                linear: !0
              })
            };
            this._fireEvent("boxzoomcancel", e)
          }
          keydown(e) {
            this._active && e.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e))
          }
          reset() {
            this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (q.remove(this._box), this._box = null), q.enableDrag(), delete this._startPos, delete this._lastPos
          }
          _fireEvent(e, a) {
            return this._map.fire(new s.l(e, {
              originalEvent: a
            }))
          }
        }

        function pu(d, e) {
          if (d.length !== e.length) throw new Error(`The number of touches and points are not equal - touches ${d.length}, points ${e.length}`);
          const a = {};
          for (let o = 0; o < d.length; o++) a[d[o].identifier] = e[o];
          return a
        }
        class vd {
          constructor(e) {
            this.reset(), this.numTouches = e.numTouches
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1
          }
          touchstart(e, a, o) {
            (this.centroid || o.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = e.timeStamp), o.length === this.numTouches && (this.centroid = (function(u) {
              const p = new s.P(0, 0);
              for (const g of u) p._add(g);
              return p.div(u.length)
            })(a), this.touches = pu(o, a)))
          }
          touchmove(e, a, o) {
            if (this.aborted || !this.centroid) return;
            const u = pu(o, a);
            for (const p in this.touches) {
              const g = u[p];
              (!g || g.dist(this.touches[p]) > 30) && (this.aborted = !0)
            }
          }
          touchend(e, a, o) {
            if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), o.length === 0) {
              const u = !this.aborted && this.centroid;
              if (this.reset(), u) return u
            }
          }
        }
        class Hs {
          constructor(e) {
            this.singleTap = new vd(e), this.numTaps = e.numTaps, this.reset()
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset()
          }
          touchstart(e, a, o) {
            this.singleTap.touchstart(e, a, o)
          }
          touchmove(e, a, o) {
            this.singleTap.touchmove(e, a, o)
          }
          touchend(e, a, o) {
            const u = this.singleTap.touchend(e, a, o);
            if (u) {
              const p = e.timeStamp - this.lastTime < 500,
                g = !this.lastTap || this.lastTap.dist(u) < 30;
              if (p && g || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = u, this.count === this.numTaps) return this.reset(), u
            }
          }
        }
        class hs {
          constructor(e) {
            this._tr = new rl(e), this._zoomIn = new Hs({
              numTouches: 1,
              numTaps: 2
            }), this._zoomOut = new Hs({
              numTouches: 2,
              numTaps: 1
            }), this.reset()
          }
          reset() {
            this._active = !1, this._zoomIn.reset(), this._zoomOut.reset()
          }
          touchstart(e, a, o) {
            this._zoomIn.touchstart(e, a, o), this._zoomOut.touchstart(e, a, o)
          }
          touchmove(e, a, o) {
            this._zoomIn.touchmove(e, a, o), this._zoomOut.touchmove(e, a, o)
          }
          touchend(e, a, o) {
            const u = this._zoomIn.touchend(e, a, o),
              p = this._zoomOut.touchend(e, a, o),
              g = this._tr;
            return u ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), {
              cameraAnimation: w => w.easeTo({
                duration: 300,
                zoom: g.zoom + 1,
                around: g.unproject(u)
              }, {
                originalEvent: e
              })
            }) : p ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), {
              cameraAnimation: w => w.easeTo({
                duration: 300,
                zoom: g.zoom - 1,
                around: g.unproject(p)
              }, {
                originalEvent: e
              })
            }) : void 0
          }
          touchcancel() {
            this.reset()
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class zr {
          constructor(e) {
            this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset()
          }
          reset(e) {
            this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(e)
          }
          _move(...e) {
            const a = this._moveFunction(...e);
            if (a.bearingDelta || a.pitchDelta || a.rollDelta || a.around || a.panDelta) return this._active = !0, a
          }
          dragStart(e, a) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = Array.isArray(a) ? a[0] : a, this._activateOnStart && this._lastPoint && (this._active = !0))
          }
          dragMove(e, a) {
            if (!this.isEnabled()) return;
            const o = this._lastPoint;
            if (!o) return;
            if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) return void this.reset(e);
            const u = Array.isArray(a) ? a[0] : a;
            return !this._moved && u.dist(o) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = u, this._move(o, u))
          }
          dragEnd(e) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && q.suppressClick(), this.reset(e))
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
          getClickTolerance() {
            return this._clickTolerance
          }
        }
        const yd = 0,
          fu = 2,
          xd = {
            [yd]: 1,
            [fu]: 2
          };
        class ds {
          constructor(e) {
            this._correctEvent = e.checkCorrectEvent
          }
          startMove(e) {
            const a = q.mouseButton(e);
            this._eventButton = a
          }
          endMove(e) {
            delete this._eventButton
          }
          isValidStartEvent(e) {
            return this._correctEvent(e)
          }
          isValidMoveEvent(e) {
            return !(function(a, o) {
              const u = xd[o];
              return a.buttons === void 0 || (a.buttons & u) !== u
            })(e, this._eventButton)
          }
          isValidEndEvent(e) {
            return q.mouseButton(e) === this._eventButton
          }
        }
        class il {
          constructor() {
            this._firstTouch = void 0
          }
          _isOneFingerTouch(e) {
            return e.targetTouches.length === 1
          }
          _isSameTouchEvent(e) {
            return e.targetTouches[0].identifier === this._firstTouch
          }
          startMove(e) {
            this._firstTouch = e.targetTouches[0].identifier
          }
          endMove(e) {
            delete this._firstTouch
          }
          isValidStartEvent(e) {
            return this._isOneFingerTouch(e)
          }
          isValidMoveEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e)
          }
          isValidEndEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e)
          }
        }
        class mu {
          constructor(e = new ds({
            checkCorrectEvent: () => !0
          }), a = new il) {
            this.mouseMoveStateManager = e, this.oneFingerTouchMoveStateManager = a
          }
          _executeRelevantHandler(e, a, o) {
            return e instanceof MouseEvent ? a(e) : typeof TouchEvent < "u" && e instanceof TouchEvent ? o(e) : void 0
          }
          startMove(e) {
            this._executeRelevantHandler(e, (a => this.mouseMoveStateManager.startMove(a)), (a => this.oneFingerTouchMoveStateManager.startMove(a)))
          }
          endMove(e) {
            this._executeRelevantHandler(e, (a => this.mouseMoveStateManager.endMove(a)), (a => this.oneFingerTouchMoveStateManager.endMove(a)))
          }
          isValidStartEvent(e) {
            return this._executeRelevantHandler(e, (a => this.mouseMoveStateManager.isValidStartEvent(a)), (a => this.oneFingerTouchMoveStateManager.isValidStartEvent(a)))
          }
          isValidMoveEvent(e) {
            return this._executeRelevantHandler(e, (a => this.mouseMoveStateManager.isValidMoveEvent(a)), (a => this.oneFingerTouchMoveStateManager.isValidMoveEvent(a)))
          }
          isValidEndEvent(e) {
            return this._executeRelevantHandler(e, (a => this.mouseMoveStateManager.isValidEndEvent(a)), (a => this.oneFingerTouchMoveStateManager.isValidEndEvent(a)))
          }
        }
        const Bi = d => {
          d.mousedown = d.dragStart, d.mousemoveWindow = d.dragMove, d.mouseup = d.dragEnd, d.contextmenu = e => {
            e.preventDefault()
          }
        };
        class gu {
          constructor(e, a) {
            this._clickTolerance = e.clickTolerance || 1, this._map = a, this.reset()
          }
          reset() {
            this._active = !1, this._touches = {}, this._sum = new s.P(0, 0)
          }
          _shouldBePrevented(e) {
            return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1)
          }
          touchstart(e, a, o) {
            return this._calculateTransform(e, a, o)
          }
          touchmove(e, a, o) {
            if (this._active) {
              if (!this._shouldBePrevented(o.length)) return e.preventDefault(), this._calculateTransform(e, a, o);
              this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e)
            }
          }
          touchend(e, a, o) {
            this._calculateTransform(e, a, o), this._active && this._shouldBePrevented(o.length) && this.reset()
          }
          touchcancel() {
            this.reset()
          }
          _calculateTransform(e, a, o) {
            o.length > 0 && (this._active = !0);
            const u = pu(o, a),
              p = new s.P(0, 0),
              g = new s.P(0, 0);
            let w = 0;
            for (const A in u) {
              const L = u[A],
                O = this._touches[A];
              O && (p._add(L), g._add(L.sub(O)), w++, u[A] = L)
            }
            if (this._touches = u, this._shouldBePrevented(w) || !g.mag()) return;
            const I = g.div(w);
            return this._sum._add(I), this._sum.mag() < this._clickTolerance ? void 0 : {
              around: p.div(w),
              panDelta: I
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class _u {
          constructor() {
            this.reset()
          }
          reset() {
            this._active = !1, delete this._firstTwoTouches
          }
          touchstart(e, a, o) {
            this._firstTwoTouches || o.length < 2 || (this._firstTwoTouches = [o[0].identifier, o[1].identifier], this._start([a[0], a[1]]))
          }
          touchmove(e, a, o) {
            if (!this._firstTwoTouches) return;
            e.preventDefault();
            const [u, p] = this._firstTwoTouches, g = Co(o, a, u), w = Co(o, a, p);
            if (!g || !w) return;
            const I = this._aroundCenter ? null : g.add(w).div(2);
            return this._move([g, w], I, e)
          }
          touchend(e, a, o) {
            if (!this._firstTwoTouches) return;
            const [u, p] = this._firstTwoTouches, g = Co(o, a, u), w = Co(o, a, p);
            g && w || (this._active && q.suppressClick(), this.reset())
          }
          touchcancel() {
            this.reset()
          }
          enable(e) {
            this._enabled = !0, this._aroundCenter = !!e && e.around === "center"
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active
          }
        }

        function Co(d, e, a) {
          for (let o = 0; o < d.length; o++)
            if (d[o].identifier === a) return e[o]
        }

        function bd(d, e) {
          return Math.log(d / e) / Math.LN2
        }
        class wd extends _u {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance
          }
          _start(e) {
            this._startDistance = this._distance = e[0].dist(e[1])
          }
          _move(e, a) {
            const o = this._distance;
            if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(bd(this._distance, this._startDistance)) < .1)) return this._active = !0, {
              zoomDelta: bd(this._distance, o),
              pinchAround: a
            }
          }
        }

        function vu(d, e) {
          return 180 * d.angleWith(e) / Math.PI
        }
        class Yl extends _u {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector
          }
          _start(e) {
            this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1])
          }
          _move(e, a, o) {
            const u = this._vector;
            if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, {
              bearingDelta: vu(this._vector, u),
              pinchAround: a
            }
          }
          _isBelowThreshold(e) {
            this._minDiameter = Math.min(this._minDiameter, e.mag());
            const a = 25 / (Math.PI * this._minDiameter) * 360,
              o = vu(e, this._startVector);
            return Math.abs(o) < a
          }
        }

        function Kl(d) {
          return Math.abs(d.y) > Math.abs(d.x)
        }
        class Td extends _u {
          constructor(e) {
            super(), this._currentTouchCount = 0, this._map = e
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints
          }
          touchstart(e, a, o) {
            super.touchstart(e, a, o), this._currentTouchCount = o.length
          }
          _start(e) {
            this._lastPoints = e, Kl(e[0].sub(e[1])) && (this._valid = !1)
          }
          _move(e, a, o) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
            const u = e[0].sub(this._lastPoints[0]),
              p = e[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(u, p, o.timeStamp), this._valid ? (this._lastPoints = e, this._active = !0, {
              pitchDelta: (u.y + p.y) / 2 * -.5
            }) : void 0
          }
          gestureBeginsVertically(e, a, o) {
            if (this._valid !== void 0) return this._valid;
            const u = e.mag() >= 2,
              p = a.mag() >= 2;
            if (!u && !p) return;
            if (!u || !p) return this._firstMove === void 0 && (this._firstMove = o), o - this._firstMove < 100 && void 0;
            const g = e.y > 0 == a.y > 0;
            return Kl(e) && Kl(a) && g
          }
        }
        const Sd = {
          panStep: 100,
          bearingStep: 15,
          pitchStep: 10
        };
        class Pd {
          constructor(e) {
            this._tr = new rl(e);
            const a = Sd;
            this._panStep = a.panStep, this._bearingStep = a.bearingStep, this._pitchStep = a.pitchStep, this._rotationDisabled = !1
          }
          reset() {
            this._active = !1
          }
          keydown(e) {
            if (e.altKey || e.ctrlKey || e.metaKey) return;
            let a = 0,
              o = 0,
              u = 0,
              p = 0,
              g = 0;
            switch (e.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                a = 1;
                break;
              case 189:
              case 109:
              case 173:
                a = -1;
                break;
              case 37:
                e.shiftKey ? o = -1 : (e.preventDefault(), p = -1);
                break;
              case 39:
                e.shiftKey ? o = 1 : (e.preventDefault(), p = 1);
                break;
              case 38:
                e.shiftKey ? u = 1 : (e.preventDefault(), g = -1);
                break;
              case 40:
                e.shiftKey ? u = -1 : (e.preventDefault(), g = 1);
                break;
              default:
                return
            }
            return this._rotationDisabled && (o = 0, u = 0), {
              cameraAnimation: w => {
                const I = this._tr;
                w.easeTo({
                  duration: 300,
                  easeId: "keyboardHandler",
                  easing: lf,
                  zoom: a ? Math.round(I.zoom) + a * (e.shiftKey ? 2 : 1) : I.zoom,
                  bearing: I.bearing + o * this._bearingStep,
                  pitch: I.pitch + u * this._pitchStep,
                  offset: [-p * this._panStep, -g * this._panStep],
                  center: I.center
                }, {
                  originalEvent: e
                })
              }
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
          disableRotation() {
            this._rotationDisabled = !0
          }
          enableRotation() {
            this._rotationDisabled = !1
          }
        }

        function lf(d) {
          return d * (2 - d)
        }
        const ps = 4.000244140625,
          ta = 1 / 450;
        class Id {
          constructor(e, a) {
            this._onTimeout = o => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(o)
            }, this._map = e, this._tr = new rl(e), this._triggerRenderFrame = a, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = ta
          }
          setZoomRate(e) {
            this._defaultZoomRate = e
          }
          setWheelZoomRate(e) {
            this._wheelZoomRate = e
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active || this._finishTimeout !== void 0
          }
          isZooming() {
            return !!this._zooming
          }
          enable(e) {
            this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && e.around === "center")
          }
          disable() {
            this.isEnabled() && (this._enabled = !1)
          }
          _shouldBePrevented(e) {
            return !!this._map.cooperativeGestures.isEnabled() && !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e))
          }
          wheel(e) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(e)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e);
            let a = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;
            const o = me(),
              u = o - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = o, a !== 0 && a % ps == 0 ? this._type = "wheel" : a !== 0 && Math.abs(a) < 4 ? this._type = "trackpad" : u > 400 ? (this._type = null, this._lastValue = a, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(u * a) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, a += this._lastValue)), e.shiftKey && a && (a /= 4), this._type && (this._lastWheelEvent = e, this._delta -= a, this._active || this._start(e)), e.preventDefault()
          }
          _start(e) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const a = q.mousePos(this._map.getCanvas(), e),
              o = this._tr;
            this._aroundPoint = this._aroundCenter ? o.transform.locationToScreenPoint(s.U.convert(o.center)) : a, this._frameId || (this._frameId = !0, this._triggerRenderFrame())
          }
          renderFrame() {
            if (!this._frameId || (this._frameId = null, !this.isActive())) return;
            const e = this._tr.transform;
            if (typeof this._lastExpectedZoom == "number") {
              const w = e.zoom - this._lastExpectedZoom;
              typeof this._startZoom == "number" && (this._startZoom += w), typeof this._targetZoom == "number" && (this._targetZoom += w)
            }
            if (this._delta !== 0) {
              const w = this._type === "wheel" && Math.abs(this._delta) > ps ? this._wheelZoomRate : this._defaultZoomRate;
              let I = 2 / (1 + Math.exp(-Math.abs(this._delta * w)));
              this._delta < 0 && I !== 0 && (I = 1 / I);
              const A = typeof this._targetZoom != "number" ? e.scale : s.al(this._targetZoom);
              this._targetZoom = e.constrain(e.getCameraLngLat(), s.ao(A * I)).zoom, this._type === "wheel" && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0
            }
            const a = typeof this._targetZoom != "number" ? e.zoom : this._targetZoom,
              o = this._startZoom,
              u = this._easing;
            let p, g = !1;
            if (this._type === "wheel" && o && u) {
              const w = me() - this._lastWheelEventTime,
                I = Math.min((w + 5) / 200, 1),
                A = u(I);
              p = s.F.number(o, a, A), I < 1 ? this._frameId || (this._frameId = !0) : g = !0
            } else p = a, g = !0;
            return this._active = !0, g && (this._active = !1, this._finishTimeout = setTimeout((() => {
              this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout
            }), 200)), this._lastExpectedZoom = p, {
              noInertia: !0,
              needsRenderFrame: !g,
              zoomDelta: p - e.zoom,
              around: this._aroundPoint,
              originalEvent: this._lastWheelEvent
            }
          }
          _smoothOutEasing(e) {
            let a = s.cr;
            if (this._prevEase) {
              const o = this._prevEase,
                u = (me() - o.start) / o.duration,
                p = o.easing(u + .01) - o.easing(u),
                g = .27 / Math.sqrt(p * p + 1e-4) * .01,
                w = Math.sqrt(.0729 - g * g);
              a = s.cp(g, w, .25, 1)
            }
            return this._prevEase = {
              start: me(),
              duration: e,
              easing: a
            }, a
          }
          reset() {
            this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout)
          }
        }
        class al {
          constructor(e, a) {
            this._clickZoom = e, this._tapZoom = a
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable()
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable()
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled()
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive()
          }
        }
        class yu {
          constructor(e) {
            this._tr = new rl(e), this.reset()
          }
          reset() {
            this._active = !1
          }
          dblclick(e, a) {
            return e.preventDefault(), {
              cameraAnimation: o => {
                o.easeTo({
                  duration: 300,
                  zoom: this._tr.zoom + (e.shiftKey ? -1 : 1),
                  around: this._tr.unproject(a)
                }, {
                  originalEvent: e
                })
              }
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class Md {
          constructor() {
            this._tap = new Hs({
              numTouches: 1,
              numTaps: 1
            }), this.reset()
          }
          reset() {
            this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset()
          }
          touchstart(e, a, o) {
            if (!this._swipePoint)
              if (this._tapTime) {
                const u = a[0],
                  p = e.timeStamp - this._tapTime < 500,
                  g = this._tapPoint.dist(u) < 30;
                p && g ? o.length > 0 && (this._swipePoint = u, this._swipeTouch = o[0].identifier) : this.reset()
              } else this._tap.touchstart(e, a, o)
          }
          touchmove(e, a, o) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (o[0].identifier !== this._swipeTouch) return;
                const u = a[0],
                  p = u.y - this._swipePoint.y;
                return this._swipePoint = u, e.preventDefault(), this._active = !0, {
                  zoomDelta: p / 128
                }
              }
            } else this._tap.touchmove(e, a, o)
          }
          touchend(e, a, o) {
            if (this._tapTime) this._swipePoint && o.length === 0 && this.reset();
            else {
              const u = this._tap.touchend(e, a, o);
              u && (this._tapTime = e.timeStamp, this._tapPoint = u)
            }
          }
          touchcancel() {
            this.reset()
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class xu {
          constructor(e, a, o) {
            this._el = e, this._mousePan = a, this._touchPan = o
          }
          enable(e) {
            this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan")
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan")
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled()
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive()
          }
        }
        class bu {
          constructor(e, a, o, u) {
            this._pitchWithRotate = e.pitchWithRotate, this._rollEnabled = e.rollEnabled, this._mouseRotate = a, this._mousePitch = o, this._mouseRoll = u
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable()
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable()
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled())
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive()
          }
        }
        class Cd {
          constructor(e, a, o, u) {
            this._el = e, this._touchZoom = a, this._touchRotate = o, this._tapDragZoom = u, this._rotationDisabled = !1, this._enabled = !0
          }
          enable(e) {
            this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate")
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate")
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled()
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive()
          }
          disableRotation() {
            this._rotationDisabled = !0, this._touchRotate.disable()
          }
          enableRotation() {
            this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable()
          }
        }
        class Un {
          constructor(e, a) {
            this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = e, this._options = a, this._enabled = !1
          }
          isActive() {
            return !1
          }
          reset() {}
          _setupUI() {
            if (this._container) return;
            const e = this._map.getCanvasContainer();
            e.classList.add("maplibregl-cooperative-gestures"), this._container = q.create("div", "maplibregl-cooperative-gesture-screen", e);
            let a = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            this._bypassKey === "metaKey" && (a = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const o = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"),
              u = document.createElement("div");
            u.className = "maplibregl-desktop-message", u.textContent = a, this._container.appendChild(u);
            const p = document.createElement("div");
            p.className = "maplibregl-mobile-message", p.textContent = o, this._container.appendChild(p), this._container.setAttribute("aria-hidden", "true")
          }
          _destroyUI() {
            this._container && (q.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container
          }
          enable() {
            this._setupUI(), this._enabled = !0
          }
          disable() {
            this._enabled = !1, this._destroyUI()
          }
          isEnabled() {
            return this._enabled
          }
          isBypassed(e) {
            return e[this._bypassKey]
          }
          notifyGestureBlocked(e, a) {
            this._enabled && (this._map.fire(new s.l("cooperativegestureprevented", {
              gestureType: e,
              originalEvent: a
            })), this._container.classList.add("maplibregl-show"), setTimeout((() => {
              this._container.classList.remove("maplibregl-show")
            }), 100))
          }
        }
        const Xs = d => d.zoom || d.drag || d.roll || d.pitch || d.rotate;
        class Xr extends s.l {}

        function hi(d) {
          return d.panDelta && d.panDelta.mag() || d.zoomDelta || d.bearingDelta || d.pitchDelta || d.rollDelta
        }
        class nl {
          constructor(e, a) {
            this.handleWindowEvent = u => {
              this.handleEvent(u, `${u.type}Window`)
            }, this.handleEvent = (u, p) => {
              if (u.type === "blur") return void this.stop(!0);
              this._updatingCamera = !0;
              const g = u.type === "renderFrame" ? void 0 : u,
                w = {
                  needsRenderFrame: !1
                },
                I = {},
                A = {};
              for (const {
                  handlerName: R,
                  handler: H,
                  allowed: $
                }
                of this._handlers) {
                if (!H.isEnabled()) continue;
                let ce;
                if (this._blockedByActive(A, $, R)) H.reset();
                else if (H[p || u.type]) {
                  if (s.cs(u, p || u.type)) {
                    const ue = q.mousePos(this._map.getCanvas(), u);
                    ce = H[p || u.type](u, ue)
                  } else if (s.ct(u, p || u.type)) {
                    const ue = this._getMapTouches(u.touches),
                      de = q.touchPos(this._map.getCanvas(), ue);
                    ce = H[p || u.type](u, de, ue)
                  } else s.cu(p || u.type) || (ce = H[p || u.type](u));
                  this.mergeHandlerResult(w, I, ce, R, g), ce && ce.needsRenderFrame && this._triggerRenderFrame()
                }(ce || H.isActive()) && (A[R] = H)
              }
              const L = {};
              for (const R in this._previousActiveHandlers) A[R] || (L[R] = g);
              this._previousActiveHandlers = A, (Object.keys(L).length || hi(w)) && (this._changes.push([w, I, L]), this._triggerRenderFrame()), (Object.keys(A).length || hi(w)) && this._map._stop(!0), this._updatingCamera = !1;
              const {
                cameraAnimation: O
              } = w;
              O && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], O(this._map))
            }, this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new md(e), this._bearingSnap = a.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(a);
            const o = this._el;
            this._listeners = [
              [o, "touchstart", {
                passive: !0
              }],
              [o, "touchmove", {
                passive: !1
              }],
              [o, "touchend", void 0],
              [o, "touchcancel", void 0],
              [o, "mousedown", void 0],
              [o, "mousemove", void 0],
              [o, "mouseup", void 0],
              [document, "mousemove", {
                capture: !0
              }],
              [document, "mouseup", void 0],
              [o, "mouseover", void 0],
              [o, "mouseout", void 0],
              [o, "dblclick", void 0],
              [o, "click", void 0],
              [o, "keydown", {
                capture: !1
              }],
              [o, "keyup", void 0],
              [o, "wheel", {
                passive: !1
              }],
              [o, "contextmenu", void 0],
              [window, "blur", void 0]
            ];
            for (const [u, p, g] of this._listeners) q.addEventListener(u, p, u === document ? this.handleWindowEvent : this.handleEvent, g)
          }
          destroy() {
            for (const [e, a, o] of this._listeners) q.removeEventListener(e, a, e === document ? this.handleWindowEvent : this.handleEvent, o)
          }
          _addDefaultHandlers(e) {
            const a = this._map,
              o = a.getCanvasContainer();
            this._add("mapEvent", new Mo(a, e));
            const u = a.boxZoom = new _d(a, e);
            this._add("boxZoom", u), e.interactive && e.boxZoom && u.enable();
            const p = a.cooperativeGestures = new Un(a, e.cooperativeGestures);
            this._add("cooperativeGestures", p), e.cooperativeGestures && p.enable();
            const g = new hs(a),
              w = new yu(a);
            a.doubleClickZoom = new al(w, g), this._add("tapZoom", g), this._add("clickZoom", w), e.interactive && e.doubleClickZoom && a.doubleClickZoom.enable();
            const I = new Md;
            this._add("tapDragZoom", I);
            const A = a.touchPitch = new Td(a);
            this._add("touchPitch", A), e.interactive && e.touchPitch && a.touchPitch.enable(e.touchPitch);
            const L = () => a.project(a.getCenter()),
              O = (function({
                enable: Ie,
                clickTolerance: Oe,
                aroundCenter: He = !0,
                minPixelCenterThreshold: Le = 100,
                rotateDegreesPerPixelMoved: $e = .8
              }, vt) {
                const ft = new ds({
                  checkCorrectEvent: gt => q.mouseButton(gt) === 0 && gt.ctrlKey || q.mouseButton(gt) === 2 && !gt.ctrlKey
                });
                return new zr({
                  clickTolerance: Oe,
                  move: (gt, xt) => {
                    const lr = vt();
                    if (He && Math.abs(lr.y - gt.y) > Le) return {
                      bearingDelta: s.cq(new s.P(gt.x, xt.y), xt, lr)
                    };
                    let cr = (xt.x - gt.x) * $e;
                    return He && xt.y < lr.y && (cr = -cr), {
                      bearingDelta: cr
                    }
                  },
                  moveStateManager: ft,
                  enable: Ie,
                  assignEvents: Bi
                })
              })(e, L),
              R = (function({
                enable: Ie,
                clickTolerance: Oe,
                pitchDegreesPerPixelMoved: He = -.5
              }) {
                const Le = new ds({
                  checkCorrectEvent: $e => q.mouseButton($e) === 0 && $e.ctrlKey || q.mouseButton($e) === 2
                });
                return new zr({
                  clickTolerance: Oe,
                  move: ($e, vt) => ({
                    pitchDelta: (vt.y - $e.y) * He
                  }),
                  moveStateManager: Le,
                  enable: Ie,
                  assignEvents: Bi
                })
              })(e),
              H = (function({
                enable: Ie,
                clickTolerance: Oe,
                rollDegreesPerPixelMoved: He = .3
              }, Le) {
                const $e = new ds({
                  checkCorrectEvent: vt => q.mouseButton(vt) === 2 && vt.ctrlKey
                });
                return new zr({
                  clickTolerance: Oe,
                  move: (vt, ft) => {
                    const gt = Le();
                    let xt = (ft.x - vt.x) * He;
                    return ft.y < gt.y && (xt = -xt), {
                      rollDelta: xt
                    }
                  },
                  moveStateManager: $e,
                  enable: Ie,
                  assignEvents: Bi
                })
              })(e, L);
            a.dragRotate = new bu(e, O, R, H), this._add("mouseRotate", O, ["mousePitch"]), this._add("mousePitch", R, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", H, ["mousePitch"]), e.interactive && e.dragRotate && a.dragRotate.enable();
            const $ = (function({
                enable: Ie,
                clickTolerance: Oe
              }) {
                const He = new ds({
                  checkCorrectEvent: Le => q.mouseButton(Le) === 0 && !Le.ctrlKey
                });
                return new zr({
                  clickTolerance: Oe,
                  move: (Le, $e) => ({
                    around: $e,
                    panDelta: $e.sub(Le)
                  }),
                  activateOnStart: !0,
                  moveStateManager: He,
                  enable: Ie,
                  assignEvents: Bi
                })
              })(e),
              ce = new gu(e, a);
            a.dragPan = new xu(o, $, ce), this._add("mousePan", $), this._add("touchPan", ce, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && a.dragPan.enable(e.dragPan);
            const ue = new Yl,
              de = new wd;
            a.touchZoomRotate = new Cd(o, de, ue, I), this._add("touchRotate", ue, ["touchPan", "touchZoom"]), this._add("touchZoom", de, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && a.touchZoomRotate.enable(e.touchZoomRotate), this._add("blockableMapEvent", new of(a));
            const Ce = a.scrollZoom = new Id(a, (() => this._triggerRenderFrame()));
            this._add("scrollZoom", Ce, ["mousePan"]), e.interactive && e.scrollZoom && a.scrollZoom.enable(e.scrollZoom);
            const Be = a.keyboard = new Pd(a);
            this._add("keyboard", Be), e.interactive && e.keyboard && a.keyboard.enable()
          }
          _add(e, a, o) {
            this._handlers.push({
              handlerName: e,
              handler: a,
              allowed: o
            }), this._handlersById[e] = a
          }
          stop(e) {
            if (!this._updatingCamera) {
              for (const {
                  handler: a
                }
                of this._handlers) a.reset();
              this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = []
            }
          }
          isActive() {
            for (const {
                handler: e
              }
              of this._handlers)
              if (e.isActive()) return !0;
            return !1
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming()
          }
          isRotating() {
            return !!this._eventsInProgress.rotate
          }
          isMoving() {
            return !!Xs(this._eventsInProgress) || this.isZooming()
          }
          _blockedByActive(e, a, o) {
            for (const u in e)
              if (u !== o && (!a || a.indexOf(u) < 0)) return !0;
            return !1
          }
          _getMapTouches(e) {
            const a = [];
            for (const o of e) this._el.contains(o.target) && a.push(o);
            return a
          }
          mergeHandlerResult(e, a, o, u, p) {
            if (!o) return;
            s.e(e, o);
            const g = {
              handlerName: u,
              originalEvent: o.originalEvent || p
            };
            o.zoomDelta !== void 0 && (a.zoom = g), o.panDelta !== void 0 && (a.drag = g), o.rollDelta !== void 0 && (a.roll = g), o.pitchDelta !== void 0 && (a.pitch = g), o.bearingDelta !== void 0 && (a.rotate = g)
          }
          _applyChanges() {
            const e = {},
              a = {},
              o = {};
            for (const [u, p, g] of this._changes) u.panDelta && (e.panDelta = (e.panDelta || new s.P(0, 0))._add(u.panDelta)), u.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + u.zoomDelta), u.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + u.bearingDelta), u.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + u.pitchDelta), u.rollDelta && (e.rollDelta = (e.rollDelta || 0) + u.rollDelta), u.around !== void 0 && (e.around = u.around), u.pinchAround !== void 0 && (e.pinchAround = u.pinchAround), u.noInertia && (e.noInertia = u.noInertia), s.e(a, p), s.e(o, g);
            this._updateMapTransform(e, a, o), this._changes = []
          }
          _updateMapTransform(e, a, o) {
            const u = this._map,
              p = u._getTransformForUpdate(),
              g = u.terrain;
            if (!(hi(e) || g && this._terrainMovement)) return this._fireEvents(a, o, !0);
            u._stop(!0);
            let {
              panDelta: w,
              zoomDelta: I,
              bearingDelta: A,
              pitchDelta: L,
              rollDelta: O,
              around: R,
              pinchAround: H
            } = e;
            H !== void 0 && (R = H), R = R || u.transform.centerPoint, g && !p.isPointOnMapSurface(R) && (R = p.centerPoint);
            const $ = {
              panDelta: w,
              zoomDelta: I,
              rollDelta: O,
              pitchDelta: L,
              bearingDelta: A,
              around: R
            };
            this._map.cameraHelper.useGlobeControls && !p.isPointOnMapSurface(R) && (R = p.centerPoint);
            const ce = R.distSqr(p.centerPoint) < .01 ? p.center : p.screenPointToLocation(w ? R.sub(w) : R);
            this._handleMapControls({
              terrain: g,
              tr: p,
              deltasForHelper: $,
              preZoomAroundLoc: ce,
              combinedEventsInProgress: a,
              panDelta: w
            }), u._applyUpdatedTransform(p), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(a, o, !0)
          }
          _handleMapControls({
            terrain: e,
            tr: a,
            deltasForHelper: o,
            preZoomAroundLoc: u,
            combinedEventsInProgress: p,
            panDelta: g
          }) {
            const w = this._map.cameraHelper;
            if (w.handleMapControlsRollPitchBearingZoom(o, a), e) return w.useGlobeControls ? (this._terrainMovement || !p.drag && !p.zoom || (this._terrainMovement = !0, this._map._elevationFreeze = !0), void w.handleMapControlsPan(o, a, u)) : this._terrainMovement || !p.drag && !p.zoom ? void(p.drag && this._terrainMovement && g ? a.setCenter(a.screenPointToLocation(a.centerPoint.sub(g))) : w.handleMapControlsPan(o, a, u)) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, void w.handleMapControlsPan(o, a, u));
            w.handleMapControlsPan(o, a, u)
          }
          _fireEvents(e, a, o) {
            const u = Xs(this._eventsInProgress),
              p = Xs(e),
              g = {};
            for (const O in e) {
              const {
                originalEvent: R
              } = e[O];
              this._eventsInProgress[O] || (g[`${O}start`] = R), this._eventsInProgress[O] = e[O]
            }!u && p && this._fireEvent("movestart", p.originalEvent);
            for (const O in g) this._fireEvent(O, g[O]);
            p && this._fireEvent("move", p.originalEvent);
            for (const O in e) {
              const {
                originalEvent: R
              } = e[O];
              this._fireEvent(O, R)
            }
            const w = {};
            let I;
            for (const O in this._eventsInProgress) {
              const {
                handlerName: R,
                originalEvent: H
              } = this._eventsInProgress[O];
              this._handlersById[R].isActive() || (delete this._eventsInProgress[O], I = a[R] || H, w[`${O}end`] = I)
            }
            for (const O in w) this._fireEvent(O, w[O]);
            const A = Xs(this._eventsInProgress),
              L = (u || p) && !A;
            if (L && this._terrainMovement) {
              this._map._elevationFreeze = !1, this._terrainMovement = !1;
              const O = this._map._getTransformForUpdate();
              this._map.getCenterClampedToGround() && O.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(O)
            }
            if (o && L) {
              this._updatingCamera = !0;
              const O = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),
                R = H => H !== 0 && -this._bearingSnap < H && H < this._bearingSnap;
              !O || !O.essential && re.prefersReducedMotion ? (this._map.fire(new s.l("moveend", {
                originalEvent: I
              })), R(this._map.getBearing()) && this._map.resetNorth()) : (R(O.bearing || this._map.getBearing()) && (O.bearing = 0), O.freezeElevation = !0, this._map.easeTo(O, {
                originalEvent: I
              })), this._updatingCamera = !1
            }
          }
          _fireEvent(e, a) {
            this._map.fire(new s.l(e, a ? {
              originalEvent: a
            } : {}))
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e => {
              delete this._frameId, this.handleEvent(new Xr("renderFrame", {
                timeStamp: e
              })), this._applyChanges()
            }))
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame())
          }
        }
        class Ad extends s.E {
          constructor(e, a, o) {
            super(), this._renderFrameCallback = () => {
              const u = Math.min((me() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(u)), u < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop()
            }, this._moving = !1, this._zooming = !1, this.transform = e, this._bearingSnap = o.bearingSnap, this.cameraHelper = a, this.on("moveend", (() => {
              delete this._requestedCameraState
            }))
          }
          migrateProjection(e, a) {
            e.apply(this.transform), this.transform = e, this.cameraHelper = a
          }
          getCenter() {
            return new s.U(this.transform.center.lng, this.transform.center.lat)
          }
          setCenter(e, a) {
            return this.jumpTo({
              center: e
            }, a)
          }
          getCenterElevation() {
            return this.transform.elevation
          }
          setCenterElevation(e, a) {
            return this.jumpTo({
              elevation: e
            }, a), this
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround
          }
          setCenterClampedToGround(e) {
            this._centerClampedToGround = e
          }
          panBy(e, a, o) {
            return e = s.P.convert(e).mult(-1), this.panTo(this.transform.center, s.e({
              offset: e
            }, a), o)
          }
          panTo(e, a, o) {
            return this.easeTo(s.e({
              center: e
            }, a), o)
          }
          getZoom() {
            return this.transform.zoom
          }
          setZoom(e, a) {
            return this.jumpTo({
              zoom: e
            }, a), this
          }
          zoomTo(e, a, o) {
            return this.easeTo(s.e({
              zoom: e
            }, a), o)
          }
          zoomIn(e, a) {
            return this.zoomTo(this.getZoom() + 1, e, a), this
          }
          zoomOut(e, a) {
            return this.zoomTo(this.getZoom() - 1, e, a), this
          }
          getVerticalFieldOfView() {
            return this.transform.fov
          }
          setVerticalFieldOfView(e, a) {
            return e != this.transform.fov && (this.transform.setFov(e), this.fire(new s.l("movestart", a)).fire(new s.l("move", a)).fire(new s.l("moveend", a))), this
          }
          getBearing() {
            return this.transform.bearing
          }
          setBearing(e, a) {
            return this.jumpTo({
              bearing: e
            }, a), this
          }
          getPadding() {
            return this.transform.padding
          }
          setPadding(e, a) {
            return this.jumpTo({
              padding: e
            }, a), this
          }
          rotateTo(e, a, o) {
            return this.easeTo(s.e({
              bearing: e
            }, a), o)
          }
          resetNorth(e, a) {
            return this.rotateTo(0, s.e({
              duration: 1e3
            }, e), a), this
          }
          resetNorthPitch(e, a) {
            return this.easeTo(s.e({
              bearing: 0,
              pitch: 0,
              roll: 0,
              duration: 1e3
            }, e), a), this
          }
          snapToNorth(e, a) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, a) : this
          }
          getPitch() {
            return this.transform.pitch
          }
          setPitch(e, a) {
            return this.jumpTo({
              pitch: e
            }, a), this
          }
          getRoll() {
            return this.transform.roll
          }
          setRoll(e, a) {
            return this.jumpTo({
              roll: e
            }, a), this
          }
          cameraForBounds(e, a) {
            e = Ut.convert(e).adjustAntiMeridian();
            const o = a && a.bearing || 0;
            return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), o, a)
          }
          _cameraForBoxAndBearing(e, a, o, u) {
            const p = {
              top: 0,
              bottom: 0,
              right: 0,
              left: 0
            };
            if (typeof(u = s.e({
                padding: p,
                offset: [0, 0],
                maxZoom: this.transform.maxZoom
              }, u)).padding == "number") {
              const A = u.padding;
              u.padding = {
                top: A,
                bottom: A,
                right: A,
                left: A
              }
            }
            const g = s.e(p, u.padding);
            u.padding = g;
            const w = this.transform,
              I = new Ut(e, a);
            return this.cameraHelper.cameraForBoxAndBearing(u, g, I, o, w)
          }
          fitBounds(e, a, o) {
            return this._fitInternal(this.cameraForBounds(e, a), a, o)
          }
          fitScreenCoordinates(e, a, o, u, p) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(s.P.convert(e)), this.transform.screenPointToLocation(s.P.convert(a)), o, u), u, p)
          }
          _fitInternal(e, a, o) {
            return e ? (delete(a = s.e(e, a)).padding, a.linear ? this.easeTo(a, o) : this.flyTo(a, o)) : this
          }
          jumpTo(e, a) {
            this.stop();
            const o = this._getTransformForUpdate();
            let u = !1,
              p = !1,
              g = !1;
            const w = o.zoom;
            this.cameraHelper.handleJumpToCenterZoom(o, e);
            const I = o.zoom !== w;
            return "elevation" in e && o.elevation !== +e.elevation && o.setElevation(+e.elevation), "bearing" in e && o.bearing !== +e.bearing && (u = !0, o.setBearing(+e.bearing)), "pitch" in e && o.pitch !== +e.pitch && (p = !0, o.setPitch(+e.pitch)), "roll" in e && o.roll !== +e.roll && (g = !0, o.setRoll(+e.roll)), e.padding == null || o.isPaddingEqual(e.padding) || o.setPadding(e.padding), this._applyUpdatedTransform(o), this.fire(new s.l("movestart", a)).fire(new s.l("move", a)), I && this.fire(new s.l("zoomstart", a)).fire(new s.l("zoom", a)).fire(new s.l("zoomend", a)), u && this.fire(new s.l("rotatestart", a)).fire(new s.l("rotate", a)).fire(new s.l("rotateend", a)), p && this.fire(new s.l("pitchstart", a)).fire(new s.l("pitch", a)).fire(new s.l("pitchend", a)), g && this.fire(new s.l("rollstart", a)).fire(new s.l("roll", a)).fire(new s.l("rollend", a)), this.fire(new s.l("moveend", a))
          }
          calculateCameraOptionsFromTo(e, a, o, u = 0) {
            const p = s.a5.fromLngLat(e, a),
              g = s.a5.fromLngLat(o, u),
              w = g.x - p.x,
              I = g.y - p.y,
              A = g.z - p.z,
              L = Math.hypot(w, I, A);
            if (L === 0) throw new Error("Can't calculate camera options with same From and To");
            const O = Math.hypot(w, I),
              R = s.ao(this.transform.cameraToCenterDistance / L / this.transform.tileSize),
              H = 180 * Math.atan2(w, -I) / Math.PI;
            let $ = 180 * Math.acos(O / L) / Math.PI;
            return $ = A < 0 ? 90 - $ : 90 + $, {
              center: g.toLngLat(),
              elevation: u,
              zoom: R,
              pitch: $,
              bearing: H
            }
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(e, a, o, u, p) {
            const g = this.transform.calculateCenterFromCameraLngLatAlt(e, a, o, u);
            return {
              center: g.center,
              elevation: g.elevation,
              zoom: g.zoom,
              bearing: o,
              pitch: u,
              roll: p
            }
          }
          easeTo(e, a) {
            this._stop(!1, e.easeId), ((e = s.e({
              offset: [0, 0],
              duration: 500,
              easing: s.cr
            }, e)).animate === !1 || !e.essential && re.prefersReducedMotion) && (e.duration = 0);
            const o = this._getTransformForUpdate(),
              u = this.getBearing(),
              p = o.pitch,
              g = o.roll,
              w = "bearing" in e ? this._normalizeBearing(e.bearing, u) : u,
              I = "pitch" in e ? +e.pitch : p,
              A = "roll" in e ? this._normalizeBearing(e.roll, g) : g,
              L = "padding" in e ? e.padding : o.padding,
              O = s.P.convert(e.offset);
            let R, H;
            e.around && (R = s.U.convert(e.around), H = o.locationToScreenPoint(R));
            const $ = {
                moving: this._moving,
                zooming: this._zooming,
                rotating: this._rotating,
                pitching: this._pitching,
                rolling: this._rolling
              },
              ce = this.cameraHelper.handleEaseTo(o, {
                bearing: w,
                pitch: I,
                roll: A,
                padding: L,
                around: R,
                aroundPoint: H,
                offsetAsPoint: O,
                offset: e.offset,
                zoom: e.zoom,
                center: e.center
              });
            return this._rotating = this._rotating || u !== w, this._pitching = this._pitching || I !== p, this._rolling = this._rolling || A !== g, this._padding = !o.isPaddingEqual(L), this._zooming = this._zooming || ce.isZooming, this._easeId = e.easeId, this._prepareEase(a, e.noMoveStart, $), this.terrain && this._prepareElevation(ce.elevationCenter), this._ease((ue => {
              ce.easeFunc(ue), this.terrain && !e.freezeElevation && this._updateElevation(ue), this._applyUpdatedTransform(o), this._fireMoveEvents(a)
            }), (ue => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(a, ue)
            }), e), this
          }
          _prepareEase(e, a, o = {}) {
            this._moving = !0, a || o.moving || this.fire(new s.l("movestart", e)), this._zooming && !o.zooming && this.fire(new s.l("zoomstart", e)), this._rotating && !o.rotating && this.fire(new s.l("rotatestart", e)), this._pitching && !o.pitching && this.fire(new s.l("pitchstart", e)), this._rolling && !o.rolling && this.fire(new s.l("rollstart", e))
          }
          _prepareElevation(e) {
            this._elevationCenter = e, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom), this._elevationFreeze = !0
          }
          _updateElevation(e) {
            this._elevationStart !== void 0 && this._elevationCenter !== void 0 || this._prepareElevation(this.transform.center), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
            const a = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (e < 1 && a !== this._elevationTarget) {
              const o = this._elevationTarget - this._elevationStart;
              this._elevationStart += e * (o - (a - (o * e + this._elevationStart)) / (1 - e)), this._elevationTarget = a
            }
            this.transform.setElevation(s.F.number(this._elevationStart, this._elevationTarget, e))
          }
          _finalizeElevation() {
            this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain)
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform
          }
          _elevateCameraIfInsideTerrain(e) {
            if (!this.terrain && e.elevation >= 0 && e.pitch <= 90) return {};
            const a = e.getCameraLngLat(),
              o = e.getCameraAltitude(),
              u = this.terrain ? this.terrain.getElevationForLngLatZoom(a, e.zoom) : 0;
            if (o < u) {
              const p = this.calculateCameraOptionsFromTo(a, u, e.center, e.elevation);
              return {
                pitch: p.pitch,
                zoom: p.zoom
              }
            }
            return {}
          }
          _applyUpdatedTransform(e) {
            const a = [];
            if (a.push((u => this._elevateCameraIfInsideTerrain(u))), this.transformCameraUpdate && a.push((u => this.transformCameraUpdate(u))), !a.length) return;
            const o = e.clone();
            for (const u of a) {
              const p = o.clone(),
                {
                  center: g,
                  zoom: w,
                  roll: I,
                  pitch: A,
                  bearing: L,
                  elevation: O
                } = u(p);
              g && p.setCenter(g), O !== void 0 && p.setElevation(O), w !== void 0 && p.setZoom(w), I !== void 0 && p.setRoll(I), A !== void 0 && p.setPitch(A), L !== void 0 && p.setBearing(L), o.apply(p)
            }
            this.transform.apply(o)
          }
          _fireMoveEvents(e) {
            this.fire(new s.l("move", e)), this._zooming && this.fire(new s.l("zoom", e)), this._rotating && this.fire(new s.l("rotate", e)), this._pitching && this.fire(new s.l("pitch", e)), this._rolling && this.fire(new s.l("roll", e))
          }
          _afterEase(e, a) {
            if (this._easeId && a && this._easeId === a) return;
            delete this._easeId;
            const o = this._zooming,
              u = this._rotating,
              p = this._pitching,
              g = this._rolling;
            this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, o && this.fire(new s.l("zoomend", e)), u && this.fire(new s.l("rotateend", e)), p && this.fire(new s.l("pitchend", e)), g && this.fire(new s.l("rollend", e)), this.fire(new s.l("moveend", e))
          }
          flyTo(e, a) {
            if (!e.essential && re.prefersReducedMotion) {
              const xt = s.S(e, ["center", "zoom", "bearing", "pitch", "roll", "elevation", "padding"]);
              return this.jumpTo(xt, a)
            }
            this.stop(), e = s.e({
              offset: [0, 0],
              speed: 1.2,
              curve: 1.42,
              easing: s.cr
            }, e);
            const o = this._getTransformForUpdate(),
              u = o.bearing,
              p = o.pitch,
              g = o.roll,
              w = o.padding,
              I = "bearing" in e ? this._normalizeBearing(e.bearing, u) : u,
              A = "pitch" in e ? +e.pitch : p,
              L = "roll" in e ? this._normalizeBearing(e.roll, g) : g,
              O = "padding" in e ? e.padding : o.padding,
              R = s.P.convert(e.offset);
            let H = o.centerPoint.add(R);
            const $ = o.screenPointToLocation(H),
              ce = this.cameraHelper.handleFlyTo(o, {
                bearing: I,
                pitch: A,
                roll: L,
                padding: O,
                locationAtOffset: $,
                offsetAsPoint: R,
                center: e.center,
                minZoom: e.minZoom,
                zoom: e.zoom
              });
            let ue = e.curve;
            const de = Math.max(o.width, o.height),
              Ce = de / ce.scaleOfZoom,
              Be = ce.pixelPathLength;
            typeof ce.scaleOfMinZoom == "number" && (ue = Math.sqrt(de / ce.scaleOfMinZoom / Be * 2));
            const Ie = ue * ue;

            function Oe(xt) {
              const lr = (Ce * Ce - de * de + (xt ? -1 : 1) * Ie * Ie * Be * Be) / (2 * (xt ? Ce : de) * Ie * Be);
              return Math.log(Math.sqrt(lr * lr + 1) - lr)
            }

            function He(xt) {
              return (Math.exp(xt) - Math.exp(-xt)) / 2
            }

            function Le(xt) {
              return (Math.exp(xt) + Math.exp(-xt)) / 2
            }
            const $e = Oe(!1);
            let vt = function(xt) {
                return Le($e) / Le($e + ue * xt)
              },
              ft = function(xt) {
                return de * ((Le($e) * (He(lr = $e + ue * xt) / Le(lr)) - He($e)) / Ie) / Be;
                var lr
              },
              gt = (Oe(!0) - $e) / ue;
            if (Math.abs(Be) < 2e-6 || !isFinite(gt)) {
              if (Math.abs(de - Ce) < 1e-6) return this.easeTo(e, a);
              const xt = Ce < de ? -1 : 1;
              gt = Math.abs(Math.log(Ce / de)) / ue, ft = () => 0, vt = lr => Math.exp(xt * ue * lr)
            }
            return e.duration = "duration" in e ? +e.duration : 1e3 * gt / ("screenSpeed" in e ? +e.screenSpeed / ue : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = !0, this._rotating = u !== I, this._pitching = A !== p, this._rolling = L !== g, this._padding = !o.isPaddingEqual(O), this._prepareEase(a, !1), this.terrain && this._prepareElevation(ce.targetCenter), this._ease((xt => {
              const lr = xt * gt,
                cr = 1 / vt(lr),
                Nt = ft(lr);
              this._rotating && o.setBearing(s.F.number(u, I, xt)), this._pitching && o.setPitch(s.F.number(p, A, xt)), this._rolling && o.setRoll(s.F.number(g, L, xt)), this._padding && (o.interpolatePadding(w, O, xt), H = o.centerPoint.add(R)), ce.easeFunc(xt, cr, Nt, H), this.terrain && !e.freezeElevation && this._updateElevation(xt), this._applyUpdatedTransform(o), this._fireMoveEvents(a)
            }), (() => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(a)
            }), e), this
          }
          isEasing() {
            return !!this._easeFrameId
          }
          stop() {
            return this._stop()
          }
          _stop(e, a) {
            var o;
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const u = this._onEaseEnd;
              delete this._onEaseEnd, u.call(this, a)
            }
            return e || (o = this.handlers) === null || o === void 0 || o.stop(!1), this
          }
          _ease(e, a, o) {
            o.animate === !1 || o.duration === 0 ? (e(1), a()) : (this._easeStart = me(), this._easeOptions = o, this._onEaseFrame = e, this._onEaseEnd = a, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback))
          }
          _normalizeBearing(e, a) {
            e = s.V(e, -180, 180);
            const o = Math.abs(e - a);
            return Math.abs(e - 360 - a) < o && (e -= 360), Math.abs(e + 360 - a) < o && (e += 360), e
          }
          queryTerrainElevation(e) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(s.U.convert(e), this.transform.tileZoom) : null
          }
        }
        const sl = {
          compact: !0,
          customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>'
        };
        class an {
          constructor(e = sl) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")))
            }, this._updateData = a => {
              !a || a.sourceDataType !== "metadata" && a.sourceDataType !== "visibility" && a.dataType !== "style" && a.type !== "terrain" || this._updateAttributions()
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"))
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show")
            }, this.options = e
          }
          getDefaultPosition() {
            return "bottom-right"
          }
          onAdd(e) {
            return this._map = e, this._compact = this.options.compact, this._container = q.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = q.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = q.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container
          }
          onRemove() {
            q.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0
          }
          _setElementTitle(e, a) {
            const o = this._map._getUIString(`AttributionControl.${a}`);
            e.title = o, e.setAttribute("aria-label", o)
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let e = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map((u => typeof u != "string" ? "" : u))) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const u = this._map.style.stylesheet;
              this.styleOwner = u.owner, this.styleId = u.id
            }
            const a = this._map.style.tileManagers;
            for (const u in a) {
              const p = a[u];
              if (p.used || p.usedForTerrain) {
                const g = p.getSource();
                g.attribution && e.indexOf(g.attribution) < 0 && e.push(g.attribution)
              }
            }
            e = e.filter((u => String(u).trim())), e.sort(((u, p) => u.length - p.length)), e = e.filter(((u, p) => {
              for (let g = p + 1; g < e.length; g++)
                if (e[g].indexOf(u) >= 0) return !1;
              return !0
            }));
            const o = e.join(" | ");
            o !== this._attribHTML && (this._attribHTML = o, e.length ? (this._innerContainer.innerHTML = q.sanitize(o), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null)
          }
        }
        class wu {
          constructor(e = {}) {
            this._updateCompact = () => {
              const a = this._container.children;
              if (a.length) {
                const o = a[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && o.classList.add("maplibregl-compact") : o.classList.remove("maplibregl-compact")
              }
            }, this.options = e
          }
          getDefaultPosition() {
            return "bottom-left"
          }
          onAdd(e) {
            this._map = e, this._compact = this.options && this.options.compact, this._container = q.create("div", "maplibregl-ctrl");
            const a = q.create("a", "maplibregl-ctrl-logo");
            return a.target = "_blank", a.rel = "noopener nofollow", a.href = "https://maplibre.org/", a.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), a.setAttribute("rel", "noopener nofollow"), this._container.appendChild(a), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container
          }
          onRemove() {
            q.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0
          }
        }
        class Zn {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1
          }
          add(e) {
            const a = ++this._id;
            return this._queue.push({
              callback: e,
              id: a,
              cancelled: !1
            }), a
          }
          remove(e) {
            const a = this._currentlyRunning,
              o = a ? this._queue.concat(a) : this._queue;
            for (const u of o)
              if (u.id === e) return void(u.cancelled = !0)
          }
          run(e = 0) {
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const a = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const o of a)
              if (!o.cancelled && (o.callback(e), this._cleared)) break;
            this._cleared = !1, this._currentlyRunning = !1
          }
          clear() {
            this._currentlyRunning && (this._cleared = !0), this._queue = []
          }
        }
        var kd = s.aN([{
          name: "a_pos3d",
          type: "Int16",
          components: 3
        }]);
        class cf extends s.E {
          constructor(e) {
            super(), this._lastTilesetChange = me(), this.tileManager = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e._source.tileSize * 2 ** this.deltaZoom, e.usedForTerrain = !0, e.tileSize = this.tileSize
          }
          destruct() {
            this.tileManager.usedForTerrain = !1, this.tileManager.tileSize = null
          }
          getSource() {
            return this.tileManager._source
          }
          update(e, a) {
            this.tileManager.update(e, a), this._renderableTilesKeys = [];
            const o = {};
            for (const u of it(e, {
                tileSize: this.tileSize,
                minzoom: this.minzoom,
                maxzoom: this.maxzoom,
                reparseOverscaled: !1,
                terrain: a,
                calculateTileZoom: this.tileManager._source.calculateTileZoom
              })) o[u.key] = !0, this._renderableTilesKeys.push(u.key), this._tiles[u.key] || (u.terrainRttPosMatrix32f = new Float64Array(16), s.c0(u.terrainRttPosMatrix32f, 0, s.a3, s.a3, 0, 0, 1), this._tiles[u.key] = new te(u, this.tileSize), this._lastTilesetChange = me());
            for (const u in this._tiles) o[u] || delete this._tiles[u]
          }
          freeRtt(e) {
            for (const a in this._tiles) {
              const o = this._tiles[a];
              (!e || o.tileID.equals(e) || o.tileID.isChildOf(e) || e.isChildOf(o.tileID)) && (o.rtt = [])
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map((e => this.getTileByID(e)))
          }
          getTileByID(e) {
            return this._tiles[e]
          }
          getTerrainCoords(e, a) {
            return a ? this._getTerrainCoordsForTileRanges(e, a) : this._getTerrainCoordsForRegularTile(e)
          }
          _getTerrainCoordsForRegularTile(e) {
            const a = {};
            for (const o of this._renderableTilesKeys) {
              const u = this._tiles[o].tileID,
                p = e.clone(),
                g = s.bd();
              if (u.canonical.equals(e.canonical)) s.c0(g, 0, s.a3, s.a3, 0, 0, 1);
              else if (u.canonical.isChildOf(e.canonical)) {
                const w = u.canonical.z - e.canonical.z,
                  I = u.canonical.x - (u.canonical.x >> w << w),
                  A = u.canonical.y - (u.canonical.y >> w << w),
                  L = s.a3 >> w;
                s.c0(g, 0, L, L, 0, 0, 1), s.N(g, g, [-I * L, -A * L, 0])
              } else {
                if (!e.canonical.isChildOf(u.canonical)) continue;
                {
                  const w = e.canonical.z - u.canonical.z,
                    I = e.canonical.x - (e.canonical.x >> w << w),
                    A = e.canonical.y - (e.canonical.y >> w << w),
                    L = s.a3 >> w;
                  s.c0(g, 0, s.a3, s.a3, 0, 0, 1), s.N(g, g, [I * L, A * L, 0]), s.O(g, g, [1 / 2 ** w, 1 / 2 ** w, 0])
                }
              }
              p.terrainRttPosMatrix32f = new Float32Array(g), a[o] = p
            }
            return a
          }
          _getTerrainCoordsForTileRanges(e, a) {
            const o = {};
            for (const u of this._renderableTilesKeys) {
              const p = this._tiles[u].tileID;
              if (!this._isWithinTileRanges(p, a)) continue;
              const g = e.clone(),
                w = s.bd();
              if (p.canonical.z === e.canonical.z) {
                const I = e.canonical.x - p.canonical.x,
                  A = e.canonical.y - p.canonical.y;
                s.c0(w, 0, s.a3, s.a3, 0, 0, 1), s.N(w, w, [I * s.a3, A * s.a3, 0])
              } else if (p.canonical.z > e.canonical.z) {
                const I = p.canonical.z - e.canonical.z,
                  A = p.canonical.x - (p.canonical.x >> I << I),
                  L = p.canonical.y - (p.canonical.y >> I << I),
                  O = e.canonical.x - (p.canonical.x >> I),
                  R = e.canonical.y - (p.canonical.y >> I),
                  H = s.a3 >> I;
                s.c0(w, 0, H, H, 0, 0, 1), s.N(w, w, [-A * H + O * s.a3, -L * H + R * s.a3, 0])
              } else {
                const I = e.canonical.z - p.canonical.z,
                  A = e.canonical.x - (e.canonical.x >> I << I),
                  L = e.canonical.y - (e.canonical.y >> I << I),
                  O = (e.canonical.x >> I) - p.canonical.x,
                  R = (e.canonical.y >> I) - p.canonical.y,
                  H = s.a3 << I;
                s.c0(w, 0, H, H, 0, 0, 1), s.N(w, w, [A * s.a3 + O * H, L * s.a3 + R * H, 0])
              }
              g.terrainRttPosMatrix32f = new Float32Array(w), o[u] = g
            }
            return o
          }
          getSourceTile(e, a) {
            const o = this.tileManager._source;
            let u = e.overscaledZ - this.deltaZoom;
            if (u > o.maxzoom && (u = o.maxzoom), u < o.minzoom) return null;
            this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(u).key);
            let p = this.tileManager.getTileByID(this._sourceTileCache[e.key]);
            if ((!p || !p.dem) && a)
              for (; u >= o.minzoom && (!p || !p.dem);) p = this.tileManager.getTileByID(e.scaledTo(u--).key);
            return p
          }
          anyTilesAfterTime(e = Date.now()) {
            return this._lastTilesetChange >= e
          }
          _isWithinTileRanges(e, a) {
            return a[e.canonical.z] && e.canonical.x >= a[e.canonical.z].minTileX && e.canonical.x <= a[e.canonical.z].maxTileX && e.canonical.y >= a[e.canonical.z].minTileY && e.canonical.y <= a[e.canonical.z].maxTileY
          }
        }
        class uf {
          constructor(e, a, o) {
            this._meshCache = {}, this.painter = e, this.tileManager = new cf(a), this.options = o, this.exaggeration = typeof o.exaggeration == "number" ? o.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024
          }
          getDEMElevation(e, a, o, u = s.a3) {
            var p;
            if (!(a >= 0 && a < u && o >= 0 && o < u)) return 0;
            const g = this.getTerrainData(e),
              w = (p = g.tile) === null || p === void 0 ? void 0 : p.dem;
            if (!w) return 0;
            const I = s.cv([], [a / u * s.a3, o / u * s.a3], g.u_terrain_matrix),
              A = [I[0] * w.dim, I[1] * w.dim],
              L = Math.floor(A[0]),
              O = Math.floor(A[1]),
              R = A[0] - L,
              H = A[1] - O;
            return w.get(L, O) * (1 - R) * (1 - H) + w.get(L + 1, O) * R * (1 - H) + w.get(L, O + 1) * (1 - R) * H + w.get(L + 1, O + 1) * R * H
          }
          getElevationForLngLatZoom(e, a) {
            if (!s.cw(a, e.wrap())) return 0;
            const {
              tileID: o,
              mercatorX: u,
              mercatorY: p
            } = this._getOverscaledTileIDFromLngLatZoom(e, a);
            return this.getElevation(o, u % s.a3, p % s.a3, s.a3)
          }
          getElevation(e, a, o, u = s.a3) {
            return this.getDEMElevation(e, a, o, u) * this.exaggeration
          }
          getTerrainData(e) {
            if (!this._emptyDemTexture) {
              const u = this.painter.context,
                p = new s.R({
                  width: 1,
                  height: 1
                }, new Uint8Array(4));
              this._emptyDepthTexture = new s.T(u, p, u.gl.RGBA, {
                premultiply: !1
              }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new s.T(u, new s.R({
                width: 1,
                height: 1
              }), u.gl.RGBA, {
                premultiply: !1
              }), this._emptyDemTexture.bind(u.gl.NEAREST, u.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = s.am([])
            }
            const a = this.tileManager.getSourceTile(e, !0);
            if (a && a.dem && (!a.demTexture || a.needsTerrainPrepare)) {
              const u = this.painter.context;
              a.demTexture = this.painter.getTileTexture(a.dem.stride), a.demTexture ? a.demTexture.update(a.dem.getPixels(), {
                premultiply: !1
              }) : a.demTexture = new s.T(u, a.dem.getPixels(), u.gl.RGBA, {
                premultiply: !1
              }), a.demTexture.bind(u.gl.NEAREST, u.gl.CLAMP_TO_EDGE), a.needsTerrainPrepare = !1
            }
            const o = a && a + a.tileID.key + e.key;
            if (o && !this._demMatrixCache[o]) {
              const u = this.tileManager.getSource().maxzoom;
              let p = e.canonical.z - a.tileID.canonical.z;
              e.overscaledZ > e.canonical.z && (e.canonical.z >= u ? p = e.canonical.z - u : s.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const g = e.canonical.x - (e.canonical.x >> p << p),
                w = e.canonical.y - (e.canonical.y >> p << p),
                I = s.cx(new Float64Array(16), [1 / (s.a3 << p), 1 / (s.a3 << p), 0]);
              s.N(I, I, [g * s.a3, w * s.a3, 0]), this._demMatrixCache[e.key] = {
                matrix: I,
                coord: e
              }
            }
            return {
              u_depth: 2,
              u_terrain: 3,
              u_terrain_dim: a && a.dem && a.dem.dim || 1,
              u_terrain_matrix: o ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix,
              u_terrain_unpack: a && a.dem && a.dem.getUnpackVector() || this._emptyDemUnpack,
              u_terrain_exaggeration: this.exaggeration,
              texture: (a && a.demTexture || this._emptyDemTexture).texture,
              depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture,
              tile: a
            }
          }
          getFramebuffer(e) {
            const a = this.painter,
              o = a.width / devicePixelRatio,
              u = a.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === o && this._fbo.height === u || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new s.T(a.context, {
              width: o,
              height: u,
              data: null
            }, a.context.gl.RGBA, {
              premultiply: !1
            }), this._fboCoordsTexture.bind(a.context.gl.NEAREST, a.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new s.T(a.context, {
              width: o,
              height: u,
              data: null
            }, a.context.gl.RGBA, {
              premultiply: !1
            }), this._fboDepthTexture.bind(a.context.gl.NEAREST, a.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = a.context.createFramebuffer(o, u, !0, !1), this._fbo.depthAttachment.set(a.context.createRenderbuffer(a.context.gl.DEPTH_COMPONENT16, o, u))), this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo
          }
          getCoordsTexture() {
            const e = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const a = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let p = 0, g = 0; p < this._coordsTextureSize; p++)
              for (let w = 0; w < this._coordsTextureSize; w++, g += 4) a[g + 0] = 255 & w, a[g + 1] = 255 & p, a[g + 2] = w >> 8 << 4 | p >> 8, a[g + 3] = 0;
            const o = new s.R({
                width: this._coordsTextureSize,
                height: this._coordsTextureSize
              }, new Uint8Array(a.buffer)),
              u = new s.T(e, o, e.gl.RGBA, {
                premultiply: !1
              });
            return u.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = u, u
          }
          pointCoordinate(e) {
            this.painter.maybeDrawDepthAndCoords(!0);
            const a = new Uint8Array(4),
              o = this.painter.context,
              u = o.gl,
              p = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio),
              g = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio),
              w = Math.round(this.painter.height / devicePixelRatio);
            o.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), u.readPixels(p, w - g - 1, 1, 1, u.RGBA, u.UNSIGNED_BYTE, a), o.bindFramebuffer.set(null);
            const I = a[0] + (a[2] >> 4 << 8),
              A = a[1] + ((15 & a[2]) << 8),
              L = this.coordsIndex[255 - a[3]],
              O = L && this.tileManager.getTileByID(L);
            if (!O) return null;
            const R = this._coordsTextureSize,
              H = (1 << O.tileID.canonical.z) * R;
            return new s.a5((O.tileID.canonical.x * R + I) / H + O.tileID.wrap, (O.tileID.canonical.y * R + A) / H, this.getElevation(O.tileID, I, A, R))
          }
          depthAtPoint(e) {
            const a = new Uint8Array(4),
              o = this.painter.context,
              u = o.gl;
            return o.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), u.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, u.RGBA, u.UNSIGNED_BYTE, a), o.bindFramebuffer.set(null), (a[0] / 16777216 + a[1] / 65536 + a[2] / 256 + a[3]) / 256
          }
          getTerrainMesh(e) {
            var a;
            const o = ((a = this.painter.style.projection) === null || a === void 0 ? void 0 : a.transitionState) > 0,
              u = o && e.canonical.y === 0,
              p = o && e.canonical.y === (1 << e.canonical.z) - 1,
              g = `m_${u?"n":""}_${p?"s":""}`;
            if (this._meshCache[g]) return this._meshCache[g];
            const w = this.painter.context,
              I = new s.cy,
              A = new s.aR,
              L = this.meshSize,
              O = s.a3 / L,
              R = L * L;
            for (let Le = 0; Le <= L; Le++)
              for (let $e = 0; $e <= L; $e++) I.emplaceBack($e * O, Le * O, 0);
            for (let Le = 0; Le < R; Le += L + 1)
              for (let $e = 0; $e < L; $e++) A.emplaceBack($e + Le, L + $e + Le + 1, L + $e + Le + 2), A.emplaceBack($e + Le, L + $e + Le + 2, $e + Le + 1);
            const H = I.length,
              $ = H + (L + 1),
              ce = (L + 1) * L,
              ue = u ? s.bk : 0,
              de = u ? 0 : 1,
              Ce = p ? s.bl : s.a3,
              Be = p ? 0 : 1;
            for (let Le = 0; Le <= L; Le++) I.emplaceBack(Le * O, ue, de);
            for (let Le = 0; Le <= L; Le++) I.emplaceBack(Le * O, Ce, Be);
            for (let Le = 0; Le < L; Le++) A.emplaceBack(ce + Le, $ + Le, $ + Le + 1), A.emplaceBack(ce + Le, $ + Le + 1, ce + Le + 1), A.emplaceBack(0 + Le, H + Le + 1, H + Le), A.emplaceBack(0 + Le, 0 + Le + 1, H + Le + 1);
            const Ie = I.length,
              Oe = Ie + 2 * (L + 1);
            for (const Le of [0, 1])
              for (let $e = 0; $e <= L; $e++)
                for (const vt of [0, 1]) I.emplaceBack(Le * s.a3, $e * O, vt);
            for (let Le = 0; Le < 2 * L; Le += 2) A.emplaceBack(Ie + Le, Ie + Le + 1, Ie + Le + 3), A.emplaceBack(Ie + Le, Ie + Le + 3, Ie + Le + 2), A.emplaceBack(Oe + Le, Oe + Le + 3, Oe + Le + 1), A.emplaceBack(Oe + Le, Oe + Le + 2, Oe + Le + 3);
            const He = new Xi(w.createVertexBuffer(I, kd.members), w.createIndexBuffer(A), s.aQ.simpleSegment(0, 0, I.length, A.length));
            return this._meshCache[g] = He, He
          }
          getMeshFrameDelta(e) {
            return 2 * Math.PI * s.bx / Math.pow(2, Math.max(e, 0)) / 5
          }
          getMinTileElevationForLngLatZoom(e, a) {
            var o;
            const {
              tileID: u
            } = this._getOverscaledTileIDFromLngLatZoom(e, a);
            return (o = this.getMinMaxElevation(u).minElevation) !== null && o !== void 0 ? o : 0
          }
          getMinMaxElevation(e) {
            const a = this.getTerrainData(e).tile,
              o = {
                minElevation: null,
                maxElevation: null
              };
            return a && a.dem && (o.minElevation = a.dem.min * this.exaggeration, o.maxElevation = a.dem.max * this.exaggeration), o
          }
          _getOverscaledTileIDFromLngLatZoom(e, a) {
            const o = s.a5.fromLngLat(e.wrap()),
              u = (1 << a) * s.a3,
              p = o.x * u,
              g = o.y * u,
              w = Math.floor(p / s.a3),
              I = Math.floor(g / s.a3);
            return {
              tileID: new s.a0(a, 0, a, w, I),
              mercatorX: p,
              mercatorY: g
            }
          }
        }
        class hf {
          constructor(e, a, o) {
            this._context = e, this._size = a, this._tileSize = o, this._objects = [], this._recentlyUsed = [], this._stamp = 0
          }
          destruct() {
            for (const e of this._objects) e.texture.destroy(), e.fbo.destroy()
          }
          _createObject(e) {
            const a = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0),
              o = new s.T(this._context, {
                width: this._tileSize,
                height: this._tileSize,
                data: null
              }, this._context.gl.RGBA);
            return o.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), a.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), a.colorAttachment.set(o.texture), {
              id: e,
              fbo: a,
              texture: o,
              stamp: -1,
              inUse: !1
            }
          }
          getObjectForId(e) {
            return this._objects[e]
          }
          useObject(e) {
            e.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter((a => e.id !== a)), this._recentlyUsed.push(e.id)
          }
          stampObject(e) {
            e.stamp = ++this._stamp
          }
          getOrCreateFreeObject() {
            for (const a of this._recentlyUsed)
              if (!this._objects[a].inUse) return this._objects[a];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const e = this._createObject(this._objects.length);
            return this._objects.push(e), e
          }
          freeObject(e) {
            e.inUse = !1
          }
          freeAllObjects() {
            for (const e of this._objects) this.freeObject(e)
          }
          isFull() {
            return !(this._objects.length < this._size) && this._objects.some((e => !e.inUse)) === !1
          }
        }
        const is = {
          background: !0,
          fill: !0,
          line: !0,
          raster: !0,
          hillshade: !0,
          "color-relief": !0
        };
        class _a {
          constructor(e, a) {
            this.painter = e, this.terrain = a, this.pool = new hf(e.context, 30, a.tileManager.tileSize * a.qualityFactor)
          }
          destruct() {
            this.pool.destruct()
          }
          getTexture(e) {
            return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture
          }
          prepareForRender(e, a) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.tileManager.getRenderableTiles(), this._renderableLayerIds = e._order.filter((o => !e._layers[o].isHidden(a))), this._coordsAscending = {};
            for (const o in e.tileManagers) {
              this._coordsAscending[o] = {};
              const u = e.tileManagers[o].getVisibleCoordinates(),
                p = e.tileManagers[o].getSource(),
                g = p instanceof sr ? p.terrainTileRanges : null;
              for (const w of u) {
                const I = this.terrain.tileManager.getTerrainCoords(w, g);
                for (const A in I) this._coordsAscending[o][A] || (this._coordsAscending[o][A] = []), this._coordsAscending[o][A].push(I[A])
              }
            }
            this._coordsAscendingStr = {};
            for (const o of e._order) {
              const u = e._layers[o],
                p = u.source;
              if (is[u.type] && !this._coordsAscendingStr[p]) {
                this._coordsAscendingStr[p] = {};
                for (const g in this._coordsAscending[p]) this._coordsAscendingStr[p][g] = this._coordsAscending[p][g].map((w => w.key)).sort().join()
              }
            }
            for (const o of this._renderableTiles)
              for (const u in this._coordsAscendingStr) {
                const p = this._coordsAscendingStr[u][o.tileID.key];
                p && p !== o.rttCoords[u] && (o.rtt = [])
              }
          }
          renderLayer(e, a) {
            if (e.isHidden(this.painter.transform.zoom)) return !1;
            const o = Object.assign(Object.assign({}, a), {
                isRenderingToTexture: !0
              }),
              u = e.type,
              p = this.painter,
              g = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
            if (is[u] && (this._prevType && is[this._prevType] || this._stacks.push([]), this._prevType = u, this._stacks[this._stacks.length - 1].push(e.id), !g)) return !0;
            if (is[this._prevType] || is[u] && g) {
              this._prevType = u;
              const w = this._stacks.length - 1,
                I = this._stacks[w] || [];
              for (const A of this._renderableTiles) {
                if (this.pool.isFull() && (uu(this.painter, this.terrain, this._rttTiles, o), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(A), A.rtt[w]) {
                  const O = this.pool.getObjectForId(A.rtt[w].id);
                  if (O.stamp === A.rtt[w].stamp) {
                    this.pool.useObject(O);
                    continue
                  }
                }
                const L = this.pool.getOrCreateFreeObject();
                this.pool.useObject(L), this.pool.stampObject(L), A.rtt[w] = {
                  id: L.id,
                  stamp: L.stamp
                }, p.context.bindFramebuffer.set(L.fbo.framebuffer), p.context.clear({
                  color: s.bi.transparent,
                  stencil: 0
                }), p.currentStencilSource = void 0;
                for (let O = 0; O < I.length; O++) {
                  const R = p.style._layers[I[O]],
                    H = R.source ? this._coordsAscending[R.source][A.tileID.key] : [A.tileID];
                  p.context.viewport.set([0, 0, L.fbo.width, L.fbo.height]), p._renderTileClippingMasks(R, H, !0), p.renderLayer(p, p.style.tileManagers[R.source], R, H, o), R.source && (A.rttCoords[R.source] = this._coordsAscendingStr[R.source][A.tileID.key])
                }
              }
              return uu(this.painter, this.terrain, this._rttTiles, o), this._rttTiles = [], this.pool.freeAllObjects(), is[u]
            }
            return !1
          }
        }
        const wa = {
            "AttributionControl.ToggleAttribution": "Toggle attribution",
            "AttributionControl.MapFeedback": "Map feedback",
            "FullscreenControl.Enter": "Enter fullscreen",
            "FullscreenControl.Exit": "Exit fullscreen",
            "GeolocateControl.FindMyLocation": "Find my location",
            "GeolocateControl.LocationNotAvailable": "Location not available",
            "LogoControl.Title": "MapLibre logo",
            "Map.Title": "Map",
            "Marker.Title": "Map marker",
            "NavigationControl.ResetBearing": "Reset bearing to north",
            "NavigationControl.ZoomIn": "Zoom in",
            "NavigationControl.ZoomOut": "Zoom out",
            "Popup.Close": "Close popup",
            "ScaleControl.Feet": "ft",
            "ScaleControl.Meters": "m",
            "ScaleControl.Kilometers": "km",
            "ScaleControl.Miles": "mi",
            "ScaleControl.NauticalMiles": "nm",
            "GlobeControl.Enable": "Enable globe",
            "GlobeControl.Disable": "Disable globe",
            "TerrainControl.Enable": "Enable terrain",
            "TerrainControl.Disable": "Disable terrain",
            "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map",
            "CooperativeGesturesHandler.MacHelpText": "Use  + scroll to zoom the map",
            "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map"
          },
          zd = F,
          Ao = {
            hash: !1,
            interactive: !0,
            bearingSnap: 7,
            attributionControl: sl,
            maplibreLogo: !1,
            refreshExpiredTiles: !0,
            canvasContextAttributes: {
              antialias: !1,
              preserveDrawingBuffer: !1,
              powerPreference: "high-performance",
              failIfMajorPerformanceCaveat: !1,
              desynchronized: !1,
              contextType: void 0
            },
            scrollZoom: !0,
            minZoom: -2,
            maxZoom: 22,
            minPitch: 0,
            maxPitch: 60,
            boxZoom: !0,
            dragRotate: !0,
            dragPan: !0,
            keyboard: !0,
            doubleClickZoom: !0,
            touchZoomRotate: !0,
            touchPitch: !0,
            cooperativeGestures: !1,
            trackResize: !0,
            center: [0, 0],
            elevation: 0,
            zoom: 0,
            bearing: 0,
            pitch: 0,
            roll: 0,
            renderWorldCopies: !0,
            maxTileCacheSize: null,
            maxTileCacheZoomLevels: s.a.MAX_TILE_CACHE_ZOOM_LEVELS,
            transformRequest: null,
            transformCameraUpdate: null,
            transformConstrain: null,
            fadeDuration: 300,
            crossSourceCollisions: !0,
            clickTolerance: 3,
            localIdeographFontFamily: "sans-serif",
            pitchWithRotate: !0,
            rollEnabled: !1,
            validateStyle: !0,
            maxCanvasSize: [4096, 4096],
            cancelPendingTileRequestsWhileZooming: !0,
            centerClampedToGround: !0
          },
          Jl = {
            showCompass: !0,
            showZoom: !0,
            visualizePitch: !1,
            visualizeRoll: !0
          };
        class Tu {
          constructor(e, a, o = !1) {
            this.mousedown = p => {
              this.startMove(p, q.mousePos(this.element, p)), q.addEventListener(window, "mousemove", this.mousemove), q.addEventListener(window, "mouseup", this.mouseup)
            }, this.mousemove = p => {
              this.move(p, q.mousePos(this.element, p))
            }, this.mouseup = p => {
              this._rotatePitchHandler.dragEnd(p), this.offTemp()
            }, this.touchstart = p => {
              p.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = q.touchPos(this.element, p.targetTouches)[0], this.startMove(p, this._startPos), q.addEventListener(window, "touchmove", this.touchmove, {
                passive: !1
              }), q.addEventListener(window, "touchend", this.touchend))
            }, this.touchmove = p => {
              p.targetTouches.length !== 1 ? this.reset() : (this._lastPos = q.touchPos(this.element, p.targetTouches)[0], this.move(p, this._lastPos))
            }, this.touchend = p => {
              p.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp()
            }, this.reset = () => {
              this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp()
            }, this._clickTolerance = 10, this.element = a;
            const u = new mu;
            this._rotatePitchHandler = new zr({
              clickTolerance: 3,
              move: (p, g) => {
                const w = a.getBoundingClientRect(),
                  I = new s.P((w.bottom - w.top) / 2, (w.right - w.left) / 2);
                return {
                  bearingDelta: s.cq(new s.P(p.x, g.y), g, I),
                  pitchDelta: o ? -.5 * (g.y - p.y) : void 0
                }
              },
              moveStateManager: u,
              enable: !0,
              assignEvents: () => {}
            }), this.map = e, q.addEventListener(a, "mousedown", this.mousedown), q.addEventListener(a, "touchstart", this.touchstart, {
              passive: !1
            }), q.addEventListener(a, "touchcancel", this.reset)
          }
          startMove(e, a) {
            this._rotatePitchHandler.dragStart(e, a), q.disableDrag()
          }
          move(e, a) {
            const o = this.map,
              {
                bearingDelta: u,
                pitchDelta: p
              } = this._rotatePitchHandler.dragMove(e, a) || {};
            u && o.setBearing(o.getBearing() + u), p && o.setPitch(o.getPitch() + p)
          }
          off() {
            const e = this.element;
            q.removeEventListener(e, "mousedown", this.mousedown), q.removeEventListener(e, "touchstart", this.touchstart, {
              passive: !1
            }), q.removeEventListener(window, "touchmove", this.touchmove, {
              passive: !1
            }), q.removeEventListener(window, "touchend", this.touchend), q.removeEventListener(e, "touchcancel", this.reset), this.offTemp()
          }
          offTemp() {
            q.enableDrag(), q.removeEventListener(window, "mousemove", this.mousemove), q.removeEventListener(window, "mouseup", this.mouseup), q.removeEventListener(window, "touchmove", this.touchmove, {
              passive: !1
            }), q.removeEventListener(window, "touchend", this.touchend)
          }
        }
        let fs;

        function $l(d, e, a, o = !1) {
          if (o || !a.getCoveringTilesDetailsProvider().allowWorldCopies()) return d == null ? void 0 : d.wrap();
          const u = new s.U(d.lng, d.lat);
          if (d = new s.U(d.lng, d.lat), e) {
            const p = new s.U(d.lng - 360, d.lat),
              g = new s.U(d.lng + 360, d.lat),
              w = a.locationToScreenPoint(d).distSqr(e);
            a.locationToScreenPoint(p).distSqr(e) < w ? d = p : a.locationToScreenPoint(g).distSqr(e) < w && (d = g)
          }
          for (; Math.abs(d.lng - a.center.lng) > 180;) {
            const p = a.locationToScreenPoint(d);
            if (p.x >= 0 && p.y >= 0 && p.x <= a.width && p.y <= a.height) break;
            d.lng > a.center.lng ? d.lng -= 360 : d.lng += 360
          }
          return d.lng !== u.lng && a.isPointOnMapSurface(a.locationToScreenPoint(d)) ? d : u
        }
        const Ys = {
          center: "translate(-50%,-50%)",
          top: "translate(-50%,0)",
          "top-left": "translate(0,0)",
          "top-right": "translate(-100%,0)",
          bottom: "translate(-50%,-100%)",
          "bottom-left": "translate(0,-100%)",
          "bottom-right": "translate(-100%,-100%)",
          left: "translate(0,-50%)",
          right: "translate(-100%,-50%)"
        };

        function Ql(d, e, a) {
          const o = d.classList;
          for (const u in Ys) o.remove(`maplibregl-${a}-anchor-${u}`);
          o.add(`maplibregl-${a}-anchor-${e}`)
        }
        class ol extends s.E {
          constructor(e) {
            if (super(), this._onKeyPress = a => {
                const o = a.code,
                  u = a.charCode || a.keyCode;
                o !== "Space" && o !== "Enter" && u !== 32 && u !== 13 || this.togglePopup()
              }, this._onMapClick = a => {
                const o = a.originalEvent.target,
                  u = this._element;
                this._popup && (o === u || u.contains(o)) && this.togglePopup()
              }, this._update = a => {
                if (!this._map) return;
                const o = this._map.loaded() && !this._map.isMoving();
                ((a == null ? void 0 : a.type) === "terrain" || (a == null ? void 0 : a.type) === "render" && !o) && this._map.once("render", this._update), this._lngLat = $l(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
                let u = "";
                this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? u = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (u = `rotateZ(${this._rotation-this._map.getBearing()}deg)`);
                let p = "";
                this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? p = "rotateX(0deg)" : this._pitchAlignment === "map" && (p = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || a && a.type !== "moveend" || (this._pos = this._pos.round()), q.setTransform(this._element, `${Ys[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${p} ${u}`), re.frameAsync(new AbortController).then((() => {
                  this._updateOpacity(a && a.type === "moveend")
                })).catch((() => {}))
              }, this._onMove = a => {
                if (!this._isDragging) {
                  const o = this._clickTolerance || this._map._clickTolerance;
                  this._isDragging = a.point.dist(this._pointerdownPos) >= o
                }
                this._isDragging && (this._pos = a.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new s.l("dragstart"))), this.fire(new s.l("drag")))
              }, this._onUp = () => {
                this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new s.l("dragend")), this._state = "inactive"
              }, this._addDragHandler = a => {
                this._element.contains(a.originalEvent.target) && (a.preventDefault(), this._positionDelta = a.point.sub(this._pos).add(this._offset), this._pointerdownPos = a.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp))
              }, this._anchor = e && e.anchor || "center", this._color = e && e.color || "#3FB1CE", this._scale = e && e.scale || 1, this._draggable = e && e.draggable || !1, this._clickTolerance = e && e.clickTolerance || 0, this._subpixelPositioning = e && e.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = e && e.rotation || 0, this._rotationAlignment = e && e.rotationAlignment || "auto", this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment !== "auto" ? e.pitchAlignment : this._rotationAlignment, this.setOpacity(e == null ? void 0 : e.opacity, e == null ? void 0 : e.opacityWhenCovered), e && e.element) this._element = e.element, this._offset = s.P.convert(e && e.offset || [0, 0]);
            else {
              this._defaultMarker = !0, this._element = q.create("div");
              const a = q.createNS("http://www.w3.org/2000/svg", "svg"),
                o = 41,
                u = 27;
              a.setAttributeNS(null, "display", "block"), a.setAttributeNS(null, "height", `${o}px`), a.setAttributeNS(null, "width", `${u}px`), a.setAttributeNS(null, "viewBox", `0 0 ${u} ${o}`);
              const p = q.createNS("http://www.w3.org/2000/svg", "g");
              p.setAttributeNS(null, "stroke", "none"), p.setAttributeNS(null, "stroke-width", "1"), p.setAttributeNS(null, "fill", "none"), p.setAttributeNS(null, "fill-rule", "evenodd");
              const g = q.createNS("http://www.w3.org/2000/svg", "g");
              g.setAttributeNS(null, "fill-rule", "nonzero");
              const w = q.createNS("http://www.w3.org/2000/svg", "g");
              w.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), w.setAttributeNS(null, "fill", "#000000");
              const I = [{
                rx: "10.5",
                ry: "5.25002273"
              }, {
                rx: "10.5",
                ry: "5.25002273"
              }, {
                rx: "9.5",
                ry: "4.77275007"
              }, {
                rx: "8.5",
                ry: "4.29549936"
              }, {
                rx: "7.5",
                ry: "3.81822308"
              }, {
                rx: "6.5",
                ry: "3.34094679"
              }, {
                rx: "5.5",
                ry: "2.86367051"
              }, {
                rx: "4.5",
                ry: "2.38636864"
              }];
              for (const de of I) {
                const Ce = q.createNS("http://www.w3.org/2000/svg", "ellipse");
                Ce.setAttributeNS(null, "opacity", "0.04"), Ce.setAttributeNS(null, "cx", "10.5"), Ce.setAttributeNS(null, "cy", "5.80029008"), Ce.setAttributeNS(null, "rx", de.rx), Ce.setAttributeNS(null, "ry", de.ry), w.appendChild(Ce)
              }
              const A = q.createNS("http://www.w3.org/2000/svg", "g");
              A.setAttributeNS(null, "fill", this._color);
              const L = q.createNS("http://www.w3.org/2000/svg", "path");
              L.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), A.appendChild(L);
              const O = q.createNS("http://www.w3.org/2000/svg", "g");
              O.setAttributeNS(null, "opacity", "0.25"), O.setAttributeNS(null, "fill", "#000000");
              const R = q.createNS("http://www.w3.org/2000/svg", "path");
              R.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), O.appendChild(R);
              const H = q.createNS("http://www.w3.org/2000/svg", "g");
              H.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), H.setAttributeNS(null, "fill", "#FFFFFF");
              const $ = q.createNS("http://www.w3.org/2000/svg", "g");
              $.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const ce = q.createNS("http://www.w3.org/2000/svg", "circle");
              ce.setAttributeNS(null, "fill", "#000000"), ce.setAttributeNS(null, "opacity", "0.25"), ce.setAttributeNS(null, "cx", "5.5"), ce.setAttributeNS(null, "cy", "5.5"), ce.setAttributeNS(null, "r", "5.4999962");
              const ue = q.createNS("http://www.w3.org/2000/svg", "circle");
              ue.setAttributeNS(null, "fill", "#FFFFFF"), ue.setAttributeNS(null, "cx", "5.5"), ue.setAttributeNS(null, "cy", "5.5"), ue.setAttributeNS(null, "r", "5.4999962"), $.appendChild(ce), $.appendChild(ue), g.appendChild(w), g.appendChild(A), g.appendChild(O), g.appendChild(H), g.appendChild($), a.appendChild(g), a.setAttributeNS(null, "height", o * this._scale + "px"), a.setAttributeNS(null, "width", u * this._scale + "px"), this._element.appendChild(a), this._offset = s.P.convert(e && e.offset || [0, -14])
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (a => {
                a.preventDefault()
              })), this._element.addEventListener("mousedown", (a => {
                a.preventDefault()
              })), Ql(this._element, this._anchor, "marker"), e && e.className)
              for (const a of e.className.split(" ")) this._element.classList.add(a);
            this._popup = null
          }
          addTo(e) {
            return this.remove(), this._map = e, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e._getUIString("Marker.Title")), this._element.hasAttribute("role") || this._element.setAttribute("role", "button"), e.getCanvasContainer().appendChild(this._element), e.on("move", this._update), e.on("moveend", this._update), e.on("terrain", this._update), e.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), q.remove(this._element), this._popup && this._popup.remove(), this
          }
          getLngLat() {
            return this._lngLat
          }
          setLngLat(e) {
            return this._lngLat = s.U.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this
          }
          getElement() {
            return this._element
          }
          setPopup(e) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
              if (!("offset" in e.options)) {
                const u = Math.abs(13.5) / Math.SQRT2;
                e.options.offset = this._defaultMarker ? {
                  top: [0, 0],
                  "top-left": [0, 0],
                  "top-right": [0, 0],
                  bottom: [0, -38.1],
                  "bottom-left": [u, -1 * (38.1 - 13.5 + u)],
                  "bottom-right": [-u, -1 * (38.1 - 13.5 + u)],
                  left: [13.5, -1 * (38.1 - 13.5)],
                  right: [-13.5, -1 * (38.1 - 13.5)]
                } : this._offset
              }
              this._popup = e, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress)
            }
            return this
          }
          setSubpixelPositioning(e) {
            return this._subpixelPositioning = e, this
          }
          getPopup() {
            return this._popup
          }
          togglePopup() {
            const e = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : e ? (e.isOpen() ? e.remove() : (e.setLngLat(this._lngLat), e.addTo(this._map)), this) : this
          }
          _updateOpacity(e = !1) {
            var a, o;
            const u = (a = this._map) === null || a === void 0 ? void 0 : a.terrain,
              p = this._map.transform.isLocationOccluded(this._lngLat);
            if (!u || p) {
              const H = p ? this._opacityWhenCovered : this._opacity;
              return void(this._element.style.opacity !== H && (this._element.style.opacity = H))
            }
            if (e) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout((() => {
                this._opacityTimeout = null
              }), 100)
            }
            const g = this._map,
              w = g.terrain.depthAtPoint(this._pos),
              I = g.terrain.getElevationForLngLatZoom(this._lngLat, g.transform.tileZoom);
            if (g.transform.lngLatToCameraDepth(this._lngLat, I) - w < .006) return void(this._element.style.opacity = this._opacity);
            const A = -this._offset.y / g.transform.pixelsPerMeter,
              L = Math.sin(g.getPitch() * Math.PI / 180) * A,
              O = g.terrain.depthAtPoint(new s.P(this._pos.x, this._pos.y - this._offset.y)),
              R = g.transform.lngLatToCameraDepth(this._lngLat, I + L) - O > .006;
            !((o = this._popup) === null || o === void 0) && o.isOpen() && R && this._popup.remove(), this._element.style.opacity = R ? this._opacityWhenCovered : this._opacity
          }
          getOffset() {
            return this._offset
          }
          setOffset(e) {
            return this._offset = s.P.convert(e), this._update(), this
          }
          addClassName(e) {
            this._element.classList.add(e)
          }
          removeClassName(e) {
            this._element.classList.remove(e)
          }
          toggleClassName(e) {
            return this._element.classList.toggle(e)
          }
          setDraggable(e) {
            return this._draggable = !!e, this._map && (e ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this
          }
          isDraggable() {
            return this._draggable
          }
          setRotation(e) {
            return this._rotation = e || 0, this._update(), this
          }
          getRotation() {
            return this._rotation
          }
          setRotationAlignment(e) {
            return this._rotationAlignment = e || "auto", this._update(), this
          }
          getRotationAlignment() {
            return this._rotationAlignment
          }
          setPitchAlignment(e) {
            return this._pitchAlignment = e && e !== "auto" ? e : this._rotationAlignment, this._update(), this
          }
          getPitchAlignment() {
            return this._pitchAlignment
          }
          setOpacity(e, a) {
            return (this._opacity === void 0 || e === void 0 && a === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), e !== void 0 && (this._opacity = e), a !== void 0 && (this._opacityWhenCovered = a), this._map && this._updateOpacity(!0), this
          }
        }
        const Su = {
          positionOptions: {
            enableHighAccuracy: !1,
            maximumAge: 0,
            timeout: 6e3
          },
          fitBoundsOptions: {
            maxZoom: 15
          },
          trackUserLocation: !1,
          showAccuracyCircle: !0,
          showUserLocation: !0
        };
        let ko = 0,
          Ks = !1;
        const Pu = {
          maxWidth: 100,
          unit: "metric"
        };

        function ec(d, e, a) {
          const o = a && a.maxWidth || 100,
            u = d._container.clientHeight / 2,
            p = d._container.clientWidth / 2,
            g = d.unproject([p - o / 2, u]),
            w = d.unproject([p + o / 2, u]),
            I = Math.round(d.project(w).x - d.project(g).x),
            A = Math.min(o, I, d._container.clientWidth),
            L = g.distanceTo(w);
          if (a && a.unit === "imperial") {
            const O = 3.2808 * L;
            O > 5280 ? Js(e, A, O / 5280, d._getUIString("ScaleControl.Miles")) : Js(e, A, O, d._getUIString("ScaleControl.Feet"))
          } else a && a.unit === "nautical" ? Js(e, A, L / 1852, d._getUIString("ScaleControl.NauticalMiles")) : L >= 1e3 ? Js(e, A, L / 1e3, d._getUIString("ScaleControl.Kilometers")) : Js(e, A, L, d._getUIString("ScaleControl.Meters"))
        }

        function Js(d, e, a, o) {
          const u = (function(p) {
            const g = Math.pow(10, `${Math.floor(p)}`.length - 1);
            let w = p / g;
            return w = w >= 10 ? 10 : w >= 5 ? 5 : w >= 3 ? 3 : w >= 2 ? 2 : w >= 1 ? 1 : (function(I) {
              const A = Math.pow(10, Math.ceil(-Math.log(I) / Math.LN10));
              return Math.round(I * A) / A
            })(w), g * w
          })(a);
          d.style.width = e * (u / a) + "px", d.innerHTML = `${u}&nbsp;${o}`
        }
        const Iu = {
            closeButton: !0,
            closeOnClick: !0,
            focusAfterOpen: !0,
            className: "",
            maxWidth: "240px",
            subpixelPositioning: !1,
            locationOccludedOpacity: void 0
          },
          tc = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");

        function rc(d) {
          if (d) {
            if (typeof d == "number") {
              const e = Math.round(Math.abs(d) / Math.SQRT2);
              return {
                center: new s.P(0, 0),
                top: new s.P(0, d),
                "top-left": new s.P(e, e),
                "top-right": new s.P(-e, e),
                bottom: new s.P(0, -d),
                "bottom-left": new s.P(e, -e),
                "bottom-right": new s.P(-e, -e),
                left: new s.P(d, 0),
                right: new s.P(-d, 0)
              }
            }
            if (d instanceof s.P || Array.isArray(d)) {
              const e = s.P.convert(d);
              return {
                center: e,
                top: e,
                "top-left": e,
                "top-right": e,
                bottom: e,
                "bottom-left": e,
                "bottom-right": e,
                left: e,
                right: e
              }
            }
            return {
              center: s.P.convert(d.center || [0, 0]),
              top: s.P.convert(d.top || [0, 0]),
              "top-left": s.P.convert(d["top-left"] || [0, 0]),
              "top-right": s.P.convert(d["top-right"] || [0, 0]),
              bottom: s.P.convert(d.bottom || [0, 0]),
              "bottom-left": s.P.convert(d["bottom-left"] || [0, 0]),
              "bottom-right": s.P.convert(d["bottom-right"] || [0, 0]),
              left: s.P.convert(d.left || [0, 0]),
              right: s.P.convert(d.right || [0, 0])
            }
          }
          return rc(new s.P(0, 0))
        }
        const Mu = F;
        T.AJAXError = s.cC, T.Event = s.l, T.Evented = s.E, T.LngLat = s.U, T.MercatorCoordinate = s.a5, T.Point = s.P, T.addProtocol = s.cD, T.config = s.a, T.removeProtocol = s.cE, T.AttributionControl = an, T.BoxZoomHandler = _d, T.CanvasSource = vr, T.CooperativeGesturesHandler = Un, T.DoubleClickZoomHandler = al, T.DragPanHandler = xu, T.DragRotateHandler = bu, T.EdgeInsets = yi, T.FullscreenControl = class extends s.E {
          constructor(d = {}) {
            super(), this._onFullscreenChange = () => {
              var e;
              let a = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; !((e = a == null ? void 0 : a.shadowRoot) === null || e === void 0) && e.fullscreenElement;) a = a.shadowRoot.fullscreenElement;
              a === this._container !== this._fullscreen && this._handleFullscreenChange()
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen()
            }, this._fullscreen = !1, d && d.container && (d.container instanceof HTMLElement ? this._container = d.container : s.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange")
          }
          onAdd(d) {
            return this._map = d, this._container || (this._container = this._map.getContainer()), this._controlContainer = q.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer
          }
          onRemove() {
            q.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange)
          }
          _setupUI() {
            const d = this._fullscreenButton = q.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            q.create("span", "maplibregl-ctrl-icon", d).setAttribute("aria-hidden", "true"), d.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange)
          }
          _updateTitle() {
            const d = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", d), this._fullscreenButton.title = d
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter")
          }
          _isFullscreen() {
            return this._fullscreen
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new s.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new s.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable())
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen()
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen()
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize()
          }
        }, T.GeoJSONSource = Yt, T.GeolocateControl = class extends s.E {
          constructor(d) {
            super(), this._onSuccess = e => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new s.l("outofmaxbounds", e)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`)
                }
                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new s.l("geolocate", e)), this._finish()
              }
            }, this._updateCamera = e => {
              const a = new s.U(e.coords.longitude, e.coords.latitude),
                o = e.coords.accuracy,
                u = this._map.getBearing(),
                p = s.e({
                  bearing: u
                }, this.options.fitBoundsOptions),
                g = Ut.fromLngLat(a, o);
              this._map.fitBounds(g, p, {
                geolocateSource: !0
              })
            }, this._updateMarker = e => {
              if (e) {
                const a = new s.U(e.coords.longitude, e.coords.latitude);
                this._accuracyCircleMarker.setLngLat(a).addTo(this._map), this._userLocationDotMarker.setLngLat(a).addTo(this._map), this._accuracy = e.coords.accuracy, this._updateCircleRadiusIfNeeded()
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove()
            }, this._onUpdate = () => {
              this._updateCircleRadiusIfNeeded()
            }, this._onError = e => {
              if (this._map) {
                if (e.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                  const a = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a), this._geolocationWatchID !== void 0 && this._clearWatch()
                } else {
                  if (e.code === 3 && Ks) return;
                  this._setErrorState()
                }
                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new s.l("error", e)), this._finish()
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0
            }, this._setupUI = () => {
              this._map && (this._container.addEventListener("contextmenu", (e => e.preventDefault())), this._geolocateButton = q.create("button", "maplibregl-ctrl-geolocate", this._container), q.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0)
            }, this._finishSetupUI = e => {
              if (this._map) {
                if (e === !1) {
                  s.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const a = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = !0, this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a)
                } else {
                  const a = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.disabled = !1, this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a)
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = q.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new ol({
                  element: this._dotElement
                }), this._circleElement = q.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new ol({
                  element: this._circleElement,
                  pitchAlignment: "map"
                }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onUpdate), this._map.on("move", this._onUpdate), this._map.on("rotate", this._onUpdate), this._map.on("pitch", this._onUpdate)), this._geolocateButton.addEventListener("click", (() => this.trigger())), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (a => {
                  const o = (a == null ? void 0 : a[0]) instanceof ResizeObserverEntry;
                  a.geolocateSource || this._watchState !== "ACTIVE_LOCK" || o || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new s.l("trackuserlocationend")), this.fire(new s.l("userlocationlostfocus")))
                }))
              }
            }, this.options = s.e({}, Su, d)
          }
          onAdd(d) {
            return this._map = d, this._container = q.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), (function() {
              return s._(this, arguments, void 0, (function*(e = !1) {
                if (fs !== void 0 && !e) return fs;
                if (window.navigator.permissions === void 0) return fs = !!window.navigator.geolocation, fs;
                try {
                  fs = (yield window.navigator.permissions.query({
                    name: "geolocation"
                  })).state !== "denied"
                } catch {
                  fs = !!window.navigator.geolocation
                }
                return fs
              }))
            })().then((e => this._finishSetupUI(e))), this._container
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), q.remove(this._container), this._map.off("zoom", this._onUpdate), this._map.off("move", this._onUpdate), this._map.off("rotate", this._onUpdate), this._map.off("pitch", this._onUpdate), this._map = void 0, ko = 0, Ks = !1
          }
          _isOutOfMapMaxBounds(d) {
            const e = this._map.getMaxBounds(),
              a = d.coords;
            return e && (a.longitude < e.getWest() || a.longitude > e.getEast() || a.latitude < e.getSouth() || a.latitude > e.getNorth())
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
              case "OFF":
              case void 0:
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`)
            }
          }
          _updateCircleRadiusIfNeeded() {
            const d = this._userLocationDotMarker.getLngLat();
            if (!(this.options.showUserLocation && this.options.showAccuracyCircle && this._accuracy && d)) return;
            const e = this._map.project(d),
              a = this._map.unproject([e.x + 100, e.y]),
              o = d.distanceTo(a) / 100,
              u = 2 * this._accuracy / o;
            this._circleElement.style.width = `${u.toFixed(2)}px`, this._circleElement.style.height = `${u.toFixed(2)}px`
          }
          trigger() {
            if (!this._setup) return s.w("Geolocate control triggered before added to a map"), !1;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new s.l("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  ko--, Ks = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new s.l("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new s.l("trackuserlocationstart")), this.fire(new s.l("userlocationfocus"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`)
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`)
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let d;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), ko++, ko > 1 ? (d = {
                  maximumAge: 6e5,
                  timeout: 0
                }, Ks = !0) : (d = this.options.positionOptions, Ks = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, d)
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return !0
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null)
          }
        }, T.GlobeControl = class {
          constructor() {
            this._toggleProjection = () => {
              var d;
              const e = (d = this._map.getProjection()) === null || d === void 0 ? void 0 : d.type;
              this._map.setProjection(e !== "mercator" && e ? {
                type: "mercator"
              } : {
                type: "globe"
              }), this._updateGlobeIcon()
            }, this._updateGlobeIcon = () => {
              var d;
              this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((d = this._map.getProjection()) === null || d === void 0 ? void 0 : d.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"))
            }
          }
          onAdd(d) {
            return this._map = d, this._container = q.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = q.create("button", "maplibregl-ctrl-globe", this._container), q.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container
          }
          onRemove() {
            q.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0
          }
        }, T.Hash = du, T.ImageSource = sr, T.KeyboardHandler = Pd, T.LngLatBounds = Ut, T.LogoControl = wu, T.Map = class extends Ad {
          constructor(d) {
            var e, a;
            s.cz.mark(s.cA.create);
            const o = Object.assign(Object.assign(Object.assign({}, Ao), d), {
              canvasContextAttributes: Object.assign(Object.assign({}, Ao.canvasContextAttributes), d.canvasContextAttributes)
            });
            if (o.minZoom != null && o.maxZoom != null && o.minZoom > o.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (o.minPitch != null && o.maxPitch != null && o.minPitch > o.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (o.minPitch != null && o.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (o.maxPitch != null && o.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
            const u = new Pa,
              p = new Na;
            if (o.minZoom !== void 0 && u.setMinZoom(o.minZoom), o.maxZoom !== void 0 && u.setMaxZoom(o.maxZoom), o.minPitch !== void 0 && u.setMinPitch(o.minPitch), o.maxPitch !== void 0 && u.setMaxPitch(o.maxPitch), o.renderWorldCopies !== void 0 && u.setRenderWorldCopies(o.renderWorldCopies), o.transformConstrain !== null && u.setConstrain(o.transformConstrain), super(u, p, {
                bearingSnap: o.bearingSnap
              }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new Zn, this._controls = [], this._mapId = s.ab(), this._contextLost = w => {
                w.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new s.l("webglcontextlost", {
                  originalEvent: w
                }))
              }, this._contextRestored = w => {
                this._setupPainter(), this.resize(), this._update(), this.fire(new s.l("webglcontextrestored", {
                  originalEvent: w
                }))
              }, this._onMapScroll = w => {
                if (w.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1
              }, this._onWindowOnline = () => {
                this._update()
              }, this._interactive = o.interactive, this._maxTileCacheSize = o.maxTileCacheSize, this._maxTileCacheZoomLevels = o.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, o.canvasContextAttributes), this._trackResize = o.trackResize === !0, this._bearingSnap = o.bearingSnap, this._centerClampedToGround = o.centerClampedToGround, this._refreshExpiredTiles = o.refreshExpiredTiles === !0, this._fadeDuration = o.fadeDuration, this._crossSourceCollisions = o.crossSourceCollisions === !0, this._collectResourceTiming = o.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, wa), o.locale), this._clickTolerance = o.clickTolerance, this._overridePixelRatio = o.pixelRatio, this._maxCanvasSize = o.maxCanvasSize, this.transformCameraUpdate = o.transformCameraUpdate, this.transformConstrain = o.transformConstrain, this.cancelPendingTileRequestsWhileZooming = o.cancelPendingTileRequestsWhileZooming === !0, this._imageQueueHandle = ze.addThrottleControl((() => this.isMoving())), this._requestManager = new Se(o.transformRequest), typeof o.container == "string") {
              if (this._container = document.getElementById(o.container), !this._container) throw new Error(`Container '${o.container}' not found.`)
            } else {
              if (!(o.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = o.container
            }
            if (o.maxBounds && this.setMaxBounds(o.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", (() => this._update(!1))), this.on("moveend", (() => this._update(!1))), this.on("zoom", (() => this._update(!0))), this.on("terrain", (() => {
                this.painter.terrainFacilitator.dirty = !0, this._update(!0)
              })), this.once("idle", (() => {
                this._idleTriggered = !0
              })), typeof window < "u") {
              addEventListener("online", this._onWindowOnline, !1);
              let w = !1;
              const I = hu((A => {
                this._trackResize && !this._removed && (this.resize(A), this.redraw())
              }), 50);
              this._resizeObserver = new ResizeObserver((A => {
                w ? I(A) : w = !0
              })), this._resizeObserver.observe(this._container)
            }
            this.handlers = new nl(this, o), this._hash = o.hash && new du(typeof o.hash == "string" && o.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({
              center: o.center,
              elevation: o.elevation,
              zoom: o.zoom,
              bearing: o.bearing,
              pitch: o.pitch,
              roll: o.roll
            }), o.bounds && (this.resize(), this.fitBounds(o.bounds, s.e({}, o.fitBoundsOptions, {
              duration: 0
            }))));
            const g = typeof o.style == "string" || ((a = (e = o.style) === null || e === void 0 ? void 0 : e.projection) === null || a === void 0 ? void 0 : a.type) !== "globe";
            this.resize(null, g), this._localIdeographFontFamily = o.localIdeographFontFamily, this._validateStyle = o.validateStyle, o.style && this.setStyle(o.style, {
              localIdeographFontFamily: o.localIdeographFontFamily
            }), o.attributionControl && this.addControl(new an(typeof o.attributionControl == "boolean" ? void 0 : o.attributionControl)), o.maplibreLogo && this.addControl(new wu, o.logoPosition), this.on("style.load", (() => {
              if (g || this._resizeTransform(), this.transform.unmodified) {
                const w = s.S(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                this.jumpTo(w)
              }
            })), this.on("data", (w => {
              this._update(w.dataType === "style"), this.fire(new s.l(`${w.dataType}data`, w))
            })), this.on("dataloading", (w => {
              this.fire(new s.l(`${w.dataType}dataloading`, w))
            })), this.on("dataabort", (w => {
              this.fire(new s.l("sourcedataabort", w))
            }))
          }
          _getMapId() {
            return this._mapId
          }
          setGlobalStateProperty(d, e) {
            return this.style.setGlobalStateProperty(d, e), this._update(!0)
          }
          getGlobalState() {
            return this.style.getGlobalState()
          }
          addControl(d, e) {
            if (e === void 0 && (e = d.getDefaultPosition ? d.getDefaultPosition() : "top-right"), !d || !d.onAdd) return this.fire(new s.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const a = d.onAdd(this);
            this._controls.push(d);
            const o = this._controlPositions[e];
            return e.indexOf("bottom") !== -1 ? o.insertBefore(a, o.firstChild) : o.appendChild(a), this
          }
          removeControl(d) {
            if (!d || !d.onRemove) return this.fire(new s.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const e = this._controls.indexOf(d);
            return e > -1 && this._controls.splice(e, 1), d.onRemove(this), this
          }
          hasControl(d) {
            return this._controls.indexOf(d) > -1
          }
          coveringTiles(d) {
            return it(this.transform, d)
          }
          calculateCameraOptionsFromTo(d, e, a, o) {
            return o == null && this.terrain && (o = this.terrain.getElevationForLngLatZoom(a, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(d, e, a, o)
          }
          resize(d, e = !0) {
            const [a, o] = this._containerDimensions(), u = this._getClampedPixelRatio(a, o);
            if (this._resizeCanvas(a, o, u), this.painter.resize(a, o, u), this.painter.overLimit()) {
              const g = this.painter.context.gl;
              this._maxCanvasSize = [g.drawingBufferWidth, g.drawingBufferHeight];
              const w = this._getClampedPixelRatio(a, o);
              this._resizeCanvas(a, o, w), this.painter.resize(a, o, w)
            }
            this._resizeTransform(e);
            const p = !this._moving;
            return p && (this.stop(), this.fire(new s.l("movestart", d)).fire(new s.l("move", d))), this.fire(new s.l("resize", d)), p && this.fire(new s.l("moveend", d)), this
          }
          _resizeTransform(d = !0) {
            var e;
            const [a, o] = this._containerDimensions();
            this.transform.resize(a, o, d), (e = this._requestedCameraState) === null || e === void 0 || e.resize(a, o, d)
          }
          _getClampedPixelRatio(d, e) {
            const {
              0: a,
              1: o
            } = this._maxCanvasSize, u = this.getPixelRatio(), p = d * u, g = e * u;
            return Math.min(p > a ? a / p : 1, g > o ? o / g : 1) * u
          }
          getPixelRatio() {
            var d;
            return (d = this._overridePixelRatio) !== null && d !== void 0 ? d : devicePixelRatio
          }
          setPixelRatio(d) {
            this._overridePixelRatio = d, this.resize()
          }
          getBounds() {
            return this.transform.getBounds()
          }
          getMaxBounds() {
            return this.transform.getMaxBounds()
          }
          setMaxBounds(d) {
            return this.transform.setMaxBounds(Ut.convert(d)), this._update()
          }
          setMinZoom(d) {
            if ((d = d ?? -2) >= -2 && d <= this.transform.maxZoom) return this.transform.setMinZoom(d), this._update(), this.getZoom() < d && this.setZoom(d), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive")
          }
          getMinZoom() {
            return this.transform.minZoom
          }
          setMaxZoom(d) {
            if ((d = d ?? 22) >= this.transform.minZoom) return this.transform.setMaxZoom(d), this._update(), this.getZoom() > d && this.setZoom(d), this;
            throw new Error("maxZoom must be greater than the current minZoom")
          }
          getMaxZoom() {
            return this.transform.maxZoom
          }
          setMinPitch(d) {
            if ((d = d ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (d >= 0 && d <= this.transform.maxPitch) return this.transform.setMinPitch(d), this._update(), this.getPitch() < d && this.setPitch(d), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive")
          }
          getMinPitch() {
            return this.transform.minPitch
          }
          setMaxPitch(d) {
            if ((d = d ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180");
            if (d >= this.transform.minPitch) return this.transform.setMaxPitch(d), this._update(), this.getPitch() > d && this.setPitch(d), this;
            throw new Error("maxPitch must be greater than the current minPitch")
          }
          getMaxPitch() {
            return this.transform.maxPitch
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies
          }
          setRenderWorldCopies(d) {
            return this.transform.setRenderWorldCopies(d), this._update()
          }
          setTransformConstrain(d) {
            return this.transform.setConstrain(d), this._update()
          }
          project(d) {
            return this.transform.locationToScreenPoint(s.U.convert(d), this.style && this.terrain)
          }
          unproject(d) {
            return this.transform.screenPointToLocation(s.P.convert(d), this.terrain)
          }
          isMoving() {
            var d;
            return this._moving || ((d = this.handlers) === null || d === void 0 ? void 0 : d.isMoving())
          }
          isZooming() {
            var d;
            return this._zooming || ((d = this.handlers) === null || d === void 0 ? void 0 : d.isZooming())
          }
          isRotating() {
            var d;
            return this._rotating || ((d = this.handlers) === null || d === void 0 ? void 0 : d.isRotating())
          }
          _createDelegatedListener(d, e, a) {
            if (d === "mouseenter" || d === "mouseover") {
              let o = !1;
              return {
                layers: e,
                listener: a,
                delegates: {
                  mousemove: p => {
                    const g = e.filter((I => this.getLayer(I))),
                      w = g.length !== 0 ? this.queryRenderedFeatures(p.point, {
                        layers: g
                      }) : [];
                    w.length ? o || (o = !0, a.call(this, new mn(d, this, p.originalEvent, {
                      features: w
                    }))) : o = !1
                  },
                  mouseout: () => {
                    o = !1
                  }
                }
              }
            }
            if (d === "mouseleave" || d === "mouseout") {
              let o = !1;
              return {
                layers: e,
                listener: a,
                delegates: {
                  mousemove: g => {
                    const w = e.filter((I => this.getLayer(I)));
                    (w.length !== 0 ? this.queryRenderedFeatures(g.point, {
                      layers: w
                    }) : []).length ? o = !0 : o && (o = !1, a.call(this, new mn(d, this, g.originalEvent)))
                  },
                  mouseout: g => {
                    o && (o = !1, a.call(this, new mn(d, this, g.originalEvent)))
                  }
                }
              }
            } {
              const o = u => {
                const p = e.filter((w => this.getLayer(w))),
                  g = p.length !== 0 ? this.queryRenderedFeatures(u.point, {
                    layers: p
                  }) : [];
                g.length && (u.features = g, a.call(this, u), delete u.features)
              };
              return {
                layers: e,
                listener: a,
                delegates: {
                  [d]: o
                }
              }
            }
          }
          _saveDelegatedListener(d, e) {
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[d] = this._delegatedListeners[d] || [], this._delegatedListeners[d].push(e)
          }
          _removeDelegatedListener(d, e, a) {
            if (!this._delegatedListeners || !this._delegatedListeners[d]) return;
            const o = this._delegatedListeners[d];
            for (let u = 0; u < o.length; u++) {
              const p = o[u];
              if (p.listener === a && p.layers.length === e.length && p.layers.every((g => e.includes(g)))) {
                for (const g in p.delegates) this.off(g, p.delegates[g]);
                return void o.splice(u, 1)
              }
            }
          }
          on(d, e, a) {
            if (a === void 0) return super.on(d, e);
            const o = typeof e == "string" ? [e] : e,
              u = this._createDelegatedListener(d, o, a);
            this._saveDelegatedListener(d, u);
            for (const p in u.delegates) this.on(p, u.delegates[p]);
            return {
              unsubscribe: () => {
                this._removeDelegatedListener(d, o, a)
              }
            }
          }
          once(d, e, a) {
            if (a === void 0) return super.once(d, e);
            const o = typeof e == "string" ? [e] : e,
              u = this._createDelegatedListener(d, o, a);
            for (const p in u.delegates) {
              const g = u.delegates[p];
              u.delegates[p] = (...w) => {
                this._removeDelegatedListener(d, o, a), g(...w)
              }
            }
            this._saveDelegatedListener(d, u);
            for (const p in u.delegates) this.once(p, u.delegates[p]);
            return this
          }
          off(d, e, a) {
            return a === void 0 ? super.off(d, e) : (this._removeDelegatedListener(d, typeof e == "string" ? [e] : e, a), this)
          }
          queryRenderedFeatures(d, e) {
            if (!this.style) return [];
            let a;
            const o = d instanceof s.P || Array.isArray(d),
              u = o ? d : [
                [0, 0],
                [this.transform.width, this.transform.height]
              ];
            if (e = e || (o ? {} : d) || {}, u instanceof s.P || typeof u[0] == "number") a = [s.P.convert(u)];
            else {
              const p = s.P.convert(u[0]),
                g = s.P.convert(u[1]);
              a = [p, new s.P(g.x, p.y), g, new s.P(p.x, g.y), p]
            }
            return this.style.queryRenderedFeatures(a, e, this.transform)
          }
          querySourceFeatures(d, e) {
            return this.style.querySourceFeatures(d, e)
          }
          setStyle(d, e) {
            return (e = s.e({}, {
              localIdeographFontFamily: this._localIdeographFontFamily,
              validate: this._validateStyle
            }, e)).diff !== !1 && e.localIdeographFontFamily === this._localIdeographFontFamily && this.style && d ? (this._diffStyle(d, e), this) : (this._localIdeographFontFamily = e.localIdeographFontFamily, this._updateStyle(d, e))
          }
          setTransformRequest(d) {
            return this._requestManager.setTransformRequest(d), this
          }
          _getUIString(d) {
            const e = this._locale[d];
            if (e == null) throw new Error(`Missing UI string '${d}'`);
            return e
          }
          _updateStyle(d, e) {
            var a, o;
            if (e.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", (() => this._updateStyle(d, e)));
            const u = this.style && e.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!d)), d ? (this.style = new Go(this, e || {}), this.style.setEventedParent(this, {
              style: this.style
            }), typeof d == "string" ? this.style.loadURL(d, e, u) : this.style.loadJSON(d, e, u), this) : ((o = (a = this.style) === null || a === void 0 ? void 0 : a.projection) === null || o === void 0 || o.destroy(), delete this.style, this)
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new Go(this, {}), this.style.setEventedParent(this, {
              style: this.style
            }), this.style.loadEmpty())
          }
          _diffStyle(d, e) {
            if (typeof d == "string") {
              const a = this._requestManager.transformRequest(d, "Style");
              s.j(a, new AbortController).then((o => {
                this._updateDiff(o.data, e)
              })).catch((o => {
                o && this.fire(new s.k(o))
              }))
            } else typeof d == "object" && this._updateDiff(d, e)
          }
          _updateDiff(d, e) {
            try {
              this.style.setState(d, e) && this._update(!0)
            } catch (a) {
              s.w(`Unable to perform style diff: ${a.message||a.error||a}.  Rebuilding the style from scratch.`), this._updateStyle(d, e)
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize()
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : s.w("There is no style added to the map.")
          }
          addSource(d, e) {
            return this._lazyInitEmptyStyle(), this.style.addSource(d, e), this._update(!0)
          }
          isSourceLoaded(d) {
            const e = this.style && this.style.tileManagers[d];
            if (e !== void 0) return e.loaded();
            this.fire(new s.k(new Error(`There is no tile manager with ID '${d}'`)))
          }
          setTerrain(d) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), d) {
              const e = this.style.tileManagers[d.source];
              if (!e) throw new Error(`cannot load terrain, because there exists no source with ID: ${d.source}`);
              this.terrain === null && e.reload();
              for (const a in this.style._layers) {
                const o = this.style._layers[a];
                o.type === "hillshade" && o.source === d.source && s.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), o.type === "color-relief" && o.source === d.source && s.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.")
              }
              this.terrain = new uf(this.painter, e, d), this.painter.renderToTexture = new _a(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = a => {
                var o;
                a.dataType === "style" ? this.terrain.tileManager.freeRtt() : a.dataType === "source" && a.tile && (a.sourceId !== d.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), ((o = a.source) === null || o === void 0 ? void 0 : o.type) === "image" ? this.terrain.tileManager.freeRtt() : this.terrain.tileManager.freeRtt(a.tile.tileID))
              }, this.style.on("data", this._terrainDataCallback)
            } else this.terrain && this.terrain.tileManager.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
            return this.fire(new s.l("terrain", {
              terrain: d
            })), this
          }
          getTerrain() {
            var d, e;
            return (e = (d = this.terrain) === null || d === void 0 ? void 0 : d.options) !== null && e !== void 0 ? e : null
          }
          areTilesLoaded() {
            const d = this.style && this.style.tileManagers;
            for (const e in d) {
              const a = d[e]._tiles;
              for (const o in a) {
                const u = a[o];
                if (u.state !== "loaded" && u.state !== "errored") return !1
              }
            }
            return !0
          }
          removeSource(d) {
            return this.style.removeSource(d), this._update(!0)
          }
          getSource(d) {
            return this.style.getSource(d)
          }
          setSourceTileLodParams(d, e, a) {
            if (a) {
              const o = this.getSource(a);
              if (!o) throw new Error(`There is no source with ID "${a}", cannot set LOD parameters`);
              o.calculateTileZoom = Ge(Math.max(1, d), Math.max(1, e))
            } else
              for (const o in this.style.tileManagers) this.style.tileManagers[o].getSource().calculateTileZoom = Ge(Math.max(1, d), Math.max(1, e));
            return this._update(!0), this
          }
          refreshTiles(d, e) {
            const a = this.style.tileManagers[d];
            if (!a) throw new Error(`There is no tile manager with ID "${d}", cannot refresh tile`);
            e === void 0 ? a.reload(!0) : a.refreshTiles(e.map((o => new s.a8(o.z, o.x, o.y))))
          }
          addImage(d, e, a = {}) {
            const {
              pixelRatio: o = 1,
              sdf: u = !1,
              stretchX: p,
              stretchY: g,
              content: w,
              textFitWidth: I,
              textFitHeight: A
            } = a;
            if (this._lazyInitEmptyStyle(), !(e instanceof HTMLImageElement || s.b(e))) {
              if (e.width === void 0 || e.height === void 0) return this.fire(new s.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const {
                  width: L,
                  height: O,
                  data: R
                } = e, H = e;
                return this.style.addImage(d, {
                  data: new s.R({
                    width: L,
                    height: O
                  }, new Uint8Array(R)),
                  pixelRatio: o,
                  stretchX: p,
                  stretchY: g,
                  content: w,
                  textFitWidth: I,
                  textFitHeight: A,
                  sdf: u,
                  version: 0,
                  userImage: H
                }), H.onAdd && H.onAdd(this, d), this
              }
            } {
              const {
                width: L,
                height: O,
                data: R
              } = re.getImageData(e);
              this.style.addImage(d, {
                data: new s.R({
                  width: L,
                  height: O
                }, R),
                pixelRatio: o,
                stretchX: p,
                stretchY: g,
                content: w,
                textFitWidth: I,
                textFitHeight: A,
                sdf: u,
                version: 0
              })
            }
          }
          updateImage(d, e) {
            const a = this.style.getImage(d);
            if (!a) return this.fire(new s.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const o = e instanceof HTMLImageElement || s.b(e) ? re.getImageData(e) : e,
              {
                width: u,
                height: p,
                data: g
              } = o;
            if (u === void 0 || p === void 0) return this.fire(new s.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (u !== a.data.width || p !== a.data.height) return this.fire(new s.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const w = !(e instanceof HTMLImageElement || s.b(e));
            return a.data.replace(g, w), this.style.updateImage(d, a), this
          }
          getImage(d) {
            return this.style.getImage(d)
          }
          hasImage(d) {
            return d ? !!this.style.getImage(d) : (this.fire(new s.k(new Error("Missing required image id"))), !1)
          }
          removeImage(d) {
            this.style.removeImage(d)
          }
          loadImage(d) {
            return ze.getImage(this._requestManager.transformRequest(d, "Image"), new AbortController)
          }
          listImages() {
            return this.style.listImages()
          }
          addLayer(d, e) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(d, e), this._update(!0)
          }
          moveLayer(d, e) {
            return this.style.moveLayer(d, e), this._update(!0)
          }
          removeLayer(d) {
            return this.style.removeLayer(d), this._update(!0)
          }
          getLayer(d) {
            return this.style.getLayer(d)
          }
          getLayersOrder() {
            return this.style.getLayersOrder()
          }
          setLayerZoomRange(d, e, a) {
            return this.style.setLayerZoomRange(d, e, a), this._update(!0)
          }
          setFilter(d, e, a = {}) {
            return this.style.setFilter(d, e, a), this._update(!0)
          }
          getFilter(d) {
            return this.style.getFilter(d)
          }
          setPaintProperty(d, e, a, o = {}) {
            return this.style.setPaintProperty(d, e, a, o), this._update(!0)
          }
          getPaintProperty(d, e) {
            return this.style.getPaintProperty(d, e)
          }
          setLayoutProperty(d, e, a, o = {}) {
            return this.style.setLayoutProperty(d, e, a, o), this._update(!0)
          }
          getLayoutProperty(d, e) {
            return this.style.getLayoutProperty(d, e)
          }
          setGlyphs(d, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(d, e), this._update(!0)
          }
          getGlyphs() {
            return this.style.getGlyphsUrl()
          }
          addSprite(d, e, a = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(d, e, a, (o => {
              o || this._update(!0)
            })), this
          }
          removeSprite(d) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(d), this._update(!0)
          }
          getSprite() {
            return this.style.getSprite()
          }
          setSprite(d, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(d, e, (a => {
              a || this._update(!0)
            })), this
          }
          setLight(d, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(d, e), this._update(!0)
          }
          getLight() {
            return this.style.getLight()
          }
          setSky(d, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSky(d, e), this._update(!0)
          }
          getSky() {
            return this.style.getSky()
          }
          setFeatureState(d, e) {
            return this.style.setFeatureState(d, e), this._update()
          }
          removeFeatureState(d, e) {
            return this.style.removeFeatureState(d, e), this._update()
          }
          getFeatureState(d) {
            return this.style.getFeatureState(d)
          }
          getContainer() {
            return this._container
          }
          getCanvasContainer() {
            return this._canvasContainer
          }
          getCanvas() {
            return this._canvas
          }
          _containerDimensions() {
            let d = 0,
              e = 0;
            return this._container && (d = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [d, e]
          }
          _setupContainer() {
            const d = this._container;
            d.classList.add("maplibregl-map");
            const e = this._canvasContainer = q.create("div", "maplibregl-canvas-container", d);
            this._interactive && e.classList.add("maplibregl-interactive"), this._canvas = q.create("canvas", "maplibregl-canvas", e), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
            const a = this._containerDimensions(),
              o = this._getClampedPixelRatio(a[0], a[1]);
            this._resizeCanvas(a[0], a[1], o);
            const u = this._controlContainer = q.create("div", "maplibregl-control-container", d),
              p = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((g => {
              p[g] = q.create("div", `maplibregl-ctrl-${g} `, u)
            })), this._container.addEventListener("scroll", this._onMapScroll, !1)
          }
          _resizeCanvas(d, e, a) {
            this._canvas.width = Math.floor(a * d), this._canvas.height = Math.floor(a * e), this._canvas.style.width = `${d}px`, this._canvas.style.height = `${e}px`
          }
          _setupPainter() {
            const d = Object.assign(Object.assign({}, this._canvasContextAttributes), {
              alpha: !0,
              depth: !0,
              stencil: !0,
              premultipliedAlpha: !0
            });
            let e = null;
            this._canvas.addEventListener("webglcontextcreationerror", (o => {
              e = {
                requestedAttributes: d
              }, o && (e.statusMessage = o.statusMessage, e.type = o.type)
            }), {
              once: !0
            });
            let a = null;
            if (a = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, d) : this._canvas.getContext("webgl2", d) || this._canvas.getContext("webgl", d), !a) {
              const o = "Failed to initialize WebGL";
              throw e ? (e.message = o, new Error(JSON.stringify(e))) : new Error(o)
            }
            this.painter = new ud(a, this.transform), ye.testSupport(a)
          }
          migrateProjection(d, e) {
            super.migrateProjection(d, e), this.painter.transform = d, this.fire(new s.l("projectiontransition", {
              newProjection: this.style.projection.name
            }))
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded()
          }
          _update(d) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || d, this._sourcesDirty = !0, this.triggerRepaint(), this) : this
          }
          _requestRenderFrame(d) {
            return this._update(), this._renderTaskQueue.add(d)
          }
          _cancelRenderFrame(d) {
            this._renderTaskQueue.remove(d)
          }
          _render(d) {
            var e, a, o, u, p;
            const g = this._idleTriggered ? this._fadeDuration : 0,
              w = ((e = this.style.projection) === null || e === void 0 ? void 0 : e.transitionState) > 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(d), this._removed) return;
            let I = !1;
            if (this.style && this._styleDirty) {
              this._styleDirty = !1;
              const O = this.transform.zoom,
                R = me();
              this.style.zoomHistory.update(O, R);
              const H = new s.G(O, {
                  now: R,
                  fadeDuration: g,
                  zoomHistory: this.style.zoomHistory,
                  transition: this.style.getTransition()
                }),
                $ = H.crossFadingFactor();
              $ === 1 && $ === this._crossFadingFactor || (I = !0, this._crossFadingFactor = $), this.style.update(H)
            }
            const A = ((a = this.style.projection) === null || a === void 0 ? void 0 : a.transitionState) > 0 !== w;
            (o = this.style.projection) === null || o === void 0 || o.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((u = this.style.projection) === null || u === void 0 ? void 0 : u.transitionState, (p = this.style.projection) === null || p === void 0 ? void 0 : p.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || A) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.tileManager.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, g, this._crossSourceCollisions, A), this.painter.render(this.style, {
              showTileBoundaries: this.showTileBoundaries,
              showOverdrawInspector: this._showOverdrawInspector,
              rotating: this.isRotating(),
              zooming: this.isZooming(),
              moving: this.isMoving(),
              fadeDuration: g,
              showPadding: this.showPadding
            }), this.fire(new s.l("render")), this.loaded() && !this._loaded && (this._loaded = !0, s.cz.mark(s.cA.load), this.fire(new s.l("load"))), this.style && (this.style.hasTransitions() || I) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const L = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return L || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new s.l("idle")), !this._loaded || this._fullyLoaded || L || (this._fullyLoaded = !0, s.cz.mark(s.cA.fullLoad)), this
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this
          }
          remove() {
            var d;
            this._hash && this._hash.remove();
            for (const a of this._controls) a.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), ze.removeThrottleControl(this._imageQueueHandle), (d = this._resizeObserver) === null || d === void 0 || d.disconnect();
            const e = this.painter.context.gl.getExtension("WEBGL_lose_context");
            e != null && e.loseContext && e.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), q.remove(this._canvasContainer), q.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), s.cz.clearMetrics(), this._removed = !0, this.fire(new s.l("remove"))
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController, re.frame(this._frameRequest, (d => {
              s.cz.frame(d), this._frameRequest = null;
              try {
                this._render(d)
              } catch (e) {
                if (!s.cB(e) && !(function(a) {
                    return a.message === rd
                  })(e)) throw e
              }
            }), (() => {})))
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries
          }
          set showTileBoundaries(d) {
            this._showTileBoundaries !== d && (this._showTileBoundaries = d, this._update())
          }
          get showPadding() {
            return !!this._showPadding
          }
          set showPadding(d) {
            this._showPadding !== d && (this._showPadding = d, this._update())
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes
          }
          set showCollisionBoxes(d) {
            this._showCollisionBoxes !== d && (this._showCollisionBoxes = d, d ? this.style._generateCollisionBoxes() : this._update())
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector
          }
          set showOverdrawInspector(d) {
            this._showOverdrawInspector !== d && (this._showOverdrawInspector = d, this._update())
          }
          get repaint() {
            return !!this._repaint
          }
          set repaint(d) {
            this._repaint !== d && (this._repaint = d, this.triggerRepaint())
          }
          get vertices() {
            return !!this._vertices
          }
          set vertices(d) {
            this._vertices = d, this._update()
          }
          get version() {
            return zd
          }
          getCameraTargetElevation() {
            return this.transform.elevation
          }
          getProjection() {
            return this.style.getProjection()
          }
          setProjection(d) {
            return this._lazyInitEmptyStyle(), this.style.setProjection(d), this._update(!0)
          }
        }, T.MapMouseEvent = mn, T.MapTouchEvent = ln, T.MapWheelEvent = gd, T.Marker = ol, T.NavigationControl = class {
          constructor(d) {
            this._updateZoomButtons = () => {
              const e = this._map.getZoom(),
                a = e === this._map.getMaxZoom(),
                o = e === this._map.getMinZoom();
              this._zoomInButton.disabled = a, this._zoomOutButton.disabled = o, this._zoomInButton.setAttribute("aria-disabled", a.toString()), this._zoomOutButton.setAttribute("aria-disabled", o.toString())
            }, this._rotateCompassArrow = () => {
              this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1/Math.pow(Math.cos(this._map.transform.pitchInRadians),.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1/Math.pow(Math.cos(this._map.transform.pitchInRadians),.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing-this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`
            }, this._setButtonTitle = (e, a) => {
              const o = this._map._getUIString(`NavigationControl.${a}`);
              e.title = o, e.setAttribute("aria-label", o)
            }, this.options = s.e({}, Jl, d), this._container = q.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (e => e.preventDefault())), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (e => this._map.zoomIn({}, {
              originalEvent: e
            }))), q.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (e => this._map.zoomOut({}, {
              originalEvent: e
            }))), q.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (e => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, {
                originalEvent: e
              }) : this._map.resetNorth({}, {
                originalEvent: e
              })
            })), this._compassIcon = q.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"))
          }
          onAdd(d) {
            return this._map = d, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Tu(this._map, this._compass, this.options.visualizePitch)), this._container
          }
          onRemove() {
            q.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map
          }
          _createButton(d, e) {
            const a = q.create("button", d, this._container);
            return a.type = "button", a.addEventListener("click", e), a
          }
        }, T.Popup = class extends s.E {
          constructor(d) {
            super(), this._updateOpacity = () => {
              this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "")
            }, this.remove = () => (this._content && q.remove(this._content), this._container && (q.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new s.l("close"))), this), this._onMouseUp = e => {
              this._update(e.point)
            }, this._onMouseMove = e => {
              this._update(e.point)
            }, this._onDrag = e => {
              this._update(e.point)
            }, this._update = e => {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = q.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = q.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className)
                  for (const g of this.options.className.split(" ")) this._container.classList.add(g);
                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer")
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = $l(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !e) return;
              const a = this._flatPos = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && e ? e : this._map.transform.locationToScreenPoint(this._lngLat));
              let o = this.options.anchor;
              const u = rc(this.options.offset);
              if (!o) {
                const g = this._container.offsetWidth,
                  w = this._container.offsetHeight;
                let I;
                I = a.y + u.bottom.y < w ? ["top"] : a.y > this._map.transform.height - w ? ["bottom"] : [], a.x < g / 2 ? I.push("left") : a.x > this._map.transform.width - g / 2 && I.push("right"), o = I.length === 0 ? "bottom" : I.join("-")
              }
              let p = a.add(u[o]);
              this.options.subpixelPositioning || (p = p.round()), q.setTransform(this._container, `${Ys[o]} translate(${p.x}px,${p.y}px)`), Ql(this._container, o, "popup"), this._updateOpacity()
            }, this._onClose = () => {
              this.remove()
            }, this.options = s.e(Object.create(Iu), d)
          }
          addTo(d) {
            return this._map && this.remove(), this._map = d, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new s.l("open")), this
          }
          isOpen() {
            return !!this._map
          }
          getLngLat() {
            return this._lngLat
          }
          setLngLat(d) {
            return this._lngLat = s.U.convert(d), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this
          }
          trackPointer() {
            return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this
          }
          getElement() {
            return this._container
          }
          setText(d) {
            return this.setDOMContent(document.createTextNode(d))
          }
          setHTML(d) {
            const e = document.createDocumentFragment(),
              a = document.createElement("body");
            let o;
            for (a.innerHTML = d; o = a.firstChild, o;) e.appendChild(o);
            return this.setDOMContent(e)
          }
          getMaxWidth() {
            var d;
            return (d = this._container) === null || d === void 0 ? void 0 : d.style.maxWidth
          }
          setMaxWidth(d) {
            return this.options.maxWidth = d, this._update(), this
          }
          setDOMContent(d) {
            if (this._content)
              for (; this._content.hasChildNodes();) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = q.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(d), this._createCloseButton(), this._update(), this._focusFirstElement(), this
          }
          addClassName(d) {
            return this._container && this._container.classList.add(d), this
          }
          removeClassName(d) {
            return this._container && this._container.classList.remove(d), this
          }
          setOffset(d) {
            return this.options.offset = d, this._update(), this
          }
          toggleClassName(d) {
            if (this._container) return this._container.classList.toggle(d)
          }
          setSubpixelPositioning(d) {
            this.options.subpixelPositioning = d
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = q.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose))
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const d = this._container.querySelector(tc);
            d && d.focus()
          }
        }, T.RasterDEMTileSource = kr, T.RasterTileSource = ir, T.ScaleControl = class {
          constructor(d) {
            this._onMove = () => {
              ec(this._map, this._container, this.options)
            }, this.setUnit = e => {
              this.options.unit = e, ec(this._map, this._container, this.options)
            }, this.options = Object.assign(Object.assign({}, Pu), d)
          }
          getDefaultPosition() {
            return "bottom-left"
          }
          onAdd(d) {
            return this._map = d, this._container = q.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", d.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container
          }
          onRemove() {
            q.remove(this._container), this._map.off("move", this._onMove), this._map = void 0
          }
        }, T.ScrollZoomHandler = Id, T.Style = Go, T.TerrainControl = class {
          constructor(d) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon()
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"))
            }, this.options = d
          }
          onAdd(d) {
            return this._map = d, this._container = q.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = q.create("button", "maplibregl-ctrl-terrain", this._container), q.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container
          }
          onRemove() {
            q.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0
          }
        }, T.TwoFingersTouchPitchHandler = Td, T.TwoFingersTouchRotateHandler = Yl, T.TwoFingersTouchZoomHandler = wd, T.TwoFingersTouchZoomRotateHandler = Cd, T.VectorTileSource = Rt, T.VideoSource = Kt, T.addSourceType = (d, e) => s._(void 0, void 0, void 0, (function*() {
          if (ii(d)) throw new Error(`A source type called "${d}" already exists.`);
          ((a, o) => {
            Lr[a] = o
          })(d, e)
        })), T.clearPrewarmedResources = function() {
          const d = Zt;
          d && (d.isPreloaded() && d.numActive() === 1 ? (d.release(wt), Zt = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"))
        }, T.createTileMesh = Tn, T.getMaxParallelImageRequests = function() {
          return s.a.MAX_PARALLEL_IMAGE_REQUESTS
        }, T.getRTLTextPluginStatus = function() {
          return U().getRTLTextPluginStatus()
        }, T.getVersion = function() {
          return Mu
        }, T.getWorkerCount = function() {
          return Ct.workerCount
        }, T.getWorkerUrl = function() {
          return s.a.WORKER_URL
        }, T.importScriptInWorkers = function(d) {
          return Vt().broadcast("IS", d)
        }, T.isTimeFrozen = function() {
          return he.isFrozen()
        }, T.now = me, T.prewarm = function() {
          ht().acquire(wt)
        }, T.restoreNow = function() {
          he.restoreNow()
        }, T.setMaxParallelImageRequests = function(d) {
          s.a.MAX_PARALLEL_IMAGE_REQUESTS = d
        }, T.setNow = function(d) {
          he.setNow(d)
        }, T.setRTLTextPlugin = function(d, e) {
          return U().setRTLTextPlugin(d, e)
        }, T.setWorkerCount = function(d) {
          Ct.workerCount = d
        }, T.setWorkerUrl = function(d) {
          s.a.WORKER_URL = d
        }
      }));
      var z = _;
      return z
    }))
  })(hp)), hp.exports
}
var eT = Q3();
const tp = J3(eT);
class Lv {
  constructor(l) {
    bi(this, "gm");
    bi(this, "markers", new Map);
    bi(this, "canvases", new Map);
    bi(this, "canvasSize");
    bi(this, "canvasOpacity", .8);
    this.input = l, this.gm = new kn(this.input.tileSize);
    const _ = W0(l.img);
    this.canvasSize = Math.ceil(2e3 / _)
  }
  place([l, _]) {
    const x = this.gm.latLonToPixelsFloor(l, _, this.input.zoom),
      k = this.getMarkerId(x),
      z = this.gm.latLonToPixelBoundsLatLon(l, _, this.input.zoom),
      T = this.input.map;
    if (this.input.markerFn && !this.markers.has(k)) {
      const G = this.input.markerFn();
      G.setLngLat({
        lat: z.min[0],
        lng: (z.max[1] + z.min[1]) / 2
      }).addTo(T), this.markers.set(k, G)
    }
    const {
      key: s,
      pos: F,
      innerPos: Z
    } = this.getCanvasPos(x);
    let K = this.canvases.get(s);
    if (!K) {
      const G = this.canvasSize,
        re = F.x * G,
        he = F.y * G,
        me = re + G - 1,
        q = he + G - 1,
        ye = this.gm.pixelsToLatLon(re, q + 1, this.input.zoom),
        be = this.gm.pixelsToLatLon(me + 1, he, this.input.zoom);
      K = new tT({
        id: `${this.input.id}-${s}`,
        img: this.input.img,
        canvasSize: this.canvasSize,
        coordinates: hg({
          min: ye,
          max: be
        }),
        layerPaint: {
          "raster-resampling": "nearest",
          "raster-opacity": this.canvasOpacity
        }
      }), K.addTo(this.input.map), this.canvases.set(s, K)
    }
    K.place(Z.x, Z.y)
  }
  clear() {
    const l = this.input.map;
    for (const _ of this.canvases.values()) _.removeFrom(l), _.removeDOM();
    this.canvases.clear();
    for (const _ of this.markers.values()) _.remove();
    this.markers.clear()
  }
  clearAndPlace(l) {
    this.clear(), this.place(l)
  }
  remove([l, _]) {
    let x = !1;
    const k = this.gm.latLonToPixelsFloor(l, _, this.input.zoom),
      {
        key: z,
        innerPos: T
      } = this.getCanvasPos(k),
      s = this.canvases.get(z);
    s && (x = s.remove(T.x, T.y), s.annotationsCount() === 0 && (this.canvases.delete(z), s.removeFrom(this.input.map), s.removeDOM()));
    const F = this.getMarkerId(k),
      Z = this.markers.get(F);
    return Z == null || Z.remove(), this.markers.delete(F), x
  }
  setCanvasOpacity(l) {
    this.canvasOpacity = l;
    for (const _ of this.canvases.values()) _.setOpacity(l)
  }
  getMarkerId([l, _]) {
    return `${this.input.id}:${l},${_}`
  }
  getCanvasPos([l, _]) {
    const x = {
        x: Math.floor(l / this.canvasSize),
        y: Math.floor(_ / this.canvasSize)
      },
      k = {
        x: l % this.canvasSize,
        y: _ % this.canvasSize
      },
      z = `${x.x},${x.y}`;
    return {
      pos: x,
      innerPos: k,
      key: z
    }
  }
}
class tT {
  constructor(l) {
    bi(this, "annotations", new Set);
    bi(this, "canvas");
    bi(this, "imgSize");
    bi(this, "maps", new Set);
    bi(this, "pendingRepaint", !1);
    this.input = l, this.imgSize = W0(l.img), this.canvas = document.createElement("canvas"), this.canvas.width = this.input.canvasSize * this.imgSize, this.canvas.height = this.input.canvasSize * this.imgSize
  }
  place(l, _) {
    const x = this.getPixelKey(l, _);
    if (this.annotations.has(x)) return !1;
    const k = this.canvas.getContext("2d");
    if (k) {
      const z = l * this.imgSize,
        T = _ * this.imgSize;
      k.drawImage(this.input.img, z, T)
    }
    return this.annotations.add(x), this.triggerRepaint(), !0
  }
  remove(l, _) {
    const x = this.getPixelKey(l, _);
    if (!this.annotations.has(x)) return !1;
    const k = this.canvas.getContext("2d");
    if (k) {
      const z = l * this.imgSize,
        T = _ * this.imgSize;
      k.clearRect(z, T, this.imgSize, this.imgSize)
    }
    return this.annotations.delete(x), this.triggerRepaint(), !0
  }
  addTo(l) {
    const _ = this.input.id;
    l.getSource(_) || l.addSource(_, {
      type: "canvas",
      canvas: this.canvas,
      coordinates: this.input.coordinates,
      animate: !1
    }), l.getLayer(_) || l.addLayer({
      id: _,
      type: "raster",
      source: _,
      paint: this.input.layerPaint
    }), this.maps.add(l)
  }
  removeFrom(l) {
    const {
      id: _
    } = this.input;
    l.getLayer(_) && l.removeLayer(_), l.getSource(_) && l.removeSource(_), this.maps.delete(l)
  }
  removeDOM() {
    this.canvas.remove()
  }
  annotationsCount() {
    return this.annotations.size
  }
  setOpacity(l) {
    for (const _ of this.maps.values()) _.setPaintProperty(this.input.id, "raster-opacity", l)
  }
  getPixelKey(l, _) {
    return `${l},${_}`
  }
  triggerRepaint() {
    this.pendingRepaint || (this.pendingRepaint = !0, requestAnimationFrame(() => {
      for (const l of this.maps.values()) {
        const _ = l.getSource(this.input.id);
        _.play(), l.once("render", () => {
          _.pause(), this.pendingRepaint = !1
        })
      }
    }))
  }
}

function W0(y) {
  return Math.max(y.naturalWidth, y.naturalHeight)
}

function rT() {
  return window.matchMedia("(display-mode: standalone)").matches || "standalone" in window.navigator && window.navigator.standalone === !0
}

function iT(y) {
  const l = {
      opaque: !0
    },
    _ = y.searchParams.get("lat"),
    x = y.searchParams.get("lng");
  _ && x && (l.pos = {
    lat: parseFloat(_),
    lng: parseFloat(x)
  });
  const k = y.searchParams.get("zoom");
  k && (l.zoom = parseFloat(k));
  const z = y.searchParams.get("season");
  z && (l.season = parseInt(z));
  const T = y.searchParams.get("opaque");
  return T && (l.opaque = T !== "0"), y.searchParams.get("select") && (l.select = !0), y.searchParams.get("twitch-migration") && (l.twitchMigration = !0), l.newUser = !!y.searchParams.get("new-user"), l.discordLinked = !!y.searchParams.get("discord-linked"), l.alliance = !!y.searchParams.get("alliance"), l
}

function aT(y, l) {
  return y = new URL(y), l.pos !== void 0 && (y.searchParams.set("lat", l.pos.lat.toString()), y.searchParams.set("lng", l.pos.lng.toString())), l.zoom !== void 0 && y.searchParams.set("zoom", l.zoom.toString()), l.season !== void 0 && y.searchParams.set("season", l.season.toString()), l.opaque !== void 0 && y.searchParams.set("opaque", l.opaque ? "1" : "0"), l.newUser !== void 0 && y.searchParams.set("new-user", l.newUser ? "1" : "0"), l.alliance !== void 0 && y.searchParams.set("alliance", l.alliance ? "1" : "0"), l.select && y.searchParams.set("alliance", "1"), y
}
var _m = function() {
  return _m = Object.assign || function(l) {
    for (var _, x = 1, k = arguments.length; x < k; x++) {
      _ = arguments[x];
      for (var z in _) Object.prototype.hasOwnProperty.call(_, z) && (l[z] = _[z])
    }
    return l
  }, _m.apply(this, arguments)
};

function Rs(y, l, _, x) {
  function k(z) {
    return z instanceof _ ? z : new _(function(T) {
      T(z)
    })
  }
  return new(_ || (_ = Promise))(function(z, T) {
    function s(K) {
      try {
        Z(x.next(K))
      } catch (G) {
        T(G)
      }
    }

    function F(K) {
      try {
        Z(x.throw(K))
      } catch (G) {
        T(G)
      }
    }

    function Z(K) {
      K.done ? z(K.value) : k(K.value).then(s, F)
    }
    Z((x = x.apply(y, l || [])).next())
  })
}

function Fs(y, l) {
  var _ = {
      label: 0,
      sent: function() {
        if (z[0] & 1) throw z[1];
        return z[1]
      },
      trys: [],
      ops: []
    },
    x, k, z, T = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
  return T.next = s(0), T.throw = s(1), T.return = s(2), typeof Symbol == "function" && (T[Symbol.iterator] = function() {
    return this
  }), T;

  function s(Z) {
    return function(K) {
      return F([Z, K])
    }
  }

  function F(Z) {
    if (x) throw new TypeError("Generator is already executing.");
    for (; T && (T = 0, Z[0] && (_ = 0)), _;) try {
      if (x = 1, k && (z = Z[0] & 2 ? k.return : Z[0] ? k.throw || ((z = k.return) && z.call(k), 0) : k.next) && !(z = z.call(k, Z[1])).done) return z;
      switch (k = 0, z && (Z = [Z[0] & 2, z.value]), Z[0]) {
        case 0:
        case 1:
          z = Z;
          break;
        case 4:
          return _.label++, {
            value: Z[1],
            done: !1
          };
        case 5:
          _.label++, k = Z[1], Z = [0];
          continue;
        case 7:
          Z = _.ops.pop(), _.trys.pop();
          continue;
        default:
          if (z = _.trys, !(z = z.length > 0 && z[z.length - 1]) && (Z[0] === 6 || Z[0] === 2)) {
            _ = 0;
            continue
          }
          if (Z[0] === 3 && (!z || Z[1] > z[0] && Z[1] < z[3])) {
            _.label = Z[1];
            break
          }
          if (Z[0] === 6 && _.label < z[1]) {
            _.label = z[1], z = Z;
            break
          }
          if (z && _.label < z[2]) {
            _.label = z[2], _.ops.push(Z);
            break
          }
          z[2] && _.ops.pop(), _.trys.pop();
          continue
      }
      Z = l.call(y, _)
    } catch (K) {
      Z = [6, K], k = 0
    } finally {
      x = z = 0
    }
    if (Z[0] & 5) throw Z[1];
    return {
      value: Z[0] ? Z[1] : void 0,
      done: !0
    }
  }
}

function H0(y, l, _) {
  if (_ || arguments.length === 2)
    for (var x = 0, k = l.length, z; x < k; x++)(z || !(x in l)) && (z || (z = Array.prototype.slice.call(l, 0, x)), z[x] = l[x]);
  return y.concat(z || Array.prototype.slice.call(l))
}
var X0 = "4.6.2";

function Mp(y, l) {
  return new Promise(function(_) {
    return setTimeout(_, y, l)
  })
}

function nT() {
  return new Promise(function(y) {
    var l = new MessageChannel;
    l.port1.onmessage = function() {
      return y()
    }, l.port2.postMessage(null)
  })
}

function sT(y, l) {
  l === void 0 && (l = 1 / 0);
  var _ = window.requestIdleCallback;
  return _ ? new Promise(function(x) {
    return _.call(window, function() {
      return x()
    }, {
      timeout: l
    })
  }) : Mp(Math.min(y, l))
}

function Y0(y) {
  return !!y && typeof y.then == "function"
}

function Dv(y, l) {
  try {
    var _ = y();
    Y0(_) ? _.then(function(x) {
      return l(!0, x)
    }, function(x) {
      return l(!1, x)
    }) : l(!0, _)
  } catch (x) {
    l(!1, x)
  }
}

function Rv(y, l, _) {
  return _ === void 0 && (_ = 16), Rs(this, void 0, void 0, function() {
    var x, k, z, T;
    return Fs(this, function(s) {
      switch (s.label) {
        case 0:
          x = Array(y.length), k = Date.now(), z = 0, s.label = 1;
        case 1:
          return z < y.length ? (x[z] = l(y[z], z), T = Date.now(), T >= k + _ ? (k = T, [4, nT()]) : [3, 3]) : [3, 4];
        case 2:
          s.sent(), s.label = 3;
        case 3:
          return ++z, [3, 1];
        case 4:
          return [2, x]
      }
    })
  })
}

function Qu(y) {
  return y.then(void 0, function() {}), y
}

function oT(y, l) {
  for (var _ = 0, x = y.length; _ < x; ++_)
    if (y[_] === l) return !0;
  return !1
}

function lT(y, l) {
  return !oT(y, l)
}

function pg(y) {
  return parseInt(y)
}

function ws(y) {
  return parseFloat(y)
}

function oo(y, l) {
  return typeof y == "number" && isNaN(y) ? l : y
}

function zn(y) {
  return y.reduce(function(l, _) {
    return l + (_ ? 1 : 0)
  }, 0)
}

function K0(y, l) {
  if (l === void 0 && (l = 1), Math.abs(l) >= 1) return Math.round(y / l) * l;
  var _ = 1 / l;
  return Math.round(y * _) / _
}

function cT(y) {
  for (var l, _, x = "Unexpected syntax '".concat(y, "'"), k = /^\s*([a-z-]*)(.*)$/i.exec(y), z = k[1] || void 0, T = {}, s = /([.:#][\w-]+|\[.+?\])/gi, F = function(re, he) {
      T[re] = T[re] || [], T[re].push(he)
    };;) {
    var Z = s.exec(k[2]);
    if (!Z) break;
    var K = Z[0];
    switch (K[0]) {
      case ".":
        F("class", K.slice(1));
        break;
      case "#":
        F("id", K.slice(1));
        break;
      case "[": {
        var G = /^\[([\w-]+)([~|^$*]?=("(.*?)"|([\w-]+)))?(\s+[is])?\]$/.exec(K);
        if (G) F(G[1], (_ = (l = G[4]) !== null && l !== void 0 ? l : G[5]) !== null && _ !== void 0 ? _ : "");
        else throw new Error(x);
        break
      }
      default:
        throw new Error(x)
    }
  }
  return [z, T]
}

function uT(y) {
  for (var l = new Uint8Array(y.length), _ = 0; _ < y.length; _++) {
    var x = y.charCodeAt(_);
    if (x > 127) return new TextEncoder().encode(y);
    l[_] = x
  }
  return l
}

function Fo(y, l) {
  var _ = y[0] >>> 16,
    x = y[0] & 65535,
    k = y[1] >>> 16,
    z = y[1] & 65535,
    T = l[0] >>> 16,
    s = l[0] & 65535,
    F = l[1] >>> 16,
    Z = l[1] & 65535,
    K = 0,
    G = 0,
    re = 0,
    he = 0;
  he += z + Z, re += he >>> 16, he &= 65535, re += k + F, G += re >>> 16, re &= 65535, G += x + s, K += G >>> 16, G &= 65535, K += _ + T, K &= 65535, y[0] = K << 16 | G, y[1] = re << 16 | he
}

function ns(y, l) {
  var _ = y[0] >>> 16,
    x = y[0] & 65535,
    k = y[1] >>> 16,
    z = y[1] & 65535,
    T = l[0] >>> 16,
    s = l[0] & 65535,
    F = l[1] >>> 16,
    Z = l[1] & 65535,
    K = 0,
    G = 0,
    re = 0,
    he = 0;
  he += z * Z, re += he >>> 16, he &= 65535, re += k * Z, G += re >>> 16, re &= 65535, re += z * F, G += re >>> 16, re &= 65535, G += x * Z, K += G >>> 16, G &= 65535, G += k * F, K += G >>> 16, G &= 65535, G += z * s, K += G >>> 16, G &= 65535, K += _ * Z + x * F + k * s + z * T, K &= 65535, y[0] = K << 16 | G, y[1] = re << 16 | he
}

function bc(y, l) {
  var _ = y[0];
  l %= 64, l === 32 ? (y[0] = y[1], y[1] = _) : l < 32 ? (y[0] = _ << l | y[1] >>> 32 - l, y[1] = y[1] << l | _ >>> 32 - l) : (l -= 32, y[0] = y[1] << l | _ >>> 32 - l, y[1] = _ << l | y[1] >>> 32 - l)
}

function Kn(y, l) {
  l %= 64, l !== 0 && (l < 32 ? (y[0] = y[1] >>> 32 - l, y[1] = y[1] << l) : (y[0] = y[1] << l - 32, y[1] = 0))
}

function Sa(y, l) {
  y[0] ^= l[0], y[1] ^= l[1]
}
var hT = [4283543511, 3981806797],
  dT = [3301882366, 444984403];

function Fv(y) {
  var l = [0, y[0] >>> 1];
  Sa(y, l), ns(y, hT), l[1] = y[0] >>> 1, Sa(y, l), ns(y, dT), l[1] = y[0] >>> 1, Sa(y, l)
}
var rp = [2277735313, 289559509],
  ip = [1291169091, 658871167],
  Bv = [0, 5],
  pT = [0, 1390208809],
  fT = [0, 944331445];

function mT(y, l) {
  var _ = uT(y);
  l = l || 0;
  var x = [0, _.length],
    k = x[1] % 16,
    z = x[1] - k,
    T = [0, l],
    s = [0, l],
    F = [0, 0],
    Z = [0, 0],
    K;
  for (K = 0; K < z; K = K + 16) F[0] = _[K + 4] | _[K + 5] << 8 | _[K + 6] << 16 | _[K + 7] << 24, F[1] = _[K] | _[K + 1] << 8 | _[K + 2] << 16 | _[K + 3] << 24, Z[0] = _[K + 12] | _[K + 13] << 8 | _[K + 14] << 16 | _[K + 15] << 24, Z[1] = _[K + 8] | _[K + 9] << 8 | _[K + 10] << 16 | _[K + 11] << 24, ns(F, rp), bc(F, 31), ns(F, ip), Sa(T, F), bc(T, 27), Fo(T, s), ns(T, Bv), Fo(T, pT), ns(Z, ip), bc(Z, 33), ns(Z, rp), Sa(s, Z), bc(s, 31), Fo(s, T), ns(s, Bv), Fo(s, fT);
  F[0] = 0, F[1] = 0, Z[0] = 0, Z[1] = 0;
  var G = [0, 0];
  switch (k) {
    case 15:
      G[1] = _[K + 14], Kn(G, 48), Sa(Z, G);
    case 14:
      G[1] = _[K + 13], Kn(G, 40), Sa(Z, G);
    case 13:
      G[1] = _[K + 12], Kn(G, 32), Sa(Z, G);
    case 12:
      G[1] = _[K + 11], Kn(G, 24), Sa(Z, G);
    case 11:
      G[1] = _[K + 10], Kn(G, 16), Sa(Z, G);
    case 10:
      G[1] = _[K + 9], Kn(G, 8), Sa(Z, G);
    case 9:
      G[1] = _[K + 8], Sa(Z, G), ns(Z, ip), bc(Z, 33), ns(Z, rp), Sa(s, Z);
    case 8:
      G[1] = _[K + 7], Kn(G, 56), Sa(F, G);
    case 7:
      G[1] = _[K + 6], Kn(G, 48), Sa(F, G);
    case 6:
      G[1] = _[K + 5], Kn(G, 40), Sa(F, G);
    case 5:
      G[1] = _[K + 4], Kn(G, 32), Sa(F, G);
    case 4:
      G[1] = _[K + 3], Kn(G, 24), Sa(F, G);
    case 3:
      G[1] = _[K + 2], Kn(G, 16), Sa(F, G);
    case 2:
      G[1] = _[K + 1], Kn(G, 8), Sa(F, G);
    case 1:
      G[1] = _[K], Sa(F, G), ns(F, rp), bc(F, 31), ns(F, ip), Sa(T, F)
  }
  return Sa(T, x), Sa(s, x), Fo(T, s), Fo(s, T), Fv(T), Fv(s), Fo(T, s), Fo(s, T), ("00000000" + (T[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (T[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (s[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (s[1] >>> 0).toString(16)).slice(-8)
}

function gT(y) {
  var l;
  return _m({
    name: y.name,
    message: y.message,
    stack: (l = y.stack) === null || l === void 0 ? void 0 : l.split(`
`)
  }, y)
}

function _T(y) {
  return /^function\s.*?\{\s*\[native code]\s*}$/.test(String(y))
}

function vT(y) {
  return typeof y != "function"
}

function yT(y, l) {
  var _ = Qu(new Promise(function(x) {
    var k = Date.now();
    Dv(y.bind(null, l), function() {
      for (var z = [], T = 0; T < arguments.length; T++) z[T] = arguments[T];
      var s = Date.now() - k;
      if (!z[0]) return x(function() {
        return {
          error: z[1],
          duration: s
        }
      });
      var F = z[1];
      if (vT(F)) return x(function() {
        return {
          value: F,
          duration: s
        }
      });
      x(function() {
        return new Promise(function(Z) {
          var K = Date.now();
          Dv(F, function() {
            for (var G = [], re = 0; re < arguments.length; re++) G[re] = arguments[re];
            var he = s + Date.now() - K;
            if (!G[0]) return Z({
              error: G[1],
              duration: he
            });
            Z({
              value: G[1],
              duration: he
            })
          })
        })
      })
    })
  }));
  return function() {
    return _.then(function(k) {
      return k()
    })
  }
}

function xT(y, l, _, x) {
  var k = Object.keys(y).filter(function(T) {
      return lT(_, T)
    }),
    z = Qu(Rv(k, function(T) {
      return yT(y[T], l)
    }, x));
  return function() {
    return Rs(this, void 0, void 0, function() {
      var s, F, Z, K, G;
      return Fs(this, function(re) {
        switch (re.label) {
          case 0:
            return [4, z];
          case 1:
            return s = re.sent(), [4, Rv(s, function(he) {
              return Qu(he())
            }, x)];
          case 2:
            return F = re.sent(), [4, Promise.all(F)];
          case 3:
            for (Z = re.sent(), K = {}, G = 0; G < k.length; ++G) K[k[G]] = Z[G];
            return [2, K]
        }
      })
    })
  }
}

function J0() {
  var y = window,
    l = navigator;
  return zn(["MSCSSMatrix" in y, "msSetImmediate" in y, "msIndexedDB" in y, "msMaxTouchPoints" in l, "msPointerEnabled" in l]) >= 4
}

function bT() {
  var y = window,
    l = navigator;
  return zn(["msWriteProfilerMark" in y, "MSStream" in y, "msLaunchUri" in l, "msSaveBlob" in l]) >= 3 && !J0()
}

function Lh() {
  var y = window,
    l = navigator;
  return zn(["webkitPersistentStorage" in l, "webkitTemporaryStorage" in l, (l.vendor || "").indexOf("Google") === 0, "webkitResolveLocalFileSystemURL" in y, "BatteryManager" in y, "webkitMediaStream" in y, "webkitSpeechGrammar" in y]) >= 5
}

function Ss() {
  var y = window,
    l = navigator;
  return zn(["ApplePayError" in y, "CSSPrimitiveValue" in y, "Counter" in y, l.vendor.indexOf("Apple") === 0, "RGBColor" in y, "WebKitMediaKeys" in y]) >= 4
}

function fg() {
  var y = window,
    l = y.HTMLElement,
    _ = y.Document;
  return zn(["safari" in y, !("ongestureend" in y), !("TouchEvent" in y), !("orientation" in y), l && !("autocapitalize" in l.prototype), _ && "pointerLockElement" in _.prototype]) >= 4
}

function Dh() {
  var y = window;
  return _T(y.print) && String(y.browser) === "[object WebPageNamespace]"
}

function $0() {
  var y, l, _ = window;
  return zn(["buildID" in navigator, "MozAppearance" in ((l = (y = document.documentElement) === null || y === void 0 ? void 0 : y.style) !== null && l !== void 0 ? l : {}), "onmozfullscreenchange" in _, "mozInnerScreenX" in _, "CSSMozDocumentRule" in _, "CanvasCaptureMediaStream" in _]) >= 4
}

function wT() {
  var y = window;
  return zn([!("MediaSettingsRange" in y), "RTCEncodedAudioFrame" in y, "" + y.Intl == "[object Intl]", "" + y.Reflect == "[object Reflect]"]) >= 3
}

function TT() {
  var y = window,
    l = y.URLPattern;
  return zn(["union" in Set.prototype, "Iterator" in y, l && "hasRegExpGroups" in l.prototype, "RGB8" in WebGLRenderingContext.prototype]) >= 3
}

function ST() {
  var y = window;
  return zn(["DOMRectList" in y, "RTCPeerConnectionIceEvent" in y, "SVGGeometryElement" in y, "ontransitioncancel" in y]) >= 3
}

function Rh() {
  var y = window,
    l = navigator,
    _ = y.CSS,
    x = y.HTMLButtonElement;
  return zn([!("getStorageUpdates" in l), x && "popover" in x.prototype, "CSSCounterStyleRule" in y, _.supports("font-size-adjust: ex-height 0.5"), _.supports("text-transform: full-width")]) >= 4
}

function PT() {
  if (navigator.platform === "iPad") return !0;
  var y = screen,
    l = y.width / y.height;
  return zn(["MediaSource" in window, !!Element.prototype.webkitRequestFullscreen, l > .65 && l < 1.53]) >= 2
}

function IT() {
  var y = document;
  return y.fullscreenElement || y.msFullscreenElement || y.mozFullScreenElement || y.webkitFullscreenElement || null
}

function MT() {
  var y = document;
  return (y.exitFullscreen || y.msExitFullscreen || y.mozCancelFullScreen || y.webkitExitFullscreen).call(y)
}

function mg() {
  var y = Lh(),
    l = $0(),
    _ = window,
    x = navigator,
    k = "connection";
  return y ? zn([!("SharedWorker" in _), x[k] && "ontypechange" in x[k], !("sinkId" in new Audio)]) >= 2 : l ? zn(["onorientationchange" in _, "orientation" in _, /android/i.test(x.appVersion)]) >= 2 : !1
}

function CT() {
  var y = navigator,
    l = window,
    _ = Audio.prototype,
    x = l.visualViewport;
  return zn(["srLatency" in _, "srChannelCount" in _, "devicePosture" in y, x && "segments" in x, "getTextInformation" in Image.prototype]) >= 3
}

function AT() {
  return ET() ? -4 : kT()
}

function kT() {
  var y = window,
    l = y.OfflineAudioContext || y.webkitOfflineAudioContext;
  if (!l) return -2;
  if (zT()) return -1;
  var _ = 4500,
    x = 5e3,
    k = new l(1, x, 44100),
    z = k.createOscillator();
  z.type = "triangle", z.frequency.value = 1e4;
  var T = k.createDynamicsCompressor();
  T.threshold.value = -50, T.knee.value = 40, T.ratio.value = 12, T.attack.value = 0, T.release.value = .25, z.connect(T), T.connect(k.destination), z.start(0);
  var s = LT(k),
    F = s[0],
    Z = s[1],
    K = Qu(F.then(function(G) {
      return DT(G.getChannelData(0).subarray(_))
    }, function(G) {
      if (G.name === "timeout" || G.name === "suspended") return -3;
      throw G
    }));
  return function() {
    return Z(), K
  }
}

function zT() {
  return Ss() && !fg() && !ST()
}

function ET() {
  return Ss() && Rh() && Dh() || Lh() && CT() && TT()
}

function LT(y) {
  var l = 3,
    _ = 500,
    x = 500,
    k = 5e3,
    z = function() {},
    T = new Promise(function(s, F) {
      var Z = !1,
        K = 0,
        G = 0;
      y.oncomplete = function(me) {
        return s(me.renderedBuffer)
      };
      var re = function() {
          setTimeout(function() {
            return F(Ov("timeout"))
          }, Math.min(x, G + k - Date.now()))
        },
        he = function() {
          try {
            var me = y.startRendering();
            switch (Y0(me) && Qu(me), y.state) {
              case "running":
                G = Date.now(), Z && re();
                break;
              case "suspended":
                document.hidden || K++, Z && K >= l ? F(Ov("suspended")) : setTimeout(he, _);
                break
            }
          } catch (q) {
            F(q)
          }
        };
      he(), z = function() {
        Z || (Z = !0, G > 0 && re())
      }
    });
  return [T, z]
}

function DT(y) {
  for (var l = 0, _ = 0; _ < y.length; ++_) l += Math.abs(y[_]);
  return l
}

function Ov(y) {
  var l = new Error(y);
  return l.name = y, l
}

function Q0(y, l, _) {
  var x, k, z;
  return _ === void 0 && (_ = 50), Rs(this, void 0, void 0, function() {
    var T, s;
    return Fs(this, function(F) {
      switch (F.label) {
        case 0:
          T = document, F.label = 1;
        case 1:
          return T.body ? [3, 3] : [4, Mp(_)];
        case 2:
          return F.sent(), [3, 1];
        case 3:
          s = T.createElement("iframe"), F.label = 4;
        case 4:
          return F.trys.push([4, , 10, 11]), [4, new Promise(function(Z, K) {
            var G = !1,
              re = function() {
                G = !0, Z()
              },
              he = function(ye) {
                G = !0, K(ye)
              };
            s.onload = re, s.onerror = he;
            var me = s.style;
            me.setProperty("display", "block", "important"), me.position = "absolute", me.top = "0", me.left = "0", me.visibility = "hidden", l && "srcdoc" in s ? s.srcdoc = l : s.src = "about:blank", T.body.appendChild(s);
            var q = function() {
              var ye, be;
              G || (((be = (ye = s.contentWindow) === null || ye === void 0 ? void 0 : ye.document) === null || be === void 0 ? void 0 : be.readyState) === "complete" ? re() : setTimeout(q, 10))
            };
            q()
          })];
        case 5:
          F.sent(), F.label = 6;
        case 6:
          return !((k = (x = s.contentWindow) === null || x === void 0 ? void 0 : x.document) === null || k === void 0) && k.body ? [3, 8] : [4, Mp(_)];
        case 7:
          return F.sent(), [3, 6];
        case 8:
          return [4, y(s, s.contentWindow)];
        case 9:
          return [2, F.sent()];
        case 10:
          return (z = s.parentNode) === null || z === void 0 || z.removeChild(s), [7];
        case 11:
          return [2]
      }
    })
  })
}

function RT(y) {
  for (var l = cT(y), _ = l[0], x = l[1], k = document.createElement(_ ?? "div"), z = 0, T = Object.keys(x); z < T.length; z++) {
    var s = T[z],
      F = x[s].join(" ");
    s === "style" ? FT(k.style, F) : k.setAttribute(s, F)
  }
  return k
}

function FT(y, l) {
  for (var _ = 0, x = l.split(";"); _ < x.length; _++) {
    var k = x[_],
      z = /^\s*([\w-]+)\s*:\s*(.+?)(\s*!([\w-]+))?\s*$/.exec(k);
    if (z) {
      var T = z[1],
        s = z[2],
        F = z[4];
      y.setProperty(T, s, F || "")
    }
  }
}

function BT() {
  for (var y = window;;) {
    var l = y.parent;
    if (!l || l === y) return !1;
    try {
      if (l.location.origin !== y.location.origin) return !0
    } catch (_) {
      if (_ instanceof Error && _.name === "SecurityError") return !0;
      throw _
    }
    y = l
  }
}
var OT = "mmMwWLliI0O&1",
  jT = "48px",
  wc = ["monospace", "sans-serif", "serif"],
  jv = ["sans-serif-thin", "ARNO PRO", "Agency FB", "Arabic Typesetting", "Arial Unicode MS", "AvantGarde Bk BT", "BankGothic Md BT", "Batang", "Bitstream Vera Sans Mono", "Calibri", "Century", "Century Gothic", "Clarendon", "EUROSTILE", "Franklin Gothic", "Futura Bk BT", "Futura Md BT", "GOTHAM", "Gill Sans", "HELV", "Haettenschweiler", "Helvetica Neue", "Humanst521 BT", "Leelawadee", "Letter Gothic", "Levenim MT", "Lucida Bright", "Lucida Sans", "Menlo", "MS Mincho", "MS Outlook", "MS Reference Specialty", "MS UI Gothic", "MT Extra", "MYRIAD PRO", "Marlett", "Meiryo UI", "Microsoft Uighur", "Minion Pro", "Monotype Corsiva", "PMingLiU", "Pristina", "SCRIPTINA", "Segoe UI Light", "Serifa", "SimHei", "Small Fonts", "Staccato222 BT", "TRAJAN PRO", "Univers CE 55 Medium", "Vrinda", "ZWAdobeF"];

function qT() {
  var y = this;
  return Q0(function(l, _) {
    var x = _.document;
    return Rs(y, void 0, void 0, function() {
      var k, z, T, s, F, Z, K, G, re, he, me, q;
      return Fs(this, function(ye) {
        for (k = x.body, k.style.fontSize = jT, z = x.createElement("div"), z.style.setProperty("visibility", "hidden", "important"), T = {}, s = {}, F = function(be) {
            var qe = x.createElement("span"),
              xe = qe.style;
            return xe.position = "absolute", xe.top = "0", xe.left = "0", xe.fontFamily = be, qe.textContent = OT, z.appendChild(qe), qe
          }, Z = function(be, qe) {
            return F("'".concat(be, "',").concat(qe))
          }, K = function() {
            return wc.map(F)
          }, G = function() {
            for (var be = {}, qe = function(ze) {
                be[ze] = wc.map(function(Se) {
                  return Z(ze, Se)
                })
              }, xe = 0, Ye = jv; xe < Ye.length; xe++) {
              var We = Ye[xe];
              qe(We)
            }
            return be
          }, re = function(be) {
            return wc.some(function(qe, xe) {
              return be[xe].offsetWidth !== T[qe] || be[xe].offsetHeight !== s[qe]
            })
          }, he = K(), me = G(), k.appendChild(z), q = 0; q < wc.length; q++) T[wc[q]] = he[q].offsetWidth, s[wc[q]] = he[q].offsetHeight;
        return [2, jv.filter(function(be) {
          return re(me[be])
        })]
      })
    })
  })
}

function NT() {
  var y = navigator.plugins;
  if (y) {
    for (var l = [], _ = 0; _ < y.length; ++_) {
      var x = y[_];
      if (x) {
        for (var k = [], z = 0; z < x.length; ++z) {
          var T = x[z];
          k.push({
            type: T.type,
            suffixes: T.suffixes
          })
        }
        l.push({
          name: x.name,
          description: x.description,
          mimeTypes: k
        })
      }
    }
    return l
  }
}

function VT() {
  return UT(KT())
}

function UT(y) {
  var l, _ = !1,
    x, k, z = ZT(),
    T = z[0],
    s = z[1];
  return GT(T, s) ? (_ = WT(s), y ? x = k = "skipped" : (l = HT(T, s), x = l[0], k = l[1])) : x = k = "unsupported", {
    winding: _,
    geometry: x,
    text: k
  }
}

function ZT() {
  var y = document.createElement("canvas");
  return y.width = 1, y.height = 1, [y, y.getContext("2d")]
}

function GT(y, l) {
  return !!(l && y.toDataURL)
}

function WT(y) {
  return y.rect(0, 0, 10, 10), y.rect(2, 2, 6, 6), !y.isPointInPath(5, 5, "evenodd")
}

function HT(y, l) {
  XT(y, l);
  var _ = em(y),
    x = em(y);
  if (_ !== x) return ["unstable", "unstable"];
  YT(y, l);
  var k = em(y);
  return [k, _]
}

function XT(y, l) {
  y.width = 240, y.height = 60, l.textBaseline = "alphabetic", l.fillStyle = "#f60", l.fillRect(100, 1, 62, 20), l.fillStyle = "#069", l.font = '11pt "Times New Roman"';
  var _ = "Cwm fjordbank gly ".concat("");
  l.fillText(_, 2, 15), l.fillStyle = "rgba(102, 204, 0, 0.2)", l.font = "18pt Arial", l.fillText(_, 4, 45)
}

function YT(y, l) {
  y.width = 122, y.height = 110, l.globalCompositeOperation = "multiply";
  for (var _ = 0, x = [
      ["#f2f", 40, 40],
      ["#2ff", 80, 40],
      ["#ff2", 60, 80]
    ]; _ < x.length; _++) {
    var k = x[_],
      z = k[0],
      T = k[1],
      s = k[2];
    l.fillStyle = z, l.beginPath(), l.arc(T, s, 40, 0, Math.PI * 2, !0), l.closePath(), l.fill()
  }
  l.fillStyle = "#f9c", l.arc(60, 60, 60, 0, Math.PI * 2, !0), l.arc(60, 60, 20, 0, Math.PI * 2, !0), l.fill("evenodd")
}

function em(y) {
  return y.toDataURL()
}

function KT() {
  return Ss() && Rh() && Dh()
}

function JT() {
  var y = navigator,
    l = 0,
    _;
  y.maxTouchPoints !== void 0 ? l = pg(y.maxTouchPoints) : y.msMaxTouchPoints !== void 0 && (l = y.msMaxTouchPoints);
  try {
    document.createEvent("TouchEvent"), _ = !0
  } catch {
    _ = !1
  }
  var x = "ontouchstart" in window;
  return {
    maxTouchPoints: l,
    touchEvent: _,
    touchStart: x
  }
}

function $T() {
  return navigator.oscpu
}

function QT() {
  var y = navigator,
    l = [],
    _ = y.language || y.userLanguage || y.browserLanguage || y.systemLanguage;
  if (_ !== void 0 && l.push([_]), Array.isArray(y.languages)) Lh() && wT() || l.push(y.languages);
  else if (typeof y.languages == "string") {
    var x = y.languages;
    x && l.push(x.split(","))
  }
  return l
}

function e4() {
  return window.screen.colorDepth
}

function t4() {
  return oo(ws(navigator.deviceMemory), void 0)
}

function r4() {
  if (!(Ss() && Rh() && Dh())) return i4()
}

function i4() {
  var y = screen,
    l = function(x) {
      return oo(pg(x), null)
    },
    _ = [l(y.width), l(y.height)];
  return _.sort().reverse(), _
}
var a4 = 2500,
  n4 = 10,
  dp, tm;

function s4() {
  if (tm === void 0) {
    var y = function() {
      var l = vm();
      ym(l) ? tm = setTimeout(y, a4) : (dp = l, tm = void 0)
    };
    y()
  }
}

function o4() {
  var y = this;
  return s4(),
    function() {
      return Rs(y, void 0, void 0, function() {
        var l;
        return Fs(this, function(_) {
          switch (_.label) {
            case 0:
              return l = vm(), ym(l) ? dp ? [2, H0([], dp, !0)] : IT() ? [4, MT()] : [3, 2] : [3, 2];
            case 1:
              _.sent(), l = vm(), _.label = 2;
            case 2:
              return ym(l) || (dp = l), [2, l]
          }
        })
      })
    }
}

function l4() {
  var y = this;
  if (Ss() && Rh() && Dh()) return function() {
    return Promise.resolve(void 0)
  };
  var l = o4();
  return function() {
    return Rs(y, void 0, void 0, function() {
      var _, x;
      return Fs(this, function(k) {
        switch (k.label) {
          case 0:
            return [4, l()];
          case 1:
            return _ = k.sent(), x = function(z) {
              return z === null ? null : K0(z, n4)
            }, [2, [x(_[0]), x(_[1]), x(_[2]), x(_[3])]]
        }
      })
    })
  }
}

function vm() {
  var y = screen;
  return [oo(ws(y.availTop), null), oo(ws(y.width) - ws(y.availWidth) - oo(ws(y.availLeft), 0), null), oo(ws(y.height) - ws(y.availHeight) - oo(ws(y.availTop), 0), null), oo(ws(y.availLeft), null)]
}

function ym(y) {
  for (var l = 0; l < 4; ++l)
    if (y[l]) return !1;
  return !0
}

function c4() {
  return oo(pg(navigator.hardwareConcurrency), void 0)
}

function u4() {
  var y, l = (y = window.Intl) === null || y === void 0 ? void 0 : y.DateTimeFormat;
  if (l) {
    var _ = new l().resolvedOptions().timeZone;
    if (_) return _
  }
  var x = -h4();
  return "UTC".concat(x >= 0 ? "+" : "").concat(x)
}

function h4() {
  var y = new Date().getFullYear();
  return Math.max(ws(new Date(y, 0, 1).getTimezoneOffset()), ws(new Date(y, 6, 1).getTimezoneOffset()))
}

function d4() {
  try {
    return !!window.sessionStorage
  } catch {
    return !0
  }
}

function p4() {
  try {
    return !!window.localStorage
  } catch {
    return !0
  }
}

function f4() {
  if (!(J0() || bT())) try {
    return !!window.indexedDB
  } catch {
    return !0
  }
}

function m4() {
  return !!window.openDatabase
}

function g4() {
  return navigator.cpuClass
}

function _4() {
  var y = navigator.platform;
  return y === "MacIntel" && Ss() && !fg() ? PT() ? "iPad" : "iPhone" : y
}

function v4() {
  return navigator.vendor || ""
}

function y4() {
  for (var y = [], l = 0, _ = ["chrome", "safari", "__crWeb", "__gCrWeb", "yandex", "__yb", "__ybro", "__firefox__", "__edgeTrackingPreventionStatistics", "webkit", "oprt", "samsungAr", "ucweb", "UCShellJava", "puffinDevice"]; l < _.length; l++) {
    var x = _[l],
      k = window[x];
    k && typeof k == "object" && y.push(x)
  }
  return y.sort()
}

function x4() {
  var y = document;
  try {
    y.cookie = "cookietest=1; SameSite=Strict;";
    var l = y.cookie.indexOf("cookietest=") !== -1;
    return y.cookie = "cookietest=1; SameSite=Strict; expires=Thu, 01-Jan-1970 00:00:01 GMT", l
  } catch {
    return !1
  }
}

function b4() {
  var y = atob;
  return {
    abpIndo: ["#Iklan-Melayang", "#Kolom-Iklan-728", "#SidebarIklan-wrapper", '[title="ALIENBOLA" i]', y("I0JveC1CYW5uZXItYWRz")],
    abpvn: [".quangcao", "#mobileCatfish", y("LmNsb3NlLWFkcw=="), '[id^="bn_bottom_fixed_"]', "#pmadv"],
    adBlockFinland: [".mainostila", y("LnNwb25zb3JpdA=="), ".ylamainos", y("YVtocmVmKj0iL2NsaWNrdGhyZ2guYXNwPyJd"), y("YVtocmVmXj0iaHR0cHM6Ly9hcHAucmVhZHBlYWsuY29tL2FkcyJd")],
    adBlockPersian: ["#navbar_notice_50", ".kadr", 'TABLE[width="140px"]', "#divAgahi", y("YVtocmVmXj0iaHR0cDovL2cxLnYuZndtcm0ubmV0L2FkLyJd")],
    adBlockWarningRemoval: ["#adblock-honeypot", ".adblocker-root", ".wp_adblock_detect", y("LmhlYWRlci1ibG9ja2VkLWFk"), y("I2FkX2Jsb2NrZXI=")],
    adGuardAnnoyances: [".hs-sosyal", "#cookieconsentdiv", 'div[class^="app_gdpr"]', ".as-oil", '[data-cypress="soft-push-notification-modal"]'],
    adGuardBase: [".BetterJsPopOverlay", y("I2FkXzMwMFgyNTA="), y("I2Jhbm5lcmZsb2F0MjI="), y("I2NhbXBhaWduLWJhbm5lcg=="), y("I0FkLUNvbnRlbnQ=")],
    adGuardChinese: [y("LlppX2FkX2FfSA=="), y("YVtocmVmKj0iLmh0aGJldDM0LmNvbSJd"), "#widget-quan", y("YVtocmVmKj0iLzg0OTkyMDIwLnh5eiJd"), y("YVtocmVmKj0iLjE5NTZobC5jb20vIl0=")],
    adGuardFrench: ["#pavePub", y("LmFkLWRlc2t0b3AtcmVjdGFuZ2xl"), ".mobile_adhesion", ".widgetadv", y("LmFkc19iYW4=")],
    adGuardGerman: ['aside[data-portal-id="leaderboard"]'],
    adGuardJapanese: ["#kauli_yad_1", y("YVtocmVmXj0iaHR0cDovL2FkMi50cmFmZmljZ2F0ZS5uZXQvIl0="), y("Ll9wb3BJbl9pbmZpbml0ZV9hZA=="), y("LmFkZ29vZ2xl"), y("Ll9faXNib29zdFJldHVybkFk")],
    adGuardMobile: [y("YW1wLWF1dG8tYWRz"), y("LmFtcF9hZA=="), 'amp-embed[type="24smi"]', "#mgid_iframe1", y("I2FkX2ludmlld19hcmVh")],
    adGuardRussian: [y("YVtocmVmXj0iaHR0cHM6Ly9hZC5sZXRtZWFkcy5jb20vIl0="), y("LnJlY2xhbWE="), 'div[id^="smi2adblock"]', y("ZGl2W2lkXj0iQWRGb3hfYmFubmVyXyJd"), "#psyduckpockeball"],
    adGuardSocial: [y("YVtocmVmXj0iLy93d3cuc3R1bWJsZXVwb24uY29tL3N1Ym1pdD91cmw9Il0="), y("YVtocmVmXj0iLy90ZWxlZ3JhbS5tZS9zaGFyZS91cmw/Il0="), ".etsy-tweet", "#inlineShare", ".popup-social"],
    adGuardSpanishPortuguese: ["#barraPublicidade", "#Publicidade", "#publiEspecial", "#queTooltip", ".cnt-publi"],
    adGuardTrackingProtection: ["#qoo-counter", y("YVtocmVmXj0iaHR0cDovL2NsaWNrLmhvdGxvZy5ydS8iXQ=="), y("YVtocmVmXj0iaHR0cDovL2hpdGNvdW50ZXIucnUvdG9wL3N0YXQucGhwIl0="), y("YVtocmVmXj0iaHR0cDovL3RvcC5tYWlsLnJ1L2p1bXAiXQ=="), "#top100counter"],
    adGuardTurkish: ["#backkapat", y("I3Jla2xhbWk="), y("YVtocmVmXj0iaHR0cDovL2Fkc2Vydi5vbnRlay5jb20udHIvIl0="), y("YVtocmVmXj0iaHR0cDovL2l6bGVuemkuY29tL2NhbXBhaWduLyJd"), y("YVtocmVmXj0iaHR0cDovL3d3dy5pbnN0YWxsYWRzLm5ldC8iXQ==")],
    bulgarian: [y("dGQjZnJlZW5ldF90YWJsZV9hZHM="), "#ea_intext_div", ".lapni-pop-over", "#xenium_hot_offers"],
    easyList: [".yb-floorad", y("LndpZGdldF9wb19hZHNfd2lkZ2V0"), y("LnRyYWZmaWNqdW5reS1hZA=="), ".textad_headline", y("LnNwb25zb3JlZC10ZXh0LWxpbmtz")],
    easyListChina: [y("LmFwcGd1aWRlLXdyYXBbb25jbGljayo9ImJjZWJvcy5jb20iXQ=="), y("LmZyb250cGFnZUFkdk0="), "#taotaole", "#aafoot.top_box", ".cfa_popup"],
    easyListCookie: [".ezmob-footer", ".cc-CookieWarning", "[data-cookie-number]", y("LmF3LWNvb2tpZS1iYW5uZXI="), ".sygnal24-gdpr-modal-wrap"],
    easyListCzechSlovak: ["#onlajny-stickers", y("I3Jla2xhbW5pLWJveA=="), y("LnJla2xhbWEtbWVnYWJvYXJk"), ".sklik", y("W2lkXj0ic2tsaWtSZWtsYW1hIl0=")],
    easyListDutch: [y("I2FkdmVydGVudGll"), y("I3ZpcEFkbWFya3RCYW5uZXJCbG9jaw=="), ".adstekst", y("YVtocmVmXj0iaHR0cHM6Ly94bHR1YmUubmwvY2xpY2svIl0="), "#semilo-lrectangle"],
    easyListGermany: ["#SSpotIMPopSlider", y("LnNwb25zb3JsaW5rZ3J1ZW4="), y("I3dlcmJ1bmdza3k="), y("I3Jla2xhbWUtcmVjaHRzLW1pdHRl"), y("YVtocmVmXj0iaHR0cHM6Ly9iZDc0Mi5jb20vIl0=")],
    easyListItaly: [y("LmJveF9hZHZfYW5udW5jaQ=="), ".sb-box-pubbliredazionale", y("YVtocmVmXj0iaHR0cDovL2FmZmlsaWF6aW9uaWFkcy5zbmFpLml0LyJd"), y("YVtocmVmXj0iaHR0cHM6Ly9hZHNlcnZlci5odG1sLml0LyJd"), y("YVtocmVmXj0iaHR0cHM6Ly9hZmZpbGlhemlvbmlhZHMuc25haS5pdC8iXQ==")],
    easyListLithuania: [y("LnJla2xhbW9zX3RhcnBhcw=="), y("LnJla2xhbW9zX251b3JvZG9z"), y("aW1nW2FsdD0iUmVrbGFtaW5pcyBza3lkZWxpcyJd"), y("aW1nW2FsdD0iRGVkaWt1b3RpLmx0IHNlcnZlcmlhaSJd"), y("aW1nW2FsdD0iSG9zdGluZ2FzIFNlcnZlcmlhaS5sdCJd")],
    estonian: [y("QVtocmVmKj0iaHR0cDovL3BheTRyZXN1bHRzMjQuZXUiXQ==")],
    fanboyAnnoyances: ["#ac-lre-player", ".navigate-to-top", "#subscribe_popup", ".newsletter_holder", "#back-top"],
    fanboyAntiFacebook: [".util-bar-module-firefly-visible"],
    fanboyEnhancedTrackers: [".open.pushModal", "#issuem-leaky-paywall-articles-zero-remaining-nag", "#sovrn_container", 'div[class$="-hide"][zoompage-fontsize][style="display: block;"]', ".BlockNag__Card"],
    fanboySocial: ["#FollowUs", "#meteored_share", "#social_follow", ".article-sharer", ".community__social-desc"],
    frellwitSwedish: [y("YVtocmVmKj0iY2FzaW5vcHJvLnNlIl1bdGFyZ2V0PSJfYmxhbmsiXQ=="), y("YVtocmVmKj0iZG9rdG9yLXNlLm9uZWxpbmsubWUiXQ=="), "article.category-samarbete", y("ZGl2LmhvbGlkQWRz"), "ul.adsmodern"],
    greekAdBlock: [y("QVtocmVmKj0iYWRtYW4ub3RlbmV0LmdyL2NsaWNrPyJd"), y("QVtocmVmKj0iaHR0cDovL2F4aWFiYW5uZXJzLmV4b2R1cy5nci8iXQ=="), y("QVtocmVmKj0iaHR0cDovL2ludGVyYWN0aXZlLmZvcnRobmV0LmdyL2NsaWNrPyJd"), "DIV.agores300", "TABLE.advright"],
    hungarian: ["#cemp_doboz", ".optimonk-iframe-container", y("LmFkX19tYWlu"), y("W2NsYXNzKj0iR29vZ2xlQWRzIl0="), "#hirdetesek_box"],
    iDontCareAboutCookies: ['.alert-info[data-block-track*="CookieNotice"]', ".ModuleTemplateCookieIndicator", ".o--cookies--container", "#cookies-policy-sticky", "#stickyCookieBar"],
    icelandicAbp: [y("QVtocmVmXj0iL2ZyYW1ld29yay9yZXNvdXJjZXMvZm9ybXMvYWRzLmFzcHgiXQ==")],
    latvian: [y("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiAxMjBweDsgaGVpZ2h0OiA0MHB4OyBvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7Il0="), y("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiA4OHB4OyBoZWlnaHQ6IDMxcHg7IG92ZXJmbG93OiBoaWRkZW47IHBvc2l0aW9uOiByZWxhdGl2ZTsiXQ==")],
    listKr: [y("YVtocmVmKj0iLy9hZC5wbGFuYnBsdXMuY28ua3IvIl0="), y("I2xpdmVyZUFkV3JhcHBlcg=="), y("YVtocmVmKj0iLy9hZHYuaW1hZHJlcC5jby5rci8iXQ=="), y("aW5zLmZhc3R2aWV3LWFk"), ".revenue_unit_item.dable"],
    listeAr: [y("LmdlbWluaUxCMUFk"), ".right-and-left-sponsers", y("YVtocmVmKj0iLmFmbGFtLmluZm8iXQ=="), y("YVtocmVmKj0iYm9vcmFxLm9yZyJd"), y("YVtocmVmKj0iZHViaXp6bGUuY29tL2FyLz91dG1fc291cmNlPSJd")],
    listeFr: [y("YVtocmVmXj0iaHR0cDovL3Byb21vLnZhZG9yLmNvbS8iXQ=="), y("I2FkY29udGFpbmVyX3JlY2hlcmNoZQ=="), y("YVtocmVmKj0id2Vib3JhbWEuZnIvZmNnaS1iaW4vIl0="), ".site-pub-interstitiel", 'div[id^="crt-"][data-criteo-id]'],
    officialPolish: ["#ceneo-placeholder-ceneo-12", y("W2hyZWZePSJodHRwczovL2FmZi5zZW5kaHViLnBsLyJd"), y("YVtocmVmXj0iaHR0cDovL2Fkdm1hbmFnZXIudGVjaGZ1bi5wbC9yZWRpcmVjdC8iXQ=="), y("YVtocmVmXj0iaHR0cDovL3d3dy50cml6ZXIucGwvP3V0bV9zb3VyY2UiXQ=="), y("ZGl2I3NrYXBpZWNfYWQ=")],
    ro: [y("YVtocmVmXj0iLy9hZmZ0cmsuYWx0ZXgucm8vQ291bnRlci9DbGljayJd"), y("YVtocmVmXj0iaHR0cHM6Ly9ibGFja2ZyaWRheXNhbGVzLnJvL3Ryay9zaG9wLyJd"), y("YVtocmVmXj0iaHR0cHM6Ly9ldmVudC4ycGVyZm9ybWFudC5jb20vZXZlbnRzL2NsaWNrIl0="), y("YVtocmVmXj0iaHR0cHM6Ly9sLnByb2ZpdHNoYXJlLnJvLyJd"), 'a[href^="/url/"]'],
    ruAd: [y("YVtocmVmKj0iLy9mZWJyYXJlLnJ1LyJd"), y("YVtocmVmKj0iLy91dGltZy5ydS8iXQ=="), y("YVtocmVmKj0iOi8vY2hpa2lkaWtpLnJ1Il0="), "#pgeldiz", ".yandex-rtb-block"],
    thaiAds: ["a[href*=macau-uta-popup]", y("I2Fkcy1nb29nbGUtbWlkZGxlX3JlY3RhbmdsZS1ncm91cA=="), y("LmFkczMwMHM="), ".bumq", ".img-kosana"],
    webAnnoyancesUltralist: ["#mod-social-share-2", "#social-tools", y("LmN0cGwtZnVsbGJhbm5lcg=="), ".zergnet-recommend", ".yt.btn-link.btn-md.btn"]
  }
}

function w4(y) {
  var l = y === void 0 ? {} : y,
    _ = l.debug;
  return Rs(this, void 0, void 0, function() {
    var x, k, z, T, s, F;
    return Fs(this, function(Z) {
      switch (Z.label) {
        case 0:
          return T4() ? (x = b4(), k = Object.keys(x), z = (F = []).concat.apply(F, k.map(function(K) {
            return x[K]
          })), [4, S4(z)]) : [2, void 0];
        case 1:
          return T = Z.sent(), _ && P4(x, T), s = k.filter(function(K) {
            var G = x[K],
              re = zn(G.map(function(he) {
                return T[he]
              }));
            return re > G.length * .6
          }), s.sort(), [2, s]
      }
    })
  })
}

function T4() {
  return Ss() || mg()
}

function S4(y) {
  var l;
  return Rs(this, void 0, void 0, function() {
    var _, x, k, z, F, T, s, F;
    return Fs(this, function(Z) {
      switch (Z.label) {
        case 0:
          for (_ = document, x = _.createElement("div"), k = new Array(y.length), z = {}, qv(x), F = 0; F < y.length; ++F) T = RT(y[F]), T.tagName === "DIALOG" && T.show(), s = _.createElement("div"), qv(s), s.appendChild(T), x.appendChild(s), k[F] = T;
          Z.label = 1;
        case 1:
          return _.body ? [3, 3] : [4, Mp(50)];
        case 2:
          return Z.sent(), [3, 1];
        case 3:
          _.body.appendChild(x);
          try {
            for (F = 0; F < y.length; ++F) k[F].offsetParent || (z[y[F]] = !0)
          } finally {
            (l = x.parentNode) === null || l === void 0 || l.removeChild(x)
          }
          return [2, z]
      }
    })
  })
}

function qv(y) {
  y.style.setProperty("visibility", "hidden", "important"), y.style.setProperty("display", "block", "important")
}

function P4(y, l) {
  for (var _ = "DOM blockers debug:\n```", x = 0, k = Object.keys(y); x < k.length; x++) {
    var z = k[x];
    _ += `
`.concat(z, ":");
    for (var T = 0, s = y[z]; T < s.length; T++) {
      var F = s[T];
      _ += `
  `.concat(l[F] ? "" : "", " ").concat(F)
    }
  }
  console.log("".concat(_, "\n```"))
}

function I4() {
  for (var y = 0, l = ["rec2020", "p3", "srgb"]; y < l.length; y++) {
    var _ = l[y];
    if (matchMedia("(color-gamut: ".concat(_, ")")).matches) return _
  }
}

function M4() {
  if (Nv("inverted")) return !0;
  if (Nv("none")) return !1
}

function Nv(y) {
  return matchMedia("(inverted-colors: ".concat(y, ")")).matches
}

function C4() {
  if (Vv("active")) return !0;
  if (Vv("none")) return !1
}

function Vv(y) {
  return matchMedia("(forced-colors: ".concat(y, ")")).matches
}
var A4 = 100;

function k4() {
  if (matchMedia("(min-monochrome: 0)").matches) {
    for (var y = 0; y <= A4; ++y)
      if (matchMedia("(max-monochrome: ".concat(y, ")")).matches) return y;
    throw new Error("Too high value")
  }
}

function z4() {
  if (Tc("no-preference")) return 0;
  if (Tc("high") || Tc("more")) return 1;
  if (Tc("low") || Tc("less")) return -1;
  if (Tc("forced")) return 10
}

function Tc(y) {
  return matchMedia("(prefers-contrast: ".concat(y, ")")).matches
}

function E4() {
  if (Uv("reduce")) return !0;
  if (Uv("no-preference")) return !1
}

function Uv(y) {
  return matchMedia("(prefers-reduced-motion: ".concat(y, ")")).matches
}

function L4() {
  if (Zv("reduce")) return !0;
  if (Zv("no-preference")) return !1
}

function Zv(y) {
  return matchMedia("(prefers-reduced-transparency: ".concat(y, ")")).matches
}

function D4() {
  if (Gv("high")) return !0;
  if (Gv("standard")) return !1
}

function Gv(y) {
  return matchMedia("(dynamic-range: ".concat(y, ")")).matches
}
var ia = Math,
  Cn = function() {
    return 0
  };

function R4() {
  var y = ia.acos || Cn,
    l = ia.acosh || Cn,
    _ = ia.asin || Cn,
    x = ia.asinh || Cn,
    k = ia.atanh || Cn,
    z = ia.atan || Cn,
    T = ia.sin || Cn,
    s = ia.sinh || Cn,
    F = ia.cos || Cn,
    Z = ia.cosh || Cn,
    K = ia.tan || Cn,
    G = ia.tanh || Cn,
    re = ia.exp || Cn,
    he = ia.expm1 || Cn,
    me = ia.log1p || Cn,
    q = function(Pe) {
      return ia.pow(ia.PI, Pe)
    },
    ye = function(Pe) {
      return ia.log(Pe + ia.sqrt(Pe * Pe - 1))
    },
    be = function(Pe) {
      return ia.log(Pe + ia.sqrt(Pe * Pe + 1))
    },
    qe = function(Pe) {
      return ia.log((1 + Pe) / (1 - Pe)) / 2
    },
    xe = function(Pe) {
      return ia.exp(Pe) - 1 / ia.exp(Pe) / 2
    },
    Ye = function(Pe) {
      return (ia.exp(Pe) + 1 / ia.exp(Pe)) / 2
    },
    We = function(Pe) {
      return ia.exp(Pe) - 1
    },
    ze = function(Pe) {
      return (ia.exp(2 * Pe) - 1) / (ia.exp(2 * Pe) + 1)
    },
    Se = function(Pe) {
      return ia.log(1 + Pe)
    };
  return {
    acos: y(.12312423423423424),
    acosh: l(1e308),
    acoshPf: ye(1e154),
    asin: _(.12312423423423424),
    asinh: x(1),
    asinhPf: be(1),
    atanh: k(.5),
    atanhPf: qe(.5),
    atan: z(.5),
    sin: T(-1e300),
    sinh: s(1),
    sinhPf: xe(1),
    cos: F(10.000000000123),
    cosh: Z(1),
    coshPf: Ye(1),
    tan: K(-1e300),
    tanh: G(1),
    tanhPf: ze(1),
    exp: re(1),
    expm1: he(1),
    expm1Pf: We(1),
    log1p: me(10),
    log1pPf: Se(10),
    powPI: q(-100)
  }
}
var F4 = "mmMwWLliI0fiflO&1",
  rm = {
    default: [],
    apple: [{
      font: "-apple-system-body"
    }],
    serif: [{
      fontFamily: "serif"
    }],
    sans: [{
      fontFamily: "sans-serif"
    }],
    mono: [{
      fontFamily: "monospace"
    }],
    min: [{
      fontSize: "1px"
    }],
    system: [{
      fontFamily: "system-ui"
    }]
  };

function B4() {
  return O4(function(y, l) {
    for (var _ = {}, x = {}, k = 0, z = Object.keys(rm); k < z.length; k++) {
      var T = z[k],
        s = rm[T],
        F = s[0],
        Z = F === void 0 ? {} : F,
        K = s[1],
        G = K === void 0 ? F4 : K,
        re = y.createElement("span");
      re.textContent = G, re.style.whiteSpace = "nowrap";
      for (var he = 0, me = Object.keys(Z); he < me.length; he++) {
        var q = me[he],
          ye = Z[q];
        ye !== void 0 && (re.style[q] = ye)
      }
      _[T] = re, l.append(y.createElement("br"), re)
    }
    for (var be = 0, qe = Object.keys(rm); be < qe.length; be++) {
      var T = qe[be];
      x[T] = _[T].getBoundingClientRect().width
    }
    return x
  })
}

function O4(y, l) {
  return l === void 0 && (l = 4e3), Q0(function(_, x) {
    var k = x.document,
      z = k.body,
      T = z.style;
    T.width = "".concat(l, "px"), T.webkitTextSizeAdjust = T.textSizeAdjust = "none", Lh() ? z.style.zoom = "".concat(1 / x.devicePixelRatio) : Ss() && (z.style.zoom = "reset");
    var s = k.createElement("div");
    return s.textContent = H0([], Array(l / 20 << 0), !0).map(function() {
      return "word"
    }).join(" "), z.appendChild(s), y(k, z)
  }, '<!doctype html><html><head><meta name="viewport" content="width=device-width, initial-scale=1">')
}

function j4() {
  return navigator.pdfViewerEnabled
}

function q4() {
  var y = new Float32Array(1),
    l = new Uint8Array(y.buffer);
  return y[0] = 1 / 0, y[0] = y[0] - y[0], l[3]
}

function N4() {
  var y = window.ApplePaySession;
  if (typeof(y == null ? void 0 : y.canMakePayments) != "function") return -1;
  if (V4()) return -3;
  try {
    return y.canMakePayments() ? 1 : 0
  } catch (l) {
    return U4(l)
  }
}
var V4 = BT;

function U4(y) {
  if (y instanceof Error && y.name === "InvalidAccessError" && /\bfrom\b.*\binsecure\b/i.test(y.message)) return -2;
  throw y
}

function Z4() {
  var y, l = document.createElement("a"),
    _ = (y = l.attributionSourceId) !== null && y !== void 0 ? y : l.attributionsourceid;
  return _ === void 0 ? void 0 : String(_)
}
var ey = -1,
  ty = -2,
  G4 = new Set([10752, 2849, 2884, 2885, 2886, 2928, 2929, 2930, 2931, 2932, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2978, 3024, 3042, 3088, 3089, 3106, 3107, 32773, 32777, 32777, 32823, 32824, 32936, 32937, 32938, 32939, 32968, 32969, 32970, 32971, 3317, 33170, 3333, 3379, 3386, 33901, 33902, 34016, 34024, 34076, 3408, 3410, 3411, 3412, 3413, 3414, 3415, 34467, 34816, 34817, 34818, 34819, 34877, 34921, 34930, 35660, 35661, 35724, 35738, 35739, 36003, 36004, 36005, 36347, 36348, 36349, 37440, 37441, 37443, 7936, 7937, 7938]),
  W4 = new Set([34047, 35723, 36063, 34852, 34853, 34854, 34229, 36392, 36795, 38449]),
  H4 = ["FRAGMENT_SHADER", "VERTEX_SHADER"],
  X4 = ["LOW_FLOAT", "MEDIUM_FLOAT", "HIGH_FLOAT", "LOW_INT", "MEDIUM_INT", "HIGH_INT"],
  ry = "WEBGL_debug_renderer_info",
  Y4 = "WEBGL_polygon_mode";

function K4(y) {
  var l, _, x, k, z, T, s = y.cache,
    F = iy(s);
  if (!F) return ey;
  if (!ny(F)) return ty;
  var Z = ay() ? null : F.getExtension(ry);
  return {
    version: ((l = F.getParameter(F.VERSION)) === null || l === void 0 ? void 0 : l.toString()) || "",
    vendor: ((_ = F.getParameter(F.VENDOR)) === null || _ === void 0 ? void 0 : _.toString()) || "",
    vendorUnmasked: Z ? (x = F.getParameter(Z.UNMASKED_VENDOR_WEBGL)) === null || x === void 0 ? void 0 : x.toString() : "",
    renderer: ((k = F.getParameter(F.RENDERER)) === null || k === void 0 ? void 0 : k.toString()) || "",
    rendererUnmasked: Z ? (z = F.getParameter(Z.UNMASKED_RENDERER_WEBGL)) === null || z === void 0 ? void 0 : z.toString() : "",
    shadingLanguageVersion: ((T = F.getParameter(F.SHADING_LANGUAGE_VERSION)) === null || T === void 0 ? void 0 : T.toString()) || ""
  }
}

function J4(y) {
  var l = y.cache,
    _ = iy(l);
  if (!_) return ey;
  if (!ny(_)) return ty;
  var x = _.getSupportedExtensions(),
    k = _.getContextAttributes(),
    z = [],
    T = [],
    s = [],
    F = [],
    Z = [];
  if (k)
    for (var K = 0, G = Object.keys(k); K < G.length; K++) {
      var re = G[K];
      T.push("".concat(re, "=").concat(k[re]))
    }
  for (var he = Wv(_), me = 0, q = he; me < q.length; me++) {
    var ye = q[me],
      be = _[ye];
    s.push("".concat(ye, "=").concat(be).concat(G4.has(be) ? "=".concat(_.getParameter(be)) : ""))
  }
  if (x)
    for (var qe = 0, xe = x; qe < xe.length; qe++) {
      var Ye = xe[qe];
      if (!(Ye === ry && ay() || Ye === Y4 && eS())) {
        var We = _.getExtension(Ye);
        if (!We) {
          z.push(Ye);
          continue
        }
        for (var ze = 0, Se = Wv(We); ze < Se.length; ze++) {
          var ye = Se[ze],
            be = We[ye];
          F.push("".concat(ye, "=").concat(be).concat(W4.has(be) ? "=".concat(_.getParameter(be)) : ""))
        }
      }
    }
  for (var Pe = 0, Ae = H4; Pe < Ae.length; Pe++)
    for (var Me = Ae[Pe], Ee = 0, Qe = X4; Ee < Qe.length; Ee++) {
      var Ue = Qe[Ee],
        je = $4(_, Me, Ue);
      Z.push("".concat(Me, ".").concat(Ue, "=").concat(je.join(",")))
    }
  return F.sort(), s.sort(), {
    contextAttributes: T,
    parameters: s,
    shaderPrecisions: Z,
    extensions: x,
    extensionParameters: F,
    unsupportedExtensions: z
  }
}

function iy(y) {
  if (y.webgl) return y.webgl.context;
  var l = document.createElement("canvas"),
    _;
  l.addEventListener("webglCreateContextError", function() {
    return _ = void 0
  });
  for (var x = 0, k = ["webgl", "experimental-webgl"]; x < k.length; x++) {
    var z = k[x];
    try {
      _ = l.getContext(z)
    } catch {}
    if (_) break
  }
  return y.webgl = {
    context: _
  }, _
}

function $4(y, l, _) {
  var x = y.getShaderPrecisionFormat(y[l], y[_]);
  return x ? [x.rangeMin, x.rangeMax, x.precision] : []
}

function Wv(y) {
  var l = Object.keys(y.__proto__);
  return l.filter(Q4)
}

function Q4(y) {
  return typeof y == "string" && !y.match(/[^A-Z0-9_x]/)
}

function ay() {
  return $0()
}

function eS() {
  return Lh() || Ss()
}

function ny(y) {
  return typeof y.getParameter == "function"
}

function tS() {
  var y = mg() || Ss();
  if (!y) return -2;
  if (!window.AudioContext) return -1;
  var l = new AudioContext().baseLatency;
  return l == null ? -1 : isFinite(l) ? l : -3
}

function rS() {
  if (!window.Intl) return -1;
  var y = window.Intl.DateTimeFormat;
  if (!y) return -2;
  var l = y().resolvedOptions().locale;
  return !l && l !== "" ? -3 : l
}
var iS = {
  fonts: qT,
  domBlockers: w4,
  fontPreferences: B4,
  audio: AT,
  screenFrame: l4,
  canvas: VT,
  osCpu: $T,
  languages: QT,
  colorDepth: e4,
  deviceMemory: t4,
  screenResolution: r4,
  hardwareConcurrency: c4,
  timezone: u4,
  sessionStorage: d4,
  localStorage: p4,
  indexedDB: f4,
  openDatabase: m4,
  cpuClass: g4,
  platform: _4,
  plugins: NT,
  touchSupport: JT,
  vendor: v4,
  vendorFlavors: y4,
  cookiesEnabled: x4,
  colorGamut: I4,
  invertedColors: M4,
  forcedColors: C4,
  monochrome: k4,
  contrast: z4,
  reducedMotion: E4,
  reducedTransparency: L4,
  hdr: D4,
  math: R4,
  pdfViewerEnabled: j4,
  architecture: q4,
  applePay: N4,
  privateClickMeasurement: Z4,
  audioBaseLatency: tS,
  dateTimeLocale: rS,
  webGlBasics: K4,
  webGlExtensions: J4
};

function aS(y) {
  return xT(iS, y, [])
}
var nS = "$ if upgrade to Pro: https://fpjs.dev/pro";

function sS(y) {
  var l = oS(y),
    _ = lS(l);
  return {
    score: l,
    comment: nS.replace(/\$/g, "".concat(_))
  }
}

function oS(y) {
  if (mg()) return .4;
  if (Ss()) return fg() && !(Rh() && Dh()) ? .5 : .3;
  var l = "value" in y.platform ? y.platform.value : "";
  return /^Win/.test(l) ? .6 : /^Mac/.test(l) ? .5 : .7
}

function lS(y) {
  return K0(.99 + .01 * y, 1e-4)
}

function cS(y) {
  for (var l = "", _ = 0, x = Object.keys(y).sort(); _ < x.length; _++) {
    var k = x[_],
      z = y[k],
      T = "error" in z ? "error" : JSON.stringify(z.value);
    l += "".concat(l ? "|" : "").concat(k.replace(/([:|\\])/g, "\\$1"), ":").concat(T)
  }
  return l
}

function sy(y) {
  return JSON.stringify(y, function(l, _) {
    return _ instanceof Error ? gT(_) : _
  }, 2)
}

function oy(y) {
  return mT(cS(y))
}

function uS(y) {
  var l, _ = sS(y);
  return {
    get visitorId() {
      return l === void 0 && (l = oy(this.components)), l
    },
    set visitorId(x) {
      l = x
    },
    confidence: _,
    components: y,
    version: X0
  }
}

function hS(y) {
  return y === void 0 && (y = 50), sT(y, y * 2)
}

function dS(y, l) {
  var _ = Date.now();
  return {
    get: function(x) {
      return Rs(this, void 0, void 0, function() {
        var k, z, T;
        return Fs(this, function(s) {
          switch (s.label) {
            case 0:
              return k = Date.now(), [4, y()];
            case 1:
              return z = s.sent(), T = uS(z), (l || x != null && x.debug) && console.log("Copy the text below to get the debug data:\n\n```\nversion: ".concat(T.version, `
userAgent: `).concat(navigator.userAgent, `
timeBetweenLoadAndGet: `).concat(k - _, `
visitorId: `).concat(T.visitorId, `
components: `).concat(sy(z), "\n```")), [2, T]
          }
        })
      })
    }
  }
}

function pS() {
  if (!(window.__fpjs_d_m || Math.random() >= .001)) try {
    var y = new XMLHttpRequest;
    y.open("get", "https://m1.openfpcdn.io/fingerprintjs/v".concat(X0, "/npm-monitoring"), !0), y.send()
  } catch (l) {
    console.error(l)
  }
}

function fS(y) {
  var l;
  return y === void 0 && (y = {}), Rs(this, void 0, void 0, function() {
    var _, x, k;
    return Fs(this, function(z) {
      switch (z.label) {
        case 0:
          return (!((l = y.monitoring) !== null && l !== void 0) || l) && pS(), _ = y.delayFallback, x = y.debug, [4, hS(_)];
        case 1:
          return z.sent(), k = aS({
            cache: {},
            debug: x
          }), [2, dS(k, x)]
      }
    })
  })
}
var ly = {
  load: fS,
  hashComponents: oy,
  componentsToDebugString: sy
};
let im = null,
  Cp;
async function mS() {
  return im || (im = ly.load()), im
}
async function gg() {
  return Cp || gS().then(y => y.visitorId)
}
async function gS() {
  const l = await (await mS()).get(),
    {
      languages: _,
      dateTimeLocale: x,
      ...k
    } = l.components;
  return Cp = ly.hashComponents(k), {
    visitorId: Cp,
    components: k
  }
}
var _S = Yr('<svg><path d="M240-120q-45 0-89-22t-71-58q26 0 53-20.5t27-59.5q0-50 35-85t85-35q50 0 85 35t35 85q0 66-47 113t-113 47Zm230-240L360-470l358-358q11-11 27.5-11.5T774-828l54 54q12 12 12 28t-12 28L470-360Z"></path></svg>');

function Vo(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = _S();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}

function pp(y) {
  const l = document.createElement("img");
  return l.src = y, new Promise((_, x) => {
    l.addEventListener("load", () => {
      _(l)
    }), l.addEventListener("error", k => {
      x(k)
    })
  })
}

function cy(y) {
  const l = document.createElement("canvas");
  l.width = y.naturalWidth, l.height = y.naturalHeight;
  const _ = l.getContext("2d");
  return _ == null || _.drawImage(y, 0, 0), l
}
var vS = ae('<button type="button"></button>'),
  yS = ae('<div class="overlay pointer-events-auto svelte-rxq6cp"><canvas></canvas> <div class="overlay-border svelte-rxq6cp"></div> <!></div>'),
  xS = ae('<div><!> <p class="text-base font-medium">Drop an image or click the button below to select a file</p> <input type="file" accept="image/*" class="hidden" id="auto-paint-file"/> <label for="auto-paint-file" class="btn btn-primary btn-sm">Upload image</label></div>'),
  bS = ae("<option> </option>"),
  wS = ae('<span class="loading loading-spinner loading-sm"></span> Processing', 1),
  TS = ae('<button class="btn btn-primary"><!></button>'),
  SS = ae('<span class="loading loading-spinner loading-sm"></span> Sending', 1),
  PS = ae('<button class="btn btn-primary"><!></button>'),
  IS = ae('<div class="rounded-box bg-success/10 text-success px-3 py-2 text-sm"> </div>'),
  MS = ae('<div class="mt-4 grid gap-4 md:grid-cols-2"><div class="space-y-2"><div class="rounded-box bg-base-200/60 p-3 text-sm"><p class="font-semibold"> </p> <p class="text-base-content/70"> </p></div> <div class="flex items-center gap-2"><label class="text-base-content/70 text-sm">Opacity</label> <input type="range" min="20" max="100"/></div> <div class="space-y-1"><label class="flex items-center gap-2 text-sm font-medium"><input type="checkbox" class="checkbox checkbox-primary checkbox-sm"/> <span>Dithering (Floyd-Steinberg)</span></label> <p class="text-base-content/70 text-xs">Makes color transitions smoother.</p></div> <div class="space-y-1"><label class="flex items-center gap-2 text-sm font-medium"><input type="checkbox" class="checkbox checkbox-primary checkbox-sm"/> <span>Paint transparent pixels</span></label> <p class="text-base-content/70 text-xs">Clears pixels using palette index 0.</p></div> <div class="space-y-1"><label class="flex flex-col gap-1 text-sm font-medium">Color metric <select class="select select-bordered select-sm w-full max-w-xs"></select></label></div></div> <div class="space-y-2 text-sm"><p class="text-base-content/70">1. Set image position by draging it.<br/> 2. Click on <strong>Generate Preview</strong> to convert the colors.<br/> 3. Confirm to paint the canvas.</p> <button class="btn btn-sm btn-outline">Change image</button> <div class="flex flex-wrap gap-2"><button class="btn btn-sm btn-outline">Flip horizontal</button> <button class="btn btn-sm btn-outline">Flip vertical</button></div> <label class="flex items-center gap-2 text-sm font-medium"><span class="whitespace-nowrap">Paint as user ID:</span> <input class="input input-bordered input-xs min-w-0 flex-1" type="number" placeholder="User ID"/></label></div></div> <div class="mt-4 flex flex-wrap items-center gap-3"><!> <button class="btn btn-ghost">Cancelar</button> <!></div>', 1),
  CS = ae(`<div class="pointer-events-none absolute inset-0 z-40 select-none"><!></div> <div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-2xl sm:-translate-x-1/2"><div class="rounded-t-box bg-base-100 border-base-300 border-t p-4 shadow-xl"><div class="flex items-center justify-between gap-2"><div><h2 class="flex items-center gap-2 text-lg font-semibold"><!> Auto Painter</h2> <p class="text-base-content/70 text-sm">Drag the image to the desired position. Use the anchors to change it's size.</p></div> <button class="btn btn-circle btn-sm" title="Fechar"><!></button></div> <!></div></div>`, 1);

function AS(y, l) {
  var Ge;
  Gr(l, !1);
  const _ = 2e3,
    x = 256,
    k = "admin-auto-painter-opacity",
    z = "admin-auto-painter-dithering",
    T = "admin-auto-painter-transparent";
  let s = Ot(l, "map", 8),
    F = Ot(l, "tileSize", 8),
    Z = Ot(l, "tileZoom", 8),
    K = Ot(l, "season", 8),
    G = Ot(l, "refreshPixelArt", 8),
    re = Ot(l, "onclose", 8),
    he = en(new kn(F())),
    me = en(((Ge = bt.data) == null ? void 0 : Ge.id) ?? 0),
    q = en("upload"),
    ye = en(!1),
    be = en(!1),
    qe = en(!1),
    xe = en(null),
    Ye = en(""),
    We = en(null),
    ze = en(null),
    Se = en(null),
    Pe = en({
      pixels: 0,
      width: 0,
      height: 0,
      tiles: 0
    }),
    Ae = [],
    Me = en(null),
    Ee = en(null),
    Qe = en(1),
    Ue = en(!1),
    je = en(!1),
    rt = en("lab");
  const _t = [{
    value: "lab",
    label: "Perceptual (CIELAB E94)"
  }, {
    value: "compuphase",
    label: "Weighted RGB (CompuPhase)"
  }];
  let dt = en(!1),
    at = null;
  const nt = ["nw", "n", "ne", "e", "se", "s", "sw", "w"],
    ot = new Set(["nw", "ne", "se", "sw"]);

  function ut(pe) {
    return ot.has(pe)
  }

  function st(pe, Ve, it) {
    return Math.min(Math.max(pe, Ve), it)
  }

  function wt(pe) {
    const Ve = Math.max(pe.north, pe.south),
      it = Math.min(pe.north, pe.south),
      yt = Math.min(pe.west, pe.east),
      Lt = Math.max(pe.west, pe.east);
    return {
      north: st(Ve, -85, 85),
      south: st(it, -85, 85),
      west: st(yt, -180, 180),
      east: st(Lt, -180, 180)
    }
  }

  function Ct(pe) {
    j(We, wt(pe)), j(ye, !1), j(Me, null), Ae = [], j(Pe, {
      pixels: 0,
      width: 0,
      height: 0,
      tiles: 0
    }), rr(), Zt(), fr()
  }

  function rr() {
    if (!h(We)) {
      j(Se, null);
      return
    }
    const [pe, Ve] = h(he).latLonToPixels(h(We).north, h(We).west, Z()), [it, yt] = h(he).latLonToPixels(h(We).south, h(We).east, Z()), Lt = Math.min(pe, it), ct = Math.max(pe, it), At = Math.min(Ve, yt), qt = Math.max(Ve, yt), Ke = Math.max(1, Math.ceil(ct - Lt)), Tt = Math.max(1, Math.ceil(qt - At));
    j(Se, {
      px0: Lt,
      py0: At,
      width: Ke,
      height: Tt
    })
  }

  function Zt() {
    if (!h(We)) {
      j(ze, null);
      return
    }
    const pe = s().project({
        lat: h(We).north,
        lng: h(We).west
      }),
      Ve = s().project({
        lat: h(We).south,
        lng: h(We).east
      }),
      it = Math.min(pe.x, Ve.x),
      yt = Math.min(pe.y, Ve.y),
      Lt = Math.abs(Ve.x - pe.x),
      ct = Math.abs(Ve.y - pe.y);
    j(ze, {
      left: it,
      top: yt,
      width: Lt,
      height: ct
    })
  }

  function lt() {
    j(q, "upload"), j(xe, null), j(Ye, ""), j(We, null), j(Se, null), j(ze, null), j(ye, !1), Ae = [], j(Me, null), j(Pe, {
      pixels: 0,
      width: 0,
      height: 0,
      tiles: 0
    })
  }

  function ht() {
    if (!h(xe)) return;
    const pe = s().getCenter(),
      [Ve, it] = h(he).latLonToPixels(pe.lat, pe.lng, Z()),
      yt = Math.min(1, x / h(xe).width),
      Lt = Math.max(8, Math.round(h(xe).width * yt)),
      ct = Math.max(8, Math.round(h(xe).height * yt)),
      At = Ve - Lt / 2,
      qt = Ve + Lt / 2,
      Ke = it - ct / 2,
      Tt = it + ct / 2,
      [Wt, Fr] = h(he).pixelsToLatLon(At, Ke, Z()),
      [or, tt] = h(he).pixelsToLatLon(qt, Tt, Z());
    Ct({
      north: Wt,
      south: or,
      west: Fr,
      east: tt
    }), fr()
  }
  async function Dt(pe) {
    try {
      lt();
      const Ve = URL.createObjectURL(pe),
        it = await pp(Ve);
      URL.revokeObjectURL(Ve), j(xe, cy(it)), j(Ye, pe.name), j(q, "place"), ht()
    } catch (Ve) {
      console.error(Ve), Bt.error("Failed to load image. Try again.")
    }
  }

  function Vt(pe) {
    var yt;
    const Ve = pe.target,
      it = (yt = Ve.files) == null ? void 0 : yt[0];
    it && Dt(it), Ve.value = ""
  }

  function Jt(pe) {
    pe.preventDefault(), j(dt, !0)
  }

  function jt(pe) {
    pe.preventDefault(), j(dt, !1)
  }

  function nr(pe) {
    var it, yt;
    pe.preventDefault(), j(dt, !1);
    const Ve = (yt = (it = pe.dataTransfer) == null ? void 0 : it.files) == null ? void 0 : yt[0];
    Ve && Dt(Ve)
  }

  function St(pe) {
    const Ve = s().getCanvas().getBoundingClientRect(),
      it = [pe.clientX - Ve.left, pe.clientY - Ve.top],
      yt = s().unproject(it);
    return {
      lat: yt.lat,
      lon: yt.lng
    }
  }

  function Et(pe, Ve, it) {
    if (!h(xe)) return Ve;
    const yt = h(xe).width / Math.max(h(xe).height, 1);
    if (!isFinite(yt) || yt <= 0) return Ve;
    const Lt = pe.includes("n") ? it.south : it.north,
      ct = pe.includes("w") ? it.east : it.west,
      At = pe.includes("n") ? Ve.north : Ve.south,
      qt = pe.includes("w") ? Ve.west : Ve.east,
      [Ke, Tt] = h(he).latLonToPixels(Lt, ct, Z()),
      [Wt, Fr] = h(he).latLonToPixels(At, qt, Z());
    let or = Wt - Ke,
      tt = Fr - Tt,
      Ht = Math.sign(or) || (pe.includes("w") ? -1 : 1),
      Qt = Math.sign(tt) || (pe.includes("n") ? -1 : 1),
      Sr = Math.abs(or),
      ei = Math.abs(tt);
    if (Sr === 0 && ei === 0) return Ve;
    const li = ei * yt,
      Dr = Sr / yt;
    li > Sr ? Sr = li : ei = Dr;
    const Oi = Ke + Ht * Sr,
      Jr = Tt + Qt * ei,
      [It, er] = h(he).pixelsToLatLon(Oi, Jr, Z());
    return pe.includes("n") ? Ve.north = It : Ve.south = It, pe.includes("w") ? Ve.west = er : Ve.east = er, Ve
  }

  function Ut(pe) {
    if (!h(We)) return;
    pe.preventDefault();
    const {
      lat: Ve,
      lon: it
    } = St(pe);
    at = {
      type: "move",
      startLat: Ve,
      startLon: it,
      startBounds: {
        ...h(We)
      }
    }, ir()
  }

  function Gt(pe, Ve) {
    h(We) && (pe.preventDefault(), pe.stopPropagation(), at = {
      type: "resize",
      handle: Ve,
      startBounds: {
        ...h(We)
      }
    }, ir())
  }

  function Rt(pe) {
    s().scrollZoom.isEnabled() && (pe.preventDefault(), s().getCanvasContainer().dispatchEvent(new WheelEvent("wheel", {
      deltaX: pe.deltaX,
      deltaY: pe.deltaY,
      deltaZ: pe.deltaZ,
      deltaMode: pe.deltaMode,
      clientX: pe.clientX,
      clientY: pe.clientY,
      screenX: pe.screenX,
      screenY: pe.screenY,
      ctrlKey: pe.ctrlKey,
      shiftKey: pe.shiftKey,
      altKey: pe.altKey,
      metaKey: pe.metaKey,
      bubbles: !0,
      cancelable: !0
    })))
  }

  function ir() {
    s().dragPan.disable(), window.addEventListener("pointermove", _r), window.addEventListener("pointerup", kr)
  }

  function kr() {
    window.removeEventListener("pointermove", _r), window.removeEventListener("pointerup", kr), s().dragPan.enable(), at = null
  }

  function _r(pe) {
    if (!at || !at.startBounds) return;
    const {
      startBounds: Ve
    } = at;
    if (at.type === "move") {
      const {
        lat: At,
        lon: qt
      } = St(pe), Ke = At - at.startLat, Tt = qt - at.startLon;
      Ct({
        north: Ve.north + Ke,
        south: Ve.south + Ke,
        west: Ve.west + Tt,
        east: Ve.east + Tt
      });
      return
    }
    const {
      handle: it
    } = at, {
      lat: yt,
      lon: Lt
    } = St(pe);
    let ct = {
      ...Ve
    };
    it.includes("n") && (ct.north = yt), it.includes("s") && (ct.south = yt), it.includes("w") && (ct.west = Lt), it.includes("e") && (ct.east = Lt), ut(it) && (ct = Et(it, ct, Ve)), Ct(ct)
  }

  function fr() {
    if (!h(Ee) || !h(Se) || !h(xe) || h(ye)) return;
    sr().drawImage(h(xe), 0, 0, h(Se).width, h(Se).height)
  }

  function Yt(pe, Ve) {
    if (!h(xe)) return;
    const it = document.createElement("canvas");
    it.width = h(xe).width, it.height = h(xe).height;
    const yt = it.getContext("2d");
    if (!yt) throw new Error("Canvas context not available");
    yt.imageSmoothingEnabled = !1;
    const Lt = pe ? -1 : 1,
      ct = Ve ? -1 : 1,
      At = pe ? h(xe).width : 0,
      qt = Ve ? h(xe).height : 0;
    if (yt.setTransform(Lt, 0, 0, ct, At, qt), yt.drawImage(h(xe), 0, 0), j(xe, it), h(ye)) {
      ge();
      return
    }
    fr()
  }

  function sr() {
    if (!h(Ee) || !h(Se)) throw new Error("Canvas not ready");
    mv(Ee, h(Ee).width = h(Se).width), mv(Ee, h(Ee).height = h(Se).height);
    const pe = h(Ee).getContext("2d", {
      willReadFrequently: !0
    });
    if (!pe) throw new Error("Canvas context not available");
    return pe.imageSmoothingEnabled = !1, pe.clearRect(0, 0, h(Ee).width, h(Ee).height), pe
  }

  function Kt() {
    if (!h(Ee) || !h(Se) || !h(Me) || !h(ye)) return;
    sr().putImageData(h(Me), 0, 0)
  }
  async function vr() {
    if (!(!h(Se) || !h(xe))) {
      if (h(Se).width > _ || h(Se).height > _) {
        Bt.error(`The selected area is too big (${h(Se).width}${h(Se).height}).`);
        return
      }
      j(be, !0);
      try {
        const pe = Lr();
        if (!pe || pe.pixels.length === 0) {
          Bt.error("Faile to convert into valid game_pixels");
          return
        }
        j(Me, pe.imageData), Ae = pe.pixels, j(Pe, pe.stats), j(ye, !0), Kt()
      } catch (pe) {
        console.error(pe), Bt.error("Failed to generate preview.")
      } finally {
        j(be, !1)
      }
    }
  }

  function Lr() {
    if (!h(Se) || !h(xe)) return;
    const pe = document.createElement("canvas");
    pe.width = h(Se).width, pe.height = h(Se).height;
    const Ve = pe.getContext("2d", {
      willReadFrequently: !0
    });
    if (!Ve) throw new Error("Context is null.");
    Ve.imageSmoothingEnabled = !1, Ve.drawImage(h(xe), 0, 0, h(Se).width, h(Se).height);
    const it = h(Se).width,
      yt = h(Se).height,
      Lt = Ve.getImageData(0, 0, it, yt),
      ct = Lt.data,
      At = [],
      qt = new Set,
      Ke = h(Ue);
    let Tt = null,
      Wt = null;
    if (Ke) {
      const Fr = it * 3;
      Tt = new Float32Array(Fr), Wt = new Float32Array(Fr)
    }
    for (let Fr = 0; Fr < yt; Fr++) {
      if (Ke && Tt && Wt) {
        const or = Tt;
        Tt = Wt, Wt = or, Wt.fill(0)
      }
      for (let or = 0; or < it; or++) {
        const tt = (Fr * it + or) * 4;
        if (ct[tt + 3] < 16) {
          if (ct[tt + 3] = 0, !h(je)) continue;
          const qr = 0,
            ur = wp(qr);
          ct[tt] = ur.r, ct[tt + 1] = ur.g, ct[tt + 2] = ur.b;
          const Mr = h(Se).px0 + or + .5,
            di = h(Se).py0 + Fr + .5,
            {
              tile: ti,
              pixel: Vr
            } = h(he).pixelsToTileLocal(Mr, di),
            Rr = {
              tile: [ti[0], ti[1]],
              pixel: [Vr[0], Vr[1]],
              season: K(),
              colorIdx: qr,
              color: ur
            },
            ni = `${ti[0]}:${ti[1]}`;
          qt.add(ni), At.push(Rr);
          continue
        }
        let Qt = ct[tt],
          Sr = ct[tt + 1],
          ei = ct[tt + 2];
        if (Ke && Tt) {
          const qr = or * 3;
          Qt = st(Math.round(Qt + Tt[qr]), 0, 255), Sr = st(Math.round(Sr + Tt[qr + 1]), 0, 255), ei = st(Math.round(ei + Tt[qr + 2]), 0, 255)
        }
        const li = g0({
            r: Qt,
            g: Sr,
            b: ei
          }, h(rt)),
          Dr = wp(li);
        if (ct[tt] = Dr.r, ct[tt + 1] = Dr.g, ct[tt + 2] = Dr.b, ct[tt + 3] = Dr.a, Ke && Tt && Wt) {
          const qr = Qt - Dr.r,
            ur = Sr - Dr.g,
            Mr = ei - Dr.b,
            di = (ti, Vr, Rr) => {
              ti[Vr] += qr * Rr, ti[Vr + 1] += ur * Rr, ti[Vr + 2] += Mr * Rr
            };
          if (or + 1 < it) {
            const ti = (or + 1) * 3;
            di(Tt, ti, 7 / 16)
          }
          if (Fr + 1 < yt) {
            if (or > 0) {
              const Vr = (or - 1) * 3;
              di(Wt, Vr, 3 / 16)
            }
            const ti = or * 3;
            if (di(Wt, ti, 5 / 16), or + 1 < it) {
              const Vr = (or + 1) * 3;
              di(Wt, Vr, 1 / 16)
            }
          }
        }
        const Oi = h(Se).px0 + or + .5,
          Jr = h(Se).py0 + Fr + .5,
          {
            tile: It,
            pixel: er
          } = h(he).pixelsToTileLocal(Oi, Jr),
          Pr = {
            tile: [It[0], It[1]],
            pixel: [er[0], er[1]],
            season: K(),
            colorIdx: li,
            color: Dr
          },
          pr = `${It[0]}:${It[1]}`;
        qt.add(pr), At.push(Pr)
      }
    }
    return {
      pixels: At,
      imageData: Lt,
      stats: {
        pixels: At.length,
        width: it,
        height: yt,
        tiles: qt.size
      }
    }
  }
  async function ii() {
    if (!(!h(ye) || Ae.length === 0)) {
      j(qe, !0);
      try {
        aa.droppletAndPlop.play();
        const pe = await gg(),
          Ve = Ae.map(({
            color: it,
            ...yt
          }) => yt);
        await Kr.adminAutoPainterPaint(Ve, pe, h(me)), await Km(Ae), G()(), bt.refresh(), Bt.success("Art painted successfully."), mr()
      } catch (pe) {
        console.error(pe), Bt.error(pe.message ?? "Failed to paint art.")
      } finally {
        j(qe, !1)
      }
    }
  }

  function mr() {
    lt(), re()()
  }

  function ge() {
    j(ye, !1), j(Me, null), Ae = [], j(Pe, {
      pixels: 0,
      width: 0,
      height: 0,
      tiles: 0
    }), fr()
  }
  Oa(() => {
    const pe = () => Zt();
    return s().on("move", pe), s().on("zoom", pe), s().on("resize", pe), () => {
      s().off("move", pe), s().off("zoom", pe), s().off("resize", pe)
    }
  }), B1(() => {
    lt()
  }), Jf(() => H1(F()), () => {
    j(he, new kn(F()))
  }), Jf(() => (h(Ee), h(Se), h(xe), h(ye), h(q)), () => {
    h(Ee) && h(Se) && h(xe) && !h(ye) && h(q) === "place" && fr()
  }), Jf(() => (h(Ee), h(Se), h(Me), h(ye)), () => {
    h(Ee) && h(Se) && h(Me) && h(ye) && Kt()
  }), W1(), $m();
  var V = CS();
  Ci("keydown", qo, pe => {
    pe.key === "Escape" && mr()
  }), Ci("dragover", qo, N3(Jt)), Ci("drop", qo, nr), Ci("dragleave", qo, jt);
  var U = zt(V),
    J = P(U);
  {
    var se = pe => {
      var Ve = yS(),
        it = P(Ve);
      let yt;
      Rn(it, At => j(Ee, At), () => h(Ee));
      var Lt = E(it, 2),
        ct = E(Lt, 2);
      Hi(ct, 1, () => nt, At => At, (At, qt) => {
        var Ke = vS();
        ke(Tt => {
          Er(Ke, 1, `handle handle-${h(qt)}`, "svelte-rxq6cp"), Xt(Ke, "aria-label", Tt)
        }, [() => (h(qt), An(() => `Redimensionar (${h(qt).toUpperCase()})`))]), Ci("pointerdown", Ke, Tt => Gt(Tt, h(qt))), B(At, Ke)
      }), S(Ve), ke(() => {
        Qn(Ve, (h(ze), h(Qe), An(() => `left:${h(ze).left}px;top:${h(ze).top}px;width:${h(ze).width}px;height:${h(ze).height}px;opacity:${h(Qe)};`))), yt = Er(it, 1, "h-full w-full svelte-rxq6cp", null, yt, {
          pixelated: h(ye)
        })
      }), Ci("pointerdown", it, Ut), Ci("pointerdown", Lt, Ut), Ci("wheel", Ve, Rt), B(pe, Ve)
    };
    Te(J, pe => {
      h(We) && h(ze) && pe(se)
    })
  }
  S(U);
  var te = E(U, 2),
    _e = P(te),
    Re = P(_e),
    ne = P(Re),
    oe = P(ne),
    fe = P(oe);
  Vo(fe, {
    class: "size-5"
  }), wi(), S(oe), wi(2), S(ne);
  var ve = E(ne, 2),
    ie = P(ve);
  ss(ie, {
    class: "size-4"
  }), S(ve), S(Re);
  var Y = E(Re, 2);
  {
    var Fe = pe => {
        var Ve = xS(),
          it = P(Ve);
        gb(it, {
          class: "text-base-content/70 size-10"
        });
        var yt = E(it, 4);
        wi(2), S(Ve), ke(() => Er(Ve, 1, `rounded-box mt-4 flex flex-col items-center justify-center gap-3 border border-dashed p-6 text-center transition ${h(dt)?"border-primary bg-primary/10":"border-base-300"}`, "svelte-rxq6cp")), Ci("change", yt, Vt), B(pe, Ve)
      },
      Ne = pe => {
        var Ve = br(),
          it = zt(Ve);
        {
          var yt = Lt => {
            var ct = MS(),
              At = zt(ct),
              qt = P(At),
              Ke = P(qt),
              Tt = P(Ke),
              Wt = P(Tt, !0);
            S(Tt);
            var Fr = E(Tt, 2),
              or = P(Fr);
            S(Fr), S(Ke);
            var tt = E(Ke, 2),
              Ht = P(tt);
            Xt(Ht, "for", k);
            var Qt = E(Ht, 2);
            Ka(Qt), Xt(Qt, "id", k), S(tt);
            var Sr = E(tt, 2),
              ei = P(Sr);
            Xt(ei, "for", z);
            var li = P(ei);
            Ka(li), Xt(li, "id", z), wi(2), S(ei), wi(2), S(Sr);
            var Dr = E(Sr, 2),
              Oi = P(Dr);
            Xt(Oi, "for", T);
            var Jr = P(Oi);
            Ka(Jr), Xt(Jr, "id", T), wi(2), S(Oi), wi(2), S(Dr);
            var It = E(Dr, 2),
              er = P(It),
              Pr = E(P(er));
            ke(() => {
              h(rt), X1(() => {
                h(ye)
              })
            }), Hi(Pr, 5, () => _t, po, (Br, Zr) => {
              var ci = bS(),
                ui = P(ci, !0);
              S(ci);
              var pt = {};
              ke(() => {
                ee(ui, (h(Zr), An(() => h(Zr).label))), pt !== (pt = (h(Zr), An(() => h(Zr).value))) && (ci.value = (ci.__value = (h(Zr), An(() => h(Zr).value))) ?? "")
              }), B(Br, ci)
            }), S(Pr), S(er), S(It), S(qt);
            var pr = E(qt, 2),
              qr = E(P(pr), 2),
              ur = E(qr, 2),
              Mr = P(ur),
              di = E(Mr, 2);
            S(ur);
            var ti = E(ur, 2),
              Vr = E(P(ti), 2);
            Ka(Vr), S(ti), S(pr), S(At);
            var Rr = E(At, 2),
              ni = P(Rr);
            {
              var Ri = Br => {
                  var Zr = TS(),
                    ci = P(Zr);
                  {
                    var ui = kt => {
                        var dr = wS();
                        wi(), B(kt, dr)
                      },
                      pt = kt => {
                        var dr = ja("Generate Preview");
                        B(kt, dr)
                      };
                    Te(ci, kt => {
                      h(be) ? kt(ui) : kt(pt, !1)
                    })
                  }
                  S(Zr), ke(() => Zr.disabled = h(be)), Ci("click", Zr, vr), B(Br, Zr)
                },
                qi = Br => {
                  var Zr = PS(),
                    ci = P(Zr);
                  {
                    var ui = kt => {
                        var dr = SS();
                        wi(), B(kt, dr)
                      },
                      pt = kt => {
                        var dr = ja("Confirm painting");
                        B(kt, dr)
                      };
                    Te(ci, kt => {
                      h(qe) ? kt(ui) : kt(pt, !1)
                    })
                  }
                  S(Zr), ke(() => Zr.disabled = h(qe)), Ci("click", Zr, ii), B(Br, Zr)
                };
              Te(ni, Br => {
                h(ye) ? Br(qi, !1) : Br(Ri)
              })
            }
            var ai = E(ni, 2),
              Pt = E(ai, 2);
            {
              var tr = Br => {
                var Zr = IS(),
                  ci = P(Zr);
                S(Zr), ke(ui => ee(ci, `Ready to paint ${ui??""} pixels.`), [() => (h(Pe), An(() => h(Pe).pixels.toLocaleString(navigator.language)))]), B(Br, Zr)
              };
              Te(Pt, Br => {
                h(ye) && Br(tr)
              })
            }
            S(Rr), ke(() => {
              ee(Wt, h(Ye)), ee(or, `Target size: ${h(Se),An(()=>h(Se).width)??""}  ${h(Se),An(()=>h(Se).height)??""} pixels`), Ym(Qt, h(Qe) * 100)
            }), Ci("input", Qt, Br => {
              const Zr = Br.target;
              j(Qe, Number(Zr.value) / 100)
            }), bp(li, () => h(Ue), Br => j(Ue, Br)), Ci("change", li, () => {
              h(ye) && ge()
            }), bp(Jr, () => h(je), Br => j(je, Br)), Ci("change", Jr, () => {
              h(ye) && ge()
            }), eb(Pr, () => h(rt), Br => j(rt, Br)), Ci("change", Pr, () => {
              h(ye) && ge()
            }), Ci("click", qr, () => j(q, "upload")), Ci("click", Mr, () => Yt(!0, !1)), Ci("click", di, () => Yt(!1, !0)), Tl(Vr, () => h(me), Br => j(me, Br)), Ci("click", ai, mr), B(Lt, ct)
          };
          Te(it, Lt => {
            h(We) && h(Se) && Lt(yt)
          }, !0)
        }
        B(pe, Ve)
      };
    Te(Y, pe => {
      h(q) === "upload" ? pe(Fe) : pe(Ne, !1)
    })
  }
  S(_e), S(te), Ci("click", ve, mr), B(y, V), Wr()
}
const fp = Wi({
  shouldReload: !0
});
var kS = ae('<dialog class="modal" closedby="any"><div class="modal-box max-w-2xl"><h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form><div class="mb-4 mt-2"><!></div> <div class="flex w-full justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-primary"> </button></div></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function zS(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "ref", 15),
    x = Xe(!1),
    k = Xe(Wi(l.description)),
    z = Xe(void 0);
  var T = kS(),
    s = P(T),
    F = P(s),
    Z = P(F, !0);
  S(F);
  var K = E(F, 2),
    G = P(K),
    re = P(G);
  {
    let qe = Je(() => v0());
    _0(re, {
      class: "h-24 rounded-lg",
      get placeholder() {
        return h(qe)
      },
      max: 512,
      get value() {
        return h(k)
      },
      set value(xe) {
        j(k, xe, !0)
      },
      get validate() {
        return h(z)
      },
      set validate(xe) {
        j(z, xe, !0)
      }
    })
  }
  S(G);
  var he = E(G, 2),
    me = P(he);
  me.__click = () => {
    var qe;
    (qe = _()) == null || qe.close()
  };
  var q = P(me, !0);
  S(me);
  var ye = E(me, 2),
    be = P(ye, !0);
  S(ye), S(he), S(K), S(s), wi(2), S(T), Rn(T, qe => _(qe), () => _()), ke((qe, xe, Ye) => {
    ee(Z, qe), me.disabled = h(x), ee(q, xe), ye.disabled = h(x), ee(be, Ye)
  }, [() => wb(), () => No(), () => Tb()]), Ci("submit", K, async () => {
    var qe, xe, Ye;
    try {
      if (!((qe = h(z)) != null && qe())) return;
      j(x, !0), l.description !== h(k) && await Kr.updateAllianceDescription(h(k)), await ((xe = l.onsuccess) == null ? void 0 : xe.call(l, h(k))), (Ye = _()) == null || Ye.close()
    } catch (We) {
      Bt.error(We.message)
    } finally {
      j(x, !1)
    }
  }), B(y, T), Wr()
}
Ui(["click"]);
var ES = ae('<span class="loading loading-spinner loading-md center-absolute absolute"></span>'),
  LS = ae('<dialog class="modal" closedby="any"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2"></button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <span class="text-base-content/80 text-sm"> </span> <div class="relative mt-4"><div><input class="text-base-content/80 min-w-10 grow text-sm font-medium" readonly=""/> <div class="h-10"><button> </button></div></div> <!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function DS(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "open", 15),
    x = Xe(""),
    k = Xe(!1);
  const z = Je(() => xa.url.origin + `/join?id=${h(x)}`);
  Qr(() => {
    _() && Kr.getAllianceInvites().then(ze => {
      j(x, ze[0], !0)
    }).catch(ze => {
      Bt.error(ze.message)
    })
  });
  var T = LS(),
    s = P(T),
    F = E(P(s), 2),
    Z = P(F, !0);
  S(F);
  var K = E(F, 2),
    G = P(K, !0);
  S(K);
  var re = E(K, 2),
    he = P(re);
  let me;
  var q = P(he);
  Ka(q);
  var ye = E(q, 2),
    be = P(ye);
  let qe;
  be.__click = () => {
    navigator.clipboard.writeText(h(z).toString()), j(k, !0), setTimeout(() => {
      j(k, !1)
    }, 1e3)
  };
  var xe = P(be, !0);
  S(be), S(ye), S(he);
  var Ye = E(he, 2);
  {
    var We = ze => {
      var Se = ES();
      B(ze, Se)
    };
    Te(Ye, ze => {
      h(x) || ze(We)
    })
  }
  S(re), S(s), wi(2), S(T), qa(T, () => ze => {
    Qr(() => {
      _() ? ze.show() : ze.close()
    })
  }), ke((ze, Se, Pe, Ae) => {
    ee(Z, ze), ee(G, Se), me = Er(he, 1, "border-base-content/20 rounded-field relative flex w-full items-center gap-1 border-2 py-1.5 pl-4 pr-2.5", null, me, {
      invisible: !h(x)
    }), Ym(q, Pe), qe = Er(be, 1, "btn btn-primary", null, qe, {
      "btn-success": h(k)
    }), ee(xe, Ae)
  }, [() => Sb(), () => Pb(), () => h(z).toString(), () => h(k) ? eg() : pm()]), Ci("close", T, () => _(!1)), B(y, T), Wr()
}
Ui(["click"]);
var RS = Yr('<svg><path d="M216.856 16.597A208.502 208.502 0 0 0 164.042 0c-2.275 4.113-4.933 9.645-6.766 14.046-19.692-2.961-39.203-2.961-58.533 0-1.832-4.4-4.55-9.933-6.846-14.046a207.809 207.809 0 0 0-52.855 16.638C5.618 67.147-3.443 116.4 1.087 164.956c22.169 16.555 43.653 26.612 64.775 33.193A161.094 161.094 0 0 0 79.735 175.3a136.413 136.413 0 0 1-21.846-10.632 108.636 108.636 0 0 0 5.356-4.237c42.122 19.702 87.89 19.702 129.51 0a131.66 131.66 0 0 0 5.355 4.237 136.07 136.07 0 0 1-21.886 10.653c4.006 8.02 8.638 15.67 13.873 22.848 21.142-6.58 42.646-16.637 64.815-33.213 5.316-56.288-9.08-105.09-38.056-148.36ZM85.474 135.095c-12.645 0-23.015-11.805-23.015-26.18s10.149-26.2 23.015-26.2c12.867 0 23.236 11.804 23.015 26.2.02 14.375-10.148 26.18-23.015 26.18Zm85.051 0c-12.645 0-23.014-11.805-23.014-26.18s10.148-26.2 23.014-26.2c12.867 0 23.236 11.804 23.015 26.2 0 14.375-10.148 26.18-23.015 26.18Z" fill="#5865F2"></path></svg>');

function xm(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = RS();
  jr(x, () => ({
    viewBox: "0 0 256 199",
    width: "256",
    height: "199",
    xmlns: "http://www.w3.org/2000/svg",
    preserveAspectRatio: "xMidYMid",
    ..._
  })), B(y, x)
}
var FS = ae('<span class="text-success">(Verified)</span>'),
  BS = ae('<a target="_blank" rel="noreferer" aria-label="Discord"><!></a>'),
  OS = ae("<button><!></button>"),
  jS = ae('<span class="tooltip h-4"><div class="tooltip-content"><span> </span> <!></div> <!></span>');

function Fh(y, l) {
  Gr(l, !0);
  const _ = !!l.id;
  var x = jS(),
    k = P(x),
    z = P(k),
    T = P(z);
  S(z);
  var s = E(z, 2);
  {
    var F = re => {
      var he = FS();
      B(re, he)
    };
    Te(s, re => {
      _ && re(F)
    })
  }
  S(k);
  var Z = E(k, 2);
  {
    var K = re => {
        var he = BS(),
          me = P(he);
        xm(me, {
          class: "size-4 opacity-70"
        }), S(he), ke(q => Xt(he, "href", q), [() => `https://discord.com/users/${encodeURIComponent(l.id)}`]), B(re, he)
      },
      G = re => {
        var he = OS();
        he.__click = async () => {
          await navigator.clipboard.writeText(l.username), Bt.info(Ib())
        };
        var me = P(he);
        xm(me, {
          class: "size-4 opacity-70"
        }), S(he), B(re, he)
      };
    Te(Z, re => {
      _ ? re(K) : re(G, !1)
    })
  }
  S(x), ke(() => ee(T, `Discord: ${l.username??""}`)), B(y, x), Wr()
}
Ui(["click"]);
var qS = ae('<input type="radio" class="tab max-[380px]:px-3"/>'),
  NS = ae('<div class="tabs tabs-border w-max font-medium"></div>');

function _g(y, l) {
  Gr(l, !0);
  const _ = [];
  let x = Ot(l, "value", 15, "today"),
    k = [{
      value: "today",
      label: Bp()
    }, {
      value: "week",
      label: Mb()
    }, {
      value: "month",
      label: Cb()
    }, {
      value: "all-time",
      label: Ab()
    }];
  var z = NS();
  Hi(z, 21, () => k, T => T.value, (T, s) => {
    var F = qS();
    Ka(F);
    var Z;
    ke(() => {
      Xt(F, "aria-label", h(s).label), Z !== (Z = h(s).value) && (F.value = (F.__value = h(s).value) ?? "")
    }), Jm(_, [], F, () => (h(s).value, x()), x), B(T, F)
  }), S(z), B(y, z), Wr()
}
var VS = ae("<span> </span>"),
  US = ae('<span><span class="inline-block"> </span> <!></span>');

function Bh(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "showId", 3, !0),
    x = Ot(l, "class", 3, "");
  const k = Je(() => {
      var G, re;
      return ((re = (G = l.equippedNameCosmetic) == null ? void 0 : G.resolved) == null ? void 0 : re.text) ?? ""
    }),
    z = Je(() => Dn(l.id ?? 0));
  var T = US(),
    s = P(T),
    F = P(s, !0);
  S(s);
  var Z = E(s, 2);
  {
    var K = G => {
      var re = VS(),
        he = P(re);
      S(re), ke(() => {
        Er(re, 1, _l(h(z))), ee(he, `#${l.id??""}`)
      }), B(G, re)
    };
    Te(Z, G => {
      _() && G(K)
    })
  }
  S(T), ke(() => {
    Er(T, 1, `inline-flex items-baseline gap-1.5 font-medium ${x()??""}`), Qn(s, h(k)), ee(F, l.name)
  }), B(y, T), Wr()
}
const ZS = typeof window < "u" ? window : void 0;

function GS(y) {
  let l = y.activeElement;
  for (; l != null && l.shadowRoot;) {
    const _ = l.shadowRoot.activeElement;
    if (_ === l) break;
    l = _
  }
  return l
}
var kc, nh, u0;
let WS = (u0 = class {
  constructor(l = {}) {
    Ii(this, kc);
    Ii(this, nh);
    const {
      window: _ = ZS,
      document: x = _ == null ? void 0 : _.document
    } = l;
    _ !== void 0 && (Mn(this, kc, x), Mn(this, nh, d0(k => {
      const z = yp(_, "focusin", k),
        T = yp(_, "focusout", k);
      return () => {
        z(), T()
      }
    })))
  }
  get current() {
    var l;
    return (l = ar(this, nh)) == null || l.call(this), ar(this, kc) ? GS(ar(this, kc)) : null
  }
}, kc = new WeakMap, nh = new WeakMap, u0);
new WS;

function HS(y) {
  return typeof y == "function"
}

function XS(y, l) {
  if (HS(y)) {
    const x = y();
    return x === void 0 ? l : x
  }
  return y === void 0 ? l : y
}

function YS(y, l) {
  let _ = Xe(null);
  const x = Je(() => XS(l, 250));

  function k(...z) {
    if (h(_)) h(_).timeout && clearTimeout(h(_).timeout);
    else {
      let T, s;
      const F = new Promise((Z, K) => {
        T = Z, s = K
      });
      j(_, {
        timeout: null,
        runner: null,
        promise: F,
        resolve: T,
        reject: s
      }, !0)
    }
    return h(_).runner = async () => {
      if (!h(_)) return;
      const T = h(_);
      j(_, null);
      try {
        T.resolve(await y.apply(this, z))
      } catch (s) {
        T.reject(s)
      }
    }, h(_).timeout = setTimeout(h(_).runner, h(x)), h(_).promise
  }
  return k.cancel = async () => {
    (!h(_) || h(_).timeout === null) && (await new Promise(z => setTimeout(z, 0)), !h(_) || h(_).timeout === null) || (clearTimeout(h(_).timeout), h(_).reject("Cancelled"), j(_, null))
  }, k.runScheduledNow = async () => {
    var z, T;
    (!h(_) || !h(_).timeout) && (await new Promise(s => setTimeout(s, 0)), !h(_) || !h(_).timeout) || (clearTimeout(h(_).timeout), h(_).timeout = null, await ((T = (z = h(_)).runner) == null ? void 0 : T.call(z)))
  }, Object.defineProperty(k, "pending", {
    enumerable: !0,
    get() {
      var z;
      return !!((z = h(_)) != null && z.timeout)
    }
  }), k
}

function KS(y, l) {
  switch (y) {
    case "post":
      Qr(l);
      break;
    case "pre":
      Hm(l);
      break
  }
}

function uy(y, l, _, x = {}) {
  const {
    lazy: k = !1
  } = x;
  let z = !k,
    T = Array.isArray(y) ? [] : void 0;
  KS(l, () => {
    const s = Array.isArray(y) ? y.map(Z => Z()) : y();
    if (!z) {
      z = !0, T = s;
      return
    }
    const F = An(() => _(s, T));
    return T = s, F
  })
}

function fo(y, l, _) {
  uy(y, "post", l, _)
}

function JS(y, l, _) {
  uy(y, "pre", l, _)
}
fo.pre = JS;

function $S() {}
var xl, Oo;
class QS {
  constructor(l, _ = 250) {
    Ii(this, xl, Xe());
    Ii(this, Oo);
    j(ar(this, xl), l(), !0), this.cancel = this.cancel.bind(this), this.setImmediately = this.setImmediately.bind(this), this.updateImmediately = this.updateImmediately.bind(this), Mn(this, Oo, YS(() => {
      j(ar(this, xl), l(), !0)
    }, _)), fo(l, () => {
      ar(this, Oo).call(this).catch($S)
    })
  }
  get current() {
    return h(ar(this, xl))
  }
  get pending() {
    return ar(this, Oo).pending
  }
  cancel() {
    ar(this, Oo).cancel()
  }
  updateImmediately() {
    return ar(this, Oo).runScheduledNow()
  }
  setImmediately(l) {
    this.cancel(), j(ar(this, xl), l, !0)
  }
}
xl = new WeakMap, Oo = new WeakMap;
var eP = ae('<span class="loading loading-spinner loading-lg mx-auto mt-18 flex items-center"></span>'),
  tP = ae('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  rP = ae('<span class="font-flag tooltip ml-0.5"> </span>'),
  iP = ae("<button><!></button>"),
  aP = ae('<tr><td class="text-base-content/80 font-medium max-[400px]:hidden"> </td><td><div class="flex items-center gap-2"><!> <!> <!> <!></div></td><td class="text-base-content/80 relative text-center font-medium"> <!></td></tr>'),
  nP = ae('<table class="table"><thead class="text-base-content/80"><tr><th class="max-[400px]:hidden"></th><th> </th><th class="text-center max-sm:px-1"> </th></tr></thead><tbody></tbody></table>'),
  sP = ae('<div><!> <div class="mt-4"><!></div></div>');

function oP(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "reload", 15),
    x = Xe(!0),
    k = Xe([]),
    z = Xe(0),
    T = Xe("today"),
    s = {};
  _(F);

  function F() {
    const q = h(T);
    Kr.allianceLeaderboard(q).then(ye => {
      j(k, ye), s = {
        [q]: ye
      }, j(x, !1)
    }).catch(ye => {
      Bt.error(ye.message)
    })
  }
  fo(() => [h(T)], () => {
    const q = h(T),
      ye = s[q];
    if (ye) {
      j(k, ye), j(x, !1);
      return
    }
    j(x, !0), Kr.allianceLeaderboard(q).then(be => {
      j(k, be), s[q] = be, j(x, !1)
    }).catch(be => {
      Bt.error(be.message)
    })
  });
  var Z = sP(),
    K = P(Z);
  _g(K, {
    get value() {
      return h(T)
    },
    set value(q) {
      j(T, q, !0)
    }
  });
  var G = E(K, 2),
    re = P(G);
  {
    var he = q => {
        var ye = eP();
        B(q, ye)
      },
      me = q => {
        var ye = br(),
          be = zt(ye);
        {
          var qe = Ye => {
              var We = tP(),
                ze = P(We),
                Se = E(ze);
              {
                var Pe = Me => {
                    var Ee = ja();
                    ke(Qe => ee(Ee, Qe), [() => Bp().toLowerCase()]), B(Me, Ee)
                  },
                  Ae = Me => {
                    var Ee = br(),
                      Qe = zt(Ee);
                    {
                      var Ue = rt => {
                          var _t = ja();
                          ke(dt => ee(_t, dt), [() => rg()]), B(rt, _t)
                        },
                        je = rt => {
                          var _t = br(),
                            dt = zt(_t);
                          {
                            var at = nt => {
                              var ot = ja();
                              ke(ut => ee(ot, ut), [() => ig()]), B(nt, ot)
                            };
                            Te(dt, nt => {
                              h(T) === "month" && nt(at)
                            }, !0)
                          }
                          B(rt, _t)
                        };
                      Te(Qe, rt => {
                        h(T) === "week" ? rt(Ue) : rt(je, !1)
                      }, !0)
                    }
                    B(Me, Ee)
                  };
                Te(Se, Me => {
                  h(T) === "today" ? Me(Pe) : Me(Ae, !1)
                })
              }
              S(We), ke(Me => ee(ze, `${Me??""} `), [() => tg()]), B(Ye, We)
            },
            xe = Ye => {
              var We = nP(),
                ze = P(We),
                Se = P(ze),
                Pe = E(P(Se)),
                Ae = P(Pe, !0);
              S(Pe);
              var Me = E(Pe),
                Ee = P(Me, !0);
              S(Me), S(Se), S(ze);
              var Qe = E(ze);
              Hi(Qe, 31, () => h(k), Ue => Ue.userId, (Ue, je, rt) => {
                const _t = Je(() => {
                  var nr;
                  return ((nr = bt.data) == null ? void 0 : nr.id) === h(je).userId
                });
                var dt = aP();
                let at;
                var nt = P(dt),
                  ot = P(nt, !0);
                S(nt);
                var ut = E(nt),
                  st = P(ut),
                  wt = P(st);
                bn(wt, {
                  class: "size-10 border",
                  get userId() {
                    return h(je).userId
                  },
                  get pictureUrl() {
                    return h(je).picture
                  }
                });
                var Ct = E(wt, 2);
                {
                  let nr = Je(() => {
                      var Et;
                      return h(_t) ? ((Et = bt.data) == null ? void 0 : Et.name) ?? h(je).name : h(je).name
                    }),
                    St = Je(() => {
                      var Et;
                      return h(_t) ? (Et = bt.data) == null ? void 0 : Et.equippedNameCosmetic : h(je).equippedNameCosmetic
                    });
                  Bh(Ct, {
                    get name() {
                      return h(nr)
                    },
                    get id() {
                      return h(je).userId
                    },
                    get equippedNameCosmetic() {
                      return h(St)
                    }
                  })
                }
                var rr = E(Ct, 2);
                {
                  var Zt = nr => {
                    const St = Je(() => Ds(h(je).equippedFlag));
                    var Et = rP(),
                      Ut = P(Et, !0);
                    S(Et), ke(() => {
                      Xt(Et, "data-tip", h(St).name), ee(Ut, h(St).flag)
                    }), B(nr, Et)
                  };
                  Te(rr, nr => {
                    h(je).equippedFlag && nr(Zt)
                  })
                }
                var lt = E(rr, 2);
                {
                  var ht = nr => {
                    Fh(nr, {
                      get username() {
                        return h(je).discord
                      },
                      get id() {
                        return h(je).discordId
                      }
                    })
                  };
                  Te(lt, nr => {
                    h(je).discord && nr(ht)
                  })
                }
                S(st), S(ut);
                var Dt = E(ut),
                  Vt = P(Dt),
                  Jt = E(Vt);
                {
                  var jt = nr => {
                    var St = iP();
                    let Et;
                    St.__click = () => {
                      l.onlastpixelclick({
                        lat: h(je).lastLatitude ?? 0,
                        lng: h(je).lastLongitude ?? 0
                      })
                    };
                    var Ut = P(St);
                    qp(Ut, {
                      class: "size-4"
                    }), S(St), ke(Gt => {
                      Et = Er(St, 1, "btn btn-sm btn-ghost absolute top-1/2 -right-2 -translate-y-1/2! sm:right-4", null, Et, {
                        tooltip: h(z) > 640
                      }), Xt(St, "data-tip", Gt)
                    }, [() => n3()]), B(nr, St)
                  };
                  Te(Jt, nr => {
                    h(je).lastLatitude && h(je).lastLongitude && nr(jt)
                  })
                }
                S(Dt), S(dt), ke(nr => {
                  at = Er(dt, 1, "", null, at, {
                    "bg-base-200": h(_t)
                  }), ee(ot, h(rt) + 1), ee(Vt, `${nr??""} `)
                }, [() => h(je).pixelsPainted.toLocaleString(navigator.language)]), vl(dt, () => yl, () => ({
                  duration: 200
                })), B(Ue, dt)
              }), S(Qe), S(We), ke((Ue, je) => {
                ee(Ae, Ue), ee(Ee, je)
              }, [() => ng(), () => Qm()]), B(Ye, We)
            };
          Te(be, Ye => {
            h(k).length === 0 ? Ye(qe) : Ye(xe, !1)
          }, !0)
        }
        B(q, ye)
      };
    Te(re, q => {
      h(x) ? q(he) : q(me, !1)
    })
  }
  S(G), S(Z), Eh("innerWidth", q => j(z, q, !0)), B(y, Z), Wr()
}
Ui(["click"]);
var lP = Yr('<svg><path d="M480-160q-33 0-56.5-23.5T400-240q0-33 23.5-56.5T480-320q33 0 56.5 23.5T560-240q0 33-23.5 56.5T480-160Zm0-240q-33 0-56.5-23.5T400-480q0-33 23.5-56.5T480-560q33 0 56.5 23.5T560-480q0 33-23.5 56.5T480-400Zm0-240q-33 0-56.5-23.5T400-720q0-33 23.5-56.5T480-800q33 0 56.5 23.5T560-720q0 33-23.5 56.5T480-640Z"></path></svg>');

function vg(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = lP();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var cP = ae('<div class="badge badge-primary badge-sm badge-soft">ADMIN</div>'),
  uP = ae('<li><button class="btn btn-ghost"> </button></li> <li><button class="btn btn-ghost btn-error not-hover:text-error"> </button></li>', 1),
  hP = ae('<li><button class="btn btn-ghost text-base-content/80"> </button></li>'),
  dP = ae('<tr><td class="w-full"><div class="flex items-center gap-2"><!> <span> </span> <!></div></td><td class="px-0"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-ghost"><!></div> <ul class="dropdown-content menu bg-base-100 rounded-box z-1 border-base-200 right-0 w-44 translate-y-1 gap-1 border p-2 shadow-sm"><!></ul></div></td></tr>'),
  pP = ae('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'),
  fP = ae('<tr><td class="w-full"><div class="flex items-center gap-2"><!> <span> </span></div></td><td class="px-0"><button class="btn btn-error"> </button></td></tr>'),
  mP = ae('<div class="text-base-content/80 mt-4 flex justify-center"> </div>'),
  gP = ae('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'),
  _P = ae('<div><section class="mt-2 flex items-center gap-1"><button class="btn btn-ghost btn-circle"><!></button> <h2 class="text-xl font-semibold"> </h2></section> <div class="tabs tabs-border mt-2"><input type="radio" name="members_tabs" class="tab" checked/> <div class="tab-content py-4"><table class="table"><tbody></tbody></table> <!></div> <input type="radio" name="members_tabs" class="tab"/> <div class="tab-content py-4"><table class="table"><tbody></tbody></table> <!> <!></div></div></div>');

function vP(y, l) {
  Gr(l, !0);
  let _ = Wi({
      data: [],
      page: 0,
      hasNextPage: !0,
      loading: !1
    }),
    x = Wi({
      data: [],
      page: 0,
      hasNextPage: !0,
      loading: !1
    });
  var k = _P(),
    z = P(k),
    T = P(z);
  T.__click = () => l.onclickback();
  var s = P(T);
  sg(s, {
    class: "size-5"
  }), S(T);
  var F = E(T, 2),
    Z = P(F, !0);
  S(F), S(z);
  var K = E(z, 2),
    G = P(K);
  Ka(G);
  var re = E(G, 2),
    he = P(re),
    me = P(he);
  Hi(me, 21, () => _.data, Ae => Ae.id, (Ae, Me, Ee) => {
    const Qe = Je(() => {
      var Dt;
      return ((Dt = bt.data) == null ? void 0 : Dt.id) === h(Me).id
    });
    var Ue = dP(),
      je = P(Ue),
      rt = P(je),
      _t = P(rt);
    bn(_t, {
      class: "size-10 border",
      get userId() {
        return h(Me).id
      },
      get pictureUrl() {
        return h(Me).picture
      }
    });
    var dt = E(_t, 2),
      at = P(dt);
    S(dt);
    var nt = E(dt, 2);
    {
      var ot = Dt => {
        var Vt = cP();
        B(Dt, Vt)
      };
      Te(nt, Dt => {
        h(Me).role === "admin" && Dt(ot)
      })
    }
    S(rt), S(je);
    var ut = E(je),
      st = P(ut),
      wt = P(st),
      Ct = P(wt);
    vg(Ct, {
      class: "size-4"
    }), S(wt);
    var rr = E(wt, 2),
      Zt = P(rr);
    {
      var lt = Dt => {
          var Vt = uP(),
            Jt = zt(Vt),
            jt = P(Jt);
          jt.__click = async () => {
            try {
              h(Me).loading = !0, await Kr.giveAllianceAdmin(h(Me).id), h(Me).role = "admin"
            } catch {
              Bt.error(kb())
            } finally {
              h(Me).loading = !1
            }
          };
          var nr = P(jt, !0);
          S(jt), S(Jt);
          var St = E(Jt, 2),
            Et = P(St);
          Et.__click = async () => {
            try {
              h(Me).loading = !0, await Kr.banAllianceUser(h(Me).id), _.data = _.data.filter(Gt => Gt.id !== h(Me).id)
            } catch {
              Bt.error(zb())
            } finally {
              h(Me).loading = !1
            }
          };
          var Ut = P(Et, !0);
          S(Et), S(St), ke((Gt, Rt) => {
            jt.disabled = h(Me).loading, ee(nr, Gt), Et.disabled = h(Me).loading, ee(Ut, Rt)
          }, [() => Eb(), () => y0()]), B(Dt, Vt)
        },
        ht = Dt => {
          var Vt = hP(),
            Jt = P(Vt);
          Jt.disabled = !0;
          var jt = P(Jt, !0);
          S(Jt), S(Vt), ke(nr => ee(jt, nr), [() => Lb()]), B(Dt, Vt)
        };
      Te(Zt, Dt => {
        h(Me).role === "member" ? Dt(lt) : Dt(ht, !1)
      })
    }
    S(rr), S(st), S(ut), S(Ue), ke(Dt => {
      var Vt;
      Er(dt, 1, `font-semibold ${Dt??""}`), ee(at, `${(h(Qe)?((Vt=bt.data)==null?void 0:Vt.name)??h(Me).name:h(Me).name)??""} #${h(Me).id??""}`)
    }, [() => Dn(h(Me).id)]), B(Ae, Ue)
  }), S(me), S(he);
  var q = E(he, 2);
  {
    var ye = Ae => {
      var Me = br(),
        Ee = zt(Me);
      bl(Ee, () => _.page, Qe => {
        var Ue = pP();
        qa(Ue, () => je => {
          const rt = new IntersectionObserver(_t => {
            _t[0].isIntersecting && !_.loading && (_.loading = !0, Kr.getAllianceMembers(_.page).then(dt => {
              _.data = [..._.data, ...dt.data], _.hasNextPage = dt.hasNext, _.page++
            }).catch(dt => {
              Bt.error(dt.message)
            }).finally(() => {
              _.loading = !1
            }))
          });
          return rt.observe(je), () => {
            rt.disconnect()
          }
        }), B(Qe, Ue)
      }), B(Ae, Me)
    };
    Te(q, Ae => {
      _.hasNextPage && Ae(ye)
    })
  }
  S(re);
  var be = E(re, 2),
    qe = E(be, 2),
    xe = P(qe),
    Ye = P(xe);
  Hi(Ye, 21, () => x.data, Ae => Ae.id, (Ae, Me, Ee) => {
    var Qe = fP(),
      Ue = P(Qe),
      je = P(Ue),
      rt = P(je);
    bn(rt, {
      class: "size-10 border",
      get userId() {
        return h(Me).id
      },
      get pictureUrl() {
        return h(Me).picture
      }
    });
    var _t = E(rt, 2),
      dt = P(_t);
    S(_t), S(je), S(Ue);
    var at = E(Ue),
      nt = P(at);
    nt.__click = () => {
      Kr.unbanAllianceUser(h(Me).id).then(() => {
        x.data = x.data.filter(ut => ut.id !== h(Me).id)
      }).catch(ut => Bt.error(ut.message)).finally(() => {
        h(Me).loading = !1
      })
    };
    var ot = P(nt, !0);
    S(nt), S(at), S(Qe), ke((ut, st) => {
      Er(_t, 1, `font-semibold ${ut??""}`), ee(dt, `${h(Me).name??""} #${h(Me).id??""}`), nt.disabled = h(Me).loading, ee(ot, st)
    }, [() => Dn(h(Me).id), () => o3()]), B(Ae, Qe)
  }), S(Ye), S(xe);
  var We = E(xe, 2);
  {
    var ze = Ae => {
      var Me = mP(),
        Ee = P(Me, !0);
      S(Me), ke(Qe => ee(Ee, Qe), [() => Db()]), B(Ae, Me)
    };
    Te(We, Ae => {
      !x.hasNextPage && x.data.length === 0 && Ae(ze)
    })
  }
  var Se = E(We, 2);
  {
    var Pe = Ae => {
      var Me = br(),
        Ee = zt(Me);
      bl(Ee, () => x.page, Qe => {
        var Ue = gP();
        qa(Ue, () => je => {
          const rt = new IntersectionObserver(_t => {
            _t[0].isIntersecting && !x.loading && (x.loading = !0, Kr.getAllianceBannedMembers(x.page).then(dt => {
              x.data = [...x.data, ...dt.data], x.hasNextPage = dt.hasNext, x.page++
            }).catch(dt => {
              Bt.error(dt.message)
            }).finally(() => {
              x.loading = !1
            }))
          });
          return rt.observe(je), () => {
            rt.disconnect()
          }
        }), B(Qe, Ue)
      }), B(Ae, Me)
    };
    Te(Se, Ae => {
      x.hasNextPage && Ae(Pe)
    })
  }
  S(qe), S(K), S(k), ke((Ae, Me, Ee) => {
    ee(Z, Ae), Xt(G, "aria-label", Me), Xt(be, "aria-label", Ee)
  }, [() => z0(), () => l3(), () => og()]), B(y, k), Wr()
}
Ui(["click"]);
var yP = ae('<span class="label"> </span>'),
  xP = ae('<span class="hidden px-1 text-[10px] peer-focus:block"> </span>'),
  bP = ae('<p class="text-error ml-3 text-sm"> </p>'),
  wP = ae('<div><label><!> <input class="peer" type="text"/> <!></label> <!></div>');

function bm(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "value", 15),
    x = Ot(l, "validate", 15),
    k = Xe("");
  const z = Je(() => {
    var be;
    return ((be = _()) == null ? void 0 : be.length) ?? 0
  });
  x(T);

  function T() {
    return l.min !== void 0 && h(z) < l.min ? (j(k, h(z) === 0 ? "Required" : `Min. characters: ${l.min}`, !0), !1) : l.max !== void 0 && h(z) > l.max ? (j(k, `Max. characters: ${l.max}`), !1) : !0
  }
  Qr(() => {
    var be;
    l.max !== void 0 && h(z) > l.max && _((be = _()) == null ? void 0 : be.substring(0, l.max))
  });
  var s = wP(),
    F = P(s);
  let Z;
  var K = P(F);
  {
    var G = be => {
      var qe = yP(),
        xe = P(qe, !0);
      S(qe), ke(() => ee(xe, l.label)), B(be, qe)
    };
    Te(K, be => {
      l.label && be(G)
    })
  }
  var re = E(K, 2);
  Ka(re);
  var he = E(re, 2);
  {
    var me = be => {
      var qe = xP(),
        xe = P(qe, !0);
      S(qe), ke(() => ee(xe, l.max - h(z))), B(be, qe)
    };
    Te(he, be => {
      l.max !== void 0 && be(me)
    })
  }
  S(F);
  var q = E(F, 2);
  {
    var ye = be => {
      var qe = bP(),
        xe = P(qe, !0);
      S(qe), ke(() => ee(xe, h(k))), B(be, qe)
    };
    Te(q, be => {
      h(k) && be(ye)
    })
  }
  S(s), ke(() => {
    Z = Er(F, 1, "input w-full", null, Z, {
      "input-error": !!h(k)
    }), Xt(re, "placeholder", l.placeholder), Xt(re, "maxlength", l.max)
  }), Tl(re, _), B(y, s), Wr()
}
var TP = ae('<dialog class="modal" closedby="any"><div class="modal-box"><h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form><div class="my-4"><!></div> <div class="flex w-full justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-primary"> </button></div></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function SP(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "ref", 15),
    x = Xe(!1),
    k = Xe(""),
    z = Xe(void 0);
  var T = TP(),
    s = P(T),
    F = P(s),
    Z = P(F, !0);
  S(F);
  var K = E(F, 2),
    G = P(K),
    re = P(G);
  {
    let qe = Je(() => fm()),
      xe = Je(() => Bb());
    bm(re, {
      get label() {
        return h(qe)
      },
      get placeholder() {
        return h(xe)
      },
      min: 1,
      max: 16,
      get value() {
        return h(k)
      },
      set value(Ye) {
        j(k, Ye, !0)
      },
      get validate() {
        return h(z)
      },
      set validate(Ye) {
        j(z, Ye, !0)
      }
    })
  }
  S(G);
  var he = E(G, 2),
    me = P(he);
  me.__click = () => {
    var qe;
    (qe = _()) == null || qe.close()
  };
  var q = P(me, !0);
  S(me);
  var ye = E(me, 2),
    be = P(ye, !0);
  S(ye), S(he), S(K), S(s), wi(2), S(T), Rn(T, qe => _(qe), () => _()), ke((qe, xe, Ye) => {
    ee(Z, qe), me.disabled = h(x), ee(q, xe), ye.disabled = h(x), ee(be, Ye)
  }, [() => Rb(), () => No(), () => Fb()]), Ci("submit", K, async () => {
    var qe, xe;
    try {
      if (!((qe = h(z)) != null && qe())) return;
      j(x, !0);
      const {
        id: Ye
      } = await Kr.createAlliance(h(k));
      await l.onsuccess(Ye), (xe = _()) == null || xe.close()
    } catch (Ye) {
      Bt.error(Ye.message)
    } finally {
      j(x, !1)
    }
  }), B(y, T), Wr()
}
Ui(["click"]);
var PP = Yr('<svg><path d="M360-440h80v-110h80v110h80v-190l-120-80-120 80v190ZM480-80Q319-217 239.5-334.5T160-552q0-150 96.5-239T480-880q127 0 223.5 89T800-552q0 100-79.5 217.5T480-80Z"></path></svg>');

function IP(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = PP();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var MP = Yr('<svg><path d="M160-160q-33 0-56.5-23.5T80-240v-480q0-33 23.5-56.5T160-800h640q33 0 56.5 23.5T880-720v480q0 33-23.5 56.5T800-160H160Zm320-280L160-640v400h640v-400L480-440Zm0-80 320-200H160l320 200ZM160-640v-80 480-400Z"></path></svg>');

function CP(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = MP();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var AP = Yr('<svg><path d="M720-400v-120H600v-80h120v-120h80v120h120v80H800v120h-80Zm-360-80q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM40-160v-112q0-34 17.5-62.5T104-378q62-31 126-46.5T360-440q66 0 130 15.5T616-378q29 15 46.5 43.5T680-272v112H40Z"></path></svg>');

function kP(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = AP();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var zP = Yr('<svg><path d="M480-480q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM160-160v-112q0-34 17.5-62.5T224-378q62-31 126-46.5T480-440q66 0 130 15.5T736-378q29 15 46.5 43.5T800-272v112H160Z"></path></svg>');

function Vp(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = zP();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}

function EP(y, l = "_blank") {
  return y.replaceAll(/https?:\/\/[^\s]+/g, _ => `<a href="${_}"${l?` target="${l}"`:""}>${_}</a>`)
}
var LP = ae('<div class="flex h-full items-center justify-center"><span class="loading loading-spinner loading-xl"></span></div>'),
  DP = ae('<div class="tooltip"><button class="btn"><!></button></div>'),
  RP = ae('<button class="text-base-content/50 translate-y-0.5 p-1"><!></button>'),
  FP = ae('<section class="text-base-content/80 highlight-link"><!> <!></section>'),
  BP = ae('<span class="font-semibold"> </span>'),
  OP = ae('<button class="text-primary font-semibold underline"> </button>'),
  jP = ae('<span class="text-primary underline"> </span>'),
  qP = ae('<span class="text-primary underline"> </span>'),
  NP = ae('<button class="text-base-content/80 p-1"><!></button>'),
  VP = ae('<div class="flex items-center gap-1"><!> <span> <button class="font-semibold"><!></button></span> <!></div>'),
  UP = ae('<section class="flex items-center justify-between"><h2 class="text-xl font-semibold sm:text-3xl"> </h2> <div class="flex items-center gap-1"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-ghost"><!></div> <ul class="dropdown-content menu bg-base-100 rounded-box z-1 border-base-200 right-0 w-44 translate-y-1 border p-2 shadow-sm"><li><button class="btn btn-soft btn-error"> </button></li></ul></div> <!></div></section> <!> <section class="mt-3"><div class="flex items-center gap-1"><!> <span> <span class="font-semibold"> </span></span></div> <div class="flex items-center gap-1"><!> <span> <!></span></div> <!></section> <section class="mt-6"><h3 class="text-lg font-semibold"> </h3> <div class="mt-1 pb-2"><!></div></section> <!> <!>', 1),
  ZP = ae('<div class="flex h-[90%] flex-col items-center justify-center gap-3"><span class="text-base-content/80"> </span> <span class="mt-8 flex items-center gap-2 text-xl font-semibold"><!> </span> <div class="flex w-full justify-center"><div class="divider w-full max-w-sm"> </div></div> <button class="btn btn-xl btn-soft mb-6"><!> </button></div> <!>', 1),
  GP = ae('<div class="h-full"><!></div>');

function WP(y, l) {
  Gr(l, !0);
  let _ = Xe(void 0),
    x = Xe(!0),
    k = Xe(void 0),
    z = Xe(!1),
    T = Xe(void 0),
    s = Xe(!1),
    F = Xe(!1),
    Z = Xe(() => {});
  fo(() => l.open, () => {
    l.open && fp.shouldReload && K()
  }), Oa(() => {
    const q = setInterval(() => {
      fp.shouldReload = !0
    }, 1e4);
    return () => {
      clearTimeout(q)
    }
  });
  async function K() {
    try {
      j(_, await Kr.getAlliance(), !0), h(_) && h(Z)(), j(x, !1), fp.shouldReload = !1
    } catch (q) {
      Bt.error(q.message)
    }
  }
  var G = GP(),
    re = P(G);
  {
    var he = q => {
        var ye = LP();
        B(q, ye)
      },
      me = q => {
        var ye = br(),
          be = zt(ye);
        {
          var qe = Ye => {
              vP(Ye, {
                onclickback: () => j(F, !1)
              })
            },
            xe = Ye => {
              var We = br(),
                ze = zt(We);
              {
                var Se = Ae => {
                    var Me = UP(),
                      Ee = zt(Me),
                      Qe = P(Ee),
                      Ue = P(Qe, !0);
                    S(Qe);
                    var je = E(Qe, 2),
                      rt = P(je),
                      _t = P(rt),
                      dt = P(_t);
                    vg(dt, {
                      class: "size-4"
                    }), S(_t);
                    var at = E(_t, 2),
                      nt = P(at),
                      ot = P(nt);
                    ot.__click = async () => {
                      try {
                        j(z, !0), await Kr.leaveAlliance(), j(x, !0), await K()
                      } catch (mr) {
                        Bt.error(mr.message)
                      } finally {
                        j(z, !1)
                      }
                    };
                    var ut = P(ot, !0);
                    S(ot), S(nt), S(at), S(rt);
                    var st = E(rt, 2);
                    {
                      var wt = mr => {
                        var ge = DP(),
                          V = P(ge);
                        V.__click = () => {
                          j(s, !0)
                        };
                        var U = P(V);
                        kP(U, {
                          class: "size-4"
                        }), S(V), S(ge), ke(J => Xt(ge, "data-tip", J), [() => Ub()]), B(mr, ge)
                      };
                      Te(st, mr => {
                        h(_).role == "admin" && mr(wt)
                      })
                    }
                    S(je), S(Ee);
                    var Ct = E(Ee, 2);
                    {
                      var rr = mr => {
                        var ge = FP(),
                          V = P(ge);
                        Fp(V, () => EP(h(_).description || v0()));
                        var U = E(V, 2);
                        {
                          var J = se => {
                            var te = RP();
                            te.__click = () => {
                              var Re;
                              (Re = h(T)) == null || Re.show()
                            };
                            var _e = P(te);
                            mm(_e, {
                              class: "size-4"
                            }), S(te), B(se, te)
                          };
                          Te(U, se => {
                            h(_).role === "admin" && se(J)
                          })
                        }
                        S(ge), B(mr, ge)
                      };
                      Te(Ct, mr => {
                        (h(_).description || h(_).role === "admin") && mr(rr)
                      })
                    }
                    var Zt = E(Ct, 2),
                      lt = P(Zt),
                      ht = P(lt);
                    Vo(ht, {
                      class: "inline size-4"
                    });
                    var Dt = E(ht, 2),
                      Vt = P(Dt),
                      Jt = E(Vt),
                      jt = P(Jt, !0);
                    S(Jt), S(Dt), S(lt);
                    var nr = E(lt, 2),
                      St = P(nr);
                    Vp(St, {
                      class: "inline size-4"
                    });
                    var Et = E(St, 2),
                      Ut = P(Et),
                      Gt = E(Ut);
                    {
                      var Rt = mr => {
                          var ge = BP(),
                            V = P(ge, !0);
                          S(ge), ke(U => ee(V, U), [() => h(_).members.toLocaleString(navigator.language)]), B(mr, ge)
                        },
                        ir = mr => {
                          var ge = OP();
                          ge.__click = () => j(F, !0);
                          var V = P(ge, !0);
                          S(ge), ke(U => ee(V, U), [() => h(_).members.toLocaleString(navigator.language)]), B(mr, ge)
                        };
                      Te(Gt, mr => {
                        h(_).role === "member" ? mr(Rt) : mr(ir, !1)
                      })
                    }
                    S(Et), S(nr);
                    var kr = E(nr, 2);
                    {
                      var _r = mr => {
                        var ge = VP(),
                          V = P(ge);
                        IP(V, {
                          class: "inline size-4"
                        });
                        var U = E(V, 2),
                          J = P(U),
                          se = E(J);
                        se.__click = () => {
                          var fe;
                          (fe = h(_)) != null && fe.hq ? l.onhqclick({
                            lat: h(_).hq.latitude,
                            lng: h(_).hq.longitude
                          }) : l.onhqchange()
                        };
                        var te = P(se);
                        {
                          var _e = fe => {
                              var ve = jP(),
                                ie = P(ve);
                              S(ve), ke((Y, Fe) => ee(ie, `${Y??""}, ${Fe??""}`), [() => h(_).hq.latitude.toFixed(3), () => h(_).hq.longitude.toFixed(3)]), B(fe, ve)
                            },
                            Re = fe => {
                              var ve = qP(),
                                ie = P(ve, !0);
                              S(ve), ke(Y => ee(ie, Y), [() => Gb()]), B(fe, ve)
                            };
                          Te(te, fe => {
                            h(_).hq ? fe(_e) : fe(Re, !1)
                          })
                        }
                        S(se), S(U);
                        var ne = E(U, 2);
                        {
                          var oe = fe => {
                            var ve = NP();
                            ve.__click = function(...Y) {
                              var Fe;
                              (Fe = l.onhqchange) == null || Fe.apply(this, Y)
                            };
                            var ie = P(ve);
                            mm(ie, {
                              class: "text-base-content/50 size-4"
                            }), S(ve), B(fe, ve)
                          };
                          Te(ne, fe => {
                            h(_).role === "admin" && fe(oe)
                          })
                        }
                        S(ge), ke(fe => ee(J, `${fe??""}: `), [() => Zb()]), B(mr, ge)
                      };
                      Te(kr, mr => {
                        (h(_).hq || h(_).role === "admin") && mr(_r)
                      })
                    }
                    S(Zt);
                    var fr = E(Zt, 2),
                      Yt = P(fr),
                      sr = P(Yt, !0);
                    S(Yt);
                    var Kt = E(Yt, 2),
                      vr = P(Kt);
                    oP(vr, {
                      get allianceId() {
                        return h(_).id
                      },
                      get onlastpixelclick() {
                        return l.onlastpixelclick
                      },
                      get reload() {
                        return h(Z)
                      },
                      set reload(mr) {
                        j(Z, mr, !0)
                      }
                    }), S(Kt), S(fr);
                    var Lr = E(fr, 2);
                    zS(Lr, {
                      get description() {
                        return h(_).description
                      },
                      onsuccess: async mr => {
                        h(_) && (h(_).description = mr)
                      },
                      get ref() {
                        return h(T)
                      },
                      set ref(mr) {
                        j(T, mr, !0)
                      }
                    });
                    var ii = E(Lr, 2);
                    DS(ii, {
                      get open() {
                        return h(s)
                      },
                      set open(mr) {
                        j(s, mr, !0)
                      }
                    }), ke((mr, ge, V, U, J) => {
                      ee(Ue, h(_).name), ot.disabled = h(z), ee(ut, mr), ee(Vt, `${ge??""}: `), ee(jt, V), ee(Ut, `${U??""}: `), ee(sr, J)
                    }, [() => Ob(), () => Qm(), () => h(_).pixelsPainted.toLocaleString(navigator.language), () => z0(), () => cg()]), B(Ae, Me)
                  },
                  Pe = Ae => {
                    var Me = ZP(),
                      Ee = zt(Me),
                      Qe = P(Ee),
                      Ue = P(Qe);
                    S(Qe);
                    var je = E(Qe, 2),
                      rt = P(je);
                    CP(rt, {
                      class: "size-5"
                    });
                    var _t = E(rt, 1, !0);
                    S(je);
                    var dt = E(je, 2),
                      at = P(dt),
                      nt = P(at, !0);
                    S(at), S(dt);
                    var ot = E(dt, 2);
                    ot.__click = () => {
                      var Ct;
                      (Ct = h(k)) == null || Ct.show()
                    };
                    var ut = P(ot);
                    f0(ut, {
                      class: "size-6"
                    });
                    var st = E(ut);
                    S(ot), S(Ee);
                    var wt = E(Ee, 2);
                    SP(wt, {
                      onsuccess: K,
                      get ref() {
                        return h(k)
                      },
                      set ref(Ct) {
                        j(k, Ct, !0)
                      }
                    }), ke((Ct, rr, Zt, lt) => {
                      ee(Ue, `${Ct??""}:`), ee(_t, rr), ee(nt, Zt), ee(st, ` ${lt??""}`)
                    }, [() => jb(), () => qb(), () => Nb(), () => Vb()]), B(Ae, Me)
                  };
                Te(ze, Ae => {
                  h(_) ? Ae(Se) : Ae(Pe, !1)
                }, !0)
              }
              B(Ye, We)
            };
          Te(be, Ye => {
            h(F) ? Ye(qe) : Ye(xe, !1)
          }, !0)
        }
        B(q, ye)
      };
    Te(re, q => {
      h(x) ? q(he) : q(me, !1)
    })
  }
  S(G), B(y, G), Wr()
}
Ui(["click"]);
var HP = Yr('<svg><path d="M40-160v-160q0-34 23.5-57t56.5-23h131q20 0 38 10t29 27q29 39 71.5 61t90.5 22q49 0 91.5-22t70.5-61q13-17 30.5-27t36.5-10h131q34 0 57 23t23 57v160H640v-91q-35 25-75.5 38T480-200q-43 0-84-13.5T320-252v92H40Zm440-160q-38 0-72-17.5T351-386q-17-25-42.5-39.5T253-440q22-37 93-58.5T480-520q63 0 134 21.5t93 58.5q-29 0-55 14.5T609-386q-22 32-56 49t-73 17ZM160-440q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T280-560q0 50-34.5 85T160-440Zm640 0q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T920-560q0 50-34.5 85T800-440ZM480-560q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T600-680q0 50-34.5 85T480-560Z"></path></svg>');

function Up(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = HP();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var XP = ae('<dialog class="modal" closedby="any"><div class="modal-box sm:h-11/12 flex max-w-3xl flex-col max-sm:size-full max-sm:rounded-none max-sm:px-3 max-sm:py-5"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2"></button></form> <div class="flex items-center gap-1.5"><!> <h3 class="text-lg font-bold max-sm:text-xl"> </h3></div> <div class="mt-1 grow"><!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function YP(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "open", 15);
  var x = XP(),
    k = P(x),
    z = E(P(k), 2),
    T = P(z);
  Up(T, {
    class: "size-5 max-sm:size-6"
  });
  var s = E(T, 2),
    F = P(s, !0);
  S(s), S(z);
  var Z = E(z, 2),
    K = P(Z);
  WP(K, {
    get open() {
      return _()
    },
    get onhqchange() {
      return l.onhqchange
    },
    get onhqclick() {
      return l.onhqclick
    },
    get onlastpixelclick() {
      return l.onlastpixelclick
    }
  }), S(Z), S(k), wi(2), S(x), qa(x, () => G => {
    Qr(() => {
      _() ? (G.show(), xa.url.searchParams.get("alliance") && (xa.url.searchParams.delete("alliance"), xp(xa.url.toString()))) : G.close()
    })
  }), ke(G => ee(F, G), [() => Np()]), Ci("close", x, () => _(!1)), dn(2, Z, () => Jn, () => ({
    duration: 300
  })), B(y, x), Wr()
}

function KP(y, l, _) {
  return new Promise((x, k) => {
    y.once("render", () => {
      const z = y.getCanvas().toDataURL(),
        T = document.createElement("img");
      T.src = z, T.onload = () => {
        const s = document.createElement("canvas");
        s.width = T.width, s.height = T.height;
        const F = s.getContext("2d");
        if (F) {
          F.drawImage(T, 0, 0);
          const [Z, K, G, re] = F.getImageData(l, _, 1, 1).data;
          x([Z, K, G, re])
        } else k(new Error("Could not get 2d context from canvas"));
        T.remove(), s.remove()
      }
    }), y.triggerRepaint()
  })
}

function Ap(y, l) {
  return new Promise((_, x) => {
    y.once("render", () => {
      const k = y.getCanvas();
      let z = k;
      if (l != null && l.maxWidth || l != null && l.maxHeight) {
        const T = k.width,
          s = k.height,
          F = (l == null ? void 0 : l.maxWidth) ?? T,
          Z = (l == null ? void 0 : l.maxHeight) ?? s;
        z = document.createElement("canvas");
        const K = Math.min(F / T, Z / s);
        z.width = Math.floor(T * K), z.height = Math.floor(s * K);
        const G = z.getContext("2d");
        G && G.drawImage(k, 0, 0, z.width, z.height)
      }
      try {
        z.toBlob(T => {
          T && _(T)
        }, (l == null ? void 0 : l.type) ?? "image/png", (l == null ? void 0 : l.quality) ?? 1)
      } catch (T) {
        x(T)
      } finally {
        z !== k && z.remove()
      }
    })
  })
}
var JP = Yr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm40-80h480L570-480 450-320l-90-120-120 160Zm-40 80v-560 560Z"></path></svg>');

function $P(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = JP();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var QP = Yr('<svg><path d="M680-80q-50 0-85-35t-35-85q0-6 3-28L282-392q-16 15-37 23.5t-45 8.5q-50 0-85-35t-35-85q0-50 35-85t85-35q24 0 45 8.5t37 23.5l281-164q-2-7-2.5-13.5T560-760q0-50 35-85t85-35q50 0 85 35t35 85q0 50-35 85t-85 35q-24 0-45-8.5T598-672L317-508q2 7 2.5 13.5t.5 14.5q0 8-.5 14.5T317-452l281 164q16-15 37-23.5t45-8.5q50 0 85 35t35 85q0 50-35 85t-85 35Z"></path></svg>');

function hy(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = QP();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
const Ic = {
  hour: 3600 * 1e3,
  min: 60 * 1e3,
  sec: 1e3
};

function dy(y) {
  const l = Math.floor(y / Ic.hour);
  y -= l * Ic.hour;
  const _ = Math.floor(y / Ic.min);
  y -= _ * Ic.min;
  const k = Math.floor(y / Ic.sec).toString().padStart(2, "0");
  return l > 0 ? `${l}:${_.toString().padStart(2,"0")}:${k}` : `${_}:${k}`
}

function eI(y) {
  const l = y.getFullYear(),
    _ = String(y.getMonth() + 1).padStart(2, "0"),
    x = String(y.getDate()).padStart(2, "0"),
    k = String(y.getHours()).padStart(2, "0"),
    z = String(y.getMinutes()).padStart(2, "0"),
    T = String(y.getSeconds()).padStart(2, "0");
  return `${l}-${_}-${x} ${k}:${z}:${T}`
}
var tI = ae('<div class="text-base-content/80 mt-2 text-xs"><span class="font-semibold"> </span> </div>'),
  rI = ae('<img class="border-base-content/20 border" alt="Screenshot"/>'),
  iI = ae('<div class="flex w-full items-center justify-center"><span class="loading loading-spinner"></span></div>'),
  aI = ae('<div><h3 class="mb-1 mt-4 flex items-center gap-1 text-xl font-semibold"><!> </h3> <!> <div class="mt-3 flex items-end justify-end gap-2"><button class="btn"><!> </button> <a class="btn btn-primary"><!> </a></div></div>'),
  nI = ae('<dialog class="modal" closedby="any"><div class="modal-box max-h-11/12"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2"></button></form> <h3 class="flex items-center gap-1.5 text-xl font-bold"><!> </h3> <div class="border-base-content/20 rounded-field mt-3 flex w-full items-center gap-1 border-2 py-1.5 pl-4 pr-2.5"><input class="text-base-content/80 min-w-10 grow text-sm font-medium" readonly=""/> <div class="h-10"><button> </button></div></div> <!> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function sI(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "open", 15),
    x = Xe(!1),
    k = Xe(null),
    z = Xe("");
  const T = Je(() => {
    const ze = new URL(l.url.toString()),
      Se = ze.searchParams.get("lat"),
      Pe = ze.searchParams.get("lng");
    if (Se && Pe) return {
      lat: parseFloat(Se),
      lng: parseFloat(Pe)
    }
  });
  Qr(() => {
    _() ? (l.hideHover(), setTimeout(async () => {
      Ap(l.map).then(ze => {
        j(k, ze, !0), j(z, URL.createObjectURL(h(k)), !0)
      }).finally(() => {
        l.showHover()
      })
    }, 500)) : h(z) && (URL.revokeObjectURL(h(z)), j(k, null), j(z, ""))
  });
  var s = nI(),
    F = P(s),
    Z = E(P(F), 2),
    K = P(Z);
  hy(K, {
    class: "size-5"
  });
  var G = E(K);
  S(Z);
  var re = E(Z, 2),
    he = P(re);
  Ka(he);
  var me = E(he, 2),
    q = P(me);
  let ye;
  q.__click = () => {
    navigator.clipboard.writeText(l.url.toString()), j(x, !0), setTimeout(() => {
      j(x, !1)
    }, 1e3)
  };
  var be = P(q, !0);
  S(q), S(me), S(re);
  var qe = E(re, 2);
  {
    var xe = ze => {
      var Se = tI(),
        Pe = P(Se),
        Ae = P(Pe);
      S(Pe);
      var Me = E(Pe);
      S(Se), ke(Ee => {
        ee(Ae, `${Ee??""}:`), ee(Me, ` ${h(T).lat??""}, ${h(T).lng??""}`)
      }, [() => x0()]), B(ze, Se)
    };
    Te(qe, ze => {
      h(T) && ze(xe)
    })
  }
  var Ye = E(qe, 2);
  {
    var We = ze => {
      const Se = Je(() => {
        var st;
        return (st = l.map) == null ? void 0 : st.getCanvas()
      });
      var Pe = aI(),
        Ae = P(Pe),
        Me = P(Ae);
      $P(Me, {
        class: "inline size-5"
      });
      var Ee = E(Me);
      S(Ae);
      var Qe = E(Ae, 2);
      {
        var Ue = st => {
            var wt = rI();
            ke(() => {
              Xt(wt, "src", h(z)), Xt(wt, "width", h(Se).width), Xt(wt, "height", h(Se).height)
            }), B(st, wt)
          },
          je = st => {
            var wt = iI();
            ke(() => Qn(wt, `aspect-ratio: ${h(Se).width/h(Se).height}`)), B(st, wt)
          };
        Te(Qe, st => {
          h(z) ? st(Ue) : st(je, !1)
        })
      }
      var rt = E(Qe, 2),
        _t = P(rt);
      _t.__click = async () => {
        h(k) && (await navigator.clipboard.write([new ClipboardItem({
          "image/png": h(k)
        })]), Bt.info(Hb()))
      };
      var dt = P(_t);
      ug(dt, {
        class: "size-5"
      });
      var at = E(dt);
      S(_t);
      var nt = E(_t, 2),
        ot = P(nt);
      lg(ot, {
        class: "size-5"
      });
      var ut = E(ot);
      S(nt), S(rt), S(Pe), ke((st, wt, Ct, rr) => {
        ee(Ee, ` ${st??""}`), ee(at, ` ${wt??""}`), Xt(nt, "href", h(z)), Xt(nt, "download", `wplace_${Ct??""}.png`), ee(ut, ` ${rr??""}`)
      }, [() => Xb(), () => pm(), () => eI(new Date).replaceAll(" ", "_").replaceAll(":", "-"), () => Yb()]), dn(2, Pe, () => Jn, () => ({
        duration: 300
      })), B(ze, Pe)
    };
    Te(Ye, ze => {
      _() && ze(We)
    })
  }
  S(F), wi(2), S(s), qa(s, () => ze => {
    Qr(() => {
      _() ? ze.show() : ze.close()
    })
  }), ke((ze, Se, Pe) => {
    ee(G, ` ${ze??""}`), Ym(he, Se), ye = Er(q, 1, "btn btn-primary", null, ye, {
      "btn-success": h(x)
    }), ee(be, Pe)
  }, [() => Wb(), () => l.url.toString(), () => h(x) ? eg() : pm()]), Ci("close", s, () => _(!1)), B(y, s), Wr()
}
Ui(["click"]);
var oI = Yr('<svg><path d="m576-160-56-56 104-104-104-104 56-56 104 104 104-104 56 56-104 104 104 104-56 56-104-104-104 104Zm79-360L513-662l56-56 85 85 170-170 56 57-225 226ZM80-280v-80h360v80H80Zm0-320v-80h360v80H80Z"></path></svg>');

function lI(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = oI();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var cI = ae('<li class="bg-base-200 border-base-content/10 rounded-xl border-2 p-3"> </li>'),
  uI = ae('<div><div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold"> <span class="badge badge-sm badge-error badge-soft ml-1"> </span></h3></div> <div class="text-sm sm:text-base"><ul class="my-3 flex flex-col gap-2 font-medium"></ul> <p class="text-base-content/80 mt-2 text-sm"> </p> <p class="text-base-content/80 mt-0.5 text-sm"> <a class="link" href="/terms/code-of-conduct" target="_blank"> </a>.</p></div></div>');

function py(y, l) {
  Gr(l, !1);
  const _ = [t2(), r2(), i2(), a2(), n2(), s2(), o2()];
  $m();
  var x = uI(),
    k = P(x),
    z = P(k);
  lI(z, {
    class: "size-5"
  });
  var T = E(z, 2),
    s = P(T),
    F = E(s),
    Z = P(F, !0);
  S(F), S(T), S(k);
  var K = E(k, 2),
    G = P(K);
  Hi(G, 5, () => _, po, (qe, xe) => {
    var Ye = cI(),
      We = P(Ye, !0);
    S(Ye), ke(() => ee(We, h(xe))), B(qe, Ye)
  }), S(G);
  var re = E(G, 2),
    he = P(re, !0);
  S(re);
  var me = E(re, 2),
    q = P(me),
    ye = E(q),
    be = P(ye, !0);
  S(ye), wi(), S(me), S(K), S(x), ke((qe, xe, Ye, We, ze) => {
    ee(s, `${qe??""} `), ee(Z, xe), ee(he, Ye), ee(q, `${We??""} `), ee(be, ze)
  }, [() => Kb(), () => Jb(), () => $b(), () => Qb(), () => e2()]), B(y, x), Wr()
}
var hI = ae('<dialog class="modal" closedby="any"><div class="modal-box max-h-11/12"><section class="mb-6 flex justify-center"><h2 class="font-pixel flex flex-col justify-center"><span class="text-center text-2xl"> </span> <!></h2></section> <section class="my-2"><!></section> <form class="mt-6 flex justify-center" method="dialog"><button class="btn btn-primary sm:btn-lg"> </button></form></div></dialog>');

function dI(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "open", 15);
  var x = hI(),
    k = P(x),
    z = P(k),
    T = P(z),
    s = P(T),
    F = P(s, !0);
  S(s);
  var Z = E(s, 2);
  R0(Z, {
    hasText: !0,
    size: "medium"
  }), S(T), S(z);
  var K = E(z, 2),
    G = P(K);
  py(G, {}), S(K);
  var re = E(K, 2),
    he = P(re);
  he.__click = () => {
    xa.url.searchParams.delete("new-user"), xp(xa.url.toString())
  };
  var me = P(he, !0);
  S(he), S(re), S(k), S(x), qa(x, () => q => {
    Qr(() => {
      _() ? q.show() : q.close()
    })
  }), ke((q, ye) => {
    ee(F, q), ee(me, ye)
  }, [() => l2(), () => c2()]), Ci("close", x, () => _(!1)), B(y, x), Wr()
}
Ui(["click"]);

function pI() {
  const y = navigator.userAgent,
    l = navigator.vendor;
  return /Chrome/.test(y) && /Google Inc/.test(l) ? "Chrome" : /Safari/.test(y) && /Apple Computer/.test(l) ? "Safari" : /Firefox/.test(y) ? "Firefox" : /Edge/.test(y) ? "Edge" : /Opera|OPR/.test(y) ? "Opera" : "Unknown"
}
var fI = Yr('<svg><path d="M358.939 44C384.805 44 405.773 64.9683 405.773 90.834C405.773 116.7 384.805 137.668 358.939 137.668C335.282 137.668 315.725 120.127 312.558 97.3418C311.882 97.5076 311.068 97.7132 310.139 97.9658C307.227 98.7577 303.219 99.9781 298.844 101.688C289.898 105.186 280.227 110.425 274.75 117.568C269.021 125.042 265.37 135.158 263.158 143.737C262.067 147.97 261.355 151.71 260.917 154.385C260.789 155.166 260.687 155.855 260.604 156.437C304.314 157.147 344.347 169.064 375.81 188.514C386.896 180.117 400.712 175.135 415.691 175.135C452.208 175.135 481.811 204.738 481.811 241.254C481.81 267.527 466.485 290.221 444.287 300.885C441.861 377.201 358.696 438.508 256.456 438.508C154.451 438.508 71.4321 377.482 68.6426 301.409C45.8419 290.978 30.0001 267.967 30 241.254C30 204.738 59.6021 175.135 96.1182 175.135C111.321 175.135 125.325 180.267 136.494 188.892C167.617 169.488 207.216 157.484 250.507 156.473C250.517 156.392 250.528 156.307 250.539 156.218C250.646 155.398 250.811 154.224 251.049 152.771C251.524 149.867 252.293 145.823 253.475 141.24C255.808 132.188 259.872 120.54 266.814 111.484C274.011 102.098 285.828 96.04 295.202 92.375C299.987 90.5044 304.348 89.1775 307.514 88.3164C309.099 87.8852 310.394 87.568 311.302 87.3574C311.69 87.2673 312.009 87.1968 312.249 87.1445C314.13 63.0035 334.316 44.0001 358.939 44ZM255.905 334.922C234.07 334.922 213.107 336.328 193.621 338.913C190.267 341.144 188.408 343.008 187.698 344.95C187.085 346.63 187.361 348.283 188.093 350.118C200.137 369.374 217.021 383.431 236.377 389.255C237.939 389.694 239.551 390.118 241.216 390.527C246.165 391.641 251.258 392.225 256.456 392.225C283.556 392.224 307.779 376.436 323.849 351.639C325.103 348.78 325.526 346.501 324.943 344.546C324.28 342.322 322.364 340.66 319.327 339.067C299.52 336.385 278.166 334.922 255.905 334.922ZM167.196 240.151C148.634 240.151 133.586 257.42 133.586 278.721C133.586 300.022 148.634 317.29 167.196 317.29C185.759 317.29 200.806 300.022 200.806 278.721C200.806 257.42 185.759 240.152 167.196 240.151ZM343.512 240.151C324.949 240.152 309.901 257.42 309.901 278.721C309.901 300.022 324.949 317.29 343.512 317.29C362.074 317.29 377.122 300.022 377.122 278.721C377.122 257.42 362.074 240.151 343.512 240.151Z"></path></svg>');

function mI(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = fI();
  jr(x, () => ({
    viewBox: "0 0 512 512",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ..._
  })), B(y, x)
}
var gI = Yr('<svg><path d="M216.856 16.597A208.502 208.502 0 0 0 164.042 0c-2.275 4.113-4.933 9.645-6.766 14.046-19.692-2.961-39.203-2.961-58.533 0-1.832-4.4-4.55-9.933-6.846-14.046a207.809 207.809 0 0 0-52.855 16.638C5.618 67.147-3.443 116.4 1.087 164.956c22.169 16.555 43.653 26.612 64.775 33.193A161.094 161.094 0 0 0 79.735 175.3a136.413 136.413 0 0 1-21.846-10.632 108.636 108.636 0 0 0 5.356-4.237c42.122 19.702 87.89 19.702 129.51 0a131.66 131.66 0 0 0 5.355 4.237 136.07 136.07 0 0 1-21.886 10.653c4.006 8.02 8.638 15.67 13.873 22.848 21.142-6.58 42.646-16.637 64.815-33.213 5.316-56.288-9.08-105.09-38.056-148.36ZM85.474 135.095c-12.645 0-23.015-11.805-23.015-26.18s10.149-26.2 23.015-26.2c12.867 0 23.236 11.804 23.015 26.2.02 14.375-10.148 26.18-23.015 26.18Zm85.051 0c-12.645 0-23.014-11.805-23.014-26.18s10.148-26.2 23.014-26.2c12.867 0 23.236 11.804 23.015 26.2 0 14.375-10.148 26.18-23.015 26.18Z"></path></svg>');

function wm(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = gI();
  jr(x, () => ({
    viewBox: "0 0 256 199",
    width: "256",
    height: "199",
    xmlns: "http://www.w3.org/2000/svg",
    preserveAspectRatio: "xMidYMid",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var _I = Yr('<svg><path d="M128 23.064c34.177 0 38.225.13 51.722.745 12.48.57 19.258 2.655 23.769 4.408 5.974 2.322 10.238 5.096 14.717 9.575 4.48 4.479 7.253 8.743 9.575 14.717 1.753 4.511 3.838 11.289 4.408 23.768.615 13.498.745 17.546.745 51.723 0 34.178-.13 38.226-.745 51.723-.57 12.48-2.655 19.257-4.408 23.768-2.322 5.974-5.096 10.239-9.575 14.718-4.479 4.479-8.743 7.253-14.717 9.574-4.511 1.753-11.289 3.839-23.769 4.408-13.495.616-17.543.746-51.722.746-34.18 0-38.228-.13-51.723-.746-12.48-.57-19.257-2.655-23.768-4.408-5.974-2.321-10.239-5.095-14.718-9.574-4.479-4.48-7.253-8.744-9.574-14.718-1.753-4.51-3.839-11.288-4.408-23.768-.616-13.497-.746-17.545-.746-51.723 0-34.177.13-38.225.746-51.722.57-12.48 2.655-19.258 4.408-23.769 2.321-5.974 5.095-10.238 9.574-14.717 4.48-4.48 8.744-7.253 14.718-9.575 4.51-1.753 11.288-3.838 23.768-4.408 13.497-.615 17.545-.745 51.723-.745M128 0C93.237 0 88.878.147 75.226.77c-13.625.622-22.93 2.786-31.071 5.95-8.418 3.271-15.556 7.648-22.672 14.764C14.367 28.6 9.991 35.738 6.72 44.155 3.555 52.297 1.392 61.602.77 75.226.147 88.878 0 93.237 0 128c0 34.763.147 39.122.77 52.774.622 13.625 2.785 22.93 5.95 31.071 3.27 8.417 7.647 15.556 14.763 22.672 7.116 7.116 14.254 11.492 22.672 14.763 8.142 3.165 17.446 5.328 31.07 5.95 13.653.623 18.012.77 52.775.77s39.122-.147 52.774-.77c13.624-.622 22.929-2.785 31.07-5.95 8.418-3.27 15.556-7.647 22.672-14.763 7.116-7.116 11.493-14.254 14.764-22.672 3.164-8.142 5.328-17.446 5.95-31.07.623-13.653.77-18.012.77-52.775s-.147-39.122-.77-52.774c-.622-13.624-2.786-22.929-5.95-31.07-3.271-8.418-7.648-15.556-14.764-22.672C227.4 14.368 220.262 9.99 211.845 6.72c-8.142-3.164-17.447-5.328-31.071-5.95C167.122.147 162.763 0 128 0Zm0 62.27C91.698 62.27 62.27 91.7 62.27 128c0 36.302 29.428 65.73 65.73 65.73 36.301 0 65.73-29.428 65.73-65.73 0-36.301-29.429-65.73-65.73-65.73Zm0 108.397c-23.564 0-42.667-19.103-42.667-42.667S104.436 85.333 128 85.333s42.667 19.103 42.667 42.667-19.103 42.667-42.667 42.667Zm83.686-110.994c0 8.484-6.876 15.36-15.36 15.36-8.483 0-15.36-6.876-15.36-15.36 0-8.483 6.877-15.36 15.36-15.36 8.484 0 15.36 6.877 15.36 15.36Z"></path></svg>');

function vI(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = _I();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "currentColor",
    preserveAspectRatio: "xMidYMid",
    viewBox: "0 0 260 260",
    ..._
  })), B(y, x)
}
var yI = Yr('<svg><path d="M240-640h360v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85h-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640Zm0 480h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM240-160v-400 400Z"></path></svg>');

function kp(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = yI();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var xI = Yr(`<svg><path d="M12.75 2c.39 0 .708.316.75.704a5.735 5.735 0 0 0 
  4.112 4.751c.257.077.523.127.801.149.394.028.713.35.713.744v2.289a.75.75 
  0 0 1-.826.746 8.89 8.89 0 0 1-3.546-1.239v6.43a5.465 5.465 0 
  1 1-5.465-5.465c.388 0 .765.042 1.128.122a.75.75 0 0 
  1 .593.732v2.289a.75.75 0 0 1-.979.715 1.549 1.549 0 0 
  0-.482-.077 1.962 1.962 0 1 0 1.962 1.962V2.75a.75.75 0 0 1 
  .75-.75h1.239Z"></path></svg>`);

function bI(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = xI();
  jr(x, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-label": "Tiktok",
    ..._
  })), B(y, x)
}
var wI = Yr(`<svg><path d="M23.498 6.186a2.986 2.986 0 0 0-2.103-2.115C19.505 
    3.5 12 3.5 12 3.5s-7.505 0-9.395.571a2.986 2.986 0 0 0-2.103 
    2.115C0 8.082 0 12 0 12s0 3.918.502 5.814a2.986 2.986 0 0 0 
    2.103 2.115C4.495 20.5 12 20.5 12 20.5s7.505 0 9.395-.571a2.986 
    2.986 0 0 0 2.103-2.115C24 15.918 24 12 24 12s0-3.918-.502-5.814zM9.75 
    15.021v-6.042L15.5 12l-5.75 3.021z"></path></svg>`);

function TI(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = wI();
  jr(x, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-label": "YouTube",
    ..._
  })), B(y, x)
}
var SI = ae(' <a class="link" href="https://help.constructiononline.com/en/scheduling-webgl-and-hardware-acceleration">link</a>', 1),
  PI = ae('<span class="link cursor-auto">chrome://settings/system</span>.', 1),
  II = ae('<span class="link cursor-auto">edge://settings/system/manageSystem</span>.', 1),
  MI = ae(' <kbd class="kbd kbd-sm h-fit px-3"> </kbd> <!>', 1),
  CI = ae('<div class="flex h-full flex-col gap-5"><section class="mb-2 flex flex-col items-center justify-center gap-2"><!> <div class="text-center text-sm max-sm:mt-1"> <a class="link" href="https://maplibre.org/" target="_blank">MapLibre</a> | <a class="link" href="https://openfreemap.org/" target="_blank">OpenFreeMap</a> <a class="link" href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a></div> <div class="w-full text-center text-sm"><p><a href="https://discord.gg/wplacelive" target="_blank" class="text-nowrap"><!> <span class="link">Discord</span></a> <span class="mx-0.5">|</span> <a href="https://www.reddit.com/r/WplaceLive/" target="_blank" class="text-nowrap"><!> <span class="link">Reddit</span></a> <span class="mx-0.5">|</span> <a href="https://www.instagram.com/wplace.live/" target="_blank" class="text-nowrap"><!> <span class="link">Instagram</span></a> <span class="mx-0.5">|</span> <a href="https://www.youtube.com/@WplaceLive" target="_blank" class="text-nowrap"><!> <span class="link">Youtube</span></a> <span class="mx-0.5">|</span> <a href="https://www.tiktok.com/@wplace5" target="_blank" class="text-nowrap"><!> <span class="link">Tiktok</span></a></p></div></section> <section><h3 class="text-lg font-semibold"> </h3> <iframe class="mt-1 aspect-video w-full bg-black" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe></section> <section><h3 class="text-lg font-semibold"> </h3> <p class="not-touchscreen:hidden text-sm"> <button class="btn btn-square shadow-md"><!></button> </p> <p class="touchscreen:hidden text-sm"> <span class="kbd kbd-xs text-base-content rounded-md"> </span> </p></section> <section><h3 class="text-lg font-semibold"> </h3> <p class="text-sm"><!></p></section> <section><!></section> <div class="grow"></div> <section class="text-base-content/80 w-full text-center text-sm max-sm:pb-4"><span>Email: <a class="link" href="mailto:contact@wplace.live">contact@wplace.live</a></span>  <a class="link" target="_blank"> </a>  <a class="link" target="_blank"> </a>  <a class="link" target="_blank"> </a>  <a class="link" href="https://forms.gle/EVG7A1ZoSyJWAjX96" target="_blank"> </a>  <a class="link" href="https://forms.gle/uinGA5Gj4SpPYa2R6" target="_blank"> </a></section></div>'),
  AI = ae('<dialog class="modal" closedby="any"><div class="modal-box sm:max-h-11/12 max-sm:size-full max-sm:rounded-none max-sm:px-4 sm:max-w-5xl"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2"></button></form> <!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>');

function kI(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "open", 15);
  const x = pI();
  var k = AI(),
    z = P(k),
    T = E(P(z), 2);
  {
    var s = G => {
      var re = CI(),
        he = P(re),
        me = P(he);
      R0(me, {
        hasText: !0,
        size: "medium"
      });
      var q = E(me, 2),
        ye = P(q),
        be = E(ye, 4);
      wi(), S(q);
      var qe = E(q, 2),
        xe = P(qe),
        Ye = P(xe),
        We = P(Ye);
      wm(We, {
        class: "text-base-content mr-0.5 inline size-4"
      }), wi(2), S(Ye);
      var ze = E(Ye, 4),
        Se = P(ze);
      mI(Se, {
        class: "size-4.5 mr-0.5 inline"
      }), wi(2), S(ze);
      var Pe = E(ze, 4),
        Ae = P(Pe);
      vI(Ae, {
        class: "mr-0.5 inline size-3.5"
      }), wi(2), S(Pe);
      var Me = E(Pe, 4),
        Ee = P(Me);
      TI(Ee, {
        class: "mr-0.5 inline size-3.5"
      }), wi(2), S(Me);
      var Qe = E(Me, 4),
        Ue = P(Qe);
      bI(Ue, {
        class: "mr-0.5 inline size-3.5"
      }), wi(2), S(Qe), S(xe), S(qe), S(he);
      var je = E(he, 2),
        rt = P(je),
        _t = P(rt, !0);
      S(rt);
      var dt = E(rt, 2);
      S(je);
      var at = E(je, 2),
        nt = P(at),
        ot = P(nt, !0);
      S(nt);
      var ut = E(nt, 2),
        st = P(ut),
        wt = E(st),
        Ct = P(wt);
      kp(Ct, {
        class: "size-5"
      }), S(wt);
      var rr = E(wt);
      S(ut);
      var Zt = E(ut, 2),
        lt = P(Zt),
        ht = E(lt),
        Dt = P(ht, !0);
      S(ht);
      var Vt = E(ht);
      S(Zt), S(at);
      var Jt = E(at, 2),
        jt = P(Jt),
        nr = P(jt, !0);
      S(jt);
      var St = E(jt, 2),
        Et = P(St);
      {
        var Ut = V => {
            var U = SI(),
              J = zt(U);
            wi(), ke(se => ee(J, `${se??""}: `), [() => S2()]), B(V, U)
          },
          Gt = V => {
            var U = MI(),
              J = zt(U),
              se = E(J),
              te = P(se, !0);
            S(se);
            var _e = E(se),
              Re = E(_e);
            {
              var ne = fe => {
                  var ve = PI();
                  wi(), B(fe, ve)
                },
                oe = fe => {
                  var ve = br(),
                    ie = zt(ve);
                  {
                    var Y = Fe => {
                      var Ne = II();
                      wi(), B(Fe, Ne)
                    };
                    Te(ie, Fe => {
                      x === "Edge" && Fe(Y)
                    }, !0)
                  }
                  B(fe, ve)
                };
              Te(Re, fe => {
                x === "Chrome" ? fe(ne) : fe(oe, !1)
              })
            }
            ke((fe, ve, ie) => {
              ee(J, `${fe??""} `), ee(te, ve), ee(_e, ` ${ie??""} `)
            }, [() => P2(), () => I2(), () => M2()]), B(V, U)
          };
        Te(Et, V => {
          x !== "Chrome" && x !== "Edge" ? V(Ut) : V(Gt, !1)
        })
      }
      S(St), S(Jt);
      var Rt = E(Jt, 2),
        ir = P(Rt);
      py(ir, {}), S(Rt);
      var kr = E(Rt, 4),
        _r = E(P(kr), 2),
        fr = P(_r, !0);
      S(_r);
      var Yt = E(_r, 2),
        sr = P(Yt, !0);
      S(Yt);
      var Kt = E(Yt, 2),
        vr = P(Kt, !0);
      S(Kt);
      var Lr = E(Kt, 2),
        ii = P(Lr, !0);
      S(Lr);
      var mr = E(Lr, 2),
        ge = P(mr, !0);
      S(mr), S(kr), S(re), ke((V, U, J, se, te, _e, Re, ne, oe, fe, ve, ie, Y, Fe, Ne, Ge, pe) => {
        ee(ye, `${V??""} `), ee(be, ` 
						${U??""} `), ee(_t, J), Xt(dt, "src", vn.language === "pt" ? "https://www.youtube.com/embed/AcE85QM4iPQ?si=wbeZD8vxOzvlB_Z9" : "https://www.youtube.com/embed/xOXtd-WzRxA?si=fHz8Z6ecXGYrDhkN"), ee(ot, se), ee(st, `${te??""} `), ee(rr, ` ${_e??""}`), ee(lt, `${Re??""} `), ee(Dt, ne), ee(Vt, ` ${oe??""}`), ee(nr, fe), Xt(_r, "href", ve), ee(fr, ie), Xt(Yt, "href", `${xa.url.origin??""}/terms/privacy`), ee(sr, Y), Xt(Kt, "href", Fe), ee(vr, Ne), ee(ii, Ge), ee(ge, pe)
      }, [() => u2(), () => h2(), () => d2(), () => p2(), () => f2(), () => m2(), () => g2(), () => _2(), () => v2(), () => y2(), S3, () => x2(), () => b2(), F0, () => b0(), () => w2(), () => T2()]), dn(2, re, () => Jn, () => ({
        duration: 300
      })), B(G, re)
    };
    Te(T, G => {
      _() && G(s)
    })
  }
  S(z);
  var F = E(z, 2),
    Z = P(F),
    K = P(Z, !0);
  S(Z), S(F), S(k), qa(k, () => G => {
    Qr(() => {
      _() ? G.show() : G.close()
    })
  }), ke(G => ee(K, G), [() => uo()]), Ci("close", k, () => _(!1)), B(y, k), Wr()
}

function zI(y) {
  return y !== null && typeof y == "object"
}
const EI = ["string", "number", "bigint", "boolean"];

function Tm(y) {
  return y == null || EI.includes(typeof y) ? !0 : Array.isArray(y) ? y.every(l => Tm(l)) : typeof y == "object" ? Object.getPrototypeOf(y) === Object.prototype : !1
}
const Sm = Symbol("box"),
  LI = Symbol("is-writable");

function Gi(y, l) {
  const _ = Je(y);
  return l ? {
    [Sm]: !0,
    [LI]: !0,
    get current() {
      return h(_)
    },
    set current(x) {
      l(x)
    }
  } : {
    [Sm]: !0,
    get current() {
      return y()
    }
  }
}

function DI(y) {
  return zI(y) && Sm in y
}

function RI(...y) {
  return function(l) {
    var _;
    for (const x of y)
      if (x) {
        if (l.defaultPrevented) return;
        typeof x == "function" ? x.call(this, l) : (_ = x.current) == null || _.call(this, l)
      }
  }
}
var Hv = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g,
  FI = /\n/g,
  BI = /^\s*/,
  OI = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/,
  jI = /^:\s*/,
  qI = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/,
  NI = /^[;\s]*/,
  VI = /^\s+|\s+$/g,
  UI = `
`,
  Xv = "/",
  Yv = "*",
  ml = "",
  ZI = "comment",
  GI = "declaration";

function WI(y, l) {
  if (typeof y != "string") throw new TypeError("First argument must be a string");
  if (!y) return [];
  l = l || {};
  var _ = 1,
    x = 1;

  function k(me) {
    var q = me.match(FI);
    q && (_ += q.length);
    var ye = me.lastIndexOf(UI);
    x = ~ye ? me.length - ye : x + me.length
  }

  function z() {
    var me = {
      line: _,
      column: x
    };
    return function(q) {
      return q.position = new T(me), Z(), q
    }
  }

  function T(me) {
    this.start = me, this.end = {
      line: _,
      column: x
    }, this.source = l.source
  }
  T.prototype.content = y;

  function s(me) {
    var q = new Error(l.source + ":" + _ + ":" + x + ": " + me);
    if (q.reason = me, q.filename = l.source, q.line = _, q.column = x, q.source = y, !l.silent) throw q
  }

  function F(me) {
    var q = me.exec(y);
    if (q) {
      var ye = q[0];
      return k(ye), y = y.slice(ye.length), q
    }
  }

  function Z() {
    F(BI)
  }

  function K(me) {
    var q;
    for (me = me || []; q = G();) q !== !1 && me.push(q);
    return me
  }

  function G() {
    var me = z();
    if (!(Xv != y.charAt(0) || Yv != y.charAt(1))) {
      for (var q = 2; ml != y.charAt(q) && (Yv != y.charAt(q) || Xv != y.charAt(q + 1));) ++q;
      if (q += 2, ml === y.charAt(q - 1)) return s("End of comment missing");
      var ye = y.slice(2, q - 2);
      return x += 2, k(ye), y = y.slice(q), x += 2, me({
        type: ZI,
        comment: ye
      })
    }
  }

  function re() {
    var me = z(),
      q = F(OI);
    if (q) {
      if (G(), !F(jI)) return s("property missing ':'");
      var ye = F(qI),
        be = me({
          type: GI,
          property: Kv(q[0].replace(Hv, ml)),
          value: ye ? Kv(ye[0].replace(Hv, ml)) : ml
        });
      return F(NI), be
    }
  }

  function he() {
    var me = [];
    K(me);
    for (var q; q = re();) q !== !1 && (me.push(q), K(me));
    return me
  }
  return Z(), he()
}

function Kv(y) {
  return y ? y.replace(VI, ml) : ml
}

function HI(y, l) {
  let _ = null;
  if (!y || typeof y != "string") return _;
  const x = WI(y),
    k = typeof l == "function";
  return x.forEach(z => {
    if (z.type !== "declaration") return;
    const {
      property: T,
      value: s
    } = z;
    k ? l(T, s, z) : s && (_ = _ || {}, _[T] = s)
  }), _
}
const XI = /\d/,
  YI = ["-", "_", "/", "."];

function KI(y = "") {
  if (!XI.test(y)) return y !== y.toLowerCase()
}

function JI(y) {
  const l = [];
  let _ = "",
    x, k;
  for (const z of y) {
    const T = YI.includes(z);
    if (T === !0) {
      l.push(_), _ = "", x = void 0;
      continue
    }
    const s = KI(z);
    if (k === !1) {
      if (x === !1 && s === !0) {
        l.push(_), _ = z, x = s;
        continue
      }
      if (x === !0 && s === !1 && _.length > 1) {
        const F = _.at(-1);
        l.push(_.slice(0, Math.max(0, _.length - 1))), _ = F + z, x = s;
        continue
      }
    }
    _ += z, x = s, k = T
  }
  return l.push(_), l
}

function fy(y) {
  return y ? JI(y).map(l => QI(l)).join("") : ""
}

function $I(y) {
  return eM(fy(y || ""))
}

function QI(y) {
  return y ? y[0].toUpperCase() + y.slice(1) : ""
}

function eM(y) {
  return y ? y[0].toLowerCase() + y.slice(1) : ""
}

function ap(y) {
  if (!y) return {};
  const l = {};

  function _(x, k) {
    if (x.startsWith("-moz-") || x.startsWith("-webkit-") || x.startsWith("-ms-") || x.startsWith("-o-")) {
      l[fy(x)] = k;
      return
    }
    if (x.startsWith("--")) {
      l[x] = k;
      return
    }
    l[$I(x)] = k
  }
  return HI(y, _), l
}

function tM(...y) {
  return (...l) => {
    for (const _ of y) typeof _ == "function" && _(...l)
  }
}

function rM(y, l) {
  const _ = RegExp(y, "g");
  return x => {
    if (typeof x != "string") throw new TypeError(`expected an argument of type string, but got ${typeof x}`);
    return x.match(_) ? x.replace(_, l) : x
  }
}
const iM = rM(/[A-Z]/, y => `-${y.toLowerCase()}`);

function aM(y) {
  if (!y || typeof y != "object" || Array.isArray(y)) throw new TypeError(`expected an argument of type object, but got ${typeof y}`);
  return Object.keys(y).map(l => `${iM(l)}: ${y[l]};`).join(`
`)
}

function my(y = {}) {
  return aM(y).replace(`
`, " ")
}
const nM = ["onabort", "onanimationcancel", "onanimationend", "onanimationiteration", "onanimationstart", "onauxclick", "onbeforeinput", "onbeforetoggle", "onblur", "oncancel", "oncanplay", "oncanplaythrough", "onchange", "onclick", "onclose", "oncompositionend", "oncompositionstart", "oncompositionupdate", "oncontextlost", "oncontextmenu", "oncontextrestored", "oncopy", "oncuechange", "oncut", "ondblclick", "ondrag", "ondragend", "ondragenter", "ondragleave", "ondragover", "ondragstart", "ondrop", "ondurationchange", "onemptied", "onended", "onerror", "onfocus", "onfocusin", "onfocusout", "onformdata", "ongotpointercapture", "oninput", "oninvalid", "onkeydown", "onkeypress", "onkeyup", "onload", "onloadeddata", "onloadedmetadata", "onloadstart", "onlostpointercapture", "onmousedown", "onmouseenter", "onmouseleave", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onpaste", "onpause", "onplay", "onplaying", "onpointercancel", "onpointerdown", "onpointerenter", "onpointerleave", "onpointermove", "onpointerout", "onpointerover", "onpointerup", "onprogress", "onratechange", "onreset", "onresize", "onscroll", "onscrollend", "onsecuritypolicyviolation", "onseeked", "onseeking", "onselect", "onselectionchange", "onselectstart", "onslotchange", "onstalled", "onsubmit", "onsuspend", "ontimeupdate", "ontoggle", "ontouchcancel", "ontouchend", "ontouchmove", "ontouchstart", "ontransitioncancel", "ontransitionend", "ontransitionrun", "ontransitionstart", "onvolumechange", "onwaiting", "onwebkitanimationend", "onwebkitanimationiteration", "onwebkitanimationstart", "onwebkittransitionend", "onwheel"],
  sM = new Set(nM);

function oM(y) {
  return sM.has(y)
}

function go(...y) {
  const l = {
    ...y[0]
  };
  for (let _ = 1; _ < y.length; _++) {
    const x = y[_];
    if (x) {
      for (const k of Object.keys(x)) {
        const z = l[k],
          T = x[k],
          s = typeof z == "function",
          F = typeof T == "function";
        if (s && oM(k)) {
          const Z = z,
            K = T;
          l[k] = RI(Z, K)
        } else if (s && F) l[k] = tM(z, T);
        else if (k === "class") {
          const Z = Tm(z),
            K = Tm(T);
          Z && K ? l[k] = op(z, T) : Z ? l[k] = op(z) : K && (l[k] = op(T))
        } else if (k === "style") {
          const Z = typeof z == "object",
            K = typeof T == "object",
            G = typeof z == "string",
            re = typeof T == "string";
          if (Z && K) l[k] = {
            ...z,
            ...T
          };
          else if (Z && re) {
            const he = ap(T);
            l[k] = {
              ...z,
              ...he
            }
          } else if (G && K) {
            const he = ap(z);
            l[k] = {
              ...he,
              ...T
            }
          } else if (G && re) {
            const he = ap(z),
              me = ap(T);
            l[k] = {
              ...he,
              ...me
            }
          } else Z ? l[k] = z : K ? l[k] = T : G ? l[k] = z : re && (l[k] = T)
        } else l[k] = T !== void 0 ? T : z
      }
      for (const k of Object.getOwnPropertySymbols(x)) {
        const z = l[k],
          T = x[k];
        l[k] = T !== void 0 ? T : z
      }
    }
  }
  return typeof l.style == "object" && (l.style = my(l.style).replaceAll(`
`, " ")), l.hidden === !1 && (l.hidden = void 0, delete l.hidden), l.disabled === !1 && (l.disabled = void 0, delete l.disabled), l
}
const gy = {
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  borderWidth: "0",
  transform: "translateX(-100%)"
};
my(gy);
const lM = typeof window < "u" ? window : void 0;

function cM(y) {
  let l = y.activeElement;
  for (; l != null && l.shadowRoot;) {
    const _ = l.shadowRoot.activeElement;
    if (_ === l) break;
    l = _
  }
  return l
}
var zc, sh;
class uM {
  constructor(l = {}) {
    Ii(this, zc);
    Ii(this, sh);
    const {
      window: _ = lM,
      document: x = _ == null ? void 0 : _.document
    } = l;
    _ !== void 0 && (Mn(this, zc, x), Mn(this, sh, d0(k => {
      const z = yp(_, "focusin", k),
        T = yp(_, "focusout", k);
      return () => {
        z(), T()
      }
    })))
  }
  get current() {
    var l;
    return (l = ar(this, sh)) == null || l.call(this), ar(this, zc) ? cM(ar(this, zc)) : null
  }
}
zc = new WeakMap, sh = new WeakMap;
new uM;
var oh, co;
class yg {
  constructor(l) {
    Ii(this, oh);
    Ii(this, co);
    Mn(this, oh, l), Mn(this, co, Symbol(l))
  }
  get key() {
    return ar(this, co)
  }
  exists() {
    return Y1(ar(this, co))
  }
  get() {
    const l = gv(ar(this, co));
    if (l === void 0) throw new Error(`Context "${ar(this,oh)}" not found`);
    return l
  }
  getOr(l) {
    const _ = gv(ar(this, co));
    return _ === void 0 ? l : _
  }
  set(l) {
    return K1(ar(this, co), l)
  }
}
oh = new WeakMap, co = new WeakMap;

function hM(y, l) {
  switch (y) {
    case "post":
      Qr(l);
      break;
    case "pre":
      Hm(l);
      break
  }
}

function _y(y, l, _, x = {}) {
  const {
    lazy: k = !1
  } = x;
  let z = !k,
    T = Array.isArray(y) ? [] : void 0;
  hM(l, () => {
    const s = Array.isArray(y) ? y.map(Z => Z()) : y();
    if (!z) {
      z = !0, T = s;
      return
    }
    const F = An(() => _(s, T));
    return T = s, F
  })
}

function Fc(y, l, _) {
  _y(y, "post", l, _)
}

function dM(y, l, _) {
  _y(y, "pre", l, _)
}
Fc.pre = dM;

function pM(y, l) {
  return setTimeout(l, y)
}

function Sc(y) {
  Xm().then(y)
}

function _o(y, l) {
  return {
    [q3()]: _ => DI(y) ? (y.current = _, An(() => l == null ? void 0 : l(_)), () => {
      "isConnected" in _ && _.isConnected || (y.current = null, l == null || l(null))
    }) : (y(_), An(() => l == null ? void 0 : l(_)), () => {
      "isConnected" in _ && _.isConnected || (y(null), l == null || l(null))
    })
  }
}

function Pm(y) {
  return y ? "true" : "false"
}

function Jv(y) {
  return y ? "" : void 0
}
var Ec, lh;
class fM {
  constructor(l) {
    Ii(this, Ec);
    Ii(this, lh);
    bi(this, "attrs");
    Mn(this, Ec, l.getVariant ? l.getVariant() : null), Mn(this, lh, ar(this, Ec) ? `data-${ar(this,Ec)}-` : `data-${l.component}-`), this.getAttr = this.getAttr.bind(this), this.selector = this.selector.bind(this), this.attrs = Object.fromEntries(l.parts.map(_ => [_, this.getAttr(_)]))
  }
  getAttr(l, _) {
    return _ ? `data-${_}-${l}` : `${ar(this,lh)}${l}`
  }
  selector(l, _) {
    return `[${this.getAttr(l,_)}]`
  }
}
Ec = new WeakMap, lh = new WeakMap;

function mM(y) {
  const l = new fM(y);
  return {
    ...l.attrs,
    selector: l.selector,
    getAttr: l.getAttr
  }
}
const gM = "ArrowDown",
  _M = "ArrowLeft",
  vM = "ArrowRight",
  yM = "ArrowUp",
  xM = "End",
  bM = "Enter",
  wM = "Home",
  TM = "p",
  SM = "n",
  PM = "j",
  IM = "k",
  MM = "h",
  CM = "l";

function Im() {}

function vo(y, l) {
  return `bits-${y}`
}

function AM(y) {
  if (!y) return null;
  for (const l of y.childNodes)
    if (l.nodeType !== Node.COMMENT_NODE) return l;
  return null
}
globalThis.bitsIdCounter ?? (globalThis.bitsIdCounter = {
  current: 0
});

function kM(y = "bits") {
  return globalThis.bitsIdCounter.current++, `${y}-${globalThis.bitsIdCounter.current}`
}

function zM(y, l) {
  let _ = y.nextElementSibling;
  for (; _;) {
    if (_.matches(l)) return _;
    _ = _.nextElementSibling
  }
}

function EM(y, l) {
  let _ = y.previousElementSibling;
  for (; _;) {
    if (_.matches(l)) return _;
    _ = _.previousElementSibling
  }
}

function vy(y) {
  if (typeof CSS < "u" && typeof CSS.escape == "function") return CSS.escape(y);
  const l = y.length;
  let _ = -1,
    x, k = "";
  const z = y.charCodeAt(0);
  if (l === 1 && z === 45) return "\\" + y;
  for (; ++_ < l;) {
    if (x = y.charCodeAt(_), x === 0) {
      k += "";
      continue
    }
    if (x >= 1 && x <= 31 || x === 127 || _ === 0 && x >= 48 && x <= 57 || _ === 1 && x >= 48 && x <= 57 && z === 45) {
      k += "\\" + x.toString(16) + " ";
      continue
    }
    if (x >= 128 || x === 45 || x === 95 || x >= 48 && x <= 57 || x >= 65 && x <= 90 || x >= 97 && x <= 122) {
      k += y.charAt(_);
      continue
    }
    k += "\\" + y.charAt(_)
  }
  return k
}
const gl = "data-value",
  Fn = mM({
    component: "command",
    parts: ["root", "list", "input", "separator", "loading", "empty", "group", "group-items", "group-heading", "item", "viewport", "input-label"]
  }),
  Pc = Fn.selector("group"),
  am = Fn.selector("group-items"),
  $v = Fn.selector("group-heading"),
  yy = Fn.selector("item"),
  nm = `${Fn.selector("item")}:not([aria-disabled="true"])`,
  Sl = new yg("Command.Root"),
  LM = new yg("Command.List"),
  eh = new yg("Command.Group"),
  Qv = {
    search: "",
    value: "",
    filtered: {
      count: 0,
      items: new Map,
      groups: new Set
    }
  };
var Lc, Dc, ch, uh, hh, dh, ph, fh, Ur, xy, mp, Cm, gp, _p, vp, Bo, by, wy, Am, Hu, km, zm, Ty, Xu, Em, Lm, Sy, Yu, Ku, mh;
const Sg = class Sg {
  constructor(l) {
    Ii(this, Ur);
    bi(this, "opts");
    bi(this, "attachment");
    Ii(this, Lc, !1);
    Ii(this, Dc, !0);
    bi(this, "sortAfterTick", !1);
    bi(this, "sortAndFilterAfterTick", !1);
    bi(this, "allItems", new Set);
    bi(this, "allGroups", new Map);
    bi(this, "allIds", new Map);
    Ii(this, ch, Xe(0));
    Ii(this, uh, Xe(null));
    Ii(this, hh, Xe(null));
    Ii(this, dh, Xe(null));
    Ii(this, ph, Xe(Qv));
    Ii(this, fh, Xe(Wi(Qv)));
    Ii(this, mh, Je(() => ({
      id: this.opts.id.current,
      role: "application",
      [Fn.root]: "",
      tabindex: -1,
      onkeydown: this.onkeydown,
      ...this.attachment
    })));
    this.opts = l, this.attachment = _o(this.opts.ref);
    const _ = {
      ...this._commandState,
      value: this.opts.value.current ?? ""
    };
    this._commandState = _, this.commandState = _, this.onkeydown = this.onkeydown.bind(this)
  }
  static create(l) {
    return Sl.set(new Sg(l))
  }
  get key() {
    return h(ar(this, ch))
  }
  set key(l) {
    j(ar(this, ch), l, !0)
  }
  get viewportNode() {
    return h(ar(this, uh))
  }
  set viewportNode(l) {
    j(ar(this, uh), l, !0)
  }
  get inputNode() {
    return h(ar(this, hh))
  }
  set inputNode(l) {
    j(ar(this, hh), l, !0)
  }
  get labelNode() {
    return h(ar(this, dh))
  }
  set labelNode(l) {
    j(ar(this, dh), l, !0)
  }
  get commandState() {
    return h(ar(this, ph))
  }
  set commandState(l) {
    j(ar(this, ph), l)
  }
  get _commandState() {
    return h(ar(this, fh))
  }
  set _commandState(l) {
    j(ar(this, fh), l, !0)
  }
  setState(l, _, x) {
    Object.is(this._commandState[l], _) || (this._commandState[l] = _, l === "search" ? (oi(this, Ur, vp).call(this), oi(this, Ur, gp).call(this)) : l === "value" && (x || oi(this, Ur, by).call(this)), oi(this, Ur, mp).call(this))
  }
  setValue(l, _) {
    l !== this.opts.value.current && l === "" && Sc(() => {
      this.key++
    }), this.setState("value", l, _), this.opts.value.current = l
  }
  getValidItems() {
    const l = this.opts.ref.current;
    return l ? Array.from(l.querySelectorAll(nm)).filter(x => !!x) : []
  }
  getVisibleItems() {
    const l = this.opts.ref.current;
    return l ? Array.from(l.querySelectorAll(yy)).filter(x => !!x) : []
  }
  get itemsGrid() {
    var s, F, Z, K;
    if (!this.isGrid) return [];
    const l = this.opts.columns.current ?? 1,
      _ = this.getVisibleItems(),
      x = [
        []
      ];
    let k = (s = _[0]) == null ? void 0 : s.getAttribute("data-group"),
      z = 0,
      T = 0;
    for (let G = 0; G < _.length; G++) {
      const re = _[G],
        he = re == null ? void 0 : re.getAttribute("data-group");
      k !== he ? (k = he, z = 1, T++, x.push([{
        index: G,
        firstRowOfGroup: !0,
        ref: re
      }])) : (z++, z > l && (T++, z = 1, x.push([])), (K = x[T]) == null || K.push({
        index: G,
        firstRowOfGroup: ((Z = (F = x[T]) == null ? void 0 : F[0]) == null ? void 0 : Z.firstRowOfGroup) ?? G === 0,
        ref: re
      }))
    }
    return x
  }
  updateSelectedToIndex(l) {
    const _ = this.getValidItems()[l];
    _ && this.setValue(_.getAttribute(gl) ?? "")
  }
  updateSelectedByItem(l) {
    const _ = oi(this, Ur, Bo).call(this),
      x = this.getValidItems(),
      k = x.findIndex(T => T === _);
    let z = x[k + l];
    this.opts.loop.current && (z = k + l < 0 ? x[x.length - 1] : k + l === x.length ? x[0] : x[k + l]), z && this.setValue(z.getAttribute(gl) ?? "")
  }
  updateSelectedByGroup(l) {
    const _ = oi(this, Ur, Bo).call(this);
    let x = _ == null ? void 0 : _.closest(Pc),
      k;
    for (; x && !k;) x = l > 0 ? zM(x, Pc) : EM(x, Pc), k = x == null ? void 0 : x.querySelector(nm);
    k ? this.setValue(k.getAttribute(gl) ?? "") : this.updateSelectedByItem(l)
  }
  registerValue(l, _) {
    var x;
    return l && l === ((x = this.allIds.get(l)) == null ? void 0 : x.value) || this.allIds.set(l, {
      value: l,
      keywords: _
    }), this._commandState.filtered.items.set(l, oi(this, Ur, Cm).call(this, l, _)), this.sortAfterTick || (this.sortAfterTick = !0, Sc(() => {
      oi(this, Ur, gp).call(this), this.sortAfterTick = !1
    })), () => {
      this.allIds.delete(l)
    }
  }
  registerItem(l, _) {
    return this.allItems.add(l), _ && (this.allGroups.has(_) ? this.allGroups.get(_).add(l) : this.allGroups.set(_, new Set([l]))), this.sortAndFilterAfterTick || (this.sortAndFilterAfterTick = !0, Sc(() => {
      oi(this, Ur, vp).call(this), oi(this, Ur, gp).call(this), this.sortAndFilterAfterTick = !1
    })), oi(this, Ur, mp).call(this), () => {
      const x = oi(this, Ur, Bo).call(this);
      this.allItems.delete(l), this.commandState.filtered.items.delete(l), oi(this, Ur, vp).call(this), (x == null ? void 0 : x.getAttribute("id")) === l && oi(this, Ur, _p).call(this), oi(this, Ur, mp).call(this)
    }
  }
  registerGroup(l) {
    return this.allGroups.has(l) || this.allGroups.set(l, new Set), () => {
      this.allIds.delete(l), this.allGroups.delete(l)
    }
  }
  get isGrid() {
    return this.opts.columns.current !== null
  }
  onkeydown(l) {
    const _ = this.opts.vimBindings.current && l.ctrlKey;
    switch (l.key) {
      case SM:
      case PM: {
        _ && (this.isGrid ? oi(this, Ur, km).call(this, l) : oi(this, Ur, Hu).call(this, l));
        break
      }
      case CM: {
        _ && this.isGrid && oi(this, Ur, Hu).call(this, l);
        break
      }
      case gM:
        this.isGrid ? oi(this, Ur, km).call(this, l) : oi(this, Ur, Hu).call(this, l);
        break;
      case vM:
        if (!this.isGrid) break;
        oi(this, Ur, Hu).call(this, l);
        break;
      case TM:
      case IM: {
        _ && (this.isGrid ? oi(this, Ur, Lm).call(this, l) : oi(this, Ur, Ku).call(this, l));
        break
      }
      case MM: {
        _ && this.isGrid && oi(this, Ur, Ku).call(this, l);
        break
      }
      case yM:
        this.isGrid ? oi(this, Ur, Lm).call(this, l) : oi(this, Ur, Ku).call(this, l);
        break;
      case _M:
        if (!this.isGrid) break;
        oi(this, Ur, Ku).call(this, l);
        break;
      case wM:
        l.preventDefault(), this.updateSelectedToIndex(0);
        break;
      case xM:
        l.preventDefault(), oi(this, Ur, Am).call(this);
        break;
      case bM:
        if (!l.isComposing && l.keyCode !== 229) {
          l.preventDefault();
          const x = oi(this, Ur, Bo).call(this);
          x && (x == null || x.click())
        }
    }
  }
  get props() {
    return h(ar(this, mh))
  }
  set props(l) {
    j(ar(this, mh), l)
  }
};
Lc = new WeakMap, Dc = new WeakMap, ch = new WeakMap, uh = new WeakMap, hh = new WeakMap, dh = new WeakMap, ph = new WeakMap, fh = new WeakMap, Ur = new WeakSet, xy = function() {
  return j3(this._commandState)
}, mp = function() {
  ar(this, Lc) || (Mn(this, Lc, !0), Sc(() => {
    var x, k;
    Mn(this, Lc, !1);
    const l = oi(this, Ur, xy).call(this);
    !Object.is(this.commandState, l) && (this.commandState = l, (k = (x = this.opts.onStateChange) == null ? void 0 : x.current) == null || k.call(x, l))
  }))
}, Cm = function(l, _) {
  const x = this.opts.filter.current ?? My;
  return l ? x(l, this._commandState.search, _) : 0
}, gp = function() {
  var T;
  if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
    (!this._commandState.value || !ar(this, Dc)) && oi(this, Ur, _p).call(this);
    return
  }
  const l = this._commandState.filtered.items,
    _ = [];
  for (const s of this._commandState.filtered.groups) {
    const F = this.allGroups.get(s);
    let Z = 0;
    if (!F) {
      _.push([s, Z]);
      continue
    }
    for (const K of F) {
      const G = l.get(K);
      Z = Math.max(G ?? 0, Z)
    }
    _.push([s, Z])
  }
  const x = this.viewportNode,
    k = this.getValidItems().sort((s, F) => {
      const Z = s.getAttribute("data-value"),
        K = F.getAttribute("data-value"),
        G = l.get(Z) ?? 0;
      return (l.get(K) ?? 0) - G
    });
  for (const s of k) {
    const F = s.closest(am);
    if (F) {
      const Z = s.parentElement === F ? s : s.closest(`${am} > *`);
      Z && F.appendChild(Z)
    } else {
      const Z = s.parentElement === x ? s : s.closest(`${am} > *`);
      Z && (x == null || x.appendChild(Z))
    }
  }
  const z = _.sort((s, F) => F[1] - s[1]);
  for (const s of z) {
    const F = x == null ? void 0 : x.querySelector(`${Pc}[${gl}="${vy(s[0])}"]`);
    (T = F == null ? void 0 : F.parentElement) == null || T.appendChild(F)
  }
  oi(this, Ur, _p).call(this)
}, _p = function() {
  Sc(() => {
    const l = this.getValidItems().find(k => k.getAttribute("aria-disabled") !== "true"),
      _ = l == null ? void 0 : l.getAttribute(gl),
      x = ar(this, Dc) && this.opts.disableInitialScroll.current;
    this.setValue(_ ?? "", x), Mn(this, Dc, !1)
  })
}, vp = function() {
  var _, x;
  if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
    this._commandState.filtered.count = this.allItems.size;
    return
  }
  this._commandState.filtered.groups = new Set;
  let l = 0;
  for (const k of this.allItems) {
    const z = ((_ = this.allIds.get(k)) == null ? void 0 : _.value) ?? "",
      T = ((x = this.allIds.get(k)) == null ? void 0 : x.keywords) ?? [],
      s = oi(this, Ur, Cm).call(this, z, T);
    this._commandState.filtered.items.set(k, s), s > 0 && l++
  }
  for (const [k, z] of this.allGroups)
    for (const T of z) {
      const s = this._commandState.filtered.items.get(T);
      if (s && s > 0) {
        this._commandState.filtered.groups.add(k);
        break
      }
    }
  this._commandState.filtered.count = l
}, Bo = function() {
  const l = this.opts.ref.current;
  if (!l) return;
  const _ = l.querySelector(`${nm}[data-selected]`);
  if (_) return _
}, by = function() {
  Sc(() => {
    var x, k, z, T, s;
    const l = oi(this, Ur, Bo).call(this);
    if (!l) return;
    const _ = (x = l.parentElement) == null ? void 0 : x.parentElement;
    if (_) {
      if (this.isGrid) {
        const F = oi(this, Ur, wy).call(this, l);
        if (l.scrollIntoView({
            block: "nearest"
          }), F) {
          const Z = (k = l == null ? void 0 : l.closest(Pc)) == null ? void 0 : k.querySelector($v);
          Z == null || Z.scrollIntoView({
            block: "nearest"
          });
          return
        }
      } else {
        const F = AM(_);
        if (F && ((z = F.dataset) == null ? void 0 : z.value) === ((T = l.dataset) == null ? void 0 : T.value)) {
          const Z = (s = l == null ? void 0 : l.closest(Pc)) == null ? void 0 : s.querySelector($v);
          Z == null || Z.scrollIntoView({
            block: "nearest"
          });
          return
        }
      }
      l.scrollIntoView({
        block: "nearest"
      })
    }
  })
}, wy = function(l) {
  const _ = this.itemsGrid;
  if (_.length === 0) return !1;
  for (let x = 0; x < _.length; x++) {
    const k = _[x];
    if (k !== void 0)
      for (let z = 0; z < k.length; z++) {
        const T = k[z];
        if (!(T === void 0 || T.ref !== l)) return T.firstRowOfGroup
      }
  }
  return !1
}, Am = function() {
  return this.updateSelectedToIndex(this.getValidItems().length - 1)
}, Hu = function(l) {
  l.preventDefault(), l.metaKey ? oi(this, Ur, Am).call(this) : l.altKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(1)
}, km = function(l) {
  this.opts.columns.current !== null && (l.preventDefault(), l.metaKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(oi(this, Ur, Ty).call(this, l)))
}, zm = function(l, _) {
  if (_.length === 0) return null;
  for (let x = 0; x < _.length; x++) {
    const k = _[x];
    if (k !== void 0)
      for (let z = 0; z < k.length; z++) {
        const T = k[z];
        if (!(T === void 0 || T.ref !== l)) return {
          columnIndex: z,
          rowIndex: x
        }
      }
  }
  return null
}, Ty = function(l) {
  const _ = this.itemsGrid,
    x = oi(this, Ur, Bo).call(this);
  if (!x) return 0;
  const k = oi(this, Ur, zm).call(this, x, _);
  if (!k) return 0;
  let z = null;
  const T = l.altKey ? 1 : 0;
  if (l.altKey && k.rowIndex === _.length - 2 && !this.opts.loop.current) z = oi(this, Ur, Xu).call(this, {
    start: _.length - 1,
    end: _.length,
    expectedColumnIndex: k.columnIndex,
    grid: _
  });
  else if (k.rowIndex === _.length - 1) {
    if (!this.opts.loop.current) return 0;
    z = oi(this, Ur, Xu).call(this, {
      start: 0 + T,
      end: k.rowIndex,
      expectedColumnIndex: k.columnIndex,
      grid: _
    })
  } else z = oi(this, Ur, Xu).call(this, {
    start: k.rowIndex + 1 + T,
    end: _.length,
    expectedColumnIndex: k.columnIndex,
    grid: _
  }), z === null && this.opts.loop.current && (z = oi(this, Ur, Xu).call(this, {
    start: 0,
    end: k.rowIndex,
    expectedColumnIndex: k.columnIndex,
    grid: _
  }));
  return oi(this, Ur, Em).call(this, x, z)
}, Xu = function({
  start: l,
  end: _,
  grid: x,
  expectedColumnIndex: k
}) {
  var T;
  let z = null;
  for (let s = l; s < _; s++) {
    const F = x[s];
    if (z = ((T = F[k]) == null ? void 0 : T.ref) ?? null, z !== null && np(z)) {
      z = null;
      continue
    }
    if (z === null)
      for (let Z = F.length - 1; Z >= 0; Z--) {
        const K = F[F.length - 1];
        if (!(K === void 0 || np(K.ref))) {
          z = K.ref;
          break
        }
      }
    break
  }
  return z
}, Em = function(l, _) {
  if (_ === null) return 0;
  const x = this.getValidItems(),
    k = x.findIndex(T => T === l);
  return x.findIndex(T => T === _) - k
}, Lm = function(l) {
  this.opts.columns.current !== null && (l.preventDefault(), l.metaKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(oi(this, Ur, Sy).call(this, l)))
}, Sy = function(l) {
  const _ = this.itemsGrid,
    x = oi(this, Ur, Bo).call(this);
  if (x === void 0) return 0;
  const k = oi(this, Ur, zm).call(this, x, _);
  if (k === null) return 0;
  let z = null;
  const T = l.altKey ? 1 : 0;
  if (l.altKey && k.rowIndex === 1 && this.opts.loop.current === !1) z = oi(this, Ur, Yu).call(this, {
    start: 0,
    end: 0,
    expectedColumnIndex: k.columnIndex,
    grid: _
  });
  else if (k.rowIndex === 0) {
    if (this.opts.loop.current === !1) return 0;
    z = oi(this, Ur, Yu).call(this, {
      start: _.length - 1 - T,
      end: k.rowIndex + 1,
      expectedColumnIndex: k.columnIndex,
      grid: _
    })
  } else z = oi(this, Ur, Yu).call(this, {
    start: k.rowIndex - 1 - T,
    end: 0,
    expectedColumnIndex: k.columnIndex,
    grid: _
  }), z === null && this.opts.loop.current && (z = oi(this, Ur, Yu).call(this, {
    start: _.length - 1,
    end: k.rowIndex + 1,
    expectedColumnIndex: k.columnIndex,
    grid: _
  }));
  return oi(this, Ur, Em).call(this, x, z)
}, Yu = function({
  start: l,
  end: _,
  grid: x,
  expectedColumnIndex: k
}) {
  var T;
  let z = null;
  for (let s = l; s >= _; s--) {
    const F = x[s];
    if (F !== void 0) {
      if (z = ((T = F[k]) == null ? void 0 : T.ref) ?? null, z !== null && np(z)) {
        z = null;
        continue
      }
      if (z === null)
        for (let Z = F.length - 1; Z >= 0; Z--) {
          const K = F[F.length - 1];
          if (!(K === void 0 || np(K.ref))) {
            z = K.ref;
            break
          }
        }
      break
    }
  }
  return z
}, Ku = function(l) {
  l.preventDefault(), l.metaKey ? this.updateSelectedToIndex(0) : l.altKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(-1)
}, mh = new WeakMap;
let Mm = Sg;

function np(y) {
  return y.getAttribute("aria-disabled") === "true"
}
var gh, _h, vh;
const Pg = class Pg {
  constructor(l, _) {
    bi(this, "opts");
    bi(this, "root");
    bi(this, "attachment");
    Ii(this, gh, Je(() => this.root._commandState.filtered.count === 0 && ar(this, _h) === !1 || this.opts.forceMount.current));
    Ii(this, _h, !0);
    Ii(this, vh, Je(() => ({
      id: this.opts.id.current,
      role: "presentation",
      [Fn.empty]: "",
      ...this.attachment
    })));
    this.opts = l, this.root = _, this.attachment = _o(this.opts.ref), Hm(() => {
      Mn(this, _h, !1)
    })
  }
  static create(l) {
    return new Pg(l, Sl.get())
  }
  get shouldRender() {
    return h(ar(this, gh))
  }
  set shouldRender(l) {
    j(ar(this, gh), l)
  }
  get props() {
    return h(ar(this, vh))
  }
  set props(l) {
    j(ar(this, vh), l)
  }
};
gh = new WeakMap, _h = new WeakMap, vh = new WeakMap;
let Dm = Pg;
var yh, xh, bh, wh;
const Ig = class Ig {
  constructor(l, _) {
    bi(this, "opts");
    bi(this, "root");
    bi(this, "attachment");
    Ii(this, yh, Je(() => this.opts.forceMount.current || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search ? !0 : this.root._commandState.filtered.groups.has(this.trueValue)));
    Ii(this, xh, Xe(null));
    Ii(this, bh, Xe(""));
    Ii(this, wh, Je(() => ({
      id: this.opts.id.current,
      role: "presentation",
      hidden: this.shouldRender ? void 0 : !0,
      "data-value": this.trueValue,
      [Fn.group]: "",
      ...this.attachment
    })));
    this.opts = l, this.root = _, this.attachment = _o(this.opts.ref), this.trueValue = l.value.current ?? l.id.current, Fc(() => this.trueValue, () => this.root.registerGroup(this.trueValue)), Qr(() => this.opts.value.current ? (this.trueValue = this.opts.value.current, this.root.registerValue(this.opts.value.current)) : this.headingNode && this.headingNode.textContent ? (this.trueValue = this.headingNode.textContent.trim().toLowerCase(), this.root.registerValue(this.trueValue)) : (this.trueValue = `-----${this.opts.id.current}`, this.root.registerValue(this.trueValue)))
  }
  static create(l) {
    return eh.set(new Ig(l, Sl.get()))
  }
  get shouldRender() {
    return h(ar(this, yh))
  }
  set shouldRender(l) {
    j(ar(this, yh), l)
  }
  get headingNode() {
    return h(ar(this, xh))
  }
  set headingNode(l) {
    j(ar(this, xh), l, !0)
  }
  get trueValue() {
    return h(ar(this, bh))
  }
  set trueValue(l) {
    j(ar(this, bh), l, !0)
  }
  get props() {
    return h(ar(this, wh))
  }
  set props(l) {
    j(ar(this, wh), l)
  }
};
yh = new WeakMap, xh = new WeakMap, bh = new WeakMap, wh = new WeakMap;
let Rm = Ig;
var Th;
const Mg = class Mg {
  constructor(l, _) {
    bi(this, "opts");
    bi(this, "group");
    bi(this, "attachment");
    Ii(this, Th, Je(() => ({
      id: this.opts.id.current,
      [Fn["group-heading"]]: "",
      ...this.attachment
    })));
    this.opts = l, this.group = _, this.attachment = _o(this.opts.ref, x => this.group.headingNode = x)
  }
  static create(l) {
    return new Mg(l, eh.get())
  }
  get props() {
    return h(ar(this, Th))
  }
  set props(l) {
    j(ar(this, Th), l)
  }
};
Th = new WeakMap;
let Fm = Mg;
var Sh;
const Cg = class Cg {
  constructor(l, _) {
    bi(this, "opts");
    bi(this, "group");
    bi(this, "attachment");
    Ii(this, Sh, Je(() => {
      var l;
      return {
        id: this.opts.id.current,
        role: "group",
        [Fn["group-items"]]: "",
        "aria-labelledby": ((l = this.group.headingNode) == null ? void 0 : l.id) ?? void 0,
        ...this.attachment
      }
    }));
    this.opts = l, this.group = _, this.attachment = _o(this.opts.ref)
  }
  static create(l) {
    return new Cg(l, eh.get())
  }
  get props() {
    return h(ar(this, Sh))
  }
  set props(l) {
    j(ar(this, Sh), l)
  }
};
Sh = new WeakMap;
let Bm = Cg;
var Ep, Ph;
const Ag = class Ag {
  constructor(l, _) {
    bi(this, "opts");
    bi(this, "root");
    bi(this, "attachment");
    Ii(this, Ep, Je(() => {
      var _;
      const l = (_ = this.root.viewportNode) == null ? void 0 : _.querySelector(`${yy}[${gl}="${vy(this.root.opts.value.current)}"]`);
      if (l != null) return l.getAttribute("id") ?? void 0
    }));
    Ii(this, Ph, Je(() => {
      var l, _;
      return {
        id: this.opts.id.current,
        type: "text",
        [Fn.input]: "",
        autocomplete: "off",
        autocorrect: "off",
        spellcheck: !1,
        "aria-autocomplete": "list",
        role: "combobox",
        "aria-expanded": Pm(!0),
        "aria-controls": ((l = this.root.viewportNode) == null ? void 0 : l.id) ?? void 0,
        "aria-labelledby": ((_ = this.root.labelNode) == null ? void 0 : _.id) ?? void 0,
        "aria-activedescendant": h(ar(this, Ep)),
        ...this.attachment
      }
    }));
    this.opts = l, this.root = _, this.attachment = _o(this.opts.ref, x => this.root.inputNode = x), Fc(() => this.opts.ref.current, () => {
      const x = this.opts.ref.current;
      x && this.opts.autofocus.current && pM(10, () => x.focus())
    }), Fc(() => this.opts.value.current, () => {
      this.root.commandState.search !== this.opts.value.current && this.root.setState("search", this.opts.value.current)
    })
  }
  static create(l) {
    return new Ag(l, Sl.get())
  }
  get props() {
    return h(ar(this, Ph))
  }
  set props(l) {
    j(ar(this, Ph), l)
  }
};
Ep = new WeakMap, Ph = new WeakMap;
let Om = Ag;
var jo, Lp, Ih, Mh, Ch, wl, Py, qm, Ah;
const kg = class kg {
  constructor(l, _) {
    Ii(this, wl);
    bi(this, "opts");
    bi(this, "root");
    bi(this, "attachment");
    Ii(this, jo, null);
    Ii(this, Lp, Je(() => {
      var l;
      return this.opts.forceMount.current || ((l = ar(this, jo)) == null ? void 0 : l.opts.forceMount.current) === !0
    }));
    Ii(this, Ih, Je(() => {
      if (this.opts.ref.current, h(ar(this, Lp)) || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search) return !0;
      const l = this.root.commandState.filtered.items.get(this.trueValue);
      return l === void 0 ? !1 : l > 0
    }));
    Ii(this, Mh, Je(() => this.root.opts.value.current === this.trueValue && this.trueValue !== ""));
    Ii(this, Ch, Xe(""));
    Ii(this, Ah, Je(() => {
      var l;
      return {
        id: this.opts.id.current,
        "aria-disabled": Pm(this.opts.disabled.current),
        "aria-selected": Pm(this.isSelected),
        "data-disabled": Jv(this.opts.disabled.current),
        "data-selected": Jv(this.isSelected),
        "data-value": this.trueValue,
        "data-group": (l = ar(this, jo)) == null ? void 0 : l.trueValue,
        [Fn.item]: "",
        role: "option",
        onpointermove: this.onpointermove,
        onclick: this.onclick,
        ...this.attachment
      }
    }));
    this.opts = l, this.root = _, Mn(this, jo, eh.getOr(null)), this.trueValue = l.value.current, this.attachment = _o(this.opts.ref), Fc([() => this.trueValue, () => {
      var x;
      return (x = ar(this, jo)) == null ? void 0 : x.trueValue
    }, () => this.opts.forceMount.current], () => {
      var x;
      if (!(this.opts.forceMount.current || !this.trueValue)) return this.root.registerItem(this.trueValue, (x = ar(this, jo)) == null ? void 0 : x.trueValue)
    }), Fc([() => this.opts.value.current, () => this.opts.ref.current], () => {
      var x, k;
      this.opts.value.current ? this.trueValue = this.opts.value.current : (x = this.opts.ref.current) != null && x.textContent && (this.trueValue = this.opts.ref.current.textContent.trim()), this.trueValue && (this.root.registerValue(this.trueValue, l.keywords.current.map(z => z.trim())), (k = this.opts.ref.current) == null || k.setAttribute(gl, this.trueValue))
    }), this.onclick = this.onclick.bind(this), this.onpointermove = this.onpointermove.bind(this)
  }
  static create(l) {
    const _ = eh.getOr(null);
    return new kg({
      ...l,
      group: _
    }, Sl.get())
  }
  get shouldRender() {
    return h(ar(this, Ih))
  }
  set shouldRender(l) {
    j(ar(this, Ih), l)
  }
  get isSelected() {
    return h(ar(this, Mh))
  }
  set isSelected(l) {
    j(ar(this, Mh), l)
  }
  get trueValue() {
    return h(ar(this, Ch))
  }
  set trueValue(l) {
    j(ar(this, Ch), l, !0)
  }
  onpointermove(l) {
    this.opts.disabled.current || this.root.opts.disablePointerSelection.current || oi(this, wl, qm).call(this)
  }
  onclick(l) {
    this.opts.disabled.current || oi(this, wl, Py).call(this)
  }
  get props() {
    return h(ar(this, Ah))
  }
  set props(l) {
    j(ar(this, Ah), l)
  }
};
jo = new WeakMap, Lp = new WeakMap, Ih = new WeakMap, Mh = new WeakMap, Ch = new WeakMap, wl = new WeakSet, Py = function() {
  var l;
  this.opts.disabled.current || (oi(this, wl, qm).call(this), (l = this.opts.onSelect) == null || l.current())
}, qm = function() {
  this.opts.disabled.current || this.root.setValue(this.trueValue, !0)
}, Ah = new WeakMap;
let jm = kg;
var kh;
const zg = class zg {
  constructor(l, _) {
    bi(this, "opts");
    bi(this, "root");
    bi(this, "attachment");
    Ii(this, kh, Je(() => ({
      id: this.opts.id.current,
      role: "listbox",
      "aria-label": this.opts.ariaLabel.current,
      [Fn.list]: "",
      ...this.attachment
    })));
    this.opts = l, this.root = _, this.attachment = _o(this.opts.ref)
  }
  static create(l) {
    return LM.set(new zg(l, Sl.get()))
  }
  get props() {
    return h(ar(this, kh))
  }
  set props(l) {
    j(ar(this, kh), l)
  }
};
kh = new WeakMap;
let Nm = zg;
var zh;
const Eg = class Eg {
  constructor(l, _) {
    bi(this, "opts");
    bi(this, "root");
    bi(this, "attachment");
    Ii(this, zh, Je(() => {
      var l;
      return {
        id: this.opts.id.current,
        [Fn["input-label"]]: "",
        for: (l = this.opts.for) == null ? void 0 : l.current,
        style: gy,
        ...this.attachment
      }
    }));
    this.opts = l, this.root = _, this.attachment = _o(this.opts.ref, x => this.root.labelNode = x)
  }
  static create(l) {
    return new Eg(l, Sl.get())
  }
  get props() {
    return h(ar(this, zh))
  }
  set props(l) {
    j(ar(this, zh), l)
  }
};
zh = new WeakMap;
let Vm = Eg;
var DM = ae("<label><!></label>");

function RM(y, l) {
  const _ = mo();
  Gr(l, !0);
  let x = Ot(l, "id", 19, () => vo(_)),
    k = Ot(l, "ref", 15, null),
    z = Or(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "children"]);
  const T = Vm.create({
      id: Gi(() => x()),
      ref: Gi(() => k(), K => k(K))
    }),
    s = Je(() => go(z, T.props));
  var F = DM();
  jr(F, () => ({
    ...h(s)
  }));
  var Z = P(F);
  La(Z, () => l.children ?? $n), S(F), B(y, F), Wr()
}
var FM = ae("<!> <!>", 1),
  BM = ae("<div><!> <!></div>");

function OM(y, l) {
  const _ = mo();
  Gr(l, !0);
  const x = Ue => {
    RM(Ue, {
      children: (je, rt) => {
        wi();
        var _t = ja();
        ke(() => ee(_t, re())), B(je, _t)
      },
      $$slots: {
        default: !0
      }
    })
  };
  let k = Ot(l, "id", 19, () => vo(_)),
    z = Ot(l, "ref", 15, null),
    T = Ot(l, "value", 15, ""),
    s = Ot(l, "onValueChange", 3, Im),
    F = Ot(l, "onStateChange", 3, Im),
    Z = Ot(l, "loop", 3, !1),
    K = Ot(l, "shouldFilter", 3, !0),
    G = Ot(l, "filter", 3, My),
    re = Ot(l, "label", 3, ""),
    he = Ot(l, "vimBindings", 3, !0),
    me = Ot(l, "disablePointerSelection", 3, !1),
    q = Ot(l, "disableInitialScroll", 3, !1),
    ye = Ot(l, "columns", 3, null),
    be = Or(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "onValueChange", "onStateChange", "loop", "shouldFilter", "filter", "label", "vimBindings", "disablePointerSelection", "disableInitialScroll", "columns", "children", "child"]);
  const qe = Mm.create({
      id: Gi(() => k()),
      ref: Gi(() => z(), Ue => z(Ue)),
      filter: Gi(() => G()),
      shouldFilter: Gi(() => K()),
      loop: Gi(() => Z()),
      value: Gi(() => T(), Ue => {
        T() !== Ue && (T(Ue), s()(Ue))
      }),
      vimBindings: Gi(() => he()),
      disablePointerSelection: Gi(() => me()),
      disableInitialScroll: Gi(() => q()),
      onStateChange: Gi(() => F()),
      columns: Gi(() => ye())
    }),
    xe = Ue => qe.updateSelectedToIndex(Ue),
    Ye = Ue => qe.updateSelectedByGroup(Ue),
    We = Ue => qe.updateSelectedByItem(Ue),
    ze = () => qe.getValidItems(),
    Se = Je(() => go(be, qe.props));
  var Pe = {
      updateSelectedToIndex: xe,
      updateSelectedByGroup: Ye,
      updateSelectedByItem: We,
      getValidItems: ze
    },
    Ae = br(),
    Me = zt(Ae);
  {
    var Ee = Ue => {
        var je = FM(),
          rt = zt(je);
        x(rt);
        var _t = E(rt, 2);
        La(_t, () => l.child, () => ({
          props: h(Se)
        })), B(Ue, je)
      },
      Qe = Ue => {
        var je = BM();
        jr(je, () => ({
          ...h(Se)
        }));
        var rt = P(je);
        x(rt);
        var _t = E(rt, 2);
        La(_t, () => l.children ?? $n), S(je), B(Ue, je)
      };
    Te(Me, Ue => {
      l.child ? Ue(Ee) : Ue(Qe, !1)
    })
  }
  return B(y, Ae), Wr(Pe)
}
var jM = ae("<div><!></div>");

function qM(y, l) {
  const _ = mo();
  Gr(l, !0);
  let x = Ot(l, "id", 19, () => vo(_)),
    k = Ot(l, "ref", 15, null),
    z = Ot(l, "forceMount", 3, !1),
    T = Or(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child", "forceMount"]);
  const s = Dm.create({
      id: Gi(() => x()),
      ref: Gi(() => k(), re => k(re)),
      forceMount: Gi(() => z())
    }),
    F = Je(() => go(s.props, T));
  var Z = br(),
    K = zt(Z);
  {
    var G = re => {
      var he = br(),
        me = zt(he);
      {
        var q = be => {
            var qe = br(),
              xe = zt(qe);
            La(xe, () => l.child, () => ({
              props: h(F)
            })), B(be, qe)
          },
          ye = be => {
            var qe = jM();
            jr(qe, () => ({
              ...h(F)
            }));
            var xe = P(qe);
            La(xe, () => l.children ?? $n), S(qe), B(be, qe)
          };
        Te(me, be => {
          l.child ? be(q) : be(ye, !1)
        })
      }
      B(re, he)
    };
    Te(K, re => {
      s.shouldRender && re(G)
    })
  }
  B(y, Z), Wr()
}
var NM = ae("<div><!></div>");

function VM(y, l) {
  const _ = mo();
  Gr(l, !0);
  let x = Ot(l, "id", 19, () => vo(_)),
    k = Ot(l, "ref", 15, null),
    z = Ot(l, "value", 3, ""),
    T = Ot(l, "forceMount", 3, !1),
    s = Or(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "forceMount", "children", "child"]);
  const F = Rm.create({
      id: Gi(() => x()),
      ref: Gi(() => k(), me => k(me)),
      forceMount: Gi(() => T()),
      value: Gi(() => z())
    }),
    Z = Je(() => go(s, F.props));
  var K = br(),
    G = zt(K);
  {
    var re = me => {
        var q = br(),
          ye = zt(q);
        La(ye, () => l.child, () => ({
          props: h(Z)
        })), B(me, q)
      },
      he = me => {
        var q = NM();
        jr(q, () => ({
          ...h(Z)
        }));
        var ye = P(q);
        La(ye, () => l.children ?? $n), S(q), B(me, q)
      };
    Te(G, me => {
      l.child ? me(re) : me(he, !1)
    })
  }
  B(y, K), Wr()
}
var UM = ae("<div><!></div>");

function ZM(y, l) {
  const _ = mo();
  Gr(l, !0);
  let x = Ot(l, "id", 19, () => vo(_)),
    k = Ot(l, "ref", 15, null),
    z = Or(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child"]);
  const T = Fm.create({
      id: Gi(() => x()),
      ref: Gi(() => k(), re => k(re))
    }),
    s = Je(() => go(z, T.props));
  var F = br(),
    Z = zt(F);
  {
    var K = re => {
        var he = br(),
          me = zt(he);
        La(me, () => l.child, () => ({
          props: h(s)
        })), B(re, he)
      },
      G = re => {
        var he = UM();
        jr(he, () => ({
          ...h(s)
        }));
        var me = P(he);
        La(me, () => l.children ?? $n), S(he), B(re, he)
      };
    Te(Z, re => {
      l.child ? re(K) : re(G, !1)
    })
  }
  B(y, F), Wr()
}
var GM = ae("<div><!></div>"),
  WM = ae('<div style="display: contents;"><!></div>');

function HM(y, l) {
  const _ = mo();
  Gr(l, !0);
  let x = Ot(l, "id", 19, () => vo(_)),
    k = Ot(l, "ref", 15, null),
    z = Or(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child"]);
  const T = Bm.create({
      id: Gi(() => x()),
      ref: Gi(() => k(), re => k(re))
    }),
    s = Je(() => go(z, T.props));
  var F = WM(),
    Z = P(F);
  {
    var K = re => {
        var he = br(),
          me = zt(he);
        La(me, () => l.child, () => ({
          props: h(s)
        })), B(re, he)
      },
      G = re => {
        var he = GM();
        jr(he, () => ({
          ...h(s)
        }));
        var me = P(he);
        La(me, () => l.children ?? $n), S(he), B(re, he)
      };
    Te(Z, re => {
      l.child ? re(K) : re(G, !1)
    })
  }
  S(F), B(y, F), Wr()
}
var XM = ae("<input/>");

function YM(y, l) {
  const _ = mo();
  Gr(l, !0);
  let x = Ot(l, "value", 15, ""),
    k = Ot(l, "autofocus", 3, !1),
    z = Ot(l, "id", 19, () => vo(_)),
    T = Ot(l, "ref", 15, null),
    s = Or(l, ["$$slots", "$$events", "$$legacy", "value", "autofocus", "id", "ref", "child"]);
  const F = Om.create({
      id: Gi(() => z()),
      ref: Gi(() => T(), me => T(me)),
      value: Gi(() => x(), me => {
        x(me)
      }),
      autofocus: Gi(() => k() ?? !1)
    }),
    Z = Je(() => go(s, F.props));
  var K = br(),
    G = zt(K);
  {
    var re = me => {
        var q = br(),
          ye = zt(q);
        La(ye, () => l.child, () => ({
          props: h(Z)
        })), B(me, q)
      },
      he = me => {
        var q = XM();
        jr(q, () => ({
          ...h(Z)
        }), void 0, void 0, void 0, void 0, !0), Tl(q, x), B(me, q)
      };
    Te(G, me => {
      l.child ? me(re) : me(he, !1)
    })
  }
  B(y, K), Wr()
}
var KM = ae("<div><!></div>"),
  JM = ae('<div style="display: contents;" data-item-wrapper=""><!></div>');

function $M(y, l) {
  const _ = mo();
  Gr(l, !0);
  let x = Ot(l, "id", 19, () => vo(_)),
    k = Ot(l, "ref", 15, null),
    z = Ot(l, "value", 3, ""),
    T = Ot(l, "disabled", 3, !1),
    s = Ot(l, "onSelect", 3, Im),
    F = Ot(l, "forceMount", 3, !1),
    Z = Ot(l, "keywords", 19, () => []),
    K = Or(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "disabled", "children", "child", "onSelect", "forceMount", "keywords"]);
  const G = jm.create({
      id: Gi(() => x()),
      ref: Gi(() => k(), q => k(q)),
      value: Gi(() => z()),
      disabled: Gi(() => T()),
      onSelect: Gi(() => s()),
      forceMount: Gi(() => F()),
      keywords: Gi(() => Z())
    }),
    re = Je(() => go(K, G.props));
  var he = br(),
    me = zt(he);
  bl(me, () => G.root.key, q => {
    var ye = JM(),
      be = P(ye);
    {
      var qe = xe => {
        var Ye = br(),
          We = zt(Ye);
        {
          var ze = Pe => {
              var Ae = br(),
                Me = zt(Ae);
              La(Me, () => l.child, () => ({
                props: h(re)
              })), B(Pe, Ae)
            },
            Se = Pe => {
              var Ae = KM();
              jr(Ae, () => ({
                ...h(re)
              }));
              var Me = P(Ae);
              La(Me, () => l.children ?? $n), S(Ae), B(Pe, Ae)
            };
          Te(We, Pe => {
            l.child ? Pe(ze) : Pe(Se, !1)
          })
        }
        B(xe, Ye)
      };
      Te(be, xe => {
        G.shouldRender && xe(qe)
      })
    }
    S(ye), ke(() => Xt(ye, "data-value", G.trueValue)), B(q, ye)
  }), B(y, he), Wr()
}
var QM = ae("<div><!></div>");

function e6(y, l) {
  const _ = mo();
  Gr(l, !0);
  let x = Ot(l, "id", 19, () => vo(_)),
    k = Ot(l, "ref", 15, null),
    z = Or(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "child", "children", "aria-label"]);
  const T = Nm.create({
      id: Gi(() => x()),
      ref: Gi(() => k(), K => k(K)),
      ariaLabel: Gi(() => l["aria-label"] ?? "Suggestions...")
    }),
    s = Je(() => go(z, T.props));
  var F = br(),
    Z = zt(F);
  bl(Z, () => T.root._commandState.search === "", K => {
    var G = br(),
      re = zt(G);
    {
      var he = q => {
          var ye = br(),
            be = zt(ye);
          La(be, () => l.child, () => ({
            props: h(s)
          })), B(q, ye)
        },
        me = q => {
          var ye = QM();
          jr(ye, () => ({
            ...h(s)
          }));
          var be = P(ye);
          La(be, () => l.children ?? $n), S(ye), B(q, ye)
        };
      Te(re, q => {
        l.child ? q(he) : q(me, !1)
      })
    }
    B(K, G)
  }), B(y, F), Wr()
}
const e0 = 1,
  t6 = .9,
  r6 = .8,
  i6 = .17,
  sm = .1,
  om = .999,
  a6 = .9999,
  n6 = .99,
  s6 = /[\\/_+.#"@[({&]/,
  o6 = /[\\/_+.#"@[({&]/g,
  l6 = /[\s-]/,
  Iy = /[\s-]/g;

function Um(y, l, _, x, k, z, T) {
  if (z === l.length) return k === y.length ? e0 : n6;
  const s = `${k},${z}`;
  if (T[s] !== void 0) return T[s];
  const F = x.charAt(z);
  let Z = _.indexOf(F, k),
    K = 0,
    G, re, he, me;
  for (; Z >= 0;) G = Um(y, l, _, x, Z + 1, z + 1, T), G > K && (Z === k ? G *= e0 : s6.test(y.charAt(Z - 1)) ? (G *= r6, he = y.slice(k, Z - 1).match(o6), he && k > 0 && (G *= om ** he.length)) : l6.test(y.charAt(Z - 1)) ? (G *= t6, me = y.slice(k, Z - 1).match(Iy), me && k > 0 && (G *= om ** me.length)) : (G *= i6, k > 0 && (G *= om ** (Z - k))), y.charAt(Z) !== l.charAt(z) && (G *= a6)), (G < sm && _.charAt(Z - 1) === x.charAt(z + 1) || x.charAt(z + 1) === x.charAt(z) && _.charAt(Z - 1) !== x.charAt(z)) && (re = Um(y, l, _, x, Z + 1, z + 2, T), re * sm > G && (G = re * sm)), G > K && (K = G), Z = _.indexOf(F, Z + 1);
  return T[s] = K, K
}

function t0(y) {
  return y.toLowerCase().replace(Iy, " ")
}

function My(y, l, _) {
  return y = _ && _.length > 0 ? `${`${y} ${_==null?void 0:_.join(" ")}`}` : y, Um(y, l, t0(y), t0(l), 0, 0, {})
}

function Oc(...y) {
  return a3(op(y))
}

function c6(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "ref", 15, null),
    x = Ot(l, "value", 15, ""),
    k = Or(l, ["$$slots", "$$events", "$$legacy", "ref", "value", "class"]);
  var z = br(),
    T = zt(z);
  {
    let s = Je(() => Oc("bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md", l.class));
    yn(T, () => OM, (F, Z) => {
      Z(F, Bc({
        "data-slot": "command",
        get class() {
          return h(s)
        }
      }, () => k, {
        get value() {
          return x()
        },
        set value(K) {
          x(K)
        },
        get ref() {
          return _()
        },
        set ref(K) {
          _(K)
        }
      }))
    })
  }
  B(y, z), Wr()
}

function u6(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "ref", 15, null),
    x = Or(l, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var k = br(),
    z = zt(k);
  {
    let T = Je(() => Oc("py-6 text-center text-sm", l.class));
    yn(z, () => qM, (s, F) => {
      F(s, Bc({
        "data-slot": "command-empty",
        get class() {
          return h(T)
        }
      }, () => x, {
        get ref() {
          return _()
        },
        set ref(Z) {
          _(Z)
        }
      }))
    })
  }
  B(y, k), Wr()
}
var h6 = ae("<!> <!>", 1);

function d6(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "ref", 15, null),
    x = Or(l, ["$$slots", "$$events", "$$legacy", "ref", "class", "children", "heading", "value"]);
  var k = br(),
    z = zt(k);
  {
    let T = Je(() => Oc("text-foreground overflow-hidden p-1", l.class)),
      s = Je(() => l.value ?? l.heading ?? `----${kM()}`);
    yn(z, () => VM, (F, Z) => {
      Z(F, Bc({
        "data-slot": "command-group",
        get class() {
          return h(T)
        },
        get value() {
          return h(s)
        }
      }, () => x, {
        get ref() {
          return _()
        },
        set ref(K) {
          _(K)
        },
        children: (K, G) => {
          var re = h6(),
            he = zt(re);
          {
            var me = ye => {
              var be = br(),
                qe = zt(be);
              yn(qe, () => ZM, (xe, Ye) => {
                Ye(xe, {
                  class: "text-muted-foreground px-2 py-1.5 text-xs font-medium",
                  children: (We, ze) => {
                    wi();
                    var Se = ja();
                    ke(() => ee(Se, l.heading)), B(We, Se)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              }), B(ye, be)
            };
            Te(he, ye => {
              l.heading && ye(me)
            })
          }
          var q = E(he, 2);
          yn(q, () => HM, (ye, be) => {
            be(ye, {
              get children() {
                return l.children
              }
            })
          }), B(K, re)
        },
        $$slots: {
          default: !0
        }
      }))
    })
  }
  B(y, k), Wr()
}

function p6(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "ref", 15, null),
    x = Or(l, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var k = br(),
    z = zt(k);
  {
    let T = Je(() => Oc("aria-selected:bg-base-300 aria-selected:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", l.class));
    yn(z, () => $M, (s, F) => {
      F(s, Bc({
        "data-slot": "command-item",
        get class() {
          return h(T)
        }
      }, () => x, {
        get ref() {
          return _()
        },
        set ref(Z) {
          _(Z)
        }
      }))
    })
  }
  B(y, k), Wr()
}
var f6 = ae('<div class="border-base-content/10 flex h-9 items-center gap-2 border-b px-3" data-slot="command-input-wrapper"><!> <!></div>');

function m6(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "ref", 15, null),
    x = Ot(l, "value", 15, ""),
    k = Or(l, ["$$slots", "$$events", "$$legacy", "ref", "class", "value"]);
  var z = f6(),
    T = P(z);
  pb(T, {
    class: "size-5 opacity-50"
  });
  var s = E(T, 2);
  {
    let F = Je(() => Oc("placeholder:text-muted-foreground outline-hidden flex h-10 w-full rounded-md bg-transparent py-3 text-sm disabled:cursor-not-allowed disabled:opacity-50", l.class));
    yn(s, () => YM, (Z, K) => {
      K(Z, Bc({
        "data-slot": "command-input",
        get class() {
          return h(F)
        }
      }, () => k, {
        get ref() {
          return _()
        },
        set ref(G) {
          _(G)
        },
        get value() {
          return x()
        },
        set value(G) {
          x(G)
        }
      }))
    })
  }
  S(z), B(y, z), Wr()
}

function g6(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "ref", 15, null),
    x = Or(l, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var k = br(),
    z = zt(k);
  {
    let T = Je(() => Oc("max-h-[300px] scroll-py-1 overflow-y-auto overflow-x-hidden", l.class));
    yn(z, () => e6, (s, F) => {
      F(s, Bc({
        "data-slot": "command-list",
        get class() {
          return h(T)
        }
      }, () => x, {
        get ref() {
          return _()
        },
        set ref(Z) {
          _(Z)
        }
      }))
    })
  }
  B(y, k), Wr()
}
var _6 = Yr('<svg><path d="M480-80 240-320l57-57 183 183 183-183 57 57L480-80ZM298-584l-58-56 240-240 240 240-58 56-182-182-182 182Z"></path></svg>');

function v6(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = _6();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var y6 = ae("<span> </span> <!>", 1),
  x6 = ae('<span class="font-flag ml-0.5"> </span> ', 1),
  b6 = ae('<span class="flex gap-1.5"><span class="font-flag"> </span> </span>'),
  w6 = ae("<!> <!>", 1),
  T6 = ae("<!> <!>", 1),
  S6 = ae('<button class="btn btn-xs btn-circle btn-ghost"><!></button>'),
  P6 = ae('<div class="flex items-center"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-sm max-w-74 text-base-content/80 m-1"><!></div> <div><!></div></div> <!></div>');

function r0(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "countryId", 15, 0),
    x = Ot(l, "dropdownDirection", 3, "right"),
    k = Xe(null),
    z = Xe(null),
    T = Xe("");

  function s() {
    Xm().then(() => {
      var xe;
      (xe = document.activeElement) == null || xe.blur(), j(T, "")
    })
  }
  var F = P6(),
    Z = P(F),
    K = P(Z),
    G = P(K);
  {
    var re = xe => {
        var Ye = y6(),
          We = zt(Ye),
          ze = P(We, !0);
        S(We);
        var Se = E(We, 2);
        v6(Se, {
          class: "size-3.5"
        }), ke(Pe => ee(ze, Pe), [() => ag()]), B(xe, Ye)
      },
      he = xe => {
        const Ye = Je(() => Ds(_()));
        var We = x6(),
          ze = zt(We),
          Se = P(ze, !0);
        S(ze);
        var Pe = E(ze);
        ke(() => {
          ee(Se, h(Ye).flag), ee(Pe, ` ${h(Ye).name??""}`)
        }), B(xe, We)
      };
    Te(G, xe => {
      _() === 0 ? xe(re) : xe(he, !1)
    })
  }
  S(K);
  var me = E(K, 2);
  let q;
  var ye = P(me);
  yn(ye, () => c6, (xe, Ye) => {
    Ye(xe, {
      children: (We, ze) => {
        var Se = T6(),
          Pe = zt(Se);
        yn(Pe, () => m6, (Me, Ee) => {
          Ee(Me, {
            placeholder: "Country",
            get ref() {
              return h(k)
            },
            set ref(Qe) {
              j(k, Qe)
            },
            get value() {
              return h(T)
            },
            set value(Qe) {
              j(T, Qe, !0)
            }
          })
        });
        var Ae = E(Pe, 2);
        yn(Ae, () => g6, (Me, Ee) => {
          Ee(Me, {
            children: (Qe, Ue) => {
              var je = w6(),
                rt = zt(je);
              yn(rt, () => u6, (dt, at) => {
                at(dt, {
                  children: (nt, ot) => {
                    wi();
                    var ut = ja();
                    ke(st => ee(ut, st), [() => C2()]), B(nt, ut)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              });
              var _t = E(rt, 2);
              yn(_t, () => d6, (dt, at) => {
                at(dt, {
                  children: (nt, ot) => {
                    var ut = br(),
                      st = zt(ut);
                    Hi(st, 17, () => xn.countries, wt => wt.id, (wt, Ct) => {
                      var rr = br(),
                        Zt = zt(rr);
                      yn(Zt, () => p6, (lt, ht) => {
                        ht(lt, {
                          get value() {
                            return h(Ct).name
                          },
                          onSelect: () => {
                            _(h(Ct).id), s()
                          },
                          children: (Dt, Vt) => {
                            var Jt = b6(),
                              jt = P(Jt),
                              nr = P(jt, !0);
                            S(jt);
                            var St = E(jt);
                            S(Jt), ke(() => {
                              ee(nr, h(Ct).flag), ee(St, ` ${h(Ct).name??""}`)
                            }), B(Dt, Jt)
                          },
                          $$slots: {
                            default: !0
                          }
                        })
                      }), B(wt, rr)
                    }), B(nt, ut)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              }), B(Qe, je)
            },
            $$slots: {
              default: !0
            }
          })
        }), B(We, Se)
      },
      $$slots: {
        default: !0
      }
    })
  }), S(me), S(Z);
  var be = E(Z, 2);
  {
    var qe = xe => {
      var Ye = S6();
      Ye.__click = () => {
        _(0)
      };
      var We = P(Ye);
      ss(We, {
        class: "size-3.5"
      }), S(Ye), B(xe, Ye)
    };
    Te(be, xe => {
      _() != 0 && xe(qe)
    })
  }
  S(F), Rn(F, xe => j(z, xe), () => h(z)), ke(() => q = Er(me, 1, "dropdown-content menu bg-base-100 rounded-box z-1 border-base-content/10 w-52 rounded-lg border py-1 shadow-sm", null, q, {
    "right-1": x() === "left"
  })), Ci("focus", K, () => {
    h(k).focus()
  }), B(y, F), Wr()
}
Ui(["click"]);
var I6 = Yr('<svg><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-7-.5-14.5T799-507q-5 29-27 48t-52 19h-80q-33 0-56.5-23.5T560-520v-40H400v-80q0-33 23.5-56.5T480-720h40q0-23 12.5-40.5T563-789q-20-5-40.5-8t-42.5-3q-134 0-227 93t-93 227h200q66 0 113 47t47 113v40H400v110q20 5 39.5 7.5T480-160Z"></path></svg>');

function Cy(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = I6();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var M6 = Yr('<svg><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Z"></path></svg>'),
  C6 = Yr('<svg><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"></path></svg>');

function th(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy", "filled"]);
  var x = br(),
    k = zt(x);
  {
    var z = s => {
        var F = M6();
        jr(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ..._
        })), B(s, F)
      },
      T = s => {
        var F = C6();
        jr(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ..._
        })), B(s, F)
      };
    Te(k, s => {
      l.filled ? s(z) : s(T, !1)
    })
  }
  B(y, x)
}
var A6 = ae('<label class="tab grow font-semibold max-sm:h-10"><input type="radio" class="tab grow"/> <!> </label>'),
  k6 = ae('<div class="mb-2"><!></div>'),
  z6 = ae('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  E6 = ae('<tr><td class="text-base-content/80 text-center font-medium max-sm:hidden"> </td><td><span class="font-flag tooltip mr-1 text-base sm:text-lg"> </span> <span> <span class="ml-0.5"> </span></span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td><td class="px-1 text-center"><button class="btn btn-sm"> </button></td></tr>'),
  L6 = ae('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th class="max-sm:hidden"></th><th> </th><th class="text-center"> <br class="sm:hidden"/> <span class="tooltip max-sm:hidden"><!></span></th><th class="px-1"></th></tr></thead><tbody></tbody></table>'),
  D6 = ae('<tr><td class="text-base-content/80 text-center font-medium"> </td><td><span class="font-flag tooltip mr-1 text-base sm:text-lg"> </span> <span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  R6 = ae('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th> </th><th class="text-center"> <br class="sm:hidden"/> <span class="tooltip before:-translate-x-1/4 max-sm:hidden"><!></span></th></tr></thead><tbody></tbody></table>'),
  F6 = ae('<span class="font-flag tooltip ml-0.5"> </span>'),
  B6 = ae("<span> </span>"),
  O6 = ae('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="max-sm:px-1"><div class="flex items-center gap-2"><!> <div class="items-center gap-2 sm:flex"><!> <!> <!> <!></div></div></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  j6 = ae('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  q6 = ae('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="h-14 max-sm:px-1"><span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  N6 = ae('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  V6 = ae('<div class="h-screen pt-20"><div class="flex justify-center"><span class="loading loading-spinner"></span></div></div>'),
  U6 = ae('<div class="tabs tabs-box max-sm:tabs-xs"></div> <div class="my-4 flex items-center justify-between"><!> <!></div> <!> <!>', 1);

function Z6(y, l) {
  Gr(l, !0);
  const _ = [];
  let x = Xe(1e3);
  const k = Je(() => h(x) <= 640);
  let z = Xe("today"),
    T = {
      regions: {
        label: k2(),
        icon: qp
      },
      countries: {
        label: A2(),
        icon: Cy
      },
      players: {
        label: w0(),
        icon: Vp
      },
      alliances: {
        label: B0(),
        icon: Up
      }
    },
    s = Xe("regions"),
    F = Xe(0),
    Z = Wi({
      players: {},
      alliances: {},
      regions: {},
      countries: {}
    }),
    K = Je(() => {
      var Se, Pe, Ae;
      return h(s) === "regions" ? (Pe = (Se = Z[h(s)][h(F)]) == null ? void 0 : Se[h(z)]) == null ? void 0 : Pe.entries : (Ae = Z[h(s)][h(z)]) == null ? void 0 : Ae.entries
    });
  const G = 5 * 1e3;
  Qr(() => {
    var Me;
    if (!l.open) return;
    const Se = h(z),
      Pe = h(s),
      Ae = h(F);
    Pe === "players" && (!Z[Pe][Se] || Date.now() - Z[Pe][Se].time > G) ? Kr.leaderboardPlayers(Se).then(Ee => {
      Z[Pe][Se] = {
        time: Date.now(),
        entries: Ee
      }
    }).catch(Ee => Bt.error(Ee.message)) : Pe === "alliances" && (!Z[Pe][Se] || Date.now() - Z[Pe][Se].time > G) ? Kr.leaderboardAlliances(Se).then(Ee => {
      Z[Pe][Se] = {
        time: Date.now(),
        entries: Ee
      }
    }).catch(Ee => Bt.error(Ee.message)) : Pe === "countries" && (!Z[Pe][Se] || Date.now() - Z[Pe][Se].time > G) ? Kr.leaderboardCountries(Se).then(Ee => {
      Z[Pe][Se] = {
        time: Date.now(),
        entries: Ee
      }
    }).catch(Ee => Bt.error(Ee.message)) : Pe === "regions" && (!((Me = Z[Pe][Ae]) != null && Me[Se]) || Date.now() - Z[Pe][Ae][Se].time > G) && Kr.leaderboardRegions(Se, Ae).then(Ee => {
      Z[Pe][Ae] || (Z[Pe][Ae] = {}), Z[Pe][Ae][Se] = {
        time: Date.now(),
        entries: Ee
      }
    }).catch(Ee => Bt.error(Ee.message))
  });
  var re = U6(),
    he = zt(re);
  Hi(he, 21, () => Object.entries(T), ([Se, {
    label: Pe,
    icon: Ae
  }]) => Se, (Se, Pe) => {
    var Ae = Je(() => h0(h(Pe), 2));
    let Me = () => h(Ae)[0],
      Ee = () => h(Ae)[1].label,
      Qe = () => h(Ae)[1].icon;
    const Ue = Je(Qe);
    var je = A6(),
      rt = P(je);
    Ka(rt);
    var _t, dt = E(rt, 2);
    yn(dt, () => h(Ue), (nt, ot) => {
      ot(nt, {
        get this() {
          return Qe()
        },
        class: "mr-1 size-5 max-sm:hidden"
      })
    });
    var at = E(dt);
    S(je), ke(() => {
      Xt(rt, "aria-label", Ee()), _t !== (_t = Me()) && (rt.value = (rt.__value = Me()) ?? ""), ee(at, ` ${Ee()??""}`)
    }), Jm(_, [], rt, () => (Me(), h(s)), nt => j(s, nt)), B(Se, je)
  }), S(he);
  var me = E(he, 2),
    q = P(me);
  _g(q, {
    get value() {
      return h(z)
    },
    set value(Se) {
      j(z, Se, !0)
    }
  });
  var ye = E(q, 2);
  {
    var be = Se => {
      r0(Se, {
        dropdownDirection: "left",
        get countryId() {
          return h(F)
        },
        set countryId(Pe) {
          j(F, Pe, !0)
        }
      })
    };
    Te(ye, Se => {
      h(s) === "regions" && !h(k) && Se(be)
    })
  }
  S(me);
  var qe = E(me, 2);
  {
    var xe = Se => {
      var Pe = k6(),
        Ae = P(Pe);
      r0(Ae, {
        get countryId() {
          return h(F)
        },
        set countryId(Me) {
          j(F, Me, !0)
        }
      }), S(Pe), B(Se, Pe)
    };
    Te(qe, Se => {
      h(s) === "regions" && h(k) && Se(xe)
    })
  }
  var Ye = E(qe, 2);
  {
    var We = Se => {
        var Pe = z6(),
          Ae = P(Pe),
          Me = E(Ae);
        {
          var Ee = Ue => {
              var je = ja();
              ke(rt => ee(je, rt), [() => Bp().toLowerCase()]), B(Ue, je)
            },
            Qe = Ue => {
              var je = br(),
                rt = zt(je);
              {
                var _t = at => {
                    var nt = ja();
                    ke(ot => ee(nt, ot), [() => rg()]), B(at, nt)
                  },
                  dt = at => {
                    var nt = br(),
                      ot = zt(nt);
                    {
                      var ut = st => {
                        var wt = ja();
                        ke(Ct => ee(wt, Ct), [() => ig()]), B(st, wt)
                      };
                      Te(ot, st => {
                        h(z) === "month" && st(ut)
                      }, !0)
                    }
                    B(at, nt)
                  };
                Te(rt, at => {
                  h(z) === "week" ? at(_t) : at(dt, !1)
                }, !0)
              }
              B(Ue, je)
            };
          Te(Me, Ue => {
            h(z) === "today" ? Ue(Ee) : Ue(Qe, !1)
          })
        }
        S(Pe), ke(Ue => ee(Ae, `${Ue??""} `), [() => tg()]), B(Se, Pe)
      },
      ze = Se => {
        var Pe = br(),
          Ae = zt(Pe);
        {
          var Me = Qe => {
              var Ue = br(),
                je = zt(Ue);
              {
                var rt = dt => {
                    const at = Je(() => h(K));
                    var nt = L6(),
                      ot = P(nt),
                      ut = P(ot),
                      st = E(P(ut)),
                      wt = P(st, !0);
                    S(st);
                    var Ct = E(st),
                      rr = P(Ct),
                      Zt = E(rr, 2),
                      lt = E(Zt),
                      ht = P(lt);
                    th(ht, {
                      class: "text-base-content/50 mb-0.5 ml-1 inline size-4"
                    }), S(lt), S(Ct), wi(), S(ut), S(ot);
                    var Dt = E(ot);
                    Hi(Dt, 31, () => h(at), Vt => Vt.id, (Vt, Jt, jt) => {
                      const nr = Je(() => Ds(h(Jt).countryId));
                      var St = E6(),
                        Et = P(St),
                        Ut = P(Et, !0);
                      S(Et);
                      var Gt = E(Et),
                        Rt = P(Gt),
                        ir = P(Rt, !0);
                      S(Rt);
                      var kr = E(Rt, 2),
                        _r = P(kr),
                        fr = E(_r),
                        Yt = P(fr);
                      S(fr), S(kr), S(Gt);
                      var sr = E(Gt),
                        Kt = P(sr, !0);
                      S(sr);
                      var vr = E(sr),
                        Lr = P(vr);
                      Lr.__click = () => {
                        l.onvisitclick({
                          lat: h(Jt).lastLatitude,
                          lng: h(Jt).lastLongitude
                        })
                      };
                      var ii = P(Lr, !0);
                      S(Lr), S(vr), S(St), ke((mr, ge, V) => {
                        ee(Ut, h(jt) + 1), Xt(Rt, "data-tip", h(nr).name), ee(ir, h(nr).flag), Er(kr, 1, `font-semibold ${mr??""}`), ee(_r, `${h(Jt).name??""} `), ee(Yt, `#${h(Jt).number??""}`), ee(Kt, ge), ee(ii, V)
                      }, [() => Dn(h(Jt).cityId), () => h(Jt).pixelsPainted.toLocaleString(navigator.language), () => s3()]), vl(St, () => yl, () => ({
                        duration: 200
                      })), B(Vt, St)
                    }), S(Dt), S(nt), ke((Vt, Jt, jt, nr) => {
                      ee(wt, Vt), ee(rr, `${Jt??""} `), ee(Zt, `${jt??""} `), Xt(lt, "data-tip", nr)
                    }, [() => z2(), () => Cc(), () => Ac().toLowerCase(), () => E2()]), B(dt, nt)
                  },
                  _t = dt => {
                    var at = br(),
                      nt = zt(at);
                    {
                      var ot = st => {
                          var wt = R6(),
                            Ct = P(wt),
                            rr = P(Ct),
                            Zt = E(P(rr)),
                            lt = P(Zt, !0);
                          S(Zt);
                          var ht = E(Zt),
                            Dt = P(ht),
                            Vt = E(Dt, 2),
                            Jt = E(Vt),
                            jt = P(Jt);
                          th(jt, {
                            class: "text-base-content/50 mb-0.5 ml-1 inline size-4"
                          }), S(Jt), S(ht), S(rr), S(Ct);
                          var nr = E(Ct);
                          Hi(nr, 31, () => h(K), St => St.id, (St, Et, Ut) => {
                            const Gt = Je(() => Ds(h(Et).id) ?? {
                              name: `Pais ID: ${h(Et).id}`,
                              flag: "",
                              code: "XX"
                            });
                            var Rt = D6(),
                              ir = P(Rt),
                              kr = P(ir, !0);
                            S(ir);
                            var _r = E(ir),
                              fr = P(_r),
                              Yt = P(fr, !0);
                            S(fr);
                            var sr = E(fr, 2),
                              Kt = P(sr, !0);
                            S(sr), S(_r);
                            var vr = E(_r),
                              Lr = P(vr, !0);
                            S(vr), S(Rt), ke((ii, mr) => {
                              ee(kr, h(Ut) + 1), Xt(fr, "data-tip", h(Gt).name), ee(Yt, h(Gt).flag), Er(sr, 1, `font-semibold ${ii??""}`), ee(Kt, h(Gt).name), ee(Lr, mr)
                            }, [() => Dn(h(Et).id), () => h(Et).pixelsPainted.toLocaleString(navigator.language)]), vl(Rt, () => yl, () => ({
                              duration: 200
                            })), B(St, Rt)
                          }), S(nr), S(wt), ke((St, Et, Ut, Gt) => {
                            ee(lt, St), ee(Dt, `${Et??""} `), ee(Vt, `${Ut??""} `), Xt(Jt, "data-tip", Gt)
                          }, [() => ag(), () => Cc(), () => Ac().toLowerCase(), () => L2()]), B(st, wt)
                        },
                        ut = st => {
                          var wt = br(),
                            Ct = zt(wt);
                          {
                            var rr = lt => {
                                const ht = Je(() => h(K));
                                var Dt = j6(),
                                  Vt = P(Dt),
                                  Jt = P(Vt),
                                  jt = E(P(Jt)),
                                  nr = P(jt, !0);
                                S(jt);
                                var St = E(jt),
                                  Et = P(St),
                                  Ut = E(Et, 2, !0);
                                S(St), S(Jt), S(Vt);
                                var Gt = E(Vt);
                                Hi(Gt, 31, () => h(ht), Rt => Rt.id, (Rt, ir, kr) => {
                                  const _r = Je(() => {
                                    var oe;
                                    return ((oe = bt.data) == null ? void 0 : oe.id) === h(ir).id
                                  });
                                  var fr = O6();
                                  let Yt;
                                  var sr = P(fr),
                                    Kt = P(sr, !0);
                                  S(sr);
                                  var vr = E(sr),
                                    Lr = P(vr),
                                    ii = P(Lr);
                                  bn(ii, {
                                    class: "size-8 border sm:size-10",
                                    get userId() {
                                      return h(ir).id
                                    },
                                    get pictureUrl() {
                                      return h(ir).picture
                                    },
                                    get borderUrl() {
                                      return h(ir).frameUrl
                                    }
                                  });
                                  var mr = E(ii, 2),
                                    ge = P(mr);
                                  {
                                    let oe = Je(() => {
                                        var ve;
                                        return h(_r) ? ((ve = bt.data) == null ? void 0 : ve.name) ?? h(ir).name : h(ir).name
                                      }),
                                      fe = Je(() => {
                                        var ve;
                                        return h(_r) ? (ve = bt.data) == null ? void 0 : ve.equippedNameCosmetic : h(ir).equippedNameCosmetic
                                      });
                                    Bh(ge, {
                                      get name() {
                                        return h(oe)
                                      },
                                      get id() {
                                        return h(ir).id
                                      },
                                      get equippedNameCosmetic() {
                                        return h(fe)
                                      },
                                      class: "max-sm:ml-2"
                                    })
                                  }
                                  var V = E(ge, 2);
                                  {
                                    var U = oe => {
                                      const fe = Je(() => Ds(h(ir).equippedFlag));
                                      var ve = br(),
                                        ie = zt(ve);
                                      {
                                        var Y = Fe => {
                                          var Ne = F6(),
                                            Ge = P(Ne, !0);
                                          S(Ne), ke(() => {
                                            Xt(Ne, "data-tip", h(fe).name), ee(Ge, h(fe).flag)
                                          }), B(Fe, Ne)
                                        };
                                        Te(ie, Fe => {
                                          h(fe) && Fe(Y)
                                        })
                                      }
                                      B(oe, ve)
                                    };
                                    Te(V, oe => {
                                      h(ir).equippedFlag && oe(U)
                                    })
                                  }
                                  var J = E(V, 2);
                                  {
                                    var se = oe => {
                                      Fh(oe, {
                                        get username() {
                                          return h(ir).discord
                                        },
                                        get id() {
                                          return h(ir).discordId
                                        }
                                      })
                                    };
                                    Te(J, oe => {
                                      h(ir).discord && oe(se)
                                    })
                                  }
                                  var te = E(J, 2);
                                  {
                                    var _e = oe => {
                                      var fe = B6(),
                                        ve = P(fe, !0);
                                      S(fe), ke((ie, Y) => {
                                        Er(fe, 1, `badge badge-sm ml-0.5 border-0 ${ie??""} ${Y??""}`), ee(ve, h(ir).allianceName)
                                      }, [() => Rp(h(ir).allianceId), () => Dn(h(ir).allianceId)]), B(oe, fe)
                                    };
                                    Te(te, oe => {
                                      "allianceName" in h(ir) && h(ir).allianceName && oe(_e)
                                    })
                                  }
                                  S(mr), S(Lr), S(vr);
                                  var Re = E(vr),
                                    ne = P(Re, !0);
                                  S(Re), S(fr), ke(oe => {
                                    Yt = Er(fr, 1, "", null, Yt, {
                                      "bg-base-200": h(_r)
                                    }), ee(Kt, h(kr) + 1), ee(ne, oe)
                                  }, [() => h(ir).pixelsPainted.toLocaleString(navigator.language)]), vl(fr, () => yl, () => ({
                                    duration: 200
                                  })), B(Rt, fr)
                                }), S(Gt), S(Dt), ke((Rt, ir, kr) => {
                                  ee(nr, Rt), ee(Et, `${ir??""} `), ee(Ut, kr)
                                }, [() => ng(), () => Cc(), () => Ac().toLowerCase()]), B(lt, Dt)
                              },
                              Zt = lt => {
                                var ht = br(),
                                  Dt = zt(ht);
                                {
                                  var Vt = Jt => {
                                    var jt = N6(),
                                      nr = P(jt),
                                      St = P(nr),
                                      Et = E(P(St)),
                                      Ut = P(Et, !0);
                                    S(Et);
                                    var Gt = E(Et),
                                      Rt = P(Gt),
                                      ir = E(Rt, 2, !0);
                                    S(Gt), S(St), S(nr);
                                    var kr = E(nr);
                                    Hi(kr, 31, () => h(K), _r => _r.id, (_r, fr, Yt) => {
                                      const sr = Je(() => {
                                        var se;
                                        return ((se = bt.data) == null ? void 0 : se.allianceId) === h(fr).id
                                      });
                                      var Kt = q6();
                                      let vr;
                                      var Lr = P(Kt),
                                        ii = P(Lr, !0);
                                      S(Lr);
                                      var mr = E(Lr),
                                        ge = P(mr),
                                        V = P(ge, !0);
                                      S(ge), S(mr);
                                      var U = E(mr),
                                        J = P(U, !0);
                                      S(U), S(Kt), ke((se, te) => {
                                        vr = Er(Kt, 1, "", null, vr, {
                                          "bg-base-200": h(sr)
                                        }), ee(ii, h(Yt) + 1), Er(ge, 1, `font-semibold ${se??""}`), ee(V, h(fr).name), ee(J, te)
                                      }, [() => Dn(h(fr).id), () => h(fr).pixelsPainted.toLocaleString(navigator.language)]), vl(Kt, () => yl, () => ({
                                        duration: 200
                                      })), B(_r, Kt)
                                    }), S(kr), S(jt), ke((_r, fr, Yt) => {
                                      ee(Ut, _r), ee(Rt, `${fr??""} `), ee(ir, Yt)
                                    }, [() => Np(), () => Cc(), () => Ac().toLowerCase()]), B(Jt, jt)
                                  };
                                  Te(Dt, Jt => {
                                    h(s) === "alliances" && Jt(Vt)
                                  }, !0)
                                }
                                B(lt, ht)
                              };
                            Te(Ct, lt => {
                              h(s) === "players" ? lt(rr) : lt(Zt, !1)
                            }, !0)
                          }
                          B(st, wt)
                        };
                      Te(nt, st => {
                        h(s) === "countries" ? st(ot) : st(ut, !1)
                      }, !0)
                    }
                    B(dt, at)
                  };
                Te(je, dt => {
                  h(s) === "regions" ? dt(rt) : dt(_t, !1)
                })
              }
              B(Qe, Ue)
            },
            Ee = Qe => {
              var Ue = V6();
              B(Qe, Ue)
            };
          Te(Ae, Qe => {
            h(K) ? Qe(Me) : Qe(Ee, !1)
          }, !0)
        }
        B(Se, Pe)
      };
    Te(Ye, Se => {
      h(K) && h(K).length === 0 ? Se(We) : Se(ze, !1)
    })
  }
  Eh("innerWidth", Se => j(x, Se, !0)), B(y, re), Wr()
}
Ui(["click"]);
var G6 = Yr('<svg><path d="M160-200h160v-320H160v320Zm240 0h160v-560H400v560Zm240 0h160v-240H640v240ZM80-120v-480h240v-240h320v320h240v400H80Z"></path></svg>');

function Ay(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = G6();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var W6 = ae('<dialog class="modal" closedby="any"><div class="modal-box h-11/12 max-w-3xl max-sm:size-full max-sm:rounded-none max-sm:px-3 max-sm:py-5 sm:overflow-x-hidden"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2"></button></form> <div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold"> </h3></div> <div class="mt-4"><!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function H6(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "open", 15);
  var x = W6(),
    k = P(x),
    z = E(P(k), 2),
    T = P(z);
  Ay(T, {
    class: "size-6"
  });
  var s = E(T, 2),
    F = P(s, !0);
  S(s), S(z);
  var Z = E(z, 2),
    K = P(Z);
  Z6(K, {
    get onvisitclick() {
      return l.onvisitclick
    },
    get open() {
      return _()
    }
  }), S(Z), S(k), wi(2), S(x), qa(x, () => G => {
    Qr(() => {
      _() ? G.show() : G.close()
    })
  }), ke(G => ee(F, G), [() => cg()]), Ci("close", x, () => _(!1)), B(y, x), Wr()
}
var X6 = ae("<div><!></div>"),
  Y6 = ae('<dialog class="modal" closedby="any"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2"></button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function K6(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "open", 15);
  var x = Y6(),
    k = P(x),
    z = E(P(k), 2);
  {
    var T = s => {
      var F = X6(),
        Z = P(F);
      I3(Z, {}), S(F), dn(2, F, () => Jn, () => ({
        duration: 300
      })), B(s, F)
    };
    Te(z, s => {
      _() && s(T)
    })
  }
  S(k), wi(2), S(x), qa(x, () => s => {
    Qr(() => {
      _() ? s.show() : s.close()
    })
  }), Ci("close", x, () => _(!1)), B(y, x), Wr()
}
var J6 = ae("<p>You don't have charges to paint. <br/> </p>");

function $6(y, l) {
  Gr(l, !1), $m();
  var _ = J6(),
    x = E(P(_), 2);
  S(_), ke(k => ee(x, ` Next charge in ${k??""}`), [() => dy(bt.cooldown ?? 0)]), B(y, _), Wr()
}
var Q6 = ae('<form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2"></button></form>'),
  eC = ae('<form method="dialog" class="modal-backdrop"><button> </button></form>'),
  tC = ae('<dialog closedby="any"><div><!> <!></div> <!></dialog>');

function xg(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "open", 15),
    x = Ot(l, "hasBackdrop", 3, !0),
    k = Ot(l, "hasCloseButton", 3, !0);
  var z = tC(),
    T = P(z),
    s = P(T);
  {
    var F = re => {
      var he = Q6();
      B(re, he)
    };
    Te(s, re => {
      k() && re(F)
    })
  }
  var Z = E(s, 2);
  La(Z, () => l.children ?? $n), S(T);
  var K = E(T, 2);
  {
    var G = re => {
      var he = eC(),
        me = P(he),
        q = P(me, !0);
      S(me), S(he), ke(ye => ee(q, ye), [() => uo()]), B(re, he)
    };
    Te(K, re => {
      x() && re(G)
    })
  }
  S(z), qa(z, () => re => {
    Qr(() => {
      _() ? re.show() : re.close()
    })
  }), ke(() => {
    Er(z, 1, `modal ${l.dialogClass??""}`), Er(T, 1, `modal-box ${l.modalBoxClass??""}`)
  }), Ci("close", z, () => _(!1)), B(y, z), Wr()
}
var rC = ae('<div class="flex h-full flex-col gap-4"><span class="text-xl font-semibold"> </span> <span class="whitespace-pre-line"><!></span> <button class="btn btn-primary mx-auto w-max px-10"> </button></div>');

function iC(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "open", 15),
    x = Ot(l, "buttonText", 3, "OK");
  xg(y, {
    dialogClass: "!bg-black/80",
    modalBoxClass: "max-h-11/12",
    get open() {
      return _()
    },
    set open(k) {
      _(k)
    },
    children: (k, z) => {
      var T = rC(),
        s = P(T),
        F = P(s, !0);
      S(s);
      var Z = E(s, 2),
        K = P(Z);
      La(K, () => l.message), S(Z);
      var G = E(Z, 2);
      G.__click = () => {
        _(!1)
      };
      var re = P(G, !0);
      S(G), S(T), ke(() => {
        ee(F, l.title), ee(re, x())
      }), B(k, T)
    },
    $$slots: {
      default: !0
    }
  }), Wr()
}
Ui(["click"]);

function aC(y) {
  const l = new Date;
  return y.getDate() === l.getDate() && y.getMonth() === l.getMonth() && y.getFullYear() === l.getFullYear() ? y.toLocaleTimeString(navigator.language, {
    timeStyle: "short"
  }) : y.toLocaleDateString(navigator.language, {
    dateStyle: "medium"
  })
}
var nC = ae('<span class="size-2 rounded-full bg-red-400"></span>'),
  sC = ae('<button class="hover:bg-base-content/10 flex gap-3 px-6 py-3"><div class="bg-primary/30 flex size-10 min-h-10 min-w-10 items-center justify-center rounded-full"><!></div> <div class="grow text-sm"><div class="flex items-baseline justify-between"><h3 class="font-semibold"> </h3> <div class="text-base-content/80 flex items-center gap-1.5 text-xs"><span> </span> <!></div></div> <p class="mt-0.5 text-left"> </p></div></button>');

function i0(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "read", 15);
  var x = sC();
  x.__click = () => {
    _(!0), l.onclick()
  };
  var k = P(x),
    z = P(k);
  La(z, () => l.icon), S(k);
  var T = E(k, 2),
    s = P(T),
    F = P(s),
    Z = P(F, !0);
  S(F);
  var K = E(F, 2),
    G = P(K),
    re = P(G, !0);
  S(G);
  var he = E(G, 2);
  {
    var me = be => {
      var qe = nC();
      B(be, qe)
    };
    Te(he, be => {
      _() || be(me)
    })
  }
  S(K), S(s);
  var q = E(s, 2),
    ye = P(q, !0);
  S(q), S(T), S(x), ke(be => {
    ee(Z, l.title), ee(re, be), ee(ye, l.message)
  }, [() => aC(l.createdAt)]), B(y, x), Wr()
}
Ui(["click"]);
var oC = Yr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h168q13-36 43.5-58t68.5-22q38 0 68.5 22t43.5 58h168q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm80-80h280v-80H280v80Zm0-160h400v-80H280v80Zm0-160h400v-80H280v80Zm200-190q13 0 21.5-8.5T510-820q0-13-8.5-21.5T480-850q-13 0-21.5 8.5T450-820q0 13 8.5 21.5T480-790ZM200-200v-560 560Z"></path></svg>');

function a0(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = oC();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var lC = ae('<button class="btn btn-sm btn-ghost"> </button>'),
  cC = ae('<p class="text-base-content/80 mt-4 text-center text-sm"> </p>'),
  uC = ae("<!> <!>", 1),
  hC = ae('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'),
  dC = ae('<div class="flex items-center justify-between gap-2 px-6"><h3 class="text-xl font-bold"> </h3> <!></div> <section class="mt-4"><!> <!></section>', 1),
  pC = ae("<p> </p>"),
  fC = ae("<!> <!>", 1);

function mC(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "open", 15),
    x = Xe(!1),
    k = Xe(void 0),
    z = Xe(void 0),
    T = Xe(!1),
    s = Xe(""),
    F = Xe("");
  var Z = fC(),
    K = zt(Z);
  xg(K, {
    modalBoxClass: "h-11/12 max-h-11/12 px-0",
    get open() {
      return _()
    },
    set open(re) {
      _(re)
    },
    children: (re, he) => {
      var me = dC(),
        q = zt(me),
        ye = P(q),
        be = P(ye, !0);
      S(ye);
      var qe = E(ye, 2);
      {
        var xe = Ae => {
          var Me = lC();
          Me.__click = async () => {
            if (Kr.postNotificationMarkReadAll(), bt.notificiationCount = 0, h(k))
              for (const Qe of h(k)) Qe.read = !0
          };
          var Ee = P(Me, !0);
          S(Me), ke(Qe => ee(Ee, Qe), [() => D2()]), B(Ae, Me)
        };
        Te(qe, Ae => {
          bt.notificiationCount !== 0 && Ae(xe)
        })
      }
      S(q);
      var Ye = E(q, 2),
        We = P(Ye);
      {
        var ze = Ae => {
          var Me = uC(),
            Ee = zt(Me);
          Hi(Ee, 17, () => h(k), je => je.id, (je, rt, _t) => {
            var dt = br(),
              at = zt(dt);
            {
              var nt = ut => {
                  {
                    const st = Zt => {
                      a0(Zt, {
                        class: "size-5"
                      })
                    };
                    let wt = Je(() => yv()),
                      Ct = Je(() => xv()),
                      rr = Je(() => new Date(h(rt).createdAt));
                    i0(ut, {
                      get title() {
                        return h(wt)
                      },
                      get message() {
                        return h(Ct)
                      },
                      get createdAt() {
                        return h(rr)
                      },
                      onclick: () => {
                        j(s, yv(), !0), j(F, `${xv()} ${R2()}`), j(T, !0)
                      },
                      get read() {
                        return h(rt).read
                      },
                      set read(Zt) {
                        h(rt).read = Zt
                      },
                      icon: st,
                      $$slots: {
                        icon: !0
                      }
                    })
                  }
                },
                ot = ut => {
                  var st = br(),
                    wt = zt(st);
                  {
                    var Ct = rr => {
                      {
                        const Zt = Vt => {
                          a0(Vt, {
                            class: "size-5"
                          })
                        };
                        let lt = Je(() => bv()),
                          ht = Je(() => {
                            var Vt;
                            return (Vt = h(rt).data) != null && Vt.approved ? wv() : Sv()
                          }),
                          Dt = Je(() => new Date(h(rt).createdAt));
                        i0(rr, {
                          get title() {
                            return h(lt)
                          },
                          get message() {
                            return h(ht)
                          },
                          get createdAt() {
                            return h(Dt)
                          },
                          onclick: () => {
                            var Vt;
                            j(s, bv(), !0), j(F, (Vt = h(rt).data) != null && Vt.approved ? `${wv()}

${Tv()}` : `${Sv()}

${Tv()}`, !0), j(T, !0)
                          },
                          get read() {
                            return h(rt).read
                          },
                          set read(Vt) {
                            h(rt).read = Vt
                          },
                          icon: Zt,
                          $$slots: {
                            icon: !0
                          }
                        })
                      }
                    };
                    Te(wt, rr => {
                      h(rt).type === "appeal_feedback" && rr(Ct)
                    }, !0)
                  }
                  B(ut, st)
                };
              Te(at, ut => {
                h(rt).type === "report_feedback" ? ut(nt) : ut(ot, !1)
              })
            }
            B(je, dt)
          });
          var Qe = E(Ee, 2);
          {
            var Ue = je => {
              var rt = cC(),
                _t = P(rt, !0);
              S(rt), ke(dt => ee(_t, dt), [() => F2()]), B(je, rt)
            };
            Te(Qe, je => {
              h(k).length === 0 && !h(x) && je(Ue)
            })
          }
          B(Ae, Me)
        };
        Te(We, Ae => {
          h(k) && Ae(ze)
        })
      }
      var Se = E(We, 2);
      {
        var Pe = Ae => {
          var Me = hC();
          qa(Me, () => Ee => {
            const Qe = new IntersectionObserver(Ue => {
              Ue[0].isIntersecting && !h(x) && (j(x, !0), Kr.getNotificationPage(h(z)).then(je => {
                j(k, [...h(k) ?? [], ...je.notifications], !0), j(z, je.nextCursor, !0);
                const rt = je.notifications.filter(_t => !_t.read).map(_t => _t.id);
                rt.length > 0 && (Kr.postNotificationMarkRead(rt), bt.notificiationCount !== void 0 && (bt.notificiationCount = Math.max(0, bt.notificiationCount - rt.length)))
              }).catch(je => {
                Bt.error(je.message)
              }).finally(() => {
                j(x, !1)
              }))
            });
            return Qe.observe(Ee), () => {
              Qe.disconnect()
            }
          }), B(Ae, Me)
        };
        Te(Se, Ae => {
          _() && (h(k) === void 0 || h(z) !== void 0) && Ae(Pe)
        })
      }
      S(Ye), ke(Ae => ee(be, Ae), [() => T0()]), B(re, me)
    },
    $$slots: {
      default: !0
    }
  });
  var G = E(K, 2);
  iC(G, {
    get title() {
      return h(s)
    },
    get open() {
      return h(T)
    },
    set open(he) {
      j(T, he, !0)
    },
    message: he => {
      var me = pC(),
        q = P(me, !0);
      S(me), ke(() => ee(q, h(F))), B(he, me)
    },
    $$slots: {
      message: !0
    }
  }), B(y, Z), Wr()
}
Ui(["click"]);
var gC = ae("<canvas></canvas>");

function ky(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "width", 15, 0),
    x = Or(l, ["$$slots", "$$events", "$$legacy", "value", "fontSize", "color", "weight", "mono", "width"]),
    k = Je(() => Math.ceil(l.fontSize)),
    z = Xe(null);
  const T = window.devicePixelRatio ?? 1,
    s = '"Geist", ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"',
    F = '"Geist Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  Qr(() => {
    const K = h(z).getContext("2d");
    K.textBaseline = "top", K.font = `${l.weight??"normal"} ${l.fontSize}px ${l.mono?F:s}`, K.fillStyle = l.color ?? "#394e6a", K.setTransform(T, 0, 0, T, 0, 0), K.clearRect(0, 0, _(), h(k)), K.fillText(l.value, 0, 0);
    const G = K.measureText(l.value);
    _(Math.ceil(G.actualBoundingBoxRight)), j(k, G.actualBoundingBoxDescent)
  });
  var Z = gC();
  jr(Z, () => ({
    width: _() * T,
    height: h(k) * T,
    style: `width: ${_()??""}px; height: ${h(k)??""}px`,
    ...x
  })), Rn(Z, K => j(z, K), () => h(z)), B(y, Z), Wr()
}
var _C = ae('<span class="w-7 text-xs"> </span>'),
  vC = ae('<span class="flex items-center gap-1 sm:mt-px"><span><!></span> <!></span>'),
  yC = ae('<span class="loading loading-spinner center-absolute absolute"></span>'),
  xC = ae('<button><div class="flex items-center gap-1.5"><!> <div class="flex items-center gap-2 whitespace-nowrap"> <!></div></div> <!></button>');

function zy(y, l) {
  Gr(l, !0);
  let _ = Or(l, ["$$slots", "$$events", "$$legacy", "loading", "charges", "maxWidth"]),
    x = Xe(0),
    k = Xe(null),
    z = Xe(void 0);
  fo(() => [l.loading, l.maxWidth], () => {
    j(z, void 0), requestAnimationFrame(() => {
      const q = h(k).offsetWidth;
      !l.loading && l.maxWidth !== void 0 && q + 20 > l.maxWidth ? j(z, 16 * (l.maxWidth / q) * .8) : j(z, void 0)
    })
  });
  var T = xC();
  jr(T, () => ({
    ..._,
    class: `btn btn-primary btn-lg sm:btn-xl relative ${l.class??""}`,
    style: `max-width: ${l.maxWidth?`${l.maxWidth}px`:"none"}
	${h(z)?`;font-size: ${h(z)}px`:""}`
  }));
  var s = P(T),
    F = P(s);
  Vo(F, {
    class: "size-6"
  });
  var Z = E(F, 2),
    K = P(Z),
    G = E(K);
  {
    var re = q => {
      const ye = Je(() => `${Math.floor(l.charges)}/${bt.data.charges.max}`);
      var be = vC(),
        qe = P(be),
        xe = P(qe);
      {
        let ze = Je(() => h(z) ?? 16),
          Se = Je(() => l.disabled ? "#394e6a33" : "#ffffff");
        ky(xe, {
          weight: 600,
          get fontSize() {
            return h(ze)
          },
          get value() {
            return h(ye)
          },
          get color() {
            return h(Se)
          },
          get width() {
            return h(x)
          },
          set width(Pe) {
            j(x, Pe, !0)
          }
        })
      }
      S(qe);
      var Ye = E(qe, 2);
      {
        var We = ze => {
          var Se = _C(),
            Pe = P(Se);
          S(Se), ke(Ae => ee(Pe, `(${Ae??""})`), [() => dy(bt.cooldown)]), B(ze, Se)
        };
        Te(Ye, ze => {
          l.charges < bt.data.charges.max && bt.cooldown !== void 0 && ze(We)
        })
      }
      S(be), ke(ze => Qn(qe, `width: ${ze??""}px`), [() => (Math.floor(h(x) / 5) + 1) * 5]), B(q, be)
    };
    Te(G, q => {
      l.charges !== void 0 && bt.data && q(re)
    })
  }
  S(Z), S(s), Rn(s, q => j(k, q), () => h(k));
  var he = E(s, 2);
  {
    var me = q => {
      var ye = yC();
      B(q, ye)
    };
    Te(he, q => {
      l.loading && q(me)
    })
  }
  S(T), ke(q => ee(K, `${q??""} `), [() => S0()]), B(y, T), Wr()
}
const bC = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAABVQTFRFAAAASkKEenHEta7xWmmLi5y0v8vc+SuCVQAAAAF0Uk5TAEDm2GYAAAA/SURBVHjaXcjBDcAwDMNAUW28/8hF0MCIzN9RV7aVfuxp+IGPe+AdPQRpFaRrgcNrn/Bb4LAE4W5aNb3TXUofoSgBYpzN5I4AAAAASUVORK5CYII=",
  wC = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAFxJREFUeNq107EJACAMRFEHyxSu4jbuZ+0IyhUS4ZDogYEr3++Svp+ZDUzGrRTMIwKmiIApImCKiBgbOXOEcRxQsQcW7rVKeA9gj5gD2D3mgC/GcQSLMEdO+/qtE+/GV5duYCOPAAAAAElFTkSuQmCC",
  TC = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAAXNSR0IArs4c6QAAAAJ0Uk5TAAB2k804AAAAKklEQVR42mOAAhsbCA3n//9vQ74ApqE2QIAgwIqBykFaICwMAQwt9HEpAIf2Me1Ro5Q9AAAAAElFTkSuQmCC",
  SC = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAABVJREFUeNpjYGA48x8DYwoB1Q0RlQDDCVmniJ241gAAAABJRU5ErkJggg==";
class PC {
  constructor(l) {
    bi(this, "gm");
    bi(this, "opacity", 1);
    bi(this, "id", `paint-preview-${Math.random()}`);
    bi(this, "tiles", new Map);
    this.input = l, this.gm = new kn(this.input.tileSize)
  }
  place([l, _], x) {
    const {
      tile: k,
      pixel: z
    } = this.gm.latLonToTileAndPixel(l, _, this.input.tileZoom), T = this.getTileKey(k[0], k[1]);
    let s = this.tiles.get(T);
    if (!s) {
      const F = this.gm.tileBoundsLatLon(k[0], k[1], this.input.tileZoom),
        Z = hg(F, !0),
        K = new IC({
          coordinates: Z,
          id: `${this.id}-${T}`,
          layerPaint: {
            "raster-opacity": this.opacity,
            "raster-resampling": "nearest"
          },
          tileSize: this.input.tileSize,
          beforeLayerId: this.input.beforeLayerId
        });
      K.addTo(this.input.map), this.tiles.set(T, K), s = K
    }
    s.place(z[0], this.input.tileSize - z[1] - 1, x)
  }
  clear() {
    const l = this.input.map;
    for (const _ of this.tiles.values()) _.removeFrom(l), _.removeDOM();
    this.tiles.clear()
  }
  clearAndPlace(l, _) {
    this.clear(), this.place(l, _)
  }
  remove([l, _]) {
    const {
      tile: x,
      pixel: k
    } = this.gm.latLonToTileAndPixel(l, _, this.input.tileZoom), z = this.getTileKey(x[0], x[1]), T = this.tiles.get(z);
    T && T.remove(k[0], this.input.tileSize - k[1] - 1)
  }
  setCanvasOpacity(l) {
    this.opacity = l;
    for (const _ of this.tiles.values()) _.setOpacity(l)
  }
  getTileKey(l, _) {
    return `${l},${_}`
  }
}
class IC {
  constructor(l) {
    bi(this, "canvas");
    bi(this, "maps", new Set);
    this.input = l;
    const _ = this.input.tileSize;
    this.canvas = document.createElement("canvas"), this.canvas.width = _, this.canvas.height = _
  }
  place(l, _, x) {
    var T;
    const k = ((T = xn.colors) == null ? void 0 : T[x]) ?? xn.colors[0],
      z = this.canvas.getContext("2d");
    if (z) {
      const s = z.createImageData(1, 1),
        [F, Z, K] = k.rgb,
        G = x === 0 ? 0 : 255;
      s.data[0] = F, s.data[1] = Z, s.data[2] = K, s.data[3] = G, z.putImageData(s, l, _)
    }
  }
  remove(l, _) {
    const x = this.canvas.getContext("2d");
    x && x.clearRect(l, _, 1, 1)
  }
  addTo(l) {
    const _ = this.input.id;
    l.getSource(_) || l.addSource(_, {
      type: "canvas",
      canvas: this.canvas,
      coordinates: this.input.coordinates
    }), l.getLayer(_) || (l.addLayer({
      id: _,
      type: "raster",
      source: _,
      paint: this.input.layerPaint
    }), this.input.beforeLayerId && l.moveLayer(_, this.input.beforeLayerId)), this.maps.add(l)
  }
  removeFrom(l) {
    const {
      id: _
    } = this.input;
    l.getLayer(_) && l.removeLayer(_), l.getSource(_) && l.removeSource(_), this.maps.delete(l)
  }
  removeDOM() {
    this.canvas.remove()
  }
  setOpacity(l) {
    for (const _ of this.maps.values()) _.setPaintProperty(this.input.id, "raster-opacity", l)
  }
}
var MC = Yr('<svg><path d="M5 21C4.45 21 3.97917 20.8042 3.5875 20.4125C3.19583 20.0208 3 19.55 3 19V15H5V19H9V21H5ZM15 21V19H19V15H21V19C21 19.55 20.8042 20.0208 20.4125 20.4125C20.0208 20.8042 19.55 21 19 21H15ZM3 9V5C3 4.45 3.19583 3.97917 3.5875 3.5875C3.97917 3.19583 4.45 3 5 3H9V5H5V9H3ZM19 9V5H15V3H19C19.55 3 20.0208 3.19583 20.4125 3.5875C20.8042 3.97917 21 4.45 21 5V9H19Z"></path></svg>');

function CC(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = MC();
  jr(x, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ..._
  })), B(y, x)
}
var AC = Yr('<svg><path d="M5 19H9V21H5C4.45 21 3.97956 20.8038 3.58789 20.4121C3.19622 20.0204 3 19.55 3 19V15H5V19ZM20.6768 20.0908C20.6015 20.2031 20.5138 20.3105 20.4121 20.4121C20.0204 20.8038 19.55 21 19 21H15V19H19V18.4141L20.6768 20.0908ZM21 17.5859L19 15.5859V15H21V17.5859ZM5.58594 5H5V9H3V5C3 4.45 3.19622 3.97956 3.58789 3.58789C3.68947 3.48631 3.79597 3.3975 3.9082 3.32227L5.58594 5ZM19 3C19.55 3 20.0204 3.19622 20.4121 3.58789C20.8038 3.97956 21 4.45 21 5V9H19V5H15V3H19ZM9 5H8.41406L6.41406 3H9V5Z"></path><rect x="1" y="2.41422" width="2" height="29" transform="rotate(-45 1 2.41422)"></rect></svg>');

function kC(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = AC();
  jr(x, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ..._
  })), B(y, x)
}
var zC = ae("<div><!></div>");

function Mc(y, l) {
  Gr(l, !0);
  var _ = zC(),
    x = P(_);
  La(x, () => l.children ?? $n), S(_), ke(() => Er(_, 1, `bg-base-100/60 border-base-content/20 -top-15 pointer-events-none absolute left-1/2 line-clamp-1 flex w-max -translate-x-1/2 select-none items-center gap-1 rounded-full border-2 px-3 py-1.5 ${l.class??""}`)), B(y, _), Wr()
}
var EC = ae('<div class="confetti svelte-av71ki"></div>'),
  LC = ae("<div></div>");

function bg(y, l) {
  Gr(l, !0);
  const _ = Ot(l, "size", 3, 10),
    x = Ot(l, "x", 19, () => [-.5, .5]),
    k = Ot(l, "y", 19, () => [.25, 1]),
    z = Ot(l, "duration", 3, 2e3),
    T = Ot(l, "infinite", 3, !1),
    s = Ot(l, "delay", 19, () => [0, 50]),
    F = Ot(l, "colorRange", 19, () => [0, 360]),
    Z = Ot(l, "colorArray", 19, () => []),
    K = Ot(l, "amount", 3, 50),
    G = Ot(l, "iterationCount", 3, 1),
    re = Ot(l, "fallDistance", 3, "100px"),
    he = Ot(l, "rounded", 3, !1),
    me = Ot(l, "cone", 3, !1),
    q = Ot(l, "noGravity", 3, !1),
    ye = Ot(l, "xSpread", 3, .15),
    be = Ot(l, "destroyOnComplete", 3, !0),
    qe = Ot(l, "disableForReducedMotion", 3, !1);
  let xe = Xe(!1);
  Oa(() => {
    !be() || T() || typeof G() == "string" || setTimeout(() => j(xe, !0), (z() + s()[1]) * G())
  });

  function Ye(Ae, Me) {
    return Math.random() * (Me - Ae) + Ae
  }

  function We() {
    return Z().length ? Z()[Math.round(Math.random() * (Z().length - 1))] : `hsl(${Math.round(Ye(F()[0],F()[1]))}, 75%, 50%)`
  }
  var ze = br(),
    Se = zt(ze);
  {
    var Pe = Ae => {
      var Me = LC();
      let Ee;
      Hi(Me, 21, () => ({
        length: K()
      }), po, (Qe, Ue) => {
        var je = EC();
        ke((rt, _t, dt, at, nt, ot, ut, st, wt, Ct, rr) => Qn(je, `
        --color: ${rt??""};
        --skew: ${_t??""}deg,${dt??""}deg;
        --rotation-xyz: ${at??""}, ${nt??""}, ${ot??""};
        --rotation-deg: ${ut??""}deg;
        --translate-y-multiplier: ${st??""};
        --translate-x-multiplier: ${wt??""};
        --scale: ${Ct??""};
        --transition-delay: ${rr??""}ms;
        --transition-duration: ${T()?`calc(${z()}ms * var(--scale))`:`${z()}ms`};`), [We, () => Ye(-45, 45), () => Ye(-45, 45), () => Ye(-10, 10), () => Ye(-10, 10), () => Ye(-10, 10), () => Ye(0, 360), () => Ye(k()[0], k()[1]), () => Ye(x()[0], x()[1]), () => .1 * Ye(2, 10), () => Ye(s()[0], s()[1])]), B(Qe, je)
      }), S(Me), ke(() => {
        Ee = Er(Me, 1, "confetti-holder svelte-av71ki", null, Ee, {
          rounded: he(),
          cone: me(),
          "no-gravity": q(),
          "reduced-motion": qe()
        }), Qn(Me, `
    --fall-distance: ${re()??""};
    --size: ${_()??""}px;
    --x-spread: ${1-ye()};
    --transition-iteration-count: ${(T()?"infinite":G())??""};`)
      }), B(Ae, Me)
    };
    Te(Se, Ae => {
      h(xe) || Ae(Pe)
    })
  }
  B(y, ze), Wr()
}
var DC = ae('<span class="loading loading-spinner center-absolute absolute"></span>'),
  RC = ae('<!> <span class="text-sm">Droplets</span>', 1),
  FC = ae('<!> Unlocked <span class="center-absolute absolute"><!></span>', 1),
  BC = ae('<div class="flex flex-col gap-4"><section><div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold">Unlock</h3> <div class="ml-auto mr-4"><!></div></div> <p class="text-base-content/80 mt-1 text-sm">Permanently unlock the color</p></section> <div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><div class="border-base-content/20 size-32 rounded-2xl border-4"></div></div> <p class="mt-4 text-center text-2xl font-bold"> </p> <div class="flex w-max flex-col"><div><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <!></button></div> <button class="btn relative mt-3 h-10">Close</button></div></div></div>'),
  OC = ae('<dialog class="modal bg-black/80!" closedby="any"><div class="modal-box max-h-11/12 w-11/12 max-w-md"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2"></button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function jC(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "open", 15);
  const x = Je(() => xn.colors[l.colorIdx]),
    k = Je(() => {
      var he;
      return ((he = bt.data) == null ? void 0 : he.droplets) ?? 0
    });
  let z = Xe(!1);
  const T = Je(() => (h(z), bt.hasColor(l.colorIdx))),
    s = 100,
    F = xn.products[s];
  var Z = OC(),
    K = P(Z),
    G = E(P(K), 2);
  {
    var re = he => {
      var me = BC(),
        q = P(me),
        ye = P(q),
        be = P(ye);
      kp(be, {
        class: "size-6"
      });
      var qe = E(be, 4),
        xe = P(qe);
      m0(xe, {
        get value() {
          return h(k)
        }
      }), S(qe), S(ye), wi(2), S(q);
      var Ye = E(q, 2),
        We = P(Ye),
        ze = P(We);
      S(We);
      var Se = E(We, 2),
        Pe = P(Se, !0);
      S(Se);
      var Ae = E(Se, 2),
        Me = P(Ae);
      let Ee;
      var Qe = P(Me);
      Qe.__click = async () => {
        try {
          j(z, !0), await Kr.purchase({
            id: s,
            amount: 1,
            variant: l.colorIdx
          }), await bt.refresh(), aa.notification1.play()
        } catch (nt) {
          Bt.error(nt.message)
        } finally {
          j(z, !1)
        }
      };
      var Ue = P(Qe);
      {
        var je = nt => {
          var ot = DC();
          B(nt, ot)
        };
        Te(Ue, nt => {
          h(z) && nt(je)
        })
      }
      var rt = E(Ue, 2);
      {
        var _t = nt => {
            var ot = RC(),
              ut = zt(ot);
            Dp(ut, {
              class: "size-5"
            });
            var st = E(ut);
            wi(), ke(wt => ee(st, ` ${wt??""} `), [() => F.price.toLocaleString(navigator.language)]), B(nt, ot)
          },
          dt = nt => {
            var ot = FC(),
              ut = zt(ot);
            kp(ut, {
              class: "size-5"
            });
            var st = E(ut, 2),
              wt = P(st);
            bg(wt, {}), S(st), B(nt, ot)
          };
        Te(rt, nt => {
          h(T) ? nt(dt, !1) : nt(_t)
        })
      }
      S(Qe), S(Me);
      var at = E(Me, 2);
      at.__click = () => _(!1), S(Ae), S(Ye), S(me), ke(nt => {
        Qn(ze, `background: rgb(${h(x).rgb[0]} ${h(x).rgb[1]} ${h(x).rgb[2]})`), Xt(ze, "aria-label", h(x).name), ee(Pe, h(x).name), Xt(Me, "data-tip", nt), Ee = Er(Me, 1, "", null, Ee, {
          tooltip: !h(T) && h(k) < F.price
        }), Qe.disabled = h(k) < F.price || h(z) || h(T)
      }, [() => Op()]), B(he, me)
    };
    Te(G, he => {
      bt.data && he(re)
    })
  }
  S(K), wi(2), S(Z), qa(Z, () => he => {
    Qr(() => {
      _() ? he.show() : he.close()
    })
  }), Ci("close", Z, () => _(!1)), B(y, Z), Wr()
}
Ui(["click"]);
var qC = Yr('<svg><path d="M120-120v-190l358-358-58-56 58-56 76 76 124-124q5-5 12.5-8t15.5-3q8 0 15 3t13 8l94 94q5 6 8 13t3 15q0 8-3 15.5t-8 12.5L705-555l76 78-57 57-56-58-358 358H120Zm80-80h78l332-334-76-76-334 332v78Zm447-410 96-96-37-37-96 96 37 37Zm0 0-37-37 37 37Z"></path></svg>');

function n0(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = qC();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var NC = Yr('<svg><path d="m247-904 57-56 343 343q23 23 23 57t-23 57L457-313q-23 23-57 23t-57-23L153-503q-23-23-23-57t23-57l190-191-96-96Zm153 153L209-560h382L400-751Zm360 471q-33 0-56.5-23.5T680-360q0-21 12.5-45t27.5-45q9-12 19-25t21-25q11 12 21 25t19 25q15 21 27.5 45t12.5 45q0 33-23.5 56.5T760-280ZM80 0v-160h800V0H80Z"></path></svg>');

function Ey(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = NC();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var VC = Yr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm240-400v80h80v-80h-80Zm-160 0v80h80v-80h-80Zm80 80v80h80v-80h-80Zm160 0v80h80v-80h-80Zm-320 0v80h80v-80h-80Zm400-80v80h80v80h80v-80h-80v-80h-80ZM280-360v80h-80v80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h-80v80h-80v-80h-80v80h-80v-80h-80Zm480-160v80-80Zm0 160v80-80Z"></path></svg>'),
  UC = Yr('<svg><path d="M440-440v-80h80v80h-80Zm-80 80v-80h80v80h-80Zm160 0v-80h80v80h-80Zm80-80v-80h80v80h-80Zm-320 0v-80h80v80h-80Zm-80 320q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm80-80h80v-80h-80v80Zm160 0h80v-80h-80v80Zm320 0v-80 80Zm-560-80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h80v-320H200v320h80v80h-80v80Zm0 80v-560 560Zm560-240v80-80ZM600-280v80h80v-80h-80Z"></path></svg>');

function Ly(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy", "filled"]);
  var x = br(),
    k = zt(x);
  {
    var z = s => {
        var F = VC();
        jr(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ..._
        })), B(s, F)
      },
      T = s => {
        var F = UC();
        jr(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ..._
        })), B(s, F)
      };
    Te(k, s => {
      l.filled ? s(z) : s(T, !1)
    })
  }
  B(y, x)
}
var ZC = Yr('<svg><path d="M240-80q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640h40v-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240Zm0-80h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM360-640h240v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85v80ZM240-160v-400 400Z"></path></svg>');

function rh(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = ZC();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var GC = Yr('<svg><path d="M396-200q-97 0-166.5-63T160-420q0-94 69.5-157T396-640h252L544-744l56-56 200 200-200 200-56-56 104-104H396q-63 0-109.5 40T240-420q0 60 46.5 100T396-280h284v80H396Z"></path></svg>');

function WC(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = GC();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var HC = Yr('<svg><path d="M419-80q-28 0-52.5-12T325-126L107-403l19-20q20-21 48-25t52 11l74 45v-328q0-17 11.5-28.5T340-760q17 0 29 11.5t12 28.5v472l-97-60 104 133q6 7 14 11t17 4h221q33 0 56.5-23.5T720-240v-160q0-17-11.5-28.5T680-440H461v-80h219q50 0 85 35t35 85v160q0 66-47 113T640-80H419ZM167-620q-13-22-20-47.5t-7-52.5q0-83 58.5-141.5T340-920q83 0 141.5 58.5T540-720q0 27-7 52.5T513-620l-69-40q8-14 12-28.5t4-31.5q0-50-35-85t-85-35q-50 0-85 35t-35 85q0 17 4 31.5t12 28.5l-69 40Zm335 280Z"></path></svg>');

function Dy(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = HC();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var XC = Yr('<svg><path d="M280-200v-80h284q63 0 109.5-40T720-420q0-60-46.5-100T564-560H312l104 104-56 56-200-200 200-200 56 56-104 104h252q97 0 166.5 63T800-420q0 94-69.5 157T564-200H280Z"></path></svg>');

function YC(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = XC();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var KC = ae("<!> ", 1),
  JC = ae("<!> ", 1),
  $C = ae("<!> ", 1),
  QC = ae('<!><b> </b> <span class="touchscreen:hidden"> <span class="kbd kbd-xs text-base-content rounded-md"> </span></span> ', 1),
  eA = ae("<!> ", 1),
  tA = ae('<!> <span class="bg-base-100 absolute right-0 bottom-0 flex size-5 translate-1/2 items-center justify-center rounded-full max-sm:hidden"><!></span>', 1),
  rA = ae("<div><button><!></button></div>"),
  iA = ae('<div class="relative px-3"><!> <div class="flex items-center gap-1.5"><button class="btn btn-circle btn-sm btn-soft"><!></button> <div class="flex grow items-center gap-1.5"><h2 class="text-xl select-none sm:min-w-38"> <!></h2> <div class="tooltip ml-1 sm:ml-2"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">I</kbd></div> <button><!></button></div> <div class="tooltip max-sm:hidden"><button title="Toggle art opacity"><!></button></div> <div class="tooltip ml-1 sm:ml-2"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">Ctrl+Z</kbd></div> <button title="Undo"><!></button></div> <div class="tooltip ml-1 sm:ml-2"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">Ctrl+Y</kbd></div> <button title="Redo"><!></button></div></div> <button class="btn btn-circle btn-sm"><!></button></div> <div class="mt-3 mb-4"><div></div></div> <div class="relative h-12 sm:h-14"><button class="btn btn-lg btn-square sm:btn-xl absolute bottom-0 left-0 shadow-md"><!></button> <div class="absolute bottom-0 left-1/2 -translate-x-1/2"><!></div> <div class="absolute right-0 bottom-0"><div class="tooltip ml-auto"><div class="tooltip-content not-touchscreen:-translate-x-[10%]"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">E</kbd></div> <button><!></button></div></div></div></div> <!>', 1);

function aA(y, l) {
  var Oi, Jr;
  Gr(l, !0);
  let _ = Ot(l, "screenLocked", 15),
    x = Ot(l, "opaquePixelArt", 15);
  const k = Je(() => new kn(l.tileSize));
  let z = Xe(1),
    T = Xe("pencil");
  const s = new Map,
    F = new Map;
  let Z = Xe(0),
    K = Xe(!1),
    G = Xe(!0),
    re = Je(() => bt.charges ?? 0),
    he = Je(() => h(re) - h(Z)),
    me = Xe(!1),
    q = !1,
    ye = Xe(!1);
  const be = Je(() => h(T) === "pencil"),
    qe = Je(() => h(T) === "eraser"),
    xe = Je(() => h(T) === "colorpicker");
  let Ye = Xe(!1),
    We = Xe(0),
    ze = Xe(void 0),
    Se = Xe(void 0);
  const Pe = [1, 2, 3, 32, 4, 5, 6, 33, 7, 34, 35, 8, 9, 10, 11, 37, 38, 39, 40, 41, 42, 12, 13, 14, 15, 16, 17, 43, 20, 44, 18, 19, 45, 46, 21, 22, 47, 48, 49, 23, 24, 25, 26, 27, 28, 53, 54, 55, 29, 30, 50, 56, 57, 36, 51, 31, 52, 61, 62, 63, 58, 59, 60, 0].map(It => ({
      ...xn.colors[It],
      idx: It,
      label: Cv[It]()
    })),
    Ae = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0].map(It => ({
      ...xn.colors[It],
      idx: It,
      label: Cv[It]()
    }));
  let Me = Xe(!1);
  const Ee = Je(() => h(Me) ? Pe : Ae),
    Qe = "show-all-colors";
  Oa(() => {
    j(Me, localStorage.getItem(Qe) === "true")
  }), Qr(() => {
    localStorage.setItem(Qe, h(Me) ? "true" : "false")
  });
  const Ue = "selected-color";
  Oa(() => {
    const It = Number(localStorage.getItem(Ue));
    !isNaN(It) && It < xn.colors.length && It > 0 && j(z, It, !0)
  }), Qr(() => {
    localStorage.setItem(Ue, h(z).toString())
  });
  const je = new PC({
    map: l.map,
    tileSize: l.tileSize,
    tileZoom: l.tileZoom,
    beforeLayerId: l.hoverLayerId
  });
  Qr(() => {
    const It = x() ? 1 : 0;
    je.setCanvasOpacity(It)
  }), Qr(() => {
    x() ? um() : ut([...s.values()])
  });
  let rt = !1;
  Oa(() => {
    so(l.map.getCenter(), l.map.getZoom());
    const It = l.map.on("click", ai => {
      var tr;
      l.zoom < l.tileZoom + 2 && ((tr = bt.data) == null ? void 0 : tr.role) === "user" && l.map.easeTo({
        center: ai.lngLat,
        zoom: 17
      });
      const Pt = [ai.lngLat.lat, ai.lngLat.lng];
      h(be) ? (dt([Pt], h(z)), jt.finishAction()) : h(qe) ? (at([Pt]), jt.finishAction()) : h(xe) && nt(Pt, ai.point), j(me, !0)
    });

    function er(ai, Pt) {
      const tr = h(k).latLonToPixels(ai.lat, ai.lng, l.tileZoom),
        Br = Pt ? h(k).latLonToPixels(Pt.lat, Pt.lng, l.tileZoom) : tr;
      return _b(tr, Br).map(ci => h(k).pixelsToLatLon(ci[0] + .5, ci[1] + .5, l.tileZoom))
    }

    function Pr(ai, Pt) {
      const tr = er(ai, Pt);
      h(be) ? dt(tr, h(z)) : h(qe) && at(tr), j(me, !0)
    }
    let pr;

    function qr(ai) {
      const Pt = l.map.unproject([ai.clientX, ai.clientY]);
      if (h(ye)) {
        const tr = er(Pt, pr);
        at(tr)
      }(rt || q) && Pr(Pt, pr), pr = Pt
    }
    window.addEventListener("mousemove", qr);
    let ur = !1;
    const Mr = l.map.on("touchstart", ai => {
        if (ai.points.length == 2) {
          _(!1), rr(), ur = !0, setTimeout(() => ur = !1, 150);
          return
        }
        _() && setTimeout(() => {
          !ur && Pr(ai.lngLat)
        }, 150), pr = ai.lngLat
      }),
      di = l.map.on("touchend", () => {
        jt.finishAction()
      }),
      ti = l.map.on("touchmove", ai => {
        _() && Pr(ai.lngLat, pr), pr = ai.lngLat
      }),
      Vr = ai => {
        ai.code === "Space" && (rt || pr && Pr(pr), rt = !0, ai.preventDefault())
      };
    document.addEventListener("keydown", Vr);
    const Rr = ai => {
      ai.code === "Space" && (rt = !1, _t = !1, jt.finishAction(), h(Z) === 0 && h(qe) && j(T, "pencil"))
    };
    document.addEventListener("keyup", Rr);

    function ni(ai) {
      if (ai.button === 2) {
        j(ye, !0);
        const tr = l.map.unproject([ai.clientX, ai.clientY]);
        at([
          [tr.lat, tr.lng]
        ])
      }
    }
    document.addEventListener("mousedown", ni);

    function Ri(ai) {
      ai.button === 2 && j(ye, !1)
    }
    document.addEventListener("mouseup", Ri);
    const qi = ai => {
      switch (ai.code) {
        case "KeyE":
          h(Z) > 0 && (h(qe) ? j(T, "pencil") : j(T, "eraser"));
          return;
        case "KeyI":
          j(T, "colorpicker");
          return
      }
    };
    return document.addEventListener("keypress", qi), () => {
      ti.unsubscribe(), Mr.unsubscribe(), di.unsubscribe(), It.unsubscribe(), document.removeEventListener("mousemove", qr), document.removeEventListener("keydown", Vr), document.removeEventListener("keyup", Rr), document.removeEventListener("keypress", qi), document.removeEventListener("mousedown", ni), document.removeEventListener("mouseup", Ri), st()
    }
  });
  let _t = !1;

  function dt(It, er, Pr = !0) {
    let pr = !1;
    const qr = er === 0;
    for (let ur of It) {
      const [Mr, di] = ur, ti = wp(er), {
        tile: Vr,
        pixel: Rr
      } = h(k).latLonToTileAndPixel(Mr, di, l.tileZoom), ni = {
        color: ti,
        tile: Vr,
        pixel: Rr,
        season: l.season,
        colorIdx: er
      }, Ri = $f(ni), qi = s.get(Ri), ai = h(re) - s.size;
      if (!qi && ai < 1) {
        if (_t && (rt || _())) continue;
        _t = !0, Bt.info(B2());
        continue
      }
      if (!(qi && qi.colorIdx === er) && (aa.plop.play(), pr || l.hidePixelHover(), s.set(Ri, ni), je.place(ur, er), l.crosshair.place(ur), pr = !0, qr && F.set(Ri, ni), Pr)) {
        const Pt = {
            type: "paint",
            latLons: [ur],
            colorIdx: er
          },
          tr = qi ? {
            type: "paint",
            latLons: [ur],
            colorIdx: qi.colorIdx
          } : {
            type: "erase",
            latLons: [ur]
          };
        jt.saveAction(Pt, tr)
      }
    }
    j(Z, s.size, !0), pr && !x() ? ut([...s.values()]) : pr && x() && qr && ut([...F.values()])
  }

  function at(It, er = !0) {
    let Pr = !1,
      pr = !1;
    for (let qr of It) {
      const [ur, Mr] = qr, {
        tile: di,
        pixel: ti
      } = h(k).latLonToTileAndPixel(ur, Mr, l.tileZoom), Vr = $f({
        tile: di,
        pixel: ti,
        season: l.season
      }), Rr = s.get(Vr);
      Rr && (aa.plop.play(), l.hidePixelHover(), s.delete(Vr), F.delete(Vr), je.remove([ur, Mr]), l.crosshair.remove(qr), Pr = !0, Rr.colorIdx === 0 && (pr = !0), er && jt.saveAction({
        type: "erase",
        latLons: [qr]
      }, {
        type: "paint",
        latLons: [qr],
        colorIdx: Rr.colorIdx
      })), s.size === 0 && !(rt || q || _()) && j(T, "pencil")
    }
    j(Z, s.size, !0), Pr && !x() ? ut([...s.values()]) : Pr && x() && pr && ut([...F.values()])
  }

  function nt(It, er) {
    const {
      tile: Pr,
      pixel: pr
    } = h(k).latLonToTileAndPixel(It[0], It[1], l.tileZoom), qr = $f({
      tile: Pr,
      pixel: pr,
      season: l.season
    }), ur = s.get(qr);
    if (ur) {
      Zt(ur.colorIdx), requestAnimationFrame(() => {
        var Vr;
        (Vr = document.getElementById(`color-${ur.colorIdx}`)) == null || Vr.focus()
      });
      return
    }
    const Mr = window.devicePixelRatio,
      di = Math.floor(er.x * Mr),
      ti = Math.floor(er.y * Mr);
    l.hidePixelHover(), KP(l.map, di, ti).then(([Vr, Rr, ni]) => {
      const Ri = g0({
        r: Vr,
        g: Rr,
        b: ni
      });
      Zt(Ri), requestAnimationFrame(() => {
        var qi;
        (qi = document.getElementById(`color-${Ri}`)) == null || qi.focus()
      })
    })
  }
  fo(() => h(z), () => {
    l.clickedLatLon && !h(me) && (h(z) === void 0 && j(z, 1), dt([l.clickedLatLon], h(z)))
  }), Qr(() => {
    const It = h(G) ? .8 : 0;
    l.crosshair.setCanvasOpacity(It)
  });
  let ot = Xe(16.5);
  Qr(() => {
    if (h(ze) && h(Se) && l.clickedLatLon) {
      const It = l.map.getZoom();
      if (It < h(ot)) {
        const [er, Pr] = l.clickedLatLon, pr = h(k).latLonToPixelBoundsLatLon(er, Pr, l.tileZoom), qr = dg(pr), ur = h(ze) - h(Se).clientHeight, Mr = h(ze) / 2 - ur / 2;
        l.map.flyTo({
          center: {
            lat: qr[0],
            lng: qr[1]
          },
          zoom: 17.5,
          offset: It > 11 ? [0, -Mr] : [0, 0]
        })
      }
      j(ot, l.tileZoom, !0)
    }
  }), Oa(() => {
    const It = () => {
      !document.hidden && (x() ? ut([...F.values()]) : ut([...s.values()]))
    };
    return document.addEventListener("visibilitychange", It), () => document.removeEventListener("visibilitychange", It)
  }), Qr(() => {
    switch (h(T)) {
      case "pencil":
        l.map.getCanvas().style.cursor = `url('${TC}') 8 8, default`, l.map.setPaintProperty(l.hoverLayerId, "raster-opacity", .4);
        return;
      case "colorpicker":
        l.map.getCanvas().style.cursor = `url('${bC}') 0 16, default`, l.map.setPaintProperty(l.hoverLayerId, "raster-opacity", 0);
        return;
      case "eraser":
        l.map.getCanvas().style.cursor = `url('${wC}') 2 14, default`, l.map.setPaintProperty(l.hoverLayerId, "raster-opacity", .4);
        return
    }
  }), Qr(() => {
    _() ? Ct() : rr()
  });
  async function ut(It) {
    await db(It), l.refreshPixelArt()
  }
  async function st() {
    await um(), je.clear(), l.refreshPixelArt(), l.crosshair.clear()
  }
  async function wt() {
    await st(), rr(), l.map.getCanvas().style.cursor = "default", l.map.setPaintProperty(l.hoverLayerId, "raster-opacity", .4), jt.clear(), l.onclose()
  }

  function Ct() {
    l.map.dragPan.disable(), l.map.touchZoomRotate.disable(), document.documentElement.style.overscrollBehavior = "none"
  }

  function rr() {
    l.map.dragPan.enable(), l.map.touchZoomRotate.enable(), document.documentElement.style.overscrollBehavior = ""
  }

  function Zt(It) {
    return It >= 32 && j(Me, !0), bt.hasColor(It) ? (aa.smallDropplet.play(), j(z, It, !0), j(T, "pencil"), !0) : (aa.smallDropplet.play(), j(Ye, !0), j(We, It, !0), !1)
  }
  tb(It => {
    It.type === "leave" && h(Z) > 0 && It.cancel()
  });
  const lt = "show-paint-more-than-one-pixel-msg";
  let ht = Xe(!1);
  Oa(() => {
    var It;
    j(ht, !localStorage.getItem(lt) && (((It = bt.data) == null ? void 0 : It.pixelsPainted) ?? 0) < 100, !0)
  }), Qr(() => {
    h(Z) > 1 && (j(ht, !1), localStorage.setItem(lt, "false"))
  });
  const Dt = "lp";
  Oa(() => {
    var er;
    const It = localStorage.getItem(Dt);
    if (It) try {
      const Pr = JSON.parse(atob(It)),
        pr = (Pr == null ? void 0 : Pr.time) ?? 0,
        qr = 60 * 1e3;
      (Pr == null ? void 0 : Pr.userId) !== ((er = bt.data) == null ? void 0 : er.id) && Date.now() - pr < 30 * qr && !V3 && (Bt.error(O2()), wt())
    } catch (Pr) {
      console.error(Pr)
    }
  });

  function Vt() {
    var er;
    const It = btoa(JSON.stringify({
      userId: (er = bt.data) == null ? void 0 : er.id,
      time: Date.now()
    }));
    localStorage.setItem(Dt, It)
  }
  class Jt {
    constructor() {
      bi(this, "history", []);
      bi(this, "actionInProgress", !1);
      bi(this, "historyIdx", -1);
      Ii(this, Oi, Xe(!1));
      Ii(this, Jr, Xe(!1))
    }
    get canUndo() {
      return h(ar(this, Oi))
    }
    set canUndo(er) {
      j(ar(this, Oi), er, !0)
    }
    get canRedo() {
      return h(ar(this, Jr))
    }
    set canRedo(er) {
      j(ar(this, Jr), er, !0)
    }
    undo() {
      if (this.historyIdx < 0) return;
      const er = this.history[this.historyIdx];
      if (er) {
        const Pr = this.mergeActions(er.undo);
        for (const pr of Pr) this.applyAction(pr)
      }
      this.historyIdx--, this.refreshCanUndoRedo()
    }
    redo() {
      if (this.historyIdx >= this.history.length - 1) return;
      this.historyIdx++;
      const er = this.history[this.historyIdx];
      if (er) {
        const Pr = this.mergeActions(er.redo);
        for (const pr of Pr) this.applyAction(pr)
      }
      this.refreshCanUndoRedo()
    }
    saveAction(er, Pr) {
      this.actionInProgress || (this.historyIdx < this.history.length - 1 && (this.history = this.history.slice(0, this.historyIdx + 1)), this.actionInProgress = !0, this.historyIdx++, this.history.push({
        redo: [],
        undo: []
      }));
      const pr = this.history[this.historyIdx];
      pr && (pr.redo.push(er), pr.undo.push(Pr))
    }
    finishAction() {
      this.actionInProgress = !1, this.refreshCanUndoRedo()
    }
    clear() {
      this.history = [], this.actionInProgress = !1, this.historyIdx = -1, this.refreshCanUndoRedo()
    }
    mergeActions(er) {
      const Pr = {
          type: "erase",
          latLons: []
        },
        pr = new Map;
      for (const ur of er)
        if (ur.type === "erase") Pr.latLons.push(...ur.latLons);
        else {
          const Mr = pr.get(ur.colorIdx);
          Mr ? Mr.latLons.push(...ur.latLons) : pr.set(ur.colorIdx, {
            type: "paint",
            colorIdx: ur.colorIdx,
            latLons: [...ur.latLons]
          })
        } const qr = [];
      if (Pr.latLons.length > 0 && qr.push(Pr), pr.size > 0)
        for (const ur of pr.values()) qr.push(ur);
      return qr
    }
    applyAction(er) {
      switch (er.type) {
        case "paint":
          dt(er.latLons, er.colorIdx, !1);
          break;
        case "erase":
          at(er.latLons, !1);
          break
      }
    }
    refreshCanUndoRedo() {
      this.canUndo = this.historyIdx >= 0, this.canRedo = this.historyIdx < this.history.length - 1
    }
  }
  Oi = new WeakMap, Jr = new WeakMap;
  const jt = new Jt;
  var nr = iA();
  Ci("keypress", qo, It => {
    switch (It.code) {
      case "KeyZ":
        (It.ctrlKey || It.metaKey) && (It.shiftKey ? jt.redo() : jt.undo());
        break;
      case "KeyY":
        (It.ctrlKey || It.metaKey) && jt.redo()
    }
  });
  var St = zt(nr),
    Et = P(St);
  {
    var Ut = It => {
        Mc(It, {
          children: (er, Pr) => {
            var pr = KC(),
              qr = zt(pr);
            Ey(qr, {
              class: "inline size-5"
            });
            var ur = E(qr);
            ke(Mr => ee(ur, ` ${Mr??""}`), [() => U2()]), B(er, pr)
          },
          $$slots: {
            default: !0
          }
        })
      },
      Gt = It => {
        var er = br(),
          Pr = zt(er);
        {
          var pr = ur => {
              Mc(ur, {
                class: "not-touchscreen:hidden",
                children: (Mr, di) => {
                  var ti = JC(),
                    Vr = zt(ti);
                  hm(Vr, {
                    class: "inline size-5"
                  });
                  var Rr = E(Vr);
                  ke(ni => ee(Rr, ` ${ni??""}`), [() => Z2()]), B(Mr, ti)
                },
                $$slots: {
                  default: !0
                }
              })
            },
            qr = ur => {
              var Mr = br(),
                di = zt(Mr);
              {
                var ti = Rr => {
                    Mc(Rr, {
                      class: "not-touchscreen:hidden",
                      children: (ni, Ri) => {
                        var qi = $C(),
                          ai = zt(qi);
                        n0(ai, {
                          class: "inline size-5"
                        });
                        var Pt = E(ai, 1, !0);
                        ke(tr => ee(Pt, tr), [() => G2()]), B(ni, qi)
                      },
                      $$slots: {
                        default: !0
                      }
                    })
                  },
                  Vr = Rr => {
                    var ni = br(),
                      Ri = zt(ni);
                    {
                      var qi = Pt => {
                          Mc(Pt, {
                            class: "touchscreen:hidden",
                            children: (tr, Br) => {
                              var Zr = QC(),
                                ci = zt(Zr);
                              Dy(ci, {
                                class: "inline size-5"
                              });
                              var ui = E(ci),
                                pt = P(ui, !0);
                              S(ui);
                              var kt = E(ui, 2),
                                dr = P(kt),
                                pi = E(dr),
                                vi = P(pi, !0);
                              S(pi), S(kt);
                              var Ji = E(kt);
                              ke((Zi, Ei, ca, Ir) => {
                                ee(pt, Zi), ee(dr, `${Ei??""} `), ee(vi, ca), ee(Ji, ` ${Ir??""}`)
                              }, [() => W2(), () => H2(), () => X2(), () => Y2()]), B(tr, Zr)
                            },
                            $$slots: {
                              default: !0
                            }
                          })
                        },
                        ai = Pt => {
                          var tr = br(),
                            Br = zt(tr);
                          {
                            var Zr = ci => {
                              Mc(ci, {
                                class: "bg-warning text-warning-content animate-bounce",
                                children: (ui, pt) => {
                                  var kt = eA(),
                                    dr = zt(kt);
                                  Vo(dr, {
                                    class: "inline size-5"
                                  });
                                  var pi = E(dr);
                                  ke(vi => ee(pi, ` ${vi??""}`), [() => K2()]), B(ui, kt)
                                },
                                $$slots: {
                                  default: !0
                                }
                              })
                            };
                            Te(Br, ci => {
                              h(ht) && ci(Zr)
                            }, !0)
                          }
                          B(Pt, tr)
                        };
                      Te(Ri, Pt => {
                        h(be) && h(Z) === 0 ? Pt(qi) : Pt(ai, !1)
                      }, !0)
                    }
                    B(Rr, ni)
                  };
                Te(di, Rr => {
                  h(xe) ? Rr(ti) : Rr(Vr, !1)
                }, !0)
              }
              B(ur, Mr)
            };
          Te(Pr, ur => {
            h(qe) ? ur(pr) : ur(qr, !1)
          }, !0)
        }
        B(It, er)
      };
    Te(Et, It => {
      h(qe) && h(Z) === 0 ? It(Ut) : It(Gt, !1)
    })
  }
  var Rt = E(Et, 2),
    ir = P(Rt);
  ir.__click = () => j(G, !h(G));
  var kr = P(ir);
  {
    var _r = It => {
        CC(It, {
          class: "size-4"
        })
      },
      fr = It => {
        kC(It, {
          class: "size-4"
        })
      };
    Te(kr, It => {
      h(G) ? It(_r) : It(fr, !1)
    })
  }
  S(ir);
  var Yt = E(ir, 2),
    sr = P(Yt),
    Kt = P(sr),
    vr = E(Kt);
  ky(vr, {
    class: "inline",
    fontSize: 14,
    get value() {
      return `(${h(Z)??""})`
    },
    mono: !0
  }), S(sr);
  var Lr = E(sr, 2),
    ii = P(Lr),
    mr = P(ii);
  wi(), S(ii);
  var ge = E(ii, 2);
  ge.__click = () => {
    j(T, "colorpicker")
  };
  var V = P(ge);
  n0(V, {
    class: "size-4.5"
  }), S(ge), S(Lr);
  var U = E(Lr, 2),
    J = P(U);
  let se;
  J.__click = () => {
    x(!x())
  };
  var te = P(J);
  {
    let It = Je(() => !x());
    Ly(te, {
      class: "size-4.5",
      get filled() {
        return h(It)
      }
    })
  }
  S(J), S(U);
  var _e = E(U, 2),
    Re = P(_e),
    ne = P(Re);
  wi(), S(Re);
  var oe = E(Re, 2);
  let fe;
  oe.__click = () => {
    jt.undo()
  };
  var ve = P(oe);
  YC(ve, {
    class: "size-4.5"
  }), S(oe), S(_e);
  var ie = E(_e, 2),
    Y = P(ie),
    Fe = P(Y);
  wi(), S(Y);
  var Ne = E(Y, 2);
  let Ge;
  Ne.__click = () => {
    jt.redo()
  };
  var pe = P(Ne);
  WC(pe, {
    class: "size-4.5"
  }), S(Ne), S(ie), S(Yt);
  var Ve = E(Yt, 2);
  Ve.__click = () => {
    aa.smallPlop.play(), wt()
  };
  var it = P(Ve);
  ss(it, {
    class: "size-4"
  }), S(Ve), S(Rt);
  var yt = E(Rt, 2),
    Lt = P(yt);
  Hi(Lt, 23, () => h(Ee), It => It.idx, (It, er, Pr) => {
    const pr = Je(() => {
        const [ni, Ri, qi] = h(er).rgb;
        return {
          r: ni,
          g: Ri,
          b: qi
        }
      }),
      qr = Je(() => h(z) === h(er).idx && h(be)),
      ur = Je(() => h(er).idx === 0),
      Mr = Je(() => bt.hasColor(h(er).idx));
    var di = rA(),
      ti = P(di);
    ti.__click = () => {
      Zt(h(er).idx)
    };
    var Vr = P(ti);
    {
      var Rr = ni => {
        var Ri = tA(),
          qi = zt(Ri);
        rh(qi, {
          class: "center-absolute absolute size-4 opacity-30 sm:hidden sm:size-6"
        });
        var ai = E(qi, 2),
          Pt = P(ai);
        rh(Pt, {
          class: "text-base-content/80 size-4"
        }), S(ai), B(ni, Ri)
      };
      Te(Vr, ni => {
        h(Mr) || ni(Rr)
      })
    }
    S(ti), S(di), ke(() => {
      Er(di, 1, _l({
        tooltip: !0,
        "max-sm:h-6": h(Me),
        "max-sm:before:translate-x-1/4": h(Pr) % 8 === 0 && h(er).label.length > 7,
        "max-sm:before:-translate-x-1/4": (h(Pr) - 7) % 8 === 0 && h(er).label.length > 7,
        "max-xl:before:translate-x-1/4": h(Pr) % 16 === 0 && h(er).label.length > 7,
        "max-xl:before:-translate-x-1/4": (h(Pr) - 15) % 16 === 0 && h(er).label.length > 7,
        "xl:before:translate-x-1/4": h(Me) && h(Pr) % 32 === 0 && h(er).label.length > 7,
        "xl:before:-translate-x-1/4": h(Me) && (h(Pr) - 31) % 32 === 0 && h(er).label.length > 7
      })), Xt(di, "data-tip", h(er).label), Er(ti, 1, _l({
        "btn relative aspect-square w-full rounded-xl": !0,
        "border-primary ring-primary ring-2": h(qr),
        "border-base-300": !h(qr) && h(ur),
        "border-base-content/20": !h(qr) && !h(ur),
        "max-sm:h-6 max-sm:rounded-md": h(Me)
      })), Qn(ti, h(ur) ? `background-image: url(${SC}); background-size: cover; image-rendering: pixelated;` : `background: rgb(${h(pr).r} ${h(pr).g} ${h(pr).b})`), Xt(ti, "aria-label", h(er).label), Xt(ti, "id", `color-${h(er).idx??""}`)
    }), Ci("focus", ti, () => {
      h(Mr) && (j(z, h(er).idx, !0), j(T, "pencil"))
    }), B(It, di)
  }), S(Lt), S(yt);
  var ct = E(yt, 2),
    At = P(ct);
  At.__click = () => {
    j(Me, !h(Me))
  };
  var qt = P(At);
  {
    var Ke = It => {
        fb(It, {
          class: "size-5"
        })
      },
      Tt = It => {
        mb(It, {
          class: "size-5"
        })
      };
    Te(qt, It => {
      h(Me) ? It(Ke) : It(Tt, !1)
    })
  }
  S(At);
  var Wt = E(At, 2),
    Fr = P(Wt);
  {
    let It = Je(() => h(Z) > 100 ? "animate-pulse" : ""),
      er = Je(() => h(Z) === 0 || h(K) || h(he) < 0);
    zy(Fr, {
      get class() {
        return h(It)
      },
      get charges() {
        return h(he)
      },
      get disabled() {
        return h(er)
      },
      get loading() {
        return h(K)
      },
      onclick: async () => {
        aa.droppletAndPlop.play();
        const Pr = [...s.values()];
        j(K, !0);
        try {
          const pr = await gg();
          await Kr.paint(Pr, pr), await Km(Pr), Vt(), bt.refresh(), fp.shouldReload = !0, await wt()
        } catch (pr) {
          Bt.error(`${pr.message}`, {
            duration: 7e3
          })
        } finally {
          j(K, !1)
        }
      }
    })
  }
  S(Wt);
  var or = E(Wt, 2),
    tt = P(or),
    Ht = P(tt),
    Qt = P(Ht);
  wi(), S(Ht);
  var Sr = E(Ht, 2);
  let ei;
  Sr.__click = () => {
    j(T, h(T) === "eraser" ? "pencil" : "eraser", !0)
  };
  var li = P(Sr);
  hm(li, {
    class: "size-5",
    get filled() {
      return h(qe)
    }
  }), S(Sr), S(tt), S(or), S(ct), S(St), Rn(St, It => j(Se, It), () => h(Se));
  var Dr = E(St, 2);
  jC(Dr, {
    get colorIdx() {
      return h(We)
    },
    get open() {
      return h(Ye)
    },
    set open(It) {
      j(Ye, It, !0)
    }
  }), ke((It, er, Pr, pr, qr, ur) => {
    ee(Kt, `${It??""} `), ee(mr, `${er??""} `), Er(ge, 1, _l({
      "btn btn-circle btn-sm": !0,
      "btn-ghost": !h(xe),
      "btn-primary": h(xe)
    })), Xt(U, "data-tip", Pr), se = Er(J, 1, "btn btn-sm btn-circle btn-ghost text-base-content/80", null, se, {
      "text-primary": !x()
    }), ee(ne, `${pr??""} `), fe = Er(oe, 1, "btn btn-sm btn-circle btn-ghost text-base-content/80", null, fe, {
      "opacity-50": !jt.canUndo
    }), oe.disabled = !jt.canUndo, ee(Fe, `${qr??""} `), Ge = Er(Ne, 1, "btn btn-sm btn-circle btn-ghost text-base-content/80", null, Ge, {
      "opacity-50": !jt.canRedo
    }), Ne.disabled = !jt.canRedo, Er(Lt, 1, _l({
      "grid grid-cols-8 md:grid-cols-16 min-[100rem]:grid-cols-32": !0,
      "gap-0.5 sm:grid-cols-16 sm:gap-1 xl:grid-cols-32": h(Me),
      "gap-1": !h(Me)
    })), ee(Qt, `${ur??""} `), ei = Er(Sr, 1, "btn btn-lg btn-square sm:btn-xl shadow-md", null, ei, {
      "btn-primary": h(qe)
    }), Sr.disabled = h(Z) === 0
  }, [() => j2(), () => q2(), () => P0(), () => N2(), () => V2(), () => M3()]), Eh("innerHeight", It => j(ze, It, !0)), B(y, nr), Wr()
}
Ui(["click"]);
var nA = ae('<dialog class="modal"><div class="modal-box max-h-11/12"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2"></button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form class="mt-3 w-full"><p class="whitespace-pre-wrap"><!></p> <div class="mt-4"><!></div> <div class="mt-2 flex justify-end gap-2"><button class="btn btn-soft tooltip" type="button"> </button> <button class="btn btn-primary" type="submit"> </button></div></form></div></dialog>');

function sA(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "open", 15),
    x = Xe(!1),
    k = Xe("");
  var z = nA(),
    T = P(z),
    s = E(P(T), 2),
    F = P(s, !0);
  S(s);
  var Z = E(s, 2),
    K = P(Z),
    G = P(K);
  Fp(G, () => J2()), S(K);
  var re = E(K, 2),
    he = P(re);
  {
    let xe = Je(() => rw()),
      Ye = Je(() => iw());
    _0(he, {
      get label() {
        return h(xe)
      },
      get placeholder() {
        return h(Ye)
      },
      min: 1,
      max: 2056,
      class: "h-32",
      get disabled() {
        return h(x)
      },
      get value() {
        return h(k)
      },
      set value(We) {
        j(k, We, !0)
      }
    })
  }
  S(re);
  var me = E(re, 2),
    q = P(me);
  q.__click = () => {
    _(!1)
  };
  var ye = P(q, !0);
  S(q);
  var be = E(q, 2),
    qe = P(be, !0);
  S(be), S(me), S(Z), S(T), S(z), qa(z, () => xe => {
    Qr(() => {
      _() ? xe.show() : xe.close()
    })
  }), ke((xe, Ye, We) => {
    ee(F, xe), q.disabled = h(x), ee(ye, Ye), be.disabled = h(x) || h(k).length <= 1, ee(qe, We)
  }, [() => l.userData.banned ? A3() : $2(), () => uo(), () => Q2()]), Ci("close", z, () => _(!1)), Ci("submit", Z, async () => {
    try {
      if (j(x, !0), await Kr.submitBanAppeal(h(k)) === 208) {
        Bt.error(ew());
        return
      }
      Bt.success(tw()), _(!1)
    } catch (xe) {
      Bt.error(xe.message, {
        duration: 5e3
      })
    } finally {
      j(x, !1)
    }
  }), B(y, z), Wr()
}
Ui(["click"]);
var oA = ae("<span> </span>");

function s0(y, l) {
  Gr(l, !0);
  var _ = oA(),
    x = P(_, !0);
  S(_), ke(() => {
    Er(_, 1, `size-4 items-center justify-center rounded-full bg-red-500 font-semibold text-red-50 ${l.count<10?"text-xs":"text-[10px]"} ${l.class??""}`), ee(x, l.count < 10 ? l.count : "9+")
  }), B(y, _), Wr()
}
var lA = ae('<p class="text-error mt-1 text-sm"> </p>'),
  cA = ae('<span class="loading loading-spinner center-absolute absolute"></span>'),
  uA = ae('<dialog class="modal bg-black/80!"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2"></button></form> <div class="flex items-center gap-2"><!> <h3 class="text-lg font-bold"> </h3></div> <p class="mt-4"><b> </b> </p> <p class="mt-2"> </p> <div class="rounded-box border-base-content/20 mt-6 w-full border py-1.5 text-center"> </div> <input class="input input-bordered mt-2 w-full" type="text"/> <!> <div class="mt-6 flex justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-error relative"> <!></button></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>');

function hA(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "open", 15),
    x = Xe(""),
    k = Xe(null),
    z = Xe(!1),
    T = Je(() => {
      var at;
      return ((at = bt.data) == null ? void 0 : at.name) ?? ""
    });
  Qr(() => {
    _() || (j(x, ""), j(k, null))
  });
  var s = uA(),
    F = P(s),
    Z = E(P(F), 2),
    K = P(Z);
  h3(K, {
    class: "text-error size-5"
  });
  var G = E(K, 2),
    re = P(G, !0);
  S(G), S(Z);
  var he = E(Z, 2),
    me = P(he),
    q = P(me, !0);
  S(me);
  var ye = E(me);
  S(he);
  var be = E(he, 2),
    qe = P(be);
  S(be);
  var xe = E(be, 2),
    Ye = P(xe, !0);
  S(xe);
  var We = E(xe, 2);
  Ka(We);
  var ze = E(We, 2);
  {
    var Se = at => {
      var nt = lA(),
        ot = P(nt, !0);
      S(nt), ke(() => ee(ot, h(k))), B(at, nt)
    };
    Te(ze, at => {
      h(k) && at(Se)
    })
  }
  var Pe = E(ze, 2),
    Ae = P(Pe);
  Ae.__click = () => {
    _(!1)
  };
  var Me = P(Ae, !0);
  S(Ae);
  var Ee = E(Ae, 2);
  Ee.__click = async () => {
    if (h(x) !== h(T)) {
      j(k, ib(), !0);
      return
    }
    try {
      j(z, !0), await Kr.deleteMe(h(T)), Bt.warning(aw()), await bt.logout(), _(!1)
    } catch (at) {
      Bt.error(at.message)
    } finally {
      j(z, !1)
    }
  };
  var Qe = P(Ee),
    Ue = E(Qe);
  {
    var je = at => {
      var nt = cA();
      B(at, nt)
    };
    Te(Ue, at => {
      h(z) && at(je)
    })
  }
  S(Ee), S(Pe), S(F);
  var rt = E(F, 2),
    _t = P(rt),
    dt = P(_t, !0);
  S(_t), S(rt), S(s), qa(s, () => at => {
    Qr(() => {
      _() ? at.show() : at.close()
    })
  }), ke((at, nt, ot, ut, st, wt, Ct, rr, Zt) => {
    ee(re, at), ee(q, nt), ee(ye, ` ${ot??""}`), ee(qe, `${ut??""} ${st??""}`), ee(Ye, h(T)), Xt(We, "placeholder", wt), ee(Me, Ct), Ee.disabled = h(z), ee(Qe, `${rr??""} `), ee(dt, Zt)
  }, [() => dm(), () => nw(), () => sw(), () => ow(), () => lw(), () => cw(), () => No(), () => dm(), () => uo()]), Ci("close", s, () => _(!1)), Tl(We, () => h(x), at => j(x, at)), B(y, s), Wr()
}
Ui(["click"]);
var dA = ae('<p class="text-base-content/80 text-sm"> </p>'),
  pA = ae('<span class="loading loading-spinner center-absolute absolute"></span>'),
  fA = ae('<h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <p class="mt-4"> </p> <!> <div class="mt-4 flex justify-end gap-2"><form method="dialog"><button class="btn btn-soft"> </button></form> <button> <!></button></div>', 1);

function mA(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "open", 15),
    x = Ot(l, "type", 3, "confirmation"),
    k = Ot(l, "buttonText", 19, () => O0()),
    z = Xe(!1);
  xg(y, {
    dialogClass: "!bg-black/80",
    get open() {
      return _()
    },
    set open(T) {
      _(T)
    },
    children: (T, s) => {
      var F = fA(),
        Z = zt(F),
        K = P(Z, !0);
      S(Z);
      var G = E(Z, 2),
        re = P(G, !0);
      S(G);
      var he = E(G, 2);
      {
        var me = Pe => {
          var Ae = dA(),
            Me = P(Ae, !0);
          S(Ae), ke(() => ee(Me, l.subDescription)), B(Pe, Ae)
        };
        Te(he, Pe => {
          l.subDescription && Pe(me)
        })
      }
      var q = E(he, 2),
        ye = P(q),
        be = P(ye),
        qe = P(be, !0);
      S(be), S(ye);
      var xe = E(ye, 2);
      let Ye;
      xe.__click = async () => {
        try {
          j(z, !0), _(await l.onConfirm())
        } finally {
          j(z, !1)
        }
      };
      var We = P(xe),
        ze = E(We);
      {
        var Se = Pe => {
          var Ae = pA();
          B(Pe, Ae)
        };
        Te(ze, Pe => {
          h(z) && Pe(Se)
        })
      }
      S(xe), S(q), ke(Pe => {
        ee(K, l.title), ee(re, l.description), ee(qe, Pe), Ye = Er(xe, 1, "btn relative", null, Ye, {
          "btn-error": x() === "warning",
          "btn-primary": x() === "confirmation"
        }), xe.disabled = h(z), ee(We, `${k()??""} `)
      }, [() => No()]), B(T, F)
    },
    $$slots: {
      default: !0
    }
  }), Wr()
}
Ui(["click"]);

function gA(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "open", 15);
  {
    let x = Je(() => L0()),
      k = Je(() => uw()),
      z = Je(() => hw());
    mA(y, {
      type: "warning",
      get title() {
        return h(x)
      },
      get description() {
        return h(k)
      },
      get subDescription() {
        return h(z)
      },
      onConfirm: async () => {
        try {
          return await Kr.deleteSessions(), Bt.success(f3()), await bt.logout(), !0
        } catch {
          return Bt.error(m3()), !1
        }
      },
      get open() {
        return _()
      },
      set open(T) {
        _(T)
      }
    })
  }
  Wr()
}
var _A = Yr('<svg><path d="M440-160v-487L216-423l-56-57 320-320 320 320-56 57-224-224v487h-80Z"></path></svg>');

function ho(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = _A();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var vA = ae('<div class="flex flex-col gap-2"><div class="flex items-center justify-between"><div class="text-base-content/70 text-xs font-semibold"> </div></div> <div class="grid grid-cols-[auto_1fr_auto] items-center gap-2"><button type="button" class="btn btn-circle btn-primary btn-xs" aria-label="Fonte anterior"><!></button> <div class="min-w-0 text-center"><div class="truncate text-lg font-bold"> </div> <div class="text-base-content/50 truncate text-[11px]"> </div></div> <button type="button" class="btn btn-circle btn-primary btn-xs" aria-label="Prxima fonte"><!></button></div> <div class="flex items-center justify-center gap-2"><button type="button" class="btn btn-circle btn-primary btn-xs" aria-label="Estilo anterior"><!></button> <span class="text-base-content/60 text-[11px]"> </span> <button type="button" class="btn btn-circle btn-primary btn-xs" aria-label="Prximo estilo"><!></button></div></div>');

function yA(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "selectedFontIndex", 15, 0),
    x = Ot(l, "selectedStyleIndex", 15, 0),
    k = Ot(l, "loading", 3, !1),
    z = Ot(l, "syncToEquipped", 3, !0),
    T = Xe(!1),
    s = Xe(!1);

  function F() {
    var ot;
    l.fonts.length !== 0 && (_((_() - 1 + l.fonts.length) % l.fonts.length), (ot = l.onselectFont) == null || ot.call(l, l.fonts[_()]))
  }

  function Z() {
    var ot;
    l.fonts.length !== 0 && (_((_() + 1) % l.fonts.length), (ot = l.onselectFont) == null || ot.call(l, l.fonts[_()]))
  }

  function K() {
    var ot;
    l.styles.length !== 0 && (x((x() - 1 + l.styles.length) % l.styles.length), (ot = l.onselectStyle) == null || ot.call(l, l.styles[x()]))
  }

  function G() {
    var ot;
    l.styles.length !== 0 && (x((x() + 1) % l.styles.length), (ot = l.onselectStyle) == null || ot.call(l, l.styles[x()]))
  }
  const re = Je(() => l.fonts[_()]),
    he = Je(() => l.styles[x()]);
  Qr(() => {
    l.fonts, j(T, !1)
  }), Qr(() => {
    l.styles, j(s, !1)
  }), Qr(() => {
    var ut, st;
    if (h(T) || !((ut = l.fonts) != null && ut.length) || l.equippedFontId == null) return;
    const ot = l.fonts.findIndex(wt => wt.id === l.equippedFontId);
    if (ot === -1) {
      j(T, !0);
      return
    }
    _(ot), j(T, !0), z() && ((st = l.onselectFont) == null || st.call(l, l.fonts[ot]))
  }), Qr(() => {
    var ut, st;
    if (h(s) || !((ut = l.styles) != null && ut.length) || l.equippedStyleId == null) return;
    const ot = l.styles.findIndex(wt => wt.id === l.equippedStyleId);
    if (ot === -1) {
      j(s, !0);
      return
    }
    x(ot), j(s, !0), z() && ((st = l.onselectStyle) == null || st.call(l, l.styles[ot]))
  });

  function me(ot) {
    return (ot == null ? void 0 : ot.text) ?? ""
  }
  var q = vA(),
    ye = P(q),
    be = P(ye),
    qe = P(be, !0);
  S(be), S(ye);
  var xe = E(ye, 2),
    Ye = P(xe);
  Ye.__click = F;
  var We = P(Ye);
  ho(We, {
    class: "size-4 -rotate-90"
  }), S(Ye);
  var ze = E(Ye, 2),
    Se = P(ze),
    Pe = P(Se, !0);
  S(Se);
  var Ae = E(Se, 2),
    Me = P(Ae, !0);
  S(Ae), S(ze);
  var Ee = E(ze, 2);
  Ee.__click = Z;
  var Qe = P(Ee);
  ho(Qe, {
    class: "size-4 rotate-90"
  }), S(Ee), S(xe);
  var Ue = E(xe, 2),
    je = P(Ue);
  je.__click = K;
  var rt = P(je);
  ho(rt, {
    class: "size-4 -rotate-90"
  }), S(je);
  var _t = E(je, 2),
    dt = P(_t, !0);
  S(_t);
  var at = E(_t, 2);
  at.__click = G;
  var nt = P(at);
  ho(nt, {
    class: "size-4 rotate-90"
  }), S(at), S(Ue), S(q), ke((ot, ut, st, wt) => {
    var Ct;
    ee(qe, ot), Ye.disabled = k() || l.fonts.length <= 1, Qn(Se, `${ut??""}; ${st??""}`), Xt(Se, "title", l.userName), ee(Pe, l.userName), ee(Me, (Ct = h(re)) == null ? void 0 : Ct.name), Ee.disabled = k() || l.fonts.length <= 1, je.disabled = k() || l.styles.length <= 1, ee(dt, wt), at.disabled = k() || l.styles.length <= 1
  }, [() => {
    var ot;
    return ((ot = I0) == null ? void 0 : ot()) ?? "Nome"
  }, () => me(h(re)), () => me(h(he)), () => {
    var ot, ut;
    return ((ot = h(he)) == null ? void 0 : ot.name) ?? ((ut = dw) == null ? void 0 : ut()) ?? "Sem estilos"
  }]), B(y, q), Wr()
}
Ui(["click"]);
var xA = ae('<div class="mt-1 flex w-full justify-center"><span class="badge badge-primary badge-sm"> </span></div>'),
  bA = ae('<div class="mt-1 flex w-full justify-center"><span class="badge badge-primary badge-sm"> </span></div>'),
  wA = ae('<button type="button"><div class="flex flex-1 flex-col items-center justify-center gap-1"><div class="relative flex size-16 items-center justify-center overflow-hidden rounded-full"><img class="pointer-events-none absolute inset-0 rounded-full object-cover"/></div></div> <div class="mt-1 flex w-full flex-col items-center text-center"><span class="line-clamp-1 w-full text-xs font-medium"> </span> <span class="text-base-content/70 mt-0.5 w-full text-[11px]"> </span></div> <!></button>'),
  TA = ae('<div><div class="flex gap-2"><div class="bg-base-200 aspect-square rounded-lg p-4"><div class="relative"><!></div></div> <div class="bg-base-200 flex flex-col items-center justify-center gap-4 rounded-lg p-2"><div class="relative"><!></div> <div class="relative"><!></div></div></div> <div class="mt-4"><div class="relative"><!></div></div></div>'),
  SA = ae('<span class="loading loading-spinner"></span>'),
  PA = ae('<dialog class="modal"><div class="modal-box max-h-11/12 max-w-2xl"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute top-2 right-2"></button></form> <h3 class="text-lg font-bold"> </h3> <p class="text-base-content/80 mb-3 text-sm"> </p> <div class="grid grow grid-cols-1 gap-4 sm:grid-cols-[1fr_auto]"><section class="min-h-0 overflow-y-auto pr-1"><h4 class="text-base-content/80 mb-2 text-sm font-semibold"> </h4> <div class="grid grid-cols-2 gap-3 sm:grid-cols-3"><button type="button"><div class="flex flex-1 flex-col items-center justify-center gap-1"><div class="text-base-content/60 border-base-content/60 flex size-16 items-center justify-center rounded-full border text-xs font-semibold"> </div></div> <div class="mt-1 flex w-full flex-col items-center text-center"><span class="line-clamp-1 w-full text-xs font-medium"> </span> <span class="text-base-content/70 mt-0.5 w-full text-[11px]"> </span></div> <!></button> <!></div></section> <section class="flex flex-col justify-between"><div><h4 class="text-base-content/80 mb-2 text-sm font-semibold"> </h4> <!></div> <div class="border-base-300 bg-base-100 sticky bottom-0 p-3 pb-[calc(env(safe-area-inset-bottom)+12px)]"><div class="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-end"><button type="button" class="btn"> </button> <button type="button" class="btn btn-primary"><!></button></div></div></section></div></div></dialog>');

function IA(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "open", 15),
    x = Xe(Wi([])),
    k = Xe(Wi([]));
  const z = Wi(bt.data);
  let T = Xe(Wi([])),
    s = Xe(Wi([])),
    F = Xe(0),
    Z = Xe(0),
    K = Xe(!1),
    G = Xe(null),
    re = Xe(null),
    he = Xe(null);
  Qr(() => {
    var Yt, sr;
    z && (z.equippedFrameId !== void 0 && h(G) === null && j(G, z.equippedFrameId || 0, !0), h(re) === null && j(re, ((Yt = z.equippedNameCosmetic) == null ? void 0 : Yt.fontId) ?? 10, !0), h(he) === null && j(he, ((sr = z.equippedNameCosmetic) == null ? void 0 : sr.styleId) ?? 20, !0))
  });

  function me(Yt) {
    h(K) || j(G, Yt, !0)
  }

  function q(Yt) {
    if (!(Yt === null || Yt === 0)) return h(x).find(sr => sr.id === Yt) ?? h(k).find(sr => sr.id === Yt)
  }
  async function ye() {
    try {
      j(x, await Kr.getUserFrames(), !0)
    } catch {
      Bt.error(j0())
    }
    try {
      j(k, await Kr.getStoreFrames(), !0)
    } catch {
      j(k, [], !0)
    }
    try {
      const Yt = await Kr.getMyNameCosmetics();
      j(T, Yt.fonts.map(sr => {
        var Kt;
        return {
          id: sr.id,
          name: sr.name,
          text: (Kt = sr.config) == null ? void 0 : Kt.text,
          price: sr.price,
          owned: !0
        }
      }), !0), j(s, Yt.styles.map(sr => {
        var Kt;
        return {
          id: sr.id,
          name: sr.name,
          price: sr.price,
          owned: !0,
          text: ((Kt = sr.config) == null ? void 0 : Kt.text) ?? ""
        }
      }), !0)
    } catch {
      j(T, [], !0), j(s, [], !0)
    }
  }
  async function be() {
    if (!h(K) && !(h(G) === null || h(re) === null || h(he) === null)) {
      j(K, !0);
      try {
        await Kr.postEquipCosmetics({
          frameId: h(G),
          fontId: h(re),
          styleId: h(he)
        }), await bt.refresh(), Bt.success(Ju())
      } catch (Yt) {
        Bt.error(Yt.message)
      } finally {
        j(K, !1)
      }
    }
  }
  let qe = Xe(!1),
    xe = Xe(!1);
  async function Ye() {
    if (!h(qe)) {
      j(qe, !0);
      try {
        await ye(), j(xe, !0)
      } finally {
        j(qe, !1)
      }
    }
  }
  Qr(() => {
    var Yt, sr;
    _() && (j(G, z.equippedFrameId || 0, !0), j(re, ((Yt = z.equippedNameCosmetic) == null ? void 0 : Yt.fontId) ?? 1e3, !0), j(he, ((sr = z.equippedNameCosmetic) == null ? void 0 : sr.styleId) ?? 1001, !0), h(xe) || Ye())
  });
  var We = PA(),
    ze = P(We),
    Se = P(ze),
    Pe = P(Se);
  Pe.__click = () => _(!1), S(Se);
  var Ae = E(Se, 2),
    Me = P(Ae, !0);
  S(Ae);
  var Ee = E(Ae, 2),
    Qe = P(Ee, !0);
  S(Ee);
  var Ue = E(Ee, 2),
    je = P(Ue),
    rt = P(je),
    _t = P(rt, !0);
  S(rt);
  var dt = E(rt, 2),
    at = P(dt);
  at.__click = () => me(0);
  var nt = P(at),
    ot = P(nt),
    ut = P(ot, !0);
  S(ot), S(nt);
  var st = E(nt, 2),
    wt = P(st),
    Ct = P(wt, !0);
  S(wt);
  var rr = E(wt, 2),
    Zt = P(rr, !0);
  S(rr), S(st);
  var lt = E(st, 2);
  {
    var ht = Yt => {
      var sr = xA(),
        Kt = P(sr),
        vr = P(Kt, !0);
      S(Kt), S(sr), ke(Lr => ee(vr, Lr), [() => Tp()]), B(Yt, sr)
    };
    Te(lt, Yt => {
      h(G) === 0 && Yt(ht)
    })
  }
  S(at);
  var Dt = E(at, 2);
  Hi(Dt, 17, () => h(x), Yt => Yt.id, (Yt, sr) => {
    var Kt = wA();
    Kt.__click = () => me(h(sr).id);
    var vr = P(Kt),
      Lr = P(vr),
      ii = P(Lr);
    S(Lr), S(vr);
    var mr = E(vr, 2),
      ge = P(mr),
      V = P(ge, !0);
    S(ge);
    var U = E(ge, 2),
      J = P(U, !0);
    S(U), S(mr);
    var se = E(mr, 2);
    {
      var te = _e => {
        var Re = bA(),
          ne = P(Re),
          oe = P(ne, !0);
        S(ne), S(Re), ke(fe => ee(oe, fe), [() => Tp()]), B(_e, Re)
      };
      Te(se, _e => {
        h(G) === h(sr).id && _e(te)
      })
    }
    S(Kt), ke(() => {
      Er(Kt, 1, `bg-base-200/80 hover:bg-base-300 group flex h-40 flex-col items-center justify-between rounded-lg p-3 text-xs transition disabled:opacity-50 ${h(G)===h(sr).id?" border-primary bg-primary/10":""}`), Kt.disabled = h(K), Xt(ii, "src", h(sr).imageUrl), Xt(ii, "alt", h(sr).name), ee(V, h(sr).name), ee(J, h(sr).description)
    }), B(Yt, Kt)
  }), S(dt), S(je);
  var Vt = E(je, 2),
    Jt = P(Vt),
    jt = P(Jt),
    nr = P(jt, !0);
  S(jt);
  var St = E(jt, 2);
  bl(St, () => h(G), Yt => {
    const sr = Je(() => q(h(G)));
    var Kt = TA(),
      vr = P(Kt),
      Lr = P(vr),
      ii = P(Lr),
      mr = P(ii);
    {
      let ne = Je(() => {
        var oe;
        return (oe = h(sr)) == null ? void 0 : oe.imageUrl
      });
      bn(mr, {
        class: "size-20",
        get userId() {
          return z.id
        },
        get pictureUrl() {
          return z.picture
        },
        get borderUrl() {
          return h(ne)
        }
      })
    }
    S(ii), S(Lr);
    var ge = E(Lr, 2),
      V = P(ge),
      U = P(V);
    {
      let ne = Je(() => {
        var oe;
        return (oe = h(sr)) == null ? void 0 : oe.imageUrl
      });
      bn(U, {
        class: "size-10",
        get userId() {
          return z.id
        },
        get pictureUrl() {
          return z.picture
        },
        get borderUrl() {
          return h(ne)
        }
      })
    }
    S(V);
    var J = E(V, 2),
      se = P(J);
    {
      let ne = Je(() => {
        var oe;
        return (oe = h(sr)) == null ? void 0 : oe.imageUrl
      });
      bn(se, {
        class: "size-5",
        get userId() {
          return z.id
        },
        get pictureUrl() {
          return z.picture
        },
        get borderUrl() {
          return h(ne)
        }
      })
    }
    S(J), S(ge), S(vr);
    var te = E(vr, 2),
      _e = P(te),
      Re = P(_e);
    {
      let ne = Je(() => {
          var ve;
          return ((ve = z.equippedNameCosmetic) == null ? void 0 : ve.fontId) ?? 0
        }),
        oe = Je(() => {
          var ve;
          return ((ve = z.equippedNameCosmetic) == null ? void 0 : ve.styleId) ?? 0
        }),
        fe = Je(() => z.name ?? "User");
      yA(Re, {
        get fonts() {
          return h(T)
        },
        get styles() {
          return h(s)
        },
        get equippedFontId() {
          return h(ne)
        },
        get equippedStyleId() {
          return h(oe)
        },
        get userName() {
          return h(fe)
        },
        get loading() {
          return h(K)
        },
        onselectFont: ve => j(re, ve.id, !0),
        onselectStyle: ve => j(he, ve.id, !0),
        get selectedFontIndex() {
          return h(F)
        },
        set selectedFontIndex(ve) {
          j(F, ve, !0)
        },
        get selectedStyleIndex() {
          return h(Z)
        },
        set selectedStyleIndex(ve) {
          j(Z, ve, !0)
        }
      })
    }
    S(_e), S(te), S(Kt), B(Yt, Kt)
  }), S(Jt);
  var Et = E(Jt, 2),
    Ut = P(Et),
    Gt = P(Ut);
  Gt.__click = () => _(!1);
  var Rt = P(Gt, !0);
  S(Gt);
  var ir = E(Gt, 2);
  ir.__click = be;
  var kr = P(ir);
  {
    var _r = Yt => {
        var sr = SA();
        B(Yt, sr)
      },
      fr = Yt => {
        var sr = ja();
        ke(Kt => ee(sr, Kt), [() => Ju()]), B(Yt, sr)
      };
    Te(kr, Yt => {
      h(K) ? Yt(_r) : Yt(fr, !1)
    })
  }
  S(ir), S(Ut), S(Et), S(Vt), S(Ue), S(ze), S(We), qa(We, () => Yt => {
    Qr(() => {
      _() ? Yt.showModal() : Yt.close()
    })
  }), ke((Yt, sr, Kt, vr, Lr, ii, mr, ge) => {
    ee(Me, Yt), ee(Qe, sr), ee(_t, Kt), Er(at, 1, `bg-base-200/80 hover:bg-base-300 group flex h-40 flex-col items-center justify-between rounded-lg p-3 text-xs transition disabled:opacity-50 ${h(G)===0?" border-primary bg-primary/10":""}`), at.disabled = h(K), ee(ut, vr), ee(Ct, Lr), ee(Zt, ii), ee(nr, mr), Gt.disabled = h(K), ee(Rt, ge), ir.disabled = h(K) || h(G) === null || h(re) === null || h(he) === null
  }, [() => pw(), () => fw(), () => mw(), () => M0(), () => gw(), () => _w(), () => q0(), () => No()]), Ci("close", We, () => _(!1)), B(y, We), Wr()
}
Ui(["click"]);
var MA = ae('<span class="center-absolute loading loading-spinner absolute"></span>'),
  CA = ae('<button type="button" class="relative hover:brightness-95 disabled:opacity-50"><!> <!></button>'),
  AA = ae('<span class="center-absolute loading loading-spinner absolute"></span>'),
  kA = ae('<button type="button" class="relative hover:brightness-95 disabled:opacity-50"><!> <!></button>'),
  zA = ae('<div><div class="text-base-content/80 text-sm"> </div> <div class="mt-2 grid grid-cols-3 gap-2"><!> <!></div></div>'),
  EA = ae('<a class="btn border-0 bg-[#5865F2] text-white"><!> </a>'),
  LA = ae('<button class="btn btn-error btn-soft"><!> </button>'),
  DA = ae('<dialog class="modal" closedby="any"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2"></button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form class="mt-3 w-full"><div class="flex flex-col gap-6 sm:flex-row"><div class="sm:min-w-34 flex items-center justify-center gap-6 sm:flex-col sm:gap-3"><div class="relative flex w-max items-center gap-2 mb-5 mt-4"><div class="relative w-max"><!> <a class="tooltip btn btn-circle tooltip-right absolute -bottom-1 -right-1 max-sm:overflow-x-hidden" href="/profile-picture"><!></a></div> <button type="button" class="tooltip btn btn-circle btn-soft tooltip-bottom absolute -bottom-1 -left-1 before:translate-x-1/3"><span class="text-lg"></span></button></div> <!></div> <div class="flex w-full flex-col gap-3"><div class="tooltip tooltip-bottom"><!></div> <!> <label class="label whitespace-pre-line text-sm"><input class="checkbox checkbox-xs" type="checkbox"/> </label></div></div> <div class="col mt-4 flex flex-wrap justify-between gap-2"><div class="dropdown dropdown-top max-sm:dropdown-top col ml-1 mt-4 flex gap-2"><button tabindex="0" class="btn btn-sm btn-soft"> </button> <ul class="dropdown-content menu bg-base-100 z-1 mb-1 w-max gap-0.5 rounded-xl p-2.5 font-medium shadow-sm"><li><button type="button" class="text-error py-2"> </button></li> <li><button type="button" class="text-error py-2"> </button></li></ul></div> <div class="col mt-4 flex gap-2"><button class="btn btn-soft" type="button"> </button> <button class="btn btn-primary" type="submit"> </button></div></div></form></div></dialog> <!> <!> <!>', 1);

function RA(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "open", 15),
    x = Xe(Wi(l.userData.name)),
    k = Xe(Wi(l.userData.discord)),
    z = Xe(Wi(l.userData.showLastPixel)),
    T = Xe(!1),
    s = Xe(void 0),
    F = Xe(!1),
    Z = Xe(!1);
  const K = ab("2025-09_discord_linking");
  let G = Xe(!!l.userData.discordId),
    re = Xe(!1),
    he = Xe(void 0),
    me = Xe(void 0);
  Qr(() => {
    j(x, l.userData.name, !0), j(z, l.userData.showLastPixel, !0)
  }), Qr(() => {
    _() && !h(s) && Kr.getMyProfilePictures().then(Kt => {
      j(s, Kt, !0)
    }).catch(Kt => {
      Bt.error(Kt.message)
    })
  });
  let q = Xe(!1);
  async function ye(Kt) {
    try {
      j(q, !0), await Kr.changeProfilePicture(Kt), await bt.refresh()
    } finally {
      j(q, !1)
    }
  }
  var be = DA(),
    qe = zt(be),
    xe = P(qe),
    Ye = E(P(xe), 2),
    We = P(Ye, !0);
  S(Ye);
  var ze = E(Ye, 2),
    Se = P(ze),
    Pe = P(Se),
    Ae = P(Pe),
    Me = P(Ae),
    Ee = P(Me);
  bn(Ee, {
    class: "h-30 w-30 relative",
    get userId() {
      return l.userData.id
    },
    get pictureUrl() {
      return l.userData.picture
    },
    get borderUrl() {
      return l.userData.equippedFrameUrl
    }
  });
  var Qe = E(Ee, 2),
    Ue = P(Qe);
  f0(Ue, {
    class: "size-5"
  }), S(Qe), S(Me);
  var je = E(Me, 2);
  je.__click = () => {
    j(re, !0)
  }, S(Ae);
  var rt = E(Ae, 2);
  {
    var _t = Kt => {
      var vr = zA(),
        Lr = P(vr),
        ii = P(Lr, !0);
      S(Lr);
      var mr = E(Lr, 2),
        ge = P(mr);
      {
        var V = J => {
          var se = CA();
          se.__click = () => {
            ye()
          };
          var te = P(se);
          bn(te, {
            class: "size-10 border",
            get userId() {
              return l.userData.id
            }
          });
          var _e = E(te, 2);
          {
            var Re = ne => {
              var oe = MA();
              B(ne, oe)
            };
            Te(_e, ne => {
              h(q) && ne(Re)
            })
          }
          S(se), ke(() => se.disabled = h(q)), B(J, se)
        };
        Te(ge, J => {
          l.userData.picture && J(V)
        })
      }
      var U = E(ge, 2);
      Hi(U, 17, () => h(s), J => J.id, (J, se) => {
        var te = br(),
          _e = zt(te);
        {
          var Re = ne => {
            var oe = kA();
            oe.__click = () => {
              ye(h(se).id)
            };
            var fe = P(oe);
            bn(fe, {
              class: "size-10 border",
              get userId() {
                return l.userData.id
              },
              get pictureUrl() {
                return h(se).url
              }
            });
            var ve = E(fe, 2);
            {
              var ie = Y => {
                var Fe = AA();
                B(Y, Fe)
              };
              Te(ve, Y => {
                h(q) && Y(ie)
              })
            }
            S(oe), ke(() => oe.disabled = h(q)), B(ne, oe)
          };
          Te(_e, ne => {
            l.userData.picture !== h(se).url && ne(Re)
          })
        }
        B(J, te)
      }), S(mr), S(vr), ke(J => ee(ii, J), [() => Sw()]), B(Kt, vr)
    };
    Te(rt, Kt => {
      var vr;
      (vr = h(s)) != null && vr.length && Kt(_t)
    })
  }
  S(Pe);
  var dt = E(Pe, 2),
    at = P(dt),
    nt = P(at);
  {
    let Kt = Je(() => fm()),
      vr = Je(() => fm());
    bm(nt, {
      get label() {
        return h(Kt)
      },
      get placeholder() {
        return h(vr)
      },
      min: 1,
      max: 16,
      get value() {
        return h(x)
      },
      set value(Lr) {
        j(x, Lr, !0)
      },
      get validate() {
        return h(he)
      },
      set validate(Lr) {
        j(he, Lr, !0)
      }
    })
  }
  S(at);
  var ot = E(at, 2);
  {
    var ut = Kt => {
        var vr = br(),
          Lr = zt(vr);
        {
          var ii = ge => {
              var V = EA(),
                U = P(V);
              wm(U, {
                class: "size-4.5"
              });
              var J = E(U);
              S(V), ke((se, te) => {
                Xt(V, "href", se), ee(J, ` ${te??""}`)
              }, [() => nb("/discord/authorize"), () => Iw()]), B(ge, V)
            },
            mr = ge => {
              var V = LA();
              V.__click = async () => {
                try {
                  j(T, !0), await Kr.unlinkDiscord(), bt.refresh(), Bt.success(Mw()), j(G, !1)
                } catch (se) {
                  Bt.error(se.message, {
                    duration: 5e3
                  })
                } finally {
                  j(T, !1)
                }
              };
              var U = P(V);
              wm(U, {
                class: "size-4.5"
              });
              var J = E(U);
              S(V), ke(se => {
                V.disabled = h(T), ee(J, ` ${se??""}`)
              }, [() => {
                var se;
                return Cw({
                  username: ((se = l.userData) == null ? void 0 : se.discord) ?? ""
                })
              }]), B(ge, V)
            };
          Te(Lr, ge => {
            h(G) ? ge(mr, !1) : ge(ii)
          })
        }
        B(Kt, vr)
      },
      st = Kt => {
        {
          let vr = Je(() => Pw());
          bm(Kt, {
            label: "Discord",
            get placeholder() {
              return h(vr)
            },
            max: 32,
            get value() {
              return h(k)
            },
            set value(Lr) {
              j(k, Lr, !0)
            },
            get validate() {
              return h(me)
            },
            set validate(Lr) {
              j(me, Lr, !0)
            }
          })
        }
      };
    Te(ot, Kt => {
      K ? Kt(ut) : Kt(st, !1)
    })
  }
  var wt = E(ot, 2),
    Ct = P(wt);
  Ka(Ct);
  var rr = E(Ct);
  S(wt), S(dt), S(Se);
  var Zt = E(Se, 2),
    lt = P(Zt),
    ht = P(lt),
    Dt = P(ht, !0);
  S(ht);
  var Vt = E(ht, 2),
    Jt = P(Vt),
    jt = P(Jt);
  jt.__click = () => {
    j(Z, !0)
  };
  var nr = P(jt, !0);
  S(jt), S(Jt);
  var St = E(Jt, 2),
    Et = P(St);
  Et.__click = () => {
    j(F, !0)
  };
  var Ut = P(Et, !0);
  S(Et), S(St), S(Vt), S(lt);
  var Gt = E(lt, 2),
    Rt = P(Gt);
  Rt.__click = () => {
    _(!1)
  };
  var ir = P(Rt, !0);
  S(Rt);
  var kr = E(Rt, 2),
    _r = P(kr, !0);
  S(kr), S(Gt), S(Zt), S(ze), S(xe), S(qe), qa(qe, () => Kt => {
    Qr(() => {
      _() ? Kt.showModal() : Kt.close()
    })
  });
  var fr = E(qe, 2);
  hA(fr, {
    get open() {
      return h(F)
    },
    set open(Kt) {
      j(F, Kt, !0)
    }
  });
  var Yt = E(fr, 2);
  gA(Yt, {
    get open() {
      return h(Z)
    },
    set open(Kt) {
      j(Z, Kt, !0)
    }
  });
  var sr = E(Yt, 2);
  IA(sr, {
    get open() {
      return h(re)
    },
    set open(Kt) {
      j(re, Kt, !0)
    }
  }), ke((Kt, vr, Lr, ii, mr, ge, V, U, J, se) => {
    ee(We, Kt), Xt(Qe, "data-tip", vr), Xt(je, "data-tip", Lr), Xt(at, "data-tip", ii), ee(rr, ` ${mr??""}`), ee(Dt, ge), ee(nr, V), ee(Ut, U), Rt.disabled = h(T), ee(ir, J), kr.disabled = h(T), ee(_r, se)
  }, [() => vw(), () => C3(), () => yw(), () => xw(), () => bw(), () => ww(), () => L0(), () => dm(), () => uo(), () => Ju()]), Ci("close", qe, () => _(!1)), Ci("submit", ze, async () => {
    var Kt;
    try {
      if (!((Kt = h(he)) != null && Kt())) return;
      j(T, !0), await Kr.updateMe({
        name: h(x),
        showLastPixel: h(z)
      }), bt.refresh(), Bt.success(Tw()), _(!1)
    } catch (vr) {
      Bt.error(vr.message, {
        duration: 5e3
      })
    } finally {
      j(T, !1)
    }
  }), bp(Ct, () => h(z), Kt => j(z, Kt)), B(y, be), Wr()
}
Ui(["click"]);
var FA = Yr('<svg><path d="M480-120q-150 0-255-105T120-480q0-150 105-255t255-105q14 0 27.5 1t26.5 3q-41 29-65.5 75.5T444-660q0 90 63 153t153 63q55 0 101-24.5t75-65.5q2 13 3 26.5t1 27.5q0 150-105 255T480-120Zm0-80q88 0 158-48.5T740-375q-20 5-40 8t-40 3q-123 0-209.5-86.5T364-660q0-20 3-40t8-40q-78 32-126.5 102T200-480q0 116 82 198t198 82Zm-10-270Z"></path></svg>');

function BA(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = FA();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var OA = Yr('<svg><path d="M480-360q50 0 85-35t35-85q0-50-35-85t-85-35q-50 0-85 35t-35 85q0 50 35 85t85 35Zm0 80q-83 0-141.5-58.5T280-480q0-83 58.5-141.5T480-680q83 0 141.5 58.5T680-480q0 83-58.5 141.5T480-280ZM200-440H40v-80h160v80Zm720 0H760v-80h160v80ZM440-760v-160h80v160h-80Zm0 720v-160h80v160h-80ZM256-650l-101-97 57-59 96 100-52 56Zm492 496-97-101 53-55 101 97-57 59Zm-98-550 97-101 59 57-100 96-56-52ZM154-212l101-97 55 53-97 101-59-57Zm326-268Z"></path></svg>');

function jA(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = OA();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var qA = Yr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h280v80H200v560h280v80H200Zm440-160-55-58 102-102H360v-80h327L585-622l55-58 200 200-200 200Z"></path></svg>');

function o0(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = qA();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var NA = Yr('<svg><path d="M160-200v-80h80v-280q0-83 50-147.5T420-792v-28q0-25 17.5-42.5T480-880q25 0 42.5 17.5T540-820v28q80 20 130 84.5T720-560v280h80v80H160Zm320-300Zm0 420q-33 0-56.5-23.5T400-160h160q0 33-23.5 56.5T480-80ZM320-280h320v-280q0-66-47-113t-113-47q-66 0-113 47t-47 113v280Z"></path></svg>');

function VA(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = NA();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var UA = Yr('<svg><path d="M240-80q-50 0-85-35t-35-85v-120h120v-560l60 60 60-60 60 60 60-60 60 60 60-60 60 60 60-60 60 60 60-60v680q0 50-35 85t-85 35H240Zm480-80q17 0 28.5-11.5T760-200v-560H320v440h360v120q0 17 11.5 28.5T720-160ZM360-600v-80h240v80H360Zm0 120v-80h240v80H360Zm320-120q-17 0-28.5-11.5T640-640q0-17 11.5-28.5T680-680q17 0 28.5 11.5T720-640q0 17-11.5 28.5T680-600Zm0 120q-17 0-28.5-11.5T640-520q0-17 11.5-28.5T680-560q17 0 28.5 11.5T720-520q0 17-11.5 28.5T680-480ZM240-160h360v-80H200v40q0 17 11.5 28.5T240-160Zm-40 0v-80 80Z"></path></svg>');

function l0(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = UA();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var ZA = Yr('<svg><defs><radialGradient id="snoo-radial-gragient" cx="169.75" cy="92.19" r="50.98" fx="169.75" fy="92.19" gradientTransform="matrix(1 0 0 .87 0 11.64)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#feffff"></stop><stop offset=".4" stop-color="#feffff"></stop><stop offset=".51" stop-color="#f9fcfc"></stop><stop offset=".62" stop-color="#edf3f5"></stop><stop offset=".7" stop-color="#dee9ec"></stop><stop offset=".72" stop-color="#d8e4e8"></stop><stop offset=".76" stop-color="#ccd8df"></stop><stop offset=".8" stop-color="#c8d5dd"></stop><stop offset=".83" stop-color="#ccd6de"></stop><stop offset=".85" stop-color="#d8dbe2"></stop><stop offset=".88" stop-color="#ede3e9"></stop><stop offset=".9" stop-color="#ffebef"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-2" cx="47.31" r="50.98" fx="47.31"></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-3" cx="109.61" cy="85.59" r="153.78" fx="109.61" fy="85.59" gradientTransform="matrix(1 0 0 .7 0 25.56)"></radialGradient><radialGradient id="snoo-radial-gragient-4" cx="-6.01" cy="64.68" r="12.85" fx="-6.01" fy="64.68" gradientTransform="matrix(1.07 0 0 1.55 81.08 27.26)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#f60"></stop><stop offset=".5" stop-color="#ff4500"></stop><stop offset=".7" stop-color="#fc4301"></stop><stop offset=".82" stop-color="#f43f07"></stop><stop offset=".92" stop-color="#e53812"></stop><stop offset="1" stop-color="#d4301f"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient-4" id="snoo-radial-gragient-5" cx="-73.55" cy="64.68" r="12.85" fx="-73.55" fy="64.68" gradientTransform="matrix(-1.07 0 0 1.55 62.87 27.26)"></radialGradient><radialGradient id="snoo-radial-gragient-6" cx="107.93" cy="166.96" r="45.3" fx="107.93" fy="166.96" gradientTransform="matrix(1 0 0 .66 0 57.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#172e35"></stop><stop offset=".29" stop-color="#0e1c21"></stop><stop offset=".73" stop-color="#030708"></stop><stop offset="1"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-7" cx="147.88" cy="32.94" r="39.77" fx="147.88" fy="32.94" gradientTransform="matrix(1 0 0 .98 0 .54)"></radialGradient><radialGradient id="snoo-radial-gragient-8" cx="131.31" cy="73.08" r="32.6" fx="131.31" fy="73.08" gradientUnits="userSpaceOnUse"><stop offset=".48" stop-color="#7a9299"></stop><stop offset=".67" stop-color="#172e35"></stop><stop offset=".75"></stop><stop offset=".82" stop-color="#172e35"></stop></radialGradient></defs><path fill="#ff4500" stroke-width="0" d="M108 0C48.35 0 0 48.35 0 108c0 29.82 12.09 56.82 31.63 76.37l-20.57 20.57C6.98 209.02 9.87 216 15.64 216H108c59.65 0 108-48.35 108-108S167.65 0 108 0Z"></path><circle cx="169.22" cy="106.98" r="25.22" fill="url(#snoo-radial-gragient)" stroke-width="0"></circle><circle cx="46.78" cy="106.98" r="25.22" fill="url(#snoo-radial-gragient-2)" stroke-width="0"></circle><ellipse cx="108.06" cy="128.64" fill="url(#snoo-radial-gragient-3)" stroke-width="0" rx="72" ry="54"></ellipse><path fill="url(#snoo-radial-gragient-4)" stroke-width="0" d="M86.78 123.48c-.42 9.08-6.49 12.38-13.56 12.38s-12.46-4.93-12.04-14.01c.42-9.08 6.49-15.02 13.56-15.02s12.46 7.58 12.04 16.66Z"></path><path fill="url(#snoo-radial-gragient-5)" stroke-width="0" d="M129.35 123.48c.42 9.08 6.49 12.38 13.56 12.38s12.46-4.93 12.04-14.01c-.42-9.08-6.49-15.02-13.56-15.02s-12.46 7.58-12.04 16.66Z"></path><ellipse cx="79.63" cy="116.37" class="snoo-cls-11 svelte-14mu38d" rx="2.8" ry="3.05"></ellipse><ellipse cx="146.21" cy="116.37" class="snoo-cls-11 svelte-14mu38d" rx="2.8" ry="3.05"></ellipse><path fill="url(#snoo-radial-gragient-6)" stroke-width="0" d="M108.06 142.92c-8.76 0-17.16.43-24.92 1.22-1.33.13-2.17 1.51-1.65 2.74 4.35 10.39 14.61 17.69 26.57 17.69s22.23-7.3 26.57-17.69c.52-1.23-.33-2.61-1.65-2.74-7.77-.79-16.16-1.22-24.92-1.22Z"></path><circle cx="147.49" cy="49.43" r="17.87" fill="url(#snoo-radial-gragient-7)" stroke-width="0"></circle><path fill="url(#snoo-radial-gragient-8)" stroke-width="0" d="M107.8 76.92c-2.14 0-3.87-.89-3.87-2.27 0-16.01 13.03-29.04 29.04-29.04 2.14 0 3.87 1.73 3.87 3.87s-1.73 3.87-3.87 3.87c-11.74 0-21.29 9.55-21.29 21.29 0 1.38-1.73 2.27-3.87 2.27Z"></path><path fill="#842123" stroke-width="0" d="M62.82 122.65c.39-8.56 6.08-14.16 12.69-14.16 6.26 0 11.1 6.39 11.28 14.33.17-8.88-5.13-15.99-12.05-15.99s-13.14 6.05-13.56 15.2c-.42 9.15 4.97 13.83 12.04 13.83h.52c-6.44-.16-11.3-4.79-10.91-13.2Zm90.48 0c-.39-8.56-6.08-14.16-12.69-14.16-6.26 0-11.1 6.39-11.28 14.33-.17-8.88 5.13-15.99 12.05-15.99 7.07 0 13.14 6.05 13.56 15.2.42 9.15-4.97 13.83-12.04 13.83h-.52c6.44-.16 11.3-4.79 10.91-13.2Z"></path></svg>');

function GA(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = ZA();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink",
    viewBox: "0 0 216 216",
    ..._
  }), void 0, void 0, void 0, "svelte-14mu38d"), B(y, x)
}
var WA = Yr('<svg><path d="M480-280q17 0 28.5-11.5T520-320q0-17-11.5-28.5T480-360q-17 0-28.5 11.5T440-320q0 17 11.5 28.5T480-280Zm-40-160h80v-240h-80v240ZM330-120 120-330v-300l210-210h300l210 210v300L630-120H330Zm34-80h232l164-164v-232L596-760H364L200-596v232l164 164Zm116-280Z"></path></svg>');

function Zm(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = WA();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var HA = Yr('<svg><path d="M480-440q-59 0-99.5-40.5T340-580q0-59 40.5-99.5T480-720q59 0 99.5 40.5T620-580q0 59-40.5 99.5T480-440Zm0-80q26 0 43-17t17-43q0-26-17-43t-43-17q-26 0-43 17t-17 43q0 26 17 43t43 17Zm0 440q-139-35-229.5-159.5T160-516v-244l320-120 320 120v244q0 152-90.5 276.5T480-80Zm0-400Zm0-315-240 90v189q0 54 15 105t41 96q42-21 88-33t96-12q50 0 96 12t88 33q26-45 41-96t15-105v-189l-240-90Zm0 515q-36 0-70 8t-65 22q29 30 63 52t72 34q38-12 72-34t63-52q-31-14-65-22t-70-8Z"></path></svg>');

function sp(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = HA();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var XA = Yr('<svg><path d="m476-80 182-480h84L924-80h-84l-43-122H603L560-80h-84ZM160-200l-56-56 202-202q-35-35-63.5-80T190-640h84q20 39 40 68t48 58q33-33 68.5-92.5T484-720H40v-80h280v-80h80v80h280v80H564q-21 72-63 148t-83 116l96 98-30 82-122-125-202 201Zm468-72h144l-72-204-72 204Z"></path></svg>');

function YA(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = XA();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var KA = Yr('<svg><path d="M480-320q75 0 127.5-52.5T660-500q0-75-52.5-127.5T480-680q-75 0-127.5 52.5T300-500q0 75 52.5 127.5T480-320Zm0-72q-45 0-76.5-31.5T372-500q0-45 31.5-76.5T480-608q45 0 76.5 31.5T588-500q0 45-31.5 76.5T480-392Zm0 192q-146 0-266-81.5T40-500q54-137 174-218.5T480-800q146 0 266 81.5T920-500q-54 137-174 218.5T480-200Zm0-300Zm0 220q113 0 207.5-59.5T832-500q-50-101-144.5-160.5T480-720q-113 0-207.5 59.5T128-500q50 101 144.5 160.5T480-280Z"></path></svg>');

function JA(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = KA();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var $A = Yr('<svg><path d="m644-428-58-58q9-47-27-88t-93-32l-58-58q17-8 34.5-12t37.5-4q75 0 127.5 52.5T660-500q0 20-4 37.5T644-428Zm128 126-58-56q38-29 67.5-63.5T832-500q-50-101-143.5-160.5T480-720q-29 0-57 4t-55 12l-62-62q41-17 84-25.5t90-8.5q151 0 269 83.5T920-500q-23 59-60.5 109.5T772-302Zm20 246L624-222q-35 11-70.5 16.5T480-200q-151 0-269-83.5T40-500q21-53 53-98.5t73-81.5L56-792l56-56 736 736-56 56ZM222-624q-29 26-53 57t-41 67q50 101 143.5 160.5T480-280q20 0 39-2.5t39-5.5l-36-38q-11 3-21 4.5t-21 1.5q-75 0-127.5-52.5T300-500q0-11 1.5-21t4.5-21l-84-82Zm319 93Zm-151 75Z"></path></svg>');

function Ry(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = $A();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var QA = Yr('<svg><path d="M792-56 671-177q-25 16-53 27.5T560-131v-82q14-5 27.5-10t25.5-12L480-368v208L280-360H120v-240h128L56-792l56-56 736 736-56 56Zm-8-232-58-58q17-31 25.5-65t8.5-70q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 53-14.5 102T784-288ZM650-422l-90-90v-130q47 22 73.5 66t26.5 96q0 15-2.5 29.5T650-422ZM480-592 376-696l104-104v208Zm-80 238v-94l-72-72H200v80h114l86 86Zm-36-130Z"></path></svg>');

function ek(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = QA();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var tk = Yr('<svg><path d="M560-131v-82q90-26 145-100t55-168q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 127-78 224.5T560-131ZM120-360v-240h160l200-200v640L280-360H120Zm440 40v-322q47 22 73.5 66t26.5 96q0 51-26.5 94.5T560-320ZM400-606l-86 86H200v80h114l86 86v-252ZM300-480Z"></path></svg>');

function rk(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = tk();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var ik = ae('<div class="absolute inset-0 flex items-center justify-center"><!></div>'),
  ak = ae('<p class="text-base-content/50 wrap-break-words mt-1 hidden text-[10px] whitespace-normal sm:block"> </p>'),
  nk = ae('<div class="relative shrink-0"><img/> <!></div> <div class="min-w-0 flex-1 text-left sm:text-center"><p> </p> <p> </p> <p class="text-base-content/70 wrap-break-words mt-1 text-xs whitespace-normal"> </p> <!></div>', 1),
  sk = ae('<div class="border-base-content/30 flex size-14 shrink-0 items-center justify-center rounded-full border border-dashed sm:size-20"><span class="text-base-content/40 text-2xl font-light sm:text-3xl">+</span></div> <span class="text-base-content/60 text-sm"> </span>', 1),
  ok = ae('<img class="size-full rounded-full object-cover"/>'),
  lk = ae('<div class="border-base-content/30 bg-base-300 flex size-full items-center justify-center rounded-full border border-dashed"><span class="text-base-content/40 text-xs">+</span></div>'),
  ck = ae("<button><!></button>"),
  uk = ae('<span class="loading loading-spinner"></span>'),
  hk = ae('<div class="mt-1 flex w-full justify-center"><span class="badge badge-primary badge-sm"> </span></div>'),
  dk = ae('<div class="mt-1 flex w-full justify-center"><span class="badge badge-primary badge-sm"> </span></div>'),
  pk = ae('<button type="button"><div class="flex flex-1 flex-col items-center justify-center gap-1"><div class="relative"><div class="relative flex size-16 items-center justify-center overflow-hidden rounded-full"><img class="pointer-events-none absolute inset-0 size-full rounded-full object-cover"/></div></div></div> <div class="mt-1 flex w-full flex-col items-center text-center"><span class="line-clamp-1 w-full text-xs font-medium"> </span> <span> </span></div> <!></button>'),
  fk = ae('<button type="button"><div class="flex flex-1 flex-col items-center justify-center gap-1"><div class="relative"><div class="relative flex size-16 items-center justify-center overflow-hidden rounded-full"><img class="pointer-events-none absolute inset-0 size-full rounded-full object-cover grayscale"/></div> <div class="absolute inset-0 flex items-center justify-center"><!></div></div></div> <div class="mt-1 flex w-full flex-col items-center text-center"><span class="text-base-content/50 line-clamp-1 w-full text-xs font-medium"> </span> <span class="text-base-content/40 mt-0.5 w-full text-[11px] capitalize"> </span></div></button>'),
  mk = ae('<h4 class="text-base-content/80 mt-4 mb-2 text-sm font-semibold"> </h4> <div class="grid grid-cols-2 gap-3 p-0.5 sm:grid-cols-3"></div>', 1),
  gk = ae('<span class="loading loading-spinner"></span>'),
  _k = ae('<dialog class="modal"><div class="modal-box max-h-11/12 max-w-2xl"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute top-2 right-2"></button></form> <h3 class="text-lg font-bold"> </h3> <p class="text-base-content/80 mb-3 text-sm"> <span class="badge badge-primary badge-sm"> </span></p> <div class="grid grow grid-cols-1 gap-4 overflow-hidden overflow-y-auto sm:grid-cols-[1fr_auto]"><section class="order-first flex flex-col justify-between sm:order-last"><div><h4 class="text-base-content/80 mb-2 text-sm font-semibold"> </h4> <div class="bg-base-200 flex h-20 items-center gap-3 rounded-lg p-3 sm:h-auto sm:min-h-48 sm:w-44 sm:flex-col sm:p-4"><!></div> <div class="mt-3"><h5 class="text-base-content/70 mb-1 text-xs"> </h5> <div class="flex items-center gap-2"></div></div></div> <div class="mt-4 hidden justify-end sm:flex"><button type="button" class="btn mr-2"> </button> <button type="button" class="btn btn-primary"><!></button></div></section> <section class="order-last max-h-[50vh] min-h-0 sm:order-first sm:max-h-none"><h4 class="text-base-content/80 mb-2 text-sm font-semibold"> </h4> <div class="grid grid-cols-2 gap-3 p-0.5 sm:grid-cols-3"><button type="button"><div class="flex flex-1 flex-col items-center justify-center gap-1"><div class="text-base-content/60 border-base-content/60 flex size-16 items-center justify-center rounded-full border border-dashed text-xs font-semibold"><span class="text-2xl font-light"></span></div></div> <div class="mt-1 flex w-full flex-col items-center text-center"><span class="line-clamp-1 w-full text-xs font-medium"> </span> <span class="text-base-content/70 mt-0.5 w-full text-[11px]"> </span></div> <!></button> <!></div> <!> <p class="sm:pt-10"></p></section> <div class="order-last mt-4 flex justify-end sm:hidden"><button type="button" class="btn mr-2"> </button> <button type="button" class="btn btn-primary"><!></button></div></div></div></dialog>');

function vk(y, l) {
  var U, J, se, te, _e, Re;
  Gr(l, !0);
  let _ = Ot(l, "open", 15),
    x = Ot(l, "slotIndex", 15, 0),
    k = Xe(Wi([]));
  const z = Wi(bt.data);
  let T = Xe(!1),
    s = Xe(Wi(((J = (U = z.equippedBadges) == null ? void 0 : U[0]) == null ? void 0 : J.id) || 0)),
    F = Xe(Wi(((te = (se = z.equippedBadges) == null ? void 0 : se[1]) == null ? void 0 : te.id) || 0)),
    Z = Xe(Wi(((Re = (_e = z.equippedBadges) == null ? void 0 : _e[2]) == null ? void 0 : Re.id) || 0)),
    K = Je(() => x() === 0 ? h(s) : x() === 1 ? h(F) : h(Z)),
    G = Xe(null),
    re = Je(() => h(G) ?? h(K));

  function he(ne) {
    x() === 0 ? j(s, ne, !0) : x() === 1 ? j(F, ne, !0) : j(Z, ne, !0)
  }
  let me = Je(() => () => {
    const ne = h(K),
      fe = [h(s), h(F), h(Z)].filter(Y => Y !== 0);
    if (fe.length !== new Set(fe).size) return !1;
    if (ne === 0) return !0;
    const ie = h(k).find(Y => Y.id === ne);
    return (ie == null ? void 0 : ie.earned) !== !1
  });
  Qr(() => {
    var ne, oe, fe, ve, ie, Y;
    _() && (j(s, ((oe = (ne = z.equippedBadges) == null ? void 0 : ne[0]) == null ? void 0 : oe.id) || 0, !0), j(F, ((ve = (fe = z.equippedBadges) == null ? void 0 : fe[1]) == null ? void 0 : ve.id) || 0, !0), j(Z, ((Y = (ie = z.equippedBadges) == null ? void 0 : ie[2]) == null ? void 0 : Y.id) || 0, !0), j(G, null))
  });

  function q(ne) {
    if (!h(T)) {
      if (ne !== 0) {
        const oe = h(k).find(fe => fe.id === ne);
        if ((oe == null ? void 0 : oe.earned) === !1) {
          j(G, ne, !0);
          return
        }
      }
      j(G, null), he(ne)
    }
  }
  async function ye() {
    if (h(T)) return;
    const ne = {
      slotIndex0: h(s),
      slotIndex1: h(F),
      slotIndex2: h(Z)
    };
    j(T, !0);
    try {
      await Kr.postEquipUserBadge(ne), await bt.refresh(), Bt.success(Rw()), _(!1)
    } catch {
      Bt.error(Fw())
    } finally {
      j(T, !1)
    }
  }

  function be(ne) {
    switch (ne) {
      case "legendary":
        return "text-yellow-500";
      case "epic":
        return "text-purple-500";
      case "rare":
        return "text-blue-500";
      case "common":
      default:
        return "text-base-content/70"
    }
  }
  Oa(async () => {
    try {
      j(k, await Kr.getUserBadges(), !0)
    } catch {
      Bt.error(j0())
    }
  });
  var qe = _k(),
    xe = P(qe),
    Ye = P(xe),
    We = P(Ye);
  We.__click = () => {
    _(!1)
  }, S(Ye);
  var ze = E(Ye, 2),
    Se = P(ze, !0);
  S(ze);
  var Pe = E(ze, 2),
    Ae = P(Pe),
    Me = E(Ae),
    Ee = P(Me);
  S(Me), S(Pe);
  var Qe = E(Pe, 2),
    Ue = P(Qe),
    je = P(Ue),
    rt = P(je),
    _t = P(rt, !0);
  S(rt);
  var dt = E(rt, 2),
    at = P(dt);
  bl(at, () => h(re), ne => {
    const oe = Je(() => h(k).find(Ne => Ne.id === h(re))),
      fe = Je(() => {
        var Ne;
        return ((Ne = h(oe)) == null ? void 0 : Ne.earned) === !1
      });
    var ve = br(),
      ie = zt(ve);
    {
      var Y = Ne => {
          var Ge = nk(),
            pe = zt(Ge),
            Ve = P(pe),
            it = E(Ve, 2);
          {
            var yt = tt => {
              var Ht = ik(),
                Qt = P(Ht);
              rh(Qt, {
                class: "text-error size-6 sm:size-8"
              }), S(Ht), B(tt, Ht)
            };
            Te(it, tt => {
              h(fe) && tt(yt)
            })
          }
          S(pe);
          var Lt = E(pe, 2),
            ct = P(Lt),
            At = P(ct, !0);
          S(ct);
          var qt = E(ct, 2),
            Ke = P(qt, !0);
          S(qt);
          var Tt = E(qt, 2),
            Wt = P(Tt, !0);
          S(Tt);
          var Fr = E(Tt, 2);
          {
            var or = tt => {
              var Ht = ak(),
                Qt = P(Ht, !0);
              S(Ht), ke(() => ee(Qt, h(oe).howToEarn)), B(tt, Ht)
            };
            Te(Fr, tt => {
              h(oe).howToEarn && tt(or)
            })
          }
          S(Lt), ke((tt, Ht) => {
            Xt(Ve, "src", h(oe).imageUrl), Xt(Ve, "alt", h(oe).name), Er(Ve, 1, `size-14 rounded-full object-cover sm:size-20 ${h(fe)?"grayscale":""}`), Er(ct, 1, `wrap-break-words font-medium whitespace-normal ${h(fe)?"text-base-content/50":""}`), ee(At, h(oe).name), Er(qt, 1, `text-xs capitalize ${tt??""}`), ee(Ke, Ht), ee(Wt, h(oe).description)
          }, [() => h(fe) ? "text-base-content/40" : be(h(oe).rarity), () => h(fe) ? Qf() : h(oe).rarity]), B(Ne, Ge)
        },
        Fe = Ne => {
          var Ge = sk(),
            pe = E(zt(Ge), 2),
            Ve = P(pe, !0);
          S(pe), ke(it => ee(Ve, it), [() => Aw()]), B(Ne, Ge)
        };
      Te(ie, Ne => {
        h(oe) ? Ne(Y) : Ne(Fe, !1)
      })
    }
    B(ne, ve)
  }), S(dt);
  var nt = E(dt, 2),
    ot = P(nt),
    ut = P(ot, !0);
  S(ot);
  var st = E(ot, 2);
  Hi(st, 20, () => [0, 1, 2], po, (ne, oe) => {
    const fe = Je(() => oe === x()),
      ve = Je(() => oe === 0 ? h(s) : oe === 1 ? h(F) : h(Z)),
      ie = Je(() => h(k).find(pe => pe.id === h(ve)));
    var Y = ck();
    Y.__click = () => x(oe);
    var Fe = P(Y);
    {
      var Ne = pe => {
          var Ve = ok();
          ke(() => {
            Xt(Ve, "src", h(ie).imageUrl), Xt(Ve, "alt", h(ie).name)
          }), B(pe, Ve)
        },
        Ge = pe => {
          var Ve = lk();
          B(pe, Ve)
        };
      Te(Fe, pe => {
        h(ie) ? pe(Ne) : pe(Ge, !1)
      })
    }
    S(Y), ke(() => Er(Y, 1, `relative size-8 rounded-full ${h(fe)?"ring-primary ring-offset-base-100 ring-2 ring-offset-2":""}`)), B(ne, Y)
  }), S(st), S(nt), S(je);
  var wt = E(je, 2),
    Ct = P(wt);
  Ct.__click = () => {
    _(!1)
  };
  var rr = P(Ct, !0);
  S(Ct);
  var Zt = E(Ct, 2);
  Zt.__click = ye;
  var lt = P(Zt);
  {
    var ht = ne => {
        var oe = uk();
        B(ne, oe)
      },
      Dt = ne => {
        var oe = ja();
        ke(fe => ee(oe, fe), [() => Ju()]), B(ne, oe)
      };
    Te(lt, ne => {
      h(T) ? ne(ht) : ne(Dt, !1)
    })
  }
  S(Zt), S(wt), S(Ue);
  var Vt = E(Ue, 2),
    Jt = P(Vt),
    jt = P(Jt, !0);
  S(Jt);
  var nr = E(Jt, 2),
    St = P(nr);
  St.__click = () => q(0);
  var Et = E(P(St), 2),
    Ut = P(Et),
    Gt = P(Ut, !0);
  S(Ut);
  var Rt = E(Ut, 2),
    ir = P(Rt, !0);
  S(Rt), S(Et);
  var kr = E(Et, 2);
  {
    var _r = ne => {
      var oe = hk(),
        fe = P(oe),
        ve = P(fe, !0);
      S(fe), S(oe), ke(ie => ee(ve, ie), [() => Tp()]), B(ne, oe)
    };
    Te(kr, ne => {
      h(K) === 0 && ne(_r)
    })
  }
  S(St);
  var fr = E(St, 2);
  Hi(fr, 17, () => h(k).filter(ne => ne.earned !== !1), ne => ne.id, (ne, oe) => {
    var fe = pk();
    fe.__click = () => q(h(oe).id);
    var ve = P(fe),
      ie = P(ve),
      Y = P(ie),
      Fe = P(Y);
    S(Y), S(ie), S(ve);
    var Ne = E(ve, 2),
      Ge = P(Ne),
      pe = P(Ge, !0);
    S(Ge);
    var Ve = E(Ge, 2),
      it = P(Ve, !0);
    S(Ve), S(Ne);
    var yt = E(Ne, 2);
    {
      var Lt = ct => {
        var At = dk(),
          qt = P(At),
          Ke = P(qt, !0);
        S(qt), S(At), ke(Tt => ee(Ke, Tt), [() => Tp()]), B(ct, At)
      };
      Te(yt, ct => {
        h(K) === h(oe).id && ct(Lt)
      })
    }
    S(fe), ke(ct => {
      Er(fe, 1, `bg-base-200/80 hover:bg-base-300 group flex h-40 flex-col items-center justify-between rounded-lg p-3 text-xs
									transition
									${h(T)?"opacity-50":""}
									${h(K)===h(oe).id?" border-primary bg-primary/10":""}`), fe.disabled = h(T), Xt(Fe, "src", h(oe).imageUrl), Xt(Fe, "alt", h(oe).name), ee(pe, h(oe).name), Er(Ve, 1, `mt-0.5 w-full text-[11px] capitalize ${ct??""}`), ee(it, h(oe).rarity)
    }, [() => be(h(oe).rarity)]), B(ne, fe)
  }), S(nr);
  var Yt = E(nr, 2);
  {
    var sr = ne => {
      var oe = mk(),
        fe = zt(oe),
        ve = P(fe, !0);
      S(fe);
      var ie = E(fe, 2);
      Hi(ie, 21, () => h(k).filter(Y => Y.earned === !1), Y => Y.id, (Y, Fe) => {
        var Ne = fk();
        Ne.__click = () => q(h(Fe).id);
        var Ge = P(Ne),
          pe = P(Ge),
          Ve = P(pe),
          it = P(Ve);
        S(Ve);
        var yt = E(Ve, 2),
          Lt = P(yt);
        rh(Lt, {
          class: "text-error size-6"
        }), S(yt), S(pe), S(Ge);
        var ct = E(Ge, 2),
          At = P(ct),
          qt = P(At, !0);
        S(At);
        var Ke = E(At, 2),
          Tt = P(Ke, !0);
        S(Ke), S(ct), S(Ne), ke(Wt => {
          Er(Ne, 1, `bg-base-200/80 hover:bg-base-300 group flex h-40 flex-col items-center justify-between rounded-lg p-3 text-xs
									transition
									${h(T)?"opacity-50":""}
									${h(G)===h(Fe).id?"ring-warning/50 bg-warning/5 ring-2":""}`), Ne.disabled = h(T), Xt(it, "src", h(Fe).imageUrl), Xt(it, "alt", h(Fe).name), ee(qt, h(Fe).name), ee(Tt, Wt)
        }, [() => Qf()]), B(Y, Ne)
      }), S(ie), ke(Y => ee(ve, Y), [() => Qf()]), B(ne, oe)
    };
    Te(Yt, ne => {
      h(k).some(oe => oe.earned === !1) && ne(sr)
    })
  }
  wi(2), S(Vt);
  var Kt = E(Vt, 2),
    vr = P(Kt);
  vr.__click = () => {
    _(!1)
  };
  var Lr = P(vr, !0);
  S(vr);
  var ii = E(vr, 2);
  ii.__click = ye;
  var mr = P(ii);
  {
    var ge = ne => {
        var oe = gk();
        B(ne, oe)
      },
      V = ne => {
        var oe = ja();
        ke(fe => ee(oe, fe), [() => Ju()]), B(ne, oe)
      };
    Te(mr, ne => {
      h(T) ? ne(ge) : ne(V, !1)
    })
  }
  S(ii), S(Kt), S(Qe), S(xe), S(qe), qa(qe, () => ne => {
    Qr(() => {
      _() ? ne.showModal() : ne.close()
    })
  }), ke((ne, oe, fe, ve, ie, Y, Fe, Ne, Ge, pe, Ve) => {
    ee(Se, ne), ee(Ae, `${oe??""} `), ee(Ee, `Slot ${x()+1}`), ee(_t, fe), ee(ut, ve), Ct.disabled = h(T), ee(rr, ie), Zt.disabled = Y, ee(jt, Fe), Er(St, 1, `bg-base-200/80 hover:bg-base-300 group flex h-40 flex-col items-center justify-between rounded-lg p-3 text-xs
								transition disabled:opacity-50
								${h(K)===0?" border-primary bg-primary/10":""}`), St.disabled = h(T), ee(Gt, Ne), ee(ir, Ge), vr.disabled = h(T), ee(Lr, pe), ii.disabled = Ve
  }, [() => kw(), () => zw(), () => q0(), () => Ew(), () => No(), () => h(T) || !h(me)(), () => Lw(), () => M0(), () => Dw(), () => No(), () => h(T) || !h(me)()]), Ci("close", qe, () => _(!1)), B(y, qe), Wr()
}
Ui(["click"]);
var yk = ae('<span class="tooltip font-flag ml-0.5"> </span>'),
  xk = ae('<div class="mt-1"><!></div>'),
  bk = ae('<button class="tooltip hover:border-primary size-7 overflow-hidden rounded-full"><img class="size-full object-cover"/></button>'),
  wk = ae('<button class="border-base-content/30 bg-base-200/50 text-base-content/40 hover:bg-base-300/50 grid size-7 place-items-center rounded-full"><span class="text-sm font-light">+</span></button>'),
  Tk = ae('<p class="w-full"> <!></p>'),
  Sk = ae('<p class="w-full"><!></p>'),
  Pk = ae('<div class=" flex items-center gap-2"><!> <!> <button class="btn btn-error btn-sm"><!> </button></div>'),
  Ik = ae('<span class="center-absolute loading loading-spinner loading-xs absolute"></span>'),
  Mk = ae("<li><button><!> </button></li>"),
  Ck = ae('<button class="btn btn-sm btn-circle tooltip"><!></button>'),
  Ak = ae('<button class="btn pwa:hidden w-full sm:hidden"><!> </button>'),
  kk = ae('<a class="btn w-full" target="_blank"><!> </a>'),
  zk = ae('<a class="btn w-full" target="_blank"><!> </a>'),
  Ek = ae('<a class="btn w-full" target="_blank"><!> </a>'),
  Lk = ae('<a class="btn w-full" target="_blank"><!> </a>'),
  Dk = ae('<span class="badge badge-primary absolute right-3">NEW</span>'),
  Rk = ae('<form class="w-full" method="POST"><button class="btn w-full"><!> </button></form> <a class="btn w-full" target="_blank"><!> </a>', 1),
  Fk = ae('<div class="dropdown"><div tabindex="0" role="button"><!> <!></div> <div class="dropdown-content menu bg-base-100 rounded-box border-base-300 right-1 z-1 w-[min(100vw-24px,400px)] translate-y-2 border p-4 shadow-md" tabindex="-1"><button class="btn btn-ghost btn-circle absolute top-2 right-2"><!></button> <section class="flex gap-2"><div class="relative mr-4"><!> <button class="btn btn-circle btn-sm absolute -right-1 -bottom-1"><!></button></div> <div><div class="flex items-center gap-1.5 pr-8 text-lg"><!> <!> <!></div> <div class="flex items-center gap-1"><!> <span> <span class="text-primary font-semibold"> </span></span></div> <div class="flex items-center gap-1"><!> <span class="text-secondary"><span class="font-semibold"> </span> <button class="tooltip"><!></button></span></div></div></section> <div class="mt-2 flex items-center gap-1.5"><p class="text-base-content/70 text-sm">Badges:</p> <!></div> <section class="mt-3 flex flex-col gap-2"><!> <div class="mb-1 flex items-center justify-between"><h3 class="text-lg font-semibold"> </h3> <div class="flex items-center gap-2"><div class="dropdown dropdown-end"><div tabindex="0" role="button" class="btn btn-sm btn-circle tooltip"><!></div> <ul tabindex="0" class="dropdown-content menu bg-base-100 z-1 max-h-[50svh] w-max flex-nowrap overflow-y-auto rounded-xl p-2 shadow-sm"></ul></div> <div class="tooltip"><button class="btn btn-sm btn-circle"><!></button></div> <div class="tooltip"><button class="btn btn-sm btn-circle"><!></button></div> <!> <button class="btn btn-sm btn-circle tooltip relative before:-left-1/2"><!> <!></button></div></div>  <!> <!> <!> <!> <!> <button class="btn relative w-full"><!> Patch notes <!></button> <a class="btn w-full" href="http://discord.gg/wplacelive" target="_blank"><!> </a> <a class="btn w-full" href="https://www.reddit.com/r/WplaceLive/" target="_blank"><!> </a> <!> <button class="btn"><!> </button></section></div></div> <!> <!>', 1),
  Bk = ae('<div class="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4"><div class="bg-base-100 border-base-300 w-full max-w-3xl rounded-xl border shadow-lg"><div class="border-base-300 flex items-center justify-between border-b p-3"><h3 class="text-lg font-semibold">Patch notes</h3> <button class="btn btn-ghost btn-circle"><!></button></div> <div class="p-0"><iframe title="Patch notes" src="/patch-notes" class="markdown-body w-full rounded-xl p-5" style="height: min(70svh, 720px); border: 0;"></iframe></div></div></div>'),
  Ok = ae('<div class="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4"><div class="bg-base-100 border-base-300 w-full max-w-3xl rounded-xl border shadow-lg"><div class="border-base-300 flex items-center justify-between border-b p-3"><h3 class="text-lg font-semibold">Patch notes</h3> <button class="btn btn-ghost btn-circle"><!></button></div> <div class="p-0"><iframe title="Patch notes" src="/patch-notes" class="markdown-body w-full rounded-xl p-5" style="height: min(70svh, 720px); border: 0;"></iframe></div></div></div>'),
  jk = ae("<!> <!> <!>", 1);

function qk(y, l) {
  var Me;
  Gr(l, !0);
  const _ = "last_seen_patch_version";
  let x = Xe(!1),
    k = Xe(!1);

  function z() {
    var Ee;
    return ((Ee = L3.at(-1)) == null ? void 0 : Ee.version) ?? ""
  }
  let T = Xe(!1),
    s = Xe(!1),
    F = Xe(0),
    Z = Xe(!1),
    K = Xe(!0);

  function G() {
    var Ee;
    (Ee = document.activeElement) == null || Ee.blur()
  }
  const re = [{
    label: " English",
    key: "en"
  }, {
    label: " Portugus",
    key: "pt"
  }, ...(Me = l.user.data) != null && Me.role && l.user.data.role !== "user" ? [{
    label: " ",
    key: "ch"
  }, {
    label: " Deutsch",
    key: "de"
  }, {
    label: " Espaol",
    key: "es"
  }, {
    label: " Franais",
    key: "fr"
  }, {
    label: " Italiano",
    key: "it"
  }, {
    label: " ",
    key: "jp"
  }, {
    label: " Polski",
    key: "pl"
  }, {
    label: " ",
    key: "ru"
  }, {
    label: " ",
    key: "uk"
  }, {
    label: " Ting Vit",
    key: "vi"
  }] : []];
  let he = Xe(""),
    me = Xe(void 0);
  const q = Je(() => !!l.user.timeoutUntil);
  let ye = Xe("");
  Oa(async () => {
    if (l.user.data || await l.user.refresh(), l.user.hasAnyPermission(Ba.dashboard.summary)) {
      j(ye, `${xa.url.origin}/dashboard/summary`);
      return
    }
    if (l.user.hasAnyPermission(Ba.dashboard.team)) {
      j(ye, `${xa.url.origin}/dashboard/team`);
      return
    }
    if (l.user.hasAnyPermission(Ba.dashboard.users)) {
      j(ye, `${xa.url.origin}/dashboard/users`);
      return
    }
    if (l.user.hasAnyPermission(Ba.dashboard.permissions)) {
      j(ye, `${xa.url.origin}/dashboard/permissions`);
      return
    }
    if (l.user.hasAnyPermission(Ba.dashboard.alliances)) {
      j(ye, `${xa.url.origin}/dashboard/alliances`);
      return
    }
    if (l.user.hasAnyPermission(Ba.dashboard.auditLogs)) {
      j(ye, `${xa.url.origin}/dashboard/audit-logs`);
      return
    }
    if (l.user.hasAnyPermission(Ba.dashboard.banWaves)) {
      j(ye, `${xa.url.origin}/dashboard/ban-waves`);
      return
    }
    be()
  });

  function be() {
    const Ee = z(),
      Qe = localStorage.getItem(_) ?? "";
    j(k, !!Ee && Qe !== Ee, !0)
  }

  function qe() {
    const Ee = z();
    Ee && localStorage.setItem(_, Ee), j(k, !1)
  }
  var xe = jk(),
    Ye = zt(xe);
  {
    var We = Ee => {
      var Qe = Fk(),
        Ue = zt(Qe),
        je = P(Ue);
      let rt;
      var _t = P(je);
      vb(_t, {
        get userId() {
          return l.user.data.id
        },
        get level() {
          return l.user.data.level
        },
        get pictureUrl() {
          return l.user.data.picture
        }
      });
      var dt = E(_t, 2);
      {
        var at = Pt => {
          s0(Pt, {
            class: "absolute -top-0.5 -right-0.5",
            get count() {
              return l.user.notificiationCount
            }
          })
        };
        Te(dt, Pt => {
          l.user.notificiationCount && Pt(at)
        })
      }
      S(je);
      var nt = E(je, 2),
        ot = P(nt);
      ot.__click = G;
      var ut = P(ot);
      ss(ut, {
        class: "size-5"
      }), S(ot);
      var st = E(ot, 2),
        wt = P(st),
        Ct = P(wt);
      bn(Ct, {
        get userId() {
          return l.user.data.id
        },
        get pictureUrl() {
          return l.user.data.picture
        },
        get isSuspended() {
          return h(q)
        },
        get borderUrl() {
          return l.user.data.equippedFrameUrl
        }
      });
      var rr = E(Ct, 2);
      rr.__click = () => {
        j(T, !0)
      };
      var Zt = P(rr);
      mm(Zt, {
        class: "size-4"
      }), S(rr), S(wt);
      var lt = E(wt, 2),
        ht = P(lt),
        Dt = P(ht);
      Bh(Dt, {
        get name() {
          return l.user.data.name
        },
        get id() {
          return l.user.data.id
        },
        get equippedNameCosmetic() {
          return l.user.data.equippedNameCosmetic
        },
        class: "line-clamp-1 text-lg"
      });
      var Vt = E(Dt, 2);
      {
        var Jt = Pt => {
          const tr = Je(() => Ds(l.user.data.equippedFlag));
          var Br = yk(),
            Zr = P(Br, !0);
          S(Br), ke(() => {
            Xt(Br, "data-tip", h(tr).name), ee(Zr, h(tr).flag)
          }), B(Pt, Br)
        };
        Te(Vt, Pt => {
          l.user.data.equippedFlag && Pt(Jt)
        })
      }
      var jt = E(Vt, 2);
      {
        var nr = Pt => {
          var tr = xk(),
            Br = P(tr);
          Fh(Br, {
            get username() {
              return l.user.data.discord
            },
            get id() {
              return l.user.data.discordId
            }
          }), S(tr), B(Pt, tr)
        };
        Te(jt, Pt => {
          l.user.data.discord && Pt(nr)
        })
      }
      S(ht);
      var St = E(ht, 2),
        Et = P(St);
      Vo(Et, {
        class: "inline size-4"
      });
      var Ut = E(Et, 2),
        Gt = P(Ut),
        Rt = E(Gt),
        ir = P(Rt, !0);
      S(Rt), S(Ut), S(St);
      var kr = E(St, 2),
        _r = P(kr);
      ho(_r, {
        class: "inline size-4"
      });
      var fr = E(_r, 2),
        Yt = P(fr),
        sr = P(Yt);
      S(Yt);
      var Kt = E(Yt),
        vr = E(Kt),
        Lr = P(vr);
      th(Lr, {
        class: "mb-0.5 inline size-4 opacity-50"
      }), S(vr), S(fr), S(kr), S(lt), S(st);
      var ii = E(st, 2),
        mr = E(P(ii), 2);
      Hi(mr, 16, () => [0, 1, 2], po, (Pt, tr) => {
        const Br = Je(() => {
          var kt;
          return (kt = l.user.data.equippedBadges) == null ? void 0 : kt[tr]
        });
        var Zr = br(),
          ci = zt(Zr);
        {
          var ui = kt => {
              var dr = bk();
              dr.__click = () => {
                j(F, tr, !0), j(s, !0)
              };
              var pi = P(dr);
              S(dr), ke(() => {
                Xt(dr, "data-tip", h(Br).name), Xt(pi, "src", h(Br).imageUrl), Xt(pi, "alt", h(Br).name)
              }), B(kt, dr)
            },
            pt = kt => {
              var dr = wk();
              dr.__click = () => {
                j(F, tr, !0), j(s, !0)
              }, B(kt, dr)
            };
          Te(ci, kt => {
            h(Br) ? kt(ui) : kt(pt, !1)
          })
        }
        B(Pt, Zr)
      }), S(ii);
      var ge = E(ii, 2),
        V = P(ge);
      {
        var U = Pt => {
          var tr = Pk(),
            Br = P(tr);
          Zm(Br, {
            class: "size-6 text-red-500"
          });
          var Zr = E(Br, 2);
          {
            var ci = pi => {
                var vi = Tk(),
                  Ji = P(vi),
                  Zi = E(Ji);
                {
                  var Ei = Ir => {
                      var wr = ja();
                      ke(Ai => ee(wr, `(${Ai??""})`), [() => Pv({
                        reason: sb()
                      })]), B(Ir, wr)
                    },
                    ca = Ir => {
                      var wr = br(),
                        Ai = zt(wr);
                      {
                        var gi = Cr => {
                          var _i = ja();
                          ke(Ar => ee(_i, `(${Ar??""})`), [() => Pv({
                            reason: lb()
                          })]), B(Cr, _i)
                        };
                        Te(Ai, Cr => {
                          l.user.data.suspensionReason === "multi-accounting" && Cr(gi)
                        }, !0)
                      }
                      B(Ir, wr)
                    };
                  Te(Zi, Ir => {
                    l.user.data.suspensionReason === "bot" ? Ir(Ei) : Ir(ca, !1)
                  })
                }
                S(vi), ke(Ir => ee(Ji, `${Ir??""} `), [() => e5()]), B(pi, vi)
              },
              ui = pi => {
                var vi = br(),
                  Ji = zt(vi);
                {
                  var Zi = Ei => {
                    var ca = Sk(),
                      Ir = P(ca);
                    Fp(Ir, () => ob({
                      until: `<span class="text-secondary font-medium text-nowrap">${l.user.timeoutUntil.toLocaleString(navigator.language)}</span>`
                    })), S(ca), B(Ei, ca)
                  };
                  Te(Ji, Ei => {
                    l.user.timeoutUntil && Ei(Zi)
                  }, !0)
                }
                B(pi, vi)
              };
            Te(Zr, pi => {
              l.user.data.timeoutUntil && new Date(l.user.data.timeoutUntil).getTime() >= Date.now() + 31536e6 ? pi(ci) : pi(ui, !1)
            })
          }
          var pt = E(Zr, 2);
          pt.__click = pi => {
            var vi;
            (vi = l.onbanappeal) == null || vi.call(l)
          };
          var kt = P(pt);
          Zm(kt, {
            class: "size-5 text-red-500"
          });
          var dr = E(kt, 1, !0);
          S(pt), S(tr), ke(pi => ee(dr, pi), [() => Hw()]), B(Pt, tr)
        };
        Te(V, Pt => {
          h(q) && Pt(U)
        })
      }
      var J = E(V, 2),
        se = P(J),
        te = P(se, !0);
      S(se);
      var _e = E(se, 2),
        Re = P(_e),
        ne = P(Re),
        oe = P(ne);
      YA(oe, {
        class: "size-4"
      }), S(ne);
      var fe = E(ne, 2);
      Hi(fe, 21, () => re, po, (Pt, tr) => {
        const Br = Je(() => h(he) === h(tr).key),
          Zr = Je(() => P3() === h(tr).key);
        var ci = Mk(),
          ui = P(ci);
        let pt;
        ui.__click = () => {
          localStorage.setItem(xb, h(tr).key), j(he, h(tr).key, !0), location.reload()
        };
        var kt = P(ui);
        {
          var dr = vi => {
            var Ji = Ik();
            B(vi, Ji)
          };
          Te(kt, vi => {
            h(Br) && vi(dr)
          })
        }
        var pi = E(kt);
        S(ui), S(ci), ke(() => {
          pt = Er(ui, 1, "font-flag relative font-medium", null, pt, {
            "bg-base-200": h(Br),
            "bg-base-300": h(Zr)
          }), ee(pi, ` ${h(tr).label??""}`)
        }), B(Pt, ci)
      }), S(fe), S(Re);
      var ve = E(Re, 2),
        ie = P(ve);
      ie.__click = () => {
        vn.muted = !vn.muted
      };
      var Y = P(ie);
      {
        var Fe = Pt => {
            ek(Pt, {
              class: "size-4"
            })
          },
          Ne = Pt => {
            rk(Pt, {
              class: "size-4"
            })
          };
        Te(Y, Pt => {
          vn.muted ? Pt(Fe) : Pt(Ne, !1)
        })
      }
      S(ie), S(ve);
      var Ge = E(ve, 2),
        pe = P(Ge);
      pe.__click = () => {
        vn.theme = vn.theme === "dark" ? "custom-winter" : "dark"
      };
      var Ve = P(pe);
      {
        var it = Pt => {
            jA(Pt, {
              class: "size-4"
            })
          },
          yt = Pt => {
            BA(Pt, {
              class: "size-4"
            })
          };
        Te(Ve, Pt => {
          vn.theme === "dark" ? Pt(it) : Pt(yt, !1)
        })
      }
      S(pe), S(Ge);
      var Lt = E(Ge, 2);
      {
        var ct = Pt => {
          var tr = Ck();
          tr.__click = () => {
            var ui;
            j(K, !h(K)), (ui = l.ontogglepixelarts) == null || ui.call(l, h(K))
          };
          var Br = P(tr);
          {
            var Zr = ui => {
                JA(ui, {
                  class: "size-4"
                })
              },
              ci = ui => {
                Ry(ui, {
                  class: "size-4"
                })
              };
            Te(Br, ui => {
              h(K) ? ui(ci, !1) : ui(Zr)
            })
          }
          S(tr), ke(ui => Xt(tr, "data-tip", ui), [() => h(K) == !1 ? Xw() : Yw()]), B(Pt, tr)
        };
        Te(Lt, Pt => {
          l.user.hasPermission(Ba.ui.tooglePixelArt) && Pt(ct)
        })
      }
      var At = E(Lt, 2);
      At.__click = function(...Pt) {
        var tr;
        (tr = l.onnotificationclick) == null || tr.apply(this, Pt)
      };
      var qt = P(At);
      VA(qt, {
        class: "size-4"
      });
      var Ke = E(qt, 2);
      {
        var Tt = Pt => {
          s0(Pt, {
            class: "absolute -top-1 -right-1",
            get count() {
              return l.user.notificiationCount
            }
          })
        };
        Te(Ke, Pt => {
          l.user.notificiationCount && Pt(Tt)
        })
      }
      S(At), S(_e), S(J);
      var Wt = E(J, 2);
      {
        var Fr = Pt => {
          var tr = Ak();
          tr.__click = async () => {
            var ci;
            try {
              const ui = await ((ci = h(me)) == null ? void 0 : ci.prompt());
              (ui == null ? void 0 : ui.outcome) === "accepted" && j(me, void 0)
            } catch (ui) {
              Bt.error(Kw({
                error: ui.message
              }))
            }
          };
          var Br = P(tr);
          lg(Br, {
            class: "size-5"
          });
          var Zr = E(Br);
          S(tr), ke(ci => ee(Zr, ` ${ci??""}`), [() => Jw()]), B(Pt, tr)
        };
        Te(Wt, Pt => {
          h(me) && Pt(Fr)
        })
      }
      var or = E(Wt, 2);
      {
        var tt = Pt => {
          var tr = kk(),
            Br = P(tr);
          sp(Br, {
            class: "size-5"
          });
          var Zr = E(Br);
          S(tr), ke(ci => {
            Xt(tr, "href", h(ye)), ee(Zr, ` ${ci??""}`)
          }, [() => z3()]), B(Pt, tr)
        };
        Te(or, Pt => {
          l.user.hasAnyPermission(Ba.dashboard) && Pt(tt)
        })
      }
      var Ht = E(or, 2);
      {
        var Qt = Pt => {
          var tr = zk(),
            Br = P(tr);
          sp(Br, {
            class: "size-5"
          });
          var Zr = E(Br);
          S(tr), ke(ci => {
            Xt(tr, "href", `${xa.url.origin??""}/tickets`), ee(Zr, ` ${ci??""}`)
          }, [() => $w()]), B(Pt, tr)
        };
        Te(Ht, Pt => {
          l.user.hasAnyPermission(Ba.tickets) && Pt(Qt)
        })
      }
      var Sr = E(Ht, 2);
      {
        var ei = Pt => {
          var tr = Ek(),
            Br = P(tr);
          sp(Br, {
            class: "size-5"
          });
          var Zr = E(Br);
          S(tr), ke(ci => {
            Xt(tr, "href", `${xa.url.origin??""}/appeals`), ee(Zr, ` ${ci??""}`)
          }, [() => k3()]), B(Pt, tr)
        };
        Te(Sr, Pt => {
          l.user.hasAnyPermission(Ba.appeals) && Pt(ei)
        })
      }
      var li = E(Sr, 2);
      {
        var Dr = Pt => {
          var tr = Lk(),
            Br = P(tr);
          sp(Br, {
            class: "size-5"
          });
          var Zr = E(Br);
          S(tr), ke(ci => {
            Xt(tr, "href", `${xa.url.origin??""}/wayback`), ee(Zr, ` ${ci??""}`)
          }, [() => Qw()]), B(Pt, tr)
        };
        Te(li, Pt => {
          l.user.hasAnyPermission(Ba.tools.wayback) && Pt(Dr)
        })
      }
      var Oi = E(li, 2);
      Oi.__click = () => {
        j(x, !0)
      };
      var Jr = P(Oi);
      l0(Jr, {
        class: "size-5"
      });
      var It = E(Jr, 2);
      {
        var er = Pt => {
          var tr = Dk();
          B(Pt, tr)
        };
        Te(It, Pt => {
          h(k) && Pt(er)
        })
      }
      S(Oi);
      var Pr = E(Oi, 2),
        pr = P(Pr);
      xm(pr, {
        class: "size-5"
      });
      var qr = E(pr);
      S(Pr);
      var ur = E(Pr, 2),
        Mr = P(ur);
      GA(Mr, {
        class: "size-5"
      });
      var di = E(Mr);
      S(ur);
      var ti = E(ur, 2);
      {
        var Vr = Pt => {
          var tr = Rk(),
            Br = zt(tr),
            Zr = P(Br),
            ci = P(Zr);
          l0(ci, {
            class: "size-5"
          });
          var ui = E(ci);
          S(Zr), S(Br);
          var pt = E(Br, 2),
            kt = P(pt);
          th(kt, {
            class: "size-5"
          });
          var dr = E(kt);
          S(pt), ke((pi, vi, Ji) => {
            Xt(Br, "action", `${rb}/payment/create-portal-session`), ee(ui, ` ${pi??""}`), Xt(pt, "href", vi), ee(dr, ` ${Ji??""}`)
          }, [() => v3(), F0, () => b0()]), B(Pt, tr)
        };
        Te(ti, Pt => {
          var tr;
          (tr = l.user.data) != null && tr.isCustomer && Pt(Vr)
        })
      }
      var Rr = E(ti, 2);
      Rr.__click = async () => {
        var Pt;
        try {
          j(Z, !0), await l.user.logout(), G(), Bt.warning(Bw(), {
            icon: o0
          }), (Pt = l.onlogout) == null || Pt.call(l)
        } catch {
          Bt.error(Ow())
        } finally {
          j(Z, !1)
        }
      };
      var ni = P(Rr);
      o0(ni, {
        class: "size-5"
      });
      var Ri = E(ni);
      S(Rr), S(ge), S(nt), S(Ue);
      var qi = E(Ue, 2);
      RA(qi, {
        get userData() {
          return l.user.data
        },
        get open() {
          return h(T)
        },
        set open(Pt) {
          j(T, Pt, !0)
        }
      });
      var ai = E(qi, 2);
      vk(ai, {
        get slotIndex() {
          return h(F)
        },
        get open() {
          return h(s)
        },
        set open(Pt) {
          j(s, Pt, !0)
        }
      }), ke((Pt, tr, Br, Zr, ci, ui, pt, kt, dr, pi, vi, Ji, Zi, Ei) => {
        rt = Er(je, 1, "btn relative size-12 p-0 shadow-md", null, rt, {
          "bg-red-500": h(q)
        }), Xt(je, "title", Pt), ee(Gt, `${tr??""}: `), ee(ir, Br), ee(sr, `Level ${Zr??""}`), ee(Kt, ` (${ci??""}%) `), Xt(vr, "data-tip", ui), ee(te, pt), Xt(ne, "data-tip", kt), Xt(ve, "data-tip", dr), Xt(Ge, "data-tip", pi), Xt(At, "data-tip", vi), ee(qr, ` ${Ji??""}`), ee(di, ` ${Zi??""}`), Rr.disabled = h(Z), ee(Ri, ` ${Ei??""}`)
      }, [() => jw(), () => Qm(), () => l.user.data.pixelsPainted.toLocaleString(navigator.language), () => Math.floor(l.user.data.level), () => Math.floor(l.user.data.level % 1 * 100), () => qw(), () => Nw(), () => Vw(), () => vn.muted ? Uw() : Zw(), () => vn.theme === "dark" ? Gw() : Ww(), () => T0(), () => g3(), () => E3(), () => _3()]), Ci("focus", je, () => {
        j(me, window.pwaInstallPrompt, !0)
      }), B(Ee, Qe)
    };
    Te(Ye, Ee => {
      l.user.data && l.user.charges !== void 0 && Ee(We)
    })
  }
  var ze = E(Ye, 2);
  {
    var Se = Ee => {
      var Qe = Bk(),
        Ue = P(Qe),
        je = P(Ue),
        rt = E(P(je), 2);
      rt.__click = () => {
        j(x, !1), qe()
      };
      var _t = P(rt);
      ss(_t, {
        class: "size-5"
      }), S(rt), S(je), wi(2), S(Ue), S(Qe), B(Ee, Qe)
    };
    Te(ze, Ee => {
      h(x) && Ee(Se)
    })
  }
  var Pe = E(ze, 2);
  {
    var Ae = Ee => {
      var Qe = Ok(),
        Ue = P(Qe),
        je = P(Ue),
        rt = E(P(je), 2);
      rt.__click = () => {
        j(x, !1), qe()
      };
      var _t = P(rt);
      ss(_t, {
        class: "size-5"
      }), S(rt), S(je), wi(2), S(Ue), S(Qe), B(Ee, Qe)
    };
    Te(Pe, Ee => {
      h(x) && Ee(Ae)
    })
  }
  B(y, xe), Wr()
}
Ui(["click"]);
var Nk = ae('<label class="tab grow font-semibold max-sm:h-10"><input type="radio" class="tab grow"/> <!> </label>'),
  Vk = ae('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  Uk = ae('<span class="font-flag tooltip ml-0.5"> </span>'),
  Zk = ae("<span> </span>"),
  Gk = ae('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="max-sm:px-1"><div class="flex items-center gap-2"><!> <div class="items-center gap-2 sm:flex"><!> <!> <!> <!></div></div></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  Wk = ae('<table class="table"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  Hk = ae('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="h-14 max-sm:px-1"><span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  Xk = ae('<table class="table"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  Yk = ae('<div class="h-screen pt-20"><div class="flex justify-center"><span class="loading loading-spinner"></span></div></div>'),
  Kk = ae('<div class="tabs tabs-box"></div> <div class="my-4 flex items-center justify-between"><!></div> <!>', 1);

function Jk(y, l) {
  Gr(l, !0);
  const _ = [];
  let x = Xe("today"),
    k = {
      players: {
        label: w0(),
        icon: Vp
      },
      alliances: {
        label: B0(),
        icon: Up
      }
    },
    z = Xe("players"),
    T = Wi({
      players: {},
      alliances: {}
    });
  const s = Je(() => T[h(z)][h(x)]);
  Qr(() => {
    if (h(s)) return;
    const q = h(x),
      ye = h(z);
    ye === "players" ? Kr.leaderboardRegionPlayers(l.regionId, q).then(be => {
      T[ye][q] = be
    }).catch(be => {
      Bt.error(be.message)
    }) : ye === "alliances" && Kr.leaderboardRegionAlliances(l.regionId, q).then(be => {
      T[ye][q] = be
    }).catch(be => {
      Bt.error(be.message)
    })
  });
  var F = Kk(),
    Z = zt(F);
  Hi(Z, 21, () => Object.entries(k), ([q, {
    label: ye,
    icon: be
  }]) => q, (q, ye) => {
    var be = Je(() => h0(h(ye), 2));
    let qe = () => h(be)[0],
      xe = () => h(be)[1].label,
      Ye = () => h(be)[1].icon;
    const We = Je(Ye);
    var ze = Nk(),
      Se = P(ze);
    Ka(Se);
    var Pe, Ae = E(Se, 2);
    yn(Ae, () => h(We), (Ee, Qe) => {
      Qe(Ee, {
        get this() {
          return Ye()
        },
        class: "mr-1 size-5 max-sm:hidden"
      })
    });
    var Me = E(Ae);
    S(ze), ke(() => {
      Xt(Se, "aria-label", xe()), Pe !== (Pe = qe()) && (Se.value = (Se.__value = qe()) ?? ""), ee(Me, ` ${xe()??""}`)
    }), Jm(_, [], Se, () => (qe(), h(z)), Ee => j(z, Ee)), B(q, ze)
  }), S(Z);
  var K = E(Z, 2),
    G = P(K);
  _g(G, {
    get value() {
      return h(x)
    },
    set value(q) {
      j(x, q, !0)
    }
  }), S(K);
  var re = E(K, 2);
  {
    var he = q => {
        var ye = Vk(),
          be = P(ye),
          qe = E(be);
        {
          var xe = We => {
              var ze = ja();
              ke(Se => ee(ze, Se), [() => Bp().toLowerCase()]), B(We, ze)
            },
            Ye = We => {
              var ze = br(),
                Se = zt(ze);
              {
                var Pe = Me => {
                    var Ee = ja();
                    ke(Qe => ee(Ee, Qe), [() => rg()]), B(Me, Ee)
                  },
                  Ae = Me => {
                    var Ee = br(),
                      Qe = zt(Ee);
                    {
                      var Ue = je => {
                        var rt = ja();
                        ke(_t => ee(rt, _t), [() => ig()]), B(je, rt)
                      };
                      Te(Qe, je => {
                        h(x) === "month" && je(Ue)
                      }, !0)
                    }
                    B(Me, Ee)
                  };
                Te(Se, Me => {
                  h(x) === "week" ? Me(Pe) : Me(Ae, !1)
                }, !0)
              }
              B(We, ze)
            };
          Te(qe, We => {
            h(x) === "today" ? We(xe) : We(Ye, !1)
          })
        }
        S(ye), ke(We => ee(be, `${We??""} `), [() => tg()]), B(q, ye)
      },
      me = q => {
        var ye = br(),
          be = zt(ye);
        {
          var qe = Ye => {
              var We = br(),
                ze = zt(We);
              {
                var Se = Ae => {
                    const Me = Je(() => h(s));
                    var Ee = Wk(),
                      Qe = P(Ee),
                      Ue = P(Qe),
                      je = E(P(Ue)),
                      rt = P(je, !0);
                    S(je);
                    var _t = E(je),
                      dt = P(_t),
                      at = E(dt, 2, !0);
                    S(_t), S(Ue), S(Qe);
                    var nt = E(Qe);
                    Hi(nt, 31, () => h(Me), ot => ot.id, (ot, ut, st) => {
                      const wt = Je(() => {
                        var _r;
                        return ((_r = bt.data) == null ? void 0 : _r.id) === h(ut).id
                      });
                      var Ct = Gk();
                      let rr;
                      var Zt = P(Ct),
                        lt = P(Zt, !0);
                      S(Zt);
                      var ht = E(Zt),
                        Dt = P(ht),
                        Vt = P(Dt);
                      bn(Vt, {
                        class: "size-10 border",
                        get userId() {
                          return h(ut).id
                        },
                        get pictureUrl() {
                          return h(ut).picture
                        },
                        get borderUrl() {
                          return h(ut).frameUrl
                        }
                      });
                      var Jt = E(Vt, 2),
                        jt = P(Jt);
                      {
                        let _r = Je(() => {
                            var Yt;
                            return h(wt) ? ((Yt = bt.data) == null ? void 0 : Yt.name) ?? h(ut).name : h(ut).name
                          }),
                          fr = Je(() => {
                            var Yt;
                            return h(wt) ? (Yt = bt.data) == null ? void 0 : Yt.equippedNameCosmetic : h(ut).equippedNameCosmetic
                          });
                        Bh(jt, {
                          get name() {
                            return h(_r)
                          },
                          get id() {
                            return h(ut).id
                          },
                          get equippedNameCosmetic() {
                            return h(fr)
                          },
                          class: "max-sm:ml-2"
                        })
                      }
                      var nr = E(jt, 2);
                      {
                        var St = _r => {
                          const fr = Je(() => Ds(h(ut).equippedFlag));
                          var Yt = Uk(),
                            sr = P(Yt, !0);
                          S(Yt), ke(() => {
                            Xt(Yt, "data-tip", h(fr).name), ee(sr, h(fr).flag)
                          }), B(_r, Yt)
                        };
                        Te(nr, _r => {
                          "equippedFlag" in h(ut) && h(ut).equippedFlag && _r(St)
                        })
                      }
                      var Et = E(nr, 2);
                      {
                        var Ut = _r => {
                          Fh(_r, {
                            get username() {
                              return h(ut).discord
                            },
                            get id() {
                              return h(ut).discordId
                            }
                          })
                        };
                        Te(Et, _r => {
                          h(ut).discord && _r(Ut)
                        })
                      }
                      var Gt = E(Et, 2);
                      {
                        var Rt = _r => {
                          var fr = Zk(),
                            Yt = P(fr, !0);
                          S(fr), ke((sr, Kt) => {
                            Er(fr, 1, `badge badge-sm ml-0.5 border-0 ${sr??""} ${Kt??""}`), ee(Yt, h(ut).allianceName)
                          }, [() => Rp(h(ut).allianceId), () => Dn(h(ut).allianceId)]), B(_r, fr)
                        };
                        Te(Gt, _r => {
                          "allianceName" in h(ut) && h(ut).allianceName && _r(Rt)
                        })
                      }
                      S(Jt), S(Dt), S(ht);
                      var ir = E(ht),
                        kr = P(ir, !0);
                      S(ir), S(Ct), ke(_r => {
                        rr = Er(Ct, 1, "", null, rr, {
                          "bg-base-200": h(wt)
                        }), ee(lt, h(st) + 1), ee(kr, _r)
                      }, [() => h(ut).pixelsPainted.toLocaleString(navigator.language)]), vl(Ct, () => yl, () => ({
                        duration: 200
                      })), B(ot, Ct)
                    }), S(nt), S(Ee), ke((ot, ut, st) => {
                      ee(rt, ot), ee(dt, `${ut??""} `), ee(at, st)
                    }, [() => ng(), () => Cc(), () => Ac().toLowerCase()]), B(Ae, Ee)
                  },
                  Pe = Ae => {
                    var Me = br(),
                      Ee = zt(Me);
                    {
                      var Qe = Ue => {
                        var je = Xk(),
                          rt = P(je),
                          _t = P(rt),
                          dt = E(P(_t)),
                          at = P(dt, !0);
                        S(dt);
                        var nt = E(dt),
                          ot = P(nt),
                          ut = E(ot, 2, !0);
                        S(nt), S(_t), S(rt);
                        var st = E(rt);
                        Hi(st, 31, () => h(s), wt => wt.id, (wt, Ct, rr) => {
                          const Zt = Je(() => {
                            var Ut;
                            return ((Ut = bt.data) == null ? void 0 : Ut.allianceId) === h(Ct).id
                          });
                          var lt = Hk();
                          let ht;
                          var Dt = P(lt),
                            Vt = P(Dt, !0);
                          S(Dt);
                          var Jt = E(Dt),
                            jt = P(Jt),
                            nr = P(jt, !0);
                          S(jt), S(Jt);
                          var St = E(Jt),
                            Et = P(St, !0);
                          S(St), S(lt), ke((Ut, Gt) => {
                            ht = Er(lt, 1, "", null, ht, {
                              "bg-base-200": h(Zt)
                            }), ee(Vt, h(rr) + 1), Er(jt, 1, `font-semibold ${Ut??""}`), ee(nr, h(Ct).name), ee(Et, Gt)
                          }, [() => Dn(h(Ct).id), () => h(Ct).pixelsPainted.toLocaleString(navigator.language)]), vl(lt, () => yl, () => ({
                            duration: 200
                          })), B(wt, lt)
                        }), S(st), S(je), ke((wt, Ct, rr) => {
                          ee(at, wt), ee(ot, `${Ct??""} `), ee(ut, rr)
                        }, [() => Np(), () => Cc(), () => Ac().toLowerCase()]), B(Ue, je)
                      };
                      Te(Ee, Ue => {
                        h(z) === "alliances" && Ue(Qe)
                      }, !0)
                    }
                    B(Ae, Me)
                  };
                Te(ze, Ae => {
                  h(z) === "players" ? Ae(Se) : Ae(Pe, !1)
                })
              }
              B(Ye, We)
            },
            xe = Ye => {
              var We = Yk();
              B(Ye, We)
            };
          Te(be, Ye => {
            h(s) ? Ye(qe) : Ye(xe, !1)
          }, !0)
        }
        B(q, ye)
      };
    Te(re, q => {
      h(s) && h(s).length === 0 ? q(he) : q(me, !1)
    })
  }
  B(y, F), Wr()
}
var $k = ae('<div class="mt-5"><!></div>'),
  Qk = ae('<dialog class="modal" closedby="any"><div class="modal-box h-11/12 max-w-3xl"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2"></button></form> <h2><span class="font-flag tooltip"> </span> <span> </span> <span> </span></h2> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function e8(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "open", 15);
  const x = Je(() => Ds(l.region.countryId));
  var k = Qk(),
    z = P(k),
    T = E(P(z), 2),
    s = P(T),
    F = P(s, !0);
  S(s);
  var Z = E(s, 2),
    K = P(Z, !0);
  S(Z);
  var G = E(Z, 2),
    re = P(G);
  S(G), S(T);
  var he = E(T, 2);
  {
    var me = q => {
      var ye = $k(),
        be = P(ye);
      Jk(be, {
        get regionId() {
          return l.region.id
        }
      }), S(ye), dn(2, ye, () => Jn, () => ({
        duration: 300
      })), B(q, ye)
    };
    Te(he, q => {
      _() && q(me)
    })
  }
  S(z), wi(2), S(k), qa(k, () => q => {
    Qr(() => {
      _() ? q.show() : q.close()
    })
  }), ke(q => {
    Er(T, 1, `flex gap-2 text-xl font-bold sm:text-2xl ${q??""}`), Xt(s, "data-tip", h(x).name), ee(F, h(x).flag), ee(K, l.region.name), ee(re, `#${l.region.number??""}`)
  }, [() => Dn(l.region.cityId)]), Ci("close", k, () => _(!1)), B(y, k), Wr()
}

function t8(y) {
  switch (y) {
    case "en":
    case "pt":
    case "es":
    case "fr":
    case "de":
    case "it":
    case "pl":
    case "ru":
    case "uk":
    case "vi":
      return y;
    case "jp":
      return "ja";
    case "ch":
      return "zh";
    default:
      return ""
  }
}
async function r8(y) {
  const l = t8(bb());
  let _ = `https://geocoding.wplace.live/v1/autocomplete?text=${encodeURIComponent(y)}${l!=="en"?`&lang=${l}`:""}`;
  const x = await fetch(_);
  if (!x.ok) {
    const k = await x.text();
    throw console.error(`Geocoding API error: ${k}`), new Error(cb())
  }
  return x.json()
}
var i8 = ae('<div class="text-base-content/80 absolute right-3 top-1/2 z-10 -translate-y-1/2 sm:right-6"><button class="btn btn-ghost btn-sm btn-circle hidden group-hover:flex"><!></button></div>'),
  a8 = ae('<div class="group relative"><button class="hover:bg-base-200 active:bg-base-200 flex w-full gap-3 px-3 py-2 sm:px-6"><!> <div class="sm:pr-8"><h3 class="text-left font-semibold"> </h3> <div class="text-base-content/80 text-left text-sm"> </div></div></button> <!></div>');

function lm(y, l) {
  Gr(l, !0);
  const _ = (s, F) => {
    let Z = () => F == null ? void 0 : F().name,
      K = () => F == null ? void 0 : F().label,
      G = () => F == null ? void 0 : F().onclick;
    var re = a8(),
      he = P(re);
    he.__click = function(...ze) {
      var Se;
      (Se = G()) == null || Se.apply(this, ze)
    };
    var me = P(he);
    qp(me, {
      class: "text-base-content/80 mt-0.5 size-6 min-w-6"
    });
    var q = E(me, 2),
      ye = P(q),
      be = P(ye, !0);
    S(ye);
    var qe = E(ye, 2),
      xe = P(qe, !0);
    S(qe), S(q), S(he);
    var Ye = E(he, 2);
    {
      var We = ze => {
        var Se = i8(),
          Pe = P(Se);
        Pe.__click = function(...Me) {
          var Ee;
          (Ee = l.onremove) == null || Ee.apply(this, Me)
        };
        var Ae = P(Pe);
        ss(Ae, {
          class: "size-4"
        }), S(Pe), S(Se), B(ze, Se)
      };
      Te(Ye, ze => {
        l.onremove && ze(We)
      })
    }
    S(re), ke(() => {
      ee(be, Z()), ee(xe, K())
    }), B(s, re)
  };
  var x = br(),
    k = zt(x);
  {
    var z = s => {
        _(s, () => ({
          name: l.location.name,
          label: l.location.label,
          onclick: l.onclick
        }))
      },
      T = s => {
        var F = br(),
          Z = zt(F);
        {
          var K = re => {
              {
                let he = Je(() => ({
                  name: l.location.name,
                  label: ag(),
                  onclick: l.onclick
                }));
                _(re, () => h(he))
              }
            },
            G = re => {
              var he = br(),
                me = zt(he);
              {
                var q = ye => {
                  {
                    let be = Je(() => ({
                      name: `${l.location.pos.lat.toFixed(4)}, ${l.location.pos.lng.toFixed(4)}`,
                      label: x0(),
                      onclick: l.onclick
                    }));
                    _(ye, () => h(be))
                  }
                };
                Te(me, ye => {
                  l.location.type === "coordinates" && ye(q)
                }, !0)
              }
              B(re, he)
            };
          Te(Z, re => {
            l.location.type === "country" ? re(K) : re(G, !1)
          }, !0)
        }
        B(s, F)
      };
    Te(k, s => {
      l.location.type === "place" ? s(z) : s(T, !1)
    })
  }
  B(y, x), Wr()
}
Ui(["click"]);
var n8 = Yr('<svg><path d="m336-280 144-144 144 144 56-56-144-144 144-144-56-56-144 144-144-144-56 56 144 144-144 144 56 56ZM480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"></path></svg>');

function s8(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = n8();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var o8 = Yr('<svg><path d="M300-240q25 0 42.5-17.5T360-300q0-25-17.5-42.5T300-360q-25 0-42.5 17.5T240-300q0 25 17.5 42.5T300-240Zm0-360q25 0 42.5-17.5T360-660q0-25-17.5-42.5T300-720q-25 0-42.5 17.5T240-660q0 25 17.5 42.5T300-600Zm180 180q25 0 42.5-17.5T540-480q0-25-17.5-42.5T480-540q-25 0-42.5 17.5T420-480q0 25 17.5 42.5T480-420Zm180 180q25 0 42.5-17.5T720-300q0-25-17.5-42.5T660-360q-25 0-42.5 17.5T600-300q0 25 17.5 42.5T660-240Zm0-360q25 0 42.5-17.5T720-660q0-25-17.5-42.5T660-720q-25 0-42.5 17.5T600-660q0 25 17.5 42.5T660-600ZM200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm0-560v560-560Z"></path></svg>');

function l8(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = o8();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var c8 = ae('<button type="button" class="absolute right-1 top-1/2 z-10 -translate-y-1/2 rounded-full p-2"><!></button>'),
  u8 = ae('<p class="text-base-content/80 pt-4 text-center text-sm"> </p>'),
  h8 = ae("<!> <!>", 1),
  d8 = ae('<p class="text-base-content/80 pt-6 text-center text-sm"> </p>'),
  p8 = ae('<div class="mb-2 flex items-center justify-between px-4 sm:px-7"><h3 class="text-sm font-semibold"> </h3> <button class="btn btn-sm btn-ghost btn-circle tooltip tooltip-bottom before:-translate-x-1/3"><!></button></div> <!> <!>', 1),
  f8 = ae('<dialog class="modal duration-0"><div class="modal-box sm:max-h-11/12 sm:h-11/12 flex flex-col p-0 max-sm:h-full max-sm:w-full max-sm:max-w-full max-sm:rounded-none"><section class="px-3 pt-3 sm:px-6 sm:pt-6"><form class="relative h-max"><input class="input placeholder:text-base-content/80 input-no-cancel-button w-full pl-10 pr-9" type="search"/> <button type="button" class="absolute left-1 top-1/2 z-10 -translate-y-1/2 rounded-full p-2"><!></button> <!></form></section> <section class="grow overflow-y-auto overflow-x-hidden pb-3 pt-4 sm:pb-6"><!></section></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function m8(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "open", 15),
    x = Xe(""),
    k = Xe(!1),
    z = Xe(!1);
  const T = new QS(() => h(x), 400);
  let s = Xe(null),
    F = Xe(void 0),
    Z = Xe([]);
  const K = /^([+-]?([1-8]?\d(\.\d+)?|90(\.0+)?))\s*,\s*([+-]?(180(\.0+)?|((1[0-7]\d)|([1-9]?\d))(\.\d+)?))$/,
    G = Je(() => {
      const Ue = K.exec(h(x));
      if (Ue) {
        const je = parseFloat(Ue[1]),
          rt = parseFloat(Ue[5]);
        return {
          type: "coordinates",
          id: `coords-${je}-${rt}`,
          pos: {
            lat: je,
            lng: rt
          },
          zoom: l.tileZoom + 2
        }
      }
    }),
    re = "recent-locations";
  Oa(() => {
    const Ue = localStorage.getItem(re);
    if (Ue) try {
      j(Z, JSON.parse(Ue))
    } catch (je) {
      console.error("Failed to parse recent locations from localStorage", je)
    }
  }), Qr(() => {
    T.current && r8(T.current).then(Ue => {
      j(F, Ue.features.map(je => {
        if (je.properties.layer === "country") return {
          type: "country",
          id: je.properties.id,
          name: je.properties.name,
          bbox: je.bbox,
          coordinates: je.geometry.type === "Point" ? {
            lat: je.geometry.coordinates[1],
            lng: je.geometry.coordinates[0]
          } : void 0
        };
        const rt = je.properties.label.replace(je.properties.name + ",", "").trim();
        return {
          type: "place",
          id: je.properties.id,
          name: je.properties.name,
          label: rt,
          bbox: je.bbox,
          coordinates: je.geometry.type === "Point" ? {
            lat: je.geometry.coordinates[1],
            lng: je.geometry.coordinates[0]
          } : void 0
        }
      })), h(k) && h(F).length > 0 && me(h(F)[0])
    })
  }), Qr(() => {
    h(x) || j(F, void 0)
  }), Qr(() => {
    _() ? setTimeout(() => {
      h(s).focus()
    }, 50) : (j(x, ""), j(k, !1), j(F, void 0))
  });
  async function he() {
    const {
      tile: Ue,
      pixel: je
    } = await Kr.getRandomTile(l.season), rt = new kn(l.tileSize), _t = Ue.x * l.tileSize + je.x, dt = Ue.y * l.tileSize + je.y, [at, nt] = rt.pixelsToLatLon(_t, dt, l.tileZoom), ot = {
      lat: at,
      lng: nt
    }, ut = l.tileZoom + 2;
    l.map.flyTo({
      zoom: ut,
      center: ot
    }), q({
      type: "coordinates",
      id: `coords-${at}-${nt}`,
      pos: ot,
      zoom: ut
    })
  }

  function me(Ue) {
    Ue.type === "coordinates" ? l.map.flyTo({
      zoom: Ue.zoom,
      center: Ue.pos
    }) : Ue.bbox ? l.map.fitBounds([
      [Ue.bbox[0], Ue.bbox[1]],
      [Ue.bbox[2], Ue.bbox[3]]
    ], {
      padding: 40,
      duration: 1e3
    }) : Ue.coordinates && l.map.flyTo({
      zoom: 16,
      center: Ue.coordinates,
      duration: 1e3
    }), _(!1), j(F, void 0), q(Ue)
  }

  function q(Ue) {
    j(Z, h(Z).filter(rt => rt.id !== Ue.id)), h(Z).unshift(Ue);
    const je = 15;
    h(Z).length > je && j(Z, h(Z).slice(0, je)), j(Z, [...h(Z)]), localStorage.setItem(re, JSON.stringify(h(Z)))
  }
  var ye = f8(),
    be = P(ye),
    qe = P(be),
    xe = P(qe),
    Ye = P(xe);
  Ka(Ye), Rn(Ye, Ue => j(s, Ue), () => h(s));
  var We = E(Ye, 2);
  We.__click = () => _(!1);
  var ze = P(We);
  sg(ze, {
    class: "size-5"
  }), S(We);
  var Se = E(We, 2);
  {
    var Pe = Ue => {
      var je = c8();
      je.__click = () => j(x, "");
      var rt = P(je);
      s8(rt, {
        class: "size-4.5"
      }), S(je), B(Ue, je)
    };
    Te(Se, Ue => {
      h(x) && Ue(Pe)
    })
  }
  S(xe), S(qe);
  var Ae = E(qe, 2),
    Me = P(Ae);
  {
    var Ee = Ue => {
        lm(Ue, {
          get location() {
            return h(G)
          },
          onclick: () => me(h(G))
        })
      },
      Qe = Ue => {
        var je = br(),
          rt = zt(je);
        {
          var _t = at => {
              var nt = h8(),
                ot = zt(nt);
              Hi(ot, 17, () => h(F), wt => wt.id, (wt, Ct) => {
                lm(wt, {
                  get location() {
                    return h(Ct)
                  },
                  onclick: () => me(h(Ct))
                })
              });
              var ut = E(ot, 2);
              {
                var st = wt => {
                  var Ct = u8(),
                    rr = P(Ct, !0);
                  S(Ct), ke(Zt => ee(rr, Zt), [() => i5()]), B(wt, Ct)
                };
                Te(ut, wt => {
                  h(F).length === 0 && wt(st)
                })
              }
              B(at, nt)
            },
            dt = at => {
              var nt = p8(),
                ot = zt(nt),
                ut = P(ot),
                st = P(ut, !0);
              S(ut);
              var wt = E(ut, 2);
              wt.__click = async () => {
                try {
                  await he(), _(!1)
                } catch (ht) {
                  Bt.error(ht.message)
                } finally {
                  j(z, !1)
                }
              };
              var Ct = P(wt);
              l8(Ct, {
                class: "size-5"
              }), S(wt), S(ot);
              var rr = E(ot, 2);
              Hi(rr, 17, () => h(Z), ht => ht.id, (ht, Dt) => {
                lm(ht, {
                  get location() {
                    return h(Dt)
                  },
                  onclick: () => {
                    me(h(Dt))
                  },
                  onremove: () => {
                    j(Z, h(Z).filter(Vt => Vt.id !== h(Dt).id)), localStorage.setItem(re, JSON.stringify(h(Z)))
                  }
                })
              });
              var Zt = E(rr, 2);
              {
                var lt = ht => {
                  var Dt = d8(),
                    Vt = P(Dt, !0);
                  S(Dt), ke(Jt => ee(Vt, Jt), [() => a5()]), B(ht, Dt)
                };
                Te(Zt, ht => {
                  h(Z).length === 0 && ht(lt)
                })
              }
              ke((ht, Dt) => {
                ee(st, ht), Xt(wt, "data-tip", Dt), wt.disabled = h(z)
              }, [() => t5(), () => r5()]), B(at, nt)
            };
          Te(rt, at => {
            h(F) ? at(_t) : at(dt, !1)
          }, !0)
        }
        B(Ue, je)
      };
    Te(Me, Ue => {
      h(G) ? Ue(Ee) : Ue(Qe, !1)
    })
  }
  S(Ae), S(be), wi(2), S(ye), qa(ye, () => Ue => {
    Qr(() => {
      _() ? Ue.showModal() : Ue.close()
    })
  }), ke(Ue => Xt(Ye, "placeholder", Ue), [() => k0()]), Ci("close", ye, () => _(!1)), Ci("submit", xe, () => {
    var Ue;
    h(G) ? me(h(G)) : T.pending ? j(k, !0) : (Ue = h(F)) != null && Ue.length && me(h(F)[0])
  }), Tl(Ye, () => h(x), Ue => j(x, Ue)), B(y, ye), Wr()
}
Ui(["click"]);
var g8 = Yr('<svg><path d="M200-80q-50 0-85-35t-35-85q0-39 22.5-69.5T160-313v-334q-35-13-57.5-43.5T80-760q0-50 35-85t85-35q39 0 69.5 22.5T313-800h334q12-35 42.5-57.5T760-880q50 0 85 35t35 85q0 40-22.5 70.5T800-647v334q35 13 57.5 43.5T880-200q0 50-35 85t-85 35q-39 0-69.5-22.5T647-160H313q-13 35-43.5 57.5T200-80Zm0-640q17 0 28.5-11.5T240-760q0-17-11.5-28.5T200-800q-17 0-28.5 11.5T160-760q0 17 11.5 28.5T200-720Zm560 0q17 0 28.5-11.5T800-760q0-17-11.5-28.5T760-800q-17 0-28.5 11.5T720-760q0 17 11.5 28.5T760-720ZM313-240h334q9-26 28-45t45-28v-334q-26-9-45-28t-28-45H313q-9 26-28 45t-45 28v334q26 9 45 28t28 45Zm447 80q17 0 28.5-11.5T800-200q0-17-11.5-28.5T760-240q-17 0-28.5 11.5T720-200q0 17 11.5 28.5T760-160Zm-560 0q17 0 28.5-11.5T240-200q0-17-11.5-28.5T200-240q-17 0-28.5 11.5T160-200q0 17 11.5 28.5T200-160Zm0-600Zm560 0Zm0 560Zm-560 0Z"></path></svg>');

function Gm(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = g8();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var _8 = Yr('<svg><path fill="currentColor" d="M9 14c1.381 0 2.631-.56 3.536-1.465C13.44 11.631 14 10.381 14 9s-.56-2.631-1.464-3.535C11.631 4.56 10.381 4 9 4s-2.631.56-3.536 1.465C4.56 6.369 4 7.619 4 9s.56 2.631 1.464 3.535A5 5 0 0 0 9 14m0 7c3.518 0 6-1 6-2c0-2-2.354-4-6-4c-3.75 0-6 2-6 4c0 1 2.25 2 6 2m12-9h-2v-2a1 1 0 1 0-2 0v2h-2a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2"></path></svg>');

function v8(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = _8();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    ..._
  })), B(y, x)
}
var y8 = Yr('<svg><circle cx="12" cy="12" r="8" fill="none" stroke="currentColor" stroke-width="2"></circle><circle cx="12" cy="12" r="3" fill="currentColor"></circle></svg>');

function x8(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = y8();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    ..._
  })), B(y, x)
}
var b8 = Yr('<svg><path fill="currentColor" d="m15 21l-6-2.1l-4.65 1.8q-.5.2-.925-.112T3 19.75v-14q0-.325.188-.575T3.7 4.8L9 3l6 2.1l4.65-1.8q.5-.2.925.113T21 4.25v14q0 .325-.187.575t-.513.375zm-1-2.45V6.85l-4-1.4v11.7zm2 0l3-1V5.7l-3 1.15zM5 18.3l3-1.15V5.45l-3 1zM16 6.85v11.7zm-8-1.4v11.7z"></path></svg>');

function w8(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = b8();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    ..._
  })), B(y, x)
}
var T8 = Yr('<svg><rect x="6" y="6" width="12" height="12" fill="none" stroke="currentColor" stroke-width="2" rx="2"></rect><rect x="10" y="10" width="4" height="4" fill="currentColor" rx="1"></rect></svg>');

function S8(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = T8();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    ..._
  })), B(y, x)
}
var P8 = ae("<!> <!>", 1),
  I8 = ae('<span class="loading loading-spinner loading-xs svelte-15blegn"></span>'),
  M8 = ae('<span class="loading loading-spinner loading-xs svelte-15blegn"></span>'),
  C8 = ae('<div class="mt-3 flex justify-center svelte-15blegn"><span class="loading loading-spinner svelte-15blegn"></span></div>'),
  A8 = ae('<div class="mt-3 flex justify-center svelte-15blegn"><p class="text-base-content/80 text-sm svelte-15blegn">No one has painted in this area yet.</p></div>'),
  k8 = ae('<button class="btn btn-xs btn-circle btn-soft btn-error tooltip tooltip-bottom svelte-15blegn" data-tip="Timeout selected players"><!></button>'),
  z8 = ae('<button class="btn btn-xs btn-circle btn-soft btn-error tooltip tooltip-bottom ml-0.5 svelte-15blegn" data-tip="Ban selected players"><!></button>'),
  E8 = ae('<span class="loading loading-spinner loading-xs svelte-15blegn"></span>'),
  L8 = ae('<button class="btn btn-xs btn-circle btn-soft btn-primary tooltip tooltip-bottom mr-1 svelte-15blegn" data-tip="Paint selected pixels with transparent color"><!></button>'),
  D8 = ae('<div class="size-5 svelte-15blegn"></div> <div class="text-base-content/80 ml-0.5 svelte-15blegn">Not painted</div>', 1),
  R8 = ae("<span> </span>"),
  F8 = ae('<span class="badge badge-sm badge-error ml-0.5 border-0 svelte-15blegn">DELETED</span>'),
  B8 = ae('<span class="tooltip svelte-15blegn"><!></span>'),
  O8 = ae('<span class="tooltip svelte-15blegn"><!></span>'),
  j8 = ae('<!> <div class="ml-0.5 flex flex-wrap items-center gap-1 svelte-15blegn"><span><span class="svelte-15blegn"> </span> <span class="svelte-15blegn"> </span></span> <!> <!> <div class="ml-0.5 flex items-center svelte-15blegn"><!></div></div>', 1),
  q8 = ae('<span class="text-primary ml-1 text-xs svelte-15blegn"> </span>'),
  N8 = ae('<tr><th class="w-1 svelte-15blegn"><input type="checkbox" class="checkbox-sm checkbox pointer-event-none svelte-15blegn"/></th><td class="flex items-center gap-1 svelte-15blegn"><!></td><td class="text-center svelte-15blegn"> <!></td></tr>'),
  V8 = ae('<div class="max-h-[27vh] overflow-y-auto overflow-x-hidden svelte-15blegn"><table class="table max-w-full svelte-15blegn"><thead class="svelte-15blegn"><tr class="svelte-15blegn"><th class="w-1 svelte-15blegn"><input type="checkbox" class="checkbox-sm checkbox svelte-15blegn"/></th><th class="svelte-15blegn">Player <button class="btn btn-xs btn-circle btn-ghost tooltip tooltip-bottom ml-0.5 svelte-15blegn" data-tip="Copy selected players IDs"><!></button> <!> <!></th><th class="text-center svelte-15blegn"><!> Pixels Painted</th></tr></thead><tbody class="svelte-15blegn"></tbody></table></div>'),
  U8 = ae('<div class="pointer-events-none w-full select-none svelte-15blegn"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box pointer-events-auto w-full border-t sm:mb-3 sm:shadow-xl svelte-15blegn"><div class="p-3 svelte-15blegn"><div class="flex cursor-grab flex-wrap items-center justify-between gap-1 active:cursor-grabbing svelte-15blegn"><h2 class="flex items-center gap-1 pl-1 text-lg svelte-15blegn"><div class="bg-base-content/20 flex size-6 items-center justify-center rounded-full svelte-15blegn"><!></div> <span class="ml-0.5 svelte-15blegn">Selected area</span> <span class="text-base-content/80 ml-0.5 text-sm svelte-15blegn"> </span></h2> <div class="flex items-center gap-1 svelte-15blegn"><div class="flex items-center gap-0 svelte-15blegn"><button class="btn btn-xs btn-soft text-base-content/80 flex items-center gap-1 whitespace-nowrap rounded-br-none rounded-tr-none pr-1 text-xs svelte-15blegn"><!> <input type="checkbox" class="checkbox checkbox-xs svelte-15blegn"/></button> <button class="btn btn-xs tooltip tooltip-bottom btn-soft rounded-bl-none rounded-tl-none svelte-15blegn"><!></button></div> <button><!></button> <button><!></button> <button><!></button> <button class="btn btn-circle btn-sm svelte-15blegn"><!></button></div></div> <div class="pb-3 svelte-15blegn"><!></div></div></div></div>');

function Z8(y, l) {
  Gr(l, !0);
  let _ = Wi([]),
    x = Xe(Wi([])),
    k = Xe(!1),
    z = Xe(!1),
    T = Xe(!1),
    s = Xe(!1),
    F = Xe(!1),
    Z, K, G, re, he, me = Xe(void 0),
    q = Wi({
      x: 0,
      y: 0
    }),
    ye, be;
  const qe = 15e6,
    xe = new Ip,
    Ye = new Map;
  let We = Xe(0);
  const ze = Je(() => {
      h(We);
      const ie = new Map;
      for (const Y of Ye.values()) ie.set(Y.userId, (ie.get(Y.userId) ?? 0) + 1);
      return ie
    }),
    Se = Je(() => {
      h(We), xe.size;
      let ie = 0;
      for (const Y of Ye.values()) xe.has(Y.userId) || (ie += 1);
      return ie
    }),
    Pe = Je(() => {
      h(We);
      const ie = h(Se);
      return xe.size === 0 && ie === 0 ? "none" : xe.size === h(x).length && ie === 0 ? "all" : "some"
    }),
    Ae = Je(() => {
      h(We);
      let ie = 0;
      for (const Y of xe.values()) Y.id !== 0 && (ie += Y.painted.latitudes.length);
      for (const Y of Ye.values()) xe.has(Y.userId) || (ie += 1);
      return ie
    }),
    Me = Je(() => h(je) * 2 + 1);
  let Ee = Xe("area-select"),
    Qe = Xe(!1);
  const Ue = 15;
  let je = Xe(Ue);
  const rt = 0,
    _t = 4096,
    dt = "select-area-info:brush-radius",
    at = new Ip,
    nt = new Map,
    ot = [],
    ut = () => h(Ee) === "brush-circle" || h(Ee) === "brush-square";
  let st, wt = !1,
    Ct = !1;

  function rr() {
    wt && (wt = !1, st = void 0)
  }

  function Zt() {
    if (ot.length > 0) return;
    const ie = [l.map.dragPan, l.map.scrollZoom, l.map.boxZoom, l.map.keyboard, l.map.doubleClickZoom, l.map.touchZoomRotate].filter(Boolean);
    for (const Y of ie) {
      const Fe = Y.isEnabled ? Y.isEnabled() !== !1 : !0;
      Y.disable && Y.disable(), ot.push({
        handler: Y,
        wasEnabled: Fe
      })
    }
  }

  function lt() {
    if (ot.length !== 0) {
      for (const {
          handler: ie,
          wasEnabled: Y
        }
        of ot) Y && ie.enable && ie.enable();
      ot.length = 0
    }
  }

  function ht() {
    var Fe, Ne;
    if (!ye) return;
    const {
      handle: ie,
      pointerId: Y
    } = ye;
    (Fe = ie.hasPointerCapture) != null && Fe.call(ie, Y) && ((Ne = ie.releasePointerCapture) == null || Ne.call(ie, Y)), ye = void 0, be !== void 0 && (document.body.style.userSelect = be, be = void 0), Dt()
  }

  function Dt() {
    var At, qt;
    if (!h(me)) return;
    const ie = (qt = (At = l.map).getContainer) == null ? void 0 : qt.call(At);
    if (!ie) return;
    const Y = ie.getBoundingClientRect(),
      Fe = h(me).getBoundingClientRect(),
      Ne = Fe.left - q.x,
      Ge = Fe.top - q.y,
      pe = Y.left - Ne,
      Ve = Y.right - Ne - Fe.width,
      it = Y.top - Ge,
      yt = Y.bottom - Ge - Fe.height;
    let Lt = q.x,
      ct = q.y;
    Ve >= pe ? (Lt < pe && (Lt = pe), Lt > Ve && (Lt = Ve)) : Lt = pe, yt >= it ? (ct < it && (ct = it), ct > yt && (ct = yt)) : ct = it, Lt !== q.x && (q.x = Lt), ct !== q.y && (q.y = ct)
  }

  function Vt(ie) {
    var it, yt, Lt;
    if (ye || ie.pointerType === "mouse" && ie.button !== 0) return;
    const Y = ie.target;
    if (Y && Y.closest('button, input, textarea, select, a, [role="button"]')) return;
    const Fe = ie.currentTarget;
    if (!Fe) return;
    const Ne = h(me);
    if (!Ne) return;
    const Ge = (yt = (it = l.map).getContainer) == null ? void 0 : yt.call(it);
    if (!Ge) return;
    const pe = Ge.getBoundingClientRect(),
      Ve = Ne.getBoundingClientRect();
    ye = {
      pointerId: ie.pointerId,
      handle: Fe,
      startX: ie.clientX,
      startY: ie.clientY,
      startPosX: q.x,
      startPosY: q.y,
      baseLeft: Ve.left - q.x,
      baseTop: Ve.top - q.y,
      containerRect: pe,
      panelWidth: Ve.width,
      panelHeight: Ve.height
    }, be === void 0 && (be = document.body.style.userSelect), document.body.style.userSelect = "none", (Lt = Fe.setPointerCapture) == null || Lt.call(Fe, ie.pointerId), ie.preventDefault(), ie.stopPropagation()
  }
  Oa(() => {
    const ie = window.localStorage.getItem(dt);
    if (ie !== null) {
      const Tt = Number(ie);
      if (!Number.isNaN(Tt)) {
        const Wt = Math.min(_t, Math.max(rt, Math.trunc(Tt)));
        j(je, Wt, !0)
      }
    }
    aa.droppletAndPlop.play(), Z = Gt();
    const Y = async Tt => {
      if (h(Ee) === "user-picker") {
        await Yt(Tt, "select");
        return
      }
      if (ut()) {
        const Wt = Tt.originalEvent;
        V(Tt, "add", {
          silent: !!(Wt != null && Wt.altKey)
        });
        return
      }
      if (_.length >= 2) {
        l.onclose();
        return
      }
      if (_.push(Tt.lngLat), Rt(), aa.plop.play(), _.length === 2) try {
        j(k, !0), j(x, await jt(_[0], _[1]), !0)
      } finally {
        j(k, !1)
      }
    }, Fe = async Tt => {
      var Fr, or;
      if (h(Ee) === "user-picker") {
        (Fr = Tt.preventDefault) == null || Fr.call(Tt);
        const tt = Tt.originalEvent;
        tt == null || tt.preventDefault();
        try {
          await Yt(Tt, "deselect")
        } catch (Ht) {
          console.error(Ht)
        }
        return
      }
      if (!ut()) return;
      (or = Tt.preventDefault) == null || or.call(Tt);
      const Wt = Tt.originalEvent;
      Wt == null || Wt.preventDefault(), V(Tt, "remove")
    }, Ne = Tt => {
      if (!ut()) return;
      const Wt = Tt.originalEvent;
      if (!Wt || !Wt.altKey) return;
      const Fr = Wt.button === 2 ? "remove" : "add";
      Wt.preventDefault(), Zt(), st = Fr, wt = !0, V(Tt, Fr, {
        silent: !0
      })
    }, Ge = () => {
      rr()
    }, pe = l.map.on("click", Y), Ve = l.map.on("contextmenu", Fe), it = l.map.on("mousedown", Ne), yt = l.map.on("mouseup", Ge), Lt = Tt => {
      const Wt = ye;
      if (!Wt || Tt.pointerId !== Wt.pointerId) return;
      const Fr = Tt.clientX - Wt.startX,
        or = Tt.clientY - Wt.startY;
      let tt = Wt.startPosX + Fr,
        Ht = Wt.startPosY + or;
      const Qt = Wt.containerRect.left - Wt.baseLeft,
        Sr = Wt.containerRect.right - Wt.baseLeft - Wt.panelWidth,
        ei = Wt.containerRect.top - Wt.baseTop,
        li = Wt.containerRect.bottom - Wt.baseTop - Wt.panelHeight;
      Sr >= Qt ? (tt < Qt && (tt = Qt), tt > Sr && (tt = Sr)) : tt = Qt, li >= ei ? (Ht < ei && (Ht = ei), Ht > li && (Ht = li)) : Ht = ei, q.x !== tt && (q.x = tt), q.y !== Ht && (q.y = Ht)
    }, ct = Tt => {
      const Wt = ye;
      !Wt || Tt.pointerId !== Wt.pointerId || ht()
    };
    window.addEventListener("pointermove", Lt), window.addEventListener("pointerup", ct), window.addEventListener("pointercancel", ct), window.addEventListener("resize", Dt);
    const At = Tt => {
        if (Tt.altKey && (Tt.key === "r" || Tt.key === "R")) {
          j(je, Ue), Tt.preventDefault(), ir();
          return
        }
        Tt.key === "Alt" && (Ct || (Ct = !0, ut() && Zt()))
      },
      qt = Tt => {
        Tt.key === "Alt" && (Ct = !1, rr(), lt())
      },
      Ke = () => {
        ht(), !(!Ct && !wt) && (Ct = !1, rr(), lt())
      };
    return window.addEventListener("keydown", At), window.addEventListener("keyup", qt), window.addEventListener("blur", Ke), () => {
      var Wt, Fr;
      pe.unsubscribe(), Ve.unsubscribe(), it.unsubscribe(), yt.unsubscribe(), window.removeEventListener("pointermove", Lt), window.removeEventListener("pointerup", ct), window.removeEventListener("pointercancel", ct), window.removeEventListener("resize", Dt), window.removeEventListener("keydown", At), window.removeEventListener("keyup", qt), window.removeEventListener("blur", Ke), ht(), rr(), lt(), Ct = !1, l.crosshair.clear();
      const Tt = (Fr = (Wt = l.map).getCanvas) == null ? void 0 : Fr.call(Wt);
      Tt && (Tt.style.cursor = ""), Z == null || Z(), Z = void 0
    }
  });

  function Jt() {
    ht(), h(z) || (Z == null || Z(), Z = void 0, j(Ee, "area-select"), rr(), lt(), Ct = !1, q.x = 0, q.y = 0, Ye.clear(), j(We, h(We) + 1), at.clear(), nt.clear(), l.crosshair.clear(), l.onclose())
  }
  async function jt(ie, Y) {
    const Fe = new kn(l.tileSize),
      [Ne, Ge] = Fe.latLonToPixelsFloor(ie.lat, ie.lng, l.pixelArtZoom),
      [pe, Ve] = Fe.latLonToPixelsFloor(Y.lat, Y.lng, l.pixelArtZoom),
      [it, yt] = [Math.min(Ne, pe), Math.min(Ge, Ve)],
      [Lt, ct] = [Math.max(Ne, pe), Math.max(Ge, Ve)],
      At = Lt - it,
      qt = ct - yt;
    if (At * qt > qe) return Bt.error(`The selected area is too big. Please select an area smaller than ${qe.toLocaleString(navigator.language)} pixels.`), [];
    const Tt = Math.floor(it / l.tileSize),
      Wt = Math.floor(yt / l.tileSize),
      Fr = Math.floor(Lt / l.tileSize),
      or = Math.floor(ct / l.tileSize),
      tt = Fr - Tt + 1,
      Ht = or - Wt + 1,
      Qt = new Array(Ht).fill(0).flatMap((Jr, It) => new Array(tt).fill(0).map(async (er, Pr) => {
        const pr = Tt + Pr,
          qr = Wt + It;
        let ur = 0,
          Mr = 0,
          di = l.tileSize - 1,
          ti = l.tileSize - 1;
        qr === Wt && (Mr = yt % l.tileSize), pr === Tt && (ur = it % l.tileSize), qr === or && (ti = ct % l.tileSize), pr === Fr && (di = Lt % l.tileSize);
        const qi = [pr, qr],
          ai = [ur, Mr],
          Pt = [di, ti];
        return {
          response: await Kr.getPixelAreaInfo({
            season: l.season,
            tile: qi,
            p0: ai,
            p1: Pt
          }),
          tile: qi,
          p0: ai,
          p1: Pt
        }
      })),
      Sr = await Promise.all(Qt);
    at.clear(), nt.clear();
    const ei = new Map;
    for (const {
        response: Jr,
        p0: It,
        p1: er,
        tile: Pr
      }
      of Sr) {
      const [pr, qr] = Pr, [ur, Mr] = It, [di, ti] = er, Vr = di - ur + 1, Rr = ti - Mr + 1;
      for (let ni = 0; ni < Rr; ni++)
        for (let Ri = 0; Ri < Vr; Ri++) {
          const qi = ni * Vr + Ri,
            ai = Jr.paintedBy[qi];
          let Pt = ei.get(ai);
          Pt || (Pt = {
            latitudes: [],
            longitudes: [],
            tileXs: [],
            tileYs: [],
            pixelXs: [],
            pixelYs: [],
            globalPx: [],
            globalPy: [],
            minLat: 1 / 0,
            maxLat: -1 / 0,
            minLon: 1 / 0,
            maxLon: -1 / 0
          }, ei.set(ai, Pt));
          const tr = ur + Ri,
            Br = Mr + ni,
            Zr = pr * l.tileSize + (tr + .5),
            ci = qr * l.tileSize + (Br + .5),
            [ui, pt] = Fe.pixelsToLatLon(Zr, ci, l.pixelArtZoom);
          if (Pt.latitudes.push(ui), Pt.longitudes.push(pt), Pt.tileXs.push(pr), Pt.tileYs.push(qr), Pt.pixelXs.push(tr), Pt.pixelYs.push(Br), Pt.globalPx.push(Zr), Pt.globalPy.push(ci), ui < Pt.minLat && (Pt.minLat = ui), ui > Pt.maxLat && (Pt.maxLat = ui), pt < Pt.minLon && (Pt.minLon = pt), pt > Pt.maxLon && (Pt.maxLon = pt), ai !== 0) {
            const kt = `${pr}:${qr}:${tr}:${Br}`,
              dr = {
                key: kt,
                userId: ai,
                lat: ui,
                lon: pt,
                tile: [pr, qr],
                pixel: [tr, Br],
                globalPx: Zr,
                globalPy: ci
              };
            at.set(kt, dr);
            const pi = `${pr}:${qr}`;
            let vi = nt.get(pi);
            vi || (vi = [], nt.set(pi, vi)), vi.push(dr)
          }
        }
    }
    const {
      users: li
    } = await Kr.getMultipleUsersInfoById([...ei.keys()]), Dr = ub(li, Jr => Jr.id), Oi = [...ei.entries()].map(([Jr, It]) => ({
      ...Dr[Jr] ?? {
        id: Jr,
        name: "Player",
        deleted: !0
      },
      painted: It
    }));
    return Oi.sort((Jr, It) => Jr.id === 0 ? 1 : It.id === 0 ? -1 : It.painted.latitudes.length - Jr.painted.latitudes.length), Oi
  }
  async function nr({
    preserveSelection: ie = !1
  } = {}) {
    if (_.length < 2) return;
    const Y = ie ? new Set([...xe.keys()]) : void 0,
      Fe = ie ? [...Ye.keys()] : void 0;
    try {
      j(k, !0);
      const Ne = await jt(_[0], _[1]);
      if (j(x, Ne, !0), xe.clear(), Ye.clear(), j(We, h(We) + 1), l.crosshair.clear(), ie && (Y != null && Y.size)) {
        for (const Ge of Ne) Y.has(Ge.id) && xe.set(Ge.id, Ge);
        for (const Ge of xe.values())
          for (let pe = 0; pe < Ge.painted.latitudes.length; pe++) l.crosshair.place([Ge.painted.latitudes[pe], Ge.painted.longitudes[pe]])
      }
      if (ie && (Fe != null && Fe.length)) {
        let Ge = !1;
        for (const pe of Fe) {
          const Ve = at.get(pe);
          Ve && (Ye.set(pe, Ve), Ge = !0)
        }
        Ge && j(We, h(We) + 1)
      }
      for (const Ge of Ye.values()) l.crosshair.place([Ge.lat, Ge.lon])
    } finally {
      j(k, !1)
    }
  }

  function St(ie) {
    let Y = !1;
    for (const Fe of ie)(Lr(Fe) || Fe.id === 0) && (Y = !0);
    Y && aa.plop.play()
  }

  function Et(ie) {
    for (let Y = 0; Y < ie.latitudes.length; Y++) l.crosshair.remove([ie.latitudes[Y], ie.longitudes[Y]])
  }

  function Ut(ie) {
    if (!ie) {
      he = void 0;
      return
    }
    if (_.length >= 2 && h(Ee) === "area-select") {
      he = void 0;
      return
    }
    he = ie
  }
  Qr(() => {
    _.length < 2 && h(Ee) !== "area-select" && j(Ee, "area-select");
    const ie = l.map.getCanvas();
    if (!ie) return;
    const Y = h(Ee) === "user-picker" || h(Ee) === "brush-circle" || h(Ee) === "brush-square";
    ie.style.cursor = Y ? "crosshair" : "", ir()
  }), Qr(() => {
    const ie = ut();
    ie || rr(), Ct && (ie ? Zt() : lt())
  }), Qr(() => {
    h(je), ir()
  }), Qr(() => {
    typeof window < "u" && window.localStorage.setItem(dt, String(Math.trunc(h(je))))
  }), Qr(() => {
    _.length, _.length < 2 ? (q.x !== 0 && (q.x = 0), q.y !== 0 && (q.y = 0)) : Dt(), Rt(), kr()
  });

  function Gt() {
    const ie = l.map.getContainer(),
      Y = document.createElement("div");
    Y.classList.add("selection-rectangle"), Y.style.position = "absolute", Y.style.pointerEvents = "none", Y.style.display = "none", Y.style.zIndex = "6", ie.appendChild(Y);
    const Fe = document.createElement("div");
    Fe.classList.add("selection-brush"), Fe.style.position = "absolute", Fe.style.pointerEvents = "none", Fe.style.display = "none", Fe.style.zIndex = "7", ie.appendChild(Fe);
    const Ne = fr(ie, "horizontal"),
      Ge = fr(ie, "vertical");
    re = {
      horizontal: Ne,
      vertical: Ge
    }, G = Fe;
    const pe = ct => {
        Ut({
          x: ct.point.x,
          y: ct.point.y
        }), Rt(), kr(), ir();
        const At = ct.originalEvent;
        if (!At) {
          wt && rr();
          return
        }
        if (!wt && At.altKey && ut()) {
          let qt = !1;
          if (At.buttons & 1 ? (Zt(), st = "add", wt = !0, qt = !0) : At.buttons & 2 && (Zt(), st = "remove", wt = !0, qt = !0), qt && st) {
            V(ct, st, {
              silent: !0
            });
            return
          }
        }
        if (wt && st) {
          if (!At.altKey || At.buttons === 0) {
            rr();
            return
          }
          V(ct, st, {
            silent: !0
          })
        }
      },
      Ve = ct => {
        const At = ie.getBoundingClientRect();
        Ut({
          x: ct.clientX - At.left,
          y: ct.clientY - At.top
        }), Rt(), kr(), ir()
      },
      it = () => {
        he = void 0, rr(), Rt(), kr(), ir()
      },
      yt = () => {
        Dt(), Rt(), kr(), ir()
      },
      Lt = ct => {
        if (!ut()) return;
        if (!(ct.altKey || Ct)) {
          wt && (rr(), lt());
          return
        }
        Ct = !0, Zt(), ct.preventDefault(), ct.stopPropagation(), typeof ct.stopImmediatePropagation == "function" && ct.stopImmediatePropagation();
        const At = ct.deltaY < 0 ? 1 : -1,
          qt = (ct.shiftKey ? 10 : 1) * At,
          Ke = Math.min(_t, Math.max(rt, h(je) + qt));
        Ke !== h(je) && (j(je, Ke, !0), ir())
      };
    return l.map.on("mousemove", pe), ie.addEventListener("pointermove", Ve), ie.addEventListener("mouseleave", it), l.map.on("move", yt), l.map.on("resize", yt), ie.addEventListener("wheel", Lt, {
      passive: !1
    }), K = Y, Rt(), kr(), ir(), () => {
      l.map.off("mousemove", pe), l.map.off("move", yt), l.map.off("resize", yt), ie.removeEventListener("pointermove", Ve), ie.removeEventListener("mouseleave", it), ie.removeEventListener("wheel", Lt), Y.remove(), K = void 0, he = void 0, re == null || re.horizontal.remove(), re == null || re.vertical.remove(), re = void 0, G == null || G.remove(), G = void 0
    }
  }

  function Rt() {
    const ie = K;
    if (!ie) return;
    const Y = new kn(l.tileSize);
    let Fe, Ne, Ge, pe;
    if (_.length >= 2) {
      const Fr = _.map(or => Y.latLonToPixelsFloor(or.lat, or.lng, l.pixelArtZoom));
      Fe = Math.min(...Fr.map(([or]) => or)), Ne = Math.max(...Fr.map(([or]) => or)) + 1, Ge = Math.min(...Fr.map(([, or]) => or)), pe = Math.max(...Fr.map(([, or]) => or)) + 1
    } else if (_.length === 1 && he) {
      const [Fr, or] = Y.latLonToPixelsFloor(_[0].lat, _[0].lng, l.pixelArtZoom), tt = l.map.unproject([he.x, he.y]), [Ht, Qt] = Y.latLonToPixelsFloor(tt.lat, tt.lng, l.pixelArtZoom);
      Fe = Math.min(Fr, Ht), Ne = Math.max(Fr, Ht) + 1, Ge = Math.min(or, Qt), pe = Math.max(or, Qt) + 1
    } else {
      ie.style.display = "none";
      return
    }
    const [Ve, it] = Y.pixelsToLatLon(Fe, Ge, l.pixelArtZoom), [yt, Lt] = Y.pixelsToLatLon(Ne, pe, l.pixelArtZoom), ct = l.map.project([it, Ve]), At = l.map.project([Lt, yt]);
    let qt = Math.min(ct.x, At.x),
      Ke = Math.max(ct.x, At.x),
      Tt = Math.min(ct.y, At.y),
      Wt = Math.max(ct.y, At.y);
    Ke - qt < 1 && (Ke = qt + 1), Wt - Tt < 1 && (Wt = Tt + 1), ie.style.display = "block", ie.style.left = `${qt}px`, ie.style.top = `${Tt}px`, ie.style.width = `${Ke-qt}px`, ie.style.height = `${Wt-Tt}px`
  }

  function ir() {
    const ie = G;
    if (!ie) return;
    if (!(h(Ee) === "brush-circle" || h(Ee) === "brush-square") || !he) {
      ie.style.display = "none";
      return
    }
    const Y = new kn(l.tileSize),
      Fe = l.map.unproject([he.x, he.y]),
      [Ne, Ge] = Y.latLonToPixels(Fe.lat, Fe.lng, l.pixelArtZoom),
      pe = h(je) + .5,
      [Ve, it] = Y.pixelsToLatLon(Ne - pe, Ge - pe, l.pixelArtZoom),
      [yt, Lt] = Y.pixelsToLatLon(Ne + pe, Ge + pe, l.pixelArtZoom),
      ct = l.map.project([it, Ve]),
      At = l.map.project([Lt, yt]),
      qt = Math.min(ct.x, At.x),
      Ke = Math.max(ct.x, At.x),
      Tt = Math.min(ct.y, At.y),
      Wt = Math.max(ct.y, At.y);
    ie.style.display = "block", ie.style.left = `${qt}px`, ie.style.top = `${Tt}px`, ie.style.width = `${Math.max(Ke-qt,2)}px`, ie.style.height = `${Math.max(Wt-Tt,2)}px`, ie.style.borderRadius = h(Ee) === "brush-circle" ? "100%" : "4px", ie.dataset.radius = String(h(je))
  }

  function kr() {
    const ie = re;
    if (ie) {
      if (!he || _.length >= 2) {
        _r();
        return
      }
      ie.horizontal.style.display = "block", ie.horizontal.style.top = `${he.y}px`, ie.horizontal.style.transform = "translateY(-0.5px)", ie.vertical.style.display = "block", ie.vertical.style.left = `${he.x}px`, ie.vertical.style.transform = "translateX(-0.5px)"
    }
  }

  function _r() {
    re && (re.horizontal.style.display = "none", re.vertical.style.display = "none")
  }

  function fr(ie, Y) {
    const Fe = document.createElement("div");
    return Fe.style.position = "absolute", Fe.style.pointerEvents = "none", Fe.style.zIndex = "5", Fe.style.display = "none", Fe.style.mixBlendMode = "difference", Fe.style.backgroundColor = "rgba(255, 255, 255, 0.9)", Y === "horizontal" ? (Fe.style.left = "0", Fe.style.right = "0", Fe.style.height = "1px") : (Fe.style.top = "0", Fe.style.bottom = "0", Fe.style.width = "1px"), ie.appendChild(Fe), Fe
  }
  async function Yt(ie, Y = "select") {
    var Fe;
    if (!h(Qe)) {
      if (h(k)) {
        Bt.info("Wait until the selected area finishes loading.");
        return
      }
      if (_.length < 2) {
        Bt.info("Select an area first to use the user picker.");
        return
      }
      j(Qe, !0);
      try {
        const Ne = new kn(l.tileSize),
          {
            tile: Ge,
            pixel: pe
          } = Ne.latLonToTileAndPixel(ie.lngLat.lat, ie.lngLat.lng, l.pixelArtZoom),
          {
            paintedBy: Ve
          } = await Kr.getPixelInfo({
            season: l.season,
            tile: Ge,
            pixel: pe,
            role: (Fe = bt.data) == null ? void 0 : Fe.role
          });
        if (!Ve || Ve.id === 0) {
          Bt.info("That pixel is not painted by any player.");
          return
        }
        const it = h(x).find(Lt => Lt.id === Ve.id);
        if (!it) {
          Bt.info("Selected pixel is outside the selected area.");
          return
        }
        if (Y === "deselect") {
          if (!xe.has(it.id)) {
            vr(it.id) ? (aa.plop.play(), Bt.success(`${it.name} deselected`)) : Bt.info("That player is not selected.");
            return
          }
          xe.delete(it.id), Et(it.painted), vr(it.id, {
            skipCrosshair: !0
          }), aa.plop.play(), Bt.success(`${it.name} deselected`);
          return
        }
        if (xe.has(it.id)) {
          Bt.info("Player already selected.");
          return
        }
        xe.set(it.id, it), (Lr(it) || it.id === 0) && aa.plop.play(), Bt.success(`${it.name} selected`)
      } catch (Ne) {
        Bt.error(Ne.message)
      } finally {
        j(Qe, !1)
      }
    }
  }

  function sr(ie, {
    skipCrosshair: Y = !1
  } = {}) {
    return Ye.has(ie.key) ? !1 : (Ye.set(ie.key, ie), Y || l.crosshair.place([ie.lat, ie.lon]), !0)
  }

  function Kt(ie, {
    skipCrosshair: Y = !1
  } = {}) {
    const Fe = Ye.get(ie);
    return Fe ? (Ye.delete(ie), Y || l.crosshair.remove([Fe.lat, Fe.lon]), !0) : !1
  }

  function vr(ie, {
    skipCrosshair: Y = !1
  } = {}) {
    const Fe = [];
    for (const [Ge, pe] of Ye.entries()) pe.userId === ie && Fe.push(Ge);
    let Ne = !1;
    for (const Ge of Fe) Kt(Ge, {
      skipCrosshair: Y
    }) && (Ne = !0);
    return Ne && j(We, h(We) + 1), Ne
  }

  function Lr(ie, {
    skipCrosshair: Y = !1
  } = {}) {
    if (ie.id === 0) return !1;
    const Fe = ie.painted;
    let Ne = !1;
    for (let Ge = 0; Ge < Fe.latitudes.length; Ge++) {
      const pe = Fe.tileXs[Ge],
        Ve = Fe.tileYs[Ge],
        it = Fe.pixelXs[Ge],
        yt = Fe.pixelYs[Ge],
        Lt = `${pe}:${Ve}:${it}:${yt}`;
      let ct = at.get(Lt);
      if (!ct) {
        ct = {
          key: Lt,
          userId: ie.id,
          lat: Fe.latitudes[Ge],
          lon: Fe.longitudes[Ge],
          tile: [pe, Ve],
          pixel: [it, yt],
          globalPx: Fe.globalPx[Ge],
          globalPy: Fe.globalPy[Ge]
        }, at.set(Lt, ct);
        const At = `${pe}:${Ve}`;
        let qt = nt.get(At);
        qt || (qt = [], nt.set(At, qt)), qt.push(ct)
      }
      sr(ct, {
        skipCrosshair: Y
      }) && (Ne = !0)
    }
    return Ne && j(We, h(We) + 1), Ne
  }

  function ii(ie) {
    return h(x).find(Y => Y.id === ie)
  }

  function mr(ie, {
    silent: Y = !1
  } = {}) {
    let Fe = !1;
    for (const [Ne, Ge] of ie) {
      if (xe.has(Ne)) continue;
      const pe = ii(Ne);
      if (!pe) continue;
      const Ve = pe.painted.latitudes.length;
      (h(ze).get(Ne) ?? 0) + Ge >= Ve && (xe.set(Ne, pe), Fe = !0)
    }
    Fe && !Y && aa.plop.play()
  }

  function ge(ie, Y) {
    if (at.size === 0) return [];
    const Fe = new kn(l.tileSize),
      [Ne, Ge] = Fe.latLonToPixels(ie, Y, l.pixelArtZoom),
      pe = h(je) + .5,
      Ve = Ne - pe,
      it = Ne + pe,
      yt = Ge - pe,
      Lt = Ge + pe,
      ct = Math.floor(Ve / l.tileSize),
      At = Math.floor(it / l.tileSize),
      qt = Math.floor(yt / l.tileSize),
      Ke = Math.floor(Lt / l.tileSize),
      Tt = [];
    for (let Wt = ct; Wt <= At; Wt++)
      for (let Fr = qt; Fr <= Ke; Fr++) {
        const or = `${Wt}:${Fr}`,
          tt = nt.get(or);
        if (tt)
          for (const Ht of tt) {
            const Qt = Ht.globalPx - Ne,
              Sr = Ht.globalPy - Ge;
            if (h(Ee) === "brush-circle") {
              if (Qt * Qt + Sr * Sr > pe * pe) continue
            } else if (Math.abs(Qt) > pe || Math.abs(Sr) > pe) continue;
            Tt.push(Ht)
          }
      }
    return Tt
  }

  function V(ie, Y, {
    silent: Fe = !1
  } = {}) {
    if (h(k)) return Fe || Bt.info("Wait until the selected area finishes loading."), !1;
    if (_.length < 2) return Fe || Bt.info("Select an area first to use the brush tool."), !1;
    const Ne = ge(ie.lngLat.lat, ie.lngLat.lng);
    if (Ne.length === 0) {
      if (!Fe) {
        const Ve = Y === "add" ? "No painted pixels found within the brush." : "No selected pixels to remove within the brush.";
        Bt.info(Ve)
      }
      return !1
    }
    let Ge = !1;
    const pe = new Map;
    if (Y === "add")
      for (const Ve of Ne) xe.has(Ve.userId) || Ye.has(Ve.key) || sr(Ve) && (Ge = !0, pe.set(Ve.userId, (pe.get(Ve.userId) ?? 0) + 1));
    else
      for (const Ve of Ne) Kt(Ve.key) && (Ge = !0, xe.has(Ve.userId) && xe.delete(Ve.userId));
    return Ge ? (Y === "add" && pe.size > 0 && mr(pe, {
      silent: Fe
    }), j(We, h(We) + 1), Fe || aa.plop.play(), !0) : (!Fe && Y === "add" && Bt.info("All pixels inside the brush are already selected."), !1)
  }
  async function U() {
    const ie = l.map.getCanvas();
    if (!ie) return Bt.error("Unable to access map canvas."), !1;
    const Y = ie.getBoundingClientRect();
    if (!Y.width || !Y.height) return Bt.error("Map is not visible to capture."), !1;
    let Fe = 1 / 0,
      Ne = -1 / 0,
      Ge = 1 / 0,
      pe = -1 / 0;
    for (const It of _) {
      const {
        lat: er,
        lng: Pr
      } = It;
      er < Fe && (Fe = er), er > Ne && (Ne = er), Pr < Ge && (Ge = Pr), Pr > pe && (pe = Pr)
    }
    if (!isFinite(Fe) || !isFinite(Ne) || !isFinite(Ge) || !isFinite(pe)) return Bt.error("Unable to determine selected area."), !1;
    const Ve = l.map.project([Ge, Ne]),
      it = l.map.project([pe, Fe]);
    if (!Number.isFinite(Ve.x) || !Number.isFinite(Ve.y) || !Number.isFinite(it.x) || !Number.isFinite(it.y)) return Bt.error("Unable to project selected area on the map."), !1;
    let yt = Math.min(Ve.x, it.x),
      Lt = Math.max(Ve.x, it.x),
      ct = Math.min(Ve.y, it.y),
      At = Math.max(Ve.y, it.y);
    yt = Math.max(0, yt), ct = Math.max(0, ct), Lt = Math.min(Y.width, Lt), At = Math.min(Y.height, At);
    const qt = Lt - yt,
      Ke = At - ct;
    if (qt <= 0 || Ke <= 0) return Bt.error("Selected area is outside the current map view."), !1;
    const Tt = ie.width / Y.width,
      Wt = ie.height / Y.height,
      Fr = Math.floor(yt * Tt),
      or = Math.floor(ct * Wt),
      tt = Math.max(1, Math.ceil(Lt * Tt) - Fr),
      Ht = Math.max(1, Math.ceil(At * Wt) - or),
      Qt = await Ap(l.map);
    let Sr;
    if ("createImageBitmap" in window) Sr = await createImageBitmap(Qt);
    else {
      const It = URL.createObjectURL(Qt);
      Sr = await new Promise((er, Pr) => {
        const pr = new Image;
        pr.crossOrigin = "anonymous", pr.onload = () => er(pr), pr.onerror = () => Pr(new Error("Failed to decode map image.")), pr.src = It
      }), URL.revokeObjectURL(It)
    }
    const ei = document.createElement("canvas");
    ei.width = tt, ei.height = Ht;
    const li = ei.getContext("2d");
    if (!li) return "close" in Sr && Sr.close(), Bt.error("Unable to create drawing context."), !1;
    li.drawImage(Sr, Fr, or, tt, Ht, 0, 0, tt, Ht), "close" in Sr && Sr.close();
    const Dr = await new Promise((It, er) => {
        ei.toBlob(Pr => {
          Pr ? It(Pr) : er(new Error("Failed to prepare download."))
        }, "image/png")
      }),
      Oi = URL.createObjectURL(Dr),
      Jr = document.createElement("a");
    return Jr.href = Oi, Jr.download = `selected-map-${tt}x${Ht}.png`, document.body.appendChild(Jr), Jr.click(), document.body.removeChild(Jr), URL.revokeObjectURL(Oi), !0
  }
  async function J() {
    if (!(h(s) || h(k))) {
      if (_.length < 2) {
        Bt.info(h(F) ? "Select an area first to save the map view." : "Select an area first to save pixel art.");
        return
      }
      j(s, !0);
      try {
        switch (h(F)) {
          case !0:
            if (h(F)) {
              await U() && Bt.success("Selected map view saved");
              return
            }
          case !1:
            const ie = new kn(l.tileSize);
            let Y = 1 / 0,
              Fe = -1 / 0,
              Ne = 1 / 0,
              Ge = -1 / 0;
            for (let tt = 0; tt < _.length; tt++) {
              const Ht = _[tt],
                Qt = ie.latLonToPixelsFloor(Ht.lat, Ht.lng, l.pixelArtZoom),
                Sr = Qt[0],
                ei = Qt[1];
              Sr < Y && (Y = Sr), Sr > Fe && (Fe = Sr), ei < Ne && (Ne = ei), ei > Ge && (Ge = ei)
            }
            if (!isFinite(Y) || !isFinite(Fe) || !isFinite(Ne) || !isFinite(Ge)) {
              Bt.error("Unable to determine selected area.");
              return
            }
            const pe = Fe + 1,
              Ve = Ge + 1,
              it = pe - Y,
              yt = Ve - Ne;
            if (it <= 0 || yt <= 0) {
              Bt.error("Selected area has no size.");
              return
            }
            const Lt = document.createElement("canvas");
            Lt.width = it, Lt.height = yt;
            const ct = Lt.getContext("2d");
            if (!ct) {
              Bt.error("Unable to create drawing context.");
              return
            }
            const At = Math.floor(Y / l.tileSize),
              qt = Math.floor((pe - 1) / l.tileSize),
              Ke = Math.floor(Ne / l.tileSize),
              Tt = Math.floor((Ve - 1) / l.tileSize);
            for (let tt = Ke; tt <= Tt; tt++)
              for (let Ht = At; Ht <= qt; Ht++) {
                const Qt = Ht * l.tileSize,
                  Sr = tt * l.tileSize,
                  ei = Math.max(Y, Qt),
                  li = Math.max(Ne, Sr),
                  Dr = Math.min(pe, Qt + l.tileSize),
                  Oi = Math.min(Ve, Sr + l.tileSize),
                  Jr = Dr - ei,
                  It = Oi - li;
                if (Jr <= 0 || It <= 0) continue;
                const er = await fetch(`${p0}/s${l.season}/tiles/${Ht}/${tt}.png`);
                if (!er.ok) throw new Error("Failed to load tile image.");
                const Pr = await er.blob();
                if ("createImageBitmap" in window) {
                  const pr = await createImageBitmap(Pr);
                  ct.drawImage(pr, ei - Qt, li - Sr, Jr, It, ei - Y, li - Ne, Jr, It), pr.close && pr.close()
                } else {
                  const pr = URL.createObjectURL(Pr),
                    qr = await new Promise((ur, Mr) => {
                      const di = new Image;
                      di.crossOrigin = "anonymous", di.onload = () => ur(di), di.onerror = () => Mr(new Error("Failed to decode tile image.")), di.src = pr
                    });
                  ct.drawImage(qr, ei - Qt, li - Sr, Jr, It, ei - Y, li - Ne, Jr, It), URL.revokeObjectURL(pr)
                }
              }
            const Wt = await new Promise((tt, Ht) => {
                Lt.toBlob(Qt => {
                  Qt ? tt(Qt) : Ht(new Error("Failed to prepare download."))
                }, "image/png")
              }),
              Fr = URL.createObjectURL(Wt),
              or = document.createElement("a");
            or.href = Fr, or.download = `selected-area-${it}x${yt}.png`, document.body.appendChild(or), or.click(), document.body.removeChild(or), URL.revokeObjectURL(Fr), Bt.success("Selected area image saved")
        }
      } catch (ie) {
        Bt.error(ie.message)
      } finally {
        j(s, !1)
      }
    }
  }
  async function se() {
    if (h(T) || h(k)) return;
    const ie = new Map;
    for (const Y of xe.values()) {
      if (Y.id === 0) continue;
      const {
        tileXs: Fe,
        tileYs: Ne,
        pixelXs: Ge,
        pixelYs: pe
      } = Y.painted;
      for (let Ve = 0; Ve < Fe.length; Ve++) {
        const it = [Fe[Ve], Ne[Ve]],
          yt = [Ge[Ve], pe[Ve]],
          Lt = {
            tile: it,
            pixel: yt,
            season: l.season
          },
          ct = `${it[0]}:${it[1]}:${yt[0]}:${yt[1]}`;
        ie.set(ct, Lt)
      }
    }
    for (const Y of Ye.values()) xe.has(Y.userId) || ie.has(Y.key) || ie.set(Y.key, {
      tile: Y.tile,
      pixel: Y.pixel,
      season: l.season
    });
    if (ie.size === 0) {
      Bt.info("Select painted pixels to clear with transparent color");
      return
    }
    j(T, !0);
    try {
      aa.droppletAndPlop.play();
      const Y = await gg(),
        Fe = [];
      for (const pe of ie.values()) Fe.push({
        ...pe,
        colorIdx: 0
      });
      await Kr.selectAreaClear(Fe, Y);
      const Ne = wp(0),
        Ge = Fe.map(({
          tile: pe,
          pixel: Ve,
          season: it
        }) => ({
          tile: pe,
          pixel: Ve,
          season: it,
          color: Ne
        }));
      await Km(Ge), Bt.success("Painted selected pixels with transparent color"), await nr()
    } catch (Y) {
      Bt.error(Y.message)
    } finally {
      j(T, !1)
    }
  }
  const te = ie => ({
    id: ie.id,
    name: ie.name,
    picture: ie.picture,
    allianceId: ie.allianceId ?? void 0,
    allianceName: ie.allianceName ?? void 0,
    timedOut: ie.timedOut,
    banned: ie.banned,
    deleted: ie.deleted
  });

  function _e() {
    const ie = new Map;
    for (const Y of xe.values()) Y.id !== 0 && ie.set(Y.id, Y);
    if (Ye.size > 0) {
      let Y;
      for (const Fe of Ye.values()) {
        const Ne = Fe.userId;
        if (Ne === 0 || ie.has(Ne)) continue;
        if (!Y) {
          Y = new Map;
          for (const pe of h(x)) Y.set(pe.id, pe)
        }
        const Ge = Y.get(Ne);
        Ge && ie.set(Ge.id, Ge)
      }
    }
    return [...ie.values()]
  }
  async function Re(ie, Y) {
    try {
      j(z, !0);
      const Fe = ie.filter(ct => ct.id !== 0);
      if (Fe.length === 0) {
        Bt.info("Select at least one player");
        return
      }
      let Ne = 1 / 0,
        Ge = -1 / 0,
        pe = 1 / 0,
        Ve = -1 / 0;
      if (_.length >= 2)
        for (const ct of _) {
          const {
            lat: At,
            lng: qt
          } = ct;
          !isFinite(At) || !isFinite(qt) || (At < Ne && (Ne = At), At > Ge && (Ge = At), qt < pe && (pe = qt), qt > Ve && (Ve = qt))
        }
      Ne === Ge && (Ne -= 1e-6, Ge += 1e-6), pe === Ve && (pe -= 1e-6, Ve += 1e-6), l.map.stop();
      const it = l.map.getCanvas(),
        yt = Math.max(48, Math.min(it.width, it.height) * .08);
      l.map.fitBounds([
        [Math.min(pe, Ve), Math.min(Ne, Ge)],
        [Math.max(pe, Ve), Math.max(Ne, Ge)]
      ], {
        padding: yt,
        duration: 0
      });
      const Lt = (async () => await Ap(l.map, {
        maxHeight: 1080,
        maxWidth: 1080,
        quality: .8,
        type: "image/jpeg"
      }))();
      l.onmodaction({
        action: Y,
        targets: Fe.map(te),
        image: Lt,
        latLon: [(Ne + Ge) / 2, (pe + Ve) / 2],
        zoom: l.map.getZoom(),
        onSuccess: async () => {
          await nr({
            preserveSelection: !0
          })
        }
      })
    } catch (Fe) {
      Bt.error(Fe.message)
    } finally {
      j(z, !1)
    }
  }
  var ne = br();
  Ci("keydown", qo, ie => ie.code === "Escape" && Jt());
  var oe = zt(ne);
  {
    var fe = ie => {
        Mc(ie, {
          class: "bg-warning animate-bounce",
          children: (Y, Fe) => {
            var Ne = P8(),
              Ge = zt(Ne);
            Gm(Ge, {
              class: "inline size-5"
            });
            var pe = E(Ge, 2);
            {
              var Ve = yt => {
                  var Lt = ja();
                  ke(ct => ee(Lt, ct), [() => n5()]), B(yt, Lt)
                },
                it = yt => {
                  var Lt = br(),
                    ct = zt(Lt);
                  {
                    var At = qt => {
                      var Ke = ja();
                      ke(Tt => ee(Ke, Tt), [() => o5()]), B(qt, Ke)
                    };
                    Te(ct, qt => {
                      _.length === 1 && qt(At)
                    }, !0)
                  }
                  B(yt, Lt)
                };
              Te(pe, yt => {
                _.length === 0 ? yt(Ve) : yt(it, !1)
              })
            }
            B(Y, Ne)
          },
          $$slots: {
            default: !0
          }
        })
      },
      ve = ie => {
        var Y = U8();
        let Fe;
        var Ne = P(Y),
          Ge = P(Ne),
          pe = P(Ge);
        pe.__pointerdown = Vt, Qn(pe, "", {}, {
          "touch-action": "none"
        });
        var Ve = P(pe),
          it = P(Ve),
          yt = P(it);
        Gm(yt, {
          class: "size-4"
        }), S(it);
        var Lt = E(it, 4),
          ct = P(Lt);
        S(Lt), S(Ve);
        var At = E(Ve, 2),
          qt = P(At),
          Ke = P(qt);
        Ke.__click = () => {
          j(F, h(F) !== !0)
        };
        var Tt = P(Ke);
        w8(Tt, {
          class: "h-4 w-4"
        });
        var Wt = E(Tt, 2);
        Ka(Wt), S(Ke);
        var Fr = E(Ke, 2);
        Fr.__click = J;
        var or = P(Fr);
        {
          var tt = Rr => {
              var ni = I8();
              B(Rr, ni)
            },
            Ht = Rr => {
              lg(Rr, {
                class: "size-4"
              })
            };
          Te(or, Rr => {
            h(s) ? Rr(tt) : Rr(Ht, !1)
          })
        }
        S(Fr), S(qt);
        var Qt = E(qt, 2);
        let Sr;
        Qt.__click = () => {
          if (h(Ee) === "brush-circle") {
            j(Ee, "area-select");
            return
          }
          if (h(k)) {
            Bt.info("Wait until the selected area finishes loading.");
            return
          }
          if (_.length < 2) {
            Bt.info("Select an area first to use the brush tools.");
            return
          }
          j(Ee, "brush-circle")
        };
        var ei = P(Qt);
        x8(ei, {
          class: "size-4"
        }), S(Qt);
        var li = E(Qt, 2);
        let Dr;
        li.__click = () => {
          if (h(Ee) === "brush-square") {
            j(Ee, "area-select");
            return
          }
          if (h(k)) {
            Bt.info("Wait until the selected area finishes loading.");
            return
          }
          if (_.length < 2) {
            Bt.info("Select an area first to use the brush tools.");
            return
          }
          j(Ee, "brush-square")
        };
        var Oi = P(li);
        S8(Oi, {
          class: "size-4"
        }), S(li);
        var Jr = E(li, 2);
        let It;
        Jr.__click = () => {
          if (h(Ee) === "user-picker") {
            j(Ee, "area-select");
            return
          }
          if (h(k)) {
            Bt.info("Wait until the selected area finishes loading.");
            return
          }
          if (_.length < 2) {
            Bt.info("Select an area first to use the user picker.");
            return
          }
          j(Ee, "user-picker")
        };
        var er = P(Jr);
        {
          var Pr = Rr => {
              var ni = M8();
              B(Rr, ni)
            },
            pr = Rr => {
              v8(Rr, {
                class: "size-4"
              })
            };
          Te(er, Rr => {
            h(Qe) ? Rr(Pr) : Rr(pr, !1)
          })
        }
        S(Jr);
        var qr = E(Jr, 2);
        qr.__click = Jt;
        var ur = P(qr);
        ss(ur, {
          class: "size-4"
        }), S(qr), S(At), S(pe);
        var Mr = E(pe, 2),
          di = P(Mr);
        {
          var ti = Rr => {
              var ni = C8();
              B(Rr, ni)
            },
            Vr = Rr => {
              var ni = br(),
                Ri = zt(ni);
              {
                var qi = Pt => {
                    var tr = A8();
                    B(Pt, tr)
                  },
                  ai = Pt => {
                    var tr = V8(),
                      Br = P(tr),
                      Zr = P(Br),
                      ci = P(Zr),
                      ui = P(ci),
                      pt = P(ui);
                    Ka(pt), pt.__click = gi => {
                      if (h(Pe) === "none") {
                        Ye.clear(), j(We, h(We) + 1), l.crosshair.clear();
                        const Cr = [];
                        for (const _i of h(x)) xe.has(_i.id) || (xe.set(_i.id, _i), Cr.push(_i));
                        Cr.length && St(Cr);
                        return
                      }
                      xe.clear(), Ye.clear(), j(We, h(We) + 1), l.crosshair.clear()
                    }, S(ui);
                    var kt = E(ui),
                      dr = E(P(kt));
                    dr.__click = () => {
                      navigator.clipboard.writeText([...xe.keys()].filter(gi => gi !== 0).join(", ")), Bt.success("Player IDs copied to clipboard")
                    };
                    var pi = P(dr);
                    ug(pi, {
                      class: "size-3"
                    }), S(dr);
                    var vi = E(dr, 2);
                    {
                      var Ji = gi => {
                        var Cr = k8();
                        Cr.__click = () => {
                          const Ar = _e();
                          Re(Ar, "timeout")
                        };
                        var _i = P(Cr);
                        $u(_i, {
                          class: "size-4"
                        }), S(Cr), ke(() => Cr.disabled = h(z)), B(gi, Cr)
                      };
                      Te(vi, gi => {
                        bt.hasPermission(Ba.tools.selectArea.timeout) && gi(Ji)
                      })
                    }
                    var Zi = E(vi, 2);
                    {
                      var Ei = gi => {
                        var Cr = z8();
                        Cr.__click = () => {
                          const Ar = _e();
                          Re(Ar, "ban")
                        };
                        var _i = P(Cr);
                        Pp(_i, {
                          class: "size-4"
                        }), S(Cr), ke(() => Cr.disabled = h(z)), B(gi, Cr)
                      };
                      Te(Zi, gi => {
                        bt.hasPermission(Ba.tools.selectArea.ban) && gi(Ei)
                      })
                    }
                    S(kt);
                    var ca = E(kt),
                      Ir = P(ca);
                    {
                      var wr = gi => {
                        var Cr = L8();
                        Cr.__click = se;
                        var _i = P(Cr);
                        {
                          var Ar = Xi => {
                              var Vi = E8();
                              B(Xi, Vi)
                            },
                            ri = Xi => {
                              hm(Xi, {
                                class: "size-4"
                              })
                            };
                          Te(_i, Xi => {
                            h(T) ? Xi(Ar) : Xi(ri, !1)
                          })
                        }
                        S(Cr), ke(() => Cr.disabled = h(T) || h(k) || xe.size === 0 && h(Se) === 0), B(gi, Cr)
                      };
                      Te(Ir, gi => {
                        bt.hasPermission(Ba.tools.selectArea.clear) && gi(wr)
                      })
                    }
                    wi(), S(ca), S(ci), S(Zr);
                    var Ai = E(Zr);
                    Hi(Ai, 23, () => h(x), gi => gi.id, (gi, Cr, _i, Ar) => {
                      const ri = Je(() => xe.has(h(Cr).id)),
                        Xi = Je(() => h(ze).get(h(Cr).id) ?? 0),
                        Vi = Je(() => h(ri) || h(Xi) > 0);
                      var Di = N8();
                      let ki;
                      Di.__click = () => {
                        h(ri) ? (xe.delete(h(Cr).id), Et(h(Cr).painted), vr(h(Cr).id, {
                          skipCrosshair: !0
                        })) : (vr(h(Cr).id, {
                          skipCrosshair: !0
                        }), xe.set(h(Cr).id, h(Cr)), (Lr(h(Cr)) || h(Cr).id === 0) && aa.plop.play())
                      };
                      var zi = P(Di),
                        yi = P(zi);
                      Ka(yi), S(zi);
                      var fi = E(zi),
                        tn = P(fi);
                      {
                        var Yi = pa => {
                            var Ia = D8();
                            wi(2), B(pa, Ia)
                          },
                          sa = pa => {
                            var Ia = j8(),
                              Na = zt(Ia);
                            bn(Na, {
                              class: "size-5 border-0",
                              get userId() {
                                return h(Cr).id
                              },
                              get pictureUrl() {
                                return h(Cr).picture
                              }
                            });
                            var Mi = E(Na, 2),
                              wn = P(Mi),
                              Ti = P(wn),
                              Si = P(Ti, !0);
                            S(Ti);
                            var Bn = E(Ti, 2),
                              Fi = P(Bn);
                            S(Bn), S(wn);
                            var On = E(wn, 2);
                            {
                              var Va = fa => {
                                var Ma = R8(),
                                  pn = P(Ma, !0);
                                S(Ma), ke((ma, Nn) => {
                                  Er(Ma, 1, `badge badge-sm ml-0.5 border-0 ${ma??""} ${Nn??""}`, "svelte-15blegn"), ee(pn, h(Cr).allianceName)
                                }, [() => Rp(h(Cr).allianceId), () => Dn(h(Cr).allianceId)]), B(fa, Ma)
                              };
                              Te(On, fa => {
                                h(Cr).allianceId && fa(Va)
                              })
                            }
                            var es = E(On, 2);
                            {
                              var jn = fa => {
                                var Ma = F8();
                                B(fa, Ma)
                              };
                              Te(es, fa => {
                                h(Cr).deleted && fa(jn)
                              })
                            }
                            var Tn = E(es, 2),
                              os = P(Tn);
                            {
                              var qn = fa => {
                                  var Ma = B8(),
                                    pn = P(Ma);
                                  Pp(pn, {
                                    class: "text-error size-4"
                                  }), S(Ma), ke(ma => Xt(Ma, "data-tip", ma), [() => og()]), B(fa, Ma)
                                },
                                ts = fa => {
                                  var Ma = br(),
                                    pn = zt(Ma);
                                  {
                                    var ma = Nn => {
                                      var Bs = O8(),
                                        yo = P(Bs);
                                      $u(yo, {
                                        class: "text-error size-4"
                                      }), S(Bs), ke(Ki => Xt(Bs, "data-tip", Ki), [() => V0()]), B(Nn, Bs)
                                    };
                                    Te(pn, Nn => {
                                      h(Cr).timedOut && Nn(ma)
                                    }, !0)
                                  }
                                  B(fa, Ma)
                                };
                              Te(os, fa => {
                                h(Cr).banned ? fa(qn) : fa(ts, !1)
                              })
                            }
                            S(Tn), S(Mi), ke(fa => {
                              Er(wn, 1, `font-medium ${fa??""} flex gap-1.5`, "svelte-15blegn"), ee(Si, h(Cr).name), ee(Fi, `#${h(Cr).id??""}`)
                            }, [() => Dn(h(Cr).id)]), B(pa, Ia)
                          };
                        Te(tn, pa => {
                          h(Cr).id === 0 ? pa(Yi) : pa(sa, !1)
                        })
                      }
                      S(fi);
                      var ua = E(fi),
                        Da = P(ua),
                        Pa = E(Da);
                      {
                        var ea = pa => {
                          var Ia = q8(),
                            Na = P(Ia);
                          S(Ia), ke(Mi => ee(Na, `(${Mi??""} selected)`), [() => h(Xi).toLocaleString(navigator.language)]), B(pa, Ia)
                        };
                        Te(Pa, pa => {
                          !h(ri) && h(Xi) > 0 && pa(ea)
                        })
                      }
                      S(ua), S(Di), ke(pa => {
                        ki = Er(Di, 1, "hover:bg-base-300 cursor-pointer svelte-15blegn", null, ki, {
                          "bg-base-200": h(Vi)
                        }), cm(yi, h(ri)), yi.indeterminate = !h(ri) && h(Xi) > 0, ee(Da, `${pa??""} `)
                      }, [() => h(Cr).painted.latitudes.length.toLocaleString(navigator.language)]), B(gi, Di)
                    }), S(Ai), S(Br), S(tr), ke(() => {
                      cm(pt, h(Pe) !== "none"), pt.indeterminate = h(Pe) === "some"
                    }), B(Pt, tr)
                  };
                Te(Ri, Pt => {
                  h(x).length === 0 ? Pt(qi) : Pt(ai, !1)
                }, !0)
              }
              B(Rr, ni)
            };
          Te(di, Rr => {
            h(k) ? Rr(ti) : Rr(Vr, !1)
          })
        }
        S(Mr), S(Ge), S(Ne), S(Y), Rn(Y, Rr => j(me, Rr), () => h(me)), ke((Rr, ni) => {
          Fe = Qn(Y, "", Fe, {
            transform: `translate3d(${q.x}px, ${q.y}px, 0)`,
            "will-change": "transform"
          }), ee(ct, `(Pixels: ${Rr??""})`), Xt(Wt, "aria-label", `${ni??""} toggle`), Xt(Fr, "data-tip", h(F) ? "Save selected map view" : "Save selected pixel art"), Fr.disabled = h(s) || h(k), Sr = Er(Qt, 1, "btn btn-xs tooltip tooltip-bottom svelte-15blegn", null, Sr, {
            "btn-soft": h(Ee) !== "brush-circle",
            "btn-primary": h(Ee) === "brush-circle"
          }), Xt(Qt, "data-tip", `Circle brush (Alt + scroll to resize)  Size: ${h(Me)}`), Xt(Qt, "aria-label", h(Ee) === "brush-circle" ? "Disable circle brush tool" : `Enable circle brush tool (size ${h(Me)})`), Xt(Qt, "aria-pressed", h(Ee) === "brush-circle"), Dr = Er(li, 1, "btn btn-xs tooltip tooltip-bottom svelte-15blegn", null, Dr, {
            "btn-soft": h(Ee) !== "brush-square",
            "btn-primary": h(Ee) === "brush-square"
          }), Xt(li, "data-tip", `Square brush (Alt + scroll to resize)  Size: ${h(Me)}`), Xt(li, "aria-label", h(Ee) === "brush-square" ? "Disable square brush tool" : `Enable square brush tool (size ${h(Me)})`), Xt(li, "aria-pressed", h(Ee) === "brush-square"), It = Er(Jr, 1, "btn btn-xs tooltip tooltip-bottom svelte-15blegn", null, It, {
            "btn-soft": h(Ee) !== "user-picker",
            "btn-primary": h(Ee) === "user-picker"
          }), Xt(Jr, "data-tip", h(Ee) === "user-picker" ? "User picker enabled. Click pixels to select their painter." : "Enable the user picker to select a player by clicking a pixel."), Xt(Jr, "aria-label", h(Ee) === "user-picker" ? "Disable user picker tool" : "Enable user picker tool"), Xt(Jr, "aria-pressed", h(Ee) === "user-picker")
        }, [() => h(Ae).toLocaleString(navigator.language), () => s5()]), bp(Wt, () => h(F), Rr => j(F, Rr)), dn(3, Ne, () => lp, () => ({
          duration: 100
        })), B(ie, Y)
      };
    Te(oe, ie => {
      _.length < 2 ? ie(fe) : ie(ve, !1)
    })
  }
  B(y, ne), Wr()
}
Ui(["pointerdown", "click"]);
var G8 = Yr('<svg><path d="M382-240 154-468l57-57 171 171 367-367 57 57-424 424Z"></path></svg>');

function wg(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = G8();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var W8 = Yr('<svg><path d="M791-55 686-160H160v-112q0-34 17.5-62.5T224-378q45-23 91.5-37t94.5-21L55-791l57-57 736 736-57 57ZM240-240h366L486-360h-6q-56 0-111 13.5T260-306q-9 5-14.5 14t-5.5 20v32Zm496-138q29 14 46 42.5t18 61.5L666-408q18 7 35.5 14t34.5 16ZM568-506l-59-59q23-9 37-29.5t14-45.5q0-33-23.5-56.5T480-720q-25 0-45.5 14T405-669l-59-59q23-34 58-53t76-19q66 0 113 47t47 113q0 41-19 76t-53 58Zm38 266H240h366ZM457-617Z"></path></svg>');

function H8(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = W8();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var X8 = Yr('<svg><path d="m233-120 65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Z"></path></svg>'),
  Y8 = Yr('<svg><path d="m354-287 126-76 126 77-33-144 111-96-146-13-58-136-58 135-146 13 111 97-33 143ZM233-120l65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Zm247-350Z"></path></svg>');

function K8(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy", "filled"]);
  var x = br(),
    k = zt(x);
  {
    var z = s => {
        var F = X8();
        jr(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ..._
        })), B(s, F)
      },
      T = s => {
        var F = Y8();
        jr(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ..._
        })), B(s, F)
      };
    Te(k, s => {
      l.filled ? s(z) : s(T, !1)
    })
  }
  B(y, x)
}
var J8 = ae('<div class="flex items-center gap-2"><div class="skeleton size-8 shrink-0 rounded-full"></div> <div class="flex flex-col gap-1"><div class="skeleton h-4 w-28"></div> <div class="skeleton h-3 w-20"></div></div></div>'),
  $8 = ae('<div class="flex items-center gap-2"><div class="bg-base-300 flex size-8 shrink-0 items-center justify-center rounded-full"><!></div> <div class="text-base-content/60 text-sm font-medium"> </div></div>'),
  Q8 = ae('<div class="flex items-center gap-2"><div class="bg-base-300 flex size-8 shrink-0 items-center justify-center rounded-full text-lg"></div> <div class="flex flex-col"><span class="text-sm font-semibold text-orange-500">Christmas</span> <span class="text-base-content/60 text-xs"> </span></div></div>'),
  ez = ae('<span class="font-flag tooltip text-sm"> </span>'),
  tz = ae('<span class="tooltip"><!></span>'),
  rz = ae('<span class="tooltip"><!></span>'),
  iz = ae("<button> <!></button>"),
  az = ae("<li><button><!> </button></li>"),
  nz = ae("<li><button><!> </button></li>"),
  sz = ae("<li><button><!> </button></li>"),
  oz = ae('<li><button class="text-error font-medium"><!> </button></li>'),
  lz = ae('<div class="dropdown dropdown-top dropdown-left shrink-0"><button tabindex="0" class="btn btn-xs btn-circle btn-ghost"><!></button> <ul tabindex="0" class="dropdown-content menu bg-base-100 z-1 mb-1 w-max gap-0.5 rounded-xl p-2.5 shadow-sm"></ul></div>'),
  cz = ae('<div class="flex items-center gap-2"><div class="shrink-0"><!></div> <div class="flex min-w-0 flex-1 flex-col gap-0.5"><div class="flex flex-wrap items-center gap-1"><!> <!> <!> <!> <!> <!></div></div> <!></div>'),
  uz = ae('<a target="_blank" class="shrink-0"><button class="btn btn-xs px-1.5"><!></button></a>'),
  hz = ae('<button><span class="font-flag tooltip shrink-0"> </span> <span class="max-w-20 truncate sm:max-w-28"> </span> <span class="shrink-0"> </span></button> <!>', 1),
  dz = ae('<div class="skeleton h-3 w-16"></div>'),
  pz = ae('<button class="btn btn-sm btn-primary"><!> </button>'),
  fz = ae("<!> ", 1),
  mz = ae("<!> ", 1),
  gz = ae('<button class="btn btn-sm btn-primary"><!></button>'),
  _z = ae("<button><!> </button>"),
  vz = ae('<div><div class="px-3 pb-1.5"><!></div> <div class="border-base-300 flex items-center justify-between gap-1.5 border-t px-3 py-1.5"><div class="flex min-w-0 grow items-center gap-1"><button class="btn btn-xs btn-circle btn-soft shrink-0"><!></button> <span class="text-base-content/70 shrink-0 text-xs"> </span> <!></div> <button class="btn btn-circle btn-xs shrink-0"><!></button></div> <div class="hide-scrollbar flex max-w-full gap-1.5 overflow-x-auto px-3 pt-1.5 pb-2"><!> <!> <button class="btn btn-sm btn-primary btn-soft"><!> </button></div></div>');

function yz(y, l) {
  Gr(l, !0);
  let _ = Xe(void 0);
  const x = Je(() => new kn(l.tileSize));
  let k = Xe(void 0),
    z = Xe(void 0),
    T = Xe(!1),
    s = Xe(!1);
  const F = Je(() => {
      var lt, ht, Dt;
      return !!((ht = (lt = h(_)) == null ? void 0 : lt.paintedBy) != null && ht.id) && ((Dt = bt.data) == null ? void 0 : Dt.id) === h(_).paintedBy.id
    }),
    Z = Je(() => {
      const [lt, ht] = l.latLon ?? [0, 0];
      return `https://wplace.eralyon.net/?lat=${lt}&lng=${ht}&zoom=${l.zoom}`
    }),
    K = Je(() => {
      const [lt, ht] = l.latLon ?? [0, 0], Dt = h(x).latLonToPixelBoundsLatLon(lt, ht, l.pixelArtZoom), Vt = dg(Dt), {
        tile: Jt,
        pixel: jt
      } = h(x).latLonToTileAndPixel(lt, ht, l.pixelArtZoom), nr = h(x).latLonToRegionAndPixel(lt, ht, l.pixelArtZoom);
      return {
        lat: lt,
        lon: ht,
        bounds: Dt,
        center: Vt,
        tile: Jt,
        pixel: jt,
        regionPixel: nr.pixel
      }
    });
  Qr(() => {
    aa.plop.play(), l.crosshair.clearAndPlace(l.latLon)
  });
  let G = 0;
  const re = ({
    pixel: lt,
    tile: ht,
    season: Dt
  }) => `s${Dt}:p(${lt[0]},${lt[1]}):t(${ht[0]},${ht[1]})`;
  let he;
  fo(() => [h(K), l.season], () => {
    const lt = {
      ...h(K),
      season: l.season
    };
    l.christmasTreeId !== void 0 && (lt.christmasTreeId = l.christmasTreeId);
    const ht = re(lt);
    if (j(_, l.pixelInfoCache.get(ht), !0), h(_) !== void 0) return;
    l.pixelInfoCache.size === 0 && (G = 0), G++, G > 6 ? (clearTimeout(he), he = setTimeout(async () => me(lt), 500)) : me(lt)
  });
  async function me(lt) {
    var Vt;
    const ht = await Kr.getPixelInfo({
      ...lt,
      role: (Vt = bt.data) == null ? void 0 : Vt.role,
      christmasTreeId: l.christmasTreeId
    });
    if (ht.paintedBy !== void 0) {
      const Jt = re(lt);
      l.pixelInfoCache.set(Jt, ht)
    }
    const Dt = re({
      ...h(K),
      season: l.season
    });
    return j(_, l.pixelInfoCache.get(Dt), !0), ht
  }
  Oa(() => () => {
    l.crosshair.clear(), aa.smallPlop.play()
  });
  const q = Je(() => {
    const lt = [];
    return bt.hasPermission(Ba.tools.selectPixel.ban) && lt.push("ban-user"), bt.hasPermission(Ba.tools.selectPixel.timeout) && lt.push("timeout-user"), !h(F) && bt.data && lt.push("report-user"), lt
  });

  function ye(lt) {
    const ht = (async () => await Ap(l.map, {
      maxHeight: 1080,
      maxWidth: 1080,
      quality: .8,
      type: "image/jpeg"
    }))();
    l.onclickmodaction(h(_), ht, l.latLon, lt)
  }
  async function be() {
    try {
      await Kr.claimEventPixel(l.christmasTreeId), await me({
        ...h(K),
        season: l.season
      }), await bt.refresh()
    } catch (lt) {
      Bt.error(lt.message)
    }
  }
  var qe = vz();
  Ci("keypress", qo, lt => {
    lt.key === "Escape" && l.onclose()
  });
  var xe = P(qe),
    Ye = P(xe);
  {
    var We = lt => {
        var ht = J8();
        B(lt, ht)
      },
      ze = lt => {
        var ht = br(),
          Dt = zt(ht);
        {
          var Vt = jt => {
              var nr = $8(),
                St = P(nr),
                Et = P(St);
              Vo(Et, {
                class: "text-base-content/40 size-4"
              }), S(St);
              var Ut = E(St, 2),
                Gt = P(Ut, !0);
              S(Ut), S(nr), ke(Rt => ee(Gt, Rt), [() => p5()]), B(jt, nr)
            },
            Jt = jt => {
              var nr = br(),
                St = zt(nr);
              {
                var Et = Gt => {
                    var Rt = Q8(),
                      ir = E(P(Rt), 2),
                      kr = E(P(ir), 2),
                      _r = P(kr, !0);
                    S(kr), S(ir), S(Rt), ke(fr => ee(_r, fr), [() => f5()]), B(Gt, Rt)
                  },
                  Ut = Gt => {
                    const Rt = Je(() => h(_).paintedBy);
                    var ir = cz(),
                      kr = P(ir),
                      _r = P(kr);
                    bn(_r, {
                      class: "size-8 border",
                      get userId() {
                        return h(Rt).id
                      },
                      get pictureUrl() {
                        return h(Rt).picture
                      },
                      get borderUrl() {
                        return h(Rt).equippedFrameUrl
                      }
                    }), S(kr);
                    var fr = E(kr, 2),
                      Yt = P(fr),
                      sr = P(Yt);
                    {
                      let ne = Je(() => {
                          var fe;
                          return ((fe = bt.data) == null ? void 0 : fe.id) === h(Rt).id ? bt.data.name ?? h(Rt).name : h(Rt).name
                        }),
                        oe = Je(() => {
                          var fe;
                          return ((fe = bt.data) == null ? void 0 : fe.id) === h(Rt).id ? bt.data.equippedNameCosmetic : h(Rt).equippedNameCosmetic
                        });
                      Bh(sr, {
                        get name() {
                          return h(ne)
                        },
                        get id() {
                          return h(Rt).id
                        },
                        get equippedNameCosmetic() {
                          return h(oe)
                        },
                        class: "text-sm font-medium"
                      })
                    }
                    var Kt = E(sr, 2);
                    {
                      var vr = ne => {
                        const oe = Je(() => Ds(h(Rt).equippedFlag));
                        var fe = ez(),
                          ve = P(fe, !0);
                        S(fe), ke(() => {
                          Xt(fe, "data-tip", h(oe).name), ee(ve, h(oe).flag)
                        }), B(ne, fe)
                      };
                      Te(Kt, ne => {
                        h(Rt).equippedFlag && ne(vr)
                      })
                    }
                    var Lr = E(Kt, 2);
                    {
                      var ii = ne => {
                        Fh(ne, {
                          get username() {
                            return h(Rt).discord
                          },
                          get id() {
                            return h(Rt).discordId
                          }
                        })
                      };
                      Te(Lr, ne => {
                        h(Rt).discord && ne(ii)
                      })
                    }
                    var mr = E(Lr, 2);
                    {
                      var ge = ne => {
                        N0(ne, {
                          get role() {
                            return h(Rt).role
                          },
                          big: !1
                        })
                      };
                      Te(mr, ne => {
                        h(Rt).role && h(Rt).role !== "user" && ne(ge)
                      })
                    }
                    var V = E(mr, 2);
                    {
                      var U = ne => {
                          var oe = tz(),
                            fe = P(oe);
                          Pp(fe, {
                            class: "text-error size-3.5"
                          }), S(oe), ke(ve => Xt(oe, "data-tip", ve), [() => og()]), B(ne, oe)
                        },
                        J = ne => {
                          var oe = br(),
                            fe = zt(oe);
                          {
                            var ve = ie => {
                              var Y = rz(),
                                Fe = P(Y);
                              $u(Fe, {
                                class: "text-error size-3.5"
                              }), S(Y), ke(Ne => Xt(Y, "data-tip", Ne), [() => V0()]), B(ie, Y)
                            };
                            Te(fe, ie => {
                              h(_).paintedBy.timedOut && ie(ve)
                            }, !0)
                          }
                          B(ne, oe)
                        };
                      Te(V, ne => {
                        h(_).paintedBy.banned ? ne(U) : ne(J, !1)
                      })
                    }
                    var se = E(V, 2);
                    {
                      var te = ne => {
                        var oe = iz();
                        oe.__click = () => {
                          var Y, Fe, Ne;
                          (((Y = bt.data) == null ? void 0 : Y.role) === "admin" || ((Fe = bt.data) == null ? void 0 : Fe.role) === "moderator" || ((Ne = bt.data) == null ? void 0 : Ne.role) === "global_moderator") && (navigator.clipboard.writeText(h(Rt).allianceId.toString()), Bt.success(eg()))
                        };
                        var fe = P(oe),
                          ve = E(fe);
                        {
                          var ie = Y => {
                            ug(Y, {
                              class: "size-3"
                            })
                          };
                          Te(ve, Y => {
                            var Fe, Ne, Ge;
                            (((Fe = bt.data) == null ? void 0 : Fe.role) === "admin" || ((Ne = bt.data) == null ? void 0 : Ne.role) === "moderator" || ((Ge = bt.data) == null ? void 0 : Ge.role) === "global_moderator") && Y(ie)
                          })
                        }
                        S(oe), ke((Y, Fe) => {
                          Er(oe, 1, `btn btn-xs gap-0.5 border-0 px-1.5 ${Y??""} ${Fe??""}`), ee(fe, `${h(Rt).allianceName??""} `)
                        }, [() => Rp(h(Rt).allianceId), () => Dn(h(Rt).allianceId)]), B(ne, oe)
                      };
                      Te(se, ne => {
                        h(Rt).allianceId && ne(te)
                      })
                    }
                    S(Yt), S(fr);
                    var _e = E(fr, 2);
                    {
                      var Re = ne => {
                        var oe = lz(),
                          fe = P(oe),
                          ve = P(fe);
                        vg(ve, {
                          class: "size-4"
                        }), S(fe);
                        var ie = E(fe, 2);
                        Hi(ie, 21, () => h(q), po, (Y, Fe) => {
                          var Ne = br(),
                            Ge = zt(Ne);
                          {
                            var pe = it => {
                                var yt = az(),
                                  Lt = P(yt);
                                let ct;
                                Lt.__click = () => {
                                  ye("report-user")
                                };
                                var At = P(Lt);
                                Zm(At, {
                                  class: "size-5"
                                });
                                var qt = E(At);
                                S(Lt), S(yt), ke(Ke => {
                                  ct = Er(Lt, 1, "py-2 font-medium text-red-300", null, ct, {
                                    "cursor-not-allowed": h(F)
                                  }), ee(qt, ` ${Ke??""}`)
                                }, [() => y3()]), B(it, yt)
                              },
                              Ve = it => {
                                var yt = br(),
                                  Lt = zt(yt);
                                {
                                  var ct = qt => {
                                      var Ke = nz(),
                                        Tt = P(Ke);
                                      let Wt;
                                      Tt.__click = () => {
                                        ye("timeout")
                                      };
                                      var Fr = P(Tt);
                                      $u(Fr, {
                                        class: "size-5"
                                      });
                                      var or = E(Fr);
                                      S(Tt), S(Ke), ke(tt => {
                                        Wt = Er(Tt, 1, "text-warning font-medium", null, Wt, {
                                          "cursor-not-allowed": h(F)
                                        }), ee(or, ` ${tt??""}`)
                                      }, [() => x3()]), B(qt, Ke)
                                    },
                                    At = qt => {
                                      var Ke = br(),
                                        Tt = zt(Ke);
                                      {
                                        var Wt = or => {
                                            var tt = sz(),
                                              Ht = P(tt);
                                            let Qt;
                                            Ht.__click = () => {
                                              ye("ban")
                                            };
                                            var Sr = P(Ht);
                                            Pp(Sr, {
                                              class: "size-5"
                                            });
                                            var ei = E(Sr);
                                            S(Ht), S(tt), ke(li => {
                                              Qt = Er(Ht, 1, "text-error font-medium", null, Qt, {
                                                "cursor-not-allowed": h(F)
                                              }), ee(ei, ` ${li??""}`)
                                            }, [() => b3()]), B(or, tt)
                                          },
                                          Fr = or => {
                                            var tt = br(),
                                              Ht = zt(tt);
                                            {
                                              var Qt = Sr => {
                                                var ei = oz(),
                                                  li = P(ei);
                                                li.__click = async () => {
                                                  j(s, !0);
                                                  try {
                                                    await Kr.banAllianceUser(h(Rt).id), await me({
                                                      ...h(K),
                                                      season: l.season
                                                    })
                                                  } catch (Jr) {
                                                    Bt.error(Jr.message)
                                                  } finally {
                                                    j(s, !1)
                                                  }
                                                };
                                                var Dr = P(li);
                                                H8(Dr, {
                                                  class: "size-5"
                                                });
                                                var Oi = E(Dr);
                                                S(li), S(ei), ke(Jr => ee(Oi, ` ${Jr??""}`), [() => y0()]), B(Sr, ei)
                                              };
                                              Te(Ht, Sr => {
                                                h(Fe) === "ban-alliance" && Sr(Qt)
                                              }, !0)
                                            }
                                            B(or, tt)
                                          };
                                        Te(Tt, or => {
                                          h(Fe) === "ban-user" ? or(Wt) : or(Fr, !1)
                                        }, !0)
                                      }
                                      B(qt, Ke)
                                    };
                                  Te(Lt, qt => {
                                    h(Fe) === "timeout-user" ? qt(ct) : qt(At, !1)
                                  }, !0)
                                }
                                B(it, yt)
                              };
                            Te(Ge, it => {
                              h(Fe) === "report-user" ? it(pe) : it(Ve, !1)
                            })
                          }
                          B(Y, Ne)
                        }), S(ie), S(oe), B(ne, oe)
                      };
                      Te(_e, ne => {
                        h(q).length > 0 && ne(Re)
                      })
                    }
                    S(ir), B(Gt, ir)
                  };
                Te(St, Gt => {
                  h(_).paintedBy.event ? Gt(Et) : Gt(Ut, !1)
                }, !0)
              }
              B(jt, nr)
            };
          Te(Dt, jt => {
            h(_).paintedBy.id === 0 ? jt(Vt) : jt(Jt, !1)
          }, !0)
        }
        B(lt, ht)
      };
    Te(Ye, lt => {
      h(_) === void 0 ? lt(We) : lt(ze, !1)
    })
  }
  S(xe);
  var Se = E(xe, 2),
    Pe = P(Se),
    Ae = P(Pe);
  Ae.__click = () => {
    if (h(k) && h(z)) {
      const lt = h(k) - h(z).clientHeight,
        ht = h(k) / 2 - lt / 2;
      l.map.flyTo({
        center: {
          lat: h(K).center[0],
          lng: h(K).center[1]
        },
        zoom: 17.5,
        offset: [0, -ht]
      })
    }
  };
  var Me = P(Ae);
  qp(Me, {
    class: "fill-primary size-4"
  }), S(Ae);
  var Ee = E(Ae, 2),
    Qe = P(Ee);
  S(Ee);
  var Ue = E(Ee, 2);
  {
    var je = lt => {
        const ht = Je(() => h(_).region),
          Dt = Je(() => Ds(h(ht).countryId));
        var Vt = hz(),
          Jt = zt(Vt);
        Jt.__click = () => l.onclickregion(h(ht));
        var jt = P(Jt),
          nr = P(jt, !0);
        S(jt);
        var St = E(jt, 2),
          Et = P(St, !0);
        S(St);
        var Ut = E(St, 2),
          Gt = P(Ut);
        S(Ut), S(Jt);
        var Rt = E(Jt, 2);
        {
          var ir = kr => {
            var _r = uz(),
              fr = P(_r),
              Yt = P(fr);
            Cy(Yt, {
              class: "size-3.5"
            }), S(fr), S(_r), ke(() => Xt(_r, "href", h(Z))), B(kr, _r)
          };
          Te(Rt, kr => {
            var _r;
            ((_r = bt.data) == null ? void 0 : _r.role) !== "user" && bt.hasPermission(Ba.tools.selectPixel.archive) && kr(ir)
          })
        }
        ke(kr => {
          Er(Jt, 1, `btn btn-xs flex min-w-0 gap-0.5 px-1.5 text-xs ${kr??""}`), Xt(jt, "data-tip", h(Dt).name), ee(nr, h(Dt).flag), ee(Et, h(ht).name), ee(Gt, `#${h(ht).number??""}`)
        }, [() => Dn(h(ht).cityId)]), B(lt, Vt)
      },
      rt = lt => {
        var ht = dz();
        B(lt, ht)
      };
    Te(Ue, lt => {
      var ht;
      (ht = h(_)) != null && ht.region ? lt(je) : lt(rt, !1)
    })
  }
  S(Pe);
  var _t = E(Pe, 2);
  _t.__click = function(...lt) {
    var ht;
    (ht = l.onclose) == null || ht.apply(this, lt)
  };
  var dt = P(_t);
  ss(dt, {
    class: "size-3.5"
  }), S(_t), S(Se);
  var at = E(Se, 2),
    nt = P(at);
  {
    var ot = lt => {
        var ht = pz();
        ht.__click = () => l.onclickpaint(l.latLon);
        var Dt = P(ht);
        Vo(Dt, {
          class: "size-4"
        });
        var Vt = E(Dt);
        S(ht), ke(Jt => {
          ht.disabled = bt.loading, ee(Vt, ` ${Jt??""}`)
        }, [() => S0()]), B(lt, ht)
      },
      ut = lt => {
        var ht = br(),
          Dt = zt(ht);
        {
          var Vt = Jt => {
            var jt = gz();
            jt.__click = () => be();
            var nr = P(jt);
            {
              var St = Ut => {
                  var Gt = fz(),
                    Rt = zt(Gt);
                  D3(Rt, {
                    class: "size-4"
                  });
                  var ir = E(Rt);
                  ke(kr => ee(ir, ` ${kr??""}`), [() => m5()]), B(Ut, Gt)
                },
                Et = Ut => {
                  var Gt = mz(),
                    Rt = zt(Gt);
                  wg(Rt, {
                    class: "size-4"
                  });
                  var ir = E(Rt);
                  ke(kr => ee(ir, ` ${kr??""}`), [() => g5()]), B(Ut, Gt)
                };
              Te(nr, Ut => {
                h(_).paintedBy.claimed ? Ut(St) : Ut(Et, !1)
              })
            }
            S(jt), ke(() => jt.disabled = bt.loading || h(_).paintedBy.claimed), B(Jt, jt)
          };
          Te(Dt, Jt => {
            bt.data && h(_).paintedBy.eventClaimNumber && Jt(Vt)
          }, !0)
        }
        B(lt, ht)
      };
    Te(nt, lt => {
      var ht;
      (ht = h(_)) != null && ht.paintedBy.event ? lt(ut, !1) : lt(ot)
    })
  }
  var st = E(nt, 2);
  {
    var wt = lt => {
      const ht = Je(() => bt.data.favoriteLocations.find(St => Math.abs(St.latitude - h(K).center[0]) < 5e-5 && Math.abs(St.longitude - h(K).center[1]) < 5e-5)),
        Dt = Je(() => !h(ht) && bt.data.favoriteLocations.length >= bt.data.maxFavoriteLocations);
      var Vt = _z();
      let Jt;
      Vt.__click = async () => {
        try {
          j(T, !0), h(ht) ? (await Kr.deleteFavoriteLocation(h(ht).id), Bt.warning(c5())) : (await Kr.favoriteLocation(h(K).center), Bt.success(u5())), aa.smallPlop.play(), bt.refresh()
        } catch (St) {
          Bt.error(St.message)
        } finally {
          j(T, !1)
        }
      };
      var jt = P(Vt);
      {
        let St = Je(() => !!h(ht));
        K8(jt, {
          class: "size-4",
          get filled() {
            return h(St)
          }
        })
      }
      var nr = E(jt);
      S(Vt), ke(St => {
        Jt = Er(Vt, 1, "btn btn-sm btn-primary btn-soft", null, Jt, {
          "text-yellow-400": !!h(ht)
        }), Vt.disabled = h(T) || h(Dt), ee(nr, ` ${St??""}`)
      }, [() => h(Dt) ? h5() : d5()]), B(lt, Vt)
    };
    Te(st, lt => {
      bt.data && lt(wt)
    })
  }
  var Ct = E(st, 2);
  Ct.__click = () => l.onclickshare(aT(xa.url, {
    pos: {
      lat: h(K).center[0],
      lng: h(K).center[1]
    },
    zoom: l.zoom
  }));
  var rr = P(Ct);
  hy(rr, {
    class: "size-4"
  });
  var Zt = E(rr);
  S(Ct), S(at), S(qe), Rn(qe, lt => j(z, lt), () => h(z)), ke(lt => {
    ee(Qe, `${h(K).regionPixel[0]??""}, ${h(K).regionPixel[1]??""}`), ee(Zt, ` ${lt??""}`)
  }, [() => l5()]), Eh("innerHeight", lt => j(k, lt, !0)), B(y, qe), Wr()
}
Ui(["click"]);

function xz(y) {
  var x;
  const l = document.createElement("div");
  (x = y.parentElement) == null || x.insertBefore(l, y.nextSibling);
  const _ = new IntersectionObserver(k => {
    k[0].isIntersecting ? y.classList.remove("stuck") : y.classList.add("stuck")
  }, {
    threshold: 0,
    rootMargin: "0px"
  });
  return _.observe(l), () => {
    l.remove(), _.disconnect()
  }
}
var Wm;
(y => {
  function l() {
    let _, x;
    return {
      promise: new Promise((z, T) => {
        _ = z, x = T
      }),
      resolve: _,
      reject: x
    }
  }
  y.withResolvers = l
})(Wm || (Wm = {}));
var bz = Yr('<svg><path d="M200-120v-680h360l16 80h224v400H520l-16-80H280v280h-80Z"></path></svg>'),
  wz = Yr('<svg><path d="M200-120v-680h360l16 80h224v400H520l-16-80H280v280h-80Zm300-440Zm86 160h134v-240H510l-16-80H280v240h290l16 80Z"></path></svg>');

function Tz(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy", "filled"]);
  var x = br(),
    k = zt(x);
  {
    var z = s => {
        var F = bz();
        jr(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ..._
        })), B(s, F)
      },
      T = s => {
        var F = wz();
        jr(F, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ..._
        })), B(s, F)
      };
    Te(k, s => {
      l.filled ? s(z) : s(T, !1)
    })
  }
  B(y, x)
}
var Sz = ae("<p><!></p>"),
  Pz = ae('<span class="loading loading-spinner center-absolute absolute"></span>'),
  Iz = ae('<span class="text-sm"> </span>'),
  Mz = ae(' <span class="text-sm">Droplets</span>', 1),
  Cz = ae('<button class="btn btn-lg sm:btn-md btn-primary relative h-10"><!> <!> <!></button>'),
  Az = ae('<span class="loading loading-spinner center-absolute absolute"></span>'),
  kz = ae('<!> <span class="text-sm"> </span>', 1),
  zz = ae('<span class="text-sm"> </span>'),
  Ez = ae('<button><div class="tooltip-content max-w-54 p-2"> </div> <!> <!></button>'),
  Lz = ae('<div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="font-flag flex grow items-center justify-center p-1 text-7xl"> </div> <h3 class="mt-2 text-center text-xl font-bold"> <!></h3> <!> <div><!></div></div>'),
  Dz = ae('<div><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <p class="text-base-content/80 text-sm"> </p> <div class="grid-cols mt-3 grid gap-3 sm:grid-cols-2 lg:grid-cols-4"></div> <div class="mt-4 flex justify-center"><button class="btn btn-lg"> </button></div></div>');

function Rz(y, l) {
  Gr(l, !0);
  const _ = (ze, Se = $n, Pe = $n) => {
      const Ae = Je(() => {
          var Zt;
          return (((Zt = bt.data) == null ? void 0 : Zt.droplets) ?? 0) >= s.price
        }),
        Me = Je(() => h(Z) === Se().id),
        Ee = Je(() => x.has(Se().id));
      var Qe = Lz(),
        Ue = P(Qe),
        je = P(Ue, !0);
      S(Ue);
      var rt = E(Ue, 2),
        _t = P(rt),
        dt = E(_t);
      {
        var at = Zt => {
          var lt = Sz(),
            ht = P(lt);
          th(ht, {
            class: "text-base-content/60 size-4.5 inline pb-0.5"
          }), S(lt), ke(Dt => {
            Er(lt, 1, _l({
              "tooltip inline": !0,
              "lg:before:-translate-x-1/3": (Pe() + 1) % 4 === 0,
              "lg:before:translate-x-1/3": Pe() % 4 === 0,
              "before:-translate-x-1/3": (Pe() + 1) % 2 === 0,
              "before:translate-x-1/3": Pe() % 2 === 0
            })), Xt(lt, "data-tip", Dt)
          }, [() => b5()]), B(Zt, lt)
        };
        Te(dt, Zt => {
          h(Ee) && Zt(at)
        })
      }
      S(rt);
      var nt = E(rt, 2);
      {
        var ot = Zt => {
          bg(Zt, {})
        };
        Te(nt, Zt => {
          Se().id === h(K) && Zt(ot)
        })
      }
      var ut = E(nt, 2);
      let st;
      var wt = P(ut);
      {
        var Ct = Zt => {
            var lt = Cz();
            lt.__click = async () => {
              if (!(h(Ee) && !await l.promptUserConfirmation(Se().label))) try {
                const St = Se().id;
                j(Z, St, !0), await Kr.purchase({
                  id: T,
                  amount: 1,
                  variant: St
                }), bt.refresh(), aa.notification1.play();
                const Et = z.find(Ut => Ut.id === St);
                Et && (Et.owned = !0), j(K, St, !0)
              } catch (St) {
                Bt.error(St.message)
              } finally {
                j(Z, void 0)
              }
            };
            var ht = P(lt);
            {
              var Dt = St => {
                var Et = Pz();
                B(St, Et)
              };
              Te(ht, St => {
                h(Me) && St(Dt)
              })
            }
            var Vt = E(ht, 2);
            Dp(Vt, {
              class: "size-4"
            });
            var Jt = E(Vt, 2);
            {
              var jt = St => {
                  var Et = Iz(),
                    Ut = P(Et, !0);
                  S(Et), ke(Gt => ee(Ut, Gt), [() => T5()]), B(St, Et)
                },
                nr = St => {
                  var Et = Mz(),
                    Ut = zt(Et);
                  wi(), ke(Gt => ee(Ut, `${Gt??""} `), [() => s.price.toLocaleString(navigator.language)]), B(St, Et)
                };
              Te(Jt, St => {
                var Et;
                (Et = bt.data) != null && Et.freeFlag ? St(jt) : St(nr, !1)
              })
            }
            S(lt), ke(() => {
              var St;
              return lt.disabled = !h(Ae) && ((St = bt.data) == null ? void 0 : St.freeFlag) == !1 || h(Me)
            }), B(Zt, lt)
          },
          rr = Zt => {
            const lt = Je(() => {
              var Gt;
              return ((Gt = bt.data) == null ? void 0 : Gt.equippedFlag) === Se().id
            });
            var ht = Ez();
            let Dt;
            ht.__click = async () => {
              try {
                j(Z, Se().id, !0);
                const Gt = h(lt) ? 0 : Se().id;
                await Kr.equipFlag(Gt), bt.data && (bt.data.equippedFlag = Gt), bt.refresh()
              } catch (Gt) {
                Bt.error(Gt.message)
              } finally {
                j(Z, void 0)
              }
            };
            var Vt = P(ht),
              Jt = P(Vt, !0);
            S(Vt);
            var jt = E(Vt, 2);
            {
              var nr = Gt => {
                var Rt = Az();
                B(Gt, Rt)
              };
              Te(jt, Gt => {
                h(Me) && Gt(nr)
              })
            }
            var St = E(jt, 2);
            {
              var Et = Gt => {
                  var Rt = kz(),
                    ir = zt(Rt);
                  ss(ir, {
                    class: "size-4"
                  });
                  var kr = E(ir, 2),
                    _r = P(kr, !0);
                  S(kr), ke(fr => ee(_r, fr), [() => Rc()]), B(Gt, Rt)
                },
                Ut = Gt => {
                  var Rt = zz(),
                    ir = P(Rt, !0);
                  S(Rt), ke(kr => ee(ir, kr), [() => jp()]), B(Gt, Rt)
                };
              Te(St, Gt => {
                h(lt) ? Gt(Et) : Gt(Ut, !1)
              })
            }
            S(ht), ke(Gt => {
              Dt = Er(ht, 1, "btn btn-lg sm:btn-md tooltip tooltip-bottom relative h-10", null, Dt, {
                "btn-warning": h(lt)
              }), ht.disabled = h(Me), ee(Jt, Gt)
            }, [() => w5()]), B(Zt, ht)
          };
        Te(wt, Zt => {
          Se().owned ? Zt(rr, !1) : Zt(Ct)
        })
      }
      S(ut), S(Qe), ke(Zt => {
        var lt;
        ee(je, Se().flag), ee(_t, `${Se().label??""} `), st = Er(ut, 1, "mt-3", null, st, {
          tooltip: !h(Ae) && !Se().owned && ((lt = bt.data) == null ? void 0 : lt.freeFlag) == !1
        }), Xt(ut, "data-tip", Zt)
      }, [() => Op()]), B(ze, Qe)
    },
    x = new Set([8, 30, 32, 84, 96, 125, 143, 146, 150, 192, 200, 236, 240, 251]),
    k = xn.countries.map(ze => {
      var Se, Pe;
      return {
        ...ze,
        owned: bt.flagsBitmap.get(ze.id),
        label: ((Pe = (Se = d3)[ze.code]) == null ? void 0 : Pe.call(Se)) ?? ze.name
      }
    });
  k.sort((ze, Se) => Number(Se.owned) - Number(ze.owned));
  const z = Wi(k),
    T = 110,
    s = xn.products[T];
  let F = Xe(!1),
    Z = Xe(void 0),
    K = Xe(void 0);
  var G = Dz(),
    re = P(G),
    he = P(re);
  Tz(he, {
    class: "size-5.5",
    filled: !0
  });
  var me = E(he, 2),
    q = P(me, !0);
  S(me), S(re);
  var ye = E(re, 2),
    be = P(ye, !0);
  S(ye);
  var qe = E(ye, 2);
  Hi(qe, 23, () => z, ze => ze.id, (ze, Se, Pe) => {
    var Ae = br(),
      Me = zt(Ae);
    {
      var Ee = Qe => {
        _(Qe, () => h(Se), () => h(Pe))
      };
      Te(Me, Qe => {
        (h(Pe) < 8 || h(F)) && Qe(Ee)
      })
    }
    B(ze, Ae)
  }), S(qe);
  var xe = E(qe, 2),
    Ye = P(xe);
  Ye.__click = () => {
    j(F, !h(F))
  };
  var We = P(Ye, !0);
  S(Ye), S(xe), S(G), ke((ze, Se, Pe) => {
    ee(q, ze), ee(be, Se), ee(We, Pe)
  }, [() => _5(), () => v5(), () => h(F) ? y5() : x5()]), B(y, G), Wr()
}
Ui(["click"]);
var Fz = ae('<p class="mt-1 text-center text-sm"> </p>'),
  Bz = ae('<button class="text-base-content/80 absolute top-1/2 left-full ml-2 size-10 -translate-y-1/2 rounded-full text-[10px] font-bold">MAX</button>'),
  Oz = ae('<span class="loading loading-spinner center-absolute absolute"></span>'),
  jz = ae('<div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><!></div> <p class="mt-2 text-center text-2xl font-bold sm:text-3xl"> </p> <!> <div class="relative mt-4 flex justify-center gap-3"><button class="btn btn-circle">-</button> <input class="input number-input max-w-16 text-center font-bold opacity-80" type="number" min="1"/> <button class="btn btn-circle">+</button> <!></div> <div><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <!> <span class="text-sm"> </span></button></div></div>');

function c0(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "amount", 15, 1);
  const x = Je(() => _() * l.unitPrice),
    k = Je(() => Math.floor(l.userDroplets / l.unitPrice));
  let z = Xe(!1);
  Qr(() => {
    _() < 0 && _(0)
  });
  var T = jz(),
    s = P(T),
    F = P(s);
  La(F, () => l.icon ?? $n), S(s);
  var Z = E(s, 2),
    K = P(Z, !0);
  S(Z);
  var G = E(Z, 2);
  {
    var re = Qe => {
      var Ue = Fz(),
        je = P(Ue, !0);
      S(Ue), ke(() => ee(je, l.subtitle)), B(Qe, Ue)
    };
    Te(G, Qe => {
      l.subtitle && Qe(re)
    })
  }
  var he = E(G, 2),
    me = P(he);
  me.__click = () => {
    vv(_, -1)
  };
  var q = E(me, 2);
  Ka(q);
  var ye = E(q, 2);
  ye.__click = () => {
    vv(_)
  };
  var be = E(ye, 2);
  {
    var qe = Qe => {
      var Ue = Bz();
      Ue.__click = () => {
        _(h(k))
      }, B(Qe, Ue)
    };
    Te(be, Qe => {
      _() < h(k) && Qe(qe)
    })
  }
  S(he);
  var xe = E(he, 2);
  let Ye;
  var We = P(xe);
  We.__click = async () => {
    try {
      j(z, !0), await Kr.purchase({
        id: l.productId,
        amount: _()
      }), aa.notification1.play(), l.onpurchasecompleted(_())
    } catch (Qe) {
      Bt.error(Qe.message)
    } finally {
      j(z, !1)
    }
  };
  var ze = P(We);
  {
    var Se = Qe => {
      var Ue = Oz();
      B(Qe, Ue)
    };
    Te(ze, Qe => {
      h(z) && Qe(Se)
    })
  }
  var Pe = E(ze, 2);
  Dp(Pe, {
    class: "size-4"
  });
  var Ae = E(Pe),
    Me = E(Ae),
    Ee = P(Me, !0);
  S(Me), S(We), S(xe), S(T), ke((Qe, Ue, je, rt) => {
    ee(K, Qe), ye.disabled = _() >= h(k), Xt(xe, "data-tip", Ue), Ye = Er(xe, 1, "", null, Ye, {
      tooltip: l.userDroplets < h(x)
    }), We.disabled = l.userDroplets < h(x) || h(z) || !_(), ee(Ae, ` ${je??""} `), ee(Ee, rt)
  }, [() => l.title(_()), () => Op(), () => h(x).toLocaleString(navigator.language), () => Sp()]), Tl(q, _), B(y, T), Wr()
}
Ui(["click"]);
var qz = Yr('<svg><path d="M346-140 100-386q-10-10-15-22t-5-25q0-13 5-25t15-22l230-229-106-106 62-65 400 400q10 10 14.5 22t4.5 25q0 13-4.5 25T686-386L440-140q-10 10-22 15t-25 5q-13 0-25-5t-22-15Zm47-506L179-432h428L393-646Zm399 526q-36 0-61-25.5T706-208q0-27 13.5-51t30.5-47l42-54 44 54q16 23 30 47t14 51q0 37-26 62.5T792-120Z"></path></svg>');

function Nz(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = qz();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var Vz = Yr('<svg><path d="M280-80q-33 0-56.5-23.5T200-160q0-33 23.5-56.5T280-240q33 0 56.5 23.5T360-160q0 33-23.5 56.5T280-80Zm400 0q-33 0-56.5-23.5T600-160q0-33 23.5-56.5T680-240q33 0 56.5 23.5T760-160q0 33-23.5 56.5T680-80ZM246-720l96 200h280l110-200H246Zm-38-80h590q23 0 35 20.5t1 41.5L692-482q-11 20-29.5 31T622-440H324l-44 80h480v80H280q-45 0-68-39.5t-2-78.5l54-98-144-304H40v-80h130l38 80Zm134 280h280-280Z"></path></svg>');

function Fy(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = Vz();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var Uz = Yr('<svg><path d="m700-300-57-56 84-84H120v-80h607l-83-84 57-56 179 180-180 180Z"></path></svg>');

function Zz(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = Uz();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var Gz = Yr('<svg><path d="M280-160v-80h400v80H280Zm160-160v-327L336-544l-56-56 200-200 200 200-56 56-104-103v327h-80Z"></path></svg>');

function Wz(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = Gz();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var Hz = ae('<button type="button"> </button>'),
  Xz = ae('<img alt="" class="pixelated absolute size-14 translate-x-[-20px] translate-y-[0px] rotate-[-12deg] rounded object-cover opacity-70 transition-all duration-300 ease-out group-hover:translate-x-[-38px] group-hover:translate-y-[-16px] group-hover:scale-110 group-hover:rotate-[-20deg] group-hover:opacity-90"/>'),
  Yz = ae('<img alt="" class="pixelated absolute size-14 translate-x-[-10px] translate-y-[0px] rotate-[0deg] rounded object-cover opacity-85 transition-all duration-300 ease-out group-hover:translate-x-[-4px] group-hover:translate-y-[-20px] group-hover:scale-110 group-hover:rotate-[2deg] group-hover:opacity-95"/>'),
  Kz = ae('<img alt="" class="pixelated absolute size-14 translate-x-[0px] translate-y-[0px] rotate-[8deg] rounded object-cover transition-all duration-300 ease-out group-hover:translate-x-[20px] group-hover:translate-y-[-14px] group-hover:scale-115 group-hover:rotate-[14deg]"/>'),
  Jz = ae('<div class="group absolute top-2 right-2"><span class="absolute -top-6 -left-[-20px] flex h-16 w-20 items-center justify-center"><!> <!> <!></span> <button type="button" class="btn relative z-10 cursor-pointer"><span> </span> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="size-4"><path fill-rule="evenodd" d="M3 10a.75.75 0 01.75-.75h10.638L10.23 5.29a.75.75 0 111.04-1.08l5.5 5.25a.75.75 0 010 1.08l-5.5 5.25a.75.75 0 11-1.04-1.08l4.158-3.96H3.75A.75.75 0 013 10z" clip-rule="evenodd"></path></svg></button></div>'),
  $z = ae('<div><div class="mb-3 flex flex-wrap gap-2"></div> <div class="bg-base-300 relative min-h-0 flex-1 rounded-xl p-4"><!> <!></div></div>');

function Qz(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "class", 3, ""),
    x = Xe(0);
  var k = $z(),
    z = P(k);
  Hi(z, 21, () => l.tabs, po, (G, re, he) => {
    var me = Hz();
    me.__click = () => j(x, he, !0);
    var q = P(me, !0);
    S(me), ke(() => {
      Er(me, 1, `btn btn-sm rounded-full transition-colors
					${h(x)===he?"btn-primary":"btn-ghost bg-base-200 text-base-content/70 hover:bg-base-200/80"}`), ee(q, h(re).title)
    }), B(G, me)
  }), S(z);
  var T = E(z, 2),
    s = P(T);
  {
    var F = G => {
      const re = Je(() => l.tabs[h(x)].previewImages ?? []);
      var he = Jz(),
        me = P(he),
        q = P(me);
      {
        var ye = Pe => {
          var Ae = Xz();
          ke(() => Xt(Ae, "src", h(re)[2])), B(Pe, Ae)
        };
        Te(q, Pe => {
          h(re).length >= 3 && Pe(ye)
        })
      }
      var be = E(q, 2);
      {
        var qe = Pe => {
          var Ae = Yz();
          ke(() => Xt(Ae, "src", h(re)[1])), B(Pe, Ae)
        };
        Te(be, Pe => {
          h(re).length >= 2 && Pe(qe)
        })
      }
      var xe = E(be, 2);
      {
        var Ye = Pe => {
          var Ae = Kz();
          ke(() => Xt(Ae, "src", h(re)[0])), B(Pe, Ae)
        };
        Te(xe, Pe => {
          h(re).length >= 1 && Pe(Ye)
        })
      }
      S(me);
      var We = E(me, 2);
      We.__click = function(...Pe) {
        var Ae;
        (Ae = l.tabs[h(x)].onViewAll) == null || Ae.apply(this, Pe)
      };
      var ze = P(We),
        Se = P(ze, !0);
      S(ze), wi(2), S(We), S(he), ke(Pe => ee(Se, Pe), [() => {
        var Pe;
        return ((Pe = S5) == null ? void 0 : Pe()) ?? "View all"
      }]), B(G, he)
    };
    Te(s, G => {
      var re;
      (re = l.tabs[h(x)]) != null && re.onViewAll && G(F)
    })
  }
  var Z = E(s, 2);
  {
    var K = G => {
      var re = br(),
        he = zt(re);
      La(he, () => l.tabs[h(x)].content), B(G, re)
    };
    Te(Z, G => {
      l.tabs[h(x)] && G(K)
    })
  }
  S(T), S(k), ke(() => Er(k, 1, `flex min-h-0 flex-col ${_()??""}`)), B(y, k), Wr()
}
Ui(["click"]);
var eE = ae('<div class="size-16 sm:size-24"><img class="size-full object-cover"/></div>'),
  tE = ae('<span class="badge badge-secondary absolute -top-2 -right-2 text-[10px] font-bold" aria-label="New"> </span>'),
  rE = ae('<button type="button"><div class="relative"><!> <!></div></button>'),
  iE = ae('<button class="btn btn-primary btn-wide" disabled> </button>'),
  aE = ae('<span class="loading loading-spinner loading-sm"></span>'),
  nE = ae('<button class="btn btn-primary btn-wide"><!> </button>'),
  sE = ae('<span class="loading loading-spinner loading-sm"></span>'),
  oE = ae('<span class="text-lg font-bold"> </span> <span class="text-sm"> </span>', 1),
  lE = ae('<button class="btn btn-primary btn-wide"><!></button>'),
  cE = ae('<div class="flex flex-col items-center gap-3 pb-2"><span class="text-base-content text-lg font-semibold"> </span> <!></div>'),
  uE = ae('<div class="text-base-content/60 flex flex-col items-center gap-3 pb-2 text-sm"> </div>'),
  hE = ae('<div class="mt-4 flex h-full flex-col gap-10"><div class="flex flex-1 items-center justify-center gap-4 py-4"><button type="button" class="btn btn-circle btn-primary btn-sm shrink-0" aria-label="Previous frame"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="size-5"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path></svg></button> <div class="flex items-center justify-center gap-2 sm:gap-6"></div> <button type="button" class="btn btn-circle btn-primary btn-sm shrink-0" aria-label="Next frame"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="size-5"><path d="M8.59 16.59L10 18l6-6-6-6-1.41 1.41L13.17 12z"></path></svg></button></div> <!></div>');

function By(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "selectedIndex", 15, 0),
    x = Ot(l, "loading", 3, !1);
  const z = 7 * 24 * 60 * 60 * 1e3;

  function T(We) {
    if (!We) return !1;
    const ze = Date.parse(We);
    return Number.isNaN(ze) ? !1 : Date.now() - ze <= z
  }

  function s() {
    var We;
    l.frames.length !== 0 && (_((_() - 1 + l.frames.length) % l.frames.length), (We = l.onselect) == null || We.call(l, _()))
  }

  function F() {
    var We;
    l.frames.length !== 0 && (_((_() + 1) % l.frames.length), (We = l.onselect) == null || We.call(l, _()))
  }

  function Z() {
    if (l.frames.length === 0) return [];
    if (l.frames.length === 1) return [{
      frame: l.frames[0],
      position: "center"
    }];
    if (l.frames.length === 2) return [{
      frame: l.frames[(_() - 1 + l.frames.length) % l.frames.length],
      position: "left"
    }, {
      frame: l.frames[_()],
      position: "center"
    }];
    const We = (_() - 1 + l.frames.length) % l.frames.length,
      ze = (_() + 1) % l.frames.length;
    return [{
      frame: l.frames[We],
      position: "left"
    }, {
      frame: l.frames[_()],
      position: "center"
    }, {
      frame: l.frames[ze],
      position: "right"
    }]
  }
  const K = Je(() => l.frames[_()]),
    G = Je(() => {
      var We;
      return ((We = h(K)) == null ? void 0 : We.id) === l.equippedFrameId
    }),
    re = Je(() => {
      var We;
      return l.userDroplets >= (((We = h(K)) == null ? void 0 : We.value) ?? 0)
    });
  var he = hE(),
    me = P(he),
    q = P(me);
  q.__click = s;
  var ye = E(q, 2);
  Hi(ye, 21, Z, ({
    frame: We,
    position: ze
  }) => We.id, (We, ze) => {
    let Se = () => h(ze).frame,
      Pe = () => h(ze).position;
    var Ae = rE();
    Ae.__click = () => {
      Pe() === "left" ? s() : Pe() === "right" && F()
    };
    var Me = P(Ae),
      Ee = P(Me);
    {
      var Qe = _t => {
          {
            let dt = Je(() => l.pictureUrl ?? void 0);
            bn(_t, {
              class: "size-28 sm:size-36",
              get userId() {
                return l.userId
              },
              get pictureUrl() {
                return h(dt)
              },
              get borderUrl() {
                return Se().imageUrl
              }
            })
          }
        },
        Ue = _t => {
          var dt = eE(),
            at = P(dt);
          S(dt), ke(() => {
            Xt(at, "src", Se().imageUrl), Xt(at, "alt", Se().name)
          }), B(_t, dt)
        };
      Te(Ee, _t => {
        Pe() === "center" ? _t(Qe) : _t(Ue, !1)
      })
    }
    var je = E(Ee, 2);
    {
      var rt = _t => {
        var dt = tE(),
          at = P(dt, !0);
        S(dt), ke(nt => ee(at, nt), [() => C0()]), B(_t, dt)
      };
      Te(je, _t => {
        T(Se().createdAt) && _t(rt)
      })
    }
    S(Me), S(Ae), ke(() => {
      Er(Ae, 1, `flex flex-col items-center transition-all duration-200
						${Pe()==="center"?"scale-100 opacity-100":"scale-75 opacity-60"}`), Ae.disabled = Pe() === "center" || x()
    }), B(We, Ae)
  }), S(ye);
  var be = E(ye, 2);
  be.__click = F, S(me);
  var qe = E(me, 2);
  {
    var xe = We => {
        var ze = cE(),
          Se = P(ze),
          Pe = P(Se, !0);
        S(Se);
        var Ae = E(Se, 2);
        {
          var Me = Qe => {
              var Ue = iE(),
                je = P(Ue, !0);
              S(Ue), ke(rt => ee(je, rt), [() => {
                var rt;
                return ((rt = Rc) == null ? void 0 : rt()) ?? "Equipped"
              }]), B(Qe, Ue)
            },
            Ee = Qe => {
              var Ue = br(),
                je = zt(Ue);
              {
                var rt = dt => {
                    var at = nE();
                    at.__click = () => {
                      var st;
                      return (st = l.onequip) == null ? void 0 : st.call(l, h(K))
                    };
                    var nt = P(at);
                    {
                      var ot = st => {
                        var wt = aE();
                        B(st, wt)
                      };
                      Te(nt, st => {
                        x() && st(ot)
                      })
                    }
                    var ut = E(nt);
                    S(at), ke(st => {
                      at.disabled = x(), ee(ut, ` ${st??""}`)
                    }, [() => {
                      var st;
                      return ((st = jp) == null ? void 0 : st()) ?? "Equip"
                    }]), B(dt, at)
                  },
                  _t = dt => {
                    var at = lE();
                    at.__click = () => {
                      var st;
                      return (st = l.onbuy) == null ? void 0 : st.call(l, h(K))
                    };
                    var nt = P(at);
                    {
                      var ot = st => {
                          var wt = sE();
                          B(st, wt)
                        },
                        ut = st => {
                          var wt = oE(),
                            Ct = zt(wt),
                            rr = P(Ct, !0);
                          S(Ct);
                          var Zt = E(Ct, 2),
                            lt = P(Zt, !0);
                          S(Zt), ke((ht, Dt) => {
                            ee(rr, ht), ee(lt, Dt)
                          }, [() => {
                            var ht, Dt;
                            return ((Dt = (ht = h(K).value) == null ? void 0 : ht.toLocaleString) == null ? void 0 : Dt.call(ht, navigator.language)) ?? h(K).value
                          }, () => Sp()]), B(st, wt)
                        };
                      Te(nt, st => {
                        x() ? st(ot) : st(ut, !1)
                      })
                    }
                    S(at), ke(() => at.disabled = x() || !h(re)), B(dt, at)
                  };
                Te(je, dt => {
                  h(K).owned ? dt(rt) : dt(_t, !1)
                }, !0)
              }
              B(Qe, Ue)
            };
          Te(Ae, Qe => {
            h(G) ? Qe(Me) : Qe(Ee, !1)
          })
        }
        S(ze), ke(() => ee(Pe, h(K).name)), B(We, ze)
      },
      Ye = We => {
        var ze = uE(),
          Se = P(ze, !0);
        S(ze), ke(Pe => ee(Se, Pe), [() => {
          var Pe;
          return ((Pe = E0) == null ? void 0 : Pe()) ?? "No frames available"
        }]), B(We, ze)
      };
    Te(qe, We => {
      h(K) ? We(xe) : We(Ye, !1)
    })
  }
  S(he), ke(() => {
    q.disabled = l.frames.length <= 1 || x(), be.disabled = l.frames.length <= 1 || x()
  }), B(y, he), Wr()
}
Ui(["click"]);
var dE = ae('<button type="button"><div><img class="pixelated size-full object-cover"/></div></button>'),
  pE = ae('<span class="loading loading-spinner loading-sm"></span>'),
  fE = ae('<span class="text-lg font-bold"> </span> <span class="text-sm">droplets</span>', 1),
  mE = ae('<span class="text-base-content text-lg font-semibold"> </span> <a href="/profile-picture"><button class="btn btn-primary btn-wide"><!></button></a>', 1),
  gE = ae('<span class="text-base-content text-lg font-semibold"> </span> <button class="btn btn-primary btn-wide" disabled> </button>', 1),
  _E = ae('<span class="loading loading-spinner loading-sm"></span>'),
  vE = ae('<span class="text-base-content text-lg font-semibold"> </span> <button class="btn btn-primary btn-wide"><!> </button>', 1),
  yE = ae('<div class="flex flex-col items-center gap-3 pb-2"><!></div>'),
  xE = ae('<div class="text-base-content/60 flex flex-col items-center gap-3 pb-2 text-sm"> </div>'),
  bE = ae('<div class="mt-4 flex h-full flex-col gap-10"><div class="flex flex-1 items-center justify-center gap-4 py-4"><button type="button" class="btn btn-circle btn-primary btn-sm shrink-0" aria-label="Previous picture"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="size-5"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path></svg></button> <div class="flex items-center justify-center gap-2 sm:gap-6"></div> <button type="button" class="btn btn-circle btn-primary btn-sm shrink-0" aria-label="Next picture"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="size-5"><path d="M8.59 16.59L10 18l6-6-6-6-1.41 1.41L13.17 12z"></path></svg></button></div> <!></div>');

function wE(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "selectedIndex", 15, 0),
    x = Ot(l, "loading", 3, !1);
  const k = "https://f.feridinha.com/OLcaa.png",
    z = Je(() => [...l.pictures, {
      id: -1,
      url: k,
      isAddNew: !0
    }]);

  function T() {
    var ze;
    h(z).length !== 0 && (_((_() - 1 + h(z).length) % h(z).length), (ze = l.onselect) == null || ze.call(l, _()))
  }

  function s() {
    var ze;
    h(z).length !== 0 && (_((_() + 1) % h(z).length), (ze = l.onselect) == null || ze.call(l, _()))
  }

  function F() {
    if (h(z).length === 0) return [];
    if (h(z).length === 1) return [{
      item: h(z)[0],
      position: "center"
    }];
    if (h(z).length === 2) return [{
      item: h(z)[(_() - 1 + h(z).length) % h(z).length],
      position: "left"
    }, {
      item: h(z)[_()],
      position: "center"
    }];
    const ze = (_() - 1 + h(z).length) % h(z).length,
      Se = (_() + 1) % h(z).length;
    return [{
      item: h(z)[ze],
      position: "left"
    }, {
      item: h(z)[_()],
      position: "center"
    }, {
      item: h(z)[Se],
      position: "right"
    }]
  }

  function Z(ze) {
    return "isAddNew" in ze && ze.isAddNew === !0
  }
  const K = Je(() => h(z)[_()]),
    G = Je(() => h(K) ? Z(h(K)) : !1),
    re = Je(() => !h(G) && h(K) && h(K).url === l.equippedPictureUrl),
    he = Je(() => l.userDroplets >= l.newPicturePrice);
  var me = bE(),
    q = P(me),
    ye = P(q);
  ye.__click = T;
  var be = E(ye, 2);
  Hi(be, 21, F, ({
    item: ze,
    position: Se
  }) => ze.id, (ze, Se) => {
    let Pe = () => h(Se).item,
      Ae = () => h(Se).position;
    var Me = dE();
    Me.__click = () => {
      Ae() === "left" ? T() : Ae() === "right" && s()
    };
    var Ee = P(Me),
      Qe = P(Ee);
    S(Ee), S(Me), ke(Ue => {
      Er(Me, 1, `flex flex-col items-center transition-all duration-200
						${Ae()==="center"?"scale-100 opacity-100":"scale-75 opacity-60"}`), Me.disabled = Ae() === "center" || x(), Er(Ee, 1, `overflow-hidden rounded-full border-2 border-base-300 bg-base-200
							${Ae()==="center"?"size-28 sm:size-36":"size-16 sm:size-24"}`), Xt(Qe, "src", Pe().url), Xt(Qe, "alt", Ue)
    }, [() => Z(Pe()) ? "Add new picture" : "Profile picture"]), B(ze, Me)
  }), S(be);
  var qe = E(be, 2);
  qe.__click = s, S(q);
  var xe = E(q, 2);
  {
    var Ye = ze => {
        var Se = yE(),
          Pe = P(Se);
        {
          var Ae = Ee => {
              var Qe = mE(),
                Ue = zt(Qe),
                je = P(Ue, !0);
              S(Ue);
              var rt = E(Ue, 2),
                _t = P(rt);
              _t.__click = () => {
                var ot;
                return (ot = l.onaddnew) == null ? void 0 : ot.call(l)
              };
              var dt = P(_t);
              {
                var at = ot => {
                    var ut = pE();
                    B(ot, ut)
                  },
                  nt = ot => {
                    var ut = fE(),
                      st = zt(ut),
                      wt = P(st, !0);
                    S(st), wi(2), ke(Ct => ee(wt, Ct), [() => l.newPicturePrice.toLocaleString(navigator.language)]), B(ot, ut)
                  };
                Te(dt, ot => {
                  x() ? ot(at) : ot(nt, !1)
                })
              }
              S(_t), S(rt), ke(ot => {
                ee(je, ot), _t.disabled = x() || !h(he)
              }, [() => I5()]), B(Ee, Qe)
            },
            Me = Ee => {
              var Qe = br(),
                Ue = zt(Qe);
              {
                var je = _t => {
                    var dt = gE(),
                      at = zt(dt),
                      nt = P(at, !0);
                    S(at);
                    var ot = E(at, 2),
                      ut = P(ot, !0);
                    S(ot), ke((st, wt) => {
                      ee(nt, st), ee(ut, wt)
                    }, [() => M5(), () => {
                      var st;
                      return ((st = Rc) == null ? void 0 : st()) ?? "Equipped"
                    }]), B(_t, dt)
                  },
                  rt = _t => {
                    var dt = vE(),
                      at = zt(dt),
                      nt = P(at, !0);
                    S(at);
                    var ot = E(at, 2);
                    ot.__click = () => {
                      var Ct;
                      return (Ct = l.onequip) == null ? void 0 : Ct.call(l, h(K))
                    };
                    var ut = P(ot);
                    {
                      var st = Ct => {
                        var rr = _E();
                        B(Ct, rr)
                      };
                      Te(ut, Ct => {
                        x() && Ct(st)
                      })
                    }
                    var wt = E(ut);
                    S(ot), ke((Ct, rr) => {
                      ee(nt, Ct), ot.disabled = x(), ee(wt, ` ${rr??""}`)
                    }, [() => D0(), () => {
                      var Ct;
                      return ((Ct = jp) == null ? void 0 : Ct()) ?? "Equip"
                    }]), B(_t, dt)
                  };
                Te(Ue, _t => {
                  h(re) ? _t(je) : _t(rt, !1)
                }, !0)
              }
              B(Ee, Qe)
            };
          Te(Pe, Ee => {
            h(G) ? Ee(Ae) : Ee(Me, !1)
          })
        }
        S(Se), B(ze, Se)
      },
      We = ze => {
        var Se = xE(),
          Pe = P(Se, !0);
        S(Se), ke(Ae => ee(Pe, Ae), [() => P5()]), B(ze, Se)
      };
    Te(xe, ze => {
      h(K) ? ze(Ye) : ze(We, !1)
    })
  }
  S(me), ke(() => {
    ye.disabled = h(z).length <= 1 || x(), qe.disabled = h(z).length <= 1 || x()
  }), B(y, me), Wr()
}
Ui(["click"]);
var TE = ae('<button class="btn btn-primary min-w-32 rounded-full text-sm sm:min-w-40 sm:text-base"> </button>'),
  SE = ae('<button class="btn btn-primary min-w-32 rounded-full text-sm sm:min-w-40 sm:text-base"> </button>'),
  PE = ae('<div class="mx-auto flex w-full max-w-4xl flex-col gap-6 px-4 sm:gap-10"><div class="flex flex-col items-center gap-3"><h4 class="text-base-content/70 text-sm font-semibold"> </h4> <div class="flex w-full items-center justify-center gap-2 text-center sm:gap-4"><button class="btn btn-circle btn-primary btn-sm flex-shrink-0"><!></button> <div class="grid w-full max-w-[280px] grid-cols-[1fr_auto_1fr] items-center gap-2 sm:max-w-[400px] sm:gap-4 md:max-w-[500px]"><span class="text-base-content/40 truncate text-right text-xs sm:text-sm"> </span> <span class="px-2 text-center text-lg font-bold whitespace-nowrap sm:text-2xl md:text-3xl"> </span> <span class="text-base-content/40 truncate text-left text-xs sm:text-sm"> </span></div> <button class="btn btn-circle btn-primary btn-sm flex-shrink-0"><!></button></div> <!></div> <div class="flex flex-col items-center gap-3"><h4 class="text-base-content/70 text-sm font-semibold"> </h4> <div class="flex w-full items-center justify-center gap-2 text-center sm:gap-4"><button class="btn btn-circle btn-primary btn-sm shrink-0"><!></button> <div class="grid w-full max-w-[280px] grid-cols-[1fr_auto_1fr] items-center gap-2 sm:max-w-[400px] sm:gap-4 md:max-w-[500px]"><span class="text-base-content/40 truncate text-right text-xs sm:text-sm"> </span> <span class="px-2 text-center text-lg font-bold whitespace-nowrap sm:text-2xl md:text-3xl"> </span> <span class="text-base-content/40 truncate text-left text-xs sm:text-sm"> </span></div> <button class="btn btn-circle btn-primary btn-sm shrink-0"><!></button></div> <!></div></div>');

function IE(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "selectedFontIndex", 15, 0),
    x = Ot(l, "selectedStyleIndex", 15, 0),
    k = Ot(l, "loading", 3, !1);

  function z() {
    _((_() - 1 + l.fonts.length) % l.fonts.length)
  }

  function T() {
    _((_() + 1) % l.fonts.length)
  }

  function s() {
    x((x() - 1 + l.styles.length) % l.styles.length)
  }

  function F() {
    x((x() + 1) % l.styles.length)
  }
  const Z = Je(() => l.fonts[_()]),
    K = Je(() => l.styles[x()]),
    G = Je(() => {
      var Et;
      return ((Et = h(Z)) == null ? void 0 : Et.id) === l.equippedFontId
    }),
    re = Je(() => {
      var Et;
      return ((Et = h(K)) == null ? void 0 : Et.id) === l.equippedStyleId
    }),
    he = Je(() => {
      var Et;
      return l.userDroplets >= (((Et = h(Z)) == null ? void 0 : Et.price) ?? 0)
    }),
    me = Je(() => {
      var Et;
      return l.userDroplets >= (((Et = h(K)) == null ? void 0 : Et.price) ?? 0)
    });

  function q(Et) {
    return (Et == null ? void 0 : Et.text) ?? ""
  }
  var ye = PE(),
    be = P(ye),
    qe = P(be),
    xe = P(qe, !0);
  S(qe);
  var Ye = E(qe, 2),
    We = P(Ye);
  We.__click = z;
  var ze = P(We);
  ho(ze, {
    class: "size-4 -rotate-90 sm:size-5"
  }), S(We);
  var Se = E(We, 2),
    Pe = P(Se),
    Ae = P(Pe, !0);
  S(Pe);
  var Me = E(Pe, 2),
    Ee = P(Me, !0);
  S(Me);
  var Qe = E(Me, 2),
    Ue = P(Qe, !0);
  S(Qe), S(Se);
  var je = E(Se, 2);
  je.__click = T;
  var rt = P(je);
  ho(rt, {
    class: "size-4 rotate-90 sm:size-5"
  }), S(je), S(Ye);
  var _t = E(Ye, 2);
  {
    var dt = Et => {
      var Ut = TE();
      Ut.__click = () => {
        var Rt;
        return (Rt = l.onbuyFont) == null ? void 0 : Rt.call(l, h(Z))
      };
      var Gt = P(Ut, !0);
      S(Ut), ke(Rt => {
        Ut.disabled = k() || h(G) || !h(he) || h(Z).owned, ee(Gt, Rt)
      }, [() => h(G) ? Rc() : h(Z).owned ? Iv() : `${h(Z).price.toLocaleString()} ${Sp()}`]), B(Et, Ut)
    };
    Te(_t, Et => {
      h(Z) && Et(dt)
    })
  }
  S(be);
  var at = E(be, 2),
    nt = P(at),
    ot = P(nt, !0);
  S(nt);
  var ut = E(nt, 2),
    st = P(ut);
  st.__click = s;
  var wt = P(st);
  ho(wt, {
    class: "size-4 -rotate-90 sm:size-5"
  }), S(st);
  var Ct = E(st, 2),
    rr = P(Ct),
    Zt = P(rr, !0);
  S(rr);
  var lt = E(rr, 2),
    ht = P(lt, !0);
  S(lt);
  var Dt = E(lt, 2),
    Vt = P(Dt, !0);
  S(Dt), S(Ct);
  var Jt = E(Ct, 2);
  Jt.__click = F;
  var jt = P(Jt);
  ho(jt, {
    class: "size-4 rotate-90 sm:size-5"
  }), S(Jt), S(ut);
  var nr = E(ut, 2);
  {
    var St = Et => {
      var Ut = SE();
      Ut.__click = () => {
        var Rt;
        return (Rt = l.onbuyStyle) == null ? void 0 : Rt.call(l, h(K))
      };
      var Gt = P(Ut, !0);
      S(Ut), ke(Rt => {
        Ut.disabled = k() || h(re) || !h(me) || h(K).owned, ee(Gt, Rt)
      }, [() => h(re) ? Rc() : h(K).owned ? Iv() : `${h(K).price.toLocaleString()} ${Sp()}`]), B(Et, Ut)
    };
    Te(nr, Et => {
      h(K) && Et(St)
    })
  }
  S(at), S(ye), ke((Et, Ut, Gt, Rt) => {
    var ir, kr, _r, fr;
    ee(xe, Et), ee(Ae, (ir = l.fonts[(_() - 1 + l.fonts.length) % l.fonts.length]) == null ? void 0 : ir.name), Qn(Me, Ut), ee(Ee, l.userName), ee(Ue, (kr = l.fonts[(_() + 1) % l.fonts.length]) == null ? void 0 : kr.name), ee(ot, Gt), ee(Zt, (_r = l.styles[(x() - 1 + l.styles.length) % l.styles.length]) == null ? void 0 : _r.name), Qn(lt, Rt), ee(ht, l.userName), ee(Vt, (fr = l.styles[(x() + 1) % l.styles.length]) == null ? void 0 : fr.name)
  }, [() => C5(), () => q(h(Z)), () => A5(), () => q(h(K)) + q(h(Z))]), B(y, ye), Wr()
}
Ui(["click"]);
var ME = ae('<span class="badge badge-secondary absolute -top-2 -right-2 text-[10px] font-bold" aria-label="New"> </span>'),
  CE = ae('<button class="btn btn-sm btn-primary w-full" disabled> </button>'),
  AE = ae('<span class="loading loading-spinner loading-xs"></span>'),
  kE = ae('<button class="btn btn-sm btn-primary w-full"><!> </button>'),
  zE = ae('<span class="loading loading-spinner loading-xs"></span>'),
  EE = ae('<!> <span class="text-xs font-bold"> </span>', 1),
  LE = ae('<div><button class="btn btn-sm btn-primary w-full"><!></button></div>'),
  DE = ae('<button type="button"><div class="relative"><!> <!></div> <h3 class="mt-2 mt-8 line-clamp-2 text-center text-xs font-semibold sm:text-sm"> </h3> <div class="mt-2 w-full"><!></div></button>');

function RE(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "loading", 3, !1),
    x = Ot(l, "isNew", 3, !1),
    k = Ot(l, "isSelected", 3, !1);
  var z = DE();
  z.__click = function(...ye) {
    var be;
    (be = l.onclick) == null || be.apply(this, ye)
  };
  var T = P(z),
    s = P(T);
  {
    let ye = Je(() => l.pictureUrl ?? void 0);
    bn(s, {
      class: "size-18 sm:size-22",
      get userId() {
        return l.userId
      },
      get pictureUrl() {
        return h(ye)
      },
      get borderUrl() {
        return l.frameUrl
      }
    })
  }
  var F = E(s, 2);
  {
    var Z = ye => {
      var be = ME(),
        qe = P(be, !0);
      S(be), ke(xe => ee(qe, xe), [() => {
        var xe;
        return ((xe = C0) == null ? void 0 : xe()) ?? "New"
      }]), B(ye, be)
    };
    Te(F, ye => {
      x() && ye(Z)
    })
  }
  S(T);
  var K = E(T, 2),
    G = P(K, !0);
  S(K);
  var re = E(K, 2),
    he = P(re);
  {
    var me = ye => {
        var be = CE(),
          qe = P(be, !0);
        S(be), ke(xe => ee(qe, xe), [() => {
          var xe;
          return ((xe = Rc) == null ? void 0 : xe()) ?? "Equipped"
        }]), B(ye, be)
      },
      q = ye => {
        var be = br(),
          qe = zt(be);
        {
          var xe = We => {
              var ze = kE();
              ze.__click = Me => {
                var Ee;
                Me.stopPropagation(), (Ee = l.onequip) == null || Ee.call(l)
              };
              var Se = P(ze);
              {
                var Pe = Me => {
                  var Ee = AE();
                  B(Me, Ee)
                };
                Te(Se, Me => {
                  _() && Me(Pe)
                })
              }
              var Ae = E(Se);
              S(ze), ke(Me => {
                ze.disabled = _(), ee(Ae, ` ${Me??""}`)
              }, [() => {
                var Me;
                return ((Me = jp) == null ? void 0 : Me()) ?? "Equip"
              }]), B(We, ze)
            },
            Ye = We => {
              var ze = LE();
              let Se;
              var Pe = P(ze);
              Pe.__click = Qe => {
                var Ue;
                Qe.stopPropagation(), (Ue = l.onbuy) == null || Ue.call(l)
              };
              var Ae = P(Pe);
              {
                var Me = Qe => {
                    var Ue = zE();
                    B(Qe, Ue)
                  },
                  Ee = Qe => {
                    var Ue = EE(),
                      je = zt(Ue);
                    Dp(je, {
                      class: "size-3"
                    });
                    var rt = E(je, 2),
                      _t = P(rt, !0);
                    S(rt), ke(dt => ee(_t, dt), [() => l.framePrice.toLocaleString(navigator.language)]), B(Qe, Ue)
                  };
                Te(Ae, Qe => {
                  _() ? Qe(Me) : Qe(Ee, !1)
                })
              }
              S(Pe), S(ze), ke(Qe => {
                Xt(ze, "data-tip", Qe), Se = Er(ze, 1, "", null, Se, {
                  tooltip: !l.canAfford
                }), Pe.disabled = _() || !l.canAfford
              }, [() => Op()]), B(We, ze)
            };
          Te(qe, We => {
            l.isOwned ? We(xe) : We(Ye, !1)
          }, !0)
        }
        B(ye, be)
      };
    Te(he, ye => {
      l.isEquipped ? ye(me) : ye(q, !1)
    })
  }
  S(re), S(z), ke(() => {
    Er(z, 1, `bg-base-200 hover:bg-base-300 flex h-full w-full flex-col items-center justify-between rounded-xl px-4 pt-8 pb-4 transition-all
		${k()?"ring-primary ring-2":""}`), z.disabled = _(), ee(G, l.frameName)
  }), B(y, z), Wr()
}
Ui(["click"]);
var FE = ae('<div class="text-base-content/60 flex flex-col items-center justify-center py-12 text-sm"> </div>'),
  BE = ae('<div class="flex flex-col"><div class="mb-4 flex items-center gap-2"><button type="button" class="btn btn-ghost btn-sm gap-1"><!> </button> <h2 class="text-lg font-semibold"> </h2></div> <div class="bg-base-300 mb-4 shrink-0 rounded-xl p-4"><!></div> <div><div class="grid grid-cols-2 gap-2 px-1 pb-4 sm:grid-cols-3 sm:gap-3 md:grid-cols-4"></div> <!></div></div>');

function OE(y, l) {
  Gr(l, !0);
  let _ = Ot(l, "loading", 3, !1),
    x = Ot(l, "loadingFrameId", 3, null),
    k = Xe(0);
  const T = 7 * 24 * 60 * 60 * 1e3;

  function s(Ae) {
    if (!Ae) return !1;
    const Me = Date.parse(Ae);
    return Number.isNaN(Me) ? !1 : Date.now() - Me <= T
  }

  function F(Ae) {
    j(k, Ae, !0)
  }

  function Z(Ae, Me) {
    var Ee;
    j(k, Me, !0), (Ee = l.onbuy) == null || Ee.call(l, Ae)
  }

  function K(Ae) {
    var Me;
    (Me = l.onbuy) == null || Me.call(l, Ae)
  }

  function G(Ae) {
    var Me;
    (Me = l.onequip) == null || Me.call(l, Ae)
  }
  var re = BE(),
    he = P(re),
    me = P(he);
  me.__click = function(...Ae) {
    var Me;
    (Me = l.onback) == null || Me.apply(this, Ae)
  };
  var q = P(me);
  sg(q, {
    class: "size-4"
  });
  var ye = E(q);
  S(me);
  var be = E(me, 2),
    qe = P(be, !0);
  S(be), S(he);
  var xe = E(he, 2),
    Ye = P(xe);
  By(Ye, {
    get frames() {
      return l.frames
    },
    get equippedFrameId() {
      return l.equippedFrameId
    },
    get userDroplets() {
      return l.userDroplets
    },
    get userId() {
      return l.userId
    },
    get pictureUrl() {
      return l.pictureUrl
    },
    get loading() {
      return _()
    },
    onbuy: K,
    onequip: G,
    get selectedIndex() {
      return h(k)
    },
    set selectedIndex(Ae) {
      j(k, Ae, !0)
    }
  }), S(xe);
  var We = E(xe, 2),
    ze = P(We);
  Hi(ze, 23, () => l.frames, Ae => Ae.id, (Ae, Me, Ee) => {
    const Qe = Je(() => h(Me).id === l.equippedFrameId),
      Ue = Je(() => l.userDroplets >= (h(Me).value ?? 0)),
      je = Je(() => h(Ee) === h(k)),
      rt = Je(() => _() && x() === h(Me).id);
    {
      let _t = Je(() => h(Me).value ?? 0),
        dt = Je(() => s(h(Me).createdAt));
      RE(Ae, {
        get userId() {
          return l.userId
        },
        get pictureUrl() {
          return l.pictureUrl
        },
        get frameUrl() {
          return h(Me).imageUrl
        },
        get frameName() {
          return h(Me).name
        },
        get framePrice() {
          return h(_t)
        },
        get isOwned() {
          return h(Me).owned
        },
        get isEquipped() {
          return h(Qe)
        },
        get canAfford() {
          return h(Ue)
        },
        get isSelected() {
          return h(je)
        },
        get loading() {
          return h(rt)
        },
        get isNew() {
          return h(dt)
        },
        onclick: () => F(h(Ee)),
        onbuy: () => Z(h(Me), h(Ee)),
        onequip: () => {
          var at;
          return (at = l.onequip) == null ? void 0 : at.call(l, h(Me))
        }
      })
    }
  }), S(ze);
  var Se = E(ze, 2);
  {
    var Pe = Ae => {
      var Me = FE(),
        Ee = P(Me, !0);
      S(Me), ke(Qe => ee(Ee, Qe), [() => E0()]), B(Ae, Me)
    };
    Te(Se, Ae => {
      l.frames.length === 0 && Ae(Pe)
    })
  }
  S(We), S(re), ke((Ae, Me) => {
    ee(ye, ` ${Ae??""}`), ee(qe, Me)
  }, [() => {
    var Ae;
    return ((Ae = c3) == null ? void 0 : Ae()) ?? "Back"
  }, () => {
    var Ae;
    return ((Ae = u3) == null ? void 0 : Ae()) ?? "All Frames"
  }]), B(y, re), Wr()
}
Ui(["click"]);
var jE = ae('<div class="flex flex-col gap-6 px-6 pb-6"><section><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <p class="text-base-content/80 text-sm"> </p> <div class="mt-3 grid gap-3 sm:grid-cols-2"><!> <!></div></section> <section><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <div class="mt-3"><!></div></section> <section><!></section></div>'),
  qE = ae('<div class="flex flex-col px-6 pb-6"><!></div>'),
  NE = ae('<div><section class="not-stuck:border-transparent stuck:border-base-content/10 bg-base-100/70 sticky top-0 z-10 border-b px-6 pt-6 pb-4 backdrop-blur-sm"><div class="relative flex items-center gap-1"><!> <h3 class="text-3xl font-bold"> </h3> <div class="mr-4 ml-auto"><!></div> <form method="dialog" class="absolute -top-4 -right-4"><button class="btn btn-sm btn-circle btn-ghost"></button></form></div></section> <!></div>'),
  VE = ae('<span class="center-absolute absolute"><!></span>'),
  UE = ae('<dialog class="modal" closedby="any"><div class="modal-box max-h-11/12 w-11/12 max-w-4xl p-0"><!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog> <dialog class="modal"><div class="modal-box w-max overflow-hidden"><div class="flex flex-col items-center gap-6 px-4"><h2 class="text-lg font-semibold"> </h2> <div class="flex items-center gap-2 text-3xl sm:text-5xl"><span class="text-base-content/80 flex items-center gap-2"> <span class="text-primary text-3xl font-semibold max-sm:hidden"> </span></span> <span><!></span> <span class="text-primary flex font-bold"> </span></div> <form method="dialog"><button class="btn btn-primary btn-lg relative"> <!></button></form></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog> <dialog class="modal"><div class="modal-box w-max overflow-hidden"><h3 class="mb-2 text-lg font-bold"> </h3> <p class="text-sm opacity-80"><!></p> <div class="mt-5 flex justify-end gap-2"><button class="btn btn-ghost"> </button> <button class="btn btn-primary"> </button></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>', 1);

function ZE(y, l) {
  Gr(l, !0);
  const _ = fe => {
      {
        let ve = Je(() => {
            var Ne;
            return (Ne = bt.data) == null ? void 0 : Ne.equippedFrameId
          }),
          ie = Je(() => {
            var Ne;
            return ((Ne = bt.data) == null ? void 0 : Ne.droplets) ?? 0
          }),
          Y = Je(() => {
            var Ne;
            return ((Ne = bt.data) == null ? void 0 : Ne.id) ?? 0
          }),
          Fe = Je(() => {
            var Ne;
            return (Ne = bt.data) == null ? void 0 : Ne.picture
          });
        By(fe, {
          get frames() {
            return h(z)
          },
          get equippedFrameId() {
            return h(ve)
          },
          get userDroplets() {
            return h(ie)
          },
          get userId() {
            return h(Y)
          },
          get pictureUrl() {
            return h(Fe)
          },
          get loading() {
            return h(s)
          },
          onbuy: Qe,
          onequip: Ue,
          get selectedIndex() {
            return h(T)
          },
          set selectedIndex(Ne) {
            j(T, Ne, !0)
          }
        })
      }
    },
    x = fe => {
      {
        let ve = Je(() => {
            var Fe;
            return (Fe = bt.data) == null ? void 0 : Fe.picture
          }),
          ie = Je(() => {
            var Fe;
            return ((Fe = bt.data) == null ? void 0 : Fe.droplets) ?? 0
          }),
          Y = Je(() => {
            var Fe;
            return ((Fe = bt.data) == null ? void 0 : Fe.id) ?? 0
          });
        wE(fe, {
          get pictures() {
            return h(K)
          },
          get equippedPictureUrl() {
            return h(ve)
          },
          get userDroplets() {
            return h(ie)
          },
          get newPicturePrice() {
            return Se.product.price
          },
          get userId() {
            return h(Y)
          },
          get loading() {
            return h(re)
          },
          onequip: je,
          get selectedIndex() {
            return h(G)
          },
          set selectedIndex(Fe) {
            j(G, Fe, !0)
          }
        })
      }
    },
    k = fe => {
      {
        let ve = Je(() => {
            var Ne, Ge;
            return ((Ge = (Ne = bt.data) == null ? void 0 : Ne.equippedNameCosmetic) == null ? void 0 : Ge.fontId) ?? 1e3
          }),
          ie = Je(() => {
            var Ne, Ge;
            return ((Ge = (Ne = bt.data) == null ? void 0 : Ne.equippedNameCosmetic) == null ? void 0 : Ge.styleId) ?? 1001
          }),
          Y = Je(() => {
            var Ne;
            return ((Ne = bt.data) == null ? void 0 : Ne.droplets) ?? 0
          }),
          Fe = Je(() => {
            var Ne;
            return ((Ne = bt.data) == null ? void 0 : Ne.name) ?? "User"
          });
        IE(fe, {
          get fonts() {
            return h(ye)
          },
          get styles() {
            return h(be)
          },
          get equippedFontId() {
            return h(ve)
          },
          get equippedStyleId() {
            return h(ie)
          },
          get userDroplets() {
            return h(Y)
          },
          get userName() {
            return h(Fe)
          },
          get loading() {
            return h(q)
          },
          onbuyFont: rt,
          onbuyStyle: _t,
          get selectedFontIndex() {
            return h(he)
          },
          set selectedFontIndex(Ne) {
            j(he, Ne, !0)
          },
          get selectedStyleIndex() {
            return h(me)
          },
          set selectedStyleIndex(Ne) {
            j(me, Ne, !0)
          }
        })
      }
    };
  let z = Xe(Wi([])),
    T = Xe(0),
    s = Xe(!1),
    F = Xe(null),
    Z = Xe("main"),
    K = Xe(Wi([])),
    G = Xe(0),
    re = Xe(!1),
    he = Xe(0),
    me = Xe(0),
    q = Xe(!1),
    ye = Xe(Wi([])),
    be = Xe(Wi([])),
    qe = Ot(l, "open", 15),
    xe = Xe(null),
    Ye = Xe(Wi({
      name: Av(),
      prev: 1e3,
      new: 1e5
    }));
  const We = {
      id: 70,
      product: xn.products[70]
    },
    ze = {
      id: 80,
      product: xn.products[80]
    },
    Se = {
      product: xn.products[120]
    };
  let Pe = Xe(null),
    Ae = Xe(null),
    Me = Xe("");
  async function Ee(fe) {
    return h(Pe).showModal(), j(Ae, Wm.withResolvers(), !0), j(Me, fe, !0), h(Ae).promise
  }
  async function Qe(fe) {
    var ve;
    try {
      j(s, !0), j(F, fe.id, !0), await Kr.postBuyUserFrame(fe.id), bt.refresh(), aa.notification1.play();
      const ie = (ve = h(z)) == null ? void 0 : ve.find(Y => Y.id === fe.id);
      ie && (ie.owned = !0)
    } catch (ie) {
      Bt.error(ie.message)
    } finally {
      j(s, !1), j(F, null)
    }
  }
  async function Ue(fe) {
    var ve;
    try {
      j(s, !0), j(F, fe.id, !0), await Kr.postEquipUserFrame(fe.id), await bt.refresh(), aa.notification1.play(), Bt.success(((ve = N5) == null ? void 0 : ve()) ?? "Frame equipped!")
    } catch (ie) {
      Bt.error(ie.message)
    } finally {
      j(s, !1), j(F, null)
    }
  }
  async function je(fe) {
    try {
      j(re, !0), await Kr.changeProfilePicture(fe.id), await bt.refresh(), aa.notification1.play(), Bt.success(q5())
    } catch (ve) {
      Bt.error(ve.message)
    } finally {
      j(re, !1)
    }
  }
  async function rt(fe) {
    try {
      if (fe.id === 10) return;
      j(q, !0), await Kr.postBuyCosmetic(fe.id), await bt.refresh(), aa.notification1.play();
      const ve = h(ye).find(ie => ie.id === fe.id);
      ve && (ve.owned = !0)
    } catch (ve) {
      Bt.error(ve.message)
    } finally {
      j(q, !1)
    }
  }
  async function _t(fe) {
    try {
      if (fe.id === 20) return;
      j(q, !0), await Kr.postBuyCosmetic(fe.id), await bt.refresh(), aa.notification1.play();
      const ve = h(be).find(ie => ie.id === fe.id);
      ve && (ve.owned = !0)
    } catch (ve) {
      Bt.error(ve.message)
    } finally {
      j(q, !1)
    }
  }
  Oa(async () => {
    try {
      j(z, await Kr.getStoreFrames(), !0);
      const fe = await Kr.getStoreNameCosmetics();
      j(ye, fe.fonts.map(ve => ({
        id: ve.id,
        name: ve.name,
        text: ve.text,
        price: ve.price,
        owned: ve.owned
      })), !0), j(be, fe.styles.map(ve => ({
        id: ve.id,
        name: ve.name,
        price: ve.price,
        owned: ve.owned,
        text: ve.text
      })), !0)
    } catch {
      j(z, [], !0)
    }
    try {
      j(K, await Kr.getMyProfilePictures(), !0)
    } catch {
      j(K, [], !0)
    }
  });
  var dt = UE(),
    at = zt(dt),
    nt = P(at),
    ot = P(nt);
  {
    var ut = fe => {
      var ve = NE(),
        ie = P(ve),
        Y = P(ie),
        Fe = P(Y);
      Fy(Fe, {
        class: "size-8"
      });
      var Ne = E(Fe, 2),
        Ge = P(Ne, !0);
      S(Ne);
      var pe = E(Ne, 2),
        Ve = P(pe);
      {
        let ct = Je(() => {
          var At;
          return ((At = bt.data) == null ? void 0 : At.droplets) ?? 0
        });
        m0(Ve, {
          get value() {
            return h(ct)
          }
        })
      }
      S(pe), wi(2), S(Y), S(ie), qa(ie, () => xz);
      var it = E(ie, 2);
      {
        var yt = ct => {
            var At = jE(),
              qt = P(At),
              Ke = P(qt),
              Tt = P(Ke);
            Nz(Tt, {
              class: "size-5.5",
              filled: !0
            });
            var Wt = E(Tt, 2),
              Fr = P(Wt, !0);
            S(Wt), S(Ke);
            var or = E(Ke, 2),
              tt = P(or, !0);
            S(or);
            var Ht = E(or, 2),
              Qt = P(Ht);
            {
              const qr = Mr => {
                Wz(Mr, {
                  class: "text-primary size-26"
                })
              };
              let ur = Je(() => B5());
              c0(Qt, {
                get productId() {
                  return We.id
                },
                title: Mr => E5({
                  amount: We.product.items[0].amount * Mr
                }),
                get subtitle() {
                  return h(ur)
                },
                get unitPrice() {
                  return We.product.price
                },
                get userDroplets() {
                  return bt.data.droplets
                },
                onpurchasecompleted: async Mr => {
                  var Vr, Rr, ni, Ri;
                  const di = (Rr = (Vr = bt.data) == null ? void 0 : Vr.charges) == null ? void 0 : Rr.max;
                  await bt.refresh();
                  const ti = (Ri = (ni = bt.data) == null ? void 0 : ni.charges) == null ? void 0 : Ri.max;
                  di !== void 0 && ti !== void 0 && (j(Ye, {
                    name: Av(),
                    prev: di,
                    new: ti
                  }, !0), h(xe).show())
                },
                icon: qr,
                $$slots: {
                  icon: !0
                }
              })
            }
            var Sr = E(Qt, 2);
            {
              const qr = Mr => {
                Ey(Mr, {
                  class: "text-primary my-3 size-20"
                })
              };
              let ur = Je(() => O5());
              c0(Sr, {
                get productId() {
                  return ze.id
                },
                title: Mr => L5({
                  amount: ze.product.items[0].amount * Mr
                }),
                get subtitle() {
                  return h(ur)
                },
                get unitPrice() {
                  return ze.product.price
                },
                get userDroplets() {
                  return bt.data.droplets
                },
                onpurchasecompleted: async Mr => {
                  var ti, Vr, Rr;
                  const di = (Vr = (ti = bt.data) == null ? void 0 : ti.charges) == null ? void 0 : Vr.count;
                  await bt.refresh(), di !== void 0 && (j(Ye, {
                    name: w3(),
                    prev: Math.floor(di),
                    new: Math.floor(di + ze.product.items[0].amount * Mr)
                  }, !0), (Rr = h(xe)) == null || Rr.show())
                },
                icon: qr,
                $$slots: {
                  icon: !0
                }
              })
            }
            S(Ht), S(qt);
            var ei = E(qt, 2),
              li = P(ei),
              Dr = P(li);
            Vp(Dr, {
              class: "size-5.5",
              filled: !0
            });
            var Oi = E(Dr, 2),
              Jr = P(Oi, !0);
            S(Oi), S(li);
            var It = E(li, 2),
              er = P(It);
            {
              let qr = Je(() => [{
                title: D0(),
                content: x
              }, {
                title: j5(),
                content: _,
                onViewAll: () => {
                  j(Z, "all-frames")
                },
                previewImages: [h(z)[5], h(z)[6], h(z)[16]].filter(Boolean).map(ur => ur.imageUrl)
              }, {
                title: I0(),
                content: k
              }]);
              Qz(er, {
                class: "h-fit",
                get tabs() {
                  return h(qr)
                }
              })
            }
            S(It), S(ei);
            var Pr = E(ei, 2),
              pr = P(Pr);
            Rz(pr, {
              promptUserConfirmation: Ee
            }), S(Pr), S(At), ke((qr, ur, Mr) => {
              ee(Fr, qr), ee(tt, ur), ee(Jr, Mr)
            }, [() => D5(), () => R5(), () => F5()]), B(ct, At)
          },
          Lt = ct => {
            var At = br(),
              qt = zt(At);
            {
              var Ke = Tt => {
                var Wt = qE(),
                  Fr = P(Wt);
                {
                  let or = Je(() => {
                      var Sr;
                      return ((Sr = bt.data) == null ? void 0 : Sr.equippedFrameId) ?? null
                    }),
                    tt = Je(() => {
                      var Sr;
                      return ((Sr = bt.data) == null ? void 0 : Sr.droplets) ?? 0
                    }),
                    Ht = Je(() => {
                      var Sr;
                      return ((Sr = bt.data) == null ? void 0 : Sr.id) ?? 0
                    }),
                    Qt = Je(() => {
                      var Sr;
                      return (Sr = bt.data) == null ? void 0 : Sr.picture
                    });
                  OE(Fr, {
                    get frames() {
                      return h(z)
                    },
                    get equippedFrameId() {
                      return h(or)
                    },
                    get userDroplets() {
                      return h(tt)
                    },
                    get userId() {
                      return h(Ht)
                    },
                    get pictureUrl() {
                      return h(Qt)
                    },
                    get loading() {
                      return h(s)
                    },
                    get loadingFrameId() {
                      return h(F)
                    },
                    onbuy: Qe,
                    onequip: Ue,
                    onback: () => {
                      j(Z, "main")
                    }
                  })
                }
                S(Wt), B(Tt, Wt)
              };
              Te(qt, Tt => {
                h(Z) === "all-frames" && Tt(Ke)
              }, !0)
            }
            B(ct, At)
          };
        Te(it, ct => {
          h(Z) === "main" ? ct(yt) : ct(Lt, !1)
        })
      }
      S(ve), ke(ct => ee(Ge, ct), [() => A0()]), dn(2, ve, () => Jn), B(fe, ve)
    };
    Te(ot, fe => {
      bt.data && qe() && fe(ut)
    })
  }
  S(nt);
  var st = E(nt, 2),
    wt = P(st),
    Ct = P(wt, !0);
  S(wt), S(st), S(at), qa(at, () => fe => {
    Qr(() => {
      qe() ? fe.show() : fe.close()
    })
  });
  var rr = E(at, 2),
    Zt = P(rr),
    lt = P(Zt),
    ht = P(lt),
    Dt = P(ht, !0);
  S(ht);
  var Vt = E(ht, 2),
    Jt = P(Vt),
    jt = P(Jt),
    nr = E(jt),
    St = P(nr);
  S(nr), S(Jt);
  var Et = E(Jt, 2),
    Ut = P(Et);
  Zz(Ut, {
    class: "size-5"
  }), S(Et);
  var Gt = E(Et, 2),
    Rt = P(Gt, !0);
  S(Gt), S(Vt);
  var ir = E(Vt, 2),
    kr = P(ir),
    _r = P(kr),
    fr = E(_r);
  bl(fr, () => h(Ye).new, fe => {
    var ve = VE(),
      ie = P(ve);
    bg(ie, {}), S(ve), B(fe, ve)
  }), S(kr), S(ir), S(lt), S(Zt);
  var Yt = E(Zt, 2),
    sr = P(Yt),
    Kt = P(sr, !0);
  S(sr), S(Yt), S(rr), Rn(rr, fe => j(xe, fe), () => h(xe));
  var vr = E(rr, 2),
    Lr = P(vr),
    ii = P(Lr),
    mr = P(ii, !0);
  S(ii);
  var ge = E(ii, 2),
    V = P(ge);
  Fp(V, () => z5({
    country: h(Me)
  })), S(ge);
  var U = E(ge, 2),
    J = P(U);
  J.__click = () => {
    var fe;
    (fe = h(Ae)) == null || fe.resolve(!1), h(Pe).close()
  };
  var se = P(J, !0);
  S(J);
  var te = E(J, 2);
  te.__click = () => {
    var fe;
    (fe = h(Ae)) == null || fe.resolve(!0), h(Pe).close()
  };
  var _e = P(te, !0);
  S(te), S(U), S(Lr);
  var Re = E(Lr, 2),
    ne = P(Re),
    oe = P(ne, !0);
  S(ne), S(Re), S(vr), Rn(vr, fe => j(Pe, fe), () => h(Pe)), ke((fe, ve, ie, Y, Fe, Ne, Ge) => {
    ee(Ct, fe), ee(Dt, h(Ye).name), ee(jt, `${h(Ye).prev??""} `), ee(St, `(+${h(Ye).new-h(Ye).prev})`), ee(Rt, h(Ye).new), ee(_r, `${ve??""} `), ee(Kt, ie), ee(mr, Y), ee(se, Fe), ee(_e, Ne), ee(oe, Ge)
  }, [() => uo(), () => uo(), () => uo(), () => k5(), () => No(), () => O0(), () => uo()]), Ci("close", at, () => qe(!1)), B(y, dt), Wr()
}
Ui(["click"]);
var GE = Yr('<svg><path d="M480-680q-33 0-56.5-23.5T400-760q0-33 23.5-56.5T480-840q33 0 56.5 23.5T560-760q0 33-23.5 56.5T480-680Zm-60 560v-480h120v480H420Z"></path></svg>');

function WE(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = GE();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var HE = Yr('<svg><path d="M440-40v-80q-125-14-214.5-103.5T122-438H42v-80h80q14-125 103.5-214.5T440-836v-80h80v80q125 14 214.5 103.5T838-518h80v80h-80q-14 125-103.5 214.5T520-120v80h-80Zm40-158q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Z"></path></svg>');

function XE(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = HE();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var YE = Yr('<svg><path d="M440-42v-80q-125-14-214.5-103.5T122-440H42v-80h80q14-125 103.5-214.5T440-838v-80h80v80q125 14 214.5 103.5T838-520h80v80h-80q-14 125-103.5 214.5T520-122v80h-80Zm40-158q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Zm0-120q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47Z"></path></svg>');

function KE(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = YE();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var JE = Yr('<svg><path d="M380-720v-98L142-580h98v60H40v-200h60v98l238-238h-98v-60h200v200h-60ZM593-40q-24 0-46-9t-39-26L304-280l30-31q16-16 37.5-21.5t42.5.5l66 19v-327q0-17 11.5-28.5T520-680q17 0 28.5 11.5T560-640v433l-97-27 102 102q5 5 12.5 8.5T593-120h167q33 0 56.5-23.5T840-200v-160q0-17 11.5-28.5T880-400q17 0 28.5 11.5T920-360v160q0 66-47 113T760-40H593Zm7-280v-160q0-17 11.5-28.5T640-520q17 0 28.5 11.5T680-480v160h-80Zm120 0v-120q0-17 11.5-28.5T760-480q17 0 28.5 11.5T800-440v120h-80Zm-20 80Z"></path></svg>');

function $E(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = JE();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var QE = Yr('<svg><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q146 0 255.5 91.5T872-559h-82q-19-73-68.5-130.5T600-776v16q0 33-23.5 56.5T520-680h-80v80q0 17-11.5 28.5T400-560h-80v80h80v120h-40L168-552q-3 18-5.5 36t-2.5 36q0 131 92 225t228 95v80Zm364-20L716-228q-21 12-45 20t-51 8q-75 0-127.5-52.5T440-380q0-75 52.5-127.5T620-560q75 0 127.5 52.5T800-380q0 27-8 51t-20 45l128 128-56 56ZM620-280q42 0 71-29t29-71q0-42-29-71t-71-29q-42 0-71 29t-29 71q0 42 29 71t71 29Z"></path></svg>');

function eL(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = QE();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), B(y, x)
}

function tL(y, l, _) {
  return y < l ? l : y > _ ? _ : y
}

function rL(y, l) {
  const _ = 10 ** l;
  return Math.round(y * _) / _
}
var iL = ae('<div class="badge badge-error badge-sm"> </div>'),
  aL = ae('<span class="loading loading-spinner loading-sm"></span>'),
  nL = ae('<div class="bg-base-100/80 absolute inset-0 flex items-center justify-center"><span class="loading loading-spinner loading-lg"></span></div>'),
  sL = ae('<div class="bg-base-200 absolute left-4 top-4 rounded-lg p-3 shadow-lg"><div class="text-sm font-semibold">Pixel Info</div> <div class="mt-2 space-y-1 text-xs"><div> </div> <div>User ID: <span class="badge badge-sm"> </span></div> <div> </div></div></div>'),
  oL = ae('<canvas class="absolute inset-0 cursor-crosshair"></canvas> <!>', 1),
  lL = ae('<span class="badge badge-outline badge-sm"> </span>'),
  cL = ae('<div><button><div class="flex items-center justify-between"><div class="flex items-center gap-2"><input type="checkbox" class="checkbox checkbox-sm pointer-events-auto"/> <span class="badge badge-sm"> </span> <!></div> <span class="text-xs"> </span></div> <div class="text-base-content/60 mt-1 text-xs"> </div></button></div>'),
  uL = ae('<span class="loading loading-spinner loading-xs"></span>'),
  hL = ae('<div class="border-base-300 border-t p-2"><button class="btn btn-outline btn-block btn-sm"><!> Load 100 Older Events</button></div>'),
  dL = ae('<div class="fixed inset-0 z-50 flex flex-col"><div class="border-base-300 bg-base-100/95 pointer-events-auto flex items-center justify-between border-b p-3 backdrop-blur-sm"><div class="flex items-center gap-4"><h2 class="text-lg font-bold">Wayback Video Mode</h2> <div class="flex gap-4 text-sm"><div class="badge badge-sm"> </div> <div class="badge badge-sm"> </div> <div class="badge badge-sm"> </div> <!></div></div> <div class="flex items-center gap-2"><button class="btn btn-success btn-sm"><!> Reconstruct</button> <button class="btn btn-circle btn-sm"><!></button></div></div> <div class="flex flex-1 overflow-hidden"><div class="relative flex-1"><!></div> <div class="bg-base-200/95 border-base-300 pointer-events-auto flex w-80 flex-col border-l backdrop-blur-sm"><div class="border-base-300 border-b p-3"><h3 class="font-semibold">Events History</h3> <p class="text-base-content/60 text-xs">Click to exclude/include</p></div> <div class="flex-1 overflow-y-auto p-2"><div class="space-y-1"></div></div> <!></div></div> <div class="border-base-300 bg-base-200/95 border-t p-3"><div class="flex items-center gap-4"><div class="font-mono text-xs"> </div> <input type="range" class="range range-primary flex-1"/> <div class="font-mono text-xs"> </div></div> <div class="text-primary mt-2 text-center font-mono text-sm font-bold"> </div></div></div>');

function pL(y, l) {
  Gr(l, !0);
  let _ = Xe(!1),
    x = Xe(!1),
    k = Xe(Wi([])),
    z = Xe(!1);
  const T = Date.now();
  let s = Xe(Wi(T)),
    F = Xe(Wi(T)),
    Z = Xe(Wi(T)),
    K = Xe(!0),
    G = 100,
    re = Xe(void 0),
    he = null,
    me = Xe(Wi(new Map)),
    q = Xe(null),
    ye = Xe(null),
    be = Xe(void 0);
  const qe = new kn(l.tileSize);
  let xe = Je(() => h(k).filter(te => te.ts <= h(Z) && te.selected)),
    Ye = Je(() => h(xe).reduce((te, _e) => te + _e.pixelsCount, 0)),
    We = Je(() => new Set(h(xe).map(te => te.userId)).size),
    ze = Je(() => h(k).filter(te => !te.selected).length);
  Qr(() => {
    h(re) && (he = h(re).getContext("2d", {
      willReadFrequently: !0
    }), he && (he.imageSmoothingEnabled = !1))
  });
  async function Se() {
    j(_, !0);
    try {
      const te = l.map.getBounds(),
        _e = new URLSearchParams({
          to_ts: T.toString(),
          min_lat: te.getSouth().toString(),
          max_lat: te.getNorth().toString(),
          min_lon: te.getWest().toString(),
          max_lon: te.getEast().toString(),
          limit: G.toString()
        }),
        Re = await Kr.getWaybackVideo(l.season, _e.toString());
      if (!Re.ok) throw new Error("Failed to load events");
      const oe = ((await Re.json()).events ?? []).map(fe => ({
        ...fe,
        selected: !0
      }));
      j(k, oe, !0), oe.length > 0 && (j(s, oe[0].ts, !0), j(F, oe[oe.length - 1].ts, !0), j(Z, h(F), !0)), j(K, oe.length === G), setTimeout(() => Ae(), 0), Bt.success(`Carregados ${oe.length} eventos mais recentes`)
    } catch (te) {
      Bt.error(te.message)
    } finally {
      j(_, !1)
    }
  }
  async function Pe() {
    if (!(h(x) || !h(K))) {
      j(x, !0);
      try {
        const te = l.map.getBounds(),
          _e = new URLSearchParams({
            from_ts: (h(s) - 10080 * 60 * 1e3).toString(),
            to_ts: h(s).toString(),
            min_lat: te.getSouth().toString(),
            max_lat: te.getNorth().toString(),
            min_lon: te.getWest().toString(),
            max_lon: te.getEast().toString(),
            limit: G.toString()
          }),
          Re = await Kr.getWaybackVideo(l.season, _e.toString());
        if (!Re.ok) throw new Error("Failed to load more events");
        const oe = ((await Re.json()).events ?? []).map(fe => ({
          ...fe,
          selected: !0
        }));
        if (oe.length === 0) {
          j(K, !1), Bt.info("No more events");
          return
        }
        j(k, [...oe, ...h(k)], !0), j(s, oe[0].ts, !0), j(K, oe.length === G), setTimeout(() => Ae(), 0), Bt.success(`Loaded +${oe.length} older events`)
      } catch (te) {
        Bt.error(te.message)
      } finally {
        j(x, !1)
      }
    }
  }

  function Ae() {
    var ne, oe, fe;
    if (console.log("rebuildCanvas called", {
        hasCtx: !!he,
        hasCanvas: !!h(re),
        visibleEventsCount: h(xe).length,
        canvasWidth: (ne = h(re)) == null ? void 0 : ne.width,
        canvasHeight: (oe = h(re)) == null ? void 0 : oe.height
      }), !he || !h(re)) {
      console.log("No ctx or canvas");
      return
    }
    if (!he || !h(re)) return;
    he.clearRect(0, 0, h(re).width, h(re).height), h(me).clear();
    const te = l.map.getBounds(),
      _e = l.map.project([te.getWest(), te.getNorth()]),
      Re = l.map.project([te.getEast(), te.getSouth()]);
    for (let ve = 0; ve < h(xe).length; ve++) {
      const ie = h(xe)[ve];
      for (let Y = 0; Y < ie.pixelsX.length; Y++) {
        const Fe = ie.pixelsX[Y],
          Ne = ie.pixelsY[Y],
          Ge = ie.colors[Y],
          pe = ie.tileX * l.tileSize + Fe,
          Ve = ie.tileY * l.tileSize + Ne,
          it = qe.pixelsToLatLon(pe + .5, Ve + .5, l.pixelArtZoom),
          yt = l.map.project([it[1], it[0]]);
        if (yt.x >= _e.x && yt.x <= Re.x && yt.y >= _e.y && yt.y <= Re.y) {
          const Lt = `${ie.tileX},${ie.tileY},${Fe},${Ne}`;
          h(me).set(Lt, {
            color: Ge,
            userId: ie.userId,
            ts: ie.ts,
            eventIndex: ve
          });
          const ct = xn.colors[Ge];
          if (ct) {
            const [At, qt, Ke] = ct.rgb;
            he.fillStyle = `rgb(${At}, ${qt}, ${Ke})`;
            const Tt = pe + 1,
              Wt = Ve + 1,
              Fr = qe.pixelsToLatLon(Tt + .5, Wt + .5, l.pixelArtZoom),
              or = l.map.project([Fr[1], Fr[0]]),
              tt = Math.max(1, Math.abs(or.x - yt.x)),
              Ht = Math.max(1, Math.abs(or.y - yt.y));
            he.fillRect(Math.floor(yt.x), Math.floor(yt.y), Math.ceil(tt), Math.ceil(Ht)), h(ye) !== null && ((fe = h(k)[h(ye)]) == null ? void 0 : fe.userId) === ie.userId && (he.strokeStyle = "rgba(255, 255, 0, 0.8)", he.lineWidth = 2, he.strokeRect(Math.floor(yt.x) - 1, Math.floor(yt.y) - 1, Math.ceil(tt) + 2, Math.ceil(Ht) + 2))
          }
        }
      }
    }
    j(me, new Map(h(me)), !0)
  }

  function Me(te) {
    if (!h(re)) return;
    const _e = h(re).getBoundingClientRect(),
      Re = te.clientX - _e.left,
      ne = te.clientY - _e.top,
      oe = l.map.unproject([Re + _e.left, ne + _e.top]),
      fe = qe.latLonToPixels(oe.lat, oe.lng, l.pixelArtZoom),
      ve = Math.floor(fe[0]),
      ie = Math.floor(fe[1]),
      Y = Math.floor(ve / l.tileSize),
      Fe = Math.floor(ie / l.tileSize),
      Ne = ve % l.tileSize,
      Ge = ie % l.tileSize,
      pe = `${Y},${Fe},${Ne},${Ge}`,
      Ve = h(me).get(pe);
    if (Ve) {
      j(q, {
        x: ve,
        y: ie,
        userId: Ve.userId,
        ts: Ve.ts
      }, !0);
      const it = h(k).findIndex(yt => yt.ts === Ve.ts && yt.userId === Ve.userId);
      it !== -1 && (j(ye, it, !0), Ue(it), setTimeout(() => Ae(), 0))
    } else j(q, null), j(ye, null), setTimeout(() => Ae(), 0)
  }

  function Ee(te) {
    h(k)[te].selected = !h(k)[te].selected, j(k, [...h(k)], !0), setTimeout(() => Ae(), 0)
  }

  function Qe(te, _e) {
    j(ye, te, !0), j(q, {
      x: _e.tileX * l.tileSize + (_e.pixelsX[0] ?? 0),
      y: _e.tileY * l.tileSize + (_e.pixelsY[0] ?? 0),
      userId: _e.userId,
      ts: _e.ts
    }, !0), setTimeout(() => Ae(), 0)
  }

  function Ue(te) {
    if (!h(be)) return;
    const _e = h(be).querySelector(`[data-event-index="${te}"]`);
    _e && _e.scrollIntoView({
      behavior: "smooth",
      block: "center"
    })
  }
  async function je() {
    if (h(xe).length === 0) {
      Bt.error("No events to reconstruct");
      return
    }
    j(z, !0);
    try {
      const te = new Map;
      for (const Re of h(xe)) {
        const ne = `${Re.tileX},${Re.tileY}`;
        te.has(ne) || te.set(ne, []), te.get(ne).push(Re)
      }
      let _e = 0;
      for (const [Re, ne] of te) {
        const [oe, fe] = Re.split(",").map(Number), ve = new Map;
        for (const Ne of ne)
          for (let Ge = 0; Ge < Ne.pixelsX.length; Ge++) {
            const pe = `${Ne.pixelsX[Ge]},${Ne.pixelsY[Ge]}`;
            ve.set(pe, {
              x: Ne.pixelsX[Ge],
              y: Ne.pixelsY[Ge],
              color: Ne.colors[Ge],
              userId: Ne.userId
            })
          }
        const ie = Array.from(ve.values()),
          Y = {
            events: [{
              tileX: oe,
              tileY: fe,
              pixelsX: ie.map(Ne => Ne.x),
              pixelsY: ie.map(Ne => Ne.y),
              colors: ie.map(Ne => Ne.color),
              userIds: ie.map(Ne => Ne.userId)
            }]
          };
        if (!(await Kr.postWaybackReconstruct(l.season, Y)).ok) throw new Error(`Failed to reconstruct tile ${Re}`);
        _e += ie.length
      }
      l.refreshPixelArt(), Bt.success(`Reconstructed ${_e} pixels from ${h(xe).length} events`)
    } catch (te) {
      Bt.error(te.message)
    } finally {
      j(z, !1)
    }
  }

  function rt(te) {
    return new Date(te).toLocaleString(navigator.language)
  }

  function _t(te) {
    return new Date(te).toLocaleTimeString(navigator.language)
  }
  Qr(() => {
    if (l.map && h(k).length > 0) {
      const te = () => setTimeout(() => Ae(), 0);
      return l.map.on("move", te), l.map.on("zoom", te), () => {
        l.map.off("move", te), l.map.off("zoom", te)
      }
    }
  }), Qr(() => {
    h(Z) !== void 0 && setTimeout(() => Ae(), 0)
  }), Oa(() => {
    setTimeout(() => Se(), 100)
  });
  var dt = dL(),
    at = P(dt),
    nt = P(at),
    ot = E(P(nt), 2),
    ut = P(ot),
    st = P(ut);
  S(ut);
  var wt = E(ut, 2),
    Ct = P(wt);
  S(wt);
  var rr = E(wt, 2),
    Zt = P(rr);
  S(rr);
  var lt = E(rr, 2);
  {
    var ht = te => {
      var _e = iL(),
        Re = P(_e);
      S(_e), ke(() => ee(Re, `${h(ze)??""} excluded`)), B(te, _e)
    };
    Te(lt, te => {
      h(ze) > 0 && te(ht)
    })
  }
  S(ot), S(nt);
  var Dt = E(nt, 2),
    Vt = P(Dt);
  Vt.__click = je;
  var Jt = P(Vt);
  {
    var jt = te => {
        var _e = aL();
        B(te, _e)
      },
      nr = te => {
        wg(te, {
          class: "size-4"
        })
      };
    Te(Jt, te => {
      h(z) ? te(jt) : te(nr, !1)
    })
  }
  wi(), S(Vt);
  var St = E(Vt, 2);
  St.__click = function(...te) {
    var _e;
    (_e = l.onclose) == null || _e.apply(this, te)
  };
  var Et = P(St);
  ss(Et, {
    class: "size-4"
  }), S(St), S(Dt), S(at);
  var Ut = E(at, 2),
    Gt = P(Ut),
    Rt = P(Gt);
  {
    var ir = te => {
        var _e = nL();
        B(te, _e)
      },
      kr = te => {
        var _e = oL(),
          Re = zt(_e);
        Xt(Re, "width", window.innerWidth), Xt(Re, "height", window.innerHeight - 150), Re.__click = Me, Rn(Re, fe => j(re, fe), () => h(re));
        var ne = E(Re, 2);
        {
          var oe = fe => {
            var ve = sL(),
              ie = E(P(ve), 2),
              Y = P(ie),
              Fe = P(Y);
            S(Y);
            var Ne = E(Y, 2),
              Ge = E(P(Ne)),
              pe = P(Ge, !0);
            S(Ge), S(Ne);
            var Ve = E(Ne, 2),
              it = P(Ve);
            S(Ve), S(ie), S(ve), ke(yt => {
              ee(Fe, `Position: (${h(q).x??""}, ${h(q).y??""})`), ee(pe, h(q).userId), ee(it, `Time: ${yt??""}`)
            }, [() => _t(h(q).ts)]), B(fe, ve)
          };
          Te(ne, fe => {
            h(q) && fe(oe)
          })
        }
        B(te, _e)
      };
    Te(Rt, te => {
      h(_) ? te(ir) : te(kr, !1)
    })
  }
  S(Gt);
  var _r = E(Gt, 2),
    fr = E(P(_r), 2),
    Yt = P(fr);
  Hi(Yt, 21, () => h(k), po, (te, _e, Re) => {
    const ne = Je(() => h(_e).ts <= h(Z)),
      oe = Je(() => h(_e).selected),
      fe = Je(() => h(ye) === Re);
    var ve = cL();
    Xt(ve, "data-event-index", Re);
    var ie = P(ve);
    let Y;
    ie.__click = Ke => {
      const Tt = Ke.target;
      Tt.tagName === "INPUT" || Tt.closest("input") ? Ee(Re) : Qe(Re, h(_e))
    };
    var Fe = P(ie),
      Ne = P(Fe),
      Ge = P(Ne);
    Ka(Ge), Ge.__click = Ke => {
      Ke.stopPropagation(), Ee(Re)
    };
    var pe = E(Ge, 2),
      Ve = P(pe, !0);
    S(pe);
    var it = E(pe, 2);
    {
      var yt = Ke => {
        var Tt = lL(),
          Wt = P(Tt, !0);
        S(Tt), ke(() => ee(Wt, h(_e).allianceId)), B(Ke, Tt)
      };
      Te(it, Ke => {
        h(_e).allianceId > 0 && Ke(yt)
      })
    }
    S(Ne);
    var Lt = E(Ne, 2),
      ct = P(Lt);
    S(Lt), S(Fe);
    var At = E(Fe, 2),
      qt = P(At);
    S(At), S(ie), S(ve), ke(Ke => {
      Er(ve, 1, "relative rounded transition-all" + (h(fe) ? " ring-primary bg-primary/10 ring-2" : "")), Y = Er(ie, 1, "hover:bg-base-300 w-full rounded p-2 text-left transition-colors", null, Y, {
        "opacity-30": !h(ne),
        "bg-base-300": !h(oe) && !h(fe),
        "line-through": !h(oe)
      }), ie.disabled = !h(ne), cm(Ge, h(oe)), Ge.disabled = !h(ne), ee(Ve, h(_e).userId), ee(ct, `${h(_e).pixelsCount??""}px`), ee(qt, `${Ke??""}  Tile (${h(_e).tileX??""}, ${h(_e).tileY??""})`)
    }, [() => _t(h(_e).ts)]), B(te, ve)
  }), S(Yt), S(fr), Rn(fr, te => j(be, te), () => h(be));
  var sr = E(fr, 2);
  {
    var Kt = te => {
      var _e = hL(),
        Re = P(_e);
      Re.__click = Pe;
      var ne = P(Re);
      {
        var oe = fe => {
          var ve = uL();
          B(fe, ve)
        };
        Te(ne, fe => {
          h(x) && fe(oe)
        })
      }
      wi(), S(Re), S(_e), ke(() => Re.disabled = h(x)), B(te, _e)
    };
    Te(sr, te => {
      h(K) && te(Kt)
    })
  }
  S(_r), S(Ut);
  var vr = E(Ut, 2),
    Lr = P(vr),
    ii = P(Lr),
    mr = P(ii, !0);
  S(ii);
  var ge = E(ii, 2);
  Ka(ge), Xt(ge, "step", 1e3);
  var V = E(ge, 2),
    U = P(V, !0);
  S(V), S(Lr);
  var J = E(Lr, 2),
    se = P(J, !0);
  S(J), S(vr), S(dt), ke((te, _e, Re) => {
    ee(st, `${h(xe).length??""} events`), ee(Ct, `${h(Ye)??""} pixels`), ee(Zt, `${h(We)??""} users`), Vt.disabled = h(z) || h(xe).length === 0 || h(ze) === 0, ee(mr, te), Xt(ge, "min", h(s)), Xt(ge, "max", h(F)), ee(U, _e), ee(se, Re)
  }, [() => rt(h(s)), () => rt(h(F)), () => rt(h(Z))]), Tl(ge, () => h(Z), te => j(Z, te)), dn(3, dt, () => Jn), B(y, dt), Wr()
}
Ui(["click"]);
var fL = Yr('<svg><path d="M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8 12.5v-9l6 4.5-6 4.5z"></path></svg>');

function mL(y, l) {
  let _ = Or(l, ["$$slots", "$$events", "$$legacy"]);
  var x = fL();
  jr(x, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    ..._
  })), B(y, x)
}
var gL = ae('<meta property="og:title" content="Wplace - A massive real-time pixel art canvas on the world map!"/> <meta name="twitter:title" content="Wplace - A massive real-time pixel art canvas on the world map!"/> <meta name="robots" content="index, follow, max-image-preview:large"/> <meta name="color-scheme" content="light only"/>', 1),
  _L = ae("<button><!></button>"),
  vL = ae('<div class="relative"><!> <span class="center-absolute absolute text-[10px] text-red-400">?</span></div>'),
  yL = ae('<button class="btn btn-lg btn-square sm:btn-xl z-30 shadow-md"><!></button>'),
  xL = ae('<button class="btn btn-primary shadow-xl"> </button>'),
  bL = ae('<div class="absolute top-0 -left-2 -translate-x-full translate-y-1/2 select-none"><!></div>'),
  wL = ae('<div class="relative z-50"><!> <!></div>'),
  TL = ae('<button class="btn btn-square shadow-md"><!></button> <button class="btn btn-square relative shadow-md"><!></button>', 1),
  SL = ae('<button title="Auto painter" class="btn btn-square shadow-md"><!></button>'),
  PL = ae('<button title="Video Wayback" class="btn btn-square shadow-md"><!></button>'),
  IL = ae('<div class="flex flex-col items-center gap-3"><!> <button class="btn btn-square relative shadow-md"><!></button> <button class="btn btn-square shadow-md"><!></button> <!> <!></div>'),
  ML = ae('<div class="flex flex-col gap-3"><button><!></button></div>'),
  CL = ae('<button class="btn btn-sm btn-circle"><!></button>'),
  AL = ae('<div class="tooltip tooltip-right"><div class="tooltip-content">Select Area <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">C</kbd></div> <button class="btn btn-sm btn-circle" title="Select area"><!></button></div>'),
  kL = ae('<button class="btn btn-sm btn-circle"><!></button>'),
  zL = ae('<button class="btn btn-sm btn-circle not-pwa:hidden"><!></button>'),
  EL = ae('<div class="btn btn-sm btn-error w-max cursor-auto text-xs text-nowrap sm:text-base"><!> </div>'),
  LL = ae('<button class="btn sm:btn-lg duration text-xs text-nowrap transition-opacity sm:text-base"><!> </button>'),
  DL = ae("<span></span>"),
  RL = ae('<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2 md:max-w-lg"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t bg-cover bg-center pt-2 sm:mb-3 sm:shadow-xl" style=""><!></div></div>'),
  FL = ae('<div class="absolute bottom-0 left-0 z-50 w-full"><div class="rounded-t-box bg-base-100 border-base-300 w-full border-t py-3"><!></div></div>'),
  BL = ae('<div class="pointer-events-none absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-lg sm:-translate-x-1/2 md:max-w-xl"><!></div>'),
  OL = ae('<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t pt-2 sm:mb-3 sm:shadow-xl"><div class="px-3 pt-1 pb-2"><div class="flex items-center justify-between"><span><!> </span> <button class="btn btn-circle btn-sm"><!></button></div> <div class="mt-1 flex items-center justify-center gap-4"><button class="btn btn-primary w-46"><!></button></div></div></div></div>'),
  jL = ae('<div class="disable-pinch-zoom relative h-full overflow-hidden"><div id="map" class="h-screen w-screen cursor-default"></div> <div><div><!> <!></div></div> <div><!> <div class="flex flex-col gap-1 max-sm:hidden"><button class="btn btn-sm btn-circle">+</button> <button class="btn btn-sm btn-circle">-</button></div> <!> <!> <!></div> <div><!> <!></div> <div><!></div> <div><!></div> <div><!></div>  <!></div> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>', 1);

function rR(y, l) {
  Gr(l, !0);
  let _ = Xe(!1);
  const x = ep,
    k = hb,
    z = new kn(k),
    T = x - .4,
    s = iT(xa.url),
    F = s.season ?? _v;
  let Z = Xe(0);
  const K = new Map;
  let G = Xe(void 0),
    re = Xe(14.5),
    he = Xe(!1);
  const me = Je(() => {
    var pt;
    return ((pt = bt.data) == null ? void 0 : pt.id) === 401
  });
  let q = Xe(!1),
    ye = Xe("select-pixel"),
    be = Xe(Wi(s.select && s.pos ? {
      name: "pixelSelected",
      latLon: [s.pos.lat, s.pos.lng]
    } : {
      name: "mainMenu"
    }));
  Oa(() => {
    We().then(dr => j(G, dr)).catch(dr => {
      Bt.error(G5(), {
        duration: 5e3
      }), console.error("Error setting up map:", dr)
    });
    let pt = [0, 0];

    function kt(dr) {
      var pi;
      if (h(G) && h(re) > x + 1) {
        const {
          lat: vi,
          lng: Ji
        } = h(G).unproject([dr.clientX, dr.clientY]), Zi = z.latLonToPixels(vi, Ji, x), Ei = Math.floor(Zi[0]), ca = Math.floor(Zi[1]);
        if (pt[0] !== Ei || pt[1] !== ca) {
          const Ir = z.latLonToPixelBoundsLatLon(vi, Ji, x),
            wr = hg(Ir, !0);
          (pi = h(G).getSource(Pe)) == null || pi.setCoordinates(wr), pt = [Ei, ca]
        }
      }
    }
    return window.addEventListener("mousemove", kt), () => {
      var dr;
      (dr = h(G)) == null || dr.remove(), window.removeEventListener("mousemove", kt), Ye && clearInterval(Ye), um()
    }
  }), fo(() => [vn.theme], () => {
    if (h(G)) {
      xe = !1;
      const pt = qe(vn.theme);
      h(G).setStyle(pt)
    }
  });

  function qe(pt) {
    return `https://maps.wplace.live/styles/${pt==="custom-winter"?"liberty":"fiord"}`
  }
  let xe = !1,
    Ye;
  async function We() {
    let pt = s.pos ? {
      ...s.pos,
      zoom: h(re)
    } : await G3();
    s.zoom !== void 0 && (pt.zoom = s.zoom), X3(pt) || (pt = {
      zoom: pt.zoom,
      ...U0.tokyo
    });
    const kt = await new Promise(Zi => {
        const Ei = new tp.Map({
          style: qe(vn.theme),
          center: pt,
          zoom: pt.zoom,
          container: "map",
          dragRotate: !1,
          doubleClickZoom: !1,
          pitch: 0,
          maxPitch: 0,
          attributionControl: !1
        });
        Ei.touchZoomRotate.disableRotation(), Ei.on("styledata", ca => {
          xe || (vn.theme === "custom-winter" && (Ei.setLayoutProperty("poi_transit", "visibility", "none"), Ei.setLayoutProperty("poi_r20", "visibility", "none"), Ei.setLayoutProperty("poi_r7", "visibility", "none"), Ei.setLayoutProperty("poi_r1", "visibility", "none"), Ei.setLayoutProperty("building", "visibility", "none"), Ei.setLayoutProperty("building-3d", "visibility", "none"), Ei.setLayoutProperty("landuse_pitch", "visibility", "none"), Ei.setLayoutProperty("landuse_hospital", "visibility", "none"), Ei.setLayoutProperty("landuse_school", "visibility", "none"), Ei.setLayoutProperty("landuse_residential", "visibility", "none"), Ei.setLayoutProperty("waterway_tunnel", "visibility", "none"), Ei.setFilter("water", ["all", ["!=", "brunnel", "tunnel"],
            ["!=", "class", "swimming_pool"]
          ])), vn.theme === "dark" && Ei.moveLayer("water", "waterway"), Se(Ei), Qe(), xe = !0)
        }), Ei.on("style.load", () => {
          Zi(Ei)
        })
      }),
      dr = xn.refreshIntervalMs;

    function pi() {
      let Zi = h(re) > x + 1.5 ? dr : 2.5 * dr;
      try {
        document.visibilityState === "visible" && Se(kt)
      } finally {
        setTimeout(pi, Zi)
      }
    }
    Ye = setTimeout(pi, dr), kt.on("load", () => {
      s.discordLinked && (Bt.success(W5()), xa.url.searchParams.delete("discord-linked"), xp(xa.url.toString())), s.twitchMigration && (Bt.success(H5()), xa.url.searchParams.delete("twitch-migration"), xp(xa.url.toString()))
    });
    let vi = h(re);
    kt.on("zoom", () => {
      j(re, kt.getZoom(), !0);
      const Zi = rL(h(re), 1);
      Zi != vi && (h(ot) && h(ot).setOpacity(ut(vi)), vi = Zi)
    });
    let Ji = "default";
    return kt.on("dragstart", () => {
      const Zi = kt.getCanvas();
      Ji = Zi.style.cursor, Zi.style.cursor = "move"
    }), kt.on("dragend", () => {
      kt.getCanvas().style.cursor = Ji
    }), kt.on("mouseout", () => {
      Ue()
    }), kt.on("click", async Zi => {
      var Ai;
      const Ei = Zi.lngLat.lat,
        ca = Zi.lngLat.lng,
        Ir = [Ei, ca];
      if (h(be).name === "paintingPixel" || h(be).name === "selectArea") return;
      if (h(be).name === "selectHq") {
        h(be).hq = Ir, (Ai = h(st)) == null || Ai.clearAndPlace(Ir);
        return
      }
      const wr = kt.getZoom();
      if (wr < T) {
        Bt.info(X5());
        return
      }
      so({
        lat: Ei,
        lng: ca
      }, wr), j(be, {
        name: "pixelSelected",
        latLon: Ir
      }, !0)
    }), kt
  }
  const ze = "pixel-art-layer";

  function Se(pt) {
    const kt = window.innerWidth,
      dr = `${p0}/s${_v}/tiles/{x}/{y}.png`;
    if (K.clear(), !pt.style) return;
    pt.getSource(ze) ? pt.refreshTiles(ze) : pt.addSource(ze, {
      type: "raster",
      tiles: [dr],
      minzoom: x,
      maxzoom: x,
      tileSize: kt > 640 ? 550 : 400
    }), pt.getLayer(ze) || pt.addLayer({
      id: ze,
      type: "raster",
      source: ze,
      paint: {
        "raster-resampling": "nearest",
        "raster-opacity": h(_t)
      }
    })
  }
  const Pe = "pixel-hover",
    Ae = 1e-5,
    Me = [
      [0, 0],
      [Ae, 0],
      [Ae, -Ae],
      [0, -Ae]
    ],
    Ee = .4;
  async function Qe() {
    var pt, kt, dr, pi;
    if (!((pt = h(G)) != null && pt.getSource(Pe))) {
      const vi = cy(await pp(U3));
      (kt = h(G)) == null || kt.addSource(Pe, {
        type: "canvas",
        canvas: vi,
        coordinates: Me
      })
    }(dr = h(G)) != null && dr.getLayer(Pe) || (pi = h(G)) == null || pi.addLayer({
      id: Pe,
      type: "raster",
      source: Pe,
      paint: {
        "raster-resampling": "nearest",
        "raster-opacity": Ee
      }
    })
  }

  function Ue() {
    var pt, kt;
    (kt = (pt = h(G)) == null ? void 0 : pt.getSource(Pe)) == null || kt.setCoordinates(Me)
  }
  let je = Xe(Wi(s.opaque ?? !0)),
    rt = Xe(!0),
    _t = Je(() => h(rt) ? h(je) ? 1 : .2 : 0);
  Qr(() => {
    var pt;
    (pt = h(G)) != null && pt.getLayer(ze) && h(G).setPaintProperty(ze, "raster-opacity", h(_t))
  });
  let dt = Xe(void 0),
    at = Xe(void 0),
    nt = Xe(void 0);
  Oa(() => (navigator.permissions.query({
    name: "geolocation"
  }).then(pt => {
    pt.state === "granted" && j(nt, navigator.geolocation.watchPosition(kt => {
      j(dt, kt)
    }, kt => {
      j(at, kt)
    }, {
      enableHighAccuracy: !1,
      maximumAge: 1e3,
      timeout: 6e3
    }), !0)
  }), () => {
    h(nt) && navigator.geolocation.clearWatch(h(nt))
  }));
  let ot = Xe(void 0);
  fo(() => [h(dt), h(G)], () => {
    var pt, kt;
    if (h(dt) && h(G)) {
      const dr = {
          lat: h(dt).coords.latitude,
          lng: h(dt).coords.longitude
        },
        pi = ut(h(re));
      if (!h(ot)) {
        const vi = document.createElement("div");
        vi.classList.add("maplibregl-user-location-dot"), vi.classList.add("cursor-auto"), j(ot, new tp.Marker({
          element: vi,
          opacity: pi
        }).setLngLat(dr).addTo(h(G)))
      }(kt = (pt = h(ot)) == null ? void 0 : pt.setLngLat(dr)) == null || kt.setOpacity(pi)
    }
  });

  function ut(pt) {
    return pt < x ? "1.0" : tL((pt - x) * .2, .5, 1).toFixed(2)
  }
  let st = Xe(void 0);
  Qr(() => {
    var pt;
    h(G) && ((pt = An(() => h(st))) == null || pt.clear(), pp(zv).then(kt => {
      j(st, new Lv({
        id: "select-crosshair",
        map: h(G),
        tileSize: k,
        zoom: x,
        img: kt,
        markerFn: () => {
          const dr = new tp.Marker({
            color: "#0069ff"
          });
          return dr.addClassName("z-20"), dr
        }
      }))
    }))
  });
  let wt = Xe(void 0);
  Qr(() => {
    var pt;
    h(G) && ((pt = An(() => h(st))) == null || pt.clear(), pp(zv).then(kt => {
      j(wt, new Lv({
        id: "paint-crosshair",
        map: h(G),
        tileSize: k,
        zoom: x,
        img: kt
      }))
    }))
  });
  let Ct = Xe(!1),
    rr = Xe(Wi(xa.url)),
    Zt = Xe(Wi({
      cityId: 0,
      countryId: 1,
      id: 0,
      name: "None",
      number: 1
    })),
    lt = Xe(!1);
  Qr(() => {
    var pt;
    j(lt, !!((pt = bt.data) != null && pt.needsPhoneVerification))
  });
  let ht = Xe([]),
    Dt = Je(() => h(re) < T ? "1.0" : h(re) < T + 2 ? "0.5" : "0.3");
  Qr(() => {
    var kt;
    const pt = (kt = bt.data) == null ? void 0 : kt.favoriteLocations;
    if (pt && h(G)) {
      for (const dr of An(() => h(ht))) dr.remove();
      j(ht, pt.map(dr => {
        const pi = document.createElement("div");
        pi.classList.add("text-yellow-400"), pi.classList.add("cursor-pointer"), pi.classList.add("z-10"), pi.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor">
					<path fill="#000a" d="m183-51 79-338L-1-617l346-29 135-319 135 319 346 29-263 228 79 338-297-180L183-51Z"/>
					<path d="m293-203.08 49.62-212.54-164.93-142.84 217.23-18.85L480-777.69l85.08 200.38 217.23 18.85-164.93 142.84L667-203.08 480-315.92 293-203.08Z"/>
				</svg>`;
        const vi = {
          lat: dr.latitude,
          lng: dr.longitude
        };
        return pi.addEventListener("click", Zi => {
          Zi.stopPropagation(), Vt([dr.latitude, dr.longitude])
        }), new tp.Marker({
          element: pi,
          opacity: h(Dt)
        }).setLngLat(vi).addTo(h(G))
      }))
    }
  });

  function Vt(pt) {
    var dr;
    const kt = {
      lat: pt[0],
      lng: pt[1]
    };
    (dr = h(G)) == null || dr.flyTo({
      center: kt,
      zoom: Math.max(h(re), 15)
    }), so(kt, h(re)), j(be, {
      name: "pixelSelected",
      latLon: [kt.lat, kt.lng]
    }, !0)
  }
  Qr(() => {
    const pt = h(be).name === "paintingPixel";
    for (const kt of h(ht)) pt ? kt.addClassName("hidden") : (kt.removeClassName("hidden"), kt.setOpacity(h(Dt)))
  });
  let Jt = Number.MAX_VALUE;
  Qr(() => {
    if (bt.charges !== void 0 && bt.data) {
      const pt = bt.data.charges.max,
        kt = bt.charges;
      Jt < pt && kt >= pt && aa.notification1.play(), Jt = bt.charges
    }
  });
  let jt = Xe(!1),
    nr = Date.now();
  Oa(() => {
    const pt = rT(),
      kt = () => {
        var pi;
        if (!document.hidden && Date.now() - nr > 30 * Ic.min) {
          if (pt) {
            const Ji = (pi = h(G)) == null ? void 0 : pi.getCenter();
            Ji && so(Ji, h(re)), window.location.replace(xa.url.origin)
          } else bt.refresh();
          nr = Date.now()
        }
      };
    return document.addEventListener("visibilitychange", kt), () => document.removeEventListener("visibilitychange", kt)
  }), Oa(() => {
    function pt() {
      Kr.online = !0
    }
    window.addEventListener("online", pt);

    function kt() {
      Kr.online = !1
    }
    return window.addEventListener("offline", kt), () => {
      window.removeEventListener("online", pt), window.removeEventListener("offline", kt)
    }
  }), Qr(() => {
    if (!Kr.online) {
      const pt = setInterval(() => {
        Kr.health().then(() => {
          Kr.online = !0, !bt.data && !bt.loading && bt.refresh()
        })
      }, 5e3);
      return () => {
        clearInterval(pt)
      }
    }
  }), Oa(() => {
    if (!navigator.serviceWorker) {
      setTimeout(() => {
        console.log("Setting up service worker message listener", navigator.serviceWorker), Bt.warning(Y5(), {
          duration: 5e3
        })
      });
      return
    }

    function pt(kt) {
      kt.data.type && h(G) && Se(h(G))
    }
    return navigator.serviceWorker.addEventListener("message", pt), () => {
      navigator.serviceWorker.removeEventListener("message", pt)
    }
  });
  let St = Xe(!1),
    Et = Xe("report-user"),
    Ut = Xe(void 0),
    Gt = Xe(void 0),
    Rt = Xe(void 0),
    ir = Xe(0),
    kr = Xe(void 0);
  Qr(() => {
    h(St) || (j(kr, void 0), j(Gt, void 0), j(Ut, void 0), j(Rt, void 0))
  });

  function _r() {
    j(be, {
      name: "mainMenu"
    }, !0), Ue()
  }
  let fr = Xe(!1),
    Yt = Xe(!1),
    sr = Xe(!1),
    Kt = Xe(!1),
    vr = Xe(!1),
    Lr = Xe(!1),
    ii = Xe(!!s.newUser),
    mr = Xe(!1),
    ge = Xe(!!s.alliance),
    V = Xe(!1);
  const U = Je(() => h(fr) || h(Yt) || h(sr) || h(Kt) || h(vr) || h(Lr) || h(ii) || h(mr) || h(ge) || h(V));
  var J = jL();
  Ci("keydown", qo, async pt => {
    if (!h(U) && !(pt.target instanceof HTMLInputElement || pt.target instanceof HTMLTextAreaElement) && !pt.ctrlKey) switch (pt.code) {
      case "KeyC":
        if (!bt.hasAnyPermission(Ba.tools.selectArea) || h(be).name === "paintingPixel" || pt.repeat) return;
        _r(), await Xm(), j(be, {
          name: "selectArea"
        }, !0);
        break
    }
  }), Q1("1uha8ag", pt => {
    var kt = gL();
    wi(6), J1(() => {
      $1.title = "Wplace - Paint the world"
    }), B(pt, kt)
  });
  var se = zt(J);
  {
    const pt = Ir => {
        var wr = _L();
        wr.__click = () => {
          j(je, !h(je))
        };
        var Ai = P(wr);
        {
          let gi = Je(() => !h(je));
          Ly(Ai, {
            class: "size-5",
            get filled() {
              return h(gi)
            }
          })
        }
        S(wr), ke(gi => {
          Xt(wr, "title", gi), Er(wr, 1, _l({
            "btn btn-lg btn-square sm:btn-xl z-30 shadow-md": !0,
            "text-base-content/80": h(je),
            "btn-primary btn-soft": !h(je)
          }))
        }, [() => P0()]), B(Ir, wr)
      },
      kt = Ir => {
        var wr = yL();
        wr.__click = async () => {
          var _i;
          h(dt) || j(dt, await new Promise((Ar, ri) => {
            navigator.geolocation.getCurrentPosition(Xi => {
              Ar(Xi)
            }, Xi => {
              ri(Xi)
            })
          })), h(dt) && (so({
            lat: h(dt).coords.latitude,
            lng: h(dt).coords.longitude
          }, h(re)), (_i = h(G)) == null || _i.flyTo({
            center: {
              lat: h(dt).coords.latitude,
              lng: h(dt).coords.longitude
            },
            zoom: 16.5
          }))
        };
        var Ai = P(wr);
        {
          var gi = _i => {
              KE(_i, {
                class: "size-5.5 fill-blue-800"
              })
            },
            Cr = _i => {
              var Ar = vL(),
                ri = P(Ar);
              XE(ri, {
                class: "size-5.5 fill-red-400"
              }), wi(2), S(Ar), B(_i, Ar)
            };
          Te(Ai, _i => {
            h(dt) ? _i(gi) : _i(Cr, !1)
          })
        }
        S(wr), ke(_i => Xt(wr, "title", _i), [() => V5()]), B(Ir, wr)
      };
    var te = E(P(se), 2);
    let dr;
    var _e = P(te);
    let pi;
    var Re = P(_e);
    {
      var ne = Ir => {
          var wr = xL();
          wr.__click = () => {
            var gi;
            j(Kt, !0), h(G) && so((gi = h(G)) == null ? void 0 : gi.getCenter(), h(re))
          };
          var Ai = P(wr, !0);
          S(wr), ke(gi => ee(Ai, gi), [() => K5()]), B(Ir, wr)
        },
        oe = Ir => {
          var wr = br(),
            Ai = zt(wr);
          {
            var gi = Cr => {
              var _i = wL(),
                Ar = P(_i);
              {
                var ri = Vi => {
                  var Di = bL(),
                    ki = P(Di);
                  N0(ki, {
                    get role() {
                      return bt.data.role
                    }
                  }), S(Di), B(Vi, Di)
                };
                Te(Ar, Vi => {
                  var Di;
                  (Di = bt.data) != null && Di.role && bt.data.role !== "user" && Vi(ri)
                })
              }
              var Xi = E(Ar, 2);
              qk(Xi, {
                get user() {
                  return bt
                },
                onlogout: () => {
                  j(be, {
                    name: "mainMenu"
                  }, !0)
                },
                onbanappeal: () => {
                  j(fr, !0)
                },
                onnotificationclick: () => {
                  j(Yt, !0)
                },
                ontogglepixelarts: Vi => {
                  j(rt, Vi, !0)
                }
              }), S(_i), dn(3, _i, () => Jn, () => ({
                duration: 150
              })), B(Cr, _i)
            };
            Te(Ai, Cr => {
              bt.data && h(G) && h(be).name !== "paintingPixel" && Cr(gi)
            }, !0)
          }
          B(Ir, wr)
        };
      Te(Re, Ir => {
        !bt.loading && !bt.data ? Ir(ne) : Ir(oe, !1)
      })
    }
    var fe = E(Re, 2);
    {
      var ve = Ir => {
          var wr = IL(),
            Ai = P(wr);
          {
            var gi = zi => {
              var yi = TL(),
                fi = zt(yi);
              fi.__click = () => {
                var Da;
                j(vr, !0);
                const ua = (Da = h(G)) == null ? void 0 : Da.getCenter();
                ua && so(ua, h(re))
              };
              var tn = P(fi);
              Fy(tn, {
                class: "size-5"
              }), S(fi);
              var Yi = E(fi, 2);
              Yi.__click = () => {
                j(ge, !0)
              };
              var sa = P(Yi);
              Up(sa, {
                class: "size-5"
              }), S(Yi), ke((ua, Da) => {
                Xt(fi, "title", ua), Xt(Yi, "title", Da)
              }, [() => A0(), () => Np()]), B(zi, yi)
            };
            Te(Ai, zi => {
              bt.data && zi(gi)
            })
          }
          var Cr = E(Ai, 2);
          Cr.__click = () => {
            j(Lr, !0)
          };
          var _i = P(Cr);
          Ay(_i, {
            class: "size-5"
          }), S(Cr);
          var Ar = E(Cr, 2);
          Ar.__click = () => {
            j(sr, !0)
          };
          var ri = P(Ar);
          eL(ri, {
            class: "size-5"
          }), S(Ar);
          var Xi = E(Ar, 2);
          {
            var Vi = zi => {
              var yi = SL();
              yi.__click = () => {
                h(G) && j(be, {
                  name: "adminAutoPaint"
                }, !0)
              };
              var fi = P(yi);
              Vo(fi, {
                class: "size-5"
              }), S(yi), B(zi, yi)
            };
            Te(Xi, zi => {
              bt.hasPermission(Ba.tools.autoPainter) && zi(Vi)
            })
          }
          var Di = E(Xi, 2);
          {
            var ki = zi => {
              var yi = PL();
              yi.__click = () => {
                h(G) && j(_, !0)
              };
              var fi = P(yi);
              mL(fi, {
                class: "size-5"
              }), S(yi), B(zi, yi)
            };
            Te(Di, zi => {
              bt.hasPermission("staff.tools.wayback.video") && zi(ki)
            })
          }
          S(wr), ke((zi, yi) => {
            Xt(Cr, "title", zi), Xt(Ar, "title", yi)
          }, [() => cg(), () => k0()]), dn(3, wr, () => Jn, () => ({
            duration: 150
          })), B(Ir, wr)
        },
        ie = Ir => {
          var wr = br(),
            Ai = zt(wr);
          {
            var gi = Cr => {
              var _i = ML(),
                Ar = P(_i);
              let ri;
              Ar.__click = () => {
                j(he, !h(he))
              };
              var Xi = P(Ar);
              {
                var Vi = ki => {
                    rh(ki, {
                      class: "size-5"
                    })
                  },
                  Di = ki => {
                    kp(ki, {
                      class: "size-5"
                    })
                  };
                Te(Xi, ki => {
                  h(he) ? ki(Vi) : ki(Di, !1)
                })
              }
              S(Ar), S(_i), ke(ki => {
                Xt(Ar, "title", ki), ri = Er(Ar, 1, "btn btn-square not-touchscreen:hidden shadow-md", null, ri, {
                  "btn-primary": h(he)
                })
              }, [() => h(he) ? T3() : t3()]), dn(1, _i, () => Jn, () => ({
                delay: 150,
                duration: 150
              })), B(Cr, _i)
            };
            Te(Ai, Cr => {
              h(G) && h(be).name === "paintingPixel" && Cr(gi)
            }, !0)
          }
          B(Ir, wr)
        };
      Te(fe, Ir => {
        h(G) && h(be).name !== "paintingPixel" ? Ir(ve) : Ir(ie, !1)
      })
    }
    S(_e), S(te);
    var Y = E(te, 2);
    let vi;
    var Fe = P(Y);
    {
      var Ne = Ir => {
        var wr = CL();
        wr.__click = () => {
          j(mr, !0)
        };
        var Ai = P(wr);
        WE(Ai, {
          class: "size-3.5"
        }), S(wr), ke(gi => Xt(wr, "title", gi), [() => J5()]), B(Ir, wr)
      };
      Te(Fe, Ir => {
        h(be).name !== "paintingPixel" && Ir(Ne)
      })
    }
    var Ge = E(Fe, 2),
      pe = P(Ge);
    pe.__click = () => {
      var Ir;
      (Ir = h(G)) == null || Ir.zoomIn()
    };
    var Ve = E(pe, 2);
    Ve.__click = () => {
      var Ir;
      (Ir = h(G)) == null || Ir.zoomOut()
    }, S(Ge);
    var it = E(Ge, 2);
    {
      var yt = Ir => {
        var wr = AL(),
          Ai = E(P(wr), 2);
        Ai.__click = () => {
          j(be, {
            name: "selectArea"
          }, !0)
        };
        var gi = P(Ai);
        Gm(gi, {
          class: "size-4"
        }), S(Ai), S(wr), B(Ir, wr)
      };
      Te(it, Ir => {
        h(be).name !== "paintingPixel" && bt.hasAnyPermission(Ba.tools.selectArea) && Ir(yt)
      })
    }
    var Lt = E(it, 2);
    {
      var ct = Ir => {
        var wr = kL(),
          Ai = P(wr);
        Ry(Ai, {
          class: "size-4",
          onclick: () => {
            j(q, !h(q))
          }
        }), S(wr), ke(gi => Xt(wr, "title", gi), [() => $5()]), B(Ir, wr)
      };
      Te(Lt, Ir => {
        h(me) && Ir(ct)
      })
    }
    var At = E(Lt, 2);
    {
      var qt = Ir => {
        var wr = zL();
        wr.__click = () => {
          window.location.replace(xa.url.origin)
        };
        var Ai = P(wr);
        R3(Ai, {
          class: "size-3"
        }), S(wr), ke(gi => Xt(wr, "title", gi), [() => B3()]), B(Ir, wr)
      };
      Te(At, Ir => {
        h(be).name !== "paintingPixel" && Ir(qt)
      })
    }
    S(Y);
    var Ke = E(Y, 2);
    let Ji;
    var Tt = P(Ke);
    {
      var Wt = Ir => {
        var wr = EL(),
          Ai = P(wr);
        F3(Ai, {
          class: "size-5"
        });
        var gi = E(Ai);
        S(wr), ke(Cr => ee(gi, ` ${Cr??""}`), [() => Q5()]), dn(1, wr, () => Jn, () => ({
          duration: 1e3
        })), dn(2, wr, () => Jn), B(Ir, wr)
      };
      Te(Tt, Ir => {
        Kr.online || Ir(Wt)
      })
    }
    var Fr = E(Tt, 2);
    {
      var or = Ir => {
        var wr = LL();
        wr.__click = () => {
          var Cr;
          (Cr = h(G)) == null || Cr.flyTo({
            center: h(G).getCenter(),
            zoom: x
          })
        };
        var Ai = P(wr);
        $E(Ai, {
          class: "size-5"
        });
        var gi = E(Ai);
        S(wr), ke(Cr => ee(gi, ` ${Cr??""}`), [() => e3()]), dn(3, wr, () => Jn, () => ({
          duration: 300
        })), B(Ir, wr)
      };
      Te(Fr, Ir => {
        h(re) < T && Ir(or)
      })
    }
    S(Ke);
    var tt = E(Ke, 2);
    let Zi;
    var Ht = P(tt);
    pt(Ht), S(tt);
    var Qt = E(tt, 2);
    let Ei;
    var Sr = P(Qt);
    {
      var ei = Ir => {
          {
            let wr = Je(() => h(Z) - 96 - 32);
            zy(Ir, {
              class: "z-30",
              get maxWidth() {
                return h(wr)
              },
              onclick: () => {
                var Ai;
                (Ai = bt.data) != null && Ai.needsPhoneVerification ? (j(lt, !0), Bt.warning(Mv())) : bt.charges !== void 0 && bt.charges < 1 ? Bt.warning($6, {
                  icon: $u
                }) : h(G) && bt.data ? (aa.smallDropplet.play(), j(be, {
                  name: "paintingPixel"
                }, !0)) : (j(Kt, !0), h(G) && so(h(G).getCenter(), h(re)))
              },
              get disabled() {
                return bt.loading
              },
              get loading() {
                return bt.loading
              },
              get charges() {
                return bt.charges
              }
            })
          }
        },
        li = Ir => {
          var wr = DL();
          B(Ir, wr)
        };
      Te(Sr, Ir => {
        h(be).name === "mainMenu" ? Ir(ei) : Ir(li, !1)
      })
    }
    S(Qt);
    var Dr = E(Qt, 2);
    let ca;
    var Oi = P(Dr);
    kt(Oi), S(Dr);
    var Jr = E(Dr, 2);
    {
      var It = Ir => {
        var wr = br(),
          Ai = zt(wr);
        {
          var gi = _i => {
              var Ar = RL(),
                ri = P(Ar),
                Xi = P(ri);
              yz(Xi, {
                get latLon() {
                  return h(be).latLon
                },
                get map() {
                  return h(G)
                },
                get crosshair() {
                  return h(st)
                },
                get pixelInfoCache() {
                  return K
                },
                get season() {
                  return F
                },
                get tileSize() {
                  return k
                },
                get pixelArtZoom() {
                  return x
                },
                get zoom() {
                  return h(re)
                },
                get opaquePixelArt() {
                  return h(je)
                },
                onclose: () => j(be, {
                  name: "mainMenu"
                }, !0),
                onclickshare: Vi => {
                  j(rr, Vi, !0), j(Ct, !0)
                },
                onclickpaint: ([Vi, Di]) => {
                  var zi, yi, fi;
                  if (!bt.data) {
                    j(Kt, !0);
                    return
                  }
                  if ((zi = bt.data) != null && zi.needsPhoneVerification) {
                    j(lt, !0), Bt.warning(Mv());
                    return
                  }
                  if (bt.charges !== void 0 && bt.charges < 1) {
                    Bt.warning(r3());
                    return
                  }
                  const ki = dg(z.latLonToPixelBoundsLatLon(Vi, Di, x));
                  (yi = h(G)) == null || yi.flyTo({
                    center: {
                      lat: ki[0],
                      lon: ki[1]
                    }
                  }), j(be, {
                    name: "paintingPixel",
                    clickedLatLon: [Vi, Di]
                  }, !0), (fi = h(st)) == null || fi.clear()
                },
                onclickregion: Vi => {
                  j(Zt, Vi, !0), j(V, !0)
                },
                onclickmodaction: (Vi, Di, ki, zi) => {
                  var tn, Yi, sa;
                  (tn = h(G)) == null || tn.setZoom(Math.max(h(re), x + 3.5));
                  const yi = z.latLonToPixelBoundsLatLon(ki[0], ki[1], x);
                  if ((Yi = h(G)) == null || Yi.setCenter({
                      lat: yi.min[0],
                      lng: (yi.max[1] + yi.min[1]) / 2
                    }), !(Vi != null && Vi.paintedBy)) {
                    Bt.error(kv());
                    return
                  }
                  const fi = Vi.paintedBy;
                  j(Ut, Di, !0), j(Gt, [{
                    id: fi.id,
                    name: fi.name,
                    picture: fi.picture,
                    allianceId: fi.allianceId ?? void 0,
                    allianceName: fi.allianceName ?? void 0,
                    timedOut: fi.timedOut,
                    banned: fi.banned
                  }], !0), j(Rt, ki, !0), j(ir, ((sa = h(G)) == null ? void 0 : sa.getZoom()) ?? 0, !0), j(Et, zi, !0), j(kr, void 0), j(St, !0), j(ye, "select-pixel")
                },
                get christmasTreeId() {
                  return h(be).christmasTreeId
                }
              }), S(ri), S(Ar), dn(3, ri, () => lp, () => ({
                duration: 100
              })), B(_i, Ar)
            },
            Cr = _i => {
              var Ar = br(),
                ri = zt(Ar);
              {
                var Xi = Di => {
                    var ki = FL(),
                      zi = P(ki),
                      yi = P(zi);
                    aA(yi, {
                      get map() {
                        return h(G)
                      },
                      get clickedLatLon() {
                        return h(be).clickedLatLon
                      },
                      get tileSize() {
                        return k
                      },
                      get tileZoom() {
                        return x
                      },
                      get season() {
                        return F
                      },
                      get zoom() {
                        return h(re)
                      },
                      get crosshair() {
                        return h(wt)
                      },
                      refreshPixelArt: () => h(G) && Se(h(G)),
                      hidePixelHover: Ue,
                      hoverLayerId: Pe,
                      onclose: () => {
                        j(be, {
                          name: "mainMenu"
                        }, !0), Ue()
                      },
                      get screenLocked() {
                        return h(he)
                      },
                      set screenLocked(fi) {
                        j(he, fi, !0)
                      },
                      get opaquePixelArt() {
                        return h(je)
                      },
                      set opaquePixelArt(fi) {
                        j(je, fi, !0)
                      }
                    }), S(zi), S(ki), dn(3, zi, () => lp, () => ({
                      duration: 100
                    })), B(Di, ki)
                  },
                  Vi = Di => {
                    var ki = br(),
                      zi = zt(ki);
                    {
                      var yi = tn => {
                          var Yi = BL(),
                            sa = P(Yi);
                          Z8(sa, {
                            get map() {
                              return h(G)
                            },
                            get tileSize() {
                              return k
                            },
                            get pixelArtZoom() {
                              return ep
                            },
                            get season() {
                              return F
                            },
                            get crosshair() {
                              return h(wt)
                            },
                            onmodaction: ua => {
                              var Mi;
                              const {
                                targets: Da,
                                image: Pa,
                                latLon: ea,
                                zoom: pa,
                                action: Ia,
                                onSuccess: Na
                              } = ua;
                              if (!Da || Da.length === 0) {
                                Bt.error(kv());
                                return
                              }
                              j(Ut, Pa, !0), j(Gt, Da, !0), j(Rt, ea, !0), j(ir, pa ?? ((Mi = h(G)) == null ? void 0 : Mi.getZoom()) ?? 0, !0), j(Et, Ia, !0), j(kr, {
                                onSuccess: Na
                              }, !0), j(St, !0), j(ye, "select-area")
                            },
                            onclose: _r
                          }), S(Yi), B(tn, Yi)
                        },
                        fi = tn => {
                          var Yi = br(),
                            sa = zt(Yi);
                          {
                            var ua = Pa => {
                                AS(Pa, {
                                  get map() {
                                    return h(G)
                                  },
                                  get tileSize() {
                                    return k
                                  },
                                  get tileZoom() {
                                    return x
                                  },
                                  get season() {
                                    return F
                                  },
                                  refreshPixelArt: () => h(G) && Se(h(G)),
                                  onclose: () => {
                                    j(be, {
                                      name: "mainMenu"
                                    }, !0)
                                  }
                                })
                              },
                              Da = Pa => {
                                var ea = br(),
                                  pa = zt(ea);
                                {
                                  var Ia = Na => {
                                    var Mi = OL(),
                                      wn = P(Mi),
                                      Ti = P(wn),
                                      Si = P(Ti),
                                      Bn = P(Si),
                                      Fi = P(Bn);
                                    Dy(Fi, {
                                      class: "inline size-4"
                                    });
                                    var On = E(Fi);
                                    S(Bn);
                                    var Va = E(Bn, 2);
                                    Va.__click = () => {
                                      j(be, {
                                        name: "mainMenu"
                                      }, !0)
                                    };
                                    var es = P(Va);
                                    ss(es, {
                                      class: "size-4"
                                    }), S(Va), S(Si);
                                    var jn = E(Si, 2),
                                      Tn = P(jn);
                                    Tn.__click = async () => {
                                      var qn;
                                      if (h(be).name === "selectHq") {
                                        const ts = h(be).hq;
                                        if (ts) try {
                                          j(jt, !0), await Kr.updateAllianceHeadquarters(ts[0], ts[1]), (qn = h(st)) == null || qn.clear(), j(ge, !0), j(be, {
                                            name: "mainMenu"
                                          }, !0)
                                        } catch (fa) {
                                          Bt.error(fa.message)
                                        } finally {
                                          j(jt, !1)
                                        }
                                      }
                                    };
                                    var os = P(Tn);
                                    wg(os, {
                                      class: "size-6"
                                    }), S(Tn), S(jn), S(Ti), S(wn), S(Mi), ke(qn => {
                                      ee(On, ` ${qn??""}`), Tn.disabled = h(be).hq === void 0 || h(jt)
                                    }, [() => i3()]), dn(3, wn, () => lp, () => ({
                                      duration: 100
                                    })), B(Na, Mi)
                                  };
                                  Te(pa, Na => {
                                    h(be).name === "selectHq" && Na(Ia)
                                  }, !0)
                                }
                                B(Pa, ea)
                              };
                            Te(sa, Pa => {
                              h(be).name === "adminAutoPaint" && h(G) ? Pa(ua) : Pa(Da, !1)
                            }, !0)
                          }
                          B(tn, Yi)
                        };
                      Te(zi, tn => {
                        h(be).name === "selectArea" ? tn(yi) : tn(fi, !1)
                      }, !0)
                    }
                    B(Di, ki)
                  };
                Te(ri, Di => {
                  h(be).name === "paintingPixel" && h(wt) ? Di(Xi) : Di(Vi, !1)
                }, !0)
              }
              B(_i, Ar)
            };
          Te(Ai, _i => {
            h(be).name === "pixelSelected" && h(st) ? _i(gi) : _i(Cr, !1)
          })
        }
        B(Ir, wr)
      };
      Te(Jr, Ir => {
        h(G) && Ir(It)
      })
    }
    S(se), ke((Ir, wr) => {
      dr = Er(te, 1, "absolute top-2 right-2 z-40", null, dr, {
        hidden: h(q)
      }), pi = Er(_e, 1, "flex flex-col gap-4", null, pi, {
        "items-end": !bt.data,
        "items-center": bt.data
      }), vi = Er(Y, 1, "absolute top-2 left-2 z-30 flex flex-col gap-3", null, vi, {
        hidden: h(q)
      }), Xt(pe, "title", Ir), Xt(Ve, "title", wr), Ji = Er(Ke, 1, "absolute top-2 left-1/2 z-30 flex -translate-x-1/2 flex-col items-center justify-center gap-2", null, Ji, {
        hidden: h(q)
      }), Zi = Er(tt, 1, "absolute bottom-3 left-3 z-30", null, Zi, {
        hidden: h(q)
      }), Ei = Er(Qt, 1, "absolute bottom-3 left-1/2 z-30 -translate-x-1/2", null, Ei, {
        hidden: h(q)
      }), ca = Er(Dr, 1, "absolute right-3 bottom-3 z-30", null, ca, {
        hidden: h(q)
      })
    }, [() => U5(), () => Z5()])
  }
  var er = E(se, 2);
  {
    var Pr = pt => {
      pL(pt, {
        get map() {
          return h(G)
        },
        get season() {
          return F
        },
        get tileSize() {
          return k
        },
        get pixelArtZoom() {
          return ep
        },
        refreshPixelArt: () => h(G) && Se(h(G)),
        onclose: () => {
          j(_, !1)
        }
      })
    };
    Te(er, pt => {
      h(_) && h(G) && pt(Pr)
    })
  }
  var pr = E(er, 2);
  K6(pr, {
    get open() {
      return h(Kt)
    },
    set open(pt) {
      j(Kt, pt, !0)
    }
  });
  var qr = E(pr, 2);
  ZE(qr, {
    get open() {
      return h(vr)
    },
    set open(pt) {
      j(vr, pt, !0)
    }
  });
  var ur = E(qr, 2);
  dI(ur, {
    get open() {
      return h(ii)
    },
    set open(pt) {
      j(ii, pt, !0)
    }
  });
  var Mr = E(ur, 2);
  kI(Mr, {
    get open() {
      return h(mr)
    },
    set open(pt) {
      j(mr, pt, !0)
    }
  });
  var di = E(Mr, 2);
  H6(di, {
    onvisitclick: pt => {
      var kt;
      (kt = h(G)) == null || kt.flyTo({
        center: pt,
        zoom: ep + 1
      }), so(pt, h(re)), K3.push({
        pos: pt,
        zoom: h(re)
      }), j(Lr, !1)
    },
    get open() {
      return h(Lr)
    },
    set open(pt) {
      j(Lr, pt, !0)
    }
  });
  var ti = E(di, 2);
  e8(ti, {
    get region() {
      return h(Zt)
    },
    get open() {
      return h(V)
    },
    set open(pt) {
      j(V, pt, !0)
    }
  });
  var Vr = E(ti, 2);
  yb(Vr, {
    get open() {
      return vn.dropletsDialogOpen
    },
    set open(pt) {
      vn.dropletsDialogOpen = pt
    }
  });
  var Rr = E(Vr, 2);
  {
    var ni = pt => {
      YP(pt, {
        onhqchange: () => {
          j(be, {
            name: "selectHq"
          }, !0), j(ge, !1)
        },
        onhqclick: kt => {
          var dr;
          (dr = h(G)) == null || dr.flyTo({
            center: kt,
            zoom: Math.max(h(re), 15)
          }), j(be, {
            name: "pixelSelected",
            latLon: [kt.lat, kt.lng]
          }, !0), j(ge, !1)
        },
        onlastpixelclick: kt => {
          var dr;
          (dr = h(G)) == null || dr.flyTo({
            center: kt,
            zoom: Math.max(h(re), 15)
          }), j(be, {
            name: "pixelSelected",
            latLon: [kt.lat, kt.lng]
          }, !0), j(ge, !1)
        },
        get open() {
          return h(ge)
        },
        set open(kt) {
          j(ge, kt, !0)
        }
      })
    };
    Te(Rr, pt => {
      h(G) && pt(ni)
    })
  }
  var Ri = E(Rr, 2);
  {
    var qi = pt => {
      sI(pt, {
        get url() {
          return h(rr)
        },
        get map() {
          return h(G)
        },
        hideHover: () => {
          var kt, dr;
          (kt = h(G)) == null || kt.setPaintProperty(Pe, "raster-opacity", 0), (dr = h(st)) == null || dr.setCanvasOpacity(0)
        },
        showHover: () => {
          var kt, dr;
          (kt = h(G)) == null || kt.setPaintProperty(Pe, "raster-opacity", Ee), (dr = h(st)) == null || dr.setCanvasOpacity(1)
        },
        get open() {
          return h(Ct)
        },
        set open(kt) {
          j(Ct, kt, !0)
        }
      })
    };
    Te(Ri, pt => {
      h(G) && pt(qi)
    })
  }
  var ai = E(Ri, 2);
  {
    var Pt = pt => {
      p3(pt, {
        get image() {
          return h(Ut)
        },
        get targets() {
          return h(Gt)
        },
        get latLon() {
          return h(Rt)
        },
        get zoom() {
          return h(ir)
        },
        get action() {
          return h(Et)
        },
        onsuccess: () => {
          var kt, dr;
          (dr = (kt = h(kr)) == null ? void 0 : kt.onSuccess) == null || dr.call(kt)
        },
        get origin() {
          return h(ye)
        },
        get open() {
          return h(St)
        },
        set open(kt) {
          j(St, kt, !0)
        }
      })
    };
    Te(ai, pt => {
      h(Gt) && h(Gt).length > 0 && h(Ut) && h(Rt) && pt(Pt)
    })
  }
  var tr = E(ai, 2);
  {
    var Br = pt => {
      sA(pt, {
        get userData() {
          return bt.data
        },
        get open() {
          return h(fr)
        },
        set open(kt) {
          j(fr, kt, !0)
        }
      })
    };
    Te(tr, pt => {
      bt.data && pt(Br)
    })
  }
  var Zr = E(tr, 2);
  mC(Zr, {
    get open() {
      return h(Yt)
    },
    set open(pt) {
      j(Yt, pt, !0)
    }
  });
  var ci = E(Zr, 2);
  {
    var ui = pt => {
      m8(pt, {
        get map() {
          return h(G)
        },
        get tileSize() {
          return k
        },
        get season() {
          return F
        },
        get tileZoom() {
          return x
        },
        get open() {
          return h(sr)
        },
        set open(kt) {
          j(sr, kt, !0)
        }
      })
    };
    Te(ci, pt => {
      h(G) && pt(ui)
    })
  }
  Eh("innerWidth", pt => j(Z, pt, !0)), B(y, J), Wr()
}
Ui(["click"]);
export {
  rR as component
};