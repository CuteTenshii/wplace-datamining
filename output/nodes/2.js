var Ey = Object.defineProperty;
var _g = y => {
  throw TypeError(y)
};
var zy = (y, l, _) => l in y ? Ey(y, l, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: _
}) : y[l] = _;
var fr = (y, l, _) => zy(y, typeof l != "symbol" ? l + "" : l, _),
  uf = (y, l, _) => l.has(y) || _g("Cannot " + _);
var st = (y, l, _) => (uf(y, l, "read from private field"), _ ? _.call(y) : l.get(y)),
  Pr = (y, l, _) => l.has(y) ? _g("Cannot add the same private member more than once") : l instanceof WeakSet ? l.add(y) : l.set(y, _),
  Xn = (y, l, _, T) => (uf(y, l, "write to private field"), T ? T.call(y, _) : l.set(y, _), _),
  Rr = (y, l, _) => (uf(y, l, "access private method"), _);
import "../chunks/Bzak7iHL.js";
import {
  o as Ii,
  s as Qi
} from "../chunks/CVpIJCQG.js";
import {
  S as Ly,
  a_ as Dy,
  bj as Ry,
  b0 as By,
  bg as Fy,
  bk as Oy,
  bb as Ny,
  g as jy,
  h as gg,
  e as qy,
  i as Vy,
  j as Zy,
  k as $y,
  l as Uy,
  m as Gy,
  aD as Hy,
  n as Wy,
  a1 as Xy,
  bl as Ky,
  bm as Xf,
  aQ as Yy,
  W as Jy,
  ao as kn,
  E as Qy,
  bn as ex,
  bo as tx,
  a2 as rx,
  v as so,
  bp as ix,
  bq as nx,
  br as ax,
  aS as _t,
  y as b,
  aI as he,
  aH as En,
  p as kr,
  aU as vt,
  q as $r,
  f as De,
  d as E,
  s as $,
  bs as sx,
  r as A,
  t as lt,
  b as H,
  c as Er,
  ak as en,
  aB as mi,
  bc as bn,
  aC as wr,
  be as Pu,
  u as Kf,
  aT as sr,
  a as Et,
  aV as sa,
  ax as ox,
  aw as vg,
  ay as lx,
  aA as Vg,
  bt as Za,
  bu as Zg,
  al as cx,
  am as ux
} from "../chunks/BUjsOn5w.js";
import {
  a as hx,
  s as Te
} from "../chunks/tlM6Zgdz.js";
import {
  p as It,
  i as et,
  r as Yt,
  s as lo,
  u as $g
} from "../chunks/BEdNL48M.js";
import {
  s as Vr,
  b as Br,
  r as $a,
  e as qn,
  f as Ug,
  a as Kt,
  d as cc,
  g as Su,
  c as Xo
} from "../chunks/Cx7BSLZW.js";
import {
  c as dx,
  e as xn,
  i as Yf
} from "../chunks/DZ6afX6-.js";
import {
  p as Va
} from "../chunks/4009TGBk.js";
import {
  S as jn,
  a as ci,
  t as Zr,
  u as Ot,
  h as as,
  g as aa,
  c as px,
  C as yg,
  i as xg,
  j as fx,
  k as mx,
  l as _x
} from "../chunks/CmXEhbGB.js";
import {
  c as Gg,
  A as ha,
  a as bf,
  g as hf,
  p as gx,
  b as vx
} from "../chunks/DmQhqxnR.js";
import {
  g as Hg,
  b as yx
} from "../chunks/DvuTo9H4.js";
import {
  h as xx
} from "../chunks/h2W_5Jzs.js";
import {
  b as Ss
} from "../chunks/DZCdaKGh.js";
import {
  j as jd,
  g as Jf,
  k as Qf,
  a as ss,
  l as Yn,
  A as bx,
  m as Wg,
  i as ec,
  t as Xg,
  n as em,
  D as Kg,
  c as qd,
  r as wx,
  o as Tx,
  p as Cx,
  q as Sx,
  I as bg,
  e as Px,
  f as Ix,
  s as Mx,
  P as Yg,
  d as Ax
} from "../chunks/BOcOBLAN.js";
import {
  g as Ue,
  l as kx
} from "../chunks/C5GsJ62f.js";
import "../chunks/Cj-nAB2C.js";
import {
  i as Jg
} from "../chunks/C2N1yofn.js";
import {
  L as Qg
} from "../chunks/awI6yFUk.js";
import {
  c as cn
} from "../chunks/dV0J5liF.js";
import {
  L as Ex,
  T as ev,
  a as zx
} from "../chunks/BSGgKtnp.js";
import {
  _ as Lx
} from "../chunks/Dp1pzeXC.js";
import {
  R as Dx,
  r as Rx,
  W as Bx
} from "../chunks/B6hSv56A.js";
const Fx = [];

function Ox(y, l = !1) {
  return Cd(y, new Map, "", Fx)
}

function Cd(y, l, _, T, z = null) {
  if (typeof y == "object" && y !== null) {
    var F = l.get(y);
    if (F !== void 0) return F;
    if (y instanceof Map) return new Map(y);
    if (y instanceof Set) return new Set(y);
    if (Ly(y)) {
      var C = Array(y.length);
      l.set(y, C), z !== null && l.set(z, C);
      for (var o = 0; o < y.length; o += 1) {
        var K = y[o];
        o in y && (C[o] = Cd(K, l, _, T))
      }
      return C
    }
    if (Dy(y) === Ry) {
      C = {}, l.set(y, C), z !== null && l.set(z, C);
      for (var G in y) C[G] = Cd(y[G], l, _, T);
      return C
    }
    if (y instanceof Date) return structuredClone(y);
    if (typeof y.toJSON == "function") return Cd(y.toJSON(), l, _, T, y)
  }
  if (y instanceof EventTarget) return y;
  try {
    return structuredClone(y)
  } catch {
    return y
  }
}

function Nx() {
  return Symbol(By)
}

function Iu(y, l, _) {
  gg && qy();
  var T = y,
    z = Hy,
    F, C, o = null,
    K = Fy() ? Oy : Ny;

  function G() {
    F && Wy(F), o !== null && (o.lastChild.remove(), T.before(o), o = null), F = C
  }
  jy(() => {
    if (K(z, z = l())) {
      var ie = T,
        de = Uy();
      de && (o = document.createDocumentFragment(), o.append(ie = Vy())), C = Zy(() => _(ie)), de ? $y.add_callback(G) : G()
    }
  }), gg && (T = Gy)
}
const jx = () => performance.now(),
  Cs = {
    tick: y => requestAnimationFrame(y),
    now: () => jx(),
    tasks: new Set
  };

function tv() {
  const y = Cs.now();
  Cs.tasks.forEach(l => {
    l.c(y) || (Cs.tasks.delete(l), l.f())
  }), Cs.tasks.size !== 0 && Cs.tick(tv)
}

function qx(y) {
  let l;
  return Cs.tasks.size === 0 && Cs.tick(tv), {
    promise: new Promise(_ => {
      Cs.tasks.add(l = {
        c: y,
        f: _
      })
    }),
    abort() {
      Cs.tasks.delete(l)
    }
  }
}

function xd(y, l) {
  Xf(() => {
    y.dispatchEvent(new CustomEvent(l))
  })
}

function Vx(y) {
  if (y === "float") return "cssFloat";
  if (y === "offset") return "cssOffset";
  if (y.startsWith("--")) return y;
  const l = y.split("-");
  return l.length === 1 ? l[0] : l[0] + l.slice(1).map(_ => _[0].toUpperCase() + _.slice(1)).join("")
}

function wg(y) {
  const l = {},
    _ = y.split(";");
  for (const T of _) {
    const [z, F] = T.split(":");
    if (!z || F === void 0) break;
    const C = Vx(z.trim());
    l[C] = F.trim()
  }
  return l
}
const Zx = y => y;

function Yo(y, l, _) {
  var T = dx,
    z, F, C, o = null;
  T.a ?? (T.a = {
    element: y,
    measure() {
      z = this.element.getBoundingClientRect()
    },
    apply() {
      if (C == null || C.abort(), F = this.element.getBoundingClientRect(), z.left !== F.left || z.right !== F.right || z.top !== F.top || z.bottom !== F.bottom) {
        const K = l()(this.element, {
          from: z,
          to: F
        }, _ == null ? void 0 : _());
        C = Ed(this.element, K, void 0, 1, () => {
          C == null || C.abort(), C = void 0
        })
      }
    },
    fix() {
      if (!y.getAnimations().length) {
        var {
          position: K,
          width: G,
          height: ie
        } = getComputedStyle(y);
        if (K !== "absolute" && K !== "fixed") {
          var de = y.style;
          o = {
            position: de.position,
            width: de.width,
            height: de.height,
            transform: de.transform
          }, de.position = "absolute", de.width = G, de.height = ie;
          var fe = y.getBoundingClientRect();
          if (z.left !== fe.left || z.top !== fe.top) {
            var W = `translate(${z.left-fe.left}px, ${z.top-fe.top}px)`;
            de.transform = de.transform ? `${de.transform} ${W}` : W
          }
        }
      }
    },
    unfix() {
      if (o) {
        var K = y.style;
        K.position = o.position, K.width = o.width, K.height = o.height, K.transform = o.transform
      }
    }
  }), T.a.element = y
}

function An(y, l, _, T) {
  var z = (y & ix) !== 0,
    F = (y & nx) !== 0,
    C = z && F,
    o = (y & Ky) !== 0,
    K = C ? "both" : z ? "in" : "out",
    G, ie = l.inert,
    de = l.style.overflow,
    fe, W;

  function le() {
    return Xf(() => G ?? (G = _()(l, (T == null ? void 0 : T()) ?? {}, {
      direction: K
    })))
  }
  var Ce = {
      is_global: o,
      in() {
        var Oe;
        if (l.inert = ie, !z) {
          W == null || W.abort(), (Oe = W == null ? void 0 : W.reset) == null || Oe.call(W);
          return
        }
        F || fe == null || fe.abort(), xd(l, "introstart"), fe = Ed(l, le(), W, 1, () => {
          xd(l, "introend"), fe == null || fe.abort(), fe = G = void 0, l.style.overflow = de
        })
      },
      out(Oe) {
        if (!F) {
          Oe == null || Oe(), G = void 0;
          return
        }
        l.inert = !0, xd(l, "outrostart"), W = Ed(l, le(), fe, 0, () => {
          xd(l, "outroend"), Oe == null || Oe()
        })
      },
      stop: () => {
        fe == null || fe.abort(), W == null || W.abort()
      }
    },
    Me = Xy;
  if ((Me.transitions ?? (Me.transitions = [])).push(Ce), z && hx) {
    var Le = o;
    if (!Le) {
      for (var $e = Me.parent; $e && ($e.f & Qy) !== 0;)
        for (;
          ($e = $e.parent) && ($e.f & ex) === 0;);
      Le = !$e || ($e.f & tx) !== 0
    }
    Le && rx(() => {
      so(() => Ce.in())
    })
  }
}

function Ed(y, l, _, T, z) {
  var F = T === 1;
  if (Yy(l)) {
    var C, o = !1;
    return Jy(() => {
      if (!o) {
        var Me = l({
          direction: F ? "in" : "out"
        });
        C = Ed(y, Me, _, T, z)
      }
    }), {
      abort: () => {
        o = !0, C == null || C.abort()
      },
      deactivate: () => C.deactivate(),
      reset: () => C.reset(),
      t: () => C.t()
    }
  }
  if (_ == null || _.deactivate(), !(l != null && l.duration)) return z(), {
    abort: kn,
    deactivate: kn,
    reset: kn,
    t: () => T
  };
  const {
    delay: K = 0,
    css: G,
    tick: ie,
    easing: de = Zx
  } = l;
  var fe = [];
  if (F && _ === void 0 && (ie && ie(0, 1), G)) {
    var W = wg(G(0, 1));
    fe.push(W, W)
  }
  var le = () => 1 - T,
    Ce = y.animate(fe, {
      duration: K,
      fill: "forwards"
    });
  return Ce.onfinish = () => {
    Ce.cancel();
    var Me = (_ == null ? void 0 : _.t()) ?? 1 - T;
    _ == null || _.abort();
    var Le = T - Me,
      $e = l.duration * Math.abs(Le),
      Oe = [];
    if ($e > 0) {
      var Ve = !1;
      if (G)
        for (var ct = Math.ceil($e / 16.666666666666668), nt = 0; nt <= ct; nt += 1) {
          var Ye = Me + Le * de(nt / ct),
            dt = wg(G(Ye, 1 - Ye));
          Oe.push(dt), Ve || (Ve = dt.overflow === "hidden")
        }
      Ve && (y.style.overflow = "hidden"), le = () => {
        var rt = Ce.currentTime;
        return Me + Le * de(rt / $e)
      }, ie && qx(() => {
        if (Ce.playState !== "running") return !1;
        var rt = le();
        return ie(rt, 1 - rt), !0
      })
    }
    Ce = y.animate(Oe, {
      duration: $e,
      fill: "forwards"
    }), Ce.onfinish = () => {
      le = () => T, ie == null || ie(T, 1 - T), z()
    }
  }, {
    abort: () => {
      Ce && (Ce.cancel(), Ce.effect = null, Ce.onfinish = kn)
    },
    deactivate: () => {
      z = kn
    },
    reset: () => {
      T === 0 && (ie == null || ie(1, 0))
    },
    t: () => le()
  }
}

function Vd(y, l) {
  ax(window, ["resize"], () => Xf(() => l(window[y])))
}
const $x = () => "Log in",
  Ux = () => "Entrar",
  Gx = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? $x() : Ux(),
  Hx = () => "Store",
  Wx = () => "Loja",
  rv = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? Hx() : Wx(),
  Xx = () => "Alliance",
  Kx = () => "Aliança",
  Zd = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? Xx() : Kx(),
  Yx = () => "Leaderboard",
  Jx = () => "Ranking",
  tm = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? Yx() : Jx(),
  Qx = () => "Unlock",
  e1 = () => "Destravar",
  t1 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? Qx() : e1(),
  r1 = () => "Lock",
  i1 = () => "Travar",
  n1 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? r1() : i1(),
  a1 = () => "Info",
  s1 = () => "Informações",
  o1 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? a1() : s1(),
  l1 = () => "Zoom in",
  c1 = () => "Aumentar zoom",
  u1 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? l1() : c1(),
  h1 = () => "Zoom out",
  d1 = () => "Diminuir zoom",
  p1 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? h1() : d1(),
  f1 = () => "Previous location",
  m1 = () => "Localização anterior",
  _1 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? f1() : m1(),
  g1 = () => "Offline",
  v1 = () => "Offline",
  y1 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? g1() : v1(),
  x1 = () => "Zoom in to see the pixels",
  b1 = () => "Amplie para ver os pixels",
  w1 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? x1() : b1(),
  T1 = () => "Phone verification required",
  C1 = () => "Verificação de telefone necessária",
  Tg = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? T1() : C1(),
  S1 = () => "My location",
  P1 = () => "Minha localização",
  I1 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? S1() : P1(),
  M1 = () => "You don't have charges to paint. Wait to recharge.",
  A1 = () => "Você não possui tinta para pintar. Aguarde para carrega-las.",
  k1 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? M1() : A1(),
  E1 = () => "Map powered by:",
  z1 = () => "Mapa fornecido por:",
  L1 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? E1() : z1(),
  D1 = () => "OpenMapTiles Data from",
  R1 = () => "OpenMapTiles com dados do",
  B1 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? D1() : R1(),
  F1 = () => "Feedback and bugs",
  O1 = () => "Feedback e bugs",
  N1 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? F1() : O1(),
  j1 = () => "Overview",
  q1 = () => "Visão Geral",
  V1 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? j1() : q1(),
  Z1 = () => "How to paint faster",
  $1 = () => "Como pintar mais rápido",
  U1 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? Z1() : $1(),
  G1 = () => "When painting, click on the button",
  H1 = () => "Quando pintar clique no botão",
  W1 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? G1() : H1(),
  X1 = () => "on the top right corner of the screen. This will lock the screen but it'll also enable painting by moving your finger over the map.",
  K1 = () => "no canto superior direito da tela. Isso bloqueará a tela, mas também permitirá pintar movendo o dedo sobre o mapa.",
  Y1 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? X1() : K1(),
  J1 = () => "Hold",
  Q1 = () => "Segure",
  eb = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? J1() : Q1(),
  tb = () => "SPACE",
  rb = () => "Espaço",
  ib = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? tb() : rb(),
  nb = () => "and move your cursor over the map.",
  ab = () => "e mova seu cursor sobre o mapa.",
  sb = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? nb() : ab(),
  ob = () => "Explore",
  lb = () => "Explorar",
  cb = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? ob() : lb(),
  ub = () => "Recharge paint charges",
  hb = () => "Recarga de tinta",
  db = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? ub() : hb(),
  pb = () => "Items",
  fb = () => "Itens",
  mb = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? pb() : fb(),
  _b = () => "Get more charges",
  gb = () => "Recarregue tinta para pintar",
  vb = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? _b() : gb(),
  yb = y => `+${y.amount} Max. Charges`,
  xb = y => `+${y.amount} Tinta máxima`,
  bb = (y, l = {}) => (l.locale ?? Ue()) === "en" ? yb(y) : xb(y),
  wb = () => "Increase your maximum paint charges capacity",
  Tb = () => "Aumente sua capacidade máxima de tinta",
  Cb = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? wb() : Tb(),
  Sb = () => "Profile picture",
  Pb = () => "Imagem de perfil",
  Ib = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? Sb() : Pb(),
  Mb = () => "Add a new 16x16 profile picture",
  Ab = () => "Adicionar uma nova imagem de perfil 16x16",
  kb = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? Mb() : Ab(),
  Eb = () => "Not enough droplets",
  zb = () => "Droplets insuficientes",
  $d = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? Eb() : zb(),
  Lb = () => "Show profile",
  Db = () => "Exibir perfil",
  Rb = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? Lb() : Db(),
  Bb = () => "Pixels painted",
  Fb = () => "Pixels pintados",
  rm = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? Bb() : Fb(),
  Ob = () => "Menu",
  Nb = () => "Menu",
  jb = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? Ob() : Nb(),
  qb = y => `Could not install the app: ${y.error}`,
  Vb = y => `Não pode instalar o app: ${y.error}`,
  Zb = (y, l = {}) => (l.locale ?? Ue()) === "en" ? qb(y) : Vb(y),
  $b = () => "Install App",
  Ub = () => "Instalar App",
  Gb = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? $b() : Ub(),
  Hb = () => "Livestreams",
  Wb = () => "Livestreams",
  Xb = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? Hb() : Wb(),
  Kb = () => "Log Out",
  Yb = () => "Log Out",
  Jb = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? Kb() : Yb(),
  Qb = () => "Hide UI",
  e2 = () => "Esconder UI",
  t2 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? Qb() : e2(),
  r2 = () => "Change picture:",
  i2 = () => "Change picture:",
  n2 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? r2() : i2(),
  a2 = () => "Show last painted pixel on alliance",
  s2 = () => "Mostrar último pixel pintado na aliança",
  o2 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? a2() : s2(),
  l2 = () => "Delete Account",
  c2 = () => "Deletar Conta",
  Cg = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? l2() : c2(),
  u2 = () => "Save",
  h2 = () => "Salvar",
  d2 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? u2() : h2(),
  p2 = () => "Are you absolutely sure?",
  f2 = () => "Você tem certeza absoluta?",
  m2 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? p2() : f2(),
  _2 = () => "This will permanently delete your account and all associated data. This action cannot be undone.",
  g2 = () => "Isso excluirá permanentemente sua conta e todos os dados associados. Esta ação não pode ser desfeita.",
  v2 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? _2() : g2(),
  y2 = () => "Profile",
  x2 = () => "Perfil",
  b2 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? y2() : x2(),
  w2 = () => "Display your country’s flag next to your username. Plus, when painting in regions where you own the corresponding flag, you recover 10% of the charges spent.",
  T2 = () => "Exiba a bandeira do seu país ao lado do seu nome de usuário. Além disso, ao pintar em regiões onde você possui a bandeira correspondente, você recupera 10% das tintas gastas.",
  C2 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? w2() : T2(),
  S2 = () => "Does not need to be equiped to provide the bonus",
  P2 = () => "Não precisa estar equipada para obter o bònus",
  I2 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? S2() : P2(),
  M2 = () => "Equipped",
  A2 = () => "Equipado",
  k2 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? M2() : A2(),
  E2 = () => "Equip",
  z2 = () => "Equipar",
  L2 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? E2() : z2(),
  D2 = () => "Country",
  R2 = () => "País",
  iv = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? D2() : R2(),
  B2 = () => "No country found.",
  F2 = () => "País não encontrado.",
  O2 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? B2() : F2(),
  N2 = () => "Welcome to",
  j2 = () => "Bem vindo ao",
  q2 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? N2() : j2(),
  V2 = () => "Rules",
  Z2 = () => "Regras",
  $2 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? V2() : Z2(),
  U2 = () => "Important",
  G2 = () => "Importante",
  H2 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? U2() : G2(),
  W2 = () => "🚫 No inappropriate content (+18, hate speech, innapropriate links, highly suggestive material, ...)",
  X2 = () => "🚫 Conteúdo inapropriado não permitido (+18, discurso de ódio, links inapropriados, conteúdo altamente sugestivo, ...)",
  K2 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? W2() : X2(),
  Y2 = () => "😈 Do not paint over other artworks using random colors or patterns just to mess things up",
  J2 = () => "😈 Não desenhe por cima de outras artes usando cores ou padrões aleatórios só para bagunçar",
  Q2 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? Y2() : J2(),
  ew = () => "🧑‍🤝‍🧑 Do not paint with more than one account",
  tw = () => "🧑‍🤝‍🧑 Não desenhe com mais de uma conta",
  rw = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? ew() : tw(),
  iw = () => "🤖 Use of bots is not allowed",
  nw = () => "🤖 Usar bots não é permitido",
  aw = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? iw() : nw(),
  sw = () => "🙅 Disclosing other's personal information is not allowed",
  ow = () => "🙅 Divulgar informações pessoais dos outros não é permitido",
  lw = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? sw() : ow(),
  cw = () => "✅ Painting over other artworks to complement them or create a new drawing is allowed",
  uw = () => "✅ Desenhar sobre outras artes para complementar ou criar novas artes é permitido",
  hw = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? cw() : uw(),
  dw = () => "✅ Griefing political party flags or portraits of politicians is allowed",
  pw = () => "✅ Desenhar sobre bandeiras de partidos e retratos de políticos é permitido",
  fw = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? dw() : pw(),
  mw = () => "Violations of these rules may result in suspension of your account.",
  _w = () => "Violações destas regras podem resultar na suspensão da sua conta.",
  gw = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? mw() : _w(),
  vw = () => "Understood",
  yw = () => "Entendido",
  xw = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? vw() : yw(),
  bw = () => "Toggle art opacity",
  ww = () => "Alterar opacidade",
  nv = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? bw() : ww(),
  Tw = () => "Paint",
  Cw = () => "Pintar",
  av = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? Tw() : Cw(),
  Sw = () => "Select a color",
  Pw = () => "Selecione uma color",
  Iw = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? Sw() : Pw(),
  Mw = () => "Select a pixel to erase",
  Aw = () => "Selecione um pixel para apagar",
  kw = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? Mw() : Aw(),
  Ew = () => "Pick a color from the map",
  zw = () => "Escolha uma cor do mapa",
  Lw = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? Ew() : zw(),
  Dw = () => "Click",
  Rw = () => "Clique",
  Bw = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? Dw() : Rw(),
  Fw = () => "SPACE",
  Ow = () => "ESPAÇO",
  Nw = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? Fw() : Ow(),
  jw = () => "or hold",
  qw = () => "ou segure",
  Vw = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? jw() : qw(),
  Zw = () => "to paint,",
  $w = () => "para pintar",
  Uw = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? Zw() : $w(),
  Gw = () => "You can paint more than 1 pixel",
  Hw = () => "Você pode pintar mais de 1 pixel",
  Ww = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? Gw() : Hw(),
  Xw = () => "Paint pixel",
  Kw = () => "Pintar pixel",
  Yw = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? Xw() : Kw(),
  Jw = () => "Color Picker",
  Qw = () => "Conta Gotas",
  e5 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? Jw() : Qw(),
  t5 = () => "+2 max. charge/level",
  r5 = () => "+2 tinta máxima/level",
  i5 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? t5() : r5(),
  n5 = () => "Name",
  a5 = () => "Nome",
  wf = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? n5() : a5(),
  s5 = () => "Discord Username",
  o5 = () => "Usuário do Discord",
  l5 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? s5() : o5(),
  c5 = () => "Max. Charges",
  u5 = () => "Tinta máxima",
  Sg = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? c5() : u5(),
  h5 = () => "Paint Charges",
  d5 = () => "Tintas",
  p5 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? h5() : d5(),
  f5 = y => `+${y.amount} Paint Charges`,
  m5 = y => `+${y.amount} Tintas`,
  _5 = (y, l = {}) => (l.locale ?? Ue()) === "en" ? f5(y) : m5(y),
  g5 = () => "Leave alliance",
  v5 = () => "Sair da aliança",
  y5 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? g5() : v5(),
  x5 = () => "Members",
  b5 = () => "Membros",
  sv = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? x5() : b5(),
  w5 = () => "Headquarters",
  T5 = () => "Quartel General",
  C5 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? w5() : T5(),
  S5 = () => "Not set",
  P5 = () => "Não configurado",
  I5 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? S5() : P5(),
  M5 = () => "You are not in an alliance",
  A5 = () => "Você não está em uma aliança",
  k5 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? M5() : A5(),
  E5 = () => "Get invited to an alliance",
  z5 = () => "Seja convidado para uma aliança",
  L5 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? E5() : z5(),
  D5 = () => "OR",
  R5 = () => "OU",
  B5 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? D5() : R5(),
  F5 = () => "Create an alliance",
  O5 = () => "Crie uma aliança",
  N5 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? F5() : O5(),
  j5 = () => "Invite link",
  q5 = () => "Link de convite",
  V5 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? j5() : q5(),
  Z5 = () => "Send the link bellow to everybody you want to invite to the alliance",
  $5 = () => "Envie o link abaixo para quem você deseja convidar para a aliança",
  U5 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? Z5() : $5(),
  G5 = () => "Copied",
  H5 = () => "Copiado",
  ov = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? G5() : H5(),
  W5 = () => "Copy",
  X5 = () => "Copiar",
  Tf = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? W5() : X5(),
  K5 = () => "No description",
  Y5 = () => "Sem descrição",
  lv = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? K5() : Y5(),
  J5 = () => "Invite",
  Q5 = () => "Convite",
  eT = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? J5() : Q5(),
  tT = () => "No pixels painted",
  rT = () => "Nenhum pixel pintado",
  im = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? tT() : rT(),
  iT = () => "Today",
  nT = () => "Hoje",
  Ud = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? iT() : nT(),
  aT = () => "Week",
  sT = () => "Semana",
  oT = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? aT() : sT(),
  lT = () => "Month",
  cT = () => "Mês",
  uT = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? lT() : cT(),
  hT = () => "All time",
  dT = () => "Geral",
  pT = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? hT() : dT(),
  fT = () => "this week",
  mT = () => "nesta semana",
  nm = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? fT() : mT(),
  _T = () => "this month",
  gT = () => "neste mês",
  am = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? _T() : gT(),
  vT = () => "Player",
  yT = () => "Jogador",
  sm = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? vT() : yT(),
  xT = () => "Last pixel",
  bT = () => "Último pixel",
  wT = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? xT() : bT(),
  TT = () => "Create alliance",
  CT = () => "Criar aliança",
  ST = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? TT() : CT(),
  PT = () => "Alliance Name",
  IT = () => "Nome da aliança",
  MT = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? PT() : IT(),
  AT = () => "Create",
  kT = () => "Criar",
  ET = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? AT() : kT(),
  zT = () => "Give admin",
  LT = () => "Tornar admin",
  DT = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? zT() : LT(),
  RT = () => "Ban from alliance",
  BT = () => "Banir da aliança",
  cv = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? RT() : BT(),
  FT = () => "No action",
  OT = () => "Sem opção",
  NT = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? FT() : OT(),
  jT = () => "Unban",
  qT = () => "Desbanir",
  VT = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? jT() : qT(),
  ZT = () => "No banned users",
  $T = () => "Sem usuários banidos",
  UT = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? ZT() : $T(),
  GT = () => "Description",
  HT = () => "Descrição",
  WT = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? GT() : HT(),
  XT = () => "Update",
  KT = () => "Atualizar",
  YT = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? XT() : KT(),
  JT = () => "Error giving admin to user",
  QT = () => "Erro ao tornar usuário admin",
  e3 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? JT() : QT(),
  t3 = () => "Users",
  r3 = () => "Usuários",
  i3 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? t3() : r3(),
  n3 = () => "Banned",
  a3 = () => "Banido",
  s3 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? n3() : a3(),
  o3 = () => "Regions",
  l3 = () => "Regiões",
  c3 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? o3() : l3(),
  u3 = () => "Countries",
  h3 = () => "Países",
  d3 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? u3() : h3(),
  p3 = () => "Players",
  f3 = () => "Jogadores",
  uv = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? p3() : f3(),
  m3 = () => "Alliances",
  _3 = () => "Alianças",
  hv = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? m3() : _3(),
  g3 = () => "Region",
  v3 = () => "Região",
  y3 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? g3() : v3(),
  x3 = () => "Pixels",
  b3 = () => "Pixels",
  Jl = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? x3() : b3(),
  w3 = () => "Painted",
  T3 = () => "Pintados",
  Ql = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? w3() : T3(),
  C3 = () => "Pixels painted inside the region",
  S3 = () => "Pixels pintados dentro da região",
  P3 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? C3() : S3(),
  I3 = () => "Visit",
  M3 = () => "Visitar",
  A3 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? I3() : M3(),
  k3 = () => "Not painted",
  E3 = () => "Não pintado",
  z3 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? k3() : E3(),
  L3 = () => "Painted by",
  D3 = () => "Pintado por",
  R3 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? L3() : D3(),
  B3 = () => "Limit reached",
  F3 = () => "Limite atingido",
  O3 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? B3() : F3(),
  N3 = () => "Favorite",
  j3 = () => "Favoritar",
  q3 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? N3() : j3(),
  V3 = () => "Share",
  Z3 = () => "Compartilhar",
  $3 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? V3() : Z3(),
  U3 = () => "Share place",
  G3 = () => "Compartilhar local",
  H3 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? U3() : G3(),
  W3 = () => "Mute",
  X3 = () => "Mutar",
  K3 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? W3() : X3(),
  Y3 = () => "Unmute",
  J3 = () => "Desmutar",
  Q3 = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? Y3() : J3(),
  eC = () => "Select the headquarters location",
  tC = () => "Selecione a localização do quartel general",
  rC = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? eC() : tC(),
  iC = () => "Pixels painted inside the country",
  nC = () => "Pixels pintados dentro do país",
  aC = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? iC() : nC(),
  sC = () => "Username copied to clipboard",
  oC = () => "Usuário copiado",
  lC = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? sC() : oC(),
  cC = () => "No more charges",
  uC = () => "Acabou a tinta",
  hC = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? cC() : uC(),
  dC = () => "You are not allowed to use multiple accounts",
  pC = () => "Não é permitido usar várias contas",
  fC = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? dC() : pC(),
  mC = () => "SMS sent to",
  _C = () => "SMS enviado para",
  gC = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? mC() : _C(),
  vC = () => "Phone successfully verified",
  yC = () => "Telefone verificado com sucesso",
  xC = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? vC() : yC(),
  bC = () => "Not a valid phone number",
  wC = () => "Não é um número válido",
  TC = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? bC() : wC(),
  CC = () => "Location unfavorited",
  SC = () => "Localização desfavoritada",
  PC = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? CC() : SC(),
  IC = () => "Location favorited",
  MC = () => "Localização favoritada",
  AC = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? IC() : MC(),
  kC = () => "Giving admin to user",
  EC = () => "Tornar usuário um admin",
  zC = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? kC() : EC(),
  LC = () => "Profile updated",
  DC = () => "Perfil atualizado",
  RC = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? LC() : DC(),
  BC = () => "Account successfully deleted",
  FC = () => "Conta deletada com sucesso",
  OC = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? BC() : FC(),
  NC = () => "Logged out",
  jC = () => "Logout feito",
  qC = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? NC() : jC(),
  VC = () => "Could not logout. Try refreshing the page.",
  ZC = () => "Não foi possível sair da conta. Tente recarregar a página.",
  $C = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? VC() : ZC(),
  UC = () => "You need zoom in to select a pixel",
  GC = () => "Dê zoom para selecionar um pixel",
  HC = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? UC() : GC(),
  WC = () => "Phone verification",
  XC = () => "Verificação de telefone",
  KC = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? WC() : XC(),
  YC = () => "Please verify your phone number to continue playing. This helps us keep bots out and ensure a safe, creative experience for everyone.",
  JC = () => "Por favor, verifique com seu telefone para continuar jogando. Isso nos ajuda a filtrar bots e manter um experiência segura e criativa para todos.",
  QC = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? YC() : JC(),
  eS = () => "Send Code",
  tS = () => "Enviar o código",
  rS = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? eS() : tS(),
  iS = () => "Input the code",
  nS = () => "Insira o código",
  aS = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? iS() : nS(),
  sS = () => "Sent to",
  oS = () => "Enviar para",
  lS = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? sS() : oS(),
  cS = () => "Resend Code",
  uS = () => "Reenviar Código",
  hS = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? cS() : uS(),
  dS = () => "Try another number",
  pS = () => "Tentar outro número",
  fS = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? dS() : pS(),
  mS = () => "Edit profile",
  _S = () => "Editar perfil",
  gS = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? mS() : _S(),
  vS = () => "Image",
  yS = () => "Imagem",
  xS = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? vS() : yS(),
  bS = () => "Download",
  wS = () => "Download",
  TS = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? bS() : wS(),
  CS = () => "Image copied to clipboard",
  SS = () => "Imagem copiada para a área de transferência",
  PS = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? CS() : SS(),
  IS = () => "My map is lagging",
  MS = () => "Meu mapa está travando",
  AS = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? IS() : MS(),
  kS = () => "Verify if",
  ES = () => "Verifique se",
  zS = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? kS() : ES(),
  LS = () => "Use graphics acceleration when available",
  DS = () => "Usar aceleração gráfica quando disponível",
  RS = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? LS() : DS(),
  BS = () => "is enabled on",
  FS = () => "está habilitado em",
  OS = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? BS() : FS(),
  NS = () => "Follow the instructions to enable hardware acceleration",
  jS = () => "Siga a instrução para habilitar a aceleração de hardware",
  qS = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? NS() : jS(),
  VS = () => "Terms",
  ZS = () => "Termos",
  $S = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? VS() : ZS(),
  US = () => "Privacy",
  GS = () => "Privacidade",
  HS = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? US() : GS(),
  WS = () => "Clear area",
  XS = () => "Limpar área",
  KS = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? WS() : XS(),
  YS = () => "Select the area's first corner",
  JS = () => "Selecione o primeiro canto da área",
  QS = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? YS() : JS(),
  eP = () => "Select the area's opposite corner",
  tP = () => "Selecione o canto oposto da área",
  rP = (y = {}, l = {}) => (l.locale ?? Ue()) === "en" ? eP() : tP(),
  xs = 2 * Math.PI * 6378137 / 2;
class uc {
  constructor(l = 256) {
    fr(this, "initialResolution");
    this.tileSize = l, this.initialResolution = 2 * xs / this.tileSize
  }
  latLonToMeters(l, _) {
    const T = _ / 180 * xs,
      z = Math.log(Math.tan((90 + l) * Math.PI / 360)) / (Math.PI / 180) * xs / 180;
    return [T, z]
  }
  metersToLatLon(l, _) {
    const T = l / xs * 180;
    let z = _ / xs * 180;
    return z = 180 / Math.PI * (2 * Math.atan(Math.exp(z * Math.PI / 180)) - Math.PI / 2), [z, T]
  }
  pixelsToMeters(l, _, T) {
    const z = this.resolution(T),
      F = l * z - xs,
      C = xs - _ * z;
    return [F, C]
  }
  pixelsToLatLon(l, _, T) {
    const [z, F] = this.pixelsToMeters(l, _, T);
    return this.metersToLatLon(z, F)
  }
  latLonToPixels(l, _, T) {
    const [z, F] = this.latLonToMeters(l, _);
    return this.metersToPixels(z, F, T)
  }
  latLonToPixelsFloor(l, _, T) {
    const [z, F] = this.latLonToPixels(l, _, T);
    return [Math.floor(z), Math.floor(F)]
  }
  metersToPixels(l, _, T) {
    const z = this.resolution(T),
      F = (l + xs) / z,
      C = (xs - _) / z;
    return [F, C]
  }
  latLonToTile(l, _, T) {
    const [z, F] = this.latLonToMeters(l, _);
    return this.metersToTile(z, F, T)
  }
  metersToTile(l, _, T) {
    const [z, F] = this.metersToPixels(l, _, T);
    return this.pixelsToTile(z, F)
  }
  pixelsToTile(l, _) {
    const T = Math.ceil(l / this.tileSize) - 1,
      z = Math.ceil(_ / this.tileSize) - 1;
    return [T, z]
  }
  pixelsToTileLocal(l, _) {
    return {
      tile: this.pixelsToTile(l, _),
      pixel: [Math.floor(l) % this.tileSize, Math.floor(_) % this.tileSize]
    }
  }
  tileBounds(l, _, T) {
    const [z, F] = this.pixelsToMeters(l * this.tileSize, _ * this.tileSize, T), [C, o] = this.pixelsToMeters((l + 1) * this.tileSize, (_ + 1) * this.tileSize, T);
    return {
      min: [z, F],
      max: [C, o]
    }
  }
  tileBoundsLatLon(l, _, T) {
    const z = this.tileBounds(l, _, T);
    return {
      min: this.metersToLatLon(z.min[0], z.min[1]),
      max: this.metersToLatLon(z.max[0], z.max[1])
    }
  }
  resolution(l) {
    return this.initialResolution / 2 ** l
  }
  latLonToTileAndPixel(l, _, T) {
    const [z, F] = this.latLonToMeters(l, _), [C, o] = this.metersToTile(z, F, T), [K, G] = this.metersToPixels(z, F, T);
    return {
      tile: [C, o],
      pixel: [Math.floor(K) % this.tileSize, Math.floor(G) % this.tileSize]
    }
  }
  pixelBounds(l, _, T) {
    return {
      min: this.pixelsToMeters(l, _, T),
      max: this.pixelsToMeters(l + 1, _ + 1, T)
    }
  }
  pixelToBoundsLatLon(l, _, T) {
    const z = this.pixelBounds(l, _, T),
      F = .001885,
      C = (z.max[0] - z.min[0]) * F,
      o = (z.max[1] - z.min[1]) * F;
    return z.min[0] -= C, z.max[0] -= C, z.min[1] -= o, z.max[1] -= o, {
      min: this.metersToLatLon(z.min[0], z.min[1]),
      max: this.metersToLatLon(z.max[0], z.max[1])
    }
  }
  latLonToTileBoundsLatLon(l, _, T) {
    const [z, F] = this.latLonToMeters(l, _), [C, o] = this.metersToTile(z, F, T);
    return this.tileBoundsLatLon(C, o, T)
  }
  latLonToPixelBoundsLatLon(l, _, T) {
    const [z, F] = this.latLonToMeters(l, _), [C, o] = this.metersToPixels(z, F, T);
    return this.pixelToBoundsLatLon(Math.floor(C), Math.floor(o), T)
  }
  latLonToRegionAndPixel(l, _, T, z = jn.regionSize) {
    const [F, C] = this.latLonToPixelsFloor(l, _, T), o = this.tileSize * z;
    return {
      region: [Math.floor(F / o), Math.floor(C / o)],
      pixel: [F % o, C % o]
    }
  }
}

function om(y, l = !0) {
  const {
    min: _,
    max: T
  } = y;
  return l ? [
    [_[1], T[0]],
    [T[1], T[0]],
    [T[1], _[0]],
    [_[1], _[0]]
  ] : [
    [_[0], T[1]],
    [T[0], T[1]],
    [T[0], _[1]],
    [_[0], _[1]]
  ]
}

function lm(y) {
  return [(y.min[0] + y.max[0]) / 2, (y.min[1] + y.max[1]) / 2]
}
const iP = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAAAAACoWZBhAAAAAXNSR0IArs4c6QAAACpJREFUeNpj+AsEZ86ASIa/DAwMZ84ACRDzDBigMs/AARITq1oUwxBWAADaREUdDMswKwAAAABJRU5ErkJggg==",
  Pg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAACVJREFUeNpj+A8FDEAAZwMRBAIBmIYLIgHcgkQDIs3E6SRsjgcABYFLtfTgakEAAAAASUVORK5CYII=";

function nP(y) {
  return Math.floor(Math.random() * y)
}
const Cf = 14.5;
async function aP() {
  const y = lP();
  if (y) return y;
  try {
    if ((await navigator.permissions.query({
        name: "geolocation"
      })).state === "granted") {
      const _ = await new Promise((T, z) => navigator.geolocation.getCurrentPosition(F => T(F), F => z(F)));
      return {
        lat: _.coords.latitude,
        lng: _.coords.longitude,
        zoom: Cf
      }
    }
  } catch (l) {
    console.error(l)
  }
  return {
    ...sP().pos,
    zoom: Cf
  }
}

function sP() {
  const y = Object.entries(oP),
    l = nP(y.length),
    [_, T] = y[l];
  return {
    city: _,
    pos: T
  }
}
const oP = {
    tokyo: {
      lat: 35.677545560719665,
      lng: 139.76394445809638
    },
    paris: {
      lat: 48.8537151734952,
      lng: 2.3484026030630787
    },
    newYork: {
      lat: 40.71283173786517,
      lng: -74.00599771376795
    },
    saoPaulo: {
      lat: -23.550584064565356,
      lng: -46.63339720713918
    },
    sydney: {
      lat: -33.86943325619071,
      lng: 151.2083447239608
    }
  },
  dv = "location";

function qa(y, l) {
  localStorage.setItem(dv, JSON.stringify({
    ...y,
    zoom: l
  }))
}

function lP() {
  const y = localStorage.getItem(dv);
  if (!y) return;
  const l = JSON.parse(y);
  return l.zoom ?? (l.zoom = Cf), l
}
var Eu, zu;
class cP {
  constructor() {
    Pr(this, Eu, _t(-1));
    Pr(this, zu, _t([]))
  }
  get idx() {
    return b(st(this, Eu))
  }
  set idx(l) {
    he(st(this, Eu), l, !0)
  }
  get entries() {
    return b(st(this, zu))
  }
  set entries(l) {
    he(st(this, zu), l)
  }
  hasNext() {
    return this.idx < this.entries.length - 1
  }
  goToNext(l) {
    const _ = this.idx + 1,
      T = this.entries[_];
    T && (this.idx = _, l.flyTo({
      center: T.pos,
      zoom: T.zoom
    }))
  }
  hasPrev() {
    return this.idx > 0
  }
  goToPrev(l) {
    const _ = this.idx - 1,
      T = this.entries[_];
    T && (this.idx = _, l.flyTo({
      center: T.pos,
      zoom: T.zoom
    }))
  }
  isEmpty() {
    return this.entries.length === 0
  }
  push(l) {
    this.idx = this.idx + 1, this.entries = [...this.entries.slice(0, this.idx), l]
  }
}
Eu = new WeakMap, zu = new WeakMap;
const Qo = new cP;

function cm(y) {
  return y && y.__esModule && Object.prototype.hasOwnProperty.call(y, "default") ? y.default : y
}
var Sd = {
  exports: {}
};
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.6.1/LICENSE.txt
 */
var uP = Sd.exports,
  Ig;

function hP() {
  return Ig || (Ig = 1, (function(y, l) {
    (function(_, T) {
      y.exports = T()
    })(uP, (function() {
      var _ = {},
        T = {};

      function z(C, o, K) {
        if (T[C] = K, C === "index") {
          var G = "var sharedModule = {}; (" + T.shared + ")(sharedModule); (" + T.worker + ")(sharedModule);",
            ie = {};
          return T.shared(ie), T.index(_, ie), typeof window < "u" && _.setWorkerUrl(window.URL.createObjectURL(new Blob([G], {
            type: "text/javascript"
          }))), _
        }
      }
      z("shared", ["exports"], (function(C) {
        function o(n, t, i, a) {
          return new(i || (i = Promise))((function(u, p) {
            function f(S) {
              try {
                x(a.next(S))
              } catch (I) {
                p(I)
              }
            }

            function g(S) {
              try {
                x(a.throw(S))
              } catch (I) {
                p(I)
              }
            }

            function x(S) {
              var I;
              S.done ? u(S.value) : (I = S.value, I instanceof i ? I : new i((function(k) {
                k(I)
              }))).then(f, g)
            }
            x((a = a.apply(n, t || [])).next())
          }))
        }

        function K(n) {
          return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
        }
        var G, ie;

        function de() {
          if (ie) return G;

          function n(t, i) {
            this.x = t, this.y = i
          }
          return ie = 1, G = n, n.prototype = {
            clone: function() {
              return new n(this.x, this.y)
            },
            add: function(t) {
              return this.clone()._add(t)
            },
            sub: function(t) {
              return this.clone()._sub(t)
            },
            multByPoint: function(t) {
              return this.clone()._multByPoint(t)
            },
            divByPoint: function(t) {
              return this.clone()._divByPoint(t)
            },
            mult: function(t) {
              return this.clone()._mult(t)
            },
            div: function(t) {
              return this.clone()._div(t)
            },
            rotate: function(t) {
              return this.clone()._rotate(t)
            },
            rotateAround: function(t, i) {
              return this.clone()._rotateAround(t, i)
            },
            matMult: function(t) {
              return this.clone()._matMult(t)
            },
            unit: function() {
              return this.clone()._unit()
            },
            perp: function() {
              return this.clone()._perp()
            },
            round: function() {
              return this.clone()._round()
            },
            mag: function() {
              return Math.sqrt(this.x * this.x + this.y * this.y)
            },
            equals: function(t) {
              return this.x === t.x && this.y === t.y
            },
            dist: function(t) {
              return Math.sqrt(this.distSqr(t))
            },
            distSqr: function(t) {
              var i = t.x - this.x,
                a = t.y - this.y;
              return i * i + a * a
            },
            angle: function() {
              return Math.atan2(this.y, this.x)
            },
            angleTo: function(t) {
              return Math.atan2(this.y - t.y, this.x - t.x)
            },
            angleWith: function(t) {
              return this.angleWithSep(t.x, t.y)
            },
            angleWithSep: function(t, i) {
              return Math.atan2(this.x * i - this.y * t, this.x * t + this.y * i)
            },
            _matMult: function(t) {
              var i = t[2] * this.x + t[3] * this.y;
              return this.x = t[0] * this.x + t[1] * this.y, this.y = i, this
            },
            _add: function(t) {
              return this.x += t.x, this.y += t.y, this
            },
            _sub: function(t) {
              return this.x -= t.x, this.y -= t.y, this
            },
            _mult: function(t) {
              return this.x *= t, this.y *= t, this
            },
            _div: function(t) {
              return this.x /= t, this.y /= t, this
            },
            _multByPoint: function(t) {
              return this.x *= t.x, this.y *= t.y, this
            },
            _divByPoint: function(t) {
              return this.x /= t.x, this.y /= t.y, this
            },
            _unit: function() {
              return this._div(this.mag()), this
            },
            _perp: function() {
              var t = this.y;
              return this.y = this.x, this.x = -t, this
            },
            _rotate: function(t) {
              var i = Math.cos(t),
                a = Math.sin(t),
                u = a * this.x + i * this.y;
              return this.x = i * this.x - a * this.y, this.y = u, this
            },
            _rotateAround: function(t, i) {
              var a = Math.cos(t),
                u = Math.sin(t),
                p = i.y + u * (this.x - i.x) + a * (this.y - i.y);
              return this.x = i.x + a * (this.x - i.x) - u * (this.y - i.y), this.y = p, this
            },
            _round: function() {
              return this.x = Math.round(this.x), this.y = Math.round(this.y), this
            }
          }, n.convert = function(t) {
            return t instanceof n ? t : Array.isArray(t) ? new n(t[0], t[1]) : t
          }, G
        }
        typeof SuppressedError == "function" && SuppressedError;
        var fe, W, le = K(de()),
          Ce = (function() {
            if (W) return fe;

            function n(t, i, a, u) {
              this.cx = 3 * t, this.bx = 3 * (a - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * i, this.by = 3 * (u - i) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = i, this.p2x = a, this.p2y = u
            }
            return W = 1, fe = n, n.prototype = {
              sampleCurveX: function(t) {
                return ((this.ax * t + this.bx) * t + this.cx) * t
              },
              sampleCurveY: function(t) {
                return ((this.ay * t + this.by) * t + this.cy) * t
              },
              sampleCurveDerivativeX: function(t) {
                return (3 * this.ax * t + 2 * this.bx) * t + this.cx
              },
              solveCurveX: function(t, i) {
                if (i === void 0 && (i = 1e-6), t < 0) return 0;
                if (t > 1) return 1;
                for (var a = t, u = 0; u < 8; u++) {
                  var p = this.sampleCurveX(a) - t;
                  if (Math.abs(p) < i) return a;
                  var f = this.sampleCurveDerivativeX(a);
                  if (Math.abs(f) < 1e-6) break;
                  a -= p / f
                }
                var g = 0,
                  x = 1;
                for (a = t, u = 0; u < 20 && (p = this.sampleCurveX(a), !(Math.abs(p - t) < i)); u++) t > p ? g = a : x = a, a = .5 * (x - g) + g;
                return a
              },
              solve: function(t, i) {
                return this.sampleCurveY(this.solveCurveX(t, i))
              }
            }, fe
          })(),
          Me = K(Ce);
        let Le, $e;

        function Oe() {
          return Le == null && (Le = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), Le
        }

        function Ve() {
          if ($e == null && ($e = !1, Oe())) {
            const t = new OffscreenCanvas(5, 5).getContext("2d", {
              willReadFrequently: !0
            });
            if (t) {
              for (let a = 0; a < 25; a++) {
                const u = 4 * a;
                t.fillStyle = `rgb(${u},${u+1},${u+2})`, t.fillRect(a % 5, Math.floor(a / 5), 1, 1)
              }
              const i = t.getImageData(0, 0, 5, 5).data;
              for (let a = 0; a < 100; a++)
                if (a % 4 != 3 && i[a] !== a) {
                  $e = !0;
                  break
                }
            }
          }
          return $e || !1
        }
        var ct = 1e-6,
          nt = typeof Float32Array < "u" ? Float32Array : Array;

        function Ye() {
          var n = new nt(9);
          return nt != Float32Array && (n[1] = 0, n[2] = 0, n[3] = 0, n[5] = 0, n[6] = 0, n[7] = 0), n[0] = 1, n[4] = 1, n[8] = 1, n
        }

        function dt(n) {
          return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = 1, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 1, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n
        }

        function rt() {
          var n = new nt(3);
          return nt != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0), n
        }

        function qe(n) {
          return Math.hypot(n[0], n[1], n[2])
        }

        function pt(n, t, i) {
          var a = new nt(3);
          return a[0] = n, a[1] = t, a[2] = i, a
        }

        function at(n, t, i) {
          return n[0] = t[0] + i[0], n[1] = t[1] + i[1], n[2] = t[2] + i[2], n
        }

        function ht(n, t, i) {
          return n[0] = t[0] * i, n[1] = t[1] * i, n[2] = t[2] * i, n
        }

        function Re(n, t, i) {
          var a = t[0],
            u = t[1],
            p = t[2],
            f = i[0],
            g = i[1],
            x = i[2];
          return n[0] = u * x - p * g, n[1] = p * f - a * x, n[2] = a * g - u * f, n
        }
        Math.hypot || (Math.hypot = function() {
          for (var n = 0, t = arguments.length; t--;) n += arguments[t] * arguments[t];
          return Math.sqrt(n)
        });
        var xt, Q = qe;

        function re(n, t, i) {
          var a = t[0],
            u = t[1],
            p = t[2],
            f = t[3];
          return n[0] = i[0] * a + i[4] * u + i[8] * p + i[12] * f, n[1] = i[1] * a + i[5] * u + i[9] * p + i[13] * f, n[2] = i[2] * a + i[6] * u + i[10] * p + i[14] * f, n[3] = i[3] * a + i[7] * u + i[11] * p + i[15] * f, n
        }

        function xe() {
          var n = new nt(4);
          return nt != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0), n[3] = 1, n
        }

        function ce(n, t, i, a) {
          var u = .5 * Math.PI / 180;
          t *= u, i *= u, a *= u;
          var p = Math.sin(t),
            f = Math.cos(t),
            g = Math.sin(i),
            x = Math.cos(i),
            S = Math.sin(a),
            I = Math.cos(a);
          return n[0] = p * x * I - f * g * S, n[1] = f * g * I + p * x * S, n[2] = f * x * S - p * g * I, n[3] = f * x * I + p * g * S, n
        }

        function Ee() {
          var n = new nt(2);
          return nt != Float32Array && (n[0] = 0, n[1] = 0), n
        }

        function Be(n, t) {
          var i = new nt(2);
          return i[0] = n, i[1] = t, i
        }
        rt(), xt = new nt(4), nt != Float32Array && (xt[0] = 0, xt[1] = 0, xt[2] = 0, xt[3] = 0), rt(), pt(1, 0, 0), pt(0, 1, 0), xe(), xe(), Ye(), Ee();
        const Ke = 8192;

        function tt(n, t, i) {
          return t * (Ke / (n.tileSize * Math.pow(2, i - n.tileID.overscaledZ)))
        }

        function ot(n, t) {
          return (n % t + t) % t
        }

        function ft(n, t, i) {
          return n * (1 - i) + t * i
        }

        function Bt(n) {
          if (n <= 0) return 0;
          if (n >= 1) return 1;
          const t = n * n,
            i = t * n;
          return 4 * (n < .5 ? i : 3 * (n - t) + i - .75)
        }

        function At(n, t, i, a) {
          const u = new Me(n, t, i, a);
          return p => u.solve(p)
        }
        const cr = At(.25, .1, .25, 1);

        function Mt(n, t, i) {
          return Math.min(i, Math.max(t, n))
        }

        function yt(n, t, i) {
          const a = i - t,
            u = ((n - t) % a + a) % a + t;
          return u === t ? i : u
        }

        function St(n, ...t) {
          for (const i of t)
            for (const a in i) n[a] = i[a];
          return n
        }
        let jt = 1;

        function Lt(n, t, i) {
          const a = {};
          for (const u in n) a[u] = t.call(this, n[u], u, n);
          return a
        }

        function Gt(n, t, i) {
          const a = {};
          for (const u in n) t.call(this, n[u], u, n) && (a[u] = n[u]);
          return a
        }

        function gr(n) {
          return Array.isArray(n) ? n.map(gr) : typeof n == "object" && n ? Lt(n, gr) : n
        }
        const ur = {};

        function Qt(n) {
          ur[n] || (typeof console < "u" && console.warn(n), ur[n] = !0)
        }

        function er(n, t, i) {
          return (i.y - n.y) * (t.x - n.x) > (t.y - n.y) * (i.x - n.x)
        }

        function Dt(n) {
          return typeof WorkerGlobalScope < "u" && n !== void 0 && n instanceof WorkerGlobalScope
        }
        let Ir = null;

        function Tr(n) {
          return typeof ImageBitmap < "u" && n instanceof ImageBitmap
        }
        const Dr = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";

        function Fr(n, t, i, a, u) {
          return o(this, void 0, void 0, (function*() {
            if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
            const p = new VideoFrame(n, {
              timestamp: 0
            });
            try {
              const f = p == null ? void 0 : p.format;
              if (!f || !f.startsWith("BGR") && !f.startsWith("RGB")) throw new Error(`Unrecognized format ${f}`);
              const g = f.startsWith("BGR"),
                x = new Uint8ClampedArray(a * u * 4);
              if (yield p.copyTo(x, (function(S, I, k, R, N) {
                  const q = 4 * Math.max(-I, 0),
                    U = (Math.max(0, k) - k) * R * 4 + q,
                    J = 4 * R,
                    ae = Math.max(0, I),
                    ke = Math.max(0, k);
                  return {
                    rect: {
                      x: ae,
                      y: ke,
                      width: Math.min(S.width, I + R) - ae,
                      height: Math.min(S.height, k + N) - ke
                    },
                    layout: [{
                      offset: U,
                      stride: J
                    }]
                  }
                })(n, t, i, a, u)), g)
                for (let S = 0; S < x.length; S += 4) {
                  const I = x[S];
                  x[S] = x[S + 2], x[S + 2] = I
                }
              return x
            } finally {
              p.close()
            }
          }))
        }
        let dr, Or;

        function zr(n, t, i, a) {
          return n.addEventListener(t, i, a), {
            unsubscribe: () => {
              n.removeEventListener(t, i, a)
            }
          }
        }

        function tr(n) {
          return n * Math.PI / 180
        }

        function br(n) {
          return n / Math.PI * 180
        }
        const $t = {
            touchstart: !0,
            touchmove: !0,
            touchmoveWindow: !0,
            touchend: !0,
            touchcancel: !0
          },
          yr = {
            dblclick: !0,
            click: !0,
            mouseover: !0,
            mouseout: !0,
            mousedown: !0,
            mousemove: !0,
            mousemoveWindow: !0,
            mouseup: !0,
            mouseupWindow: !0,
            contextmenu: !0,
            wheel: !0
          },
          jr = "AbortError";

        function ye() {
          return new Error(jr)
        }
        const j = {
          MAX_PARALLEL_IMAGE_REQUESTS: 16,
          MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8,
          MAX_TILE_CACHE_ZOOM_LEVELS: 5,
          REGISTERED_PROTOCOLS: {},
          WORKER_URL: ""
        };

        function V(n) {
          return j.REGISTERED_PROTOCOLS[n.substring(0, n.indexOf("://"))]
        }
        const X = "global-dispatcher";
        class se extends Error {
          constructor(t, i, a, u) {
            super(`AJAXError: ${i} (${t}): ${a}`), this.status = t, this.statusText = i, this.url = a, this.body = u
          }
        }
        const we = () => Dt(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href,
          Ae = function(n, t) {
            if (/:\/\//.test(n.url) && !/^https?:|^file:/.test(n.url)) {
              const a = V(n.url);
              if (a) return a(n, t);
              if (Dt(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
                type: "GR",
                data: n,
                targetMapId: X
              }, t)
            }
            if (!(/^file:/.test(i = n.url) || /^file:/.test(we()) && !/^\w+:/.test(i))) {
              if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return (function(a, u) {
                return o(this, void 0, void 0, (function*() {
                  const p = new Request(a.url, {
                    method: a.method || "GET",
                    body: a.body,
                    credentials: a.credentials,
                    headers: a.headers,
                    cache: a.cache,
                    referrer: we(),
                    signal: u.signal
                  });
                  let f, g;
                  a.type !== "json" || p.headers.has("Accept") || p.headers.set("Accept", "application/json");
                  try {
                    f = yield fetch(p)
                  } catch (S) {
                    throw new se(0, S.message, a.url, new Blob)
                  }
                  if (!f.ok) {
                    const S = yield f.blob();
                    throw new se(f.status, f.statusText, a.url, S)
                  }
                  g = a.type === "arrayBuffer" || a.type === "image" ? f.arrayBuffer() : a.type === "json" ? f.json() : f.text();
                  const x = yield g;
                  if (u.signal.aborted) throw ye();
                  return {
                    data: x,
                    cacheControl: f.headers.get("Cache-Control"),
                    expires: f.headers.get("Expires")
                  }
                }))
              })(n, t);
              if (Dt(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
                type: "GR",
                data: n,
                mustQueue: !0,
                targetMapId: X
              }, t)
            }
            var i;
            return (function(a, u) {
              return new Promise(((p, f) => {
                var g;
                const x = new XMLHttpRequest;
                x.open(a.method || "GET", a.url, !0), a.type !== "arrayBuffer" && a.type !== "image" || (x.responseType = "arraybuffer");
                for (const S in a.headers) x.setRequestHeader(S, a.headers[S]);
                a.type === "json" && (x.responseType = "text", !((g = a.headers) === null || g === void 0) && g.Accept || x.setRequestHeader("Accept", "application/json")), x.withCredentials = a.credentials === "include", x.onerror = () => {
                  f(new Error(x.statusText))
                }, x.onload = () => {
                  if (!u.signal.aborted)
                    if ((x.status >= 200 && x.status < 300 || x.status === 0) && x.response !== null) {
                      let S = x.response;
                      if (a.type === "json") try {
                        S = JSON.parse(x.response)
                      } catch (I) {
                        return void f(I)
                      }
                      p({
                        data: S,
                        cacheControl: x.getResponseHeader("Cache-Control"),
                        expires: x.getResponseHeader("Expires")
                      })
                    } else {
                      const S = new Blob([x.response], {
                        type: x.getResponseHeader("Content-Type")
                      });
                      f(new se(x.status, x.statusText, a.url, S))
                    }
                }, u.signal.addEventListener("abort", (() => {
                  x.abort(), f(ye())
                })), x.send(a.body)
              }))
            })(n, t)
          };

        function Ze(n) {
          if (!n || n.indexOf("://") <= 0 || n.indexOf("data:image/") === 0 || n.indexOf("blob:") === 0) return !0;
          const t = new URL(n),
            i = window.location;
          return t.protocol === i.protocol && t.host === i.host
        }

        function Se(n, t, i) {
          i[n] && i[n].indexOf(t) !== -1 || (i[n] = i[n] || [], i[n].push(t))
        }

        function Ne(n, t, i) {
          if (i && i[n]) {
            const a = i[n].indexOf(t);
            a !== -1 && i[n].splice(a, 1)
          }
        }
        class ze {
          constructor(t, i = {}) {
            St(this, i), this.type = t
          }
        }
        class Ie extends ze {
          constructor(t, i = {}) {
            super("error", St({
              error: t
            }, i))
          }
        }
        class We {
          on(t, i) {
            return this._listeners = this._listeners || {}, Se(t, i, this._listeners), {
              unsubscribe: () => {
                this.off(t, i)
              }
            }
          }
          off(t, i) {
            return Ne(t, i, this._listeners), Ne(t, i, this._oneTimeListeners), this
          }
          once(t, i) {
            return i ? (this._oneTimeListeners = this._oneTimeListeners || {}, Se(t, i, this._oneTimeListeners), this) : new Promise((a => this.once(t, a)))
          }
          fire(t, i) {
            typeof t == "string" && (t = new ze(t, i || {}));
            const a = t.type;
            if (this.listens(a)) {
              t.target = this;
              const u = this._listeners && this._listeners[a] ? this._listeners[a].slice() : [];
              for (const g of u) g.call(this, t);
              const p = this._oneTimeListeners && this._oneTimeListeners[a] ? this._oneTimeListeners[a].slice() : [];
              for (const g of p) Ne(a, g, this._oneTimeListeners), g.call(this, t);
              const f = this._eventedParent;
              f && (St(t, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), f.fire(t))
            } else t instanceof Ie && console.error(t.error);
            return this
          }
          listens(t) {
            return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t)
          }
          setEventedParent(t, i) {
            return this._eventedParent = t, this._eventedParentData = i, this
          }
        }
        var ve = {
          $version: 8,
          $root: {
            version: {
              required: !0,
              type: "enum",
              values: [8]
            },
            name: {
              type: "string"
            },
            metadata: {
              type: "*"
            },
            center: {
              type: "array",
              value: "number"
            },
            centerAltitude: {
              type: "number"
            },
            zoom: {
              type: "number"
            },
            bearing: {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees"
            },
            pitch: {
              type: "number",
              default: 0,
              units: "degrees"
            },
            roll: {
              type: "number",
              default: 0,
              units: "degrees"
            },
            state: {
              type: "state",
              default: {}
            },
            light: {
              type: "light"
            },
            sky: {
              type: "sky"
            },
            projection: {
              type: "projection"
            },
            terrain: {
              type: "terrain"
            },
            sources: {
              required: !0,
              type: "sources"
            },
            sprite: {
              type: "sprite"
            },
            glyphs: {
              type: "string"
            },
            transition: {
              type: "transition"
            },
            layers: {
              required: !0,
              type: "array",
              value: "layer"
            }
          },
          sources: {
            "*": {
              type: "source"
            }
          },
          source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"],
          source_vector: {
            type: {
              required: !0,
              type: "enum",
              values: {
                vector: {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            scheme: {
              type: "enum",
              values: {
                xyz: {},
                tms: {}
              },
              default: "xyz"
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            attribution: {
              type: "string"
            },
            promoteId: {
              type: "promoteId"
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            "*": {
              type: "*"
            }
          },
          source_raster: {
            type: {
              required: !0,
              type: "enum",
              values: {
                raster: {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            tileSize: {
              type: "number",
              default: 512,
              units: "pixels"
            },
            scheme: {
              type: "enum",
              values: {
                xyz: {},
                tms: {}
              },
              default: "xyz"
            },
            attribution: {
              type: "string"
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            "*": {
              type: "*"
            }
          },
          source_raster_dem: {
            type: {
              required: !0,
              type: "enum",
              values: {
                "raster-dem": {}
              }
            },
            url: {
              type: "string"
            },
            tiles: {
              type: "array",
              value: "string"
            },
            bounds: {
              type: "array",
              value: "number",
              length: 4,
              default: [-180, -85.051129, 180, 85.051129]
            },
            minzoom: {
              type: "number",
              default: 0
            },
            maxzoom: {
              type: "number",
              default: 22
            },
            tileSize: {
              type: "number",
              default: 512,
              units: "pixels"
            },
            attribution: {
              type: "string"
            },
            encoding: {
              type: "enum",
              values: {
                terrarium: {},
                mapbox: {},
                custom: {}
              },
              default: "mapbox"
            },
            redFactor: {
              type: "number",
              default: 1
            },
            blueFactor: {
              type: "number",
              default: 1
            },
            greenFactor: {
              type: "number",
              default: 1
            },
            baseShift: {
              type: "number",
              default: 0
            },
            volatile: {
              type: "boolean",
              default: !1
            },
            "*": {
              type: "*"
            }
          },
          source_geojson: {
            type: {
              required: !0,
              type: "enum",
              values: {
                geojson: {}
              }
            },
            data: {
              required: !0,
              type: "*"
            },
            maxzoom: {
              type: "number",
              default: 18
            },
            attribution: {
              type: "string"
            },
            buffer: {
              type: "number",
              default: 128,
              maximum: 512,
              minimum: 0
            },
            filter: {
              type: "*"
            },
            tolerance: {
              type: "number",
              default: .375
            },
            cluster: {
              type: "boolean",
              default: !1
            },
            clusterRadius: {
              type: "number",
              default: 50,
              minimum: 0
            },
            clusterMaxZoom: {
              type: "number"
            },
            clusterMinPoints: {
              type: "number"
            },
            clusterProperties: {
              type: "*"
            },
            lineMetrics: {
              type: "boolean",
              default: !1
            },
            generateId: {
              type: "boolean",
              default: !1
            },
            promoteId: {
              type: "promoteId"
            }
          },
          source_video: {
            type: {
              required: !0,
              type: "enum",
              values: {
                video: {}
              }
            },
            urls: {
              required: !0,
              type: "array",
              value: "string"
            },
            coordinates: {
              required: !0,
              type: "array",
              length: 4,
              value: {
                type: "array",
                length: 2,
                value: "number"
              }
            }
          },
          source_image: {
            type: {
              required: !0,
              type: "enum",
              values: {
                image: {}
              }
            },
            url: {
              required: !0,
              type: "string"
            },
            coordinates: {
              required: !0,
              type: "array",
              length: 4,
              value: {
                type: "array",
                length: 2,
                value: "number"
              }
            }
          },
          layer: {
            id: {
              type: "string",
              required: !0
            },
            type: {
              type: "enum",
              values: {
                fill: {},
                line: {},
                symbol: {},
                circle: {},
                heatmap: {},
                "fill-extrusion": {},
                raster: {},
                hillshade: {},
                "color-relief": {},
                background: {}
              },
              required: !0
            },
            metadata: {
              type: "*"
            },
            source: {
              type: "string"
            },
            "source-layer": {
              type: "string"
            },
            minzoom: {
              type: "number",
              minimum: 0,
              maximum: 24
            },
            maxzoom: {
              type: "number",
              minimum: 0,
              maximum: 24
            },
            filter: {
              type: "filter"
            },
            layout: {
              type: "layout"
            },
            paint: {
              type: "paint"
            }
          },
          layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"],
          layout_background: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_fill: {
            "fill-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_circle: {
            "circle-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_heatmap: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          "layout_fill-extrusion": {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_line: {
            "line-cap": {
              type: "enum",
              values: {
                butt: {},
                round: {},
                square: {}
              },
              default: "butt",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-join": {
              type: "enum",
              values: {
                bevel: {},
                round: {},
                miter: {}
              },
              default: "miter",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "line-miter-limit": {
              type: "number",
              default: 2,
              requires: [{
                "line-join": "miter"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-round-limit": {
              type: "number",
              default: 1.05,
              requires: [{
                "line-join": "round"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_symbol: {
            "symbol-placement": {
              type: "enum",
              values: {
                point: {},
                line: {},
                "line-center": {}
              },
              default: "point",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-spacing": {
              type: "number",
              default: 250,
              minimum: 1,
              units: "pixels",
              requires: [{
                "symbol-placement": "line"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-avoid-edges": {
              type: "boolean",
              default: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "symbol-sort-key": {
              type: "number",
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "symbol-z-order": {
              type: "enum",
              values: {
                auto: {},
                "viewport-y": {},
                source: {}
              },
              default: "auto",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-allow-overlap": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", {
                "!": "icon-overlap"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-overlap": {
              type: "enum",
              values: {
                never: {},
                always: {},
                cooperative: {}
              },
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-ignore-placement": {
              type: "boolean",
              default: !1,
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-optional": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", "text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-rotation-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-size": {
              type: "number",
              default: 1,
              minimum: 0,
              units: "factor of the original icon size",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-text-fit": {
              type: "enum",
              values: {
                none: {},
                width: {},
                height: {},
                both: {}
              },
              default: "none",
              requires: ["icon-image", "text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-text-fit-padding": {
              type: "array",
              value: "number",
              length: 4,
              default: [0, 0, 0, 0],
              units: "pixels",
              requires: ["icon-image", "text-field", {
                "icon-text-fit": ["both", "width", "height"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-image": {
              type: "resolvedImage",
              tokens: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-rotate": {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-padding": {
              type: "padding",
              default: [2],
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-keep-upright": {
              type: "boolean",
              default: !1,
              requires: ["icon-image", {
                "icon-rotation-alignment": "map"
              }, {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-offset": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-anchor": {
              type: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              default: "center",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "icon-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                auto: {}
              },
              default: "auto",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-rotation-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {},
                "viewport-glyph": {},
                auto: {}
              },
              default: "auto",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-field": {
              type: "formatted",
              default: "",
              tokens: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-font": {
              type: "array",
              value: "string",
              default: ["Open Sans Regular", "Arial Unicode MS Regular"],
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-size": {
              type: "number",
              default: 16,
              minimum: 0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-max-width": {
              type: "number",
              default: 10,
              minimum: 0,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-line-height": {
              type: "number",
              default: 1.2,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-letter-spacing": {
              type: "number",
              default: 0,
              units: "ems",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-justify": {
              type: "enum",
              values: {
                auto: {},
                left: {},
                center: {},
                right: {}
              },
              default: "center",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-radial-offset": {
              type: "number",
              units: "ems",
              default: 0,
              requires: ["text-field"],
              "property-type": "data-driven",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              }
            },
            "text-variable-anchor": {
              type: "array",
              value: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-variable-anchor-offset": {
              type: "variableAnchorOffsetCollection",
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-anchor": {
              type: "enum",
              values: {
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                "top-left": {},
                "top-right": {},
                "bottom-left": {},
                "bottom-right": {}
              },
              default: "center",
              requires: ["text-field", {
                "!": "text-variable-anchor"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-max-angle": {
              type: "number",
              default: 45,
              units: "degrees",
              requires: ["text-field", {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-writing-mode": {
              type: "array",
              value: "enum",
              values: {
                horizontal: {},
                vertical: {}
              },
              requires: ["text-field", {
                "symbol-placement": ["point"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-rotate": {
              type: "number",
              default: 0,
              period: 360,
              units: "degrees",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-padding": {
              type: "number",
              default: 2,
              minimum: 0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-keep-upright": {
              type: "boolean",
              default: !0,
              requires: ["text-field", {
                "text-rotation-alignment": "map"
              }, {
                "symbol-placement": ["line", "line-center"]
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-transform": {
              type: "enum",
              values: {
                none: {},
                uppercase: {},
                lowercase: {}
              },
              default: "none",
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-offset": {
              type: "array",
              value: "number",
              units: "ems",
              length: 2,
              default: [0, 0],
              requires: ["text-field", {
                "!": "text-radial-offset"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature"]
              },
              "property-type": "data-driven"
            },
            "text-allow-overlap": {
              type: "boolean",
              default: !1,
              requires: ["text-field", {
                "!": "text-overlap"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-overlap": {
              type: "enum",
              values: {
                never: {},
                always: {},
                cooperative: {}
              },
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-ignore-placement": {
              type: "boolean",
              default: !1,
              requires: ["text-field"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-optional": {
              type: "boolean",
              default: !1,
              requires: ["text-field", "icon-image"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_raster: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          layout_hillshade: {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          "layout_color-relief": {
            visibility: {
              type: "enum",
              values: {
                visible: {},
                none: {}
              },
              default: "visible",
              "property-type": "constant"
            }
          },
          filter: {
            type: "array",
            value: "*"
          },
          filter_operator: {
            type: "enum",
            values: {
              "==": {},
              "!=": {},
              ">": {},
              ">=": {},
              "<": {},
              "<=": {},
              in: {},
              "!in": {},
              all: {},
              any: {},
              none: {},
              has: {},
              "!has": {}
            }
          },
          geometry_type: {
            type: "enum",
            values: {
              Point: {},
              LineString: {},
              Polygon: {}
            }
          },
          function: {
            expression: {
              type: "expression"
            },
            stops: {
              type: "array",
              value: "function_stop"
            },
            base: {
              type: "number",
              default: 1,
              minimum: 0
            },
            property: {
              type: "string",
              default: "$zoom"
            },
            type: {
              type: "enum",
              values: {
                identity: {},
                exponential: {},
                interval: {},
                categorical: {}
              },
              default: "exponential"
            },
            colorSpace: {
              type: "enum",
              values: {
                rgb: {},
                lab: {},
                hcl: {}
              },
              default: "rgb"
            },
            default: {
              type: "*",
              required: !1
            }
          },
          function_stop: {
            type: "array",
            minimum: 0,
            maximum: 24,
            value: ["number", "color"],
            length: 2
          },
          expression: {
            type: "array",
            value: "*",
            minimum: 1
          },
          light: {
            anchor: {
              type: "enum",
              default: "viewport",
              values: {
                map: {},
                viewport: {}
              },
              "property-type": "data-constant",
              transition: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              }
            },
            position: {
              type: "array",
              default: [1.15, 210, 30],
              length: 3,
              value: "number",
              "property-type": "data-constant",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              }
            },
            color: {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            intensity: {
              type: "number",
              "property-type": "data-constant",
              default: .5,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            }
          },
          sky: {
            "sky-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#88C6FC",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "horizon-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "fog-color": {
              type: "color",
              "property-type": "data-constant",
              default: "#ffffff",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "fog-ground-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .5,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "horizon-fog-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "sky-horizon-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            },
            "atmosphere-blend": {
              type: "number",
              "property-type": "data-constant",
              default: .8,
              minimum: 0,
              maximum: 1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              transition: !0
            }
          },
          terrain: {
            source: {
              type: "string",
              required: !0
            },
            exaggeration: {
              type: "number",
              minimum: 0,
              default: 1
            }
          },
          projection: {
            type: {
              type: "projectionDefinition",
              default: "mercator",
              "property-type": "data-constant",
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              }
            }
          },
          paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"],
          paint_fill: {
            "fill-antialias": {
              type: "boolean",
              default: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "fill-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-outline-color": {
              type: "color",
              transition: !0,
              requires: [{
                "!": "fill-pattern"
              }, {
                "fill-antialias": !0
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["fill-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            }
          },
          "paint_fill-extrusion": {
            "fill-extrusion-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "fill-extrusion-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["fill-extrusion-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "fill-extrusion-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "fill-extrusion-height": {
              type: "number",
              default: 0,
              minimum: 0,
              units: "meters",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-base": {
              type: "number",
              default: 0,
              minimum: 0,
              units: "meters",
              transition: !0,
              requires: ["fill-extrusion-height"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "fill-extrusion-vertical-gradient": {
              type: "boolean",
              default: !0,
              transition: !1,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_line: {
            "line-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "line-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["line-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "line-width": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-gap-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-offset": {
              type: "number",
              default: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "line-dasharray": {
              type: "array",
              value: "number",
              minimum: 0,
              transition: !0,
              units: "line widths",
              requires: [{
                "!": "line-pattern"
              }],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "cross-faded"
            },
            "line-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom", "feature"]
              },
              "property-type": "cross-faded-data-driven"
            },
            "line-gradient": {
              type: "color",
              transition: !1,
              requires: [{
                "!": "line-dasharray"
              }, {
                "!": "line-pattern"
              }, {
                source: "geojson",
                has: {
                  lineMetrics: !0
                }
              }],
              expression: {
                interpolated: !0,
                parameters: ["line-progress"]
              },
              "property-type": "color-ramp"
            }
          },
          paint_circle: {
            "circle-radius": {
              type: "number",
              default: 5,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-blur": {
              type: "number",
              default: 0,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["circle-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-pitch-scale": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-pitch-alignment": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "viewport",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "circle-stroke-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-stroke-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "circle-stroke-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            }
          },
          paint_heatmap: {
            "heatmap-radius": {
              type: "number",
              default: 30,
              minimum: 1,
              transition: !0,
              units: "pixels",
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "heatmap-weight": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "heatmap-intensity": {
              type: "number",
              default: 1,
              minimum: 0,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "heatmap-color": {
              type: "color",
              default: ["interpolate", ["linear"],
                ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", .1, "royalblue", .3, "cyan", .5, "lime", .7, "yellow", 1, "red"
              ],
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["heatmap-density"]
              },
              "property-type": "color-ramp"
            },
            "heatmap-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_symbol: {
            "icon-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-color": {
              type: "color",
              default: "rgba(0, 0, 0, 0)",
              transition: !0,
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-halo-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "icon-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              requires: ["icon-image"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "icon-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["icon-image", "icon-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              overridable: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-color": {
              type: "color",
              default: "rgba(0, 0, 0, 0)",
              transition: !0,
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-width": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-halo-blur": {
              type: "number",
              default: 0,
              minimum: 0,
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom", "feature", "feature-state"]
              },
              "property-type": "data-driven"
            },
            "text-translate": {
              type: "array",
              value: "number",
              length: 2,
              default: [0, 0],
              transition: !0,
              units: "pixels",
              requires: ["text-field"],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "text-translate-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "map",
              requires: ["text-field", "text-translate"],
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_raster: {
            "raster-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-hue-rotate": {
              type: "number",
              default: 0,
              period: 360,
              transition: !0,
              units: "degrees",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-brightness-min": {
              type: "number",
              default: 0,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-brightness-max": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-saturation": {
              type: "number",
              default: 0,
              minimum: -1,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-contrast": {
              type: "number",
              default: 0,
              minimum: -1,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-resampling": {
              type: "enum",
              values: {
                linear: {},
                nearest: {}
              },
              default: "linear",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "raster-fade-duration": {
              type: "number",
              default: 300,
              minimum: 0,
              transition: !1,
              units: "milliseconds",
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          paint_hillshade: {
            "hillshade-illumination-direction": {
              type: "numberArray",
              default: 335,
              minimum: 0,
              maximum: 359,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-illumination-altitude": {
              type: "numberArray",
              default: 45,
              minimum: 0,
              maximum: 90,
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-illumination-anchor": {
              type: "enum",
              values: {
                map: {},
                viewport: {}
              },
              default: "viewport",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-exaggeration": {
              type: "number",
              default: .5,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-shadow-color": {
              type: "colorArray",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-highlight-color": {
              type: "colorArray",
              default: "#FFFFFF",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-accent-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "hillshade-method": {
              type: "enum",
              values: {
                standard: {},
                basic: {},
                combined: {},
                igor: {},
                multidirectional: {}
              },
              default: "standard",
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          "paint_color-relief": {
            "color-relief-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "color-relief-color": {
              type: "color",
              transition: !1,
              expression: {
                interpolated: !0,
                parameters: ["elevation"]
              },
              "property-type": "color-ramp"
            }
          },
          paint_background: {
            "background-color": {
              type: "color",
              default: "#000000",
              transition: !0,
              requires: [{
                "!": "background-pattern"
              }],
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            },
            "background-pattern": {
              type: "resolvedImage",
              transition: !0,
              expression: {
                interpolated: !1,
                parameters: ["zoom"]
              },
              "property-type": "cross-faded"
            },
            "background-opacity": {
              type: "number",
              default: 1,
              minimum: 0,
              maximum: 1,
              transition: !0,
              expression: {
                interpolated: !0,
                parameters: ["zoom"]
              },
              "property-type": "data-constant"
            }
          },
          transition: {
            duration: {
              type: "number",
              default: 300,
              minimum: 0,
              units: "milliseconds"
            },
            delay: {
              type: "number",
              default: 0,
              minimum: 0,
              units: "milliseconds"
            }
          },
          "property-type": {
            "data-driven": {
              type: "property-type"
            },
            "cross-faded": {
              type: "property-type"
            },
            "cross-faded-data-driven": {
              type: "property-type"
            },
            "color-ramp": {
              type: "property-type"
            },
            "data-constant": {
              type: "property-type"
            },
            constant: {
              type: "property-type"
            }
          },
          promoteId: {
            "*": {
              type: "string"
            }
          }
        };
        const Pt = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];

        function Xt(n, t) {
          const i = {};
          for (const a in n) a !== "ref" && (i[a] = n[a]);
          return Pt.forEach((a => {
            a in t && (i[a] = t[a])
          })), i
        }

        function Nt(n, t) {
          if (Array.isArray(n)) {
            if (!Array.isArray(t) || n.length !== t.length) return !1;
            for (let i = 0; i < n.length; i++)
              if (!Nt(n[i], t[i])) return !1;
            return !0
          }
          if (typeof n == "object" && n !== null && t !== null) {
            if (typeof t != "object" || Object.keys(n).length !== Object.keys(t).length) return !1;
            for (const i in n)
              if (!Nt(n[i], t[i])) return !1;
            return !0
          }
          return n === t
        }

        function Ht(n, t) {
          n.push(t)
        }

        function or(n, t, i) {
          Ht(i, {
            command: "addSource",
            args: [n, t[n]]
          })
        }

        function ri(n, t, i) {
          Ht(t, {
            command: "removeSource",
            args: [n]
          }), i[n] = !0
        }

        function ti(n, t, i, a) {
          ri(n, i, a), or(n, t, i)
        }

        function Wr(n, t, i) {
          let a;
          for (a in n[i])
            if (Object.prototype.hasOwnProperty.call(n[i], a) && a !== "data" && !Nt(n[i][a], t[i][a])) return !1;
          for (a in t[i])
            if (Object.prototype.hasOwnProperty.call(t[i], a) && a !== "data" && !Nt(n[i][a], t[i][a])) return !1;
          return !0
        }

        function Cr(n, t, i, a, u, p) {
          n = n || {}, t = t || {};
          for (const f in n) Object.prototype.hasOwnProperty.call(n, f) && (Nt(n[f], t[f]) || i.push({
            command: p,
            args: [a, f, t[f], u]
          }));
          for (const f in t) Object.prototype.hasOwnProperty.call(t, f) && !Object.prototype.hasOwnProperty.call(n, f) && (Nt(n[f], t[f]) || i.push({
            command: p,
            args: [a, f, t[f], u]
          }))
        }

        function ii(n) {
          return n.id
        }

        function Hi(n, t) {
          return n[t.id] = t, n
        }
        class je {
          constructor(t, i, a, u) {
            this.message = (t ? `${t}: ` : "") + a, u && (this.identifier = u), i != null && i.__line__ && (this.line = i.__line__)
          }
        }

        function Ut(n, ...t) {
          for (const i of t)
            for (const a in i) n[a] = i[a];
          return n
        }
        class nr extends Error {
          constructor(t, i) {
            super(i), this.message = i, this.key = t
          }
        }
        class Gr {
          constructor(t, i = []) {
            this.parent = t, this.bindings = {};
            for (const [a, u] of i) this.bindings[a] = u
          }
          concat(t) {
            return new Gr(this, t)
          }
          get(t) {
            if (this.bindings[t]) return this.bindings[t];
            if (this.parent) return this.parent.get(t);
            throw new Error(`${t} not found in scope.`)
          }
          has(t) {
            return !!this.bindings[t] || !!this.parent && this.parent.has(t)
          }
        }
        const Xr = {
            kind: "null"
          },
          gt = {
            kind: "number"
          },
          hr = {
            kind: "string"
          },
          xr = {
            kind: "boolean"
          },
          ai = {
            kind: "color"
          },
          ki = {
            kind: "projectionDefinition"
          },
          _i = {
            kind: "object"
          },
          _r = {
            kind: "value"
          },
          Ti = {
            kind: "collator"
          },
          Ar = {
            kind: "formatted"
          },
          qr = {
            kind: "padding"
          },
          fi = {
            kind: "colorArray"
          },
          nn = {
            kind: "numberArray"
          },
          un = {
            kind: "resolvedImage"
          },
          bt = {
            kind: "variableAnchorOffsetCollection"
          };

        function Rt(n, t) {
          return {
            kind: "array",
            itemType: n,
            N: t
          }
        }

        function Zt(n) {
          if (n.kind === "array") {
            const t = Zt(n.itemType);
            return typeof n.N == "number" ? `array<${t}, ${n.N}>` : n.itemType.kind === "value" ? "array" : `array<${t}>`
          }
          return n.kind
        }
        const hi = [Xr, gt, hr, xr, ai, ki, Ar, _i, Rt(_r), qr, nn, fi, un, bt];

        function gi(n, t) {
          if (t.kind === "error") return null;
          if (n.kind === "array") {
            if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !gi(n.itemType, t.itemType)) && (typeof n.N != "number" || n.N === t.N)) return null
          } else {
            if (n.kind === t.kind) return null;
            if (n.kind === "value") {
              for (const i of hi)
                if (!gi(i, t)) return null
            }
          }
          return `Expected ${Zt(n)} but found ${Zt(t)} instead.`
        }

        function Ei(n, t) {
          return t.some((i => i.kind === n.kind))
        }

        function si(n, t) {
          return t.some((i => i === "null" ? n === null : i === "array" ? Array.isArray(n) : i === "object" ? n && !Array.isArray(n) && typeof n == "object" : i === typeof n))
        }

        function vr(n, t) {
          return n.kind === "array" && t.kind === "array" ? n.itemType.kind === t.itemType.kind && typeof n.N == "number" : n.kind === t.kind
        }
        const Xi = .96422,
          Jt = .82521,
          Vt = 4 / 29,
          Ur = 6 / 29,
          Kr = 3 * Ur * Ur,
          bi = Ur * Ur * Ur,
          Yr = Math.PI / 180,
          wi = 180 / Math.PI;

        function Fi(n) {
          return (n %= 360) < 0 && (n += 360), n
        }

        function Ci([n, t, i, a]) {
          let u, p;
          const f = Li((.2225045 * (n = zi(n)) + .7168786 * (t = zi(t)) + .0606169 * (i = zi(i))) / 1);
          n === t && t === i ? u = p = f : (u = Li((.4360747 * n + .3850649 * t + .1430804 * i) / Xi), p = Li((.0139322 * n + .0971045 * t + .7141733 * i) / Jt));
          const g = 116 * f - 16;
          return [g < 0 ? 0 : g, 500 * (u - f), 200 * (f - p), a]
        }

        function zi(n) {
          return n <= .04045 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4)
        }

        function Li(n) {
          return n > bi ? Math.pow(n, 1 / 3) : n / Kr + Vt
        }

        function vi([n, t, i, a]) {
          let u = (n + 16) / 116,
            p = isNaN(t) ? u : u + t / 500,
            f = isNaN(i) ? u : u - i / 200;
          return u = 1 * Jn(u), p = Xi * Jn(p), f = Jt * Jn(f), [an(3.1338561 * p - 1.6168667 * u - .4906146 * f), an(-.9787684 * p + 1.9161415 * u + .033454 * f), an(.0719453 * p - .2289914 * u + 1.4052427 * f), a]
        }

        function an(n) {
          return (n = n <= .00304 ? 12.92 * n : 1.055 * Math.pow(n, 1 / 2.4) - .055) < 0 ? 0 : n > 1 ? 1 : n
        }

        function Jn(n) {
          return n > Ur ? n * n * n : Kr * (n - Vt)
        }
        const Ki = Object.hasOwn || function(n, t) {
          return Object.prototype.hasOwnProperty.call(n, t)
        };

        function Jr(n, t) {
          return Ki(n, t) ? n[t] : void 0
        }

        function Qn(n) {
          return parseInt(n.padEnd(2, n), 16) / 255
        }

        function oa(n, t) {
          return pa(t ? n / 100 : n, 0, 1)
        }

        function pa(n, t, i) {
          return Math.min(Math.max(t, n), i)
        }

        function os(n) {
          return !n.some(Number.isNaN)
        }
        const Ps = {
          aliceblue: [240, 248, 255],
          antiquewhite: [250, 235, 215],
          aqua: [0, 255, 255],
          aquamarine: [127, 255, 212],
          azure: [240, 255, 255],
          beige: [245, 245, 220],
          bisque: [255, 228, 196],
          black: [0, 0, 0],
          blanchedalmond: [255, 235, 205],
          blue: [0, 0, 255],
          blueviolet: [138, 43, 226],
          brown: [165, 42, 42],
          burlywood: [222, 184, 135],
          cadetblue: [95, 158, 160],
          chartreuse: [127, 255, 0],
          chocolate: [210, 105, 30],
          coral: [255, 127, 80],
          cornflowerblue: [100, 149, 237],
          cornsilk: [255, 248, 220],
          crimson: [220, 20, 60],
          cyan: [0, 255, 255],
          darkblue: [0, 0, 139],
          darkcyan: [0, 139, 139],
          darkgoldenrod: [184, 134, 11],
          darkgray: [169, 169, 169],
          darkgreen: [0, 100, 0],
          darkgrey: [169, 169, 169],
          darkkhaki: [189, 183, 107],
          darkmagenta: [139, 0, 139],
          darkolivegreen: [85, 107, 47],
          darkorange: [255, 140, 0],
          darkorchid: [153, 50, 204],
          darkred: [139, 0, 0],
          darksalmon: [233, 150, 122],
          darkseagreen: [143, 188, 143],
          darkslateblue: [72, 61, 139],
          darkslategray: [47, 79, 79],
          darkslategrey: [47, 79, 79],
          darkturquoise: [0, 206, 209],
          darkviolet: [148, 0, 211],
          deeppink: [255, 20, 147],
          deepskyblue: [0, 191, 255],
          dimgray: [105, 105, 105],
          dimgrey: [105, 105, 105],
          dodgerblue: [30, 144, 255],
          firebrick: [178, 34, 34],
          floralwhite: [255, 250, 240],
          forestgreen: [34, 139, 34],
          fuchsia: [255, 0, 255],
          gainsboro: [220, 220, 220],
          ghostwhite: [248, 248, 255],
          gold: [255, 215, 0],
          goldenrod: [218, 165, 32],
          gray: [128, 128, 128],
          green: [0, 128, 0],
          greenyellow: [173, 255, 47],
          grey: [128, 128, 128],
          honeydew: [240, 255, 240],
          hotpink: [255, 105, 180],
          indianred: [205, 92, 92],
          indigo: [75, 0, 130],
          ivory: [255, 255, 240],
          khaki: [240, 230, 140],
          lavender: [230, 230, 250],
          lavenderblush: [255, 240, 245],
          lawngreen: [124, 252, 0],
          lemonchiffon: [255, 250, 205],
          lightblue: [173, 216, 230],
          lightcoral: [240, 128, 128],
          lightcyan: [224, 255, 255],
          lightgoldenrodyellow: [250, 250, 210],
          lightgray: [211, 211, 211],
          lightgreen: [144, 238, 144],
          lightgrey: [211, 211, 211],
          lightpink: [255, 182, 193],
          lightsalmon: [255, 160, 122],
          lightseagreen: [32, 178, 170],
          lightskyblue: [135, 206, 250],
          lightslategray: [119, 136, 153],
          lightslategrey: [119, 136, 153],
          lightsteelblue: [176, 196, 222],
          lightyellow: [255, 255, 224],
          lime: [0, 255, 0],
          limegreen: [50, 205, 50],
          linen: [250, 240, 230],
          magenta: [255, 0, 255],
          maroon: [128, 0, 0],
          mediumaquamarine: [102, 205, 170],
          mediumblue: [0, 0, 205],
          mediumorchid: [186, 85, 211],
          mediumpurple: [147, 112, 219],
          mediumseagreen: [60, 179, 113],
          mediumslateblue: [123, 104, 238],
          mediumspringgreen: [0, 250, 154],
          mediumturquoise: [72, 209, 204],
          mediumvioletred: [199, 21, 133],
          midnightblue: [25, 25, 112],
          mintcream: [245, 255, 250],
          mistyrose: [255, 228, 225],
          moccasin: [255, 228, 181],
          navajowhite: [255, 222, 173],
          navy: [0, 0, 128],
          oldlace: [253, 245, 230],
          olive: [128, 128, 0],
          olivedrab: [107, 142, 35],
          orange: [255, 165, 0],
          orangered: [255, 69, 0],
          orchid: [218, 112, 214],
          palegoldenrod: [238, 232, 170],
          palegreen: [152, 251, 152],
          paleturquoise: [175, 238, 238],
          palevioletred: [219, 112, 147],
          papayawhip: [255, 239, 213],
          peachpuff: [255, 218, 185],
          peru: [205, 133, 63],
          pink: [255, 192, 203],
          plum: [221, 160, 221],
          powderblue: [176, 224, 230],
          purple: [128, 0, 128],
          rebeccapurple: [102, 51, 153],
          red: [255, 0, 0],
          rosybrown: [188, 143, 143],
          royalblue: [65, 105, 225],
          saddlebrown: [139, 69, 19],
          salmon: [250, 128, 114],
          sandybrown: [244, 164, 96],
          seagreen: [46, 139, 87],
          seashell: [255, 245, 238],
          sienna: [160, 82, 45],
          silver: [192, 192, 192],
          skyblue: [135, 206, 235],
          slateblue: [106, 90, 205],
          slategray: [112, 128, 144],
          slategrey: [112, 128, 144],
          snow: [255, 250, 250],
          springgreen: [0, 255, 127],
          steelblue: [70, 130, 180],
          tan: [210, 180, 140],
          teal: [0, 128, 128],
          thistle: [216, 191, 216],
          tomato: [255, 99, 71],
          turquoise: [64, 224, 208],
          violet: [238, 130, 238],
          wheat: [245, 222, 179],
          white: [255, 255, 255],
          whitesmoke: [245, 245, 245],
          yellow: [255, 255, 0],
          yellowgreen: [154, 205, 50]
        };

        function Vn(n, t, i) {
          return n + i * (t - n)
        }

        function ea(n, t, i) {
          return n.map(((a, u) => Vn(a, t[u], i)))
        }
        class ni {
          constructor(t, i, a, u = 1, p = !0) {
            this.r = t, this.g = i, this.b = a, this.a = u, p || (this.r *= u, this.g *= u, this.b *= u, u || this.overwriteGetter("rgb", [t, i, a, u]))
          }
          static parse(t) {
            if (t instanceof ni) return t;
            if (typeof t != "string") return;
            const i = (function(a) {
              if ((a = a.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
              const u = Jr(Ps, a);
              if (u) {
                const [f, g, x] = u;
                return [f / 255, g / 255, x / 255, 1]
              }
              if (a.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(a)) {
                const f = a.length < 6 ? 1 : 2;
                let g = 1;
                return [Qn(a.slice(g, g += f)), Qn(a.slice(g, g += f)), Qn(a.slice(g, g += f)), Qn(a.slice(g, g + f) || "ff")]
              }
              if (a.startsWith("rgb")) {
                const f = a.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (f) {
                  const [g, x, S, I, k, R, N, q, U, J, ae, ke] = f, _e = [I || " ", N || " ", J].join("");
                  if (_e === "  " || _e === "  /" || _e === ",," || _e === ",,,") {
                    const O = [S, R, U].join(""),
                      Y = O === "%%%" ? 100 : O === "" ? 255 : 0;
                    if (Y) {
                      const ge = [pa(+x / Y, 0, 1), pa(+k / Y, 0, 1), pa(+q / Y, 0, 1), ae ? oa(+ae, ke) : 1];
                      if (os(ge)) return ge
                    }
                  }
                  return
                }
              }
              const p = a.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (p) {
                const [f, g, x, S, I, k, R, N, q] = p, U = [x || " ", I || " ", R].join("");
                if (U === "  " || U === "  /" || U === ",," || U === ",,,") {
                  const J = [+g, pa(+S, 0, 100), pa(+k, 0, 100), N ? oa(+N, q) : 1];
                  if (os(J)) return (function([ae, ke, _e, O]) {
                    function Y(ge) {
                      const Xe = (ge + ae / 30) % 12,
                        wt = ke * Math.min(_e, 1 - _e);
                      return _e - wt * Math.max(-1, Math.min(Xe - 3, 9 - Xe, 1))
                    }
                    return ae = Fi(ae), ke /= 100, _e /= 100, [Y(0), Y(8), Y(4), O]
                  })(J)
                }
              }
            })(t);
            return i ? new ni(...i, !1) : void 0
          }
          get rgb() {
            const {
              r: t,
              g: i,
              b: a,
              a: u
            } = this, p = u || 1 / 0;
            return this.overwriteGetter("rgb", [t / p, i / p, a / p, u])
          }
          get hcl() {
            return this.overwriteGetter("hcl", (function(t) {
              const [i, a, u, p] = Ci(t), f = Math.sqrt(a * a + u * u);
              return [Math.round(1e4 * f) ? Fi(Math.atan2(u, a) * wi) : NaN, f, i, p]
            })(this.rgb))
          }
          get lab() {
            return this.overwriteGetter("lab", Ci(this.rgb))
          }
          overwriteGetter(t, i) {
            return Object.defineProperty(this, t, {
              value: i
            }), i
          }
          toString() {
            const [t, i, a, u] = this.rgb;
            return `rgba(${[t,i,a].map((p=>Math.round(255*p))).join(",")},${u})`
          }
          static interpolate(t, i, a, u = "rgb") {
            switch (u) {
              case "rgb": {
                const [p, f, g, x] = ea(t.rgb, i.rgb, a);
                return new ni(p, f, g, x, !1)
              }
              case "hcl": {
                const [p, f, g, x] = t.hcl, [S, I, k, R] = i.hcl;
                let N, q;
                if (isNaN(p) || isNaN(S)) isNaN(p) ? isNaN(S) ? N = NaN : (N = S, g !== 1 && g !== 0 || (q = I)) : (N = p, k !== 1 && k !== 0 || (q = f));
                else {
                  let _e = S - p;
                  S > p && _e > 180 ? _e -= 360 : S < p && p - S > 180 && (_e += 360), N = p + a * _e
                }
                const [U, J, ae, ke] = (function([_e, O, Y, ge]) {
                  return _e = isNaN(_e) ? 0 : _e * Yr, vi([Y, Math.cos(_e) * O, Math.sin(_e) * O, ge])
                })([N, q ?? Vn(f, I, a), Vn(g, k, a), Vn(x, R, a)]);
                return new ni(U, J, ae, ke, !1)
              }
              case "lab": {
                const [p, f, g, x] = vi(ea(t.lab, i.lab, a));
                return new ni(p, f, g, x, !1)
              }
            }
          }
        }
        ni.black = new ni(0, 0, 0, 1), ni.white = new ni(1, 1, 1, 1), ni.transparent = new ni(0, 0, 0, 0), ni.red = new ni(1, 0, 0, 1);
        class Ua {
          constructor(t, i, a) {
            this.sensitivity = t ? i ? "variant" : "case" : i ? "accent" : "base", this.locale = a, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
              sensitivity: this.sensitivity,
              usage: "search"
            })
          }
          compare(t, i) {
            return this.collator.compare(t, i)
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale
          }
        }
        const La = ["bottom", "center", "top"];
        class co {
          constructor(t, i, a, u, p, f) {
            this.text = t, this.image = i, this.scale = a, this.fontStack = u, this.textColor = p, this.verticalAlign = f
          }
        }
        class Yi {
          constructor(t) {
            this.sections = t
          }
          static fromString(t) {
            return new Yi([new co(t, null, null, null, null, null)])
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some((t => t.text.length !== 0 || t.image && t.image.name.length !== 0))
          }
          static factory(t) {
            return t instanceof Yi ? t : Yi.fromString(t)
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map((t => t.text)).join("")
          }
        }
        class Oi {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof Oi) return t;
            if (typeof t == "number") return new Oi([t, t, t, t]);
            if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
              for (const i of t)
                if (typeof i != "number") return;
              switch (t.length) {
                case 1:
                  t = [t[0], t[0], t[0], t[0]];
                  break;
                case 2:
                  t = [t[0], t[1], t[0], t[1]];
                  break;
                case 3:
                  t = [t[0], t[1], t[2], t[1]]
              }
              return new Oi(t)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, i, a) {
            return new Oi(ea(t.values, i.values, a))
          }
        }
        class hn {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof hn) return t;
            if (typeof t == "number") return new hn([t]);
            if (Array.isArray(t)) {
              for (const i of t)
                if (typeof i != "number") return;
              return new hn(t)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, i, a) {
            return new hn(ea(t.values, i.values, a))
          }
        }
        class dn {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof dn) return t;
            if (typeof t == "string") {
              const a = ni.parse(t);
              return a ? new dn([a]) : void 0
            }
            if (!Array.isArray(t)) return;
            const i = [];
            for (const a of t) {
              if (typeof a != "string") return;
              const u = ni.parse(a);
              if (!u) return;
              i.push(u)
            }
            return new dn(i)
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, i, a, u = "rgb") {
            const p = [];
            if (t.values.length != i.values.length) throw new Error(`colorArray: Arrays have mismatched length (${t.values.length} vs. ${i.values.length}), cannot interpolate.`);
            for (let f = 0; f < t.values.length; f++) p.push(ni.interpolate(t.values[f], i.values[f], a, u));
            return new dn(p)
          }
        }
        class Ni extends Error {
          constructor(t) {
            super(t), this.name = "RuntimeError"
          }
          toJSON() {
            return this.message
          }
        }
        const rl = new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class di {
          constructor(t) {
            this.values = t.slice()
          }
          static parse(t) {
            if (t instanceof di) return t;
            if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
              for (let i = 0; i < t.length; i += 2) {
                const a = t[i],
                  u = t[i + 1];
                if (typeof a != "string" || !rl.has(a) || !Array.isArray(u) || u.length !== 2 || typeof u[0] != "number" || typeof u[1] != "number") return
              }
              return new di(t)
            }
          }
          toString() {
            return JSON.stringify(this.values)
          }
          static interpolate(t, i, a) {
            const u = t.values,
              p = i.values;
            if (u.length !== p.length) throw new Ni(`Cannot interpolate values of different length. from: ${t.toString()}, to: ${i.toString()}`);
            const f = [];
            for (let g = 0; g < u.length; g += 2) {
              if (u[g] !== p[g]) throw new Ni(`Cannot interpolate values containing mismatched anchors. from[${g}]: ${u[g]}, to[${g}]: ${p[g]}`);
              f.push(u[g]);
              const [x, S] = u[g + 1], [I, k] = p[g + 1];
              f.push([Vn(x, I, a), Vn(S, k, a)])
            }
            return new di(f)
          }
        }
        class Zn {
          constructor(t) {
            this.name = t.name, this.available = t.available
          }
          toString() {
            return this.name
          }
          static fromString(t) {
            return t ? new Zn({
              name: t,
              available: !1
            }) : null
          }
        }
        class Hr {
          constructor(t, i, a) {
            this.from = t, this.to = i, this.transition = a
          }
          static interpolate(t, i, a) {
            return new Hr(t, i, a)
          }
          static parse(t) {
            return t instanceof Hr ? t : Array.isArray(t) && t.length === 3 && typeof t[0] == "string" && typeof t[1] == "string" && typeof t[2] == "number" ? new Hr(t[0], t[1], t[2]) : typeof t == "object" && typeof t.from == "string" && typeof t.to == "string" && typeof t.transition == "number" ? new Hr(t.from, t.to, t.transition) : typeof t == "string" ? new Hr(t, t, 1) : void 0
          }
        }

        function Qr(n, t, i, a) {
          return typeof n == "number" && n >= 0 && n <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof i == "number" && i >= 0 && i <= 255 ? a === void 0 || typeof a == "number" && a >= 0 && a <= 1 ? null : `Invalid rgba value [${[n,t,i,a].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof a=="number"?[n,t,i,a]:[n,t,i]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`
        }

        function ls(n) {
          if (n === null || typeof n == "string" || typeof n == "boolean" || typeof n == "number" || n instanceof Hr || n instanceof ni || n instanceof Ua || n instanceof Yi || n instanceof Oi || n instanceof hn || n instanceof dn || n instanceof di || n instanceof Zn) return !0;
          if (Array.isArray(n)) {
            for (const t of n)
              if (!ls(t)) return !1;
            return !0
          }
          if (typeof n == "object") {
            for (const t in n)
              if (!ls(n[t])) return !1;
            return !0
          }
          return !1
        }

        function Nr(n) {
          if (n === null) return Xr;
          if (typeof n == "string") return hr;
          if (typeof n == "boolean") return xr;
          if (typeof n == "number") return gt;
          if (n instanceof ni) return ai;
          if (n instanceof Hr) return ki;
          if (n instanceof Ua) return Ti;
          if (n instanceof Yi) return Ar;
          if (n instanceof Oi) return qr;
          if (n instanceof hn) return nn;
          if (n instanceof dn) return fi;
          if (n instanceof di) return bt;
          if (n instanceof Zn) return un;
          if (Array.isArray(n)) {
            const t = n.length;
            let i;
            for (const a of n) {
              const u = Nr(a);
              if (i) {
                if (i === u) continue;
                i = _r;
                break
              }
              i = u
            }
            return Rt(i || _r, t)
          }
          return _i
        }

        function cs(n) {
          const t = typeof n;
          return n === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(n) : n instanceof ni || n instanceof Hr || n instanceof Yi || n instanceof Oi || n instanceof hn || n instanceof dn || n instanceof di || n instanceof Zn ? n.toString() : JSON.stringify(n)
        }
        class Dn {
          constructor(t, i) {
            this.type = t, this.value = i
          }
          static parse(t, i) {
            if (t.length !== 2) return i.error(`'literal' expression requires exactly one argument, but found ${t.length-1} instead.`);
            if (!ls(t[1])) return i.error("invalid value");
            const a = t[1];
            let u = Nr(a);
            const p = i.expectedType;
            return u.kind !== "array" || u.N !== 0 || !p || p.kind !== "array" || typeof p.N == "number" && p.N !== 0 || (u = p), new Dn(u, a)
          }
          evaluate() {
            return this.value
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        const Is = {
          string: hr,
          number: gt,
          boolean: xr,
          object: _i
        };
        class $n {
          constructor(t, i) {
            this.type = t, this.args = i
          }
          static parse(t, i) {
            if (t.length < 2) return i.error("Expected at least one argument.");
            let a, u = 1;
            const p = t[0];
            if (p === "array") {
              let g, x;
              if (t.length > 2) {
                const S = t[1];
                if (typeof S != "string" || !(S in Is) || S === "object") return i.error('The item type argument of "array" must be one of string, number, boolean', 1);
                g = Is[S], u++
              } else g = _r;
              if (t.length > 3) {
                if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2]))) return i.error('The length argument to "array" must be a positive integer literal', 2);
                x = t[2], u++
              }
              a = Rt(g, x)
            } else {
              if (!Is[p]) throw new Error(`Types doesn't contain name = ${p}`);
              a = Is[p]
            }
            const f = [];
            for (; u < t.length; u++) {
              const g = i.parse(t[u], u, _r);
              if (!g) return null;
              f.push(g)
            }
            return new $n(a, f)
          }
          evaluate(t) {
            for (let i = 0; i < this.args.length; i++) {
              const a = this.args[i].evaluate(t);
              if (!gi(this.type, Nr(a))) return a;
              if (i === this.args.length - 1) throw new Ni(`Expected value to be of type ${Zt(this.type)}, but found ${Zt(Nr(a))} instead.`)
            }
            throw new Error
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return this.args.every((t => t.outputDefined()))
          }
        }
        const fc = {
          "to-boolean": xr,
          "to-color": ai,
          "to-number": gt,
          "to-string": hr
        };
        class Ca {
          constructor(t, i) {
            this.type = t, this.args = i
          }
          static parse(t, i) {
            if (t.length < 2) return i.error("Expected at least one argument.");
            const a = t[0];
            if (!fc[a]) throw new Error(`Can't parse ${a} as it is not part of the known types`);
            if ((a === "to-boolean" || a === "to-string") && t.length !== 2) return i.error("Expected one argument.");
            const u = fc[a],
              p = [];
            for (let f = 1; f < t.length; f++) {
              const g = i.parse(t[f], f, _r);
              if (!g) return null;
              p.push(g)
            }
            return new Ca(u, p)
          }
          evaluate(t) {
            switch (this.type.kind) {
              case "boolean":
                return !!this.args[0].evaluate(t);
              case "color": {
                let i, a;
                for (const u of this.args) {
                  if (i = u.evaluate(t), a = null, i instanceof ni) return i;
                  if (typeof i == "string") {
                    const p = t.parseColor(i);
                    if (p) return p
                  } else if (Array.isArray(i) && (a = i.length < 3 || i.length > 4 ? `Invalid rgba value ${JSON.stringify(i)}: expected an array containing either three or four numeric values.` : Qr(i[0], i[1], i[2], i[3]), !a)) return new ni(i[0] / 255, i[1] / 255, i[2] / 255, i[3])
                }
                throw new Ni(a || `Could not parse color from value '${typeof i=="string"?i:JSON.stringify(i)}'`)
              }
              case "padding": {
                let i;
                for (const a of this.args) {
                  i = a.evaluate(t);
                  const u = Oi.parse(i);
                  if (u) return u
                }
                throw new Ni(`Could not parse padding from value '${typeof i=="string"?i:JSON.stringify(i)}'`)
              }
              case "numberArray": {
                let i;
                for (const a of this.args) {
                  i = a.evaluate(t);
                  const u = hn.parse(i);
                  if (u) return u
                }
                throw new Ni(`Could not parse numberArray from value '${typeof i=="string"?i:JSON.stringify(i)}'`)
              }
              case "colorArray": {
                let i;
                for (const a of this.args) {
                  i = a.evaluate(t);
                  const u = dn.parse(i);
                  if (u) return u
                }
                throw new Ni(`Could not parse colorArray from value '${typeof i=="string"?i:JSON.stringify(i)}'`)
              }
              case "variableAnchorOffsetCollection": {
                let i;
                for (const a of this.args) {
                  i = a.evaluate(t);
                  const u = di.parse(i);
                  if (u) return u
                }
                throw new Ni(`Could not parse variableAnchorOffsetCollection from value '${typeof i=="string"?i:JSON.stringify(i)}'`)
              }
              case "number": {
                let i = null;
                for (const a of this.args) {
                  if (i = a.evaluate(t), i === null) return 0;
                  const u = Number(i);
                  if (!isNaN(u)) return u
                }
                throw new Ni(`Could not convert ${JSON.stringify(i)} to number.`)
              }
              case "formatted":
                return Yi.fromString(cs(this.args[0].evaluate(t)));
              case "resolvedImage":
                return Zn.fromString(cs(this.args[0].evaluate(t)));
              case "projectionDefinition":
                return this.args[0].evaluate(t);
              default:
                return cs(this.args[0].evaluate(t))
            }
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return this.args.every((t => t.outputDefined()))
          }
        }
        const gh = ["Unknown", "Point", "LineString", "Polygon"];
        class vh {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = new Map, this.availableImages = null, this.canonical = null
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? gh[this.feature.type] : this.feature.type : null
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null
          }
          canonicalID() {
            return this.canonical
          }
          properties() {
            return this.feature && this.feature.properties || {}
          }
          parseColor(t) {
            let i = this._parseColorCache.get(t);
            return i || (i = ni.parse(t), this._parseColorCache.set(t, i)), i
          }
        }
        class uo {
          constructor(t, i, a = [], u, p = new Gr, f = []) {
            this.registry = t, this.path = a, this.key = a.map((g => `[${g}]`)).join(""), this.scope = p, this.errors = f, this.expectedType = u, this._isConstant = i
          }
          parse(t, i, a, u, p = {}) {
            return i ? this.concat(i, a, u)._parse(t, p) : this._parse(t, p)
          }
          _parse(t, i) {
            function a(u, p, f) {
              return f === "assert" ? new $n(p, [u]) : f === "coerce" ? new Ca(p, [u]) : u
            }
            if (t !== null && typeof t != "string" && typeof t != "boolean" && typeof t != "number" || (t = ["literal", t]), Array.isArray(t)) {
              if (t.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const u = t[0];
              if (typeof u != "string") return this.error(`Expression name must be a string, but found ${typeof u} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const p = this.registry[u];
              if (p) {
                let f = p.parse(t, this);
                if (!f) return null;
                if (this.expectedType) {
                  const g = this.expectedType,
                    x = f.type;
                  if (g.kind !== "string" && g.kind !== "number" && g.kind !== "boolean" && g.kind !== "object" && g.kind !== "array" || x.kind !== "value") {
                    if (g.kind === "projectionDefinition" && ["string", "array"].includes(x.kind) || ["color", "formatted", "resolvedImage"].includes(g.kind) && ["value", "string"].includes(x.kind) || ["padding", "numberArray"].includes(g.kind) && ["value", "number", "array"].includes(x.kind) || g.kind === "colorArray" && ["value", "string", "array"].includes(x.kind) || g.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(x.kind)) f = a(f, g, i.typeAnnotation || "coerce");
                    else if (this.checkSubtype(g, x)) return null
                  } else f = a(f, g, i.typeAnnotation || "assert")
                }
                if (!(f instanceof Dn) && f.type.kind !== "resolvedImage" && this._isConstant(f)) {
                  const g = new vh;
                  try {
                    f = new Dn(f.type, f.evaluate(g))
                  } catch (x) {
                    return this.error(x.message), null
                  }
                }
                return f
              }
              return this.error(`Unknown expression "${u}". If you wanted a literal array, use ["literal", [...]].`, 0)
            }
            return this.error(t === void 0 ? "'undefined' value invalid. Use null instead." : typeof t == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`)
          }
          concat(t, i, a) {
            const u = typeof t == "number" ? this.path.concat(t) : this.path,
              p = a ? this.scope.concat(a) : this.scope;
            return new uo(this.registry, this._isConstant, u, i || null, p, this.errors)
          }
          error(t, ...i) {
            const a = `${this.key}${i.map((u=>`[${u}]`)).join("")}`;
            this.errors.push(new nr(a, t))
          }
          checkSubtype(t, i) {
            const a = gi(t, i);
            return a && this.error(a), a
          }
        }
        class ho {
          constructor(t, i) {
            this.type = i.type, this.bindings = [].concat(t), this.result = i
          }
          evaluate(t) {
            return this.result.evaluate(t)
          }
          eachChild(t) {
            for (const i of this.bindings) t(i[1]);
            t(this.result)
          }
          static parse(t, i) {
            if (t.length < 4) return i.error(`Expected at least 3 arguments, but found ${t.length-1} instead.`);
            const a = [];
            for (let p = 1; p < t.length - 1; p += 2) {
              const f = t[p];
              if (typeof f != "string") return i.error(`Expected string, but found ${typeof f} instead.`, p);
              if (/[^a-zA-Z0-9_]/.test(f)) return i.error("Variable names must contain only alphanumeric characters or '_'.", p);
              const g = i.parse(t[p + 1], p + 1);
              if (!g) return null;
              a.push([f, g])
            }
            const u = i.parse(t[t.length - 1], t.length - 1, i.expectedType, a);
            return u ? new ho(a, u) : null
          }
          outputDefined() {
            return this.result.outputDefined()
          }
        }
        class fa {
          constructor(t, i) {
            this.type = i.type, this.name = t, this.boundExpression = i
          }
          static parse(t, i) {
            if (t.length !== 2 || typeof t[1] != "string") return i.error("'var' expression requires exactly one string literal argument.");
            const a = t[1];
            return i.scope.has(a) ? new fa(a, i.scope.get(a)) : i.error(`Unknown variable "${a}". Make sure "${a}" has been bound in an enclosing "let" expression before using it.`, 1)
          }
          evaluate(t) {
            return this.boundExpression.evaluate(t)
          }
          eachChild() {}
          outputDefined() {
            return !1
          }
        }
        class pn {
          constructor(t, i, a) {
            this.type = t, this.index = i, this.input = a
          }
          static parse(t, i) {
            if (t.length !== 3) return i.error(`Expected 2 arguments, but found ${t.length-1} instead.`);
            const a = i.parse(t[1], 1, gt),
              u = i.parse(t[2], 2, Rt(i.expectedType || _r));
            return a && u ? new pn(u.type.itemType, a, u) : null
          }
          evaluate(t) {
            const i = this.index.evaluate(t),
              a = this.input.evaluate(t);
            if (i < 0) throw new Ni(`Array index out of bounds: ${i} < 0.`);
            if (i >= a.length) throw new Ni(`Array index out of bounds: ${i} > ${a.length-1}.`);
            if (i !== Math.floor(i)) throw new Ni(`Array index must be an integer, but found ${i} instead.`);
            return a[i]
          }
          eachChild(t) {
            t(this.index), t(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        class Ms {
          constructor(t, i) {
            this.type = xr, this.needle = t, this.haystack = i
          }
          static parse(t, i) {
            if (t.length !== 3) return i.error(`Expected 2 arguments, but found ${t.length-1} instead.`);
            const a = i.parse(t[1], 1, _r),
              u = i.parse(t[2], 2, _r);
            return a && u ? Ei(a.type, [xr, hr, gt, Xr, _r]) ? new Ms(a, u) : i.error(`Expected first argument to be of type boolean, string, number or null, but found ${Zt(a.type)} instead`) : null
          }
          evaluate(t) {
            const i = this.needle.evaluate(t),
              a = this.haystack.evaluate(t);
            if (!a) return !1;
            if (!si(i, ["boolean", "string", "number", "null"])) throw new Ni(`Expected first argument to be of type boolean, string, number or null, but found ${Zt(Nr(i))} instead.`);
            if (!si(a, ["string", "array"])) throw new Ni(`Expected second argument to be of type array or string, but found ${Zt(Nr(a))} instead.`);
            return a.indexOf(i) >= 0
          }
          eachChild(t) {
            t(this.needle), t(this.haystack)
          }
          outputDefined() {
            return !0
          }
        }
        class po {
          constructor(t, i, a) {
            this.type = gt, this.needle = t, this.haystack = i, this.fromIndex = a
          }
          static parse(t, i) {
            if (t.length <= 2 || t.length >= 5) return i.error(`Expected 3 or 4 arguments, but found ${t.length-1} instead.`);
            const a = i.parse(t[1], 1, _r),
              u = i.parse(t[2], 2, _r);
            if (!a || !u) return null;
            if (!Ei(a.type, [xr, hr, gt, Xr, _r])) return i.error(`Expected first argument to be of type boolean, string, number or null, but found ${Zt(a.type)} instead`);
            if (t.length === 4) {
              const p = i.parse(t[3], 3, gt);
              return p ? new po(a, u, p) : null
            }
            return new po(a, u)
          }
          evaluate(t) {
            const i = this.needle.evaluate(t),
              a = this.haystack.evaluate(t);
            if (!si(i, ["boolean", "string", "number", "null"])) throw new Ni(`Expected first argument to be of type boolean, string, number or null, but found ${Zt(Nr(i))} instead.`);
            let u;
            if (this.fromIndex && (u = this.fromIndex.evaluate(t)), si(a, ["string"])) {
              const p = a.indexOf(i, u);
              return p === -1 ? -1 : [...a.slice(0, p)].length
            }
            if (si(a, ["array"])) return a.indexOf(i, u);
            throw new Ni(`Expected second argument to be of type array or string, but found ${Zt(Nr(a))} instead.`)
          }
          eachChild(t) {
            t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex)
          }
          outputDefined() {
            return !1
          }
        }
        class As {
          constructor(t, i, a, u, p, f) {
            this.inputType = t, this.type = i, this.input = a, this.cases = u, this.outputs = p, this.otherwise = f
          }
          static parse(t, i) {
            if (t.length < 5) return i.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
            if (t.length % 2 != 1) return i.error("Expected an even number of arguments.");
            let a, u;
            i.expectedType && i.expectedType.kind !== "value" && (u = i.expectedType);
            const p = {},
              f = [];
            for (let S = 2; S < t.length - 1; S += 2) {
              let I = t[S];
              const k = t[S + 1];
              Array.isArray(I) || (I = [I]);
              const R = i.concat(S);
              if (I.length === 0) return R.error("Expected at least one branch label.");
              for (const q of I) {
                if (typeof q != "number" && typeof q != "string") return R.error("Branch labels must be numbers or strings.");
                if (typeof q == "number" && Math.abs(q) > Number.MAX_SAFE_INTEGER) return R.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof q == "number" && Math.floor(q) !== q) return R.error("Numeric branch labels must be integer values.");
                if (a) {
                  if (R.checkSubtype(a, Nr(q))) return null
                } else a = Nr(q);
                if (p[String(q)] !== void 0) return R.error("Branch labels must be unique.");
                p[String(q)] = f.length
              }
              const N = i.parse(k, S, u);
              if (!N) return null;
              u = u || N.type, f.push(N)
            }
            const g = i.parse(t[1], 1, _r);
            if (!g) return null;
            const x = i.parse(t[t.length - 1], t.length - 1, u);
            return x ? g.type.kind !== "value" && i.concat(1).checkSubtype(a, g.type) ? null : new As(a, u, g, p, f, x) : null
          }
          evaluate(t) {
            const i = this.input.evaluate(t);
            return (Nr(i) === this.inputType && this.outputs[this.cases[i]] || this.otherwise).evaluate(t)
          }
          eachChild(t) {
            t(this.input), this.outputs.forEach(t), t(this.otherwise)
          }
          outputDefined() {
            return this.outputs.every((t => t.outputDefined())) && this.otherwise.outputDefined()
          }
        }
        class tn {
          constructor(t, i, a) {
            this.type = t, this.branches = i, this.otherwise = a
          }
          static parse(t, i) {
            if (t.length < 4) return i.error(`Expected at least 3 arguments, but found only ${t.length-1}.`);
            if (t.length % 2 != 0) return i.error("Expected an odd number of arguments.");
            let a;
            i.expectedType && i.expectedType.kind !== "value" && (a = i.expectedType);
            const u = [];
            for (let f = 1; f < t.length - 1; f += 2) {
              const g = i.parse(t[f], f, xr);
              if (!g) return null;
              const x = i.parse(t[f + 1], f + 1, a);
              if (!x) return null;
              u.push([g, x]), a = a || x.type
            }
            const p = i.parse(t[t.length - 1], t.length - 1, a);
            if (!p) return null;
            if (!a) throw new Error("Can't infer output type");
            return new tn(a, u, p)
          }
          evaluate(t) {
            for (const [i, a] of this.branches)
              if (i.evaluate(t)) return a.evaluate(t);
            return this.otherwise.evaluate(t)
          }
          eachChild(t) {
            for (const [i, a] of this.branches) t(i), t(a);
            t(this.otherwise)
          }
          outputDefined() {
            return this.branches.every((([t, i]) => i.outputDefined())) && this.otherwise.outputDefined()
          }
        }
        class fo {
          constructor(t, i, a, u) {
            this.type = t, this.input = i, this.beginIndex = a, this.endIndex = u
          }
          static parse(t, i) {
            if (t.length <= 2 || t.length >= 5) return i.error(`Expected 3 or 4 arguments, but found ${t.length-1} instead.`);
            const a = i.parse(t[1], 1, _r),
              u = i.parse(t[2], 2, gt);
            if (!a || !u) return null;
            if (!Ei(a.type, [Rt(_r), hr, _r])) return i.error(`Expected first argument to be of type array or string, but found ${Zt(a.type)} instead`);
            if (t.length === 4) {
              const p = i.parse(t[3], 3, gt);
              return p ? new fo(a.type, a, u, p) : null
            }
            return new fo(a.type, a, u)
          }
          evaluate(t) {
            const i = this.input.evaluate(t),
              a = this.beginIndex.evaluate(t);
            let u;
            if (this.endIndex && (u = this.endIndex.evaluate(t)), si(i, ["string"])) return [...i].slice(a, u).join("");
            if (si(i, ["array"])) return i.slice(a, u);
            throw new Ni(`Expected first argument to be of type array or string, but found ${Zt(Nr(i))} instead.`)
          }
          eachChild(t) {
            t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex)
          }
          outputDefined() {
            return !1
          }
        }

        function ks(n, t) {
          const i = n.length - 1;
          let a, u, p = 0,
            f = i,
            g = 0;
          for (; p <= f;)
            if (g = Math.floor((p + f) / 2), a = n[g], u = n[g + 1], a <= t) {
              if (g === i || t < u) return g;
              p = g + 1
            } else {
              if (!(a > t)) throw new Ni("Input is not a number.");
              f = g - 1
            } return 0
        }
        class Es {
          constructor(t, i, a) {
            this.type = t, this.input = i, this.labels = [], this.outputs = [];
            for (const [u, p] of a) this.labels.push(u), this.outputs.push(p)
          }
          static parse(t, i) {
            if (t.length - 1 < 4) return i.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
            if ((t.length - 1) % 2 != 0) return i.error("Expected an even number of arguments.");
            const a = i.parse(t[1], 1, gt);
            if (!a) return null;
            const u = [];
            let p = null;
            i.expectedType && i.expectedType.kind !== "value" && (p = i.expectedType);
            for (let f = 1; f < t.length; f += 2) {
              const g = f === 1 ? -1 / 0 : t[f],
                x = t[f + 1],
                S = f,
                I = f + 1;
              if (typeof g != "number") return i.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', S);
              if (u.length && u[u.length - 1][0] >= g) return i.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', S);
              const k = i.parse(x, I, p);
              if (!k) return null;
              p = p || k.type, u.push([g, k])
            }
            return new Es(p, a, u)
          }
          evaluate(t) {
            const i = this.labels,
              a = this.outputs;
            if (i.length === 1) return a[0].evaluate(t);
            const u = this.input.evaluate(t);
            if (u <= i[0]) return a[0].evaluate(t);
            const p = i.length;
            return u >= i[p - 1] ? a[p - 1].evaluate(t) : a[ks(i, u)].evaluate(t)
          }
          eachChild(t) {
            t(this.input);
            for (const i of this.outputs) t(i)
          }
          outputDefined() {
            return this.outputs.every((t => t.outputDefined()))
          }
        }

        function Wd(n) {
          return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
        }
        var Ga, mo, mc = (function() {
            if (mo) return Ga;

            function n(t, i, a, u) {
              this.cx = 3 * t, this.bx = 3 * (a - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * i, this.by = 3 * (u - i) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = i, this.p2x = a, this.p2y = u
            }
            return mo = 1, Ga = n, n.prototype = {
              sampleCurveX: function(t) {
                return ((this.ax * t + this.bx) * t + this.cx) * t
              },
              sampleCurveY: function(t) {
                return ((this.ay * t + this.by) * t + this.cy) * t
              },
              sampleCurveDerivativeX: function(t) {
                return (3 * this.ax * t + 2 * this.bx) * t + this.cx
              },
              solveCurveX: function(t, i) {
                if (i === void 0 && (i = 1e-6), t < 0) return 0;
                if (t > 1) return 1;
                for (var a = t, u = 0; u < 8; u++) {
                  var p = this.sampleCurveX(a) - t;
                  if (Math.abs(p) < i) return a;
                  var f = this.sampleCurveDerivativeX(a);
                  if (Math.abs(f) < 1e-6) break;
                  a -= p / f
                }
                var g = 0,
                  x = 1;
                for (a = t, u = 0; u < 20 && (p = this.sampleCurveX(a), !(Math.abs(p - t) < i)); u++) t > p ? g = a : x = a, a = .5 * (x - g) + g;
                return a
              },
              solve: function(t, i) {
                return this.sampleCurveY(this.solveCurveX(t, i))
              }
            }, Ga
          })(),
          Xd = Wd(mc);
        class Rn {
          constructor(t, i, a, u, p) {
            this.type = t, this.operator = i, this.interpolation = a, this.input = u, this.labels = [], this.outputs = [];
            for (const [f, g] of p) this.labels.push(f), this.outputs.push(g)
          }
          static interpolationFactor(t, i, a, u) {
            let p = 0;
            if (t.name === "exponential") p = zs(i, t.base, a, u);
            else if (t.name === "linear") p = zs(i, 1, a, u);
            else if (t.name === "cubic-bezier") {
              const f = t.controlPoints;
              p = new Xd(f[0], f[1], f[2], f[3]).solve(zs(i, 1, a, u))
            }
            return p
          }
          static parse(t, i) {
            let [a, u, p, ...f] = t;
            if (!Array.isArray(u) || u.length === 0) return i.error("Expected an interpolation type expression.", 1);
            if (u[0] === "linear") u = {
              name: "linear"
            };
            else if (u[0] === "exponential") {
              const S = u[1];
              if (typeof S != "number") return i.error("Exponential interpolation requires a numeric base.", 1, 1);
              u = {
                name: "exponential",
                base: S
              }
            } else {
              if (u[0] !== "cubic-bezier") return i.error(`Unknown interpolation type ${String(u[0])}`, 1, 0);
              {
                const S = u.slice(1);
                if (S.length !== 4 || S.some((I => typeof I != "number" || I < 0 || I > 1))) return i.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                u = {
                  name: "cubic-bezier",
                  controlPoints: S
                }
              }
            }
            if (t.length - 1 < 4) return i.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);
            if ((t.length - 1) % 2 != 0) return i.error("Expected an even number of arguments.");
            if (p = i.parse(p, 2, gt), !p) return null;
            const g = [];
            let x = null;
            a !== "interpolate-hcl" && a !== "interpolate-lab" || i.expectedType == fi ? i.expectedType && i.expectedType.kind !== "value" && (x = i.expectedType) : x = ai;
            for (let S = 0; S < f.length; S += 2) {
              const I = f[S],
                k = f[S + 1],
                R = S + 3,
                N = S + 4;
              if (typeof I != "number") return i.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', R);
              if (g.length && g[g.length - 1][0] >= I) return i.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', R);
              const q = i.parse(k, N, x);
              if (!q) return null;
              x = x || q.type, g.push([I, q])
            }
            return vr(x, gt) || vr(x, ki) || vr(x, ai) || vr(x, qr) || vr(x, nn) || vr(x, fi) || vr(x, bt) || vr(x, Rt(gt)) ? new Rn(x, a, u, p, g) : i.error(`Type ${Zt(x)} is not interpolatable.`)
          }
          evaluate(t) {
            const i = this.labels,
              a = this.outputs;
            if (i.length === 1) return a[0].evaluate(t);
            const u = this.input.evaluate(t);
            if (u <= i[0]) return a[0].evaluate(t);
            const p = i.length;
            if (u >= i[p - 1]) return a[p - 1].evaluate(t);
            const f = ks(i, u),
              g = Rn.interpolationFactor(this.interpolation, u, i[f], i[f + 1]),
              x = a[f].evaluate(t),
              S = a[f + 1].evaluate(t);
            switch (this.operator) {
              case "interpolate":
                switch (this.type.kind) {
                  case "number":
                    return Vn(x, S, g);
                  case "color":
                    return ni.interpolate(x, S, g);
                  case "padding":
                    return Oi.interpolate(x, S, g);
                  case "colorArray":
                    return dn.interpolate(x, S, g);
                  case "numberArray":
                    return hn.interpolate(x, S, g);
                  case "variableAnchorOffsetCollection":
                    return di.interpolate(x, S, g);
                  case "array":
                    return ea(x, S, g);
                  case "projectionDefinition":
                    return Hr.interpolate(x, S, g)
                }
              case "interpolate-hcl":
                switch (this.type.kind) {
                  case "color":
                    return ni.interpolate(x, S, g, "hcl");
                  case "colorArray":
                    return dn.interpolate(x, S, g, "hcl")
                }
              case "interpolate-lab":
                switch (this.type.kind) {
                  case "color":
                    return ni.interpolate(x, S, g, "lab");
                  case "colorArray":
                    return dn.interpolate(x, S, g, "lab")
                }
            }
          }
          eachChild(t) {
            t(this.input);
            for (const i of this.outputs) t(i)
          }
          outputDefined() {
            return this.outputs.every((t => t.outputDefined()))
          }
        }

        function zs(n, t, i, a) {
          const u = a - i,
            p = n - i;
          return u === 0 ? 0 : t === 1 ? p / u : (Math.pow(t, p) - 1) / (Math.pow(t, u) - 1)
        }
        const ta = {
          color: ni.interpolate,
          number: Vn,
          padding: Oi.interpolate,
          numberArray: hn.interpolate,
          colorArray: dn.interpolate,
          variableAnchorOffsetCollection: di.interpolate,
          array: ea
        };
        class Un {
          constructor(t, i) {
            this.type = t, this.args = i
          }
          static parse(t, i) {
            if (t.length < 2) return i.error("Expected at least one argument.");
            let a = null;
            const u = i.expectedType;
            u && u.kind !== "value" && (a = u);
            const p = [];
            for (const g of t.slice(1)) {
              const x = i.parse(g, 1 + p.length, a, void 0, {
                typeAnnotation: "omit"
              });
              if (!x) return null;
              a = a || x.type, p.push(x)
            }
            if (!a) throw new Error("No output type");
            const f = u && p.some((g => gi(u, g.type)));
            return new Un(f ? _r : a, p)
          }
          evaluate(t) {
            let i, a = null,
              u = 0;
            for (const p of this.args)
              if (u++, a = p.evaluate(t), a && a instanceof Zn && !a.available && (i || (i = a.name), a = null, u === this.args.length && (a = i)), a !== null) break;
            return a
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return this.args.every((t => t.outputDefined()))
          }
        }

        function _c(n, t) {
          return n === "==" || n === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value"
        }

        function _o(n, t, i, a) {
          return a.compare(t, i) === 0
        }

        function Ls(n, t, i) {
          const a = n !== "==" && n !== "!=";
          return class pv {
            constructor(p, f, g) {
              this.type = xr, this.lhs = p, this.rhs = f, this.collator = g, this.hasUntypedArgument = p.type.kind === "value" || f.type.kind === "value"
            }
            static parse(p, f) {
              if (p.length !== 3 && p.length !== 4) return f.error("Expected two or three arguments.");
              const g = p[0];
              let x = f.parse(p[1], 1, _r);
              if (!x) return null;
              if (!_c(g, x.type)) return f.concat(1).error(`"${g}" comparisons are not supported for type '${Zt(x.type)}'.`);
              let S = f.parse(p[2], 2, _r);
              if (!S) return null;
              if (!_c(g, S.type)) return f.concat(2).error(`"${g}" comparisons are not supported for type '${Zt(S.type)}'.`);
              if (x.type.kind !== S.type.kind && x.type.kind !== "value" && S.type.kind !== "value") return f.error(`Cannot compare types '${Zt(x.type)}' and '${Zt(S.type)}'.`);
              a && (x.type.kind === "value" && S.type.kind !== "value" ? x = new $n(S.type, [x]) : x.type.kind !== "value" && S.type.kind === "value" && (S = new $n(x.type, [S])));
              let I = null;
              if (p.length === 4) {
                if (x.type.kind !== "string" && S.type.kind !== "string" && x.type.kind !== "value" && S.type.kind !== "value") return f.error("Cannot use collator to compare non-string types.");
                if (I = f.parse(p[3], 3, Ti), !I) return null
              }
              return new pv(x, S, I)
            }
            evaluate(p) {
              const f = this.lhs.evaluate(p),
                g = this.rhs.evaluate(p);
              if (a && this.hasUntypedArgument) {
                const x = Nr(f),
                  S = Nr(g);
                if (x.kind !== S.kind || x.kind !== "string" && x.kind !== "number") throw new Ni(`Expected arguments for "${n}" to be (string, string) or (number, number), but found (${x.kind}, ${S.kind}) instead.`)
              }
              if (this.collator && !a && this.hasUntypedArgument) {
                const x = Nr(f),
                  S = Nr(g);
                if (x.kind !== "string" || S.kind !== "string") return t(p, f, g)
              }
              return this.collator ? i(p, f, g, this.collator.evaluate(p)) : t(p, f, g)
            }
            eachChild(p) {
              p(this.lhs), p(this.rhs), this.collator && p(this.collator)
            }
            outputDefined() {
              return !0
            }
          }
        }
        const gc = Ls("==", (function(n, t, i) {
            return t === i
          }), _o),
          Kd = Ls("!=", (function(n, t, i) {
            return t !== i
          }), (function(n, t, i, a) {
            return !_o(0, t, i, a)
          })),
          Yd = Ls("<", (function(n, t, i) {
            return t < i
          }), (function(n, t, i, a) {
            return a.compare(t, i) < 0
          })),
          Jd = Ls(">", (function(n, t, i) {
            return t > i
          }), (function(n, t, i, a) {
            return a.compare(t, i) > 0
          })),
          Qd = Ls("<=", (function(n, t, i) {
            return t <= i
          }), (function(n, t, i, a) {
            return a.compare(t, i) <= 0
          })),
          il = Ls(">=", (function(n, t, i) {
            return t >= i
          }), (function(n, t, i, a) {
            return a.compare(t, i) >= 0
          }));
        class nl {
          constructor(t, i, a) {
            this.type = Ti, this.locale = a, this.caseSensitive = t, this.diacriticSensitive = i
          }
          static parse(t, i) {
            if (t.length !== 2) return i.error("Expected one argument.");
            const a = t[1];
            if (typeof a != "object" || Array.isArray(a)) return i.error("Collator options argument must be an object.");
            const u = i.parse(a["case-sensitive"] !== void 0 && a["case-sensitive"], 1, xr);
            if (!u) return null;
            const p = i.parse(a["diacritic-sensitive"] !== void 0 && a["diacritic-sensitive"], 1, xr);
            if (!p) return null;
            let f = null;
            return a.locale && (f = i.parse(a.locale, 1, hr), !f) ? null : new nl(u, p, f)
          }
          evaluate(t) {
            return new Ua(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null)
          }
          eachChild(t) {
            t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale)
          }
          outputDefined() {
            return !1
          }
        }
        class al {
          constructor(t, i, a, u, p) {
            this.type = hr, this.number = t, this.locale = i, this.currency = a, this.minFractionDigits = u, this.maxFractionDigits = p
          }
          static parse(t, i) {
            if (t.length !== 3) return i.error("Expected two arguments.");
            const a = i.parse(t[1], 1, gt);
            if (!a) return null;
            const u = t[2];
            if (typeof u != "object" || Array.isArray(u)) return i.error("NumberFormat options argument must be an object.");
            let p = null;
            if (u.locale && (p = i.parse(u.locale, 1, hr), !p)) return null;
            let f = null;
            if (u.currency && (f = i.parse(u.currency, 1, hr), !f)) return null;
            let g = null;
            if (u["min-fraction-digits"] && (g = i.parse(u["min-fraction-digits"], 1, gt), !g)) return null;
            let x = null;
            return u["max-fraction-digits"] && (x = i.parse(u["max-fraction-digits"], 1, gt), !x) ? null : new al(a, p, f, g, x)
          }
          evaluate(t) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], {
              style: this.currency ? "currency" : "decimal",
              currency: this.currency ? this.currency.evaluate(t) : void 0,
              minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,
              maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0
            }).format(this.number.evaluate(t))
          }
          eachChild(t) {
            t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits)
          }
          outputDefined() {
            return !1
          }
        }
        class go {
          constructor(t) {
            this.type = Ar, this.sections = t
          }
          static parse(t, i) {
            if (t.length < 2) return i.error("Expected at least one argument.");
            const a = t[1];
            if (!Array.isArray(a) && typeof a == "object") return i.error("First argument must be an image or text section.");
            const u = [];
            let p = !1;
            for (let f = 1; f <= t.length - 1; ++f) {
              const g = t[f];
              if (p && typeof g == "object" && !Array.isArray(g)) {
                p = !1;
                let x = null;
                if (g["font-scale"] && (x = i.parse(g["font-scale"], 1, gt), !x)) return null;
                let S = null;
                if (g["text-font"] && (S = i.parse(g["text-font"], 1, Rt(hr)), !S)) return null;
                let I = null;
                if (g["text-color"] && (I = i.parse(g["text-color"], 1, ai), !I)) return null;
                let k = null;
                if (g["vertical-align"]) {
                  if (typeof g["vertical-align"] == "string" && !La.includes(g["vertical-align"])) return i.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${g["vertical-align"]}' instead.`);
                  if (k = i.parse(g["vertical-align"], 1, hr), !k) return null
                }
                const R = u[u.length - 1];
                R.scale = x, R.font = S, R.textColor = I, R.verticalAlign = k
              } else {
                const x = i.parse(t[f], 1, _r);
                if (!x) return null;
                const S = x.type.kind;
                if (S !== "string" && S !== "value" && S !== "null" && S !== "resolvedImage") return i.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                p = !0, u.push({
                  content: x,
                  scale: null,
                  font: null,
                  textColor: null,
                  verticalAlign: null
                })
              }
            }
            return new go(u)
          }
          evaluate(t) {
            return new Yi(this.sections.map((i => {
              const a = i.content.evaluate(t);
              return Nr(a) === un ? new co("", a, null, null, null, i.verticalAlign ? i.verticalAlign.evaluate(t) : null) : new co(cs(a), null, i.scale ? i.scale.evaluate(t) : null, i.font ? i.font.evaluate(t).join(",") : null, i.textColor ? i.textColor.evaluate(t) : null, i.verticalAlign ? i.verticalAlign.evaluate(t) : null)
            })))
          }
          eachChild(t) {
            for (const i of this.sections) t(i.content), i.scale && t(i.scale), i.font && t(i.font), i.textColor && t(i.textColor), i.verticalAlign && t(i.verticalAlign)
          }
          outputDefined() {
            return !1
          }
        }
        class vc {
          constructor(t) {
            this.type = un, this.input = t
          }
          static parse(t, i) {
            if (t.length !== 2) return i.error("Expected two arguments.");
            const a = i.parse(t[1], 1, hr);
            return a ? new vc(a) : i.error("No image name provided.")
          }
          evaluate(t) {
            const i = this.input.evaluate(t),
              a = Zn.fromString(i);
            return a && t.availableImages && (a.available = t.availableImages.indexOf(i) > -1), a
          }
          eachChild(t) {
            t(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        class sl {
          constructor(t) {
            this.type = gt, this.input = t
          }
          static parse(t, i) {
            if (t.length !== 2) return i.error(`Expected 1 argument, but found ${t.length-1} instead.`);
            const a = i.parse(t[1], 1);
            return a ? a.type.kind !== "array" && a.type.kind !== "string" && a.type.kind !== "value" ? i.error(`Expected argument of type string or array, but found ${Zt(a.type)} instead.`) : new sl(a) : null
          }
          evaluate(t) {
            const i = this.input.evaluate(t);
            if (typeof i == "string") return [...i].length;
            if (Array.isArray(i)) return i.length;
            throw new Ni(`Expected value to be of type string or array, but found ${Zt(Nr(i))} instead.`)
          }
          eachChild(t) {
            t(this.input)
          }
          outputDefined() {
            return !1
          }
        }
        const Sa = 8192;

        function ep(n, t) {
          const i = (180 + n[0]) / 360,
            a = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + n[1] * Math.PI / 360))) / 360,
            u = Math.pow(2, t.z);
          return [Math.round(i * u * Sa), Math.round(a * u * Sa)]
        }

        function yc(n, t) {
          const i = Math.pow(2, t.z);
          return [(u = (n[0] / Sa + t.x) / i, 360 * u - 180), (a = (n[1] / Sa + t.y) / i, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * a) * Math.PI / 180)) - 90)];
          var a, u
        }

        function vo(n, t) {
          n[0] = Math.min(n[0], t[0]), n[1] = Math.min(n[1], t[1]), n[2] = Math.max(n[2], t[0]), n[3] = Math.max(n[3], t[1])
        }

        function yo(n, t) {
          return !(n[0] <= t[0] || n[2] >= t[2] || n[1] <= t[1] || n[3] >= t[3])
        }

        function yh(n, t, i) {
          const a = n[0] - t[0],
            u = n[1] - t[1],
            p = n[0] - i[0],
            f = n[1] - i[1];
          return a * f - p * u == 0 && a * p <= 0 && u * f <= 0
        }

        function xo(n, t, i, a) {
          return (u = [a[0] - i[0], a[1] - i[1]])[0] * (p = [t[0] - n[0], t[1] - n[1]])[1] - u[1] * p[0] != 0 && !(!ol(n, t, i, a) || !ol(i, a, n, t));
          var u, p
        }

        function xh(n, t, i) {
          for (const a of i)
            for (let u = 0; u < a.length - 1; ++u)
              if (xo(n, t, a[u], a[u + 1])) return !0;
          return !1
        }

        function Ds(n, t, i = !1) {
          let a = !1;
          for (const g of t)
            for (let x = 0; x < g.length - 1; x++) {
              if (yh(n, g[x], g[x + 1])) return i;
              (p = g[x])[1] > (u = n)[1] != (f = g[x + 1])[1] > u[1] && u[0] < (f[0] - p[0]) * (u[1] - p[1]) / (f[1] - p[1]) + p[0] && (a = !a)
            }
          var u, p, f;
          return a
        }

        function tp(n, t) {
          for (const i of t)
            if (Ds(n, i)) return !0;
          return !1
        }

        function bh(n, t) {
          for (const i of n)
            if (!Ds(i, t)) return !1;
          for (let i = 0; i < n.length - 1; ++i)
            if (xh(n[i], n[i + 1], t)) return !1;
          return !0
        }

        function rp(n, t) {
          for (const i of t)
            if (bh(n, i)) return !0;
          return !1
        }

        function ol(n, t, i, a) {
          const u = a[0] - i[0],
            p = a[1] - i[1],
            f = (n[0] - i[0]) * p - u * (n[1] - i[1]),
            g = (t[0] - i[0]) * p - u * (t[1] - i[1]);
          return f > 0 && g < 0 || f < 0 && g > 0
        }

        function xc(n, t, i) {
          const a = [];
          for (let u = 0; u < n.length; u++) {
            const p = [];
            for (let f = 0; f < n[u].length; f++) {
              const g = ep(n[u][f], i);
              vo(t, g), p.push(g)
            }
            a.push(p)
          }
          return a
        }

        function wh(n, t, i) {
          const a = [];
          for (let u = 0; u < n.length; u++) {
            const p = xc(n[u], t, i);
            a.push(p)
          }
          return a
        }

        function Th(n, t, i, a) {
          if (n[0] < i[0] || n[0] > i[2]) {
            const u = .5 * a;
            let p = n[0] - i[0] > u ? -a : i[0] - n[0] > u ? a : 0;
            p === 0 && (p = n[0] - i[2] > u ? -a : i[2] - n[0] > u ? a : 0), n[0] += p
          }
          vo(t, n)
        }

        function bc(n, t, i, a) {
          const u = Math.pow(2, a.z) * Sa,
            p = [a.x * Sa, a.y * Sa],
            f = [];
          for (const g of n)
            for (const x of g) {
              const S = [x.x + p[0], x.y + p[1]];
              Th(S, t, i, u), f.push(S)
            }
          return f
        }

        function wc(n, t, i, a) {
          const u = Math.pow(2, a.z) * Sa,
            p = [a.x * Sa, a.y * Sa],
            f = [];
          for (const x of n) {
            const S = [];
            for (const I of x) {
              const k = [I.x + p[0], I.y + p[1]];
              vo(t, k), S.push(k)
            }
            f.push(S)
          }
          if (t[2] - t[0] <= u / 2) {
            (g = t)[0] = g[1] = 1 / 0, g[2] = g[3] = -1 / 0;
            for (const x of f)
              for (const S of x) Th(S, t, i, u)
          }
          var g;
          return f
        }
        class us {
          constructor(t, i) {
            this.type = xr, this.geojson = t, this.geometries = i
          }
          static parse(t, i) {
            if (t.length !== 2) return i.error(`'within' expression requires exactly one argument, but found ${t.length-1} instead.`);
            if (ls(t[1])) {
              const a = t[1];
              if (a.type === "FeatureCollection") {
                const u = [];
                for (const p of a.features) {
                  const {
                    type: f,
                    coordinates: g
                  } = p.geometry;
                  f === "Polygon" && u.push(g), f === "MultiPolygon" && u.push(...g)
                }
                if (u.length) return new us(a, {
                  type: "MultiPolygon",
                  coordinates: u
                })
              } else if (a.type === "Feature") {
                const u = a.geometry.type;
                if (u === "Polygon" || u === "MultiPolygon") return new us(a, a.geometry)
              } else if (a.type === "Polygon" || a.type === "MultiPolygon") return new us(a, a)
            }
            return i.error("'within' expression requires valid geojson object that contains polygon geometry type.")
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(i, a) {
                const u = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  p = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  f = i.canonicalID();
                if (a.type === "Polygon") {
                  const g = xc(a.coordinates, p, f),
                    x = bc(i.geometry(), u, p, f);
                  if (!yo(u, p)) return !1;
                  for (const S of x)
                    if (!Ds(S, g)) return !1
                }
                if (a.type === "MultiPolygon") {
                  const g = wh(a.coordinates, p, f),
                    x = bc(i.geometry(), u, p, f);
                  if (!yo(u, p)) return !1;
                  for (const S of x)
                    if (!tp(S, g)) return !1
                }
                return !0
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(i, a) {
                const u = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  p = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  f = i.canonicalID();
                if (a.type === "Polygon") {
                  const g = xc(a.coordinates, p, f),
                    x = wc(i.geometry(), u, p, f);
                  if (!yo(u, p)) return !1;
                  for (const S of x)
                    if (!bh(S, g)) return !1
                }
                if (a.type === "MultiPolygon") {
                  const g = wh(a.coordinates, p, f),
                    x = wc(i.geometry(), u, p, f);
                  if (!yo(u, p)) return !1;
                  for (const S of x)
                    if (!rp(S, g)) return !1
                }
                return !0
              })(t, this.geometries)
            }
            return !1
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        let Ch = class {
          constructor(n = [], t = (i, a) => i < a ? -1 : i > a ? 1 : 0) {
            if (this.data = n, this.length = this.data.length, this.compare = t, this.length > 0)
              for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i)
          }
          push(n) {
            this.data.push(n), this._up(this.length++)
          }
          pop() {
            if (this.length === 0) return;
            const n = this.data[0],
              t = this.data.pop();
            return --this.length > 0 && (this.data[0] = t, this._down(0)), n
          }
          peek() {
            return this.data[0]
          }
          _up(n) {
            const {
              data: t,
              compare: i
            } = this, a = t[n];
            for (; n > 0;) {
              const u = n - 1 >> 1,
                p = t[u];
              if (i(a, p) >= 0) break;
              t[n] = p, n = u
            }
            t[n] = a
          }
          _down(n) {
            const {
              data: t,
              compare: i
            } = this, a = this.length >> 1, u = t[n];
            for (; n < a;) {
              let p = 1 + (n << 1);
              const f = p + 1;
              if (f < this.length && i(t[f], t[p]) < 0 && (p = f), i(t[p], u) >= 0) break;
              t[n] = t[p], n = p
            }
            t[n] = u
          }
        };

        function Tc(n, t, i = 0, a = n.length - 1, u = ip) {
          for (; a > i;) {
            if (a - i > 600) {
              const x = a - i + 1,
                S = t - i + 1,
                I = Math.log(x),
                k = .5 * Math.exp(2 * I / 3),
                R = .5 * Math.sqrt(I * k * (x - k) / x) * (S - x / 2 < 0 ? -1 : 1);
              Tc(n, t, Math.max(i, Math.floor(t - S * k / x + R)), Math.min(a, Math.floor(t + (x - S) * k / x + R)), u)
            }
            const p = n[t];
            let f = i,
              g = a;
            for (Rs(n, i, t), u(n[a], p) > 0 && Rs(n, i, a); f < g;) {
              for (Rs(n, f, g), f++, g--; u(n[f], p) < 0;) f++;
              for (; u(n[g], p) > 0;) g--
            }
            u(n[i], p) === 0 ? Rs(n, i, g) : (g++, Rs(n, g, a)), g <= t && (i = g + 1), t <= g && (a = g - 1)
          }
        }

        function Rs(n, t, i) {
          const a = n[t];
          n[t] = n[i], n[i] = a
        }

        function ip(n, t) {
          return n < t ? -1 : n > t ? 1 : 0
        }

        function ll(n, t) {
          if (n.length <= 1) return [n];
          const i = [];
          let a, u;
          for (const p of n) {
            const f = Sh(p);
            f !== 0 && (p.area = Math.abs(f), u === void 0 && (u = f < 0), u === f < 0 ? (a && i.push(a), a = [p]) : a.push(p))
          }
          if (a && i.push(a), t > 1)
            for (let p = 0; p < i.length; p++) i[p].length <= t || (Tc(i[p], t, 1, i[p].length - 1, np), i[p] = i[p].slice(0, t));
          return i
        }

        function np(n, t) {
          return t.area - n.area
        }

        function Sh(n) {
          let t = 0;
          for (let i, a, u = 0, p = n.length, f = p - 1; u < p; f = u++) i = n[u], a = n[f], t += (a.x - i.x) * (i.y + a.y);
          return t
        }
        const Ph = 1 / 298.257223563,
          Ih = Ph * (2 - Ph),
          Mh = Math.PI / 180;
        class Cc {
          constructor(t) {
            const i = 6378.137 * Mh * 1e3,
              a = Math.cos(t * Mh),
              u = 1 / (1 - Ih * (1 - a * a)),
              p = Math.sqrt(u);
            this.kx = i * p * a, this.ky = i * p * u * (1 - Ih)
          }
          distance(t, i) {
            const a = this.wrap(t[0] - i[0]) * this.kx,
              u = (t[1] - i[1]) * this.ky;
            return Math.sqrt(a * a + u * u)
          }
          pointOnLine(t, i) {
            let a, u, p, f, g = 1 / 0;
            for (let x = 0; x < t.length - 1; x++) {
              let S = t[x][0],
                I = t[x][1],
                k = this.wrap(t[x + 1][0] - S) * this.kx,
                R = (t[x + 1][1] - I) * this.ky,
                N = 0;
              k === 0 && R === 0 || (N = (this.wrap(i[0] - S) * this.kx * k + (i[1] - I) * this.ky * R) / (k * k + R * R), N > 1 ? (S = t[x + 1][0], I = t[x + 1][1]) : N > 0 && (S += k / this.kx * N, I += R / this.ky * N)), k = this.wrap(i[0] - S) * this.kx, R = (i[1] - I) * this.ky;
              const q = k * k + R * R;
              q < g && (g = q, a = S, u = I, p = x, f = N)
            }
            return {
              point: [a, u],
              index: p,
              t: Math.max(0, Math.min(1, f))
            }
          }
          wrap(t) {
            for (; t < -180;) t += 360;
            for (; t > 180;) t -= 360;
            return t
          }
        }

        function yi(n, t) {
          return t[0] - n[0]
        }

        function cl(n) {
          return n[1] - n[0] + 1
        }

        function Da(n, t) {
          return n[1] >= n[0] && n[1] < t
        }

        function Sc(n, t) {
          if (n[0] > n[1]) return [null, null];
          const i = cl(n);
          if (t) {
            if (i === 2) return [n, null];
            const u = Math.floor(i / 2);
            return [
              [n[0], n[0] + u],
              [n[0] + u, n[1]]
            ]
          }
          if (i === 1) return [n, null];
          const a = Math.floor(i / 2) - 1;
          return [
            [n[0], n[0] + a],
            [n[0] + a + 1, n[1]]
          ]
        }

        function Pc(n, t) {
          if (!Da(t, n.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          const i = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let a = t[0]; a <= t[1]; ++a) vo(i, n[a]);
          return i
        }

        function Ic(n) {
          const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (const i of n)
            for (const a of i) vo(t, a);
          return t
        }

        function Ah(n) {
          return n[0] !== -1 / 0 && n[1] !== -1 / 0 && n[2] !== 1 / 0 && n[3] !== 1 / 0
        }

        function Mc(n, t, i) {
          if (!Ah(n) || !Ah(t)) return NaN;
          let a = 0,
            u = 0;
          return n[2] < t[0] && (a = t[0] - n[2]), n[0] > t[2] && (a = n[0] - t[2]), n[1] > t[3] && (u = n[1] - t[3]), n[3] < t[1] && (u = t[1] - n[3]), i.distance([0, 0], [a, u])
        }

        function hs(n, t, i) {
          const a = i.pointOnLine(t, n);
          return i.distance(n, a.point)
        }

        function Ac(n, t, i, a, u) {
          const p = Math.min(hs(n, [i, a], u), hs(t, [i, a], u)),
            f = Math.min(hs(i, [n, t], u), hs(a, [n, t], u));
          return Math.min(p, f)
        }

        function ap(n, t, i, a, u) {
          if (!Da(t, n.length) || !Da(a, i.length)) return 1 / 0;
          let p = 1 / 0;
          for (let f = t[0]; f < t[1]; ++f) {
            const g = n[f],
              x = n[f + 1];
            for (let S = a[0]; S < a[1]; ++S) {
              const I = i[S],
                k = i[S + 1];
              if (xo(g, x, I, k)) return 0;
              p = Math.min(p, Ac(g, x, I, k, u))
            }
          }
          return p
        }

        function sp(n, t, i, a, u) {
          if (!Da(t, n.length) || !Da(a, i.length)) return NaN;
          let p = 1 / 0;
          for (let f = t[0]; f <= t[1]; ++f)
            for (let g = a[0]; g <= a[1]; ++g)
              if (p = Math.min(p, u.distance(n[f], i[g])), p === 0) return p;
          return p
        }

        function op(n, t, i) {
          if (Ds(n, t, !0)) return 0;
          let a = 1 / 0;
          for (const u of t) {
            const p = u[0],
              f = u[u.length - 1];
            if (p !== f && (a = Math.min(a, hs(n, [f, p], i)), a === 0)) return a;
            const g = i.pointOnLine(u, n);
            if (a = Math.min(a, i.distance(n, g.point)), a === 0) return a
          }
          return a
        }

        function lp(n, t, i, a) {
          if (!Da(t, n.length)) return NaN;
          for (let p = t[0]; p <= t[1]; ++p)
            if (Ds(n[p], i, !0)) return 0;
          let u = 1 / 0;
          for (let p = t[0]; p < t[1]; ++p) {
            const f = n[p],
              g = n[p + 1];
            for (const x of i)
              for (let S = 0, I = x.length, k = I - 1; S < I; k = S++) {
                const R = x[k],
                  N = x[S];
                if (xo(f, g, R, N)) return 0;
                u = Math.min(u, Ac(f, g, R, N, a))
              }
          }
          return u
        }

        function kh(n, t) {
          for (const i of n)
            for (const a of i)
              if (Ds(a, t, !0)) return !0;
          return !1
        }

        function cp(n, t, i, a = 1 / 0) {
          const u = Ic(n),
            p = Ic(t);
          if (a !== 1 / 0 && Mc(u, p, i) >= a) return a;
          if (yo(u, p)) {
            if (kh(n, t)) return 0
          } else if (kh(t, n)) return 0;
          let f = 1 / 0;
          for (const g of n)
            for (let x = 0, S = g.length, I = S - 1; x < S; I = x++) {
              const k = g[I],
                R = g[x];
              for (const N of t)
                for (let q = 0, U = N.length, J = U - 1; q < U; J = q++) {
                  const ae = N[J],
                    ke = N[q];
                  if (xo(k, R, ae, ke)) return 0;
                  f = Math.min(f, Ac(k, R, ae, ke, i))
                }
            }
          return f
        }

        function Eh(n, t, i, a, u, p) {
          if (!p) return;
          const f = Mc(Pc(a, p), u, i);
          f < t && n.push([f, p, [0, 0]])
        }

        function ul(n, t, i, a, u, p, f) {
          if (!p || !f) return;
          const g = Mc(Pc(a, p), Pc(u, f), i);
          g < t && n.push([g, p, f])
        }

        function hl(n, t, i, a, u = 1 / 0) {
          let p = Math.min(a.distance(n[0], i[0][0]), u);
          if (p === 0) return p;
          const f = new Ch([
              [0, [0, n.length - 1],
                [0, 0]
              ]
            ], yi),
            g = Ic(i);
          for (; f.length > 0;) {
            const x = f.pop();
            if (x[0] >= p) continue;
            const S = x[1],
              I = t ? 50 : 100;
            if (cl(S) <= I) {
              if (!Da(S, n.length)) return NaN;
              if (t) {
                const k = lp(n, S, i, a);
                if (isNaN(k) || k === 0) return k;
                p = Math.min(p, k)
              } else
                for (let k = S[0]; k <= S[1]; ++k) {
                  const R = op(n[k], i, a);
                  if (p = Math.min(p, R), p === 0) return 0
                }
            } else {
              const k = Sc(S, t);
              Eh(f, p, a, n, g, k[0]), Eh(f, p, a, n, g, k[1])
            }
          }
          return p
        }

        function dl(n, t, i, a, u, p = 1 / 0) {
          let f = Math.min(p, u.distance(n[0], i[0]));
          if (f === 0) return f;
          const g = new Ch([
            [0, [0, n.length - 1],
              [0, i.length - 1]
            ]
          ], yi);
          for (; g.length > 0;) {
            const x = g.pop();
            if (x[0] >= f) continue;
            const S = x[1],
              I = x[2],
              k = t ? 50 : 100,
              R = a ? 50 : 100;
            if (cl(S) <= k && cl(I) <= R) {
              if (!Da(S, n.length) && Da(I, i.length)) return NaN;
              let N;
              if (t && a) N = ap(n, S, i, I, u), f = Math.min(f, N);
              else if (t && !a) {
                const q = n.slice(S[0], S[1] + 1);
                for (let U = I[0]; U <= I[1]; ++U)
                  if (N = hs(i[U], q, u), f = Math.min(f, N), f === 0) return f
              } else if (!t && a) {
                const q = i.slice(I[0], I[1] + 1);
                for (let U = S[0]; U <= S[1]; ++U)
                  if (N = hs(n[U], q, u), f = Math.min(f, N), f === 0) return f
              } else N = sp(n, S, i, I, u), f = Math.min(f, N)
            } else {
              const N = Sc(S, t),
                q = Sc(I, a);
              ul(g, f, u, n, i, N[0], q[0]), ul(g, f, u, n, i, N[0], q[1]), ul(g, f, u, n, i, N[1], q[0]), ul(g, f, u, n, i, N[1], q[1])
            }
          }
          return f
        }

        function kc(n) {
          return n.type === "MultiPolygon" ? n.coordinates.map((t => ({
            type: "Polygon",
            coordinates: t
          }))) : n.type === "MultiLineString" ? n.coordinates.map((t => ({
            type: "LineString",
            coordinates: t
          }))) : n.type === "MultiPoint" ? n.coordinates.map((t => ({
            type: "Point",
            coordinates: t
          }))) : [n]
        }
        class ds {
          constructor(t, i) {
            this.type = gt, this.geojson = t, this.geometries = i
          }
          static parse(t, i) {
            if (t.length !== 2) return i.error(`'distance' expression requires exactly one argument, but found ${t.length-1} instead.`);
            if (ls(t[1])) {
              const a = t[1];
              if (a.type === "FeatureCollection") return new ds(a, a.features.map((u => kc(u.geometry))).flat());
              if (a.type === "Feature") return new ds(a, kc(a.geometry));
              if ("type" in a && "coordinates" in a) return new ds(a, kc(a))
            }
            return i.error("'distance' expression requires valid geojson object that contains polygon geometry type.")
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(i, a) {
                const u = i.geometry(),
                  p = u.flat().map((x => yc([x.x, x.y], i.canonical)));
                if (u.length === 0) return NaN;
                const f = new Cc(p[0][1]);
                let g = 1 / 0;
                for (const x of a) {
                  switch (x.type) {
                    case "Point":
                      g = Math.min(g, dl(p, !1, [x.coordinates], !1, f, g));
                      break;
                    case "LineString":
                      g = Math.min(g, dl(p, !1, x.coordinates, !0, f, g));
                      break;
                    case "Polygon":
                      g = Math.min(g, hl(p, !1, x.coordinates, f, g))
                  }
                  if (g === 0) return g
                }
                return g
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(i, a) {
                const u = i.geometry(),
                  p = u.flat().map((x => yc([x.x, x.y], i.canonical)));
                if (u.length === 0) return NaN;
                const f = new Cc(p[0][1]);
                let g = 1 / 0;
                for (const x of a) {
                  switch (x.type) {
                    case "Point":
                      g = Math.min(g, dl(p, !0, [x.coordinates], !1, f, g));
                      break;
                    case "LineString":
                      g = Math.min(g, dl(p, !0, x.coordinates, !0, f, g));
                      break;
                    case "Polygon":
                      g = Math.min(g, hl(p, !0, x.coordinates, f, g))
                  }
                  if (g === 0) return g
                }
                return g
              })(t, this.geometries);
              if (t.geometryType() === "Polygon") return (function(i, a) {
                const u = i.geometry();
                if (u.length === 0 || u[0].length === 0) return NaN;
                const p = ll(u, 0).map((x => x.map((S => S.map((I => yc([I.x, I.y], i.canonical))))))),
                  f = new Cc(p[0][0][0][1]);
                let g = 1 / 0;
                for (const x of a)
                  for (const S of p) {
                    switch (x.type) {
                      case "Point":
                        g = Math.min(g, hl([x.coordinates], !1, S, f, g));
                        break;
                      case "LineString":
                        g = Math.min(g, hl(x.coordinates, !0, S, f, g));
                        break;
                      case "Polygon":
                        g = Math.min(g, cp(S, x.coordinates, f, g))
                    }
                    if (g === 0) return g
                  }
                return g
              })(t, this.geometries)
            }
            return NaN
          }
          eachChild() {}
          outputDefined() {
            return !0
          }
        }
        class bo {
          constructor(t) {
            this.type = _r, this.key = t
          }
          static parse(t, i) {
            if (t.length !== 2) return i.error(`Expected 1 argument, but found ${t.length-1} instead.`);
            const a = t[1];
            return a == null ? i.error("Global state property must be defined.") : typeof a != "string" ? i.error(`Global state property must be string, but found ${typeof t[1]} instead.`) : new bo(a)
          }
          evaluate(t) {
            var i;
            const a = (i = t.globals) === null || i === void 0 ? void 0 : i.globalState;
            return a && Object.keys(a).length !== 0 ? Jr(a, this.key) : null
          }
          eachChild() {}
          outputDefined() {
            return !1
          }
        }
        const Bs = {
          "==": gc,
          "!=": Kd,
          ">": Jd,
          "<": Yd,
          ">=": il,
          "<=": Qd,
          array: $n,
          at: pn,
          boolean: $n,
          case: tn,
          coalesce: Un,
          collator: nl,
          format: go,
          image: vc,
          in: Ms,
          "index-of": po,
          interpolate: Rn,
          "interpolate-hcl": Rn,
          "interpolate-lab": Rn,
          length: sl,
          let: ho,
          literal: Dn,
          match: As,
          number: $n,
          "number-format": al,
          object: $n,
          slice: fo,
          step: Es,
          string: $n,
          "to-boolean": Ca,
          "to-color": Ca,
          "to-number": Ca,
          "to-string": Ca,
          var: fa,
          within: us,
          distance: ds,
          "global-state": bo
        };
        class la {
          constructor(t, i, a, u) {
            this.name = t, this.type = i, this._evaluate = a, this.args = u
          }
          evaluate(t) {
            return this._evaluate(t, this.args)
          }
          eachChild(t) {
            this.args.forEach(t)
          }
          outputDefined() {
            return !1
          }
          static parse(t, i) {
            const a = t[0],
              u = la.definitions[a];
            if (!u) return i.error(`Unknown expression "${a}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const p = Array.isArray(u) ? u[0] : u.type,
              f = Array.isArray(u) ? [
                [u[1], u[2]]
              ] : u.overloads,
              g = f.filter((([S]) => !Array.isArray(S) || S.length === t.length - 1));
            let x = null;
            for (const [S, I] of g) {
              x = new uo(i.registry, pl, i.path, null, i.scope);
              const k = [];
              let R = !1;
              for (let N = 1; N < t.length; N++) {
                const q = t[N],
                  U = Array.isArray(S) ? S[N - 1] : S.type,
                  J = x.parse(q, 1 + k.length, U);
                if (!J) {
                  R = !0;
                  break
                }
                k.push(J)
              }
              if (!R)
                if (Array.isArray(S) && S.length !== k.length) x.error(`Expected ${S.length} arguments, but found ${k.length} instead.`);
                else {
                  for (let N = 0; N < k.length; N++) {
                    const q = Array.isArray(S) ? S[N] : S.type,
                      U = k[N];
                    x.concat(N + 1).checkSubtype(q, U.type)
                  }
                  if (x.errors.length === 0) return new la(a, p, I, k)
                }
            }
            if (g.length === 1) i.errors.push(...x.errors);
            else {
              const S = (g.length ? g : f).map((([k]) => {
                  return R = k, Array.isArray(R) ? `(${R.map(Zt).join(", ")})` : `(${Zt(R.type)}...)`;
                  var R
                })).join(" | "),
                I = [];
              for (let k = 1; k < t.length; k++) {
                const R = i.parse(t[k], 1 + I.length);
                if (!R) return null;
                I.push(Zt(R.type))
              }
              i.error(`Expected arguments of type ${S}, but found (${I.join(", ")}) instead.`)
            }
            return null
          }
          static register(t, i) {
            la.definitions = i;
            for (const a in i) t[a] = la
          }
        }

        function zh(n, [t, i, a, u]) {
          t = t.evaluate(n), i = i.evaluate(n), a = a.evaluate(n);
          const p = u ? u.evaluate(n) : 1,
            f = Qr(t, i, a, p);
          if (f) throw new Ni(f);
          return new ni(t / 255, i / 255, a / 255, p, !1)
        }

        function Lh(n, t) {
          return n in t
        }

        function Ec(n, t) {
          const i = t[n];
          return i === void 0 ? null : i
        }

        function ps(n) {
          return {
            type: n
          }
        }

        function pl(n) {
          if (n instanceof fa) return pl(n.boundExpression);
          if (n instanceof la && n.name === "error" || n instanceof nl || n instanceof us || n instanceof ds || n instanceof bo) return !1;
          const t = n instanceof Ca || n instanceof $n;
          let i = !0;
          return n.eachChild((a => {
            i = t ? i && pl(a) : i && a instanceof Dn
          })), !!i && fl(n) && Fs(n, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"])
        }

        function fl(n) {
          if (n instanceof la && (n.name === "get" && n.args.length === 1 || n.name === "feature-state" || n.name === "has" && n.args.length === 1 || n.name === "properties" || n.name === "geometry-type" || n.name === "id" || /^filter-/.test(n.name)) || n instanceof us || n instanceof ds) return !1;
          let t = !0;
          return n.eachChild((i => {
            t && !fl(i) && (t = !1)
          })), t
        }

        function wo(n) {
          if (n instanceof la && n.name === "feature-state") return !1;
          let t = !0;
          return n.eachChild((i => {
            t && !wo(i) && (t = !1)
          })), t
        }

        function Fs(n, t) {
          if (n instanceof la && t.indexOf(n.name) >= 0) return !1;
          let i = !0;
          return n.eachChild((a => {
            i && !Fs(a, t) && (i = !1)
          })), i
        }

        function Dh(n) {
          return {
            result: "success",
            value: n
          }
        }

        function Os(n) {
          return {
            result: "error",
            value: n
          }
        }

        function Ns(n) {
          return n["property-type"] === "data-driven" || n["property-type"] === "cross-faded-data-driven"
        }

        function zc(n) {
          return !!n.expression && n.expression.parameters.indexOf("zoom") > -1
        }

        function Lc(n) {
          return !!n.expression && n.expression.interpolated
        }

        function oi(n) {
          return n instanceof Number ? "number" : n instanceof String ? "string" : n instanceof Boolean ? "boolean" : Array.isArray(n) ? "array" : n === null ? "null" : typeof n
        }

        function fs(n) {
          return typeof n == "object" && n !== null && !Array.isArray(n) && Nr(n) === _i
        }

        function Rh(n) {
          return n
        }

        function Bh(n, t) {
          const i = n.stops && typeof n.stops[0][0] == "object",
            a = i || !(i || n.property !== void 0),
            u = n.type || (Lc(t) ? "exponential" : "interval"),
            p = (function(I) {
              switch (I.type) {
                case "color":
                  return ni.parse;
                case "padding":
                  return Oi.parse;
                case "numberArray":
                  return hn.parse;
                case "colorArray":
                  return dn.parse;
                default:
                  return null
              }
            })(t);
          if (p && ((n = Ut({}, n)).stops && (n.stops = n.stops.map((I => [I[0], p(I[1])]))), n.default = p(n.default ? n.default : t.default)), n.colorSpace && (f = n.colorSpace) !== "rgb" && f !== "hcl" && f !== "lab") throw new Error(`Unknown color space: "${n.colorSpace}"`);
          var f;
          const g = (function(I) {
            switch (I) {
              case "exponential":
                return Fh;
              case "interval":
                return hp;
              case "categorical":
                return up;
              case "identity":
                return Oh;
              default:
                throw new Error(`Unknown function type "${I}"`)
            }
          })(u);
          let x, S;
          if (u === "categorical") {
            x = Object.create(null);
            for (const I of n.stops) x[I[0]] = I[1];
            S = typeof n.stops[0][0]
          }
          if (i) {
            const I = {},
              k = [];
            for (let q = 0; q < n.stops.length; q++) {
              const U = n.stops[q],
                J = U[0].zoom;
              I[J] === void 0 && (I[J] = {
                zoom: J,
                type: n.type,
                property: n.property,
                default: n.default,
                stops: []
              }, k.push(J)), I[J].stops.push([U[0].value, U[1]])
            }
            const R = [];
            for (const q of k) R.push([I[q].zoom, Bh(I[q], t)]);
            const N = {
              name: "linear"
            };
            return {
              kind: "composite",
              interpolationType: N,
              interpolationFactor: Rn.interpolationFactor.bind(void 0, N),
              zoomStops: R.map((q => q[0])),
              evaluate: ({
                zoom: q
              }, U) => Fh({
                stops: R,
                base: n.base
              }, t, q).evaluate(q, U)
            }
          }
          if (a) {
            const I = u === "exponential" ? {
              name: "exponential",
              base: n.base !== void 0 ? n.base : 1
            } : null;
            return {
              kind: "camera",
              interpolationType: I,
              interpolationFactor: Rn.interpolationFactor.bind(void 0, I),
              zoomStops: n.stops.map((k => k[0])),
              evaluate: ({
                zoom: k
              }) => g(n, t, k, x, S)
            }
          }
          return {
            kind: "source",
            evaluate(I, k) {
              const R = k && k.properties ? k.properties[n.property] : void 0;
              return R === void 0 ? To(n.default, t.default) : g(n, t, R, x, S)
            }
          }
        }

        function To(n, t, i) {
          return n !== void 0 ? n : t !== void 0 ? t : i !== void 0 ? i : void 0
        }

        function up(n, t, i, a, u) {
          return To(typeof i === u ? a[i] : void 0, n.default, t.default)
        }

        function hp(n, t, i) {
          if (oi(i) !== "number") return To(n.default, t.default);
          const a = n.stops.length;
          if (a === 1 || i <= n.stops[0][0]) return n.stops[0][1];
          if (i >= n.stops[a - 1][0]) return n.stops[a - 1][1];
          const u = ks(n.stops.map((p => p[0])), i);
          return n.stops[u][1]
        }

        function Fh(n, t, i) {
          const a = n.base !== void 0 ? n.base : 1;
          if (oi(i) !== "number") return To(n.default, t.default);
          const u = n.stops.length;
          if (u === 1 || i <= n.stops[0][0]) return n.stops[0][1];
          if (i >= n.stops[u - 1][0]) return n.stops[u - 1][1];
          const p = ks(n.stops.map((I => I[0])), i),
            f = (function(I, k, R, N) {
              const q = N - R,
                U = I - R;
              return q === 0 ? 0 : k === 1 ? U / q : (Math.pow(k, U) - 1) / (Math.pow(k, q) - 1)
            })(i, a, n.stops[p][0], n.stops[p + 1][0]),
            g = n.stops[p][1],
            x = n.stops[p + 1][1],
            S = ta[t.type] || Rh;
          return typeof g.evaluate == "function" ? {
            evaluate(...I) {
              const k = g.evaluate.apply(void 0, I),
                R = x.evaluate.apply(void 0, I);
              if (k !== void 0 && R !== void 0) return S(k, R, f, n.colorSpace)
            }
          } : S(g, x, f, n.colorSpace)
        }

        function Oh(n, t, i) {
          switch (t.type) {
            case "color":
              i = ni.parse(i);
              break;
            case "formatted":
              i = Yi.fromString(i.toString());
              break;
            case "resolvedImage":
              i = Zn.fromString(i.toString());
              break;
            case "padding":
              i = Oi.parse(i);
              break;
            case "colorArray":
              i = dn.parse(i);
              break;
            case "numberArray":
              i = hn.parse(i);
              break;
            default:
              oi(i) === t.type || t.type === "enum" && t.values[i] || (i = void 0)
          }
          return To(i, n.default, t.default)
        }
        la.register(Bs, {
          error: [{
              kind: "error"
            },
            [hr], (n, [t]) => {
              throw new Ni(t.evaluate(n))
            }
          ],
          typeof: [hr, [_r], (n, [t]) => Zt(Nr(t.evaluate(n)))],
          "to-rgba": [Rt(gt, 4), [ai], (n, [t]) => {
            const [i, a, u, p] = t.evaluate(n).rgb;
            return [255 * i, 255 * a, 255 * u, p]
          }],
          rgb: [ai, [gt, gt, gt], zh],
          rgba: [ai, [gt, gt, gt, gt], zh],
          has: {
            type: xr,
            overloads: [
              [
                [hr], (n, [t]) => Lh(t.evaluate(n), n.properties())
              ],
              [
                [hr, _i], (n, [t, i]) => Lh(t.evaluate(n), i.evaluate(n))
              ]
            ]
          },
          get: {
            type: _r,
            overloads: [
              [
                [hr], (n, [t]) => Ec(t.evaluate(n), n.properties())
              ],
              [
                [hr, _i], (n, [t, i]) => Ec(t.evaluate(n), i.evaluate(n))
              ]
            ]
          },
          "feature-state": [_r, [hr], (n, [t]) => Ec(t.evaluate(n), n.featureState || {})],
          properties: [_i, [], n => n.properties()],
          "geometry-type": [hr, [], n => n.geometryType()],
          id: [_r, [], n => n.id()],
          zoom: [gt, [], n => n.globals.zoom],
          "heatmap-density": [gt, [], n => n.globals.heatmapDensity || 0],
          elevation: [gt, [], n => n.globals.elevation || 0],
          "line-progress": [gt, [], n => n.globals.lineProgress || 0],
          accumulated: [_r, [], n => n.globals.accumulated === void 0 ? null : n.globals.accumulated],
          "+": [gt, ps(gt), (n, t) => {
            let i = 0;
            for (const a of t) i += a.evaluate(n);
            return i
          }],
          "*": [gt, ps(gt), (n, t) => {
            let i = 1;
            for (const a of t) i *= a.evaluate(n);
            return i
          }],
          "-": {
            type: gt,
            overloads: [
              [
                [gt, gt], (n, [t, i]) => t.evaluate(n) - i.evaluate(n)
              ],
              [
                [gt], (n, [t]) => -t.evaluate(n)
              ]
            ]
          },
          "/": [gt, [gt, gt], (n, [t, i]) => t.evaluate(n) / i.evaluate(n)],
          "%": [gt, [gt, gt], (n, [t, i]) => t.evaluate(n) % i.evaluate(n)],
          ln2: [gt, [], () => Math.LN2],
          pi: [gt, [], () => Math.PI],
          e: [gt, [], () => Math.E],
          "^": [gt, [gt, gt], (n, [t, i]) => Math.pow(t.evaluate(n), i.evaluate(n))],
          sqrt: [gt, [gt], (n, [t]) => Math.sqrt(t.evaluate(n))],
          log10: [gt, [gt], (n, [t]) => Math.log(t.evaluate(n)) / Math.LN10],
          ln: [gt, [gt], (n, [t]) => Math.log(t.evaluate(n))],
          log2: [gt, [gt], (n, [t]) => Math.log(t.evaluate(n)) / Math.LN2],
          sin: [gt, [gt], (n, [t]) => Math.sin(t.evaluate(n))],
          cos: [gt, [gt], (n, [t]) => Math.cos(t.evaluate(n))],
          tan: [gt, [gt], (n, [t]) => Math.tan(t.evaluate(n))],
          asin: [gt, [gt], (n, [t]) => Math.asin(t.evaluate(n))],
          acos: [gt, [gt], (n, [t]) => Math.acos(t.evaluate(n))],
          atan: [gt, [gt], (n, [t]) => Math.atan(t.evaluate(n))],
          min: [gt, ps(gt), (n, t) => Math.min(...t.map((i => i.evaluate(n))))],
          max: [gt, ps(gt), (n, t) => Math.max(...t.map((i => i.evaluate(n))))],
          abs: [gt, [gt], (n, [t]) => Math.abs(t.evaluate(n))],
          round: [gt, [gt], (n, [t]) => {
            const i = t.evaluate(n);
            return i < 0 ? -Math.round(-i) : Math.round(i)
          }],
          floor: [gt, [gt], (n, [t]) => Math.floor(t.evaluate(n))],
          ceil: [gt, [gt], (n, [t]) => Math.ceil(t.evaluate(n))],
          "filter-==": [xr, [hr, _r], (n, [t, i]) => n.properties()[t.value] === i.value],
          "filter-id-==": [xr, [_r], (n, [t]) => n.id() === t.value],
          "filter-type-==": [xr, [hr], (n, [t]) => n.geometryType() === t.value],
          "filter-<": [xr, [hr, _r], (n, [t, i]) => {
            const a = n.properties()[t.value],
              u = i.value;
            return typeof a == typeof u && a < u
          }],
          "filter-id-<": [xr, [_r], (n, [t]) => {
            const i = n.id(),
              a = t.value;
            return typeof i == typeof a && i < a
          }],
          "filter->": [xr, [hr, _r], (n, [t, i]) => {
            const a = n.properties()[t.value],
              u = i.value;
            return typeof a == typeof u && a > u
          }],
          "filter-id->": [xr, [_r], (n, [t]) => {
            const i = n.id(),
              a = t.value;
            return typeof i == typeof a && i > a
          }],
          "filter-<=": [xr, [hr, _r], (n, [t, i]) => {
            const a = n.properties()[t.value],
              u = i.value;
            return typeof a == typeof u && a <= u
          }],
          "filter-id-<=": [xr, [_r], (n, [t]) => {
            const i = n.id(),
              a = t.value;
            return typeof i == typeof a && i <= a
          }],
          "filter->=": [xr, [hr, _r], (n, [t, i]) => {
            const a = n.properties()[t.value],
              u = i.value;
            return typeof a == typeof u && a >= u
          }],
          "filter-id->=": [xr, [_r], (n, [t]) => {
            const i = n.id(),
              a = t.value;
            return typeof i == typeof a && i >= a
          }],
          "filter-has": [xr, [_r], (n, [t]) => t.value in n.properties()],
          "filter-has-id": [xr, [], n => n.id() !== null && n.id() !== void 0],
          "filter-type-in": [xr, [Rt(hr)], (n, [t]) => t.value.indexOf(n.geometryType()) >= 0],
          "filter-id-in": [xr, [Rt(_r)], (n, [t]) => t.value.indexOf(n.id()) >= 0],
          "filter-in-small": [xr, [hr, Rt(_r)], (n, [t, i]) => i.value.indexOf(n.properties()[t.value]) >= 0],
          "filter-in-large": [xr, [hr, Rt(_r)], (n, [t, i]) => (function(a, u, p, f) {
            for (; p <= f;) {
              const g = p + f >> 1;
              if (u[g] === a) return !0;
              u[g] > a ? f = g - 1 : p = g + 1
            }
            return !1
          })(n.properties()[t.value], i.value, 0, i.value.length - 1)],
          all: {
            type: xr,
            overloads: [
              [
                [xr, xr], (n, [t, i]) => t.evaluate(n) && i.evaluate(n)
              ],
              [ps(xr), (n, t) => {
                for (const i of t)
                  if (!i.evaluate(n)) return !1;
                return !0
              }]
            ]
          },
          any: {
            type: xr,
            overloads: [
              [
                [xr, xr], (n, [t, i]) => t.evaluate(n) || i.evaluate(n)
              ],
              [ps(xr), (n, t) => {
                for (const i of t)
                  if (i.evaluate(n)) return !0;
                return !1
              }]
            ]
          },
          "!": [xr, [xr], (n, [t]) => !t.evaluate(n)],
          "is-supported-script": [xr, [hr], (n, [t]) => {
            const i = n.globals && n.globals.isSupportedScript;
            return !i || i(t.evaluate(n))
          }],
          upcase: [hr, [hr], (n, [t]) => t.evaluate(n).toUpperCase()],
          downcase: [hr, [hr], (n, [t]) => t.evaluate(n).toLowerCase()],
          concat: [hr, ps(_r), (n, t) => t.map((i => cs(i.evaluate(n)))).join("")],
          "resolved-locale": [hr, [Ti], (n, [t]) => t.evaluate(n).resolvedLocale()]
        });
        class ml {
          constructor(t, i) {
            this.expression = t, this._warningHistory = {}, this._evaluator = new vh, this._defaultValue = i ? (function(a) {
              if (a.type === "color" && fs(a.default)) return new ni(0, 0, 0, 0);
              switch (a.type) {
                case "color":
                  return ni.parse(a.default) || null;
                case "padding":
                  return Oi.parse(a.default) || null;
                case "numberArray":
                  return hn.parse(a.default) || null;
                case "colorArray":
                  return dn.parse(a.default) || null;
                case "variableAnchorOffsetCollection":
                  return di.parse(a.default) || null;
                case "projectionDefinition":
                  return Hr.parse(a.default) || null;
                default:
                  return a.default === void 0 ? null : a.default
              }
            })(i) : null, this._enumValues = i && i.type === "enum" ? i.values : null
          }
          evaluateWithoutErrorHandling(t, i, a, u, p, f) {
            return this._evaluator.globals = t, this._evaluator.feature = i, this._evaluator.featureState = a, this._evaluator.canonical = u, this._evaluator.availableImages = p || null, this._evaluator.formattedSection = f, this.expression.evaluate(this._evaluator)
          }
          evaluate(t, i, a, u, p, f) {
            this._evaluator.globals = t, this._evaluator.feature = i || null, this._evaluator.featureState = a || null, this._evaluator.canonical = u, this._evaluator.availableImages = p || null, this._evaluator.formattedSection = f || null;
            try {
              const g = this.expression.evaluate(this._evaluator);
              if (g == null || typeof g == "number" && g != g) return this._defaultValue;
              if (this._enumValues && !(g in this._enumValues)) throw new Ni(`Expected value to be one of ${Object.keys(this._enumValues).map((x=>JSON.stringify(x))).join(", ")}, but found ${JSON.stringify(g)} instead.`);
              return g
            } catch (g) {
              return this._warningHistory[g.message] || (this._warningHistory[g.message] = !0, typeof console < "u" && console.warn(g.message)), this._defaultValue
            }
          }
        }

        function _l(n) {
          return Array.isArray(n) && n.length > 0 && typeof n[0] == "string" && n[0] in Bs
        }

        function gl(n, t) {
          const i = new uo(Bs, pl, [], t ? (function(u) {
              const p = {
                color: ai,
                string: hr,
                number: gt,
                enum: hr,
                boolean: xr,
                formatted: Ar,
                padding: qr,
                numberArray: nn,
                colorArray: fi,
                projectionDefinition: ki,
                resolvedImage: un,
                variableAnchorOffsetCollection: bt
              };
              return u.type === "array" ? Rt(p[u.value] || _r, u.length) : p[u.type]
            })(t) : void 0),
            a = i.parse(n, void 0, void 0, void 0, t && t.type === "string" ? {
              typeAnnotation: "coerce"
            } : void 0);
          return a ? Dh(new ml(a, t)) : Os(i.errors)
        }
        class Co {
          constructor(t, i) {
            this.kind = t, this._styleExpression = i, this.isStateDependent = t !== "constant" && !wo(i.expression), this.globalStateRefs = qs(i.expression)
          }
          evaluateWithoutErrorHandling(t, i, a, u, p, f) {
            return this._styleExpression.evaluateWithoutErrorHandling(t, i, a, u, p, f)
          }
          evaluate(t, i, a, u, p, f) {
            return this._styleExpression.evaluate(t, i, a, u, p, f)
          }
        }
        class vl {
          constructor(t, i, a, u) {
            this.kind = t, this.zoomStops = a, this._styleExpression = i, this.isStateDependent = t !== "camera" && !wo(i.expression), this.globalStateRefs = qs(i.expression), this.interpolationType = u
          }
          evaluateWithoutErrorHandling(t, i, a, u, p, f) {
            return this._styleExpression.evaluateWithoutErrorHandling(t, i, a, u, p, f)
          }
          evaluate(t, i, a, u, p, f) {
            return this._styleExpression.evaluate(t, i, a, u, p, f)
          }
          interpolationFactor(t, i, a) {
            return this.interpolationType ? Rn.interpolationFactor(this.interpolationType, t, i, a) : 0
          }
        }

        function Dc(n, t) {
          const i = gl(n, t);
          if (i.result === "error") return i;
          const a = i.value.expression,
            u = fl(a);
          if (!u && !Ns(t)) return Os([new nr("", "data expressions not supported")]);
          const p = Fs(a, ["zoom"]);
          if (!p && !zc(t)) return Os([new nr("", "zoom expressions not supported")]);
          const f = js(a);
          return f || p ? f instanceof nr ? Os([f]) : f instanceof Rn && !Lc(t) ? Os([new nr("", '"interpolate" expressions cannot be used with this property')]) : Dh(f ? new vl(u ? "camera" : "composite", i.value, f.labels, f instanceof Rn ? f.interpolation : void 0) : new Co(u ? "constant" : "source", i.value)) : Os([new nr("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')])
        }
        class So {
          constructor(t, i) {
            this._parameters = t, this._specification = i, Ut(this, Bh(this._parameters, this._specification))
          }
          static deserialize(t) {
            return new So(t._parameters, t._specification)
          }
          static serialize(t) {
            return {
              _parameters: t._parameters,
              _specification: t._specification
            }
          }
        }

        function js(n) {
          let t = null;
          if (n instanceof ho) t = js(n.result);
          else if (n instanceof Un) {
            for (const i of n.args)
              if (t = js(i), t) break
          } else(n instanceof Es || n instanceof Rn) && n.input instanceof la && n.input.name === "zoom" && (t = n);
          return t instanceof nr || n.eachChild((i => {
            const a = js(i);
            a instanceof nr ? t = a : !t && a ? t = new nr("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && a && t !== a && (t = new nr("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'))
          })), t
        }

        function qs(n, t = new Set) {
          return n instanceof bo && t.add(n.key), n.eachChild((i => {
            qs(i, t)
          })), t
        }

        function Po(n) {
          if (n === !0 || n === !1) return !0;
          if (!Array.isArray(n) || n.length === 0) return !1;
          switch (n[0]) {
            case "has":
              return n.length >= 2 && n[1] !== "$id" && n[1] !== "$type";
            case "in":
              return n.length >= 3 && (typeof n[1] != "string" || Array.isArray(n[2]));
            case "!in":
            case "!has":
            case "none":
              return !1;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return n.length !== 3 || Array.isArray(n[1]) || Array.isArray(n[2]);
            case "any":
            case "all":
              for (const t of n.slice(1))
                if (!Po(t) && typeof t != "boolean") return !1;
              return !0;
            default:
              return !0
          }
        }
        const Rc = {
          type: "boolean",
          default: !1,
          transition: !1,
          "property-type": "data-driven",
          expression: {
            interpolated: !1,
            parameters: ["zoom", "feature"]
          }
        };

        function Ha(n) {
          if (n == null) return {
            filter: () => !0,
            needGeometry: !1,
            getGlobalStateRefs: () => new Set
          };
          Po(n) || (n = yl(n));
          const t = gl(n, Rc);
          if (t.result === "error") throw new Error(t.value.map((i => `${i.key}: ${i.message}`)).join(", "));
          return {
            filter: (i, a, u) => t.value.evaluate(i, a, {}, u),
            needGeometry: Nh(n),
            getGlobalStateRefs: () => qs(t.value.expression)
          }
        }

        function dp(n, t) {
          return n < t ? -1 : n > t ? 1 : 0
        }

        function Nh(n) {
          if (!Array.isArray(n)) return !1;
          if (n[0] === "within" || n[0] === "distance") return !0;
          for (let t = 1; t < n.length; t++)
            if (Nh(n[t])) return !0;
          return !1
        }

        function yl(n) {
          if (!n) return !0;
          const t = n[0];
          return n.length <= 1 ? t !== "any" : t === "==" ? Bc(n[1], n[2], "==") : t === "!=" ? Io(Bc(n[1], n[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? Bc(n[1], n[2], t) : t === "any" ? (i = n.slice(1), ["any"].concat(i.map(yl))) : t === "all" ? ["all"].concat(n.slice(1).map(yl)) : t === "none" ? ["all"].concat(n.slice(1).map(yl).map(Io)) : t === "in" ? jh(n[1], n.slice(2)) : t === "!in" ? Io(jh(n[1], n.slice(2))) : t === "has" ? qh(n[1]) : t !== "!has" || Io(qh(n[1]));
          var i
        }

        function Bc(n, t, i) {
          switch (n) {
            case "$type":
              return [`filter-type-${i}`, t];
            case "$id":
              return [`filter-id-${i}`, t];
            default:
              return [`filter-${i}`, n, t]
          }
        }

        function jh(n, t) {
          if (t.length === 0) return !1;
          switch (n) {
            case "$type":
              return ["filter-type-in", ["literal", t]];
            case "$id":
              return ["filter-id-in", ["literal", t]];
            default:
              return t.length > 200 && !t.some((i => typeof i != typeof t[0])) ? ["filter-in-large", n, ["literal", t.sort(dp)]] : ["filter-in-small", n, ["literal", t]]
          }
        }

        function qh(n) {
          switch (n) {
            case "$type":
              return !0;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", n]
          }
        }

        function Io(n) {
          return ["!", n]
        }

        function xl(n) {
          const t = typeof n;
          if (t === "number" || t === "boolean" || t === "string" || n == null) return JSON.stringify(n);
          if (Array.isArray(n)) {
            let u = "[";
            for (const p of n) u += `${xl(p)},`;
            return `${u}]`
          }
          const i = Object.keys(n).sort();
          let a = "{";
          for (let u = 0; u < i.length; u++) a += `${JSON.stringify(i[u])}:${xl(n[i[u]])},`;
          return `${a}}`
        }

        function bl(n) {
          let t = "";
          for (const i of Pt) t += `/${xl(n[i])}`;
          return t
        }

        function Vh(n) {
          const t = n.value;
          return t ? [new je(n.key, t, "constants have been deprecated as of v8")] : []
        }

        function $i(n) {
          return n instanceof Number || n instanceof String || n instanceof Boolean ? n.valueOf() : n
        }

        function Wa(n) {
          if (Array.isArray(n)) return n.map(Wa);
          if (n instanceof Object && !(n instanceof Number || n instanceof String || n instanceof Boolean)) {
            const t = {};
            for (const i in n) t[i] = Wa(n[i]);
            return t
          }
          return $i(n)
        }

        function ca(n) {
          const t = n.key,
            i = n.value,
            a = n.valueSpec || {},
            u = n.objectElementValidators || {},
            p = n.style,
            f = n.styleSpec,
            g = n.validateSpec;
          let x = [];
          const S = oi(i);
          if (S !== "object") return [new je(t, i, `object expected, ${S} found`)];
          for (const I in i) {
            const k = I.split(".")[0],
              R = Jr(a, k) || a["*"];
            let N;
            if (Jr(u, k)) N = u[k];
            else if (Jr(a, k)) N = g;
            else if (u["*"]) N = u["*"];
            else {
              if (!a["*"]) {
                x.push(new je(t, i[I], `unknown property "${I}"`));
                continue
              }
              N = g
            }
            x = x.concat(N({
              key: (t && `${t}.`) + I,
              value: i[I],
              valueSpec: R,
              style: p,
              styleSpec: f,
              object: i,
              objectKey: I,
              validateSpec: g
            }, i))
          }
          for (const I in a) u[I] || a[I].required && a[I].default === void 0 && i[I] === void 0 && x.push(new je(t, i, `missing required property "${I}"`));
          return x
        }

        function wl(n) {
          const t = n.value,
            i = n.valueSpec,
            a = n.style,
            u = n.styleSpec,
            p = n.key,
            f = n.arrayElementValidator || n.validateSpec;
          if (oi(t) !== "array") return [new je(p, t, `array expected, ${oi(t)} found`)];
          if (i.length && t.length !== i.length) return [new je(p, t, `array length ${i.length} expected, length ${t.length} found`)];
          if (i["min-length"] && t.length < i["min-length"]) return [new je(p, t, `array length at least ${i["min-length"]} expected, length ${t.length} found`)];
          let g = {
            type: i.value,
            values: i.values
          };
          u.$version < 7 && (g.function = i.function), oi(i.value) === "object" && (g = i.value);
          let x = [];
          for (let S = 0; S < t.length; S++) x = x.concat(f({
            array: t,
            arrayIndex: S,
            value: t[S],
            valueSpec: g,
            validateSpec: n.validateSpec,
            style: a,
            styleSpec: u,
            key: `${p}[${S}]`
          }));
          return x
        }

        function Mo(n) {
          const t = n.key,
            i = n.value,
            a = n.valueSpec;
          let u = oi(i);
          return u === "number" && i != i && (u = "NaN"), u !== "number" ? [new je(t, i, `number expected, ${u} found`)] : "minimum" in a && i < a.minimum ? [new je(t, i, `${i} is less than the minimum value ${a.minimum}`)] : "maximum" in a && i > a.maximum ? [new je(t, i, `${i} is greater than the maximum value ${a.maximum}`)] : []
        }

        function Vs(n) {
          const t = n.valueSpec,
            i = $i(n.value.type);
          let a, u, p, f = {};
          const g = i !== "categorical" && n.value.property === void 0,
            x = !g,
            S = oi(n.value.stops) === "array" && oi(n.value.stops[0]) === "array" && oi(n.value.stops[0][0]) === "object",
            I = ca({
              key: n.key,
              value: n.value,
              valueSpec: n.styleSpec.function,
              validateSpec: n.validateSpec,
              style: n.style,
              styleSpec: n.styleSpec,
              objectElementValidators: {
                stops: function(N) {
                  if (i === "identity") return [new je(N.key, N.value, 'identity function may not have a "stops" property')];
                  let q = [];
                  const U = N.value;
                  return q = q.concat(wl({
                    key: N.key,
                    value: U,
                    valueSpec: N.valueSpec,
                    validateSpec: N.validateSpec,
                    style: N.style,
                    styleSpec: N.styleSpec,
                    arrayElementValidator: k
                  })), oi(U) === "array" && U.length === 0 && q.push(new je(N.key, U, "array must have at least one stop")), q
                },
                default: function(N) {
                  return N.validateSpec({
                    key: N.key,
                    value: N.value,
                    valueSpec: t,
                    validateSpec: N.validateSpec,
                    style: N.style,
                    styleSpec: N.styleSpec
                  })
                }
              }
            });
          return i === "identity" && g && I.push(new je(n.key, n.value, 'missing required property "property"')), i === "identity" || n.value.stops || I.push(new je(n.key, n.value, 'missing required property "stops"')), i === "exponential" && n.valueSpec.expression && !Lc(n.valueSpec) && I.push(new je(n.key, n.value, "exponential functions not supported")), n.styleSpec.$version >= 8 && (x && !Ns(n.valueSpec) ? I.push(new je(n.key, n.value, "property functions not supported")) : g && !zc(n.valueSpec) && I.push(new je(n.key, n.value, "zoom functions not supported"))), i !== "categorical" && !S || n.value.property !== void 0 || I.push(new je(n.key, n.value, '"property" property is required')), I;

          function k(N) {
            let q = [];
            const U = N.value,
              J = N.key;
            if (oi(U) !== "array") return [new je(J, U, `array expected, ${oi(U)} found`)];
            if (U.length !== 2) return [new je(J, U, `array length 2 expected, length ${U.length} found`)];
            if (S) {
              if (oi(U[0]) !== "object") return [new je(J, U, `object expected, ${oi(U[0])} found`)];
              if (U[0].zoom === void 0) return [new je(J, U, "object stop key must have zoom")];
              if (U[0].value === void 0) return [new je(J, U, "object stop key must have value")];
              if (p && p > $i(U[0].zoom)) return [new je(J, U[0].zoom, "stop zoom values must appear in ascending order")];
              $i(U[0].zoom) !== p && (p = $i(U[0].zoom), u = void 0, f = {}), q = q.concat(ca({
                key: `${J}[0]`,
                value: U[0],
                valueSpec: {
                  zoom: {}
                },
                validateSpec: N.validateSpec,
                style: N.style,
                styleSpec: N.styleSpec,
                objectElementValidators: {
                  zoom: Mo,
                  value: R
                }
              }))
            } else q = q.concat(R({
              key: `${J}[0]`,
              value: U[0],
              validateSpec: N.validateSpec,
              style: N.style,
              styleSpec: N.styleSpec
            }, U));
            return _l(Wa(U[1])) ? q.concat([new je(`${J}[1]`, U[1], "expressions are not allowed in function stops.")]) : q.concat(N.validateSpec({
              key: `${J}[1]`,
              value: U[1],
              valueSpec: t,
              validateSpec: N.validateSpec,
              style: N.style,
              styleSpec: N.styleSpec
            }))
          }

          function R(N, q) {
            const U = oi(N.value),
              J = $i(N.value),
              ae = N.value !== null ? N.value : q;
            if (a) {
              if (U !== a) return [new je(N.key, ae, `${U} stop domain type must match previous stop domain type ${a}`)]
            } else a = U;
            if (U !== "number" && U !== "string" && U !== "boolean") return [new je(N.key, ae, "stop domain value must be a number, string, or boolean")];
            if (U !== "number" && i !== "categorical") {
              let ke = `number expected, ${U} found`;
              return Ns(t) && i === void 0 && (ke += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new je(N.key, ae, ke)]
            }
            return i !== "categorical" || U !== "number" || isFinite(J) && Math.floor(J) === J ? i !== "categorical" && U === "number" && u !== void 0 && J < u ? [new je(N.key, ae, "stop domain values must appear in ascending order")] : (u = J, i === "categorical" && J in f ? [new je(N.key, ae, "stop domain values must be unique")] : (f[J] = !0, [])) : [new je(N.key, ae, `integer expected, found ${J}`)]
          }
        }

        function Zs(n) {
          const t = (n.expressionContext === "property" ? Dc : gl)(Wa(n.value), n.valueSpec);
          if (t.result === "error") return t.value.map((a => new je(`${n.key}${a.key}`, n.value, a.message)));
          const i = t.value.expression || t.value._styleExpression.expression;
          if (n.expressionContext === "property" && n.propertyKey === "text-font" && !i.outputDefined()) return [new je(n.key, n.value, `Invalid data expression for "${n.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (n.expressionContext === "property" && n.propertyType === "layout" && !wo(i)) return [new je(n.key, n.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (n.expressionContext === "filter" && !wo(i)) return [new je(n.key, n.value, '"feature-state" data expressions are not supported with filters.')];
          if (n.expressionContext && n.expressionContext.indexOf("cluster") === 0) {
            if (!Fs(i, ["zoom", "feature-state"])) return [new je(n.key, n.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (n.expressionContext === "cluster-initial" && !fl(i)) return [new je(n.key, n.value, "Feature data expressions are not supported with initial expression part of cluster properties.")]
          }
          return []
        }

        function Fc(n) {
          const t = n.key,
            i = n.value,
            a = oi(i);
          return a !== "string" ? [new je(t, i, `color expected, ${a} found`)] : ni.parse(String(i)) ? [] : [new je(t, i, `color expected, "${i}" found`)]
        }

        function Ao(n) {
          const t = n.key,
            i = n.value,
            a = n.valueSpec,
            u = [];
          return Array.isArray(a.values) ? a.values.indexOf($i(i)) === -1 && u.push(new je(t, i, `expected one of [${a.values.join(", ")}], ${JSON.stringify(i)} found`)) : Object.keys(a.values).indexOf($i(i)) === -1 && u.push(new je(t, i, `expected one of [${Object.keys(a.values).join(", ")}], ${JSON.stringify(i)} found`)), u
        }

        function Oc(n) {
          return Po(Wa(n.value)) ? Zs(Ut({}, n, {
            expressionContext: "filter",
            valueSpec: {
              value: "boolean"
            }
          })) : Zh(n)
        }

        function Zh(n) {
          const t = n.value,
            i = n.key;
          if (oi(t) !== "array") return [new je(i, t, `array expected, ${oi(t)} found`)];
          const a = n.styleSpec;
          let u, p = [];
          if (t.length < 1) return [new je(i, t, "filter array must have at least 1 element")];
          switch (p = p.concat(Ao({
              key: `${i}[0]`,
              value: t[0],
              valueSpec: a.filter_operator,
              style: n.style,
              styleSpec: n.styleSpec
            })), $i(t[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              t.length >= 2 && $i(t[1]) === "$type" && p.push(new je(i, t, `"$type" cannot be use with operator "${t[0]}"`));
            case "==":
            case "!=":
              t.length !== 3 && p.push(new je(i, t, `filter array for operator "${t[0]}" must have 3 elements`));
            case "in":
            case "!in":
              t.length >= 2 && (u = oi(t[1]), u !== "string" && p.push(new je(`${i}[1]`, t[1], `string expected, ${u} found`)));
              for (let f = 2; f < t.length; f++) u = oi(t[f]), $i(t[1]) === "$type" ? p = p.concat(Ao({
                key: `${i}[${f}]`,
                value: t[f],
                valueSpec: a.geometry_type,
                style: n.style,
                styleSpec: n.styleSpec
              })) : u !== "string" && u !== "number" && u !== "boolean" && p.push(new je(`${i}[${f}]`, t[f], `string, number, or boolean expected, ${u} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let f = 1; f < t.length; f++) p = p.concat(Zh({
                key: `${i}[${f}]`,
                value: t[f],
                style: n.style,
                styleSpec: n.styleSpec
              }));
              break;
            case "has":
            case "!has":
              u = oi(t[1]), t.length !== 2 ? p.push(new je(i, t, `filter array for "${t[0]}" operator must have 2 elements`)) : u !== "string" && p.push(new je(`${i}[1]`, t[1], `string expected, ${u} found`))
          }
          return p
        }

        function $h(n, t) {
          const i = n.key,
            a = n.validateSpec,
            u = n.style,
            p = n.styleSpec,
            f = n.value,
            g = n.objectKey,
            x = p[`${t}_${n.layerType}`];
          if (!x) return [];
          const S = g.match(/^(.*)-transition$/);
          if (t === "paint" && S && x[S[1]] && x[S[1]].transition) return a({
            key: i,
            value: f,
            valueSpec: p.transition,
            style: u,
            styleSpec: p
          });
          const I = n.valueSpec || x[g];
          if (!I) return [new je(i, f, `unknown property "${g}"`)];
          let k;
          if (oi(f) === "string" && Ns(I) && !I.tokens && (k = /^{([^}]+)}$/.exec(f))) return [new je(i, f, `"${g}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(k[1])} }\`.`)];
          const R = [];
          return n.layerType === "symbol" && (g === "text-field" && u && !u.glyphs && R.push(new je(i, f, 'use of "text-field" requires a style "glyphs" property')), g === "text-font" && fs(Wa(f)) && $i(f.type) === "identity" && R.push(new je(i, f, '"text-font" does not support identity functions'))), R.concat(a({
            key: n.key,
            value: f,
            valueSpec: I,
            style: u,
            styleSpec: p,
            expressionContext: "property",
            propertyType: t,
            propertyKey: g
          }))
        }

        function $s(n) {
          return $h(n, "paint")
        }

        function Us(n) {
          return $h(n, "layout")
        }

        function Gn(n) {
          let t = [];
          const i = n.value,
            a = n.key,
            u = n.style,
            p = n.styleSpec;
          if (oi(i) !== "object") return [new je(a, i, `object expected, ${oi(i)} found`)];
          i.type || i.ref || t.push(new je(a, i, 'either "type" or "ref" is required'));
          let f = $i(i.type);
          const g = $i(i.ref);
          if (i.id) {
            const x = $i(i.id);
            for (let S = 0; S < n.arrayIndex; S++) {
              const I = u.layers[S];
              $i(I.id) === x && t.push(new je(a, i.id, `duplicate layer id "${i.id}", previously used at line ${I.id.__line__}`))
            }
          }
          if ("ref" in i) {
            let x;
            ["type", "source", "source-layer", "filter", "layout"].forEach((S => {
              S in i && t.push(new je(a, i[S], `"${S}" is prohibited for ref layers`))
            })), u.layers.forEach((S => {
              $i(S.id) === g && (x = S)
            })), x ? x.ref ? t.push(new je(a, i.ref, "ref cannot reference another ref layer")) : f = $i(x.type) : t.push(new je(a, i.ref, `ref layer "${g}" not found`))
          } else if (f !== "background")
            if (i.source) {
              const x = u.sources && u.sources[i.source],
                S = x && $i(x.type);
              x ? S === "vector" && f === "raster" ? t.push(new je(a, i.source, `layer "${i.id}" requires a raster source`)) : S !== "raster-dem" && f === "hillshade" || S !== "raster-dem" && f === "color-relief" ? t.push(new je(a, i.source, `layer "${i.id}" requires a raster-dem source`)) : S === "raster" && f !== "raster" ? t.push(new je(a, i.source, `layer "${i.id}" requires a vector source`)) : S !== "vector" || i["source-layer"] ? S === "raster-dem" && f !== "hillshade" && f !== "color-relief" ? t.push(new je(a, i.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : f !== "line" || !i.paint || !i.paint["line-gradient"] || S === "geojson" && x.lineMetrics || t.push(new je(a, i, `layer "${i.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new je(a, i, `layer "${i.id}" must specify a "source-layer"`)) : t.push(new je(a, i.source, `source "${i.source}" not found`))
            } else t.push(new je(a, i, 'missing required property "source"'));
          return t = t.concat(ca({
            key: a,
            value: i,
            valueSpec: p.layer,
            style: n.style,
            styleSpec: n.styleSpec,
            validateSpec: n.validateSpec,
            objectElementValidators: {
              "*": () => [],
              type: () => n.validateSpec({
                key: `${a}.type`,
                value: i.type,
                valueSpec: p.layer.type,
                style: n.style,
                styleSpec: n.styleSpec,
                validateSpec: n.validateSpec,
                object: i,
                objectKey: "type"
              }),
              filter: Oc,
              layout: x => ca({
                layer: i,
                key: x.key,
                value: x.value,
                style: x.style,
                styleSpec: x.styleSpec,
                validateSpec: x.validateSpec,
                objectElementValidators: {
                  "*": S => Us(Ut({
                    layerType: f
                  }, S))
                }
              }),
              paint: x => ca({
                layer: i,
                key: x.key,
                value: x.value,
                style: x.style,
                styleSpec: x.styleSpec,
                validateSpec: x.validateSpec,
                objectElementValidators: {
                  "*": S => $s(Ut({
                    layerType: f
                  }, S))
                }
              })
            }
          })), t
        }

        function ma(n) {
          const t = n.value,
            i = n.key,
            a = oi(t);
          return a !== "string" ? [new je(i, t, `string expected, ${a} found`)] : []
        }
        const Nc = {
          promoteId: function({
            key: n,
            value: t
          }) {
            if (oi(t) === "string") return ma({
              key: n,
              value: t
            });
            {
              const i = [];
              for (const a in t) i.push(...ma({
                key: `${n}.${a}`,
                value: t[a]
              }));
              return i
            }
          }
        };

        function Uh(n) {
          const t = n.value,
            i = n.key,
            a = n.styleSpec,
            u = n.style,
            p = n.validateSpec;
          if (!t.type) return [new je(i, t, '"type" is required')];
          const f = $i(t.type);
          let g;
          switch (f) {
            case "vector":
            case "raster":
              return g = ca({
                key: i,
                value: t,
                valueSpec: a[`source_${f.replace("-","_")}`],
                style: n.style,
                styleSpec: a,
                objectElementValidators: Nc,
                validateSpec: p
              }), g;
            case "raster-dem":
              return g = (function(x) {
                var S;
                const I = (S = x.sourceName) !== null && S !== void 0 ? S : "",
                  k = x.value,
                  R = x.styleSpec,
                  N = R.source_raster_dem,
                  q = x.style;
                let U = [];
                const J = oi(k);
                if (k === void 0) return U;
                if (J !== "object") return U.push(new je("source_raster_dem", k, `object expected, ${J} found`)), U;
                const ae = $i(k.encoding) === "custom",
                  ke = ["redFactor", "greenFactor", "blueFactor", "baseShift"],
                  _e = x.value.encoding ? `"${x.value.encoding}"` : "Default";
                for (const O in k) !ae && ke.includes(O) ? U.push(new je(O, k[O], `In "${I}": "${O}" is only valid when "encoding" is set to "custom". ${_e} encoding found`)) : N[O] ? U = U.concat(x.validateSpec({
                  key: O,
                  value: k[O],
                  valueSpec: N[O],
                  validateSpec: x.validateSpec,
                  style: q,
                  styleSpec: R
                })) : U.push(new je(O, k[O], `unknown property "${O}"`));
                return U
              })({
                sourceName: i,
                value: t,
                style: n.style,
                styleSpec: a,
                validateSpec: p
              }), g;
            case "geojson":
              if (g = ca({
                  key: i,
                  value: t,
                  valueSpec: a.source_geojson,
                  style: u,
                  styleSpec: a,
                  validateSpec: p,
                  objectElementValidators: Nc
                }), t.cluster)
                for (const x in t.clusterProperties) {
                  const [S, I] = t.clusterProperties[x], k = typeof S == "string" ? [S, ["accumulated"],
                    ["get", x]
                  ] : S;
                  g.push(...Zs({
                    key: `${i}.${x}.map`,
                    value: I,
                    expressionContext: "cluster-map"
                  })), g.push(...Zs({
                    key: `${i}.${x}.reduce`,
                    value: k,
                    expressionContext: "cluster-reduce"
                  }))
                }
              return g;
            case "video":
              return ca({
                key: i,
                value: t,
                valueSpec: a.source_video,
                style: u,
                validateSpec: p,
                styleSpec: a
              });
            case "image":
              return ca({
                key: i,
                value: t,
                valueSpec: a.source_image,
                style: u,
                validateSpec: p,
                styleSpec: a
              });
            case "canvas":
              return [new je(i, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return Ao({
                key: `${i}.type`,
                value: t.type,
                valueSpec: {
                  values: ["vector", "raster", "raster-dem", "geojson", "video", "image"]
                }
              })
          }
        }

        function Gh(n) {
          const t = n.value,
            i = n.styleSpec,
            a = i.light,
            u = n.style;
          let p = [];
          const f = oi(t);
          if (t === void 0) return p;
          if (f !== "object") return p = p.concat([new je("light", t, `object expected, ${f} found`)]), p;
          for (const g in t) {
            const x = g.match(/^(.*)-transition$/);
            p = p.concat(x && a[x[1]] && a[x[1]].transition ? n.validateSpec({
              key: g,
              value: t[g],
              valueSpec: i.transition,
              validateSpec: n.validateSpec,
              style: u,
              styleSpec: i
            }) : a[g] ? n.validateSpec({
              key: g,
              value: t[g],
              valueSpec: a[g],
              validateSpec: n.validateSpec,
              style: u,
              styleSpec: i
            }) : [new je(g, t[g], `unknown property "${g}"`)])
          }
          return p
        }

        function Gs(n) {
          const t = n.value,
            i = n.styleSpec,
            a = i.sky,
            u = n.style,
            p = oi(t);
          if (t === void 0) return [];
          if (p !== "object") return [new je("sky", t, `object expected, ${p} found`)];
          let f = [];
          for (const g in t) f = f.concat(a[g] ? n.validateSpec({
            key: g,
            value: t[g],
            valueSpec: a[g],
            style: u,
            styleSpec: i
          }) : [new je(g, t[g], `unknown property "${g}"`)]);
          return f
        }

        function jc(n) {
          const t = n.value,
            i = n.styleSpec,
            a = i.terrain,
            u = n.style;
          let p = [];
          const f = oi(t);
          if (t === void 0) return p;
          if (f !== "object") return p = p.concat([new je("terrain", t, `object expected, ${f} found`)]), p;
          for (const g in t) p = p.concat(a[g] ? n.validateSpec({
            key: g,
            value: t[g],
            valueSpec: a[g],
            validateSpec: n.validateSpec,
            style: u,
            styleSpec: i
          }) : [new je(g, t[g], `unknown property "${g}"`)]);
          return p
        }

        function Tl(n) {
          let t = [];
          const i = n.value,
            a = n.key;
          if (Array.isArray(i)) {
            const u = [],
              p = [];
            for (const f in i) i[f].id && u.includes(i[f].id) && t.push(new je(a, i, `all the sprites' ids must be unique, but ${i[f].id} is duplicated`)), u.push(i[f].id), i[f].url && p.includes(i[f].url) && t.push(new je(a, i, `all the sprites' URLs must be unique, but ${i[f].url} is duplicated`)), p.push(i[f].url), t = t.concat(ca({
              key: `${a}[${f}]`,
              value: i[f],
              valueSpec: {
                id: {
                  type: "string",
                  required: !0
                },
                url: {
                  type: "string",
                  required: !0
                }
              },
              validateSpec: n.validateSpec
            }));
            return t
          }
          return ma({
            key: a,
            value: i
          })
        }

        function Hh(n) {
          return t = n.value, t && t.constructor === Object ? [] : [new je(n.key, n.value, `object expected, ${oi(n.value)} found`)];
          var t
        }
        const Cl = {
          "*": () => [],
          array: wl,
          boolean: function(n) {
            const t = n.value,
              i = n.key,
              a = oi(t);
            return a !== "boolean" ? [new je(i, t, `boolean expected, ${a} found`)] : []
          },
          number: Mo,
          color: Fc,
          constants: Vh,
          enum: Ao,
          filter: Oc,
          function: Vs,
          layer: Gn,
          object: ca,
          source: Uh,
          light: Gh,
          sky: Gs,
          terrain: jc,
          projection: function(n) {
            const t = n.value,
              i = n.styleSpec,
              a = i.projection,
              u = n.style,
              p = oi(t);
            if (t === void 0) return [];
            if (p !== "object") return [new je("projection", t, `object expected, ${p} found`)];
            let f = [];
            for (const g in t) f = f.concat(a[g] ? n.validateSpec({
              key: g,
              value: t[g],
              valueSpec: a[g],
              style: u,
              styleSpec: i
            }) : [new je(g, t[g], `unknown property "${g}"`)]);
            return f
          },
          projectionDefinition: function(n) {
            const t = n.key;
            let i = n.value;
            i = i instanceof String ? i.valueOf() : i;
            const a = oi(i);
            return a !== "array" || (function(u) {
              return Array.isArray(u) && u.length === 3 && typeof u[0] == "string" && typeof u[1] == "string" && typeof u[2] == "number"
            })(i) || (function(u) {
              return !!["interpolate", "step", "literal"].includes(u[0])
            })(i) ? ["array", "string"].includes(a) ? [] : [new je(t, i, `projection expected, invalid type "${a}" found`)] : [new je(t, i, `projection expected, invalid array ${JSON.stringify(i)} found`)]
          },
          string: ma,
          formatted: function(n) {
            return ma(n).length === 0 ? [] : Zs(n)
          },
          resolvedImage: function(n) {
            return ma(n).length === 0 ? [] : Zs(n)
          },
          padding: function(n) {
            const t = n.key,
              i = n.value;
            if (oi(i) === "array") {
              if (i.length < 1 || i.length > 4) return [new je(t, i, `padding requires 1 to 4 values; ${i.length} values found`)];
              const a = {
                type: "number"
              };
              let u = [];
              for (let p = 0; p < i.length; p++) u = u.concat(n.validateSpec({
                key: `${t}[${p}]`,
                value: i[p],
                validateSpec: n.validateSpec,
                valueSpec: a
              }));
              return u
            }
            return Mo({
              key: t,
              value: i,
              valueSpec: {}
            })
          },
          numberArray: function(n) {
            const t = n.key,
              i = n.value;
            if (oi(i) === "array") {
              const a = {
                type: "number"
              };
              if (i.length < 1) return [new je(t, i, "array length at least 1 expected, length 0 found")];
              let u = [];
              for (let p = 0; p < i.length; p++) u = u.concat(n.validateSpec({
                key: `${t}[${p}]`,
                value: i[p],
                validateSpec: n.validateSpec,
                valueSpec: a
              }));
              return u
            }
            return Mo({
              key: t,
              value: i,
              valueSpec: {}
            })
          },
          colorArray: function(n) {
            const t = n.key,
              i = n.value;
            if (oi(i) === "array") {
              if (i.length < 1) return [new je(t, i, "array length at least 1 expected, length 0 found")];
              let a = [];
              for (let u = 0; u < i.length; u++) a = a.concat(Fc({
                key: `${t}[${u}]`,
                value: i[u]
              }));
              return a
            }
            return Fc({
              key: t,
              value: i
            })
          },
          variableAnchorOffsetCollection: function(n) {
            const t = n.key,
              i = n.value,
              a = oi(i),
              u = n.styleSpec;
            if (a !== "array" || i.length < 1 || i.length % 2 != 0) return [new je(t, i, "variableAnchorOffsetCollection requires a non-empty array of even length")];
            let p = [];
            for (let f = 0; f < i.length; f += 2) p = p.concat(Ao({
              key: `${t}[${f}]`,
              value: i[f],
              valueSpec: u.layout_symbol["text-anchor"]
            })), p = p.concat(wl({
              key: `${t}[${f+1}]`,
              value: i[f + 1],
              valueSpec: {
                length: 2,
                value: "number"
              },
              validateSpec: n.validateSpec,
              style: n.style,
              styleSpec: u
            }));
            return p
          },
          sprite: Tl,
          state: Hh
        };

        function Sl(n) {
          const t = n.value,
            i = n.valueSpec,
            a = n.styleSpec;
          return n.validateSpec = Sl, i.expression && fs($i(t)) ? Vs(n) : i.expression && _l(Wa(t)) ? Zs(n) : i.type && Cl[i.type] ? Cl[i.type](n) : ca(Ut({}, n, {
            valueSpec: i.type ? a[i.type] : i
          }))
        }

        function Hs(n) {
          const t = n.value,
            i = n.key,
            a = ma(n);
          return a.length || (t.indexOf("{fontstack}") === -1 && a.push(new je(i, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf("{range}") === -1 && a.push(new je(i, t, '"glyphs" url must include a "{range}" token'))), a
        }

        function ua(n, t = ve) {
          let i = [];
          return i = i.concat(Sl({
            key: "",
            value: n,
            valueSpec: t.$root,
            styleSpec: t,
            style: n,
            validateSpec: Sl,
            objectElementValidators: {
              glyphs: Hs,
              "*": () => []
            }
          })), n.constants && (i = i.concat(Vh({
            key: "constants",
            value: n.constants
          }))), Wh(i)
        }

        function _a(n) {
          return function(t) {
            return n({
              ...t,
              validateSpec: Sl
            })
          }
        }

        function Wh(n) {
          return [].concat(n).sort(((t, i) => t.line - i.line))
        }

        function Bn(n) {
          return function(...t) {
            return Wh(n.apply(this, t))
          }
        }
        ua.source = Bn(_a(Uh)), ua.sprite = Bn(_a(Tl)), ua.glyphs = Bn(_a(Hs)), ua.light = Bn(_a(Gh)), ua.sky = Bn(_a(Gs)), ua.terrain = Bn(_a(jc)), ua.state = Bn(_a(Hh)), ua.layer = Bn(_a(Gn)), ua.filter = Bn(_a(Oc)), ua.paintProperty = Bn(_a($s)), ua.layoutProperty = Bn(_a(Us));
        const Ws = ua,
          pp = Ws.light,
          Pl = Ws.sky,
          fp = Ws.paintProperty,
          qc = Ws.layoutProperty;

        function ko(n, t) {
          let i = !1;
          if (t && t.length)
            for (const a of t) n.fire(new Ie(new Error(a.message))), i = !0;
          return i
        }
        class Xs {
          constructor(t, i, a) {
            const u = this.cells = [];
            if (t instanceof ArrayBuffer) {
              this.arrayBuffer = t;
              const f = new Int32Array(this.arrayBuffer);
              t = f[0], this.d = (i = f[1]) + 2 * (a = f[2]);
              for (let x = 0; x < this.d * this.d; x++) {
                const S = f[3 + x],
                  I = f[3 + x + 1];
                u.push(S === I ? null : f.subarray(S, I))
              }
              const g = f[3 + u.length + 1];
              this.keys = f.subarray(f[3 + u.length], g), this.bboxes = f.subarray(g), this.insert = this._insertReadonly
            } else {
              this.d = i + 2 * a;
              for (let f = 0; f < this.d * this.d; f++) u.push([]);
              this.keys = [], this.bboxes = []
            }
            this.n = i, this.extent = t, this.padding = a, this.scale = i / t, this.uid = 0;
            const p = a / i * t;
            this.min = -p, this.max = t + p
          }
          insert(t, i, a, u, p) {
            this._forEachCell(i, a, u, p, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t), this.bboxes.push(i), this.bboxes.push(a), this.bboxes.push(u), this.bboxes.push(p)
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.")
          }
          _insertCell(t, i, a, u, p, f) {
            this.cells[p].push(f)
          }
          query(t, i, a, u, p) {
            const f = this.min,
              g = this.max;
            if (t <= f && i <= f && g <= a && g <= u && !p) return Array.prototype.slice.call(this.keys);
            {
              const x = [];
              return this._forEachCell(t, i, a, u, this._queryCell, x, {}, p), x
            }
          }
          _queryCell(t, i, a, u, p, f, g, x) {
            const S = this.cells[p];
            if (S !== null) {
              const I = this.keys,
                k = this.bboxes;
              for (let R = 0; R < S.length; R++) {
                const N = S[R];
                if (g[N] === void 0) {
                  const q = 4 * N;
                  (x ? x(k[q + 0], k[q + 1], k[q + 2], k[q + 3]) : t <= k[q + 2] && i <= k[q + 3] && a >= k[q + 0] && u >= k[q + 1]) ? (g[N] = !0, f.push(I[N])) : g[N] = !1
                }
              }
            }
          }
          _forEachCell(t, i, a, u, p, f, g, x) {
            const S = this._convertToCellCoord(t),
              I = this._convertToCellCoord(i),
              k = this._convertToCellCoord(a),
              R = this._convertToCellCoord(u);
            for (let N = S; N <= k; N++)
              for (let q = I; q <= R; q++) {
                const U = this.d * q + N;
                if ((!x || x(this._convertFromCellCoord(N), this._convertFromCellCoord(q), this._convertFromCellCoord(N + 1), this._convertFromCellCoord(q + 1))) && p.call(this, t, i, a, u, U, f, g, x)) return
              }
          }
          _convertFromCellCoord(t) {
            return (t - this.padding) / this.scale
          }
          _convertToCellCoord(t) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding))
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const t = this.cells,
              i = 3 + this.cells.length + 1 + 1;
            let a = 0;
            for (let f = 0; f < this.cells.length; f++) a += this.cells[f].length;
            const u = new Int32Array(i + a + this.keys.length + this.bboxes.length);
            u[0] = this.extent, u[1] = this.n, u[2] = this.padding;
            let p = i;
            for (let f = 0; f < t.length; f++) {
              const g = t[f];
              u[3 + f] = p, u.set(g, p), p += g.length
            }
            return u[3 + t.length] = p, u.set(this.keys, p), p += this.keys.length, u[3 + t.length + 1] = p, u.set(this.bboxes, p), p += this.bboxes.length, u.buffer
          }
          static serialize(t, i) {
            const a = t.toArrayBuffer();
            return i && i.push(a), {
              buffer: a
            }
          }
          static deserialize(t) {
            return new Xs(t.buffer)
          }
        }
        const Pa = {};

        function Wt(n, t, i = {}) {
          if (Pa[n]) throw new Error(`${n} is already registered.`);
          Object.defineProperty(t, "_classRegistryKey", {
            value: n,
            writeable: !1
          }), Pa[n] = {
            klass: t,
            omit: i.omit || [],
            shallow: i.shallow || []
          }
        }
        Wt("Object", Object), Wt("Set", Set), Wt("TransferableGridIndex", Xs), Wt("Color", ni), Wt("Error", Error), Wt("AJAXError", se), Wt("ResolvedImage", Zn), Wt("StylePropertyFunction", So), Wt("StyleExpression", ml, {
          omit: ["_evaluator"]
        }), Wt("ZoomDependentExpression", vl), Wt("ZoomConstantExpression", Co), Wt("CompoundExpression", la, {
          omit: ["_evaluate"]
        });
        for (const n in Bs) Bs[n]._classRegistryKey || Wt(`Expression_${n}`, Bs[n]);

        function Vc(n) {
          return n && typeof ArrayBuffer < "u" && (n instanceof ArrayBuffer || n.constructor && n.constructor.name === "ArrayBuffer")
        }

        function Eo(n) {
          return n.$name || n.constructor._classRegistryKey
        }

        function Zc(n) {
          return !(function(t) {
            if (t === null || typeof t != "object") return !1;
            const i = Eo(t);
            return !(!i || i === "Object")
          })(n) && (n == null || typeof n == "boolean" || typeof n == "number" || typeof n == "string" || n instanceof Boolean || n instanceof Number || n instanceof String || n instanceof Date || n instanceof RegExp || n instanceof Blob || n instanceof Error || Vc(n) || Tr(n) || ArrayBuffer.isView(n) || n instanceof ImageData)
        }

        function zo(n, t) {
          if (Zc(n)) return (Vc(n) || Tr(n)) && t && t.push(n), ArrayBuffer.isView(n) && t && t.push(n.buffer), n instanceof ImageData && t && t.push(n.data.buffer), n;
          if (Array.isArray(n)) {
            const p = [];
            for (const f of n) p.push(zo(f, t));
            return p
          }
          if (typeof n != "object") throw new Error("can't serialize object of type " + typeof n);
          const i = Eo(n);
          if (!i) throw new Error(`can't serialize object of unregistered class ${n.constructor.name}`);
          if (!Pa[i]) throw new Error(`${i} is not registered.`);
          const {
            klass: a
          } = Pa[i], u = a.serialize ? a.serialize(n, t) : {};
          if (a.serialize) {
            if (t && u === t[t.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property")
          } else {
            for (const p in n) {
              if (!n.hasOwnProperty(p) || Pa[i].omit.indexOf(p) >= 0) continue;
              const f = n[p];
              u[p] = Pa[i].shallow.indexOf(p) >= 0 ? f : zo(f, t)
            }
            n instanceof Error && (u.message = n.message)
          }
          if (u.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return i !== "Object" && (u.$name = i), u
        }

        function Ks(n) {
          if (Zc(n)) return n;
          if (Array.isArray(n)) return n.map(Ks);
          if (typeof n != "object") throw new Error("can't deserialize object of type " + typeof n);
          const t = Eo(n) || "Object";
          if (!Pa[t]) throw new Error(`can't deserialize unregistered class ${t}`);
          const {
            klass: i
          } = Pa[t];
          if (!i) throw new Error(`can't deserialize unregistered class ${t}`);
          if (i.deserialize) return i.deserialize(n);
          const a = Object.create(i.prototype);
          for (const u of Object.keys(n)) {
            if (u === "$name") continue;
            const p = n[u];
            a[u] = Pa[t].shallow.indexOf(u) >= 0 ? p : Ks(p)
          }
          return a
        }
        class $c {
          constructor() {
            this.first = !0
          }
          update(t, i) {
            const a = Math.floor(t);
            return this.first ? (this.first = !1, this.lastIntegerZoom = a, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = a, !0) : (this.lastFloorZoom > a ? (this.lastIntegerZoom = a + 1, this.lastIntegerZoomTime = i) : this.lastFloorZoom < a && (this.lastIntegerZoom = a, this.lastIntegerZoomTime = i), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = a, !0))
          }
        }
        const li = {
          "Latin-1 Supplement": n => n >= 128 && n <= 255,
          "Hangul Jamo": n => n >= 4352 && n <= 4607,
          Khmer: n => n >= 6016 && n <= 6143,
          "General Punctuation": n => n >= 8192 && n <= 8303,
          "Letterlike Symbols": n => n >= 8448 && n <= 8527,
          "Number Forms": n => n >= 8528 && n <= 8591,
          "Miscellaneous Technical": n => n >= 8960 && n <= 9215,
          "Control Pictures": n => n >= 9216 && n <= 9279,
          "Optical Character Recognition": n => n >= 9280 && n <= 9311,
          "Enclosed Alphanumerics": n => n >= 9312 && n <= 9471,
          "Geometric Shapes": n => n >= 9632 && n <= 9727,
          "Miscellaneous Symbols": n => n >= 9728 && n <= 9983,
          "Miscellaneous Symbols and Arrows": n => n >= 11008 && n <= 11263,
          "Ideographic Description Characters": n => n >= 12272 && n <= 12287,
          "CJK Symbols and Punctuation": n => n >= 12288 && n <= 12351,
          Hiragana: n => n >= 12352 && n <= 12447,
          Katakana: n => n >= 12448 && n <= 12543,
          Kanbun: n => n >= 12688 && n <= 12703,
          "CJK Strokes": n => n >= 12736 && n <= 12783,
          "Enclosed CJK Letters and Months": n => n >= 12800 && n <= 13055,
          "CJK Compatibility": n => n >= 13056 && n <= 13311,
          "Yijing Hexagram Symbols": n => n >= 19904 && n <= 19967,
          "CJK Unified Ideographs": n => n >= 19968 && n <= 40959,
          "Hangul Syllables": n => n >= 44032 && n <= 55215,
          "Private Use Area": n => n >= 57344 && n <= 63743,
          "Vertical Forms": n => n >= 65040 && n <= 65055,
          "CJK Compatibility Forms": n => n >= 65072 && n <= 65103,
          "Small Form Variants": n => n >= 65104 && n <= 65135,
          "Halfwidth and Fullwidth Forms": n => n >= 65280 && n <= 65519
        };

        function Uc(n) {
          for (const t of n)
            if (Ml(t.charCodeAt(0))) return !0;
          return !1
        }

        function Xh(n) {
          for (const t of n)
            if (!_p(t.charCodeAt(0))) return !1;
          return !0
        }

        function Il(n) {
          const t = n.map((i => {
            try {
              return new RegExp(`\\p{sc=${i}}`, "u").source
            } catch {
              return null
            }
          })).filter((i => i));
          return new RegExp(t.join("|"), "u")
        }
        const mp = Il(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);

        function _p(n) {
          return !mp.test(String.fromCodePoint(n))
        }
        const Gc = Il(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);

        function Ml(n) {
          return !(n !== 746 && n !== 747 && (n < 4352 || !(li["CJK Compatibility Forms"](n) && !(n >= 65097 && n <= 65103) || li["CJK Compatibility"](n) || li["CJK Strokes"](n) || !(!li["CJK Symbols and Punctuation"](n) || n >= 12296 && n <= 12305 || n >= 12308 && n <= 12319 || n === 12336) || li["Enclosed CJK Letters and Months"](n) || li["Ideographic Description Characters"](n) || li.Kanbun(n) || li.Katakana(n) && n !== 12540 || !(!li["Halfwidth and Fullwidth Forms"](n) || n === 65288 || n === 65289 || n === 65293 || n >= 65306 && n <= 65310 || n === 65339 || n === 65341 || n === 65343 || n >= 65371 && n <= 65503 || n === 65507 || n >= 65512 && n <= 65519) || !(!li["Small Form Variants"](n) || n >= 65112 && n <= 65118 || n >= 65123 && n <= 65126) || li["Vertical Forms"](n) || li["Yijing Hexagram Symbols"](n) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(n)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(n)) || Gc.test(String.fromCodePoint(n)))))
        }

        function Hc(n) {
          return !(Ml(n) || (function(t) {
            return !!(li["Latin-1 Supplement"](t) && (t === 167 || t === 169 || t === 174 || t === 177 || t === 188 || t === 189 || t === 190 || t === 215 || t === 247) || li["General Punctuation"](t) && (t === 8214 || t === 8224 || t === 8225 || t === 8240 || t === 8241 || t === 8251 || t === 8252 || t === 8258 || t === 8263 || t === 8264 || t === 8265 || t === 8273) || li["Letterlike Symbols"](t) || li["Number Forms"](t) || li["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || t === 9003 || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || t === 9167 || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || li["Control Pictures"](t) && t !== 9251 || li["Optical Character Recognition"](t) || li["Enclosed Alphanumerics"](t) || li["Geometric Shapes"](t) || li["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || li["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || li["CJK Symbols and Punctuation"](t) || li.Katakana(t) || li["Private Use Area"](t) || li["CJK Compatibility Forms"](t) || li["Small Form Variants"](t) || li["Halfwidth and Fullwidth Forms"](t) || t === 8734 || t === 8756 || t === 8757 || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || t === 65532 || t === 65533)
          })(n))
        }
        const Kh = Il(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);

        function Lo(n) {
          return Kh.test(String.fromCodePoint(n))
        }

        function gp(n, t) {
          return !(!t && Lo(n) || n >= 2304 && n <= 3583 || n >= 3840 && n <= 4255 || li.Khmer(n))
        }

        function Wc(n) {
          for (const t of n)
            if (Lo(t.charCodeAt(0))) return !0;
          return !1
        }
        const Xa = new class {
          constructor() {
            this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {}
          }
          setState(n) {
            this.pluginStatus = n.pluginStatus, this.pluginURL = n.pluginURL
          }
          getState() {
            return {
              pluginStatus: this.pluginStatus,
              pluginURL: this.pluginURL
            }
          }
          setMethods(n) {
            if (Xa.isParsed()) throw new Error("RTL text plugin already registered.");
            this.applyArabicShaping = n.applyArabicShaping, this.processBidirectionalText = n.processBidirectionalText, this.processStyledBidirectionalText = n.processStyledBidirectionalText, this.loadScriptResolve()
          }
          isParsed() {
            return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus
          }
          syncState(n, t) {
            return o(this, void 0, void 0, (function*() {
              if (this.isParsed()) return this.getState();
              if (n.pluginStatus !== "loading") return this.setState(n), n;
              const i = n.pluginURL,
                a = new Promise((p => {
                  this.loadScriptResolve = p
                }));
              t(i);
              const u = new Promise((p => setTimeout((() => p()), this.TIMEOUT)));
              if (yield Promise.race([a, u]), this.isParsed()) {
                const p = {
                  pluginStatus: "loaded",
                  pluginURL: i
                };
                return this.setState(p), p
              }
              throw this.setState({
                pluginStatus: "error",
                pluginURL: ""
              }), new Error(`RTL Text Plugin failed to import scripts from ${i}`)
            }))
          }
        };
        class Bi {
          constructor(t, i) {
            this.zoom = t, i ? (this.now = i.now || 0, this.fadeDuration = i.fadeDuration || 0, this.zoomHistory = i.zoomHistory || new $c, this.transition = i.transition || {}, this.globalState = i.globalState || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new $c, this.transition = {}, this.globalState = {})
          }
          isSupportedScript(t) {
            return (function(i, a) {
              for (const u of i)
                if (!gp(u.charCodeAt(0), a)) return !1;
              return !0
            })(t, Xa.getRTLTextPluginStatus() === "loaded")
          }
          crossFadingFactor() {
            return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1)
          }
          getCrossfadeParameters() {
            const t = this.zoom,
              i = t - Math.floor(t),
              a = this.crossFadingFactor();
            return t > this.zoomHistory.lastIntegerZoom ? {
              fromScale: 2,
              toScale: 1,
              t: i + (1 - i) * a
            } : {
              fromScale: .5,
              toScale: 1,
              t: 1 - (1 - a) * i
            }
          }
        }
        class Do {
          constructor(t, i) {
            this.property = t, this.value = i, this.expression = (function(a, u) {
              if (fs(a)) return new So(a, u);
              if (_l(a)) {
                const p = Dc(a, u);
                if (p.result === "error") throw new Error(p.value.map((f => `${f.key}: ${f.message}`)).join(", "));
                return p.value
              } {
                let p = a;
                return u.type === "color" && typeof a == "string" ? p = ni.parse(a) : u.type !== "padding" || typeof a != "number" && !Array.isArray(a) ? u.type !== "numberArray" || typeof a != "number" && !Array.isArray(a) ? u.type !== "colorArray" || typeof a != "string" && !Array.isArray(a) ? u.type === "variableAnchorOffsetCollection" && Array.isArray(a) ? p = di.parse(a) : u.type === "projectionDefinition" && typeof a == "string" && (p = Hr.parse(a)) : p = dn.parse(a) : p = hn.parse(a) : p = Oi.parse(a), {
                  globalStateRefs: new Set,
                  kind: "constant",
                  evaluate: () => p
                }
              }
            })(i === void 0 ? t.specification.default : i, t.specification)
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite"
          }
          getGlobalStateRefs() {
            return this.expression.globalStateRefs || new Set
          }
          possiblyEvaluate(t, i, a) {
            return this.property.possiblyEvaluate(this, t, i, a)
          }
        }
        class Al {
          constructor(t) {
            this.property = t, this.value = new Do(t, void 0)
          }
          transitioned(t, i) {
            return new Yh(this.property, this.value, i, St({}, t.transition, this.transition), t.now)
          }
          untransitioned() {
            return new Yh(this.property, this.value, null, {}, 0)
          }
        }
        class Xc {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues)
          }
          getValue(t) {
            return gr(this._values[t].value.value)
          }
          setValue(t, i) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new Al(this._values[t].property)), this._values[t].value = new Do(this._values[t].property, i === null ? void 0 : gr(i))
          }
          getTransition(t) {
            return gr(this._values[t].transition)
          }
          setTransition(t, i) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new Al(this._values[t].property)), this._values[t].transition = gr(i) || void 0
          }
          serialize() {
            const t = {};
            for (const i of Object.keys(this._values)) {
              const a = this.getValue(i);
              a !== void 0 && (t[i] = a);
              const u = this.getTransition(i);
              u !== void 0 && (t[`${i}-transition`] = u)
            }
            return t
          }
          transitioned(t, i) {
            const a = new Jh(this._properties);
            for (const u of Object.keys(this._values)) a._values[u] = this._values[u].transitioned(t, i._values[u]);
            return a
          }
          untransitioned() {
            const t = new Jh(this._properties);
            for (const i of Object.keys(this._values)) t._values[i] = this._values[i].untransitioned();
            return t
          }
        }
        class Yh {
          constructor(t, i, a, u, p) {
            this.property = t, this.value = i, this.begin = p + u.delay || 0, this.end = this.begin + u.duration || 0, t.specification.transition && (u.delay || u.duration) && (this.prior = a)
          }
          possiblyEvaluate(t, i, a) {
            const u = t.now || 0,
              p = this.value.possiblyEvaluate(t, i, a),
              f = this.prior;
            if (f) {
              if (u > this.end) return this.prior = null, p;
              if (this.value.isDataDriven()) return this.prior = null, p;
              if (u < this.begin) return f.possiblyEvaluate(t, i, a);
              {
                const g = (u - this.begin) / (this.end - this.begin);
                return this.property.interpolate(f.possiblyEvaluate(t, i, a), p, Bt(g))
              }
            }
            return p
          }
        }
        class Jh {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues)
          }
          possiblyEvaluate(t, i, a) {
            const u = new kl(this._properties);
            for (const p of Object.keys(this._values)) u._values[p] = this._values[p].possiblyEvaluate(t, i, a);
            return u
          }
          hasTransition() {
            for (const t of Object.keys(this._values))
              if (this._values[t].prior) return !0;
            return !1
          }
        }
        class vp {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultPropertyValues)
          }
          hasValue(t) {
            return this._values[t].value !== void 0
          }
          getValue(t) {
            return gr(this._values[t].value)
          }
          setValue(t, i) {
            this._values[t] = new Do(this._values[t].property, i === null ? void 0 : gr(i))
          }
          serialize() {
            const t = {};
            for (const i of Object.keys(this._values)) {
              const a = this.getValue(i);
              a !== void 0 && (t[i] = a)
            }
            return t
          }
          possiblyEvaluate(t, i, a) {
            const u = new kl(this._properties);
            for (const p of Object.keys(this._values)) u._values[p] = this._values[p].possiblyEvaluate(t, i, a);
            return u
          }
        }
        class Ia {
          constructor(t, i, a) {
            this.property = t, this.value = i, this.parameters = a
          }
          isConstant() {
            return this.value.kind === "constant"
          }
          constantOr(t) {
            return this.value.kind === "constant" ? this.value.value : t
          }
          evaluate(t, i, a, u) {
            return this.property.evaluate(this.value, this.parameters, t, i, a, u)
          }
        }
        class kl {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues)
          }
          get(t) {
            return this._values[t]
          }
        }
        class ar {
          constructor(t) {
            this.specification = t
          }
          possiblyEvaluate(t, i) {
            if (t.isDataDriven()) throw new Error("Value should not be data driven");
            return t.expression.evaluate(i)
          }
          interpolate(t, i, a) {
            const u = ta[this.specification.type];
            return u ? u(t, i, a) : t
          }
        }
        class Lr {
          constructor(t, i) {
            this.specification = t, this.overrides = i
          }
          possiblyEvaluate(t, i, a, u) {
            return new Ia(this, t.expression.kind === "constant" || t.expression.kind === "camera" ? {
              kind: "constant",
              value: t.expression.evaluate(i, null, {}, a, u)
            } : t.expression, i)
          }
          interpolate(t, i, a) {
            if (t.value.kind !== "constant" || i.value.kind !== "constant") return t;
            if (t.value.value === void 0 || i.value.value === void 0) return new Ia(this, {
              kind: "constant",
              value: void 0
            }, t.parameters);
            const u = ta[this.specification.type];
            if (u) {
              const p = u(t.value.value, i.value.value, a);
              return new Ia(this, {
                kind: "constant",
                value: p
              }, t.parameters)
            }
            return t
          }
          evaluate(t, i, a, u, p, f) {
            return t.kind === "constant" ? t.value : t.evaluate(i, a, u, p, f)
          }
        }
        class El extends Lr {
          possiblyEvaluate(t, i, a, u) {
            if (t.value === void 0) return new Ia(this, {
              kind: "constant",
              value: void 0
            }, i);
            if (t.expression.kind === "constant") {
              const p = t.expression.evaluate(i, null, {}, a, u),
                f = t.property.specification.type === "resolvedImage" && typeof p != "string" ? p.name : p,
                g = this._calculate(f, f, f, i);
              return new Ia(this, {
                kind: "constant",
                value: g
              }, i)
            }
            if (t.expression.kind === "camera") {
              const p = this._calculate(t.expression.evaluate({
                zoom: i.zoom - 1
              }), t.expression.evaluate({
                zoom: i.zoom
              }), t.expression.evaluate({
                zoom: i.zoom + 1
              }), i);
              return new Ia(this, {
                kind: "constant",
                value: p
              }, i)
            }
            return new Ia(this, t.expression, i)
          }
          evaluate(t, i, a, u, p, f) {
            if (t.kind === "source") {
              const g = t.evaluate(i, a, u, p, f);
              return this._calculate(g, g, g, i)
            }
            return t.kind === "composite" ? this._calculate(t.evaluate({
              zoom: Math.floor(i.zoom) - 1
            }, a, u), t.evaluate({
              zoom: Math.floor(i.zoom)
            }, a, u), t.evaluate({
              zoom: Math.floor(i.zoom) + 1
            }, a, u), i) : t.value
          }
          _calculate(t, i, a, u) {
            return u.zoom > u.zoomHistory.lastIntegerZoom ? {
              from: t,
              to: i
            } : {
              from: a,
              to: i
            }
          }
          interpolate(t) {
            return t
          }
        }
        class Kc {
          constructor(t) {
            this.specification = t
          }
          possiblyEvaluate(t, i, a, u) {
            if (t.value !== void 0) {
              if (t.expression.kind === "constant") {
                const p = t.expression.evaluate(i, null, {}, a, u);
                return this._calculate(p, p, p, i)
              }
              return this._calculate(t.expression.evaluate(new Bi(Math.floor(i.zoom - 1), i)), t.expression.evaluate(new Bi(Math.floor(i.zoom), i)), t.expression.evaluate(new Bi(Math.floor(i.zoom + 1), i)), i)
            }
          }
          _calculate(t, i, a, u) {
            return u.zoom > u.zoomHistory.lastIntegerZoom ? {
              from: t,
              to: i
            } : {
              from: a,
              to: i
            }
          }
          interpolate(t) {
            return t
          }
        }
        class Ro {
          constructor(t) {
            this.specification = t
          }
          possiblyEvaluate(t, i, a, u) {
            return !!t.expression.evaluate(i, null, {}, a, u)
          }
          interpolate() {
            return !1
          }
        }
        class Fn {
          constructor(t) {
            this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const i in t) {
              const a = t[i];
              a.specification.overridable && this.overridableProperties.push(i);
              const u = this.defaultPropertyValues[i] = new Do(a, void 0),
                p = this.defaultTransitionablePropertyValues[i] = new Al(a);
              this.defaultTransitioningPropertyValues[i] = p.untransitioned(), this.defaultPossiblyEvaluatedValues[i] = u.possiblyEvaluate({})
            }
          }
        }
        Wt("DataDrivenProperty", Lr), Wt("DataConstantProperty", ar), Wt("CrossFadedDataDrivenProperty", El), Wt("CrossFadedProperty", Kc), Wt("ColorRampProperty", Ro);
        const Qh = "-transition";
        class wn extends We {
          constructor(t, i) {
            if (super(), this.id = t.id, this.type = t.type, this._featureFilter = {
                filter: () => !0,
                needGeometry: !1,
                getGlobalStateRefs: () => new Set
              }, t.type !== "custom" && (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, t.type !== "background" && (this.source = t.source, this.sourceLayer = t["source-layer"], this.filter = t.filter, this._featureFilter = Ha(t.filter)), i.layout && (this._unevaluatedLayout = new vp(i.layout)), i.paint)) {
              this._transitionablePaint = new Xc(i.paint);
              for (const a in t.paint) this.setPaintProperty(a, t.paint[a], {
                validate: !1
              });
              for (const a in t.layout) this.setLayoutProperty(a, t.layout[a], {
                validate: !1
              });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new kl(i.paint)
            }
          }
          setFilter(t) {
            this.filter = t, this._featureFilter = Ha(t)
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters
          }
          getLayoutProperty(t) {
            return t === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t)
          }
          getLayoutAffectingGlobalStateRefs() {
            const t = new Set;
            if (this._unevaluatedLayout)
              for (const i in this._unevaluatedLayout._values) {
                const a = this._unevaluatedLayout._values[i];
                for (const u of a.getGlobalStateRefs()) t.add(u)
              }
            for (const i of this._featureFilter.getGlobalStateRefs()) t.add(i);
            return t
          }
          setLayoutProperty(t, i, a = {}) {
            i != null && this._validate(qc, `layers.${this.id}.layout.${t}`, t, i, a) || (t !== "visibility" ? this._unevaluatedLayout.setValue(t, i) : this.visibility = i)
          }
          getPaintProperty(t) {
            return t.endsWith(Qh) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t)
          }
          setPaintProperty(t, i, a = {}) {
            if (i != null && this._validate(fp, `layers.${this.id}.paint.${t}`, t, i, a)) return !1;
            if (t.endsWith(Qh)) return this._transitionablePaint.setTransition(t.slice(0, -11), i || void 0), !1;
            {
              const u = this._transitionablePaint._values[t],
                p = u.property.specification["property-type"] === "cross-faded-data-driven",
                f = u.value.isDataDriven(),
                g = u.value;
              this._transitionablePaint.setValue(t, i), this._handleSpecialPaintPropertyUpdate(t);
              const x = this._transitionablePaint._values[t].value;
              return x.isDataDriven() || f || p || this._handleOverridablePaintPropertyUpdate(t, g, x)
            }
          }
          _handleSpecialPaintPropertyUpdate(t) {}
          _handleOverridablePaintPropertyUpdate(t, i, a) {
            return !1
          }
          isHidden(t) {
            return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || this.visibility === "none"
          }
          updateTransitions(t) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint)
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition()
          }
          recalculate(t, i) {
            t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, i)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, i)
          }
          serialize() {
            const t = {
              id: this.id,
              type: this.type,
              source: this.source,
              "source-layer": this.sourceLayer,
              metadata: this.metadata,
              minzoom: this.minzoom,
              maxzoom: this.maxzoom,
              filter: this.filter,
              layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
              paint: this._transitionablePaint && this._transitionablePaint.serialize()
            };
            return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), Gt(t, ((i, a) => !(i === void 0 || a === "layout" && !Object.keys(i).length || a === "paint" && !Object.keys(i).length)))
          }
          _validate(t, i, a, u, p = {}) {
            return (!p || p.validate !== !1) && ko(this, t.call(Ws, {
              key: i,
              layerType: this.type,
              objectKey: a,
              value: u,
              styleSpec: ve,
              style: {
                glyphs: !0,
                sprite: !0
              }
            }))
          }
          is3D() {
            return !1
          }
          isTileClipped() {
            return !1
          }
          hasOffscreenPass() {
            return !1
          }
          resize() {}
          isStateDependent() {
            for (const t in this.paint._values) {
              const i = this.paint.get(t);
              if (i instanceof Ia && Ns(i.property.specification) && (i.value.kind === "source" || i.value.kind === "composite") && i.value.isStateDependent) return !0
            }
            return !1
          }
        }
        const ed = {
          Int8: Int8Array,
          Uint8: Uint8Array,
          Int16: Int16Array,
          Uint16: Uint16Array,
          Int32: Int32Array,
          Uint32: Uint32Array,
          Float32: Float32Array
        };
        class ms {
          constructor(t, i) {
            this._structArray = t, this._pos1 = i * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8
          }
        }
        class ji {
          constructor() {
            this.isTransferred = !1, this.capacity = -1, this.resize(0)
          }
          static serialize(t, i) {
            return t._trim(), i && (t.isTransferred = !0, i.push(t.arrayBuffer)), {
              length: t.length,
              arrayBuffer: t.arrayBuffer
            }
          }
          static deserialize(t) {
            const i = Object.create(this.prototype);
            return i.arrayBuffer = t.arrayBuffer, i.length = t.length, i.capacity = t.arrayBuffer.byteLength / i.bytesPerElement, i._refreshViews(), i
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews())
          }
          clear() {
            this.length = 0
          }
          resize(t) {
            this.reserve(t), this.length = t
          }
          reserve(t) {
            if (t > this.capacity) {
              this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const i = this.uint8;
              this._refreshViews(), i && this.uint8.set(i)
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout")
          }
        }

        function Ui(n, t = 1) {
          let i = 0,
            a = 0;
          return {
            members: n.map((u => {
              const p = ed[u.type].BYTES_PER_ELEMENT,
                f = i = td(i, Math.max(t, p)),
                g = u.components || 1;
              return a = Math.max(a, p), i += p * g, {
                name: u.name,
                type: u.type,
                components: g,
                offset: f
              }
            })),
            size: td(i, Math.max(a, t)),
            alignment: t
          }
        }

        function td(n, t) {
          return Math.ceil(n / t) * t
        }
        class Ka extends ji {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, i) {
            const a = this.length;
            return this.resize(a + 1), this.emplace(a, t, i)
          }
          emplace(t, i, a) {
            const u = 2 * t;
            return this.int16[u + 0] = i, this.int16[u + 1] = a, t
          }
        }
        Ka.prototype.bytesPerElement = 4, Wt("StructArrayLayout2i4", Ka);
        class Ya extends ji {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, i, a) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, t, i, a)
          }
          emplace(t, i, a, u) {
            const p = 3 * t;
            return this.int16[p + 0] = i, this.int16[p + 1] = a, this.int16[p + 2] = u, t
          }
        }
        Ya.prototype.bytesPerElement = 6, Wt("StructArrayLayout3i6", Ya);
        class Yc extends ji {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, i, a, u) {
            const p = this.length;
            return this.resize(p + 1), this.emplace(p, t, i, a, u)
          }
          emplace(t, i, a, u, p) {
            const f = 4 * t;
            return this.int16[f + 0] = i, this.int16[f + 1] = a, this.int16[f + 2] = u, this.int16[f + 3] = p, t
          }
        }
        Yc.prototype.bytesPerElement = 8, Wt("StructArrayLayout4i8", Yc);
        class zl extends ji {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, i, a, u, p, f) {
            const g = this.length;
            return this.resize(g + 1), this.emplace(g, t, i, a, u, p, f)
          }
          emplace(t, i, a, u, p, f, g) {
            const x = 6 * t;
            return this.int16[x + 0] = i, this.int16[x + 1] = a, this.int16[x + 2] = u, this.int16[x + 3] = p, this.int16[x + 4] = f, this.int16[x + 5] = g, t
          }
        }
        zl.prototype.bytesPerElement = 12, Wt("StructArrayLayout2i4i12", zl);
        class _s extends ji {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, i, a, u, p, f) {
            const g = this.length;
            return this.resize(g + 1), this.emplace(g, t, i, a, u, p, f)
          }
          emplace(t, i, a, u, p, f, g) {
            const x = 4 * t,
              S = 8 * t;
            return this.int16[x + 0] = i, this.int16[x + 1] = a, this.uint8[S + 4] = u, this.uint8[S + 5] = p, this.uint8[S + 6] = f, this.uint8[S + 7] = g, t
          }
        }
        _s.prototype.bytesPerElement = 8, Wt("StructArrayLayout2i4ub8", _s);
        class Bo extends ji {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, i) {
            const a = this.length;
            return this.resize(a + 1), this.emplace(a, t, i)
          }
          emplace(t, i, a) {
            const u = 2 * t;
            return this.float32[u + 0] = i, this.float32[u + 1] = a, t
          }
        }
        Bo.prototype.bytesPerElement = 8, Wt("StructArrayLayout2f8", Bo);
        class Jc extends ji {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, i, a, u, p, f, g, x, S, I) {
            const k = this.length;
            return this.resize(k + 1), this.emplace(k, t, i, a, u, p, f, g, x, S, I)
          }
          emplace(t, i, a, u, p, f, g, x, S, I, k) {
            const R = 10 * t;
            return this.uint16[R + 0] = i, this.uint16[R + 1] = a, this.uint16[R + 2] = u, this.uint16[R + 3] = p, this.uint16[R + 4] = f, this.uint16[R + 5] = g, this.uint16[R + 6] = x, this.uint16[R + 7] = S, this.uint16[R + 8] = I, this.uint16[R + 9] = k, t
          }
        }
        Jc.prototype.bytesPerElement = 20, Wt("StructArrayLayout10ui20", Jc);
        class Ll extends ji {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, i, a, u, p, f, g, x, S, I, k, R) {
            const N = this.length;
            return this.resize(N + 1), this.emplace(N, t, i, a, u, p, f, g, x, S, I, k, R)
          }
          emplace(t, i, a, u, p, f, g, x, S, I, k, R, N) {
            const q = 12 * t;
            return this.int16[q + 0] = i, this.int16[q + 1] = a, this.int16[q + 2] = u, this.int16[q + 3] = p, this.uint16[q + 4] = f, this.uint16[q + 5] = g, this.uint16[q + 6] = x, this.uint16[q + 7] = S, this.int16[q + 8] = I, this.int16[q + 9] = k, this.int16[q + 10] = R, this.int16[q + 11] = N, t
          }
        }
        Ll.prototype.bytesPerElement = 24, Wt("StructArrayLayout4i4ui4i24", Ll);
        class Qc extends ji {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, i, a) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, t, i, a)
          }
          emplace(t, i, a, u) {
            const p = 3 * t;
            return this.float32[p + 0] = i, this.float32[p + 1] = a, this.float32[p + 2] = u, t
          }
        }
        Qc.prototype.bytesPerElement = 12, Wt("StructArrayLayout3f12", Qc);
        class h extends ji {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer)
          }
          emplaceBack(t) {
            const i = this.length;
            return this.resize(i + 1), this.emplace(i, t)
          }
          emplace(t, i) {
            return this.uint32[1 * t + 0] = i, t
          }
        }
        h.prototype.bytesPerElement = 4, Wt("StructArrayLayout1ul4", h);
        class e extends ji {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, i, a, u, p, f, g, x, S) {
            const I = this.length;
            return this.resize(I + 1), this.emplace(I, t, i, a, u, p, f, g, x, S)
          }
          emplace(t, i, a, u, p, f, g, x, S, I) {
            const k = 10 * t,
              R = 5 * t;
            return this.int16[k + 0] = i, this.int16[k + 1] = a, this.int16[k + 2] = u, this.int16[k + 3] = p, this.int16[k + 4] = f, this.int16[k + 5] = g, this.uint32[R + 3] = x, this.uint16[k + 8] = S, this.uint16[k + 9] = I, t
          }
        }
        e.prototype.bytesPerElement = 20, Wt("StructArrayLayout6i1ul2ui20", e);
        class r extends ji {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, i, a, u, p, f) {
            const g = this.length;
            return this.resize(g + 1), this.emplace(g, t, i, a, u, p, f)
          }
          emplace(t, i, a, u, p, f, g) {
            const x = 6 * t;
            return this.int16[x + 0] = i, this.int16[x + 1] = a, this.int16[x + 2] = u, this.int16[x + 3] = p, this.int16[x + 4] = f, this.int16[x + 5] = g, t
          }
        }
        r.prototype.bytesPerElement = 12, Wt("StructArrayLayout2i2i2i12", r);
        class s extends ji {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, i, a, u, p) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, t, i, a, u, p)
          }
          emplace(t, i, a, u, p, f) {
            const g = 4 * t,
              x = 8 * t;
            return this.float32[g + 0] = i, this.float32[g + 1] = a, this.float32[g + 2] = u, this.int16[x + 6] = p, this.int16[x + 7] = f, t
          }
        }
        s.prototype.bytesPerElement = 16, Wt("StructArrayLayout2f1f2i16", s);
        class c extends ji {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
          }
          emplaceBack(t, i, a, u, p, f) {
            const g = this.length;
            return this.resize(g + 1), this.emplace(g, t, i, a, u, p, f)
          }
          emplace(t, i, a, u, p, f, g) {
            const x = 16 * t,
              S = 4 * t,
              I = 8 * t;
            return this.uint8[x + 0] = i, this.uint8[x + 1] = a, this.float32[S + 1] = u, this.float32[S + 2] = p, this.int16[I + 6] = f, this.int16[I + 7] = g, t
          }
        }
        c.prototype.bytesPerElement = 16, Wt("StructArrayLayout2ub2f2i16", c);
        class d extends ji {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, i, a) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, t, i, a)
          }
          emplace(t, i, a, u) {
            const p = 3 * t;
            return this.uint16[p + 0] = i, this.uint16[p + 1] = a, this.uint16[p + 2] = u, t
          }
        }
        d.prototype.bytesPerElement = 6, Wt("StructArrayLayout3ui6", d);
        class m extends ji {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, i, a, u, p, f, g, x, S, I, k, R, N, q, U, J, ae) {
            const ke = this.length;
            return this.resize(ke + 1), this.emplace(ke, t, i, a, u, p, f, g, x, S, I, k, R, N, q, U, J, ae)
          }
          emplace(t, i, a, u, p, f, g, x, S, I, k, R, N, q, U, J, ae, ke) {
            const _e = 24 * t,
              O = 12 * t,
              Y = 48 * t;
            return this.int16[_e + 0] = i, this.int16[_e + 1] = a, this.uint16[_e + 2] = u, this.uint16[_e + 3] = p, this.uint32[O + 2] = f, this.uint32[O + 3] = g, this.uint32[O + 4] = x, this.uint16[_e + 10] = S, this.uint16[_e + 11] = I, this.uint16[_e + 12] = k, this.float32[O + 7] = R, this.float32[O + 8] = N, this.uint8[Y + 36] = q, this.uint8[Y + 37] = U, this.uint8[Y + 38] = J, this.uint32[O + 10] = ae, this.int16[_e + 22] = ke, t
          }
        }
        m.prototype.bytesPerElement = 48, Wt("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", m);
        class v extends ji {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, i, a, u, p, f, g, x, S, I, k, R, N, q, U, J, ae, ke, _e, O, Y, ge, Xe, wt, it, ut, kt, Ct) {
            const zt = this.length;
            return this.resize(zt + 1), this.emplace(zt, t, i, a, u, p, f, g, x, S, I, k, R, N, q, U, J, ae, ke, _e, O, Y, ge, Xe, wt, it, ut, kt, Ct)
          }
          emplace(t, i, a, u, p, f, g, x, S, I, k, R, N, q, U, J, ae, ke, _e, O, Y, ge, Xe, wt, it, ut, kt, Ct, zt) {
            const mt = 32 * t,
              ir = 16 * t;
            return this.int16[mt + 0] = i, this.int16[mt + 1] = a, this.int16[mt + 2] = u, this.int16[mt + 3] = p, this.int16[mt + 4] = f, this.int16[mt + 5] = g, this.int16[mt + 6] = x, this.int16[mt + 7] = S, this.uint16[mt + 8] = I, this.uint16[mt + 9] = k, this.uint16[mt + 10] = R, this.uint16[mt + 11] = N, this.uint16[mt + 12] = q, this.uint16[mt + 13] = U, this.uint16[mt + 14] = J, this.uint16[mt + 15] = ae, this.uint16[mt + 16] = ke, this.uint16[mt + 17] = _e, this.uint16[mt + 18] = O, this.uint16[mt + 19] = Y, this.uint16[mt + 20] = ge, this.uint16[mt + 21] = Xe, this.uint16[mt + 22] = wt, this.uint32[ir + 12] = it, this.float32[ir + 13] = ut, this.float32[ir + 14] = kt, this.uint16[mt + 30] = Ct, this.uint16[mt + 31] = zt, t
          }
        }
        v.prototype.bytesPerElement = 64, Wt("StructArrayLayout8i15ui1ul2f2ui64", v);
        class w extends ji {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t) {
            const i = this.length;
            return this.resize(i + 1), this.emplace(i, t)
          }
          emplace(t, i) {
            return this.float32[1 * t + 0] = i, t
          }
        }
        w.prototype.bytesPerElement = 4, Wt("StructArrayLayout1f4", w);
        class P extends ji {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, i, a) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, t, i, a)
          }
          emplace(t, i, a, u) {
            const p = 3 * t;
            return this.uint16[6 * t + 0] = i, this.float32[p + 1] = a, this.float32[p + 2] = u, t
          }
        }
        P.prototype.bytesPerElement = 12, Wt("StructArrayLayout1ui2f12", P);
        class M extends ji {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, i, a) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, t, i, a)
          }
          emplace(t, i, a, u) {
            const p = 4 * t;
            return this.uint32[2 * t + 0] = i, this.uint16[p + 2] = a, this.uint16[p + 3] = u, t
          }
        }
        M.prototype.bytesPerElement = 8, Wt("StructArrayLayout1ul2ui8", M);
        class D extends ji {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t, i) {
            const a = this.length;
            return this.resize(a + 1), this.emplace(a, t, i)
          }
          emplace(t, i, a) {
            const u = 2 * t;
            return this.uint16[u + 0] = i, this.uint16[u + 1] = a, t
          }
        }
        D.prototype.bytesPerElement = 4, Wt("StructArrayLayout2ui4", D);
        class L extends ji {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
          }
          emplaceBack(t) {
            const i = this.length;
            return this.resize(i + 1), this.emplace(i, t)
          }
          emplace(t, i) {
            return this.uint16[1 * t + 0] = i, t
          }
        }
        L.prototype.bytesPerElement = 2, Wt("StructArrayLayout1ui2", L);
        class B extends ji {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
          }
          emplaceBack(t, i, a, u) {
            const p = this.length;
            return this.resize(p + 1), this.emplace(p, t, i, a, u)
          }
          emplace(t, i, a, u, p) {
            const f = 4 * t;
            return this.float32[f + 0] = i, this.float32[f + 1] = a, this.float32[f + 2] = u, this.float32[f + 3] = p, t
          }
        }
        B.prototype.bytesPerElement = 16, Wt("StructArrayLayout4f16", B);
        class Z extends ms {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2]
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3]
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4]
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5]
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3]
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8]
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9]
          }
          get anchorPoint() {
            return new le(this.anchorPointX, this.anchorPointY)
          }
        }
        Z.prototype.size = 20;
        class te extends e {
          get(t) {
            return new Z(this, t)
          }
        }
        Wt("CollisionBoxArray", te);
        class ee extends ms {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2]
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3]
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2]
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3]
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4]
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10]
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11]
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12]
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7]
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8]
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36]
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37]
          }
          set placedOrientation(t) {
            this._structArray.uint8[this._pos1 + 37] = t
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38]
          }
          set hidden(t) {
            this._structArray.uint8[this._pos1 + 38] = t
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10]
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 10] = t
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22]
          }
        }
        ee.prototype.size = 48;
        class ne extends m {
          get(t) {
            return new ee(this, t)
          }
        }
        Wt("PlacedSymbolArray", ne);
        class oe extends ms {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0]
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1]
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2]
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3]
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4]
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5]
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6]
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7]
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8]
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9]
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10]
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11]
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12]
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13]
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14]
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15]
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16]
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17]
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18]
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19]
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20]
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21]
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22]
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12]
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 12] = t
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13]
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14]
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30]
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31]
          }
        }
        oe.prototype.size = 64;
        class me extends v {
          get(t) {
            return new oe(this, t)
          }
        }
        Wt("SymbolInstanceArray", me);
        class ue extends w {
          getoffsetX(t) {
            return this.float32[1 * t + 0]
          }
        }
        Wt("GlyphOffsetArray", ue);
        class be extends Ya {
          getx(t) {
            return this.int16[3 * t + 0]
          }
          gety(t) {
            return this.int16[3 * t + 1]
          }
          gettileUnitDistanceFromAnchor(t) {
            return this.int16[3 * t + 2]
          }
        }
        Wt("SymbolLineVertexArray", be);
        class Pe extends ms {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0]
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1]
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2]
          }
        }
        Pe.prototype.size = 12;
        class pe extends P {
          get(t) {
            return new Pe(this, t)
          }
        }
        Wt("TextAnchorOffsetArray", pe);
        class Fe extends ms {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0]
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2]
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3]
          }
        }
        Fe.prototype.size = 8;
        class Je extends M {
          get(t) {
            return new Fe(this, t)
          }
        }
        Wt("FeatureIndexArray", Je);
        class Ge extends Ka {}
        class He extends Ka {}
        class Qe extends Ka {}
        class qt extends zl {}
        class Ft extends _s {}
        class Tt extends Bo {}
        class rr extends Jc {}
        class ei extends Ll {}
        class xi extends Qc {}
        class qi extends h {}
        class Si extends r {}
        class Vi extends c {}
        class Mi extends d {}
        class Pi extends D {}
        const Ai = Ui([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: Tn
          } = Ai;
        class pi {
          constructor(t = []) {
            this._forceNewSegmentOnNextPrepare = !1, this.segments = t
          }
          prepareSegment(t, i, a, u) {
            const p = this.segments[this.segments.length - 1];
            return t > pi.MAX_VERTEX_ARRAY_LENGTH && Qt(`Max vertices per segment is ${pi.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${pi.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !p || p.vertexLength + t > pi.MAX_VERTEX_ARRAY_LENGTH || p.sortKey !== u ? this.createNewSegment(i, a, u) : p
          }
          createNewSegment(t, i, a) {
            const u = {
              vertexOffset: t.length,
              primitiveOffset: i.length,
              vertexLength: 0,
              primitiveLength: 0,
              vaos: {}
            };
            return a !== void 0 && (u.sortKey = a), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(u), u
          }
          getOrCreateLatestSegment(t, i, a) {
            return this.prepareSegment(0, t, i, a)
          }
          forceNewSegmentOnNextPrepare() {
            this._forceNewSegmentOnNextPrepare = !0
          }
          get() {
            return this.segments
          }
          destroy() {
            for (const t of this.segments)
              for (const i in t.vaos) t.vaos[i].destroy()
          }
          static simpleSegment(t, i, a, u) {
            return new pi([{
              vertexOffset: t,
              primitiveOffset: i,
              vertexLength: a,
              primitiveLength: u,
              vaos: {},
              sortKey: 0
            }])
          }
        }

        function fn(n, t) {
          return 256 * (n = Mt(Math.floor(n), 0, 255)) + Mt(Math.floor(t), 0, 255)
        }
        pi.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Wt("SegmentVector", pi);
        const Cn = Ui([{
          name: "a_pattern_from",
          components: 4,
          type: "Uint16"
        }, {
          name: "a_pattern_to",
          components: 4,
          type: "Uint16"
        }, {
          name: "a_pixel_ratio_from",
          components: 1,
          type: "Uint16"
        }, {
          name: "a_pixel_ratio_to",
          components: 1,
          type: "Uint16"
        }]);
        var Ja, Qa, es, Ma = {
            exports: {}
          },
          Fo = {
            exports: {}
          },
          Oo = {
            exports: {}
          },
          Ys = (function() {
            if (es) return Ma.exports;
            es = 1;
            var n = (Ja || (Ja = 1, Fo.exports = function(i, a) {
                var u, p, f, g, x, S, I, k;
                for (p = i.length - (u = 3 & i.length), f = a, x = 3432918353, S = 461845907, k = 0; k < p;) I = 255 & i.charCodeAt(k) | (255 & i.charCodeAt(++k)) << 8 | (255 & i.charCodeAt(++k)) << 16 | (255 & i.charCodeAt(++k)) << 24, ++k, f = 27492 + (65535 & (g = 5 * (65535 & (f = (f ^= I = (65535 & (I = (I = (65535 & I) * x + (((I >>> 16) * x & 65535) << 16) & 4294967295) << 15 | I >>> 17)) * S + (((I >>> 16) * S & 65535) << 16) & 4294967295) << 13 | f >>> 19)) + ((5 * (f >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (g >>> 16) & 65535) << 16);
                switch (I = 0, u) {
                  case 3:
                    I ^= (255 & i.charCodeAt(k + 2)) << 16;
                  case 2:
                    I ^= (255 & i.charCodeAt(k + 1)) << 8;
                  case 1:
                    f ^= I = (65535 & (I = (I = (65535 & (I ^= 255 & i.charCodeAt(k))) * x + (((I >>> 16) * x & 65535) << 16) & 4294967295) << 15 | I >>> 17)) * S + (((I >>> 16) * S & 65535) << 16) & 4294967295
                }
                return f ^= i.length, f = 2246822507 * (65535 & (f ^= f >>> 16)) + ((2246822507 * (f >>> 16) & 65535) << 16) & 4294967295, f = 3266489909 * (65535 & (f ^= f >>> 13)) + ((3266489909 * (f >>> 16) & 65535) << 16) & 4294967295, (f ^= f >>> 16) >>> 0
              }), Fo.exports),
              t = (Qa || (Qa = 1, Oo.exports = function(i, a) {
                for (var u, p = i.length, f = a ^ p, g = 0; p >= 4;) u = 1540483477 * (65535 & (u = 255 & i.charCodeAt(g) | (255 & i.charCodeAt(++g)) << 8 | (255 & i.charCodeAt(++g)) << 16 | (255 & i.charCodeAt(++g)) << 24)) + ((1540483477 * (u >>> 16) & 65535) << 16), f = 1540483477 * (65535 & f) + ((1540483477 * (f >>> 16) & 65535) << 16) ^ (u = 1540483477 * (65535 & (u ^= u >>> 24)) + ((1540483477 * (u >>> 16) & 65535) << 16)), p -= 4, ++g;
                switch (p) {
                  case 3:
                    f ^= (255 & i.charCodeAt(g + 2)) << 16;
                  case 2:
                    f ^= (255 & i.charCodeAt(g + 1)) << 8;
                  case 1:
                    f = 1540483477 * (65535 & (f ^= 255 & i.charCodeAt(g))) + ((1540483477 * (f >>> 16) & 65535) << 16)
                }
                return f = 1540483477 * (65535 & (f ^= f >>> 13)) + ((1540483477 * (f >>> 16) & 65535) << 16), (f ^= f >>> 15) >>> 0
              }), Oo.exports);
            return Ma.exports = n, Ma.exports.murmur3 = n, Ma.exports.murmur2 = t, Ma.exports
          })(),
          Hn = K(Ys);
        class ga {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = !1
          }
          add(t, i, a, u) {
            this.ids.push(ts(t)), this.positions.push(i, a, u)
          }
          getPositions(t) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const i = ts(t);
            let a = 0,
              u = this.ids.length - 1;
            for (; a < u;) {
              const f = a + u >> 1;
              this.ids[f] >= i ? u = f : a = f + 1
            }
            const p = [];
            for (; this.ids[a] === i;) p.push({
              index: this.positions[3 * a],
              start: this.positions[3 * a + 1],
              end: this.positions[3 * a + 2]
            }), a++;
            return p
          }
          static serialize(t, i) {
            const a = new Float64Array(t.ids),
              u = new Uint32Array(t.positions);
            return gs(a, u, 0, a.length - 1), i && i.push(a.buffer, u.buffer), {
              ids: a,
              positions: u
            }
          }
          static deserialize(t) {
            const i = new ga;
            return i.ids = t.ids, i.positions = t.positions, i.indexed = !0, i
          }
        }

        function ts(n) {
          const t = +n;
          return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER ? t : Hn(String(n))
        }

        function gs(n, t, i, a) {
          for (; i < a;) {
            const u = n[i + a >> 1];
            let p = i - 1,
              f = a + 1;
            for (;;) {
              do p++; while (n[p] < u);
              do f--; while (n[f] > u);
              if (p >= f) break;
              Wi(n, p, f), Wi(t, 3 * p, 3 * f), Wi(t, 3 * p + 1, 3 * f + 1), Wi(t, 3 * p + 2, 3 * f + 2)
            }
            f - i < a - f ? (gs(n, t, i, f), i = f + 1) : (gs(n, t, f + 1, a), a = f)
          }
        }

        function Wi(n, t, i) {
          const a = n[t];
          n[t] = n[i], n[i] = a
        }
        Wt("FeaturePositionMap", ga);
        class Di {
          constructor(t, i) {
            this.gl = t.gl, this.location = i
          }
        }
        class On extends Di {
          constructor(t, i) {
            super(t, i), this.current = 0
          }
          set(t) {
            this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t))
          }
        }
        class sn extends Di {
          constructor(t, i) {
            super(t, i), this.current = [0, 0, 0, 0]
          }
          set(t) {
            t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]))
          }
        }
        class rd extends Di {
          constructor(t, i) {
            super(t, i), this.current = ni.transparent
          }
          set(t) {
            t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a))
          }
        }
        const yp = new Float32Array(16);

        function eu(n) {
          return [fn(255 * n.r, 255 * n.g), fn(255 * n.b, 255 * n.a)]
        }
        class No {
          constructor(t, i, a) {
            this.value = t, this.uniformNames = i.map((u => `u_${u}`)), this.type = a
          }
          setUniform(t, i, a) {
            t.set(a.constantOr(this.value))
          }
          getBinding(t, i, a) {
            return this.type === "color" ? new rd(t, i) : new On(t, i)
          }
        }
        class Js {
          constructor(t, i) {
            this.uniformNames = i.map((a => `u_${a}`)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1
          }
          setConstantPatternPositions(t, i) {
            this.pixelRatioFrom = i.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = i.tlbr, this.patternTo = t.tlbr
          }
          setUniform(t, i, a, u) {
            const p = u === "u_pattern_to" ? this.patternTo : u === "u_pattern_from" ? this.patternFrom : u === "u_pixel_ratio_to" ? this.pixelRatioTo : u === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
            p && t.set(p)
          }
          getBinding(t, i, a) {
            return a.substr(0, 9) === "u_pattern" ? new sn(t, i) : new On(t, i)
          }
        }
        class Ra {
          constructor(t, i, a, u) {
            this.expression = t, this.type = a, this.maxValue = 0, this.paintVertexAttributes = i.map((p => ({
              name: `a_${p}`,
              type: "Float32",
              components: a === "color" ? 2 : 1,
              offset: 0
            }))), this.paintVertexArray = new u
          }
          populatePaintArray(t, i, a, u, p) {
            const f = this.paintVertexArray.length,
              g = this.expression.evaluate(new Bi(0), i, {}, u, [], p);
            this.paintVertexArray.resize(t), this._setPaintValue(f, t, g)
          }
          updatePaintArray(t, i, a, u) {
            const p = this.expression.evaluate({
              zoom: 0
            }, a, u);
            this._setPaintValue(t, i, p)
          }
          _setPaintValue(t, i, a) {
            if (this.type === "color") {
              const u = eu(a);
              for (let p = t; p < i; p++) this.paintVertexArray.emplace(p, u[0], u[1])
            } else {
              for (let u = t; u < i; u++) this.paintVertexArray.emplace(u, a);
              this.maxValue = Math.max(this.maxValue, Math.abs(a))
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy()
          }
        }
        class Sn {
          constructor(t, i, a, u, p, f) {
            this.expression = t, this.uniformNames = i.map((g => `u_${g}_t`)), this.type = a, this.useIntegerZoom = u, this.zoom = p, this.maxValue = 0, this.paintVertexAttributes = i.map((g => ({
              name: `a_${g}`,
              type: "Float32",
              components: a === "color" ? 4 : 2,
              offset: 0
            }))), this.paintVertexArray = new f
          }
          populatePaintArray(t, i, a, u, p) {
            const f = this.expression.evaluate(new Bi(this.zoom), i, {}, u, [], p),
              g = this.expression.evaluate(new Bi(this.zoom + 1), i, {}, u, [], p),
              x = this.paintVertexArray.length;
            this.paintVertexArray.resize(t), this._setPaintValue(x, t, f, g)
          }
          updatePaintArray(t, i, a, u) {
            const p = this.expression.evaluate({
                zoom: this.zoom
              }, a, u),
              f = this.expression.evaluate({
                zoom: this.zoom + 1
              }, a, u);
            this._setPaintValue(t, i, p, f)
          }
          _setPaintValue(t, i, a, u) {
            if (this.type === "color") {
              const p = eu(a),
                f = eu(u);
              for (let g = t; g < i; g++) this.paintVertexArray.emplace(g, p[0], p[1], f[0], f[1])
            } else {
              for (let p = t; p < i; p++) this.paintVertexArray.emplace(p, a, u);
              this.maxValue = Math.max(this.maxValue, Math.abs(a), Math.abs(u))
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy()
          }
          setUniform(t, i) {
            const a = this.useIntegerZoom ? Math.floor(i.zoom) : i.zoom,
              u = Mt(this.expression.interpolationFactor(a, this.zoom, this.zoom + 1), 0, 1);
            t.set(u)
          }
          getBinding(t, i, a) {
            return new On(t, i)
          }
        }
        class Ba {
          constructor(t, i, a, u, p, f) {
            this.expression = t, this.type = i, this.useIntegerZoom = a, this.zoom = u, this.layerId = f, this.zoomInPaintVertexArray = new p, this.zoomOutPaintVertexArray = new p
          }
          populatePaintArray(t, i, a) {
            const u = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(u, t, i.patterns && i.patterns[this.layerId], a)
          }
          updatePaintArray(t, i, a, u, p) {
            this._setPaintValues(t, i, a.patterns && a.patterns[this.layerId], p)
          }
          _setPaintValues(t, i, a, u) {
            if (!u || !a) return;
            const {
              min: p,
              mid: f,
              max: g
            } = a, x = u[p], S = u[f], I = u[g];
            if (x && S && I)
              for (let k = t; k < i; k++) this.zoomInPaintVertexArray.emplace(k, S.tl[0], S.tl[1], S.br[0], S.br[1], x.tl[0], x.tl[1], x.br[0], x.br[1], S.pixelRatio, x.pixelRatio), this.zoomOutPaintVertexArray.emplace(k, S.tl[0], S.tl[1], S.br[0], S.br[1], I.tl[0], I.tl[1], I.br[0], I.br[1], S.pixelRatio, I.pixelRatio)
          }
          upload(t) {
            this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, Cn.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, Cn.members, this.expression.isStateDependent))
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy()
          }
        }
        class tu {
          constructor(t, i, a) {
            this.binders = {}, this._buffers = [];
            const u = [];
            for (const p in t.paint._values) {
              if (!a(p)) continue;
              const f = t.paint.get(p);
              if (!(f instanceof Ia && Ns(f.property.specification))) continue;
              const g = ru(p, t.type),
                x = f.value,
                S = f.property.specification.type,
                I = f.property.useIntegerZoom,
                k = f.property.specification["property-type"],
                R = k === "cross-faded" || k === "cross-faded-data-driven";
              if (x.kind === "constant") this.binders[p] = R ? new Js(x.value, g) : new No(x.value, g, S), u.push(`/u_${p}`);
              else if (x.kind === "source" || R) {
                const N = iu(p, S, "source");
                this.binders[p] = R ? new Ba(x, S, I, i, N, t.id) : new Ra(x, g, S, N), u.push(`/a_${p}`)
              } else {
                const N = iu(p, S, "composite");
                this.binders[p] = new Sn(x, g, S, I, i, N), u.push(`/z_${p}`)
              }
            }
            this.cacheKey = u.sort().join("")
          }
          getMaxValue(t) {
            const i = this.binders[t];
            return i instanceof Ra || i instanceof Sn ? i.maxValue : 0
          }
          populatePaintArrays(t, i, a, u, p) {
            for (const f in this.binders) {
              const g = this.binders[f];
              (g instanceof Ra || g instanceof Sn || g instanceof Ba) && g.populatePaintArray(t, i, a, u, p)
            }
          }
          setConstantPatternPositions(t, i) {
            for (const a in this.binders) {
              const u = this.binders[a];
              u instanceof Js && u.setConstantPatternPositions(t, i)
            }
          }
          updatePaintArrays(t, i, a, u, p) {
            let f = !1;
            for (const g in t) {
              const x = i.getPositions(g);
              for (const S of x) {
                const I = a.feature(S.index);
                for (const k in this.binders) {
                  const R = this.binders[k];
                  if ((R instanceof Ra || R instanceof Sn || R instanceof Ba) && R.expression.isStateDependent === !0) {
                    const N = u.paint.get(k);
                    R.expression = N.value, R.updatePaintArray(S.start, S.end, I, t[g], p), f = !0
                  }
                }
              }
            }
            return f
          }
          defines() {
            const t = [];
            for (const i in this.binders) {
              const a = this.binders[i];
              (a instanceof No || a instanceof Js) && t.push(...a.uniformNames.map((u => `#define HAS_UNIFORM_${u}`)))
            }
            return t
          }
          getBinderAttributes() {
            const t = [];
            for (const i in this.binders) {
              const a = this.binders[i];
              if (a instanceof Ra || a instanceof Sn)
                for (let u = 0; u < a.paintVertexAttributes.length; u++) t.push(a.paintVertexAttributes[u].name);
              else if (a instanceof Ba)
                for (let u = 0; u < Cn.members.length; u++) t.push(Cn.members[u].name)
            }
            return t
          }
          getBinderUniforms() {
            const t = [];
            for (const i in this.binders) {
              const a = this.binders[i];
              if (a instanceof No || a instanceof Js || a instanceof Sn)
                for (const u of a.uniformNames) t.push(u)
            }
            return t
          }
          getPaintVertexBuffers() {
            return this._buffers
          }
          getUniforms(t, i) {
            const a = [];
            for (const u in this.binders) {
              const p = this.binders[u];
              if (p instanceof No || p instanceof Js || p instanceof Sn) {
                for (const f of p.uniformNames)
                  if (i[f]) {
                    const g = p.getBinding(t, i[f], f);
                    a.push({
                      name: f,
                      property: u,
                      binding: g
                    })
                  }
              }
            }
            return a
          }
          setUniforms(t, i, a, u) {
            for (const {
                name: p,
                property: f,
                binding: g
              }
              of i) this.binders[f].setUniform(g, u, a.get(f), p)
          }
          updatePaintBuffers(t) {
            this._buffers = [];
            for (const i in this.binders) {
              const a = this.binders[i];
              if (t && a instanceof Ba) {
                const u = t.fromScale === 2 ? a.zoomInPaintVertexBuffer : a.zoomOutPaintVertexBuffer;
                u && this._buffers.push(u)
              } else(a instanceof Ra || a instanceof Sn) && a.paintVertexBuffer && this._buffers.push(a.paintVertexBuffer)
            }
          }
          upload(t) {
            for (const i in this.binders) {
              const a = this.binders[i];
              (a instanceof Ra || a instanceof Sn || a instanceof Ba) && a.upload(t)
            }
            this.updatePaintBuffers()
          }
          destroy() {
            for (const t in this.binders) {
              const i = this.binders[t];
              (i instanceof Ra || i instanceof Sn || i instanceof Ba) && i.destroy()
            }
          }
        }
        class rs {
          constructor(t, i, a = () => !0) {
            this.programConfigurations = {};
            for (const u of t) this.programConfigurations[u.id] = new tu(u, i, a);
            this.needsUpload = !1, this._featureMap = new ga, this._bufferOffset = 0
          }
          populatePaintArrays(t, i, a, u, p, f) {
            for (const g in this.programConfigurations) this.programConfigurations[g].populatePaintArrays(t, i, u, p, f);
            i.id !== void 0 && this._featureMap.add(i.id, a, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0
          }
          updatePaintArrays(t, i, a, u) {
            for (const p of a) this.needsUpload = this.programConfigurations[p.id].updatePaintArrays(t, this._featureMap, i, p, u) || this.needsUpload
          }
          get(t) {
            return this.programConfigurations[t]
          }
          upload(t) {
            if (this.needsUpload) {
              for (const i in this.programConfigurations) this.programConfigurations[i].upload(t);
              this.needsUpload = !1
            }
          }
          destroy() {
            for (const t in this.programConfigurations) this.programConfigurations[t].destroy()
          }
        }

        function ru(n, t) {
          return {
            "text-opacity": ["opacity"],
            "icon-opacity": ["opacity"],
            "text-color": ["fill_color"],
            "icon-color": ["fill_color"],
            "text-halo-color": ["halo_color"],
            "icon-halo-color": ["halo_color"],
            "text-halo-blur": ["halo_blur"],
            "icon-halo-blur": ["halo_blur"],
            "text-halo-width": ["halo_width"],
            "icon-halo-width": ["halo_width"],
            "line-gap-width": ["gapwidth"],
            "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
            "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
            "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"]
          } [n] || [n.replace(`${t}-`, "").replace(/-/g, "_")]
        }

        function iu(n, t, i) {
          const a = {
              color: {
                source: Bo,
                composite: B
              },
              number: {
                source: w,
                composite: Bo
              }
            },
            u = (function(p) {
              return {
                "line-pattern": {
                  source: rr,
                  composite: rr
                },
                "fill-pattern": {
                  source: rr,
                  composite: rr
                },
                "fill-extrusion-pattern": {
                  source: rr,
                  composite: rr
                }
              } [p]
            })(n);
          return u && u[i] || a[t][i]
        }
        Wt("ConstantBinder", No), Wt("CrossFadedConstantBinder", Js), Wt("SourceExpressionBinder", Ra), Wt("CrossFadedCompositeBinder", Ba), Wt("CompositeExpressionBinder", Sn), Wt("ProgramConfiguration", tu, {
          omit: ["_buffers"]
        }), Wt("ProgramConfigurationSet", rs);
        const jo = Math.pow(2, 14) - 1,
          km = -jo - 1;

        function qo(n) {
          const t = Ke / n.extent,
            i = n.loadGeometry();
          for (let a = 0; a < i.length; a++) {
            const u = i[a];
            for (let p = 0; p < u.length; p++) {
              const f = u[p],
                g = Math.round(f.x * t),
                x = Math.round(f.y * t);
              f.x = Mt(g, km, jo), f.y = Mt(x, km, jo), (g < f.x || g > f.x + 1 || x < f.y || x > f.y + 1) && Qt("Geometry exceeds allowed extent, reduce your vector tile buffer size")
            }
          }
          return i
        }

        function Vo(n, t) {
          return {
            type: n.type,
            id: n.id,
            properties: n.properties,
            geometry: t ? qo(n) : []
          }
        }
        const Em = -32768;

        function Gv(n, t, i, a, u) {
          n.emplaceBack(Em + 8 * t + a, Em + 8 * i + u)
        }
        class xp {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((i => i.id)), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new He, this.indexArray = new Mi, this.segments = new pi, this.programConfigurations = new rs(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter((i => i.isStateDependent())).map((i => i.id))
          }
          populate(t, i, a) {
            const u = this.layers[0],
              p = [];
            let f = null,
              g = !1,
              x = u.type === "heatmap";
            if (u.type === "circle") {
              const I = u;
              f = I.layout.get("circle-sort-key"), g = !f.isConstant(), x = x || I.paint.get("circle-pitch-alignment") === "map"
            }
            const S = x ? i.subdivisionGranularity.circle : 1;
            for (const {
                feature: I,
                id: k,
                index: R,
                sourceLayerIndex: N
              }
              of t) {
              const q = this.layers[0]._featureFilter.needGeometry,
                U = Vo(I, q);
              if (!this.layers[0]._featureFilter.filter(new Bi(this.zoom, {
                  globalState: this.globalState
                }), U, a)) continue;
              const J = g ? f.evaluate(U, {}, a) : void 0,
                ae = {
                  id: k,
                  properties: I.properties,
                  type: I.type,
                  sourceLayerIndex: N,
                  index: R,
                  geometry: q ? U.geometry : qo(I),
                  patterns: {},
                  sortKey: J
                };
              p.push(ae)
            }
            g && p.sort(((I, k) => I.sortKey - k.sortKey));
            for (const I of p) {
              const {
                geometry: k,
                index: R,
                sourceLayerIndex: N
              } = I, q = t[R].feature;
              this.addFeature(I, k, R, a, S), i.featureIndex.insert(q, k, R, N, this.index)
            }
          }
          update(t, i, a) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, i, this.stateDependentLayers, a)
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Tn), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy())
          }
          addFeature(t, i, a, u, p = 1) {
            let f;
            switch (p) {
              case 1:
                f = [0, 7];
                break;
              case 3:
                f = [0, 2, 5, 7];
                break;
              case 5:
                f = [0, 1, 3, 4, 6, 7];
                break;
              case 7:
                f = [0, 1, 2, 3, 4, 5, 6, 7];
                break;
              default:
                throw new Error(`Invalid circle bucket granularity: ${p}; valid values are 1, 3, 5, 7.`)
            }
            const g = f.length;
            for (const x of i)
              for (const S of x) {
                const I = S.x,
                  k = S.y;
                if (I < 0 || I >= Ke || k < 0 || k >= Ke) continue;
                const R = this.segments.prepareSegment(g * g, this.layoutVertexArray, this.indexArray, t.sortKey),
                  N = R.vertexLength;
                for (let q = 0; q < g; q++)
                  for (let U = 0; U < g; U++) Gv(this.layoutVertexArray, I, k, f[U], f[q]);
                for (let q = 0; q < g - 1; q++)
                  for (let U = 0; U < g - 1; U++) {
                    const J = N + q * g + U,
                      ae = N + (q + 1) * g + U;
                    this.indexArray.emplaceBack(J, ae + 1, J + 1), this.indexArray.emplaceBack(J, ae, ae + 1)
                  }
                R.vertexLength += g * g, R.primitiveLength += (g - 1) * (g - 1) * 2
              }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, a, {}, u)
          }
        }

        function zm(n, t) {
          for (let i = 0; i < n.length; i++)
            if (Dl(t, n[i])) return !0;
          for (let i = 0; i < t.length; i++)
            if (Dl(n, t[i])) return !0;
          return !!bp(n, t)
        }

        function Hv(n, t, i) {
          return !!Dl(n, t) || !!wp(t, n, i)
        }

        function Lm(n, t) {
          if (n.length === 1) return Rm(t, n[0]);
          for (let i = 0; i < t.length; i++) {
            const a = t[i];
            for (let u = 0; u < a.length; u++)
              if (Dl(n, a[u])) return !0
          }
          for (let i = 0; i < n.length; i++)
            if (Rm(t, n[i])) return !0;
          for (let i = 0; i < t.length; i++)
            if (bp(n, t[i])) return !0;
          return !1
        }

        function Wv(n, t, i) {
          if (n.length > 1) {
            if (bp(n, t)) return !0;
            for (let a = 0; a < t.length; a++)
              if (wp(t[a], n, i)) return !0
          }
          for (let a = 0; a < n.length; a++)
            if (wp(n[a], t, i)) return !0;
          return !1
        }

        function bp(n, t) {
          if (n.length === 0 || t.length === 0) return !1;
          for (let i = 0; i < n.length - 1; i++) {
            const a = n[i],
              u = n[i + 1];
            for (let p = 0; p < t.length - 1; p++)
              if (Xv(a, u, t[p], t[p + 1])) return !0
          }
          return !1
        }

        function Xv(n, t, i, a) {
          return er(n, i, a) !== er(t, i, a) && er(n, t, i) !== er(n, t, a)
        }

        function wp(n, t, i) {
          const a = i * i;
          if (t.length === 1) return n.distSqr(t[0]) < a;
          for (let u = 1; u < t.length; u++)
            if (Dm(n, t[u - 1], t[u]) < a) return !0;
          return !1
        }

        function Dm(n, t, i) {
          const a = t.distSqr(i);
          if (a === 0) return n.distSqr(t);
          const u = ((n.x - t.x) * (i.x - t.x) + (n.y - t.y) * (i.y - t.y)) / a;
          return n.distSqr(u < 0 ? t : u > 1 ? i : i.sub(t)._mult(u)._add(t))
        }

        function Rm(n, t) {
          let i, a, u, p = !1;
          for (let f = 0; f < n.length; f++) {
            i = n[f];
            for (let g = 0, x = i.length - 1; g < i.length; x = g++) a = i[g], u = i[x], a.y > t.y != u.y > t.y && t.x < (u.x - a.x) * (t.y - a.y) / (u.y - a.y) + a.x && (p = !p)
          }
          return p
        }

        function Dl(n, t) {
          let i = !1;
          for (let a = 0, u = n.length - 1; a < n.length; u = a++) {
            const p = n[a],
              f = n[u];
            p.y > t.y != f.y > t.y && t.x < (f.x - p.x) * (t.y - p.y) / (f.y - p.y) + p.x && (i = !i)
          }
          return i
        }

        function Kv(n, t, i) {
          const a = i[0],
            u = i[2];
          if (n.x < a.x && t.x < a.x || n.x > u.x && t.x > u.x || n.y < a.y && t.y < a.y || n.y > u.y && t.y > u.y) return !1;
          const p = er(n, t, i[0]);
          return p !== er(n, t, i[1]) || p !== er(n, t, i[2]) || p !== er(n, t, i[3])
        }

        function nu(n, t, i) {
          const a = t.paint.get(n).value;
          return a.kind === "constant" ? a.value : i.programConfigurations.get(t.id).getMaxValue(n)
        }

        function id(n) {
          return Math.sqrt(n[0] * n[0] + n[1] * n[1])
        }

        function nd(n, t, i, a, u) {
          if (!t[0] && !t[1]) return n;
          const p = le.convert(t)._mult(u);
          i === "viewport" && p._rotate(-a);
          const f = [];
          for (let g = 0; g < n.length; g++) f.push(n[g].sub(p));
          return f
        }
        let Bm, Fm;
        Wt("CircleBucket", xp, {
          omit: ["layers"]
        });
        var Yv = {
          get paint() {
            return Fm = Fm || new Fn({
              "circle-radius": new Lr(ve.paint_circle["circle-radius"]),
              "circle-color": new Lr(ve.paint_circle["circle-color"]),
              "circle-blur": new Lr(ve.paint_circle["circle-blur"]),
              "circle-opacity": new Lr(ve.paint_circle["circle-opacity"]),
              "circle-translate": new ar(ve.paint_circle["circle-translate"]),
              "circle-translate-anchor": new ar(ve.paint_circle["circle-translate-anchor"]),
              "circle-pitch-scale": new ar(ve.paint_circle["circle-pitch-scale"]),
              "circle-pitch-alignment": new ar(ve.paint_circle["circle-pitch-alignment"]),
              "circle-stroke-width": new Lr(ve.paint_circle["circle-stroke-width"]),
              "circle-stroke-color": new Lr(ve.paint_circle["circle-stroke-color"]),
              "circle-stroke-opacity": new Lr(ve.paint_circle["circle-stroke-opacity"])
            })
          },
          get layout() {
            return Bm = Bm || new Fn({
              "circle-sort-key": new Lr(ve.layout_circle["circle-sort-key"])
            })
          }
        };
        class Jv extends wn {
          constructor(t) {
            super(t, Yv)
          }
          createBucket(t) {
            return new xp(t)
          }
          queryRadius(t) {
            const i = t;
            return nu("circle-radius", this, i) + nu("circle-stroke-width", this, i) + id(this.paint.get("circle-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: i,
            featureState: a,
            geometry: u,
            transform: p,
            pixelsToTileUnits: f,
            unwrappedTileID: g,
            getElevation: x
          }) {
            const S = nd(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -p.bearingInRadians, f),
              I = this.paint.get("circle-radius").evaluate(i, a) + this.paint.get("circle-stroke-width").evaluate(i, a),
              k = this.paint.get("circle-pitch-alignment") === "map",
              R = k ? S : (function(q, U, J, ae) {
                return q.map((ke => Om(ke, U, J, ae)))
              })(S, p, g, x),
              N = k ? I * f : I;
            for (const q of u)
              for (const U of q) {
                const J = k ? U : Om(U, p, g, x);
                let ae = N;
                const ke = p.projectTileCoordinates(U.x, U.y, g, x).signedDistanceFromCamera;
                if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? ae *= ke / p.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (ae *= p.cameraToCenterDistance / ke), Hv(R, J, ae)) return !0
              }
            return !1
          }
        }

        function Om(n, t, i, a) {
          const u = t.projectTileCoordinates(n.x, n.y, i, a).point;
          return new le((.5 * u.x + .5) * t.width, (.5 * -u.y + .5) * t.height)
        }
        class Nm extends xp {}
        let jm;
        Wt("HeatmapBucket", Nm, {
          omit: ["layers"]
        });
        var Qv = {
          get paint() {
            return jm = jm || new Fn({
              "heatmap-radius": new Lr(ve.paint_heatmap["heatmap-radius"]),
              "heatmap-weight": new Lr(ve.paint_heatmap["heatmap-weight"]),
              "heatmap-intensity": new ar(ve.paint_heatmap["heatmap-intensity"]),
              "heatmap-color": new Ro(ve.paint_heatmap["heatmap-color"]),
              "heatmap-opacity": new ar(ve.paint_heatmap["heatmap-opacity"])
            })
          }
        };

        function Tp(n, {
          width: t,
          height: i
        }, a, u) {
          if (u) {
            if (u instanceof Uint8ClampedArray) u = new Uint8Array(u.buffer);
            else if (u.length !== t * i * a) throw new RangeError(`mismatched image size. expected: ${u.length} but got: ${t*i*a}`)
          } else u = new Uint8Array(t * i * a);
          return n.width = t, n.height = i, n.data = u, n
        }

        function qm(n, {
          width: t,
          height: i
        }, a) {
          if (t === n.width && i === n.height) return;
          const u = Tp({}, {
            width: t,
            height: i
          }, a);
          Cp(n, u, {
            x: 0,
            y: 0
          }, {
            x: 0,
            y: 0
          }, {
            width: Math.min(n.width, t),
            height: Math.min(n.height, i)
          }, a), n.width = t, n.height = i, n.data = u.data
        }

        function Cp(n, t, i, a, u, p) {
          if (u.width === 0 || u.height === 0) return t;
          if (u.width > n.width || u.height > n.height || i.x > n.width - u.width || i.y > n.height - u.height) throw new RangeError("out of range source coordinates for image copy");
          if (u.width > t.width || u.height > t.height || a.x > t.width - u.width || a.y > t.height - u.height) throw new RangeError("out of range destination coordinates for image copy");
          const f = n.data,
            g = t.data;
          if (f === g) throw new Error("srcData equals dstData, so image is already copied");
          for (let x = 0; x < u.height; x++) {
            const S = ((i.y + x) * n.width + i.x) * p,
              I = ((a.y + x) * t.width + a.x) * p;
            for (let k = 0; k < u.width * p; k++) g[I + k] = f[S + k]
          }
          return t
        }
        class au {
          constructor(t, i) {
            Tp(this, t, 1, i)
          }
          resize(t) {
            qm(this, t, 1)
          }
          clone() {
            return new au({
              width: this.width,
              height: this.height
            }, new Uint8Array(this.data))
          }
          static copy(t, i, a, u, p) {
            Cp(t, i, a, u, p, 1)
          }
        }
        class ra {
          constructor(t, i) {
            Tp(this, t, 4, i)
          }
          resize(t) {
            qm(this, t, 4)
          }
          replace(t, i) {
            i ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t
          }
          clone() {
            return new ra({
              width: this.width,
              height: this.height
            }, new Uint8Array(this.data))
          }
          static copy(t, i, a, u, p) {
            Cp(t, i, a, u, p, 4)
          }
          setPixel(t, i, a) {
            const u = 4 * (t * this.width + i);
            this.data[u + 0] = Math.round(255 * a.r / a.a), this.data[u + 1] = Math.round(255 * a.g / a.a), this.data[u + 2] = Math.round(255 * a.b / a.a), this.data[u + 3] = Math.round(255 * a.a)
          }
        }

        function Vm(n) {
          const t = {},
            i = n.resolution || 256,
            a = n.clips ? n.clips.length : 1,
            u = n.image || new ra({
              width: i,
              height: a
            });
          if (Math.log(i) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${i}`);
          const p = (f, g, x) => {
            t[n.evaluationKey] = x;
            const S = n.expression.evaluate(t);
            u.setPixel(f / 4 / i, g / 4, S)
          };
          if (n.clips)
            for (let f = 0, g = 0; f < a; ++f, g += 4 * i)
              for (let x = 0, S = 0; x < i; x++, S += 4) {
                const I = x / (i - 1),
                  {
                    start: k,
                    end: R
                  } = n.clips[f];
                p(g, S, k * (1 - I) + R * I)
              } else
                for (let f = 0, g = 0; f < i; f++, g += 4) p(0, g, f / (i - 1));
          return u
        }
        Wt("AlphaImage", au), Wt("RGBAImage", ra);
        const Sp = "big-fb";
        class e0 extends wn {
          createBucket(t) {
            return new Nm(t)
          }
          constructor(t) {
            super(t, Qv), this.heatmapFbos = new Map, this._updateColorRamp()
          }
          _handleSpecialPaintPropertyUpdate(t) {
            t === "heatmap-color" && this._updateColorRamp()
          }
          _updateColorRamp() {
            this.colorRamp = Vm({
              expression: this._transitionablePaint._values["heatmap-color"].value.expression,
              evaluationKey: "heatmapDensity",
              image: this.colorRamp
            }), this.colorRampTexture = null
          }
          resize() {
            this.heatmapFbos.has(Sp) && this.heatmapFbos.delete(Sp)
          }
          queryRadius() {
            return 0
          }
          queryIntersectsFeature() {
            return !1
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none"
          }
        }
        let Zm;
        var t0 = {
          get paint() {
            return Zm = Zm || new Fn({
              "hillshade-illumination-direction": new ar(ve.paint_hillshade["hillshade-illumination-direction"]),
              "hillshade-illumination-altitude": new ar(ve.paint_hillshade["hillshade-illumination-altitude"]),
              "hillshade-illumination-anchor": new ar(ve.paint_hillshade["hillshade-illumination-anchor"]),
              "hillshade-exaggeration": new ar(ve.paint_hillshade["hillshade-exaggeration"]),
              "hillshade-shadow-color": new ar(ve.paint_hillshade["hillshade-shadow-color"]),
              "hillshade-highlight-color": new ar(ve.paint_hillshade["hillshade-highlight-color"]),
              "hillshade-accent-color": new ar(ve.paint_hillshade["hillshade-accent-color"]),
              "hillshade-method": new ar(ve.paint_hillshade["hillshade-method"])
            })
          }
        };
        class r0 extends wn {
          constructor(t) {
            super(t, t0), this.recalculate({
              zoom: 0,
              zoomHistory: {}
            }, void 0)
          }
          getIlluminationProperties() {
            let t = this.paint.get("hillshade-illumination-direction").values,
              i = this.paint.get("hillshade-illumination-altitude").values,
              a = this.paint.get("hillshade-highlight-color").values,
              u = this.paint.get("hillshade-shadow-color").values;
            const p = Math.max(t.length, i.length, a.length, u.length);
            t = t.concat(Array(p - t.length).fill(t.at(-1))), i = i.concat(Array(p - i.length).fill(i.at(-1))), a = a.concat(Array(p - a.length).fill(a.at(-1))), u = u.concat(Array(p - u.length).fill(u.at(-1)));
            const f = i.map(tr);
            return {
              directionRadians: t.map(tr),
              altitudeRadians: f,
              shadowColor: u,
              highlightColor: a
            }
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none"
          }
        }
        let $m;
        var i0 = {
          get paint() {
            return $m = $m || new Fn({
              "color-relief-opacity": new ar(ve["paint_color-relief"]["color-relief-opacity"]),
              "color-relief-color": new Ro(ve["paint_color-relief"]["color-relief-color"])
            })
          }
        };
        class Pp {
          constructor(t, i, a, u) {
            this.context = t, this.format = a, this.texture = t.gl.createTexture(), this.update(i, u)
          }
          update(t, i, a) {
            const {
              width: u,
              height: p
            } = t, f = !(this.size && this.size[0] === u && this.size[1] === p || a), {
              context: g
            } = this, {
              gl: x
            } = g;
            if (this.useMipmap = !!(i && i.useMipmap), x.bindTexture(x.TEXTURE_2D, this.texture), g.pixelStoreUnpackFlipY.set(!1), g.pixelStoreUnpack.set(1), g.pixelStoreUnpackPremultiplyAlpha.set(this.format === x.RGBA && (!i || i.premultiply !== !1)), f) this.size = [u, p], t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || Tr(t) ? x.texImage2D(x.TEXTURE_2D, 0, this.format, this.format, x.UNSIGNED_BYTE, t) : x.texImage2D(x.TEXTURE_2D, 0, this.format, u, p, 0, this.format, x.UNSIGNED_BYTE, t.data);
            else {
              const {
                x: S,
                y: I
              } = a || {
                x: 0,
                y: 0
              };
              t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || Tr(t) ? x.texSubImage2D(x.TEXTURE_2D, 0, S, I, x.RGBA, x.UNSIGNED_BYTE, t) : x.texSubImage2D(x.TEXTURE_2D, 0, S, I, u, p, x.RGBA, x.UNSIGNED_BYTE, t.data)
            }
            this.useMipmap && this.isSizePowerOfTwo() && x.generateMipmap(x.TEXTURE_2D), g.pixelStoreUnpackFlipY.setDefault(), g.pixelStoreUnpack.setDefault(), g.pixelStoreUnpackPremultiplyAlpha.setDefault()
          }
          bind(t, i, a) {
            const {
              context: u
            } = this, {
              gl: p
            } = u;
            p.bindTexture(p.TEXTURE_2D, this.texture), a !== p.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (a = p.LINEAR), t !== this.filter && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, t), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, a || t), this.filter = t), i !== this.wrap && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, i), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, i), this.wrap = i)
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0
          }
          destroy() {
            const {
              gl: t
            } = this.context;
            t.deleteTexture(this.texture), this.texture = null
          }
        }
        class Um {
          constructor(t, i, a, u = 1, p = 1, f = 1, g = 0) {
            if (this.uid = t, i.height !== i.width) throw new RangeError("DEM tiles must be square");
            if (a && !["mapbox", "terrarium", "custom"].includes(a)) return void Qt(`"${a}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = i.height;
            const x = this.dim = i.height - 2;
            switch (this.data = new Uint32Array(i.data.buffer), a) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = u, this.greenFactor = p, this.blueFactor = f, this.baseShift = g;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = .1, this.baseShift = 1e4
            }
            for (let S = 0; S < x; S++) this.data[this._idx(-1, S)] = this.data[this._idx(0, S)], this.data[this._idx(x, S)] = this.data[this._idx(x - 1, S)], this.data[this._idx(S, -1)] = this.data[this._idx(S, 0)], this.data[this._idx(S, x)] = this.data[this._idx(S, x - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(x, -1)] = this.data[this._idx(x - 1, 0)], this.data[this._idx(-1, x)] = this.data[this._idx(0, x - 1)], this.data[this._idx(x, x)] = this.data[this._idx(x - 1, x - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let S = 0; S < x; S++)
              for (let I = 0; I < x; I++) {
                const k = this.get(S, I);
                k > this.max && (this.max = k), k < this.min && (this.min = k)
              }
          }
          get(t, i) {
            const a = new Uint8Array(this.data.buffer),
              u = 4 * this._idx(t, i);
            return this.unpack(a[u], a[u + 1], a[u + 2])
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift]
          }
          _idx(t, i) {
            if (t < -1 || t >= this.dim + 1 || i < -1 || i >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (i + 1) * this.stride + (t + 1)
          }
          unpack(t, i, a) {
            return t * this.redFactor + i * this.greenFactor + a * this.blueFactor - this.baseShift
          }
          pack(t) {
            return Gm(t, this.getUnpackVector())
          }
          getPixels() {
            return new ra({
              width: this.stride,
              height: this.stride
            }, new Uint8Array(this.data.buffer))
          }
          backfillBorder(t, i, a) {
            if (this.dim !== t.dim) throw new Error("dem dimension mismatch");
            let u = i * this.dim,
              p = i * this.dim + this.dim,
              f = a * this.dim,
              g = a * this.dim + this.dim;
            switch (i) {
              case -1:
                u = p - 1;
                break;
              case 1:
                p = u + 1
            }
            switch (a) {
              case -1:
                f = g - 1;
                break;
              case 1:
                g = f + 1
            }
            const x = -i * this.dim,
              S = -a * this.dim;
            for (let I = f; I < g; I++)
              for (let k = u; k < p; k++) this.data[this._idx(k, I)] = t.data[this._idx(k + x, I + S)]
          }
        }

        function Gm(n, t) {
          const i = t[0],
            a = t[1],
            u = t[2],
            p = t[3],
            f = Math.min(i, a, u),
            g = Math.round((n + p) / f);
          return {
            r: Math.floor(g * f / i) % 256,
            g: Math.floor(g * f / a) % 256,
            b: Math.floor(g * f / u) % 256
          }
        }
        Wt("DEMData", Um);
        class n0 extends wn {
          constructor(t) {
            super(t, i0)
          }
          _createColorRamp(t) {
            const i = {
                elevationStops: [],
                colorStops: []
              },
              a = this._transitionablePaint._values["color-relief-color"].value.expression;
            if (a instanceof Co && a._styleExpression.expression instanceof Rn) {
              this.colorRampExpression = a;
              const f = a._styleExpression.expression;
              i.elevationStops = f.labels, i.colorStops = [];
              for (const g of i.elevationStops) i.colorStops.push(f.evaluate({
                globals: {
                  elevation: g
                }
              }))
            }
            if (i.elevationStops.length < 1 && (i.elevationStops = [0], i.colorStops = [ni.transparent]), i.elevationStops.length < 2 && (i.elevationStops.push(i.elevationStops[0] + 1), i.colorStops.push(i.colorStops[0])), i.elevationStops.length <= t) return i;
            const u = {
                elevationStops: [],
                colorStops: []
              },
              p = (i.elevationStops.length - 1) / (t - 1);
            for (let f = 0; f < i.elevationStops.length - .5; f += p) u.elevationStops.push(i.elevationStops[Math.round(f)]), u.colorStops.push(i.colorStops[Math.round(f)]);
            return Qt(`Too many colors in specification of ${this.id} color-relief layer, may not render properly.`), u
          }
          _colorRampChanged() {
            return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression
          }
          getColorRampTextures(t, i, a) {
            if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
            const u = this._createColorRamp(i),
              p = new ra({
                width: u.colorStops.length,
                height: 1
              }),
              f = new ra({
                width: u.colorStops.length,
                height: 1
              });
            for (let g = 0; g < u.elevationStops.length; g++) {
              const x = Gm(u.elevationStops[g], a);
              f.setPixel(0, g, new ni(x.r / 255, x.g / 255, x.b / 255, 1)), p.setPixel(0, g, u.colorStops[g])
            }
            return this.colorRampTextures = {
              elevationTexture: new Pp(t, f, t.gl.RGBA),
              colorTexture: new Pp(t, p, t.gl.RGBA)
            }, this.colorRampTextures
          }
          hasOffscreenPass() {
            return this.visibility !== "none" && !!this.colorRampTextures
          }
        }
        const a0 = Ui([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: s0
          } = a0;

        function Ip(n, t, i) {
          const a = i.patternDependencies;
          let u = !1;
          for (const p of t) {
            const f = p.paint.get(`${n}-pattern`);
            f.isConstant() || (u = !0);
            const g = f.constantOr(null);
            g && (u = !0, a[g.to] = !0, a[g.from] = !0)
          }
          return u
        }

        function Mp(n, t, i, a, u) {
          const p = u.patternDependencies;
          for (const f of t) {
            const g = f.paint.get(`${n}-pattern`).value;
            if (g.kind !== "constant") {
              let x = g.evaluate({
                  zoom: a - 1
                }, i, {}, u.availableImages),
                S = g.evaluate({
                  zoom: a
                }, i, {}, u.availableImages),
                I = g.evaluate({
                  zoom: a + 1
                }, i, {}, u.availableImages);
              x = x && x.name ? x.name : x, S = S && S.name ? S.name : S, I = I && I.name ? I.name : I, p[x] = !0, p[S] = !0, p[I] = !0, i.patterns[f.id] = {
                min: x,
                mid: S,
                max: I
              }
            }
          }
          return i
        }

        function Hm(n, t, i, a, u) {
          let p;
          if (u === (function(f, g, x, S) {
              let I = 0;
              for (let k = g, R = x - S; k < x; k += S) I += (f[R] - f[k]) * (f[k + 1] + f[R + 1]), R = k;
              return I
            })(n, t, i, a) > 0)
            for (let f = t; f < i; f += a) p = Ym(f / a | 0, n[f], n[f + 1], p);
          else
            for (let f = i - a; f >= t; f -= a) p = Ym(f / a | 0, n[f], n[f + 1], p);
          return p && Rl(p, p.next) && (cu(p), p = p.next), p
        }

        function Zo(n, t) {
          if (!n) return n;
          t || (t = n);
          let i, a = n;
          do
            if (i = !1, a.steiner || !Rl(a, a.next) && Ji(a.prev, a, a.next) !== 0) a = a.next;
            else {
              if (cu(a), a = t = a.prev, a === a.next) break;
              i = !0
            } while (i || a !== t);
          return t
        }

        function su(n, t, i, a, u, p, f) {
          if (!n) return;
          !f && p && (function(x, S, I, k) {
            let R = x;
            do R.z === 0 && (R.z = Ap(R.x, R.y, S, I, k)), R.prevZ = R.prev, R.nextZ = R.next, R = R.next; while (R !== x);
            R.prevZ.nextZ = null, R.prevZ = null, (function(N) {
              let q, U = 1;
              do {
                let J, ae = N;
                N = null;
                let ke = null;
                for (q = 0; ae;) {
                  q++;
                  let _e = ae,
                    O = 0;
                  for (let ge = 0; ge < U && (O++, _e = _e.nextZ, _e); ge++);
                  let Y = U;
                  for (; O > 0 || Y > 0 && _e;) O !== 0 && (Y === 0 || !_e || ae.z <= _e.z) ? (J = ae, ae = ae.nextZ, O--) : (J = _e, _e = _e.nextZ, Y--), ke ? ke.nextZ = J : N = J, J.prevZ = ke, ke = J;
                  ae = _e
                }
                ke.nextZ = null, U *= 2
              } while (q > 1)
            })(R)
          })(n, a, u, p);
          let g = n;
          for (; n.prev !== n.next;) {
            const x = n.prev,
              S = n.next;
            if (p ? l0(n, a, u, p) : o0(n)) t.push(x.i, n.i, S.i), cu(n), n = S.next, g = S.next;
            else if ((n = S) === g) {
              f ? f === 1 ? su(n = c0(Zo(n), t), t, i, a, u, p, 2) : f === 2 && u0(n, t, i, a, u, p) : su(Zo(n), t, i, a, u, p, 1);
              break
            }
          }
        }

        function o0(n) {
          const t = n.prev,
            i = n,
            a = n.next;
          if (Ji(t, i, a) >= 0) return !1;
          const u = t.x,
            p = i.x,
            f = a.x,
            g = t.y,
            x = i.y,
            S = a.y,
            I = Math.min(u, p, f),
            k = Math.min(g, x, S),
            R = Math.max(u, p, f),
            N = Math.max(g, x, S);
          let q = a.next;
          for (; q !== t;) {
            if (q.x >= I && q.x <= R && q.y >= k && q.y <= N && ou(u, g, p, x, f, S, q.x, q.y) && Ji(q.prev, q, q.next) >= 0) return !1;
            q = q.next
          }
          return !0
        }

        function l0(n, t, i, a) {
          const u = n.prev,
            p = n,
            f = n.next;
          if (Ji(u, p, f) >= 0) return !1;
          const g = u.x,
            x = p.x,
            S = f.x,
            I = u.y,
            k = p.y,
            R = f.y,
            N = Math.min(g, x, S),
            q = Math.min(I, k, R),
            U = Math.max(g, x, S),
            J = Math.max(I, k, R),
            ae = Ap(N, q, t, i, a),
            ke = Ap(U, J, t, i, a);
          let _e = n.prevZ,
            O = n.nextZ;
          for (; _e && _e.z >= ae && O && O.z <= ke;) {
            if (_e.x >= N && _e.x <= U && _e.y >= q && _e.y <= J && _e !== u && _e !== f && ou(g, I, x, k, S, R, _e.x, _e.y) && Ji(_e.prev, _e, _e.next) >= 0 || (_e = _e.prevZ, O.x >= N && O.x <= U && O.y >= q && O.y <= J && O !== u && O !== f && ou(g, I, x, k, S, R, O.x, O.y) && Ji(O.prev, O, O.next) >= 0)) return !1;
            O = O.nextZ
          }
          for (; _e && _e.z >= ae;) {
            if (_e.x >= N && _e.x <= U && _e.y >= q && _e.y <= J && _e !== u && _e !== f && ou(g, I, x, k, S, R, _e.x, _e.y) && Ji(_e.prev, _e, _e.next) >= 0) return !1;
            _e = _e.prevZ
          }
          for (; O && O.z <= ke;) {
            if (O.x >= N && O.x <= U && O.y >= q && O.y <= J && O !== u && O !== f && ou(g, I, x, k, S, R, O.x, O.y) && Ji(O.prev, O, O.next) >= 0) return !1;
            O = O.nextZ
          }
          return !0
        }

        function c0(n, t) {
          let i = n;
          do {
            const a = i.prev,
              u = i.next.next;
            !Rl(a, u) && Xm(a, i, i.next, u) && lu(a, u) && lu(u, a) && (t.push(a.i, i.i, u.i), cu(i), cu(i.next), i = n = u), i = i.next
          } while (i !== n);
          return Zo(i)
        }

        function u0(n, t, i, a, u, p) {
          let f = n;
          do {
            let g = f.next.next;
            for (; g !== f.prev;) {
              if (f.i !== g.i && m0(f, g)) {
                let x = Km(f, g);
                return f = Zo(f, f.next), x = Zo(x, x.next), su(f, t, i, a, u, p, 0), void su(x, t, i, a, u, p, 0)
              }
              g = g.next
            }
            f = f.next
          } while (f !== n)
        }

        function h0(n, t) {
          let i = n.x - t.x;
          return i === 0 && (i = n.y - t.y, i === 0) && (i = (n.next.y - n.y) / (n.next.x - n.x) - (t.next.y - t.y) / (t.next.x - t.x)), i
        }

        function d0(n, t) {
          const i = (function(u, p) {
            let f = p;
            const g = u.x,
              x = u.y;
            let S, I = -1 / 0;
            if (Rl(u, f)) return f;
            do {
              if (Rl(u, f.next)) return f.next;
              if (x <= f.y && x >= f.next.y && f.next.y !== f.y) {
                const U = f.x + (x - f.y) * (f.next.x - f.x) / (f.next.y - f.y);
                if (U <= g && U > I && (I = U, S = f.x < f.next.x ? f : f.next, U === g)) return S
              }
              f = f.next
            } while (f !== p);
            if (!S) return null;
            const k = S,
              R = S.x,
              N = S.y;
            let q = 1 / 0;
            f = S;
            do {
              if (g >= f.x && f.x >= R && g !== f.x && Wm(x < N ? g : I, x, R, N, x < N ? I : g, x, f.x, f.y)) {
                const U = Math.abs(x - f.y) / (g - f.x);
                lu(f, u) && (U < q || U === q && (f.x > S.x || f.x === S.x && p0(S, f))) && (S = f, q = U)
              }
              f = f.next
            } while (f !== k);
            return S
          })(n, t);
          if (!i) return t;
          const a = Km(i, n);
          return Zo(a, a.next), Zo(i, i.next)
        }

        function p0(n, t) {
          return Ji(n.prev, n, t.prev) < 0 && Ji(t.next, n, n.next) < 0
        }

        function Ap(n, t, i, a, u) {
          return (n = 1431655765 & ((n = 858993459 & ((n = 252645135 & ((n = 16711935 & ((n = (n - i) * u | 0) | n << 8)) | n << 4)) | n << 2)) | n << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - a) * u | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
        }

        function f0(n) {
          let t = n,
            i = n;
          do(t.x < i.x || t.x === i.x && t.y < i.y) && (i = t), t = t.next; while (t !== n);
          return i
        }

        function Wm(n, t, i, a, u, p, f, g) {
          return (u - f) * (t - g) >= (n - f) * (p - g) && (n - f) * (a - g) >= (i - f) * (t - g) && (i - f) * (p - g) >= (u - f) * (a - g)
        }

        function ou(n, t, i, a, u, p, f, g) {
          return !(n === f && t === g) && Wm(n, t, i, a, u, p, f, g)
        }

        function m0(n, t) {
          return n.next.i !== t.i && n.prev.i !== t.i && !(function(i, a) {
            let u = i;
            do {
              if (u.i !== i.i && u.next.i !== i.i && u.i !== a.i && u.next.i !== a.i && Xm(u, u.next, i, a)) return !0;
              u = u.next
            } while (u !== i);
            return !1
          })(n, t) && (lu(n, t) && lu(t, n) && (function(i, a) {
            let u = i,
              p = !1;
            const f = (i.x + a.x) / 2,
              g = (i.y + a.y) / 2;
            do u.y > g != u.next.y > g && u.next.y !== u.y && f < (u.next.x - u.x) * (g - u.y) / (u.next.y - u.y) + u.x && (p = !p), u = u.next; while (u !== i);
            return p
          })(n, t) && (Ji(n.prev, n, t.prev) || Ji(n, t.prev, t)) || Rl(n, t) && Ji(n.prev, n, n.next) > 0 && Ji(t.prev, t, t.next) > 0)
        }

        function Ji(n, t, i) {
          return (t.y - n.y) * (i.x - t.x) - (t.x - n.x) * (i.y - t.y)
        }

        function Rl(n, t) {
          return n.x === t.x && n.y === t.y
        }

        function Xm(n, t, i, a) {
          const u = sd(Ji(n, t, i)),
            p = sd(Ji(n, t, a)),
            f = sd(Ji(i, a, n)),
            g = sd(Ji(i, a, t));
          return u !== p && f !== g || !(u !== 0 || !ad(n, i, t)) || !(p !== 0 || !ad(n, a, t)) || !(f !== 0 || !ad(i, n, a)) || !(g !== 0 || !ad(i, t, a))
        }

        function ad(n, t, i) {
          return t.x <= Math.max(n.x, i.x) && t.x >= Math.min(n.x, i.x) && t.y <= Math.max(n.y, i.y) && t.y >= Math.min(n.y, i.y)
        }

        function sd(n) {
          return n > 0 ? 1 : n < 0 ? -1 : 0
        }

        function lu(n, t) {
          return Ji(n.prev, n, n.next) < 0 ? Ji(n, t, n.next) >= 0 && Ji(n, n.prev, t) >= 0 : Ji(n, t, n.prev) < 0 || Ji(n, n.next, t) < 0
        }

        function Km(n, t) {
          const i = kp(n.i, n.x, n.y),
            a = kp(t.i, t.x, t.y),
            u = n.next,
            p = t.prev;
          return n.next = t, t.prev = n, i.next = u, u.prev = i, a.next = i, i.prev = a, p.next = a, a.prev = p, a
        }

        function Ym(n, t, i, a) {
          const u = kp(n, t, i);
          return a ? (u.next = a.next, u.prev = a, a.next.prev = u, a.next = u) : (u.prev = u, u.next = u), u
        }

        function cu(n) {
          n.next.prev = n.prev, n.prev.next = n.next, n.prevZ && (n.prevZ.nextZ = n.nextZ), n.nextZ && (n.nextZ.prevZ = n.prevZ)
        }

        function kp(n, t, i) {
          return {
            i: n,
            x: t,
            y: i,
            prev: null,
            next: null,
            z: 0,
            prevZ: null,
            nextZ: null,
            steiner: !1
          }
        }
        class Bl {
          constructor(t, i) {
            if (i > t) throw new Error("Min granularity must not be greater than base granularity.");
            this._baseZoomGranularity = t, this._minGranularity = i
          }
          getGranularityForZoomLevel(t) {
            return Math.max(Math.floor(this._baseZoomGranularity / (1 << t)), this._minGranularity, 1)
          }
        }
        class od {
          constructor(t) {
            this.fill = t.fill, this.line = t.line, this.tile = t.tile, this.stencil = t.stencil, this.circle = t.circle
          }
        }
        od.noSubdivision = new od({
          fill: new Bl(0, 0),
          line: new Bl(0, 0),
          tile: new Bl(0, 0),
          stencil: new Bl(0, 0),
          circle: 1
        }), Wt("SubdivisionGranularityExpression", Bl), Wt("SubdivisionGranularitySetting", od);
        const Fl = -32768,
          uu = 32767;
        class _0 {
          constructor(t, i) {
            this._vertexBuffer = [], this._vertexDictionary = new Map, this._used = !1, this._granularity = t, this._granularityCellSize = Ke / t, this._canonical = i
          }
          _getKey(t, i) {
            return (t += 32768) << 16 | i + 32768
          }
          _vertexToIndex(t, i) {
            if (t < -32768 || i < -32768 || t > 32767 || i > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
            const a = 0 | Math.round(t),
              u = 0 | Math.round(i),
              p = this._getKey(a, u);
            if (this._vertexDictionary.has(p)) return this._vertexDictionary.get(p);
            const f = this._vertexBuffer.length / 2;
            return this._vertexDictionary.set(p, f), this._vertexBuffer.push(a, u), f
          }
          _subdivideTrianglesScanline(t) {
            if (this._granularity < 2) return (function(u, p) {
              const f = [];
              for (let g = 0; g < p.length; g += 3) {
                const x = p[g],
                  S = p[g + 1],
                  I = p[g + 2],
                  k = u[2 * x],
                  R = u[2 * x + 1];
                (u[2 * S] - k) * (u[2 * I + 1] - R) - (u[2 * S + 1] - R) * (u[2 * I] - k) > 0 ? (f.push(x), f.push(I), f.push(S)) : (f.push(x), f.push(S), f.push(I))
              }
              return f
            })(this._vertexBuffer, t);
            const i = [],
              a = t.length;
            for (let u = 0; u < a; u += 3) {
              const p = [t[u + 0], t[u + 1], t[u + 2]],
                f = [this._vertexBuffer[2 * t[u + 0] + 0], this._vertexBuffer[2 * t[u + 0] + 1], this._vertexBuffer[2 * t[u + 1] + 0], this._vertexBuffer[2 * t[u + 1] + 1], this._vertexBuffer[2 * t[u + 2] + 0], this._vertexBuffer[2 * t[u + 2] + 1]];
              let g = 1 / 0,
                x = 1 / 0,
                S = -1 / 0,
                I = -1 / 0;
              for (let U = 0; U < 3; U++) {
                const J = f[2 * U],
                  ae = f[2 * U + 1];
                g = Math.min(g, J), S = Math.max(S, J), x = Math.min(x, ae), I = Math.max(I, ae)
              }
              if (g === S || x === I) continue;
              const k = Math.floor(g / this._granularityCellSize),
                R = Math.ceil(S / this._granularityCellSize),
                N = Math.floor(x / this._granularityCellSize),
                q = Math.ceil(I / this._granularityCellSize);
              if (k !== R || N !== q)
                for (let U = N; U < q; U++) {
                  const J = this._scanlineGenerateVertexRingForCellRow(U, f, p);
                  g0(this._vertexBuffer, J, i)
                } else i.push(...p)
            }
            return i
          }
          _scanlineGenerateVertexRingForCellRow(t, i, a) {
            const u = t * this._granularityCellSize,
              p = u + this._granularityCellSize,
              f = [];
            for (let g = 0; g < 3; g++) {
              const x = i[2 * g],
                S = i[2 * g + 1],
                I = i[2 * (g + 1) % 6],
                k = i[(2 * (g + 1) + 1) % 6],
                R = i[2 * (g + 2) % 6],
                N = i[(2 * (g + 2) + 1) % 6],
                q = I - x,
                U = k - S,
                J = q === 0,
                ae = U === 0,
                ke = (u - S) / U,
                _e = (p - S) / U,
                O = Math.min(ke, _e),
                Y = Math.max(ke, _e);
              if (!ae && (O >= 1 || Y <= 0) || ae && (S < u || S > p)) {
                k >= u && k <= p && f.push(a[(g + 1) % 3]);
                continue
              }!ae && O > 0 && f.push(this._vertexToIndex(x + q * O, S + U * O));
              const ge = x + q * Math.max(O, 0),
                Xe = x + q * Math.min(Y, 1);
              J || this._generateIntraEdgeVertices(f, x, S, I, k, ge, Xe), !ae && Y < 1 && f.push(this._vertexToIndex(x + q * Y, S + U * Y)), (ae || k >= u && k <= p) && f.push(a[(g + 1) % 3]), !ae && (k <= u || k >= p) && this._generateInterEdgeVertices(f, x, S, I, k, R, N, Xe, u, p)
            }
            return f
          }
          _generateIntraEdgeVertices(t, i, a, u, p, f, g) {
            const x = u - i,
              S = p - a,
              I = S === 0,
              k = I ? Math.min(i, u) : Math.min(f, g),
              R = I ? Math.max(i, u) : Math.max(f, g),
              N = Math.floor(k / this._granularityCellSize) + 1,
              q = Math.ceil(R / this._granularityCellSize) - 1;
            if (I ? i < u : f < g)
              for (let U = N; U <= q; U++) {
                const J = U * this._granularityCellSize;
                t.push(this._vertexToIndex(J, a + S * (J - i) / x))
              } else
                for (let U = q; U >= N; U--) {
                  const J = U * this._granularityCellSize;
                  t.push(this._vertexToIndex(J, a + S * (J - i) / x))
                }
          }
          _generateInterEdgeVertices(t, i, a, u, p, f, g, x, S, I) {
            const k = p - a,
              R = f - u,
              N = g - p,
              q = (S - p) / N,
              U = (I - p) / N,
              J = Math.min(q, U),
              ae = Math.max(q, U),
              ke = u + R * J;
            let _e = Math.floor(Math.min(ke, x) / this._granularityCellSize) + 1,
              O = Math.ceil(Math.max(ke, x) / this._granularityCellSize) - 1,
              Y = x < ke;
            const ge = N === 0;
            if (ge && (g === S || g === I)) return;
            if (ge || J >= 1 || ae <= 0) {
              const wt = a - g,
                it = f + (i - f) * Math.min((S - g) / wt, (I - g) / wt);
              _e = Math.floor(Math.min(it, x) / this._granularityCellSize) + 1, O = Math.ceil(Math.max(it, x) / this._granularityCellSize) - 1, Y = x < it
            }
            const Xe = k > 0 ? I : S;
            if (Y)
              for (let wt = _e; wt <= O; wt++) t.push(this._vertexToIndex(wt * this._granularityCellSize, Xe));
            else
              for (let wt = O; wt >= _e; wt--) t.push(this._vertexToIndex(wt * this._granularityCellSize, Xe))
          }
          _generateOutline(t) {
            const i = [];
            for (const a of t) {
              const u = $o(a, this._granularity, !0),
                p = this._pointArrayToIndices(u),
                f = [];
              for (let g = 1; g < p.length; g++) f.push(p[g - 1]), f.push(p[g]);
              i.push(f)
            }
            return i
          }
          _handlePoles(t) {
            let i = !1,
              a = !1;
            this._canonical && (this._canonical.y === 0 && (i = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (a = !0)), (i || a) && this._fillPoles(t, i, a)
          }
          _ensureNoPoleVertices() {
            const t = this._vertexBuffer;
            for (let i = 0; i < t.length; i += 2) {
              const a = t[i + 1];
              a === Fl && (t[i + 1] = -32767), a === uu && (t[i + 1] = 32766)
            }
          }
          _generatePoleQuad(t, i, a, u, p, f) {
            u > p != (f === Fl) ? (t.push(i), t.push(a), t.push(this._vertexToIndex(u, f)), t.push(a), t.push(this._vertexToIndex(p, f)), t.push(this._vertexToIndex(u, f))) : (t.push(a), t.push(i), t.push(this._vertexToIndex(u, f)), t.push(this._vertexToIndex(p, f)), t.push(a), t.push(this._vertexToIndex(u, f)))
          }
          _fillPoles(t, i, a) {
            const u = this._vertexBuffer,
              p = Ke,
              f = t.length;
            for (let g = 2; g < f; g += 3) {
              const x = t[g - 2],
                S = t[g - 1],
                I = t[g],
                k = u[2 * x],
                R = u[2 * x + 1],
                N = u[2 * S],
                q = u[2 * S + 1],
                U = u[2 * I],
                J = u[2 * I + 1];
              i && (R === 0 && q === 0 && this._generatePoleQuad(t, x, S, k, N, Fl), q === 0 && J === 0 && this._generatePoleQuad(t, S, I, N, U, Fl), J === 0 && R === 0 && this._generatePoleQuad(t, I, x, U, k, Fl)), a && (R === p && q === p && this._generatePoleQuad(t, x, S, k, N, uu), q === p && J === p && this._generatePoleQuad(t, S, I, N, U, uu), J === p && R === p && this._generatePoleQuad(t, I, x, U, k, uu))
            }
          }
          _initializeVertices(t) {
            for (let i = 0; i < t.length; i += 2) this._vertexToIndex(t[i], t[i + 1])
          }
          subdividePolygonInternal(t, i) {
            if (this._used) throw new Error("Subdivision: multiple use not allowed.");
            this._used = !0;
            const {
              flattened: a,
              holeIndices: u
            } = (function(g) {
              const x = [],
                S = [];
              for (const I of g)
                if (I.length !== 0) {
                  I !== g[0] && x.push(S.length / 2);
                  for (let k = 0; k < I.length; k++) S.push(I[k].x), S.push(I[k].y)
                } return {
                flattened: S,
                holeIndices: x
              }
            })(t);
            let p;
            this._initializeVertices(a);
            try {
              const g = (function(S, I, k = 2) {
                  const R = I && I.length,
                    N = R ? I[0] * k : S.length;
                  let q = Hm(S, 0, N, k, !0);
                  const U = [];
                  if (!q || q.next === q.prev) return U;
                  let J, ae, ke;
                  if (R && (q = (function(_e, O, Y, ge) {
                      const Xe = [];
                      for (let wt = 0, it = O.length; wt < it; wt++) {
                        const ut = Hm(_e, O[wt] * ge, wt < it - 1 ? O[wt + 1] * ge : _e.length, ge, !1);
                        ut === ut.next && (ut.steiner = !0), Xe.push(f0(ut))
                      }
                      Xe.sort(h0);
                      for (let wt = 0; wt < Xe.length; wt++) Y = d0(Xe[wt], Y);
                      return Y
                    })(S, I, q, k)), S.length > 80 * k) {
                    J = 1 / 0, ae = 1 / 0;
                    let _e = -1 / 0,
                      O = -1 / 0;
                    for (let Y = k; Y < N; Y += k) {
                      const ge = S[Y],
                        Xe = S[Y + 1];
                      ge < J && (J = ge), Xe < ae && (ae = Xe), ge > _e && (_e = ge), Xe > O && (O = Xe)
                    }
                    ke = Math.max(_e - J, O - ae), ke = ke !== 0 ? 32767 / ke : 0
                  }
                  return su(q, U, k, J, ae, ke, 0), U
                })(a, u),
                x = this._convertIndices(a, g);
              p = this._subdivideTrianglesScanline(x)
            } catch (g) {
              console.error(g)
            }
            let f = [];
            return i && (f = this._generateOutline(t)), this._ensureNoPoleVertices(), this._handlePoles(p), {
              verticesFlattened: this._vertexBuffer,
              indicesTriangles: p,
              indicesLineList: f
            }
          }
          _convertIndices(t, i) {
            const a = [];
            for (let u = 0; u < i.length; u++) a.push(this._vertexToIndex(t[2 * i[u]], t[2 * i[u] + 1]));
            return a
          }
          _pointArrayToIndices(t) {
            const i = [];
            for (let a = 0; a < t.length; a++) {
              const u = t[a];
              i.push(this._vertexToIndex(u.x, u.y))
            }
            return i
          }
        }

        function Jm(n, t, i, a = !0) {
          return new _0(i, t).subdividePolygonInternal(n, a)
        }

        function $o(n, t, i = !1) {
          if (!n || n.length < 1) return [];
          if (n.length < 2) return [];
          const a = n[0],
            u = n[n.length - 1],
            p = i && (a.x !== u.x || a.y !== u.y);
          if (t < 2) return p ? [...n, n[0]] : [...n];
          const f = Math.floor(Ke / t),
            g = [];
          g.push(new le(n[0].x, n[0].y));
          const x = n.length,
            S = p ? x : x - 1;
          for (let I = 0; I < S; I++) {
            const k = n[I],
              R = I < x - 1 ? n[I + 1] : n[0],
              N = k.x,
              q = k.y,
              U = R.x,
              J = R.y,
              ae = N !== U,
              ke = q !== J;
            if (!ae && !ke) continue;
            const _e = U - N,
              O = J - q,
              Y = Math.abs(_e),
              ge = Math.abs(O);
            let Xe = N,
              wt = q;
            for (;;) {
              const ut = _e > 0 ? (Math.floor(Xe / f) + 1) * f : (Math.ceil(Xe / f) - 1) * f,
                kt = O > 0 ? (Math.floor(wt / f) + 1) * f : (Math.ceil(wt / f) - 1) * f,
                Ct = Math.abs(Xe - ut),
                zt = Math.abs(wt - kt),
                mt = Math.abs(Xe - U),
                ir = Math.abs(wt - J),
                Mr = ae ? Ct / Y : Number.POSITIVE_INFINITY,
                Sr = ke ? zt / ge : Number.POSITIVE_INFINITY;
              if ((mt <= Ct || !ae) && (ir <= zt || !ke)) break;
              if (Mr < Sr && ae || !ke) {
                Xe = ut, wt += O * Mr;
                const pr = new le(Xe, Math.round(wt));
                g[g.length - 1].x === pr.x && g[g.length - 1].y === pr.y || g.push(pr)
              } else {
                Xe += _e * Sr, wt = kt;
                const pr = new le(Math.round(Xe), wt);
                g[g.length - 1].x === pr.x && g[g.length - 1].y === pr.y || g.push(pr)
              }
            }
            const it = new le(U, J);
            g[g.length - 1].x === it.x && g[g.length - 1].y === it.y || g.push(it)
          }
          return g
        }

        function g0(n, t, i) {
          if (t.length === 0) throw new Error("Subdivision vertex ring is empty.");
          let a = 0,
            u = n[2 * t[0]];
          for (let x = 1; x < t.length; x++) {
            const S = n[2 * t[x]];
            S < u && (u = S, a = x)
          }
          const p = t.length;
          let f = a,
            g = (f + 1) % p;
          for (;;) {
            const x = f - 1 >= 0 ? f - 1 : p - 1,
              S = (g + 1) % p,
              I = n[2 * t[x]],
              k = n[2 * t[S]],
              R = n[2 * t[f]],
              N = n[2 * t[f] + 1],
              q = n[2 * t[g] + 1];
            let U = !1;
            if (I < k) U = !0;
            else if (I > k) U = !1;
            else {
              const J = q - N,
                ae = -(n[2 * t[g]] - R),
                ke = N < q ? 1 : -1;
              ((I - R) * J + (n[2 * t[x] + 1] - N) * ae) * ke > ((k - R) * J + (n[2 * t[S] + 1] - N) * ae) * ke && (U = !0)
            }
            if (U) {
              const J = t[x],
                ae = t[f],
                ke = t[g];
              J !== ae && J !== ke && ae !== ke && i.push(ke, ae, J), f--, f < 0 && (f = p - 1)
            } else {
              const J = t[S],
                ae = t[f],
                ke = t[g];
              J !== ae && J !== ke && ae !== ke && i.push(ke, ae, J), g++, g >= p && (g = 0)
            }
            if (x === S) break
          }
        }

        function Qm(n, t, i, a, u, p, f, g, x) {
          const S = u.length / 2,
            I = f && g && x;
          if (S < pi.MAX_VERTEX_ARRAY_LENGTH) {
            const k = t.prepareSegment(S, i, a),
              R = k.vertexLength;
            for (let U = 0; U < p.length; U += 3) a.emplaceBack(R + p[U], R + p[U + 1], R + p[U + 2]);
            let N, q;
            k.vertexLength += S, k.primitiveLength += p.length / 3, I && (q = f.prepareSegment(S, i, g), N = q.vertexLength, q.vertexLength += S);
            for (let U = 0; U < u.length; U += 2) n(u[U], u[U + 1]);
            if (I)
              for (let U = 0; U < x.length; U++) {
                const J = x[U];
                for (let ae = 1; ae < J.length; ae += 2) g.emplaceBack(N + J[ae - 1], N + J[ae]);
                q.primitiveLength += J.length / 2
              }
          } else(function(k, R, N, q, U, J) {
            const ae = [];
            for (let ge = 0; ge < q.length / 2; ge++) ae.push(-1);
            const ke = {
              count: 0
            };
            let _e = 0,
              O = k.getOrCreateLatestSegment(R, N),
              Y = O.vertexLength;
            for (let ge = 2; ge < U.length; ge += 3) {
              const Xe = U[ge - 2],
                wt = U[ge - 1],
                it = U[ge];
              let ut = ae[Xe] < _e,
                kt = ae[wt] < _e,
                Ct = ae[it] < _e;
              O.vertexLength + ((ut ? 1 : 0) + (kt ? 1 : 0) + (Ct ? 1 : 0)) > pi.MAX_VERTEX_ARRAY_LENGTH && (O = k.createNewSegment(R, N), _e = ke.count, ut = !0, kt = !0, Ct = !0, Y = 0);
              const zt = hu(ae, q, J, ke, Xe, ut, O),
                mt = hu(ae, q, J, ke, wt, kt, O),
                ir = hu(ae, q, J, ke, it, Ct, O);
              N.emplaceBack(Y + zt - _e, Y + mt - _e, Y + ir - _e), O.primitiveLength++
            }
          })(t, i, a, u, p, n), I && (function(k, R, N, q, U, J) {
            const ae = [];
            for (let ge = 0; ge < q.length / 2; ge++) ae.push(-1);
            const ke = {
              count: 0
            };
            let _e = 0,
              O = k.getOrCreateLatestSegment(R, N),
              Y = O.vertexLength;
            for (let ge = 0; ge < U.length; ge++) {
              const Xe = U[ge];
              for (let wt = 1; wt < U[ge].length; wt += 2) {
                const it = Xe[wt - 1],
                  ut = Xe[wt];
                let kt = ae[it] < _e,
                  Ct = ae[ut] < _e;
                O.vertexLength + ((kt ? 1 : 0) + (Ct ? 1 : 0)) > pi.MAX_VERTEX_ARRAY_LENGTH && (O = k.createNewSegment(R, N), _e = ke.count, kt = !0, Ct = !0, Y = 0);
                const zt = hu(ae, q, J, ke, it, kt, O),
                  mt = hu(ae, q, J, ke, ut, Ct, O);
                N.emplaceBack(Y + zt - _e, Y + mt - _e), O.primitiveLength++
              }
            }
          })(f, i, g, u, x, n), t.forceNewSegmentOnNextPrepare(), f == null || f.forceNewSegmentOnNextPrepare()
        }

        function hu(n, t, i, a, u, p, f) {
          if (p) {
            const g = a.count;
            return i(t[2 * u], t[2 * u + 1]), n[u] = a.count, a.count++, f.vertexLength++, g
          }
          return n[u]
        }
        class Ep {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((i => i.id)), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new Qe, this.indexArray = new Mi, this.indexArray2 = new Pi, this.programConfigurations = new rs(t.layers, t.zoom), this.segments = new pi, this.segments2 = new pi, this.stateDependentLayerIds = this.layers.filter((i => i.isStateDependent())).map((i => i.id))
          }
          populate(t, i, a) {
            this.hasPattern = Ip("fill", this.layers, i);
            const u = this.layers[0].layout.get("fill-sort-key"),
              p = !u.isConstant(),
              f = [];
            for (const {
                feature: g,
                id: x,
                index: S,
                sourceLayerIndex: I
              }
              of t) {
              const k = this.layers[0]._featureFilter.needGeometry,
                R = Vo(g, k);
              if (!this.layers[0]._featureFilter.filter(new Bi(this.zoom, {
                  globalState: this.globalState
                }), R, a)) continue;
              const N = p ? u.evaluate(R, {}, a, i.availableImages) : void 0,
                q = {
                  id: x,
                  properties: g.properties,
                  type: g.type,
                  sourceLayerIndex: I,
                  index: S,
                  geometry: k ? R.geometry : qo(g),
                  patterns: {},
                  sortKey: N
                };
              f.push(q)
            }
            p && f.sort(((g, x) => g.sortKey - x.sortKey));
            for (const g of f) {
              const {
                geometry: x,
                index: S,
                sourceLayerIndex: I
              } = g;
              if (this.hasPattern) {
                const k = Mp("fill", this.layers, g, this.zoom, i);
                this.patternFeatures.push(k)
              } else this.addFeature(g, x, S, a, {}, i.subdivisionGranularity);
              i.featureIndex.insert(t[S].feature, x, S, I, this.index)
            }
          }
          update(t, i, a) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, i, this.stateDependentLayers, a)
          }
          addFeatures(t, i, a) {
            for (const u of this.patternFeatures) this.addFeature(u, u.geometry, u.index, i, a, t.subdivisionGranularity)
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, s0), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy())
          }
          addFeature(t, i, a, u, p, f) {
            for (const g of ll(i, 500)) {
              const x = Jm(g, u, f.fill.getGranularityForZoomLevel(u.z)),
                S = this.layoutVertexArray;
              Qm(((I, k) => {
                S.emplaceBack(I, k)
              }), this.segments, this.layoutVertexArray, this.indexArray, x.verticesFlattened, x.indicesTriangles, this.segments2, this.indexArray2, x.indicesLineList)
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, a, p, u)
          }
        }
        let e_, t_;
        Wt("FillBucket", Ep, {
          omit: ["layers", "patternFeatures"]
        });
        var v0 = {
          get paint() {
            return t_ = t_ || new Fn({
              "fill-antialias": new ar(ve.paint_fill["fill-antialias"]),
              "fill-opacity": new Lr(ve.paint_fill["fill-opacity"]),
              "fill-color": new Lr(ve.paint_fill["fill-color"]),
              "fill-outline-color": new Lr(ve.paint_fill["fill-outline-color"]),
              "fill-translate": new ar(ve.paint_fill["fill-translate"]),
              "fill-translate-anchor": new ar(ve.paint_fill["fill-translate-anchor"]),
              "fill-pattern": new El(ve.paint_fill["fill-pattern"])
            })
          },
          get layout() {
            return e_ = e_ || new Fn({
              "fill-sort-key": new Lr(ve.layout_fill["fill-sort-key"])
            })
          }
        };
        class y0 extends wn {
          constructor(t) {
            super(t, v0)
          }
          recalculate(t, i) {
            super.recalculate(t, i);
            const a = this.paint._values["fill-outline-color"];
            a.value.kind === "constant" && a.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"])
          }
          createBucket(t) {
            return new Ep(t)
          }
          queryRadius() {
            return id(this.paint.get("fill-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: t,
            geometry: i,
            transform: a,
            pixelsToTileUnits: u
          }) {
            return Lm(nd(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -a.bearingInRadians, u), i)
          }
          isTileClipped() {
            return !0
          }
        }
        const x0 = Ui([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_normal_ed",
            components: 4,
            type: "Int16"
          }], 4),
          b0 = Ui([{
            name: "a_centroid",
            components: 2,
            type: "Int16"
          }], 4),
          {
            members: w0
          } = x0;
        var zp, r_, Lp, i_, Dp, n_, a_, ld = {};

        function s_() {
          if (r_) return zp;
          r_ = 1;
          var n = de();

          function t(u, p, f, g, x) {
            this.properties = {}, this.extent = f, this.type = 0, this._pbf = u, this._geometry = -1, this._keys = g, this._values = x, u.readFields(i, this, p)
          }

          function i(u, p, f) {
            u == 1 ? p.id = f.readVarint() : u == 2 ? (function(g, x) {
              for (var S = g.readVarint() + g.pos; g.pos < S;) {
                var I = x._keys[g.readVarint()],
                  k = x._values[g.readVarint()];
                x.properties[I] = k
              }
            })(f, p) : u == 3 ? p.type = f.readVarint() : u == 4 && (p._geometry = f.pos)
          }

          function a(u) {
            for (var p, f, g = 0, x = 0, S = u.length, I = S - 1; x < S; I = x++) g += ((f = u[I]).x - (p = u[x]).x) * (p.y + f.y);
            return g
          }
          return zp = t, t.types = ["Unknown", "Point", "LineString", "Polygon"], t.prototype.loadGeometry = function() {
            var u = this._pbf;
            u.pos = this._geometry;
            for (var p, f = u.readVarint() + u.pos, g = 1, x = 0, S = 0, I = 0, k = []; u.pos < f;) {
              if (x <= 0) {
                var R = u.readVarint();
                g = 7 & R, x = R >> 3
              }
              if (x--, g === 1 || g === 2) S += u.readSVarint(), I += u.readSVarint(), g === 1 && (p && k.push(p), p = []), p.push(new n(S, I));
              else {
                if (g !== 7) throw new Error("unknown command " + g);
                p && p.push(p[0].clone())
              }
            }
            return p && k.push(p), k
          }, t.prototype.bbox = function() {
            var u = this._pbf;
            u.pos = this._geometry;
            for (var p = u.readVarint() + u.pos, f = 1, g = 0, x = 0, S = 0, I = 1 / 0, k = -1 / 0, R = 1 / 0, N = -1 / 0; u.pos < p;) {
              if (g <= 0) {
                var q = u.readVarint();
                f = 7 & q, g = q >> 3
              }
              if (g--, f === 1 || f === 2)(x += u.readSVarint()) < I && (I = x), x > k && (k = x), (S += u.readSVarint()) < R && (R = S), S > N && (N = S);
              else if (f !== 7) throw new Error("unknown command " + f)
            }
            return [I, R, k, N]
          }, t.prototype.toGeoJSON = function(u, p, f) {
            var g, x, S = this.extent * Math.pow(2, f),
              I = this.extent * u,
              k = this.extent * p,
              R = this.loadGeometry(),
              N = t.types[this.type];

            function q(ae) {
              for (var ke = 0; ke < ae.length; ke++) {
                var _e = ae[ke];
                ae[ke] = [360 * (_e.x + I) / S - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (_e.y + k) / S) * Math.PI / 180)) - 90]
              }
            }
            switch (this.type) {
              case 1:
                var U = [];
                for (g = 0; g < R.length; g++) U[g] = R[g][0];
                q(R = U);
                break;
              case 2:
                for (g = 0; g < R.length; g++) q(R[g]);
                break;
              case 3:
                for (R = (function(ae) {
                    var ke = ae.length;
                    if (ke <= 1) return [ae];
                    for (var _e, O, Y = [], ge = 0; ge < ke; ge++) {
                      var Xe = a(ae[ge]);
                      Xe !== 0 && (O === void 0 && (O = Xe < 0), O === Xe < 0 ? (_e && Y.push(_e), _e = [ae[ge]]) : _e.push(ae[ge]))
                    }
                    return _e && Y.push(_e), Y
                  })(R), g = 0; g < R.length; g++)
                  for (x = 0; x < R[g].length; x++) q(R[g][x])
            }
            R.length === 1 ? R = R[0] : N = "Multi" + N;
            var J = {
              type: "Feature",
              geometry: {
                type: N,
                coordinates: R
              },
              properties: this.properties
            };
            return "id" in this && (J.id = this.id), J
          }, zp
        }

        function o_() {
          if (i_) return Lp;
          i_ = 1;
          var n = s_();

          function t(a, u) {
            this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = a, this._keys = [], this._values = [], this._features = [], a.readFields(i, this, u), this.length = this._features.length
          }

          function i(a, u, p) {
            a === 15 ? u.version = p.readVarint() : a === 1 ? u.name = p.readString() : a === 5 ? u.extent = p.readVarint() : a === 2 ? u._features.push(p.pos) : a === 3 ? u._keys.push(p.readString()) : a === 4 && u._values.push((function(f) {
              for (var g = null, x = f.readVarint() + f.pos; f.pos < x;) {
                var S = f.readVarint() >> 3;
                g = S === 1 ? f.readString() : S === 2 ? f.readFloat() : S === 3 ? f.readDouble() : S === 4 ? f.readVarint64() : S === 5 ? f.readVarint() : S === 6 ? f.readSVarint() : S === 7 ? f.readBoolean() : null
              }
              return g
            })(p))
          }
          return Lp = t, t.prototype.feature = function(a) {
            if (a < 0 || a >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[a];
            var u = this._pbf.readVarint() + this._pbf.pos;
            return new n(this._pbf, u, this.extent, this._keys, this._values)
          }, Lp
        }

        function l_() {
          return a_ || (a_ = 1, ld.VectorTile = (function() {
            if (n_) return Dp;
            n_ = 1;
            var n = o_();

            function t(i, a, u) {
              if (i === 3) {
                var p = new n(u, u.readVarint() + u.pos);
                p.length && (a[p.name] = p)
              }
            }
            return Dp = function(i, a) {
              this.layers = i.readFields(t, {}, a)
            }, Dp
          })(), ld.VectorTileFeature = s_(), ld.VectorTileLayer = o_()), ld
        }
        var du = K(l_());
        const T0 = du.VectorTileFeature.types,
          Rp = Math.pow(2, 13);

        function pu(n, t, i, a, u, p, f, g) {
          n.emplaceBack(t, i, 2 * Math.floor(a * Rp) + f, u * Rp * 2, p * Rp * 2, Math.round(g))
        }
        class Bp {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((i => i.id)), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new qt, this.centroidVertexArray = new Ge, this.indexArray = new Mi, this.programConfigurations = new rs(t.layers, t.zoom), this.segments = new pi, this.stateDependentLayerIds = this.layers.filter((i => i.isStateDependent())).map((i => i.id))
          }
          populate(t, i, a) {
            this.features = [], this.hasPattern = Ip("fill-extrusion", this.layers, i);
            for (const {
                feature: u,
                id: p,
                index: f,
                sourceLayerIndex: g
              }
              of t) {
              const x = this.layers[0]._featureFilter.needGeometry,
                S = Vo(u, x);
              if (!this.layers[0]._featureFilter.filter(new Bi(this.zoom, {
                  globalState: this.globalState
                }), S, a)) continue;
              const I = {
                id: p,
                sourceLayerIndex: g,
                index: f,
                geometry: x ? S.geometry : qo(u),
                properties: u.properties,
                type: u.type,
                patterns: {}
              };
              this.hasPattern ? this.features.push(Mp("fill-extrusion", this.layers, I, this.zoom, i)) : this.addFeature(I, I.geometry, f, a, {}, i.subdivisionGranularity), i.featureIndex.insert(u, I.geometry, f, g, this.index, !0)
            }
          }
          addFeatures(t, i, a) {
            for (const u of this.features) {
              const {
                geometry: p
              } = u;
              this.addFeature(u, p, u.index, i, a, t.subdivisionGranularity)
            }
          }
          update(t, i, a) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, i, this.stateDependentLayers, a)
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, w0), this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, b0.members, !0), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy())
          }
          addFeature(t, i, a, u, p, f) {
            for (const g of ll(i, 500)) {
              const x = {
                  x: 0,
                  y: 0,
                  sampleCount: 0
                },
                S = this.layoutVertexArray.length;
              this.processPolygon(x, u, t, g, f);
              const I = this.layoutVertexArray.length - S,
                k = Math.floor(x.x / x.sampleCount),
                R = Math.floor(x.y / x.sampleCount);
              for (let N = 0; N < I; N++) this.centroidVertexArray.emplaceBack(k, R)
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, a, p, u)
          }
          processPolygon(t, i, a, u, p) {
            if (u.length < 1 || c_(u[0])) return;
            for (const k of u) k.length !== 0 && C0(t, k);
            const f = {
                segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray)
              },
              g = p.fill.getGranularityForZoomLevel(i.z),
              x = T0[a.type] === "Polygon";
            for (const k of u) {
              if (k.length === 0 || c_(k)) continue;
              const R = $o(k, g, x);
              this._generateSideFaces(R, f)
            }
            if (!x) return;
            const S = Jm(u, i, g, !1),
              I = this.layoutVertexArray;
            Qm(((k, R) => {
              pu(I, k, R, 0, 0, 1, 1, 0)
            }), this.segments, this.layoutVertexArray, this.indexArray, S.verticesFlattened, S.indicesTriangles)
          }
          _generateSideFaces(t, i) {
            let a = 0;
            for (let u = 1; u < t.length; u++) {
              const p = t[u],
                f = t[u - 1];
              if (S0(p, f)) continue;
              i.segment.vertexLength + 4 > pi.MAX_VERTEX_ARRAY_LENGTH && (i.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              const g = p.sub(f)._perp()._unit(),
                x = f.dist(p);
              a + x > 32768 && (a = 0), pu(this.layoutVertexArray, p.x, p.y, g.x, g.y, 0, 0, a), pu(this.layoutVertexArray, p.x, p.y, g.x, g.y, 0, 1, a), a += x, pu(this.layoutVertexArray, f.x, f.y, g.x, g.y, 0, 0, a), pu(this.layoutVertexArray, f.x, f.y, g.x, g.y, 0, 1, a);
              const S = i.segment.vertexLength;
              this.indexArray.emplaceBack(S, S + 2, S + 1), this.indexArray.emplaceBack(S + 1, S + 2, S + 3), i.segment.vertexLength += 4, i.segment.primitiveLength += 2
            }
          }
        }

        function C0(n, t) {
          for (let i = 0; i < t.length; i++) {
            const a = t[i];
            i === t.length - 1 && t[0].x === a.x && t[0].y === a.y || (n.x += a.x, n.y += a.y, n.sampleCount++)
          }
        }

        function S0(n, t) {
          return n.x === t.x && (n.x < 0 || n.x > Ke) || n.y === t.y && (n.y < 0 || n.y > Ke)
        }

        function c_(n) {
          return n.every((t => t.x < 0)) || n.every((t => t.x > Ke)) || n.every((t => t.y < 0)) || n.every((t => t.y > Ke))
        }
        let u_;
        Wt("FillExtrusionBucket", Bp, {
          omit: ["layers", "features"]
        });
        var P0 = {
          get paint() {
            return u_ = u_ || new Fn({
              "fill-extrusion-opacity": new ar(ve["paint_fill-extrusion"]["fill-extrusion-opacity"]),
              "fill-extrusion-color": new Lr(ve["paint_fill-extrusion"]["fill-extrusion-color"]),
              "fill-extrusion-translate": new ar(ve["paint_fill-extrusion"]["fill-extrusion-translate"]),
              "fill-extrusion-translate-anchor": new ar(ve["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
              "fill-extrusion-pattern": new El(ve["paint_fill-extrusion"]["fill-extrusion-pattern"]),
              "fill-extrusion-height": new Lr(ve["paint_fill-extrusion"]["fill-extrusion-height"]),
              "fill-extrusion-base": new Lr(ve["paint_fill-extrusion"]["fill-extrusion-base"]),
              "fill-extrusion-vertical-gradient": new ar(ve["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])
            })
          }
        };
        class I0 extends wn {
          constructor(t) {
            super(t, P0)
          }
          createBucket(t) {
            return new Bp(t)
          }
          queryRadius() {
            return id(this.paint.get("fill-extrusion-translate"))
          }
          is3D() {
            return !0
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: i,
            featureState: a,
            geometry: u,
            transform: p,
            pixelsToTileUnits: f,
            pixelPosMatrix: g
          }) {
            const x = nd(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -p.bearingInRadians, f),
              S = this.paint.get("fill-extrusion-height").evaluate(i, a),
              I = this.paint.get("fill-extrusion-base").evaluate(i, a),
              k = (function(N, q) {
                const U = [];
                for (const J of N) {
                  const ae = [J.x, J.y, 0, 1];
                  re(ae, ae, q), U.push(new le(ae[0] / ae[3], ae[1] / ae[3]))
                }
                return U
              })(x, g),
              R = (function(N, q, U, J) {
                const ae = [],
                  ke = [],
                  _e = J[8] * q,
                  O = J[9] * q,
                  Y = J[10] * q,
                  ge = J[11] * q,
                  Xe = J[8] * U,
                  wt = J[9] * U,
                  it = J[10] * U,
                  ut = J[11] * U;
                for (const kt of N) {
                  const Ct = [],
                    zt = [];
                  for (const mt of kt) {
                    const ir = mt.x,
                      Mr = mt.y,
                      Sr = J[0] * ir + J[4] * Mr + J[12],
                      pr = J[1] * ir + J[5] * Mr + J[13],
                      ui = J[2] * ir + J[6] * Mr + J[14],
                      Gi = J[3] * ir + J[7] * Mr + J[15],
                      on = ui + Y,
                      Ln = Gi + ge,
                      ya = Sr + Xe,
                      ia = pr + wt,
                      Pn = ui + it,
                      Zi = Gi + ut,
                      _n = new le((Sr + _e) / Ln, (pr + O) / Ln);
                    _n.z = on / Ln, Ct.push(_n);
                    const In = new le(ya / Zi, ia / Zi);
                    In.z = Pn / Zi, zt.push(In)
                  }
                  ae.push(Ct), ke.push(zt)
                }
                return [ae, ke]
              })(u, I, S, g);
            return (function(N, q, U) {
              let J = 1 / 0;
              Lm(U, q) && (J = h_(U, q[0]));
              for (let ae = 0; ae < q.length; ae++) {
                const ke = q[ae],
                  _e = N[ae];
                for (let O = 0; O < ke.length - 1; O++) {
                  const Y = ke[O],
                    ge = [Y, ke[O + 1], _e[O + 1], _e[O], Y];
                  zm(U, ge) && (J = Math.min(J, h_(U, ge)))
                }
              }
              return J !== 1 / 0 && J
            })(R[0], R[1], k)
          }
        }

        function fu(n, t) {
          return n.x * t.x + n.y * t.y
        }

        function h_(n, t) {
          if (n.length === 1) {
            let i = 0;
            const a = t[i++];
            let u;
            for (; !u || a.equals(u);)
              if (u = t[i++], !u) return 1 / 0;
            for (; i < t.length; i++) {
              const p = t[i],
                f = n[0],
                g = u.sub(a),
                x = p.sub(a),
                S = f.sub(a),
                I = fu(g, g),
                k = fu(g, x),
                R = fu(x, x),
                N = fu(S, g),
                q = fu(S, x),
                U = I * R - k * k,
                J = (R * N - k * q) / U,
                ae = (I * q - k * N) / U,
                ke = a.z * (1 - J - ae) + u.z * J + p.z * ae;
              if (isFinite(ke)) return ke
            }
            return 1 / 0
          } {
            let i = 1 / 0;
            for (const a of t) i = Math.min(i, a.z);
            return i
          }
        }
        const M0 = Ui([{
            name: "a_pos_normal",
            components: 2,
            type: "Int16"
          }, {
            name: "a_data",
            components: 4,
            type: "Uint8"
          }], 4),
          {
            members: A0
          } = M0,
          k0 = Ui([{
            name: "a_uv_x",
            components: 1,
            type: "Float32"
          }, {
            name: "a_split_index",
            components: 1,
            type: "Float32"
          }]),
          {
            members: E0
          } = k0,
          z0 = du.VectorTileFeature.types,
          L0 = Math.cos(Math.PI / 180 * 37.5),
          d_ = Math.pow(2, 14) / .5;
        class Fp {
          constructor(t) {
            this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((i => i.id)), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((i => {
              this.gradients[i.id] = {}
            })), this.layoutVertexArray = new Ft, this.layoutVertexArray2 = new Tt, this.indexArray = new Mi, this.programConfigurations = new rs(t.layers, t.zoom), this.segments = new pi, this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((i => i.isStateDependent())).map((i => i.id))
          }
          populate(t, i, a) {
            this.hasPattern = Ip("line", this.layers, i);
            const u = this.layers[0].layout.get("line-sort-key"),
              p = !u.isConstant(),
              f = [];
            for (const {
                feature: g,
                id: x,
                index: S,
                sourceLayerIndex: I
              }
              of t) {
              const k = this.layers[0]._featureFilter.needGeometry,
                R = Vo(g, k);
              if (!this.layers[0]._featureFilter.filter(new Bi(this.zoom, {
                  globalState: this.globalState
                }), R, a)) continue;
              const N = p ? u.evaluate(R, {}, a) : void 0,
                q = {
                  id: x,
                  properties: g.properties,
                  type: g.type,
                  sourceLayerIndex: I,
                  index: S,
                  geometry: k ? R.geometry : qo(g),
                  patterns: {},
                  sortKey: N
                };
              f.push(q)
            }
            p && f.sort(((g, x) => g.sortKey - x.sortKey));
            for (const g of f) {
              const {
                geometry: x,
                index: S,
                sourceLayerIndex: I
              } = g;
              if (this.hasPattern) {
                const k = Mp("line", this.layers, g, this.zoom, i);
                this.patternFeatures.push(k)
              } else this.addFeature(g, x, S, a, {}, i.subdivisionGranularity);
              i.featureIndex.insert(t[S].feature, x, S, I, this.index)
            }
          }
          update(t, i, a) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, i, this.stateDependentLayers, a)
          }
          addFeatures(t, i, a) {
            for (const u of this.patternFeatures) this.addFeature(u, u.geometry, u.index, i, a, t.subdivisionGranularity)
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload
          }
          upload(t) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, E0)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, A0), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy())
          }
          lineFeatureClips(t) {
            if (t.properties && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_end")) return {
              start: +t.properties.mapbox_clip_start,
              end: +t.properties.mapbox_clip_end
            }
          }
          addFeature(t, i, a, u, p, f) {
            const g = this.layers[0].layout,
              x = g.get("line-join").evaluate(t, {}),
              S = g.get("line-cap"),
              I = g.get("line-miter-limit"),
              k = g.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t);
            for (const R of i) this.addLine(R, t, x, S, I, k, u, f);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, a, p, u)
          }
          addLine(t, i, a, u, p, f, g, x) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t = $o(t, g ? x.line.getGranularityForZoomLevel(g.z) : 1), this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let _e = 0; _e < t.length - 1; _e++) this.totalDistance += t[_e].dist(t[_e + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance)
            }
            const S = z0[i.type] === "Polygon";
            let I = t.length;
            for (; I >= 2 && t[I - 1].equals(t[I - 2]);) I--;
            let k = 0;
            for (; k < I - 1 && t[k].equals(t[k + 1]);) k++;
            if (I < (S ? 3 : 2)) return;
            a === "bevel" && (p = 1.05);
            const R = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0,
              N = this.segments.prepareSegment(10 * I, this.layoutVertexArray, this.indexArray);
            let q, U, J, ae, ke;
            this.e1 = this.e2 = -1, S && (q = t[I - 2], ke = t[k].sub(q)._unit()._perp());
            for (let _e = k; _e < I; _e++) {
              if (J = _e === I - 1 ? S ? t[k + 1] : void 0 : t[_e + 1], J && t[_e].equals(J)) continue;
              ke && (ae = ke), q && (U = q), q = t[_e], ke = J ? J.sub(q)._unit()._perp() : ae, ae = ae || ke;
              let O = ae.add(ke);
              O.x === 0 && O.y === 0 || O._unit();
              const Y = ae.x * ke.x + ae.y * ke.y,
                ge = O.x * ke.x + O.y * ke.y,
                Xe = ge !== 0 ? 1 / ge : 1 / 0,
                wt = 2 * Math.sqrt(2 - 2 * ge),
                it = ge < L0 && U && J,
                ut = ae.x * ke.y - ae.y * ke.x > 0;
              if (it && _e > k) {
                const zt = q.dist(U);
                if (zt > 2 * R) {
                  const mt = q.sub(q.sub(U)._mult(R / zt)._round());
                  this.updateDistance(U, mt), this.addCurrentVertex(mt, ae, 0, 0, N), U = mt
                }
              }
              const kt = U && J;
              let Ct = kt ? a : S ? "butt" : u;
              if (kt && Ct === "round" && (Xe < f ? Ct = "miter" : Xe <= 2 && (Ct = "fakeround")), Ct === "miter" && Xe > p && (Ct = "bevel"), Ct === "bevel" && (Xe > 2 && (Ct = "flipbevel"), Xe < p && (Ct = "miter")), U && this.updateDistance(U, q), Ct === "miter") O._mult(Xe), this.addCurrentVertex(q, O, 0, 0, N);
              else if (Ct === "flipbevel") {
                if (Xe > 100) O = ke.mult(-1);
                else {
                  const zt = Xe * ae.add(ke).mag() / ae.sub(ke).mag();
                  O._perp()._mult(zt * (ut ? -1 : 1))
                }
                this.addCurrentVertex(q, O, 0, 0, N), this.addCurrentVertex(q, O.mult(-1), 0, 0, N)
              } else if (Ct === "bevel" || Ct === "fakeround") {
                const zt = -Math.sqrt(Xe * Xe - 1),
                  mt = ut ? zt : 0,
                  ir = ut ? 0 : zt;
                if (U && this.addCurrentVertex(q, ae, mt, ir, N), Ct === "fakeround") {
                  const Mr = Math.round(180 * wt / Math.PI / 20);
                  for (let Sr = 1; Sr < Mr; Sr++) {
                    let pr = Sr / Mr;
                    if (pr !== .5) {
                      const Gi = pr - .5;
                      pr += pr * Gi * (pr - 1) * ((1.0904 + Y * (Y * (3.55645 - 1.43519 * Y) - 3.2452)) * Gi * Gi + (.848013 + Y * (.215638 * Y - 1.06021)))
                    }
                    const ui = ke.sub(ae)._mult(pr)._add(ae)._unit()._mult(ut ? -1 : 1);
                    this.addHalfVertex(q, ui.x, ui.y, !1, ut, 0, N)
                  }
                }
                J && this.addCurrentVertex(q, ke, -mt, -ir, N)
              } else if (Ct === "butt") this.addCurrentVertex(q, O, 0, 0, N);
              else if (Ct === "square") {
                const zt = U ? 1 : -1;
                this.addCurrentVertex(q, O, zt, zt, N)
              } else Ct === "round" && (U && (this.addCurrentVertex(q, ae, 0, 0, N), this.addCurrentVertex(q, ae, 1, 1, N, !0)), J && (this.addCurrentVertex(q, ke, -1, -1, N, !0), this.addCurrentVertex(q, ke, 0, 0, N)));
              if (it && _e < I - 1) {
                const zt = q.dist(J);
                if (zt > 2 * R) {
                  const mt = q.add(J.sub(q)._mult(R / zt)._round());
                  this.updateDistance(q, mt), this.addCurrentVertex(mt, ke, 0, 0, N), q = mt
                }
              }
            }
          }
          addCurrentVertex(t, i, a, u, p, f = !1) {
            const g = i.y * u - i.x,
              x = -i.y - i.x * u;
            this.addHalfVertex(t, i.x + i.y * a, i.y - i.x * a, f, !1, a, p), this.addHalfVertex(t, g, x, f, !0, -u, p), this.distance > d_ / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t, i, a, u, p, f))
          }
          addHalfVertex({
            x: t,
            y: i
          }, a, u, p, f, g, x) {
            const S = .5 * (this.lineClips ? this.scaledDistance * (d_ - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((t << 1) + (p ? 1 : 0), (i << 1) + (f ? 1 : 0), Math.round(63 * a) + 128, Math.round(63 * u) + 128, 1 + (g === 0 ? 0 : g < 0 ? -1 : 1) | (63 & S) << 2, S >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const I = x.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, I, this.e2), x.primitiveLength++), f ? this.e2 = I : this.e1 = I
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance
          }
          updateDistance(t, i) {
            this.distance += t.dist(i), this.updateScaledDistance()
          }
        }
        let p_, f_;
        Wt("LineBucket", Fp, {
          omit: ["layers", "patternFeatures"]
        });
        var m_ = {
          get paint() {
            return f_ = f_ || new Fn({
              "line-opacity": new Lr(ve.paint_line["line-opacity"]),
              "line-color": new Lr(ve.paint_line["line-color"]),
              "line-translate": new ar(ve.paint_line["line-translate"]),
              "line-translate-anchor": new ar(ve.paint_line["line-translate-anchor"]),
              "line-width": new Lr(ve.paint_line["line-width"]),
              "line-gap-width": new Lr(ve.paint_line["line-gap-width"]),
              "line-offset": new Lr(ve.paint_line["line-offset"]),
              "line-blur": new Lr(ve.paint_line["line-blur"]),
              "line-dasharray": new Kc(ve.paint_line["line-dasharray"]),
              "line-pattern": new El(ve.paint_line["line-pattern"]),
              "line-gradient": new Ro(ve.paint_line["line-gradient"])
            })
          },
          get layout() {
            return p_ = p_ || new Fn({
              "line-cap": new ar(ve.layout_line["line-cap"]),
              "line-join": new Lr(ve.layout_line["line-join"]),
              "line-miter-limit": new ar(ve.layout_line["line-miter-limit"]),
              "line-round-limit": new ar(ve.layout_line["line-round-limit"]),
              "line-sort-key": new Lr(ve.layout_line["line-sort-key"])
            })
          }
        };
        class D0 extends Lr {
          possiblyEvaluate(t, i) {
            return i = new Bi(Math.floor(i.zoom), {
              now: i.now,
              fadeDuration: i.fadeDuration,
              zoomHistory: i.zoomHistory,
              transition: i.transition
            }), super.possiblyEvaluate(t, i)
          }
          evaluate(t, i, a, u) {
            return i = St({}, i, {
              zoom: Math.floor(i.zoom)
            }), super.evaluate(t, i, a, u)
          }
        }
        let cd;
        class R0 extends wn {
          constructor(t) {
            super(t, m_), this.gradientVersion = 0, cd || (cd = new D0(m_.paint.properties["line-width"].specification), cd.useIntegerZoom = !0)
          }
          _handleSpecialPaintPropertyUpdate(t) {
            if (t === "line-gradient") {
              const i = this.gradientExpression();
              this.stepInterpolant = !!(function(a) {
                return a._styleExpression !== void 0
              })(i) && i._styleExpression.expression instanceof Es, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression
          }
          recalculate(t, i) {
            super.recalculate(t, i), this.paint._values["line-floorwidth"] = cd.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t)
          }
          createBucket(t) {
            return new Fp(t)
          }
          queryRadius(t) {
            const i = t,
              a = __(nu("line-width", this, i), nu("line-gap-width", this, i)),
              u = nu("line-offset", this, i);
            return a / 2 + Math.abs(u) + id(this.paint.get("line-translate"))
          }
          queryIntersectsFeature({
            queryGeometry: t,
            feature: i,
            featureState: a,
            geometry: u,
            transform: p,
            pixelsToTileUnits: f
          }) {
            const g = nd(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -p.bearingInRadians, f),
              x = f / 2 * __(this.paint.get("line-width").evaluate(i, a), this.paint.get("line-gap-width").evaluate(i, a)),
              S = this.paint.get("line-offset").evaluate(i, a);
            return S && (u = (function(I, k) {
              const R = [];
              for (let N = 0; N < I.length; N++) {
                const q = I[N],
                  U = [];
                for (let J = 0; J < q.length; J++) {
                  const ae = q[J - 1],
                    ke = q[J],
                    _e = q[J + 1],
                    O = J === 0 ? new le(0, 0) : ke.sub(ae)._unit()._perp(),
                    Y = J === q.length - 1 ? new le(0, 0) : _e.sub(ke)._unit()._perp(),
                    ge = O._add(Y)._unit(),
                    Xe = ge.x * Y.x + ge.y * Y.y;
                  Xe !== 0 && ge._mult(1 / Xe), U.push(ge._mult(k)._add(ke))
                }
                R.push(U)
              }
              return R
            })(u, S * f)), (function(I, k, R) {
              for (let N = 0; N < k.length; N++) {
                const q = k[N];
                if (I.length >= 3) {
                  for (let U = 0; U < q.length; U++)
                    if (Dl(I, q[U])) return !0
                }
                if (Wv(I, q, R)) return !0
              }
              return !1
            })(g, u, x)
          }
          isTileClipped() {
            return !0
          }
        }

        function __(n, t) {
          return t > 0 ? t + 2 * n : n
        }
        const B0 = Ui([{
            name: "a_pos_offset",
            components: 4,
            type: "Int16"
          }, {
            name: "a_data",
            components: 4,
            type: "Uint16"
          }, {
            name: "a_pixeloffset",
            components: 4,
            type: "Int16"
          }], 4),
          F0 = Ui([{
            name: "a_projected_pos",
            components: 3,
            type: "Float32"
          }], 4);
        Ui([{
          name: "a_fade_opacity",
          components: 1,
          type: "Uint32"
        }], 4);
        const O0 = Ui([{
          name: "a_placed",
          components: 2,
          type: "Uint8"
        }, {
          name: "a_shift",
          components: 2,
          type: "Float32"
        }, {
          name: "a_box_real",
          components: 2,
          type: "Int16"
        }]);
        Ui([{
          type: "Int16",
          name: "anchorPointX"
        }, {
          type: "Int16",
          name: "anchorPointY"
        }, {
          type: "Int16",
          name: "x1"
        }, {
          type: "Int16",
          name: "y1"
        }, {
          type: "Int16",
          name: "x2"
        }, {
          type: "Int16",
          name: "y2"
        }, {
          type: "Uint32",
          name: "featureIndex"
        }, {
          type: "Uint16",
          name: "sourceLayerIndex"
        }, {
          type: "Uint16",
          name: "bucketIndex"
        }]);
        const g_ = Ui([{
            name: "a_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_anchor_pos",
            components: 2,
            type: "Int16"
          }, {
            name: "a_extrude",
            components: 2,
            type: "Int16"
          }], 4),
          N0 = Ui([{
            name: "a_pos",
            components: 2,
            type: "Float32"
          }, {
            name: "a_radius",
            components: 1,
            type: "Float32"
          }, {
            name: "a_flags",
            components: 2,
            type: "Int16"
          }], 4);

        function j0(n, t, i) {
          return n.sections.forEach((a => {
            a.text = (function(u, p, f) {
              const g = p.layout.get("text-transform").evaluate(f, {});
              return g === "uppercase" ? u = u.toLocaleUpperCase() : g === "lowercase" && (u = u.toLocaleLowerCase()), Xa.applyArabicShaping && (u = Xa.applyArabicShaping(u)), u
            })(a.text, t, i)
          })), n
        }
        Ui([{
          name: "triangle",
          components: 3,
          type: "Uint16"
        }]), Ui([{
          type: "Int16",
          name: "anchorX"
        }, {
          type: "Int16",
          name: "anchorY"
        }, {
          type: "Uint16",
          name: "glyphStartIndex"
        }, {
          type: "Uint16",
          name: "numGlyphs"
        }, {
          type: "Uint32",
          name: "vertexStartIndex"
        }, {
          type: "Uint32",
          name: "lineStartIndex"
        }, {
          type: "Uint32",
          name: "lineLength"
        }, {
          type: "Uint16",
          name: "segment"
        }, {
          type: "Uint16",
          name: "lowerSize"
        }, {
          type: "Uint16",
          name: "upperSize"
        }, {
          type: "Float32",
          name: "lineOffsetX"
        }, {
          type: "Float32",
          name: "lineOffsetY"
        }, {
          type: "Uint8",
          name: "writingMode"
        }, {
          type: "Uint8",
          name: "placedOrientation"
        }, {
          type: "Uint8",
          name: "hidden"
        }, {
          type: "Uint32",
          name: "crossTileID"
        }, {
          type: "Int16",
          name: "associatedIconIndex"
        }]), Ui([{
          type: "Int16",
          name: "anchorX"
        }, {
          type: "Int16",
          name: "anchorY"
        }, {
          type: "Int16",
          name: "rightJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "centerJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "leftJustifiedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "verticalPlacedTextSymbolIndex"
        }, {
          type: "Int16",
          name: "placedIconSymbolIndex"
        }, {
          type: "Int16",
          name: "verticalPlacedIconSymbolIndex"
        }, {
          type: "Uint16",
          name: "key"
        }, {
          type: "Uint16",
          name: "textBoxStartIndex"
        }, {
          type: "Uint16",
          name: "textBoxEndIndex"
        }, {
          type: "Uint16",
          name: "verticalTextBoxStartIndex"
        }, {
          type: "Uint16",
          name: "verticalTextBoxEndIndex"
        }, {
          type: "Uint16",
          name: "iconBoxStartIndex"
        }, {
          type: "Uint16",
          name: "iconBoxEndIndex"
        }, {
          type: "Uint16",
          name: "verticalIconBoxStartIndex"
        }, {
          type: "Uint16",
          name: "verticalIconBoxEndIndex"
        }, {
          type: "Uint16",
          name: "featureIndex"
        }, {
          type: "Uint16",
          name: "numHorizontalGlyphVertices"
        }, {
          type: "Uint16",
          name: "numVerticalGlyphVertices"
        }, {
          type: "Uint16",
          name: "numIconVertices"
        }, {
          type: "Uint16",
          name: "numVerticalIconVertices"
        }, {
          type: "Uint16",
          name: "useRuntimeCollisionCircles"
        }, {
          type: "Uint32",
          name: "crossTileID"
        }, {
          type: "Float32",
          name: "textBoxScale"
        }, {
          type: "Float32",
          name: "collisionCircleDiameter"
        }, {
          type: "Uint16",
          name: "textAnchorOffsetStartIndex"
        }, {
          type: "Uint16",
          name: "textAnchorOffsetEndIndex"
        }]), Ui([{
          type: "Float32",
          name: "offsetX"
        }]), Ui([{
          type: "Int16",
          name: "x"
        }, {
          type: "Int16",
          name: "y"
        }, {
          type: "Int16",
          name: "tileUnitDistanceFromAnchor"
        }]), Ui([{
          type: "Uint16",
          name: "textAnchor"
        }, {
          type: "Float32",
          components: 2,
          name: "textOffset"
        }]);
        const mu = {
          "!": "︕",
          "#": "＃",
          $: "＄",
          "%": "％",
          "&": "＆",
          "(": "︵",
          ")": "︶",
          "*": "＊",
          "+": "＋",
          ",": "︐",
          "-": "︲",
          ".": "・",
          "/": "／",
          ":": "︓",
          ";": "︔",
          "<": "︿",
          "=": "＝",
          ">": "﹀",
          "?": "︖",
          "@": "＠",
          "[": "﹇",
          "\\": "＼",
          "]": "﹈",
          "^": "＾",
          _: "︳",
          "`": "｀",
          "{": "︷",
          "|": "―",
          "}": "︸",
          "~": "～",
          "¢": "￠",
          "£": "￡",
          "¥": "￥",
          "¦": "￤",
          "¬": "￢",
          "¯": "￣",
          "–": "︲",
          "—": "︱",
          "‘": "﹃",
          "’": "﹄",
          "“": "﹁",
          "”": "﹂",
          "…": "︙",
          "‧": "・",
          "₩": "￦",
          "、": "︑",
          "。": "︒",
          "〈": "︿",
          "〉": "﹀",
          "《": "︽",
          "》": "︾",
          "「": "﹁",
          "」": "﹂",
          "『": "﹃",
          "』": "﹄",
          "【": "︻",
          "】": "︼",
          "〔": "︹",
          "〕": "︺",
          "〖": "︗",
          "〗": "︘",
          "！": "︕",
          "（": "︵",
          "）": "︶",
          "，": "︐",
          "－": "︲",
          "．": "・",
          "：": "︓",
          "；": "︔",
          "＜": "︿",
          "＞": "﹀",
          "？": "︖",
          "［": "﹇",
          "］": "﹈",
          "＿": "︳",
          "｛": "︷",
          "｜": "―",
          "｝": "︸",
          "｟": "︵",
          "｠": "︶",
          "｡": "︒",
          "｢": "﹁",
          "｣": "﹂"
        };
        var v_, Op, y_, mn = 24,
          Np = {};

        function q0() {
          return v_ || (v_ = 1, Np.read = function(n, t, i, a, u) {
            var p, f, g = 8 * u - a - 1,
              x = (1 << g) - 1,
              S = x >> 1,
              I = -7,
              k = i ? u - 1 : 0,
              R = i ? -1 : 1,
              N = n[t + k];
            for (k += R, p = N & (1 << -I) - 1, N >>= -I, I += g; I > 0; p = 256 * p + n[t + k], k += R, I -= 8);
            for (f = p & (1 << -I) - 1, p >>= -I, I += a; I > 0; f = 256 * f + n[t + k], k += R, I -= 8);
            if (p === 0) p = 1 - S;
            else {
              if (p === x) return f ? NaN : 1 / 0 * (N ? -1 : 1);
              f += Math.pow(2, a), p -= S
            }
            return (N ? -1 : 1) * f * Math.pow(2, p - a)
          }, Np.write = function(n, t, i, a, u, p) {
            var f, g, x, S = 8 * p - u - 1,
              I = (1 << S) - 1,
              k = I >> 1,
              R = u === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
              N = a ? 0 : p - 1,
              q = a ? 1 : -1,
              U = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
            for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (g = isNaN(t) ? 1 : 0, f = I) : (f = Math.floor(Math.log(t) / Math.LN2), t * (x = Math.pow(2, -f)) < 1 && (f--, x *= 2), (t += f + k >= 1 ? R / x : R * Math.pow(2, 1 - k)) * x >= 2 && (f++, x /= 2), f + k >= I ? (g = 0, f = I) : f + k >= 1 ? (g = (t * x - 1) * Math.pow(2, u), f += k) : (g = t * Math.pow(2, k - 1) * Math.pow(2, u), f = 0)); u >= 8; n[i + N] = 255 & g, N += q, g /= 256, u -= 8);
            for (f = f << u | g, S += u; S > 0; n[i + N] = 255 & f, N += q, f /= 256, S -= 8);
            n[i + N - q] |= 128 * U
          }), Np
        }

        function x_() {
          if (y_) return Op;
          y_ = 1, Op = t;
          var n = q0();

          function t(O) {
            this.buf = ArrayBuffer.isView && ArrayBuffer.isView(O) ? O : new Uint8Array(O || 0), this.pos = 0, this.type = 0, this.length = this.buf.length
          }
          t.Varint = 0, t.Fixed64 = 1, t.Bytes = 2, t.Fixed32 = 5;
          var i = 4294967296,
            a = 1 / i,
            u = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");

          function p(O) {
            return O.type === t.Bytes ? O.readVarint() + O.pos : O.pos + 1
          }

          function f(O, Y, ge) {
            return ge ? 4294967296 * Y + (O >>> 0) : 4294967296 * (Y >>> 0) + (O >>> 0)
          }

          function g(O, Y, ge) {
            var Xe = Y <= 16383 ? 1 : Y <= 2097151 ? 2 : Y <= 268435455 ? 3 : Math.floor(Math.log(Y) / (7 * Math.LN2));
            ge.realloc(Xe);
            for (var wt = ge.pos - 1; wt >= O; wt--) ge.buf[wt + Xe] = ge.buf[wt]
          }

          function x(O, Y) {
            for (var ge = 0; ge < O.length; ge++) Y.writeVarint(O[ge])
          }

          function S(O, Y) {
            for (var ge = 0; ge < O.length; ge++) Y.writeSVarint(O[ge])
          }

          function I(O, Y) {
            for (var ge = 0; ge < O.length; ge++) Y.writeFloat(O[ge])
          }

          function k(O, Y) {
            for (var ge = 0; ge < O.length; ge++) Y.writeDouble(O[ge])
          }

          function R(O, Y) {
            for (var ge = 0; ge < O.length; ge++) Y.writeBoolean(O[ge])
          }

          function N(O, Y) {
            for (var ge = 0; ge < O.length; ge++) Y.writeFixed32(O[ge])
          }

          function q(O, Y) {
            for (var ge = 0; ge < O.length; ge++) Y.writeSFixed32(O[ge])
          }

          function U(O, Y) {
            for (var ge = 0; ge < O.length; ge++) Y.writeFixed64(O[ge])
          }

          function J(O, Y) {
            for (var ge = 0; ge < O.length; ge++) Y.writeSFixed64(O[ge])
          }

          function ae(O, Y) {
            return (O[Y] | O[Y + 1] << 8 | O[Y + 2] << 16) + 16777216 * O[Y + 3]
          }

          function ke(O, Y, ge) {
            O[ge] = Y, O[ge + 1] = Y >>> 8, O[ge + 2] = Y >>> 16, O[ge + 3] = Y >>> 24
          }

          function _e(O, Y) {
            return (O[Y] | O[Y + 1] << 8 | O[Y + 2] << 16) + (O[Y + 3] << 24)
          }
          return t.prototype = {
            destroy: function() {
              this.buf = null
            },
            readFields: function(O, Y, ge) {
              for (ge = ge || this.length; this.pos < ge;) {
                var Xe = this.readVarint(),
                  wt = Xe >> 3,
                  it = this.pos;
                this.type = 7 & Xe, O(wt, Y, this), this.pos === it && this.skip(Xe)
              }
              return Y
            },
            readMessage: function(O, Y) {
              return this.readFields(O, Y, this.readVarint() + this.pos)
            },
            readFixed32: function() {
              var O = ae(this.buf, this.pos);
              return this.pos += 4, O
            },
            readSFixed32: function() {
              var O = _e(this.buf, this.pos);
              return this.pos += 4, O
            },
            readFixed64: function() {
              var O = ae(this.buf, this.pos) + ae(this.buf, this.pos + 4) * i;
              return this.pos += 8, O
            },
            readSFixed64: function() {
              var O = ae(this.buf, this.pos) + _e(this.buf, this.pos + 4) * i;
              return this.pos += 8, O
            },
            readFloat: function() {
              var O = n.read(this.buf, this.pos, !0, 23, 4);
              return this.pos += 4, O
            },
            readDouble: function() {
              var O = n.read(this.buf, this.pos, !0, 52, 8);
              return this.pos += 8, O
            },
            readVarint: function(O) {
              var Y, ge, Xe = this.buf;
              return Y = 127 & (ge = Xe[this.pos++]), ge < 128 ? Y : (Y |= (127 & (ge = Xe[this.pos++])) << 7, ge < 128 ? Y : (Y |= (127 & (ge = Xe[this.pos++])) << 14, ge < 128 ? Y : (Y |= (127 & (ge = Xe[this.pos++])) << 21, ge < 128 ? Y : (function(wt, it, ut) {
                var kt, Ct, zt = ut.buf;
                if (kt = (112 & (Ct = zt[ut.pos++])) >> 4, Ct < 128 || (kt |= (127 & (Ct = zt[ut.pos++])) << 3, Ct < 128) || (kt |= (127 & (Ct = zt[ut.pos++])) << 10, Ct < 128) || (kt |= (127 & (Ct = zt[ut.pos++])) << 17, Ct < 128) || (kt |= (127 & (Ct = zt[ut.pos++])) << 24, Ct < 128) || (kt |= (1 & (Ct = zt[ut.pos++])) << 31, Ct < 128)) return f(wt, kt, it);
                throw new Error("Expected varint not more than 10 bytes")
              })(Y |= (15 & (ge = Xe[this.pos])) << 28, O, this))))
            },
            readVarint64: function() {
              return this.readVarint(!0)
            },
            readSVarint: function() {
              var O = this.readVarint();
              return O % 2 == 1 ? (O + 1) / -2 : O / 2
            },
            readBoolean: function() {
              return !!this.readVarint()
            },
            readString: function() {
              var O = this.readVarint() + this.pos,
                Y = this.pos;
              return this.pos = O, O - Y >= 12 && u ? (function(ge, Xe, wt) {
                return u.decode(ge.subarray(Xe, wt))
              })(this.buf, Y, O) : (function(ge, Xe, wt) {
                for (var it = "", ut = Xe; ut < wt;) {
                  var kt, Ct, zt, mt = ge[ut],
                    ir = null,
                    Mr = mt > 239 ? 4 : mt > 223 ? 3 : mt > 191 ? 2 : 1;
                  if (ut + Mr > wt) break;
                  Mr === 1 ? mt < 128 && (ir = mt) : Mr === 2 ? (192 & (kt = ge[ut + 1])) == 128 && (ir = (31 & mt) << 6 | 63 & kt) <= 127 && (ir = null) : Mr === 3 ? (Ct = ge[ut + 2], (192 & (kt = ge[ut + 1])) == 128 && (192 & Ct) == 128 && ((ir = (15 & mt) << 12 | (63 & kt) << 6 | 63 & Ct) <= 2047 || ir >= 55296 && ir <= 57343) && (ir = null)) : Mr === 4 && (Ct = ge[ut + 2], zt = ge[ut + 3], (192 & (kt = ge[ut + 1])) == 128 && (192 & Ct) == 128 && (192 & zt) == 128 && ((ir = (15 & mt) << 18 | (63 & kt) << 12 | (63 & Ct) << 6 | 63 & zt) <= 65535 || ir >= 1114112) && (ir = null)), ir === null ? (ir = 65533, Mr = 1) : ir > 65535 && (ir -= 65536, it += String.fromCharCode(ir >>> 10 & 1023 | 55296), ir = 56320 | 1023 & ir), it += String.fromCharCode(ir), ut += Mr
                }
                return it
              })(this.buf, Y, O)
            },
            readBytes: function() {
              var O = this.readVarint() + this.pos,
                Y = this.buf.subarray(this.pos, O);
              return this.pos = O, Y
            },
            readPackedVarint: function(O, Y) {
              if (this.type !== t.Bytes) return O.push(this.readVarint(Y));
              var ge = p(this);
              for (O = O || []; this.pos < ge;) O.push(this.readVarint(Y));
              return O
            },
            readPackedSVarint: function(O) {
              if (this.type !== t.Bytes) return O.push(this.readSVarint());
              var Y = p(this);
              for (O = O || []; this.pos < Y;) O.push(this.readSVarint());
              return O
            },
            readPackedBoolean: function(O) {
              if (this.type !== t.Bytes) return O.push(this.readBoolean());
              var Y = p(this);
              for (O = O || []; this.pos < Y;) O.push(this.readBoolean());
              return O
            },
            readPackedFloat: function(O) {
              if (this.type !== t.Bytes) return O.push(this.readFloat());
              var Y = p(this);
              for (O = O || []; this.pos < Y;) O.push(this.readFloat());
              return O
            },
            readPackedDouble: function(O) {
              if (this.type !== t.Bytes) return O.push(this.readDouble());
              var Y = p(this);
              for (O = O || []; this.pos < Y;) O.push(this.readDouble());
              return O
            },
            readPackedFixed32: function(O) {
              if (this.type !== t.Bytes) return O.push(this.readFixed32());
              var Y = p(this);
              for (O = O || []; this.pos < Y;) O.push(this.readFixed32());
              return O
            },
            readPackedSFixed32: function(O) {
              if (this.type !== t.Bytes) return O.push(this.readSFixed32());
              var Y = p(this);
              for (O = O || []; this.pos < Y;) O.push(this.readSFixed32());
              return O
            },
            readPackedFixed64: function(O) {
              if (this.type !== t.Bytes) return O.push(this.readFixed64());
              var Y = p(this);
              for (O = O || []; this.pos < Y;) O.push(this.readFixed64());
              return O
            },
            readPackedSFixed64: function(O) {
              if (this.type !== t.Bytes) return O.push(this.readSFixed64());
              var Y = p(this);
              for (O = O || []; this.pos < Y;) O.push(this.readSFixed64());
              return O
            },
            skip: function(O) {
              var Y = 7 & O;
              if (Y === t.Varint)
                for (; this.buf[this.pos++] > 127;);
              else if (Y === t.Bytes) this.pos = this.readVarint() + this.pos;
              else if (Y === t.Fixed32) this.pos += 4;
              else {
                if (Y !== t.Fixed64) throw new Error("Unimplemented type: " + Y);
                this.pos += 8
              }
            },
            writeTag: function(O, Y) {
              this.writeVarint(O << 3 | Y)
            },
            realloc: function(O) {
              for (var Y = this.length || 16; Y < this.pos + O;) Y *= 2;
              if (Y !== this.length) {
                var ge = new Uint8Array(Y);
                ge.set(this.buf), this.buf = ge, this.length = Y
              }
            },
            finish: function() {
              return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length)
            },
            writeFixed32: function(O) {
              this.realloc(4), ke(this.buf, O, this.pos), this.pos += 4
            },
            writeSFixed32: function(O) {
              this.realloc(4), ke(this.buf, O, this.pos), this.pos += 4
            },
            writeFixed64: function(O) {
              this.realloc(8), ke(this.buf, -1 & O, this.pos), ke(this.buf, Math.floor(O * a), this.pos + 4), this.pos += 8
            },
            writeSFixed64: function(O) {
              this.realloc(8), ke(this.buf, -1 & O, this.pos), ke(this.buf, Math.floor(O * a), this.pos + 4), this.pos += 8
            },
            writeVarint: function(O) {
              (O = +O || 0) > 268435455 || O < 0 ? (function(Y, ge) {
                var Xe, wt;
                if (Y >= 0 ? (Xe = Y % 4294967296 | 0, wt = Y / 4294967296 | 0) : (wt = ~(-Y / 4294967296), 4294967295 ^ (Xe = ~(-Y % 4294967296)) ? Xe = Xe + 1 | 0 : (Xe = 0, wt = wt + 1 | 0)), Y >= 18446744073709552e3 || Y < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
                ge.realloc(10), (function(it, ut, kt) {
                  kt.buf[kt.pos++] = 127 & it | 128, it >>>= 7, kt.buf[kt.pos++] = 127 & it | 128, it >>>= 7, kt.buf[kt.pos++] = 127 & it | 128, it >>>= 7, kt.buf[kt.pos++] = 127 & it | 128, kt.buf[kt.pos] = 127 & (it >>>= 7)
                })(Xe, 0, ge), (function(it, ut) {
                  var kt = (7 & it) << 4;
                  ut.buf[ut.pos++] |= kt | ((it >>>= 3) ? 128 : 0), it && (ut.buf[ut.pos++] = 127 & it | ((it >>>= 7) ? 128 : 0), it && (ut.buf[ut.pos++] = 127 & it | ((it >>>= 7) ? 128 : 0), it && (ut.buf[ut.pos++] = 127 & it | ((it >>>= 7) ? 128 : 0), it && (ut.buf[ut.pos++] = 127 & it | ((it >>>= 7) ? 128 : 0), it && (ut.buf[ut.pos++] = 127 & it)))))
                })(wt, ge)
              })(O, this) : (this.realloc(4), this.buf[this.pos++] = 127 & O | (O > 127 ? 128 : 0), O <= 127 || (this.buf[this.pos++] = 127 & (O >>>= 7) | (O > 127 ? 128 : 0), O <= 127 || (this.buf[this.pos++] = 127 & (O >>>= 7) | (O > 127 ? 128 : 0), O <= 127 || (this.buf[this.pos++] = O >>> 7 & 127))))
            },
            writeSVarint: function(O) {
              this.writeVarint(O < 0 ? 2 * -O - 1 : 2 * O)
            },
            writeBoolean: function(O) {
              this.writeVarint(!!O)
            },
            writeString: function(O) {
              O = String(O), this.realloc(4 * O.length), this.pos++;
              var Y = this.pos;
              this.pos = (function(Xe, wt, it) {
                for (var ut, kt, Ct = 0; Ct < wt.length; Ct++) {
                  if ((ut = wt.charCodeAt(Ct)) > 55295 && ut < 57344) {
                    if (!kt) {
                      ut > 56319 || Ct + 1 === wt.length ? (Xe[it++] = 239, Xe[it++] = 191, Xe[it++] = 189) : kt = ut;
                      continue
                    }
                    if (ut < 56320) {
                      Xe[it++] = 239, Xe[it++] = 191, Xe[it++] = 189, kt = ut;
                      continue
                    }
                    ut = kt - 55296 << 10 | ut - 56320 | 65536, kt = null
                  } else kt && (Xe[it++] = 239, Xe[it++] = 191, Xe[it++] = 189, kt = null);
                  ut < 128 ? Xe[it++] = ut : (ut < 2048 ? Xe[it++] = ut >> 6 | 192 : (ut < 65536 ? Xe[it++] = ut >> 12 | 224 : (Xe[it++] = ut >> 18 | 240, Xe[it++] = ut >> 12 & 63 | 128), Xe[it++] = ut >> 6 & 63 | 128), Xe[it++] = 63 & ut | 128)
                }
                return it
              })(this.buf, O, this.pos);
              var ge = this.pos - Y;
              ge >= 128 && g(Y, ge, this), this.pos = Y - 1, this.writeVarint(ge), this.pos += ge
            },
            writeFloat: function(O) {
              this.realloc(4), n.write(this.buf, O, this.pos, !0, 23, 4), this.pos += 4
            },
            writeDouble: function(O) {
              this.realloc(8), n.write(this.buf, O, this.pos, !0, 52, 8), this.pos += 8
            },
            writeBytes: function(O) {
              var Y = O.length;
              this.writeVarint(Y), this.realloc(Y);
              for (var ge = 0; ge < Y; ge++) this.buf[this.pos++] = O[ge]
            },
            writeRawMessage: function(O, Y) {
              this.pos++;
              var ge = this.pos;
              O(Y, this);
              var Xe = this.pos - ge;
              Xe >= 128 && g(ge, Xe, this), this.pos = ge - 1, this.writeVarint(Xe), this.pos += Xe
            },
            writeMessage: function(O, Y, ge) {
              this.writeTag(O, t.Bytes), this.writeRawMessage(Y, ge)
            },
            writePackedVarint: function(O, Y) {
              Y.length && this.writeMessage(O, x, Y)
            },
            writePackedSVarint: function(O, Y) {
              Y.length && this.writeMessage(O, S, Y)
            },
            writePackedBoolean: function(O, Y) {
              Y.length && this.writeMessage(O, R, Y)
            },
            writePackedFloat: function(O, Y) {
              Y.length && this.writeMessage(O, I, Y)
            },
            writePackedDouble: function(O, Y) {
              Y.length && this.writeMessage(O, k, Y)
            },
            writePackedFixed32: function(O, Y) {
              Y.length && this.writeMessage(O, N, Y)
            },
            writePackedSFixed32: function(O, Y) {
              Y.length && this.writeMessage(O, q, Y)
            },
            writePackedFixed64: function(O, Y) {
              Y.length && this.writeMessage(O, U, Y)
            },
            writePackedSFixed64: function(O, Y) {
              Y.length && this.writeMessage(O, J, Y)
            },
            writeBytesField: function(O, Y) {
              this.writeTag(O, t.Bytes), this.writeBytes(Y)
            },
            writeFixed32Field: function(O, Y) {
              this.writeTag(O, t.Fixed32), this.writeFixed32(Y)
            },
            writeSFixed32Field: function(O, Y) {
              this.writeTag(O, t.Fixed32), this.writeSFixed32(Y)
            },
            writeFixed64Field: function(O, Y) {
              this.writeTag(O, t.Fixed64), this.writeFixed64(Y)
            },
            writeSFixed64Field: function(O, Y) {
              this.writeTag(O, t.Fixed64), this.writeSFixed64(Y)
            },
            writeVarintField: function(O, Y) {
              this.writeTag(O, t.Varint), this.writeVarint(Y)
            },
            writeSVarintField: function(O, Y) {
              this.writeTag(O, t.Varint), this.writeSVarint(Y)
            },
            writeStringField: function(O, Y) {
              this.writeTag(O, t.Bytes), this.writeString(Y)
            },
            writeFloatField: function(O, Y) {
              this.writeTag(O, t.Fixed32), this.writeFloat(Y)
            },
            writeDoubleField: function(O, Y) {
              this.writeTag(O, t.Fixed64), this.writeDouble(Y)
            },
            writeBooleanField: function(O, Y) {
              this.writeVarintField(O, !!Y)
            }
          }, Op
        }
        var Qs, jp = K(x_());

        function V0(n, t, i) {
          n === 1 && i.readMessage(Z0, t)
        }

        function Z0(n, t, i) {
          if (n === 3) {
            const {
              id: a,
              bitmap: u,
              width: p,
              height: f,
              left: g,
              top: x,
              advance: S
            } = i.readMessage($0, {});
            t.push({
              id: a,
              bitmap: new au({
                width: p + 6,
                height: f + 6
              }, u),
              metrics: {
                width: p,
                height: f,
                left: g,
                top: x,
                advance: S
              }
            })
          }
        }

        function $0(n, t, i) {
          n === 1 ? t.id = i.readVarint() : n === 2 ? t.bitmap = i.readBytes() : n === 3 ? t.width = i.readVarint() : n === 4 ? t.height = i.readVarint() : n === 5 ? t.left = i.readSVarint() : n === 6 ? t.top = i.readSVarint() : n === 7 && (t.advance = i.readVarint())
        }

        function b_(n) {
          let t = 0,
            i = 0;
          for (const f of n) t += f.w * f.h, i = Math.max(i, f.w);
          n.sort(((f, g) => g.h - f.h));
          const a = [{
            x: 0,
            y: 0,
            w: Math.max(Math.ceil(Math.sqrt(t / .95)), i),
            h: 1 / 0
          }];
          let u = 0,
            p = 0;
          for (const f of n)
            for (let g = a.length - 1; g >= 0; g--) {
              const x = a[g];
              if (!(f.w > x.w || f.h > x.h)) {
                if (f.x = x.x, f.y = x.y, p = Math.max(p, f.y + f.h), u = Math.max(u, f.x + f.w), f.w === x.w && f.h === x.h) {
                  const S = a.pop();
                  g < a.length && (a[g] = S)
                } else f.h === x.h ? (x.x += f.w, x.w -= f.w) : f.w === x.w ? (x.y += f.h, x.h -= f.h) : (a.push({
                  x: x.x + f.w,
                  y: x.y,
                  w: x.w - f.w,
                  h: f.h
                }), x.y += f.h, x.h -= f.h);
                break
              }
            }
          return {
            w: u,
            h: p,
            fill: t / (u * p) || 0
          }
        }
        class qp {
          constructor(t, {
            pixelRatio: i,
            version: a,
            stretchX: u,
            stretchY: p,
            content: f,
            textFitWidth: g,
            textFitHeight: x
          }) {
            this.paddedRect = t, this.pixelRatio = i, this.stretchX = u, this.stretchY = p, this.content = f, this.version = a, this.textFitWidth = g, this.textFitHeight = x
          }
          get tl() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1]
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1]
          }
          get tlbr() {
            return this.tl.concat(this.br)
          }
          get displaySize() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio]
          }
        }
        class w_ {
          constructor(t, i) {
            const a = {},
              u = {};
            this.haveRenderCallbacks = [];
            const p = [];
            this.addImages(t, a, p), this.addImages(i, u, p);
            const {
              w: f,
              h: g
            } = b_(p), x = new ra({
              width: f || 1,
              height: g || 1
            });
            for (const S in t) {
              const I = t[S],
                k = a[S].paddedRect;
              ra.copy(I.data, x, {
                x: 0,
                y: 0
              }, {
                x: k.x + 1,
                y: k.y + 1
              }, I.data)
            }
            for (const S in i) {
              const I = i[S],
                k = u[S].paddedRect,
                R = k.x + 1,
                N = k.y + 1,
                q = I.data.width,
                U = I.data.height;
              ra.copy(I.data, x, {
                x: 0,
                y: 0
              }, {
                x: R,
                y: N
              }, I.data), ra.copy(I.data, x, {
                x: 0,
                y: U - 1
              }, {
                x: R,
                y: N - 1
              }, {
                width: q,
                height: 1
              }), ra.copy(I.data, x, {
                x: 0,
                y: 0
              }, {
                x: R,
                y: N + U
              }, {
                width: q,
                height: 1
              }), ra.copy(I.data, x, {
                x: q - 1,
                y: 0
              }, {
                x: R - 1,
                y: N
              }, {
                width: 1,
                height: U
              }), ra.copy(I.data, x, {
                x: 0,
                y: 0
              }, {
                x: R + q,
                y: N
              }, {
                width: 1,
                height: U
              })
            }
            this.image = x, this.iconPositions = a, this.patternPositions = u
          }
          addImages(t, i, a) {
            for (const u in t) {
              const p = t[u],
                f = {
                  x: 0,
                  y: 0,
                  w: p.data.width + 2,
                  h: p.data.height + 2
                };
              a.push(f), i[u] = new qp(f, p), p.hasRenderCallback && this.haveRenderCallbacks.push(u)
            }
          }
          patchUpdatedImages(t, i) {
            t.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const a in t.updatedImages) this.patchUpdatedImage(this.iconPositions[a], t.getImage(a), i), this.patchUpdatedImage(this.patternPositions[a], t.getImage(a), i)
          }
          patchUpdatedImage(t, i, a) {
            if (!t || !i || t.version === i.version) return;
            t.version = i.version;
            const [u, p] = t.tl;
            a.update(i.data, void 0, {
              x: u,
              y: p
            })
          }
        }
        Wt("ImagePosition", qp), Wt("ImageAtlas", w_), C.an = void 0, (Qs = C.an || (C.an = {}))[Qs.none = 0] = "none", Qs[Qs.horizontal = 1] = "horizontal", Qs[Qs.vertical = 2] = "vertical", Qs[Qs.horizontalOnly = 3] = "horizontalOnly";
        class _u {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom"
          }
          static forText(t, i, a) {
            const u = new _u;
            return u.scale = t || 1, u.fontStack = i, u.verticalAlign = a || "bottom", u
          }
          static forImage(t, i) {
            const a = new _u;
            return a.imageName = t, a.verticalAlign = i || "bottom", a
          }
        }
        class Ol {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null
          }
          static fromFeature(t, i) {
            const a = new Ol;
            for (let u = 0; u < t.sections.length; u++) {
              const p = t.sections[u];
              p.image ? a.addImageSection(p) : a.addTextSection(p, i)
            }
            return a
          }
          length() {
            return this.text.length
          }
          getSection(t) {
            return this.sections[this.sectionIndex[t]]
          }
          getSectionIndex(t) {
            return this.sectionIndex[t]
          }
          getCharCode(t) {
            return this.text.charCodeAt(t)
          }
          verticalizePunctuation() {
            this.text = (function(t) {
              let i = "";
              for (let a = 0; a < t.length; a++) {
                const u = t.charCodeAt(a + 1) || null,
                  p = t.charCodeAt(a - 1) || null;
                i += u && Hc(u) && !mu[t[a + 1]] || p && Hc(p) && !mu[t[a - 1]] || !mu[t[a]] ? t[a] : mu[t[a]]
              }
              return i
            })(this.text)
          }
          trim() {
            let t = 0;
            for (let a = 0; a < this.text.length && hd[this.text.charCodeAt(a)]; a++) t++;
            let i = this.text.length;
            for (let a = this.text.length - 1; a >= 0 && a >= t && hd[this.text.charCodeAt(a)]; a--) i--;
            this.text = this.text.substring(t, i), this.sectionIndex = this.sectionIndex.slice(t, i)
          }
          substring(t, i) {
            const a = new Ol;
            return a.text = this.text.substring(t, i), a.sectionIndex = this.sectionIndex.slice(t, i), a.sections = this.sections, a
          }
          toString() {
            return this.text
          }
          getMaxScale() {
            return this.sectionIndex.reduce(((t, i) => Math.max(t, this.sections[i].scale)), 0)
          }
          getMaxImageSize(t) {
            let i = 0,
              a = 0;
            for (let u = 0; u < this.length(); u++) {
              const p = this.getSection(u);
              if (p.imageName) {
                const f = t[p.imageName];
                if (!f) continue;
                const g = f.displaySize;
                i = Math.max(i, g[0]), a = Math.max(a, g[1])
              }
            }
            return {
              maxImageWidth: i,
              maxImageHeight: a
            }
          }
          addTextSection(t, i) {
            this.text += t.text, this.sections.push(_u.forText(t.scale, t.fontStack || i, t.verticalAlign));
            const a = this.sections.length - 1;
            for (let u = 0; u < t.text.length; ++u) this.sectionIndex.push(a)
          }
          addImageSection(t) {
            const i = t.image ? t.image.name : "";
            if (i.length === 0) return void Qt("Can't add FormattedSection with an empty image.");
            const a = this.getNextImageSectionCharCode();
            a ? (this.text += String.fromCharCode(a), this.sections.push(_u.forImage(i, t.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : Qt("Reached maximum number of images 6401")
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID)
          }
        }

        function ud(n, t, i, a, u, p, f, g, x, S, I, k, R, N, q) {
          const U = Ol.fromFeature(n, u);
          let J;
          k === C.an.vertical && U.verticalizePunctuation();
          const {
            processBidirectionalText: ae,
            processStyledBidirectionalText: ke
          } = Xa;
          if (ae && U.sections.length === 1) {
            J = [];
            const Y = ae(U.toString(), Vp(U, S, p, t, a, N));
            for (const ge of Y) {
              const Xe = new Ol;
              Xe.text = ge, Xe.sections = U.sections;
              for (let wt = 0; wt < ge.length; wt++) Xe.sectionIndex.push(0);
              J.push(Xe)
            }
          } else if (ke) {
            J = [];
            const Y = ke(U.text, U.sectionIndex, Vp(U, S, p, t, a, N));
            for (const ge of Y) {
              const Xe = new Ol;
              Xe.text = ge[0], Xe.sectionIndex = ge[1], Xe.sections = U.sections, J.push(Xe)
            }
          } else J = (function(Y, ge) {
            const Xe = [],
              wt = Y.text;
            let it = 0;
            for (const ut of ge) Xe.push(Y.substring(it, ut)), it = ut;
            return it < wt.length && Xe.push(Y.substring(it, wt.length)), Xe
          })(U, Vp(U, S, p, t, a, N));
          const _e = [],
            O = {
              positionedLines: _e,
              text: U.toString(),
              top: I[1],
              bottom: I[1],
              left: I[0],
              right: I[0],
              writingMode: k,
              iconsInText: !1,
              verticalizable: !1
            };
          return (function(Y, ge, Xe, wt, it, ut, kt, Ct, zt, mt, ir, Mr) {
            let Sr = 0,
              pr = 0,
              ui = 0,
              Gi = 0;
            const on = Ct === "right" ? 1 : Ct === "left" ? 0 : .5,
              Ln = mn / Mr;
            let ya = 0;
            for (const Zi of it) {
              Zi.trim();
              const _n = Zi.getMaxScale(),
                In = {
                  positionedGlyphs: [],
                  lineOffset: 0
                };
              Y.positionedLines[ya] = In;
              const Mn = In.positionedGlyphs;
              let Wn = 0;
              if (!Zi.length()) {
                pr += ut, ++ya;
                continue
              }
              const xa = W0(wt, Zi, Ln);
              for (let na = 0; na < Zi.length(); na++) {
                const ln = Zi.getSection(na),
                  vn = Zi.getSectionIndex(na),
                  yn = Zi.getCharCode(na),
                  rn = X0(zt, ir, yn);
                let Ri;
                if (ln.imageName) {
                  if (Y.iconsInText = !0, ln.scale = ln.scale * Ln, Ri = Y0(ln, rn, _n, xa, wt), !Ri) continue;
                  Wn = Math.max(Wn, Ri.imageOffset)
                } else if (Ri = K0(ln, yn, rn, xa, ge, Xe), !Ri) continue;
                const {
                  rect: Fa,
                  metrics: Vl,
                  baselineOffset: Oa
                } = Ri;
                Mn.push({
                  glyph: yn,
                  imageName: ln.imageName,
                  x: Sr,
                  y: pr + Oa + -17,
                  vertical: rn,
                  scale: ln.scale,
                  fontStack: ln.fontStack,
                  sectionIndex: vn,
                  metrics: Vl,
                  rect: Fa
                }), rn ? (Y.verticalizable = !0, Sr += (ln.imageName ? Vl.advance : mn) * ln.scale + mt) : Sr += Vl.advance * ln.scale + mt
              }
              Mn.length !== 0 && (ui = Math.max(Sr - mt, ui), J0(Mn, 0, Mn.length - 1, on)), Sr = 0, In.lineOffset = Math.max(Wn, (_n - 1) * mn);
              const gn = ut * _n + Wn;
              pr += gn, Gi = Math.max(gn, Gi), ++ya
            }
            const {
              horizontalAlign: ia,
              verticalAlign: Pn
            } = Zp(kt);
            (function(Zi, _n, In, Mn, Wn, xa, gn, na, ln) {
              const vn = (_n - In) * Wn;
              let yn = 0;
              yn = xa !== gn ? -na * Mn - -17 : -Mn * ln * gn + .5 * gn;
              for (const rn of Zi)
                for (const Ri of rn.positionedGlyphs) Ri.x += vn, Ri.y += yn
            })(Y.positionedLines, on, ia, Pn, ui, Gi, ut, pr, it.length), Y.top += -Pn * pr, Y.bottom = Y.top + pr, Y.left += -ia * ui, Y.right = Y.left + ui
          })(O, t, i, a, J, f, g, x, k, S, R, q), !(function(Y) {
            for (const ge of Y)
              if (ge.positionedGlyphs.length !== 0) return !1;
            return !0
          })(_e) && O
        }
        const hd = {
            9: !0,
            10: !0,
            11: !0,
            12: !0,
            13: !0,
            32: !0
          },
          U0 = {
            10: !0,
            32: !0,
            38: !0,
            41: !0,
            43: !0,
            45: !0,
            47: !0,
            173: !0,
            183: !0,
            8203: !0,
            8208: !0,
            8211: !0,
            8231: !0
          },
          G0 = {
            40: !0
          };

        function T_(n, t, i, a, u, p) {
          if (t.imageName) {
            const f = a[t.imageName];
            return f ? f.displaySize[0] * t.scale * mn / p + u : 0
          } {
            const f = i[t.fontStack],
              g = f && f[n];
            return g ? g.metrics.advance * t.scale + u : 0
          }
        }

        function C_(n, t, i, a) {
          const u = Math.pow(n - t, 2);
          return a ? n < t ? u / 2 : 2 * u : u + Math.abs(i) * i
        }

        function H0(n, t, i) {
          let a = 0;
          return n === 10 && (a -= 1e4), i && (a += 150), n !== 40 && n !== 65288 || (a += 50), t !== 41 && t !== 65289 || (a += 50), a
        }

        function S_(n, t, i, a, u, p) {
          let f = null,
            g = C_(t, i, u, p);
          for (const x of a) {
            const S = C_(t - x.x, i, u, p) + x.badness;
            S <= g && (f = x, g = S)
          }
          return {
            index: n,
            x: t,
            priorBreak: f,
            badness: g
          }
        }

        function P_(n) {
          return n ? P_(n.priorBreak).concat(n.index) : []
        }

        function Vp(n, t, i, a, u, p) {
          if (!n) return [];
          const f = [],
            g = (function(k, R, N, q, U, J) {
              let ae = 0;
              for (let ke = 0; ke < k.length(); ke++) {
                const _e = k.getSection(ke);
                ae += T_(k.getCharCode(ke), _e, q, U, R, J)
              }
              return ae / Math.max(1, Math.ceil(ae / N))
            })(n, t, i, a, u, p),
            x = n.text.indexOf("​") >= 0;
          let S = 0;
          for (let k = 0; k < n.length(); k++) {
            const R = n.getSection(k),
              N = n.getCharCode(k);
            if (hd[N] || (S += T_(N, R, a, u, t, p)), k < n.length() - 1) {
              const q = !((I = N) < 11904) && (!!li["CJK Compatibility Forms"](I) || !!li["CJK Compatibility"](I) || !!li["CJK Strokes"](I) || !!li["CJK Symbols and Punctuation"](I) || !!li["Enclosed CJK Letters and Months"](I) || !!li["Halfwidth and Fullwidth Forms"](I) || !!li["Ideographic Description Characters"](I) || !!li["Vertical Forms"](I) || Gc.test(String.fromCodePoint(I)));
              (U0[N] || q || R.imageName || k !== n.length() - 2 && G0[n.getCharCode(k + 1)]) && f.push(S_(k + 1, S, g, f, H0(N, n.getCharCode(k + 1), q && x), !1))
            }
          }
          var I;
          return P_(S_(n.length(), S, g, f, 0, !0))
        }

        function Zp(n) {
          let t = .5,
            i = .5;
          switch (n) {
            case "right":
            case "top-right":
            case "bottom-right":
              t = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              t = 0
          }
          switch (n) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              i = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              i = 0
          }
          return {
            horizontalAlign: t,
            verticalAlign: i
          }
        }

        function W0(n, t, i) {
          const a = t.getMaxScale() * mn,
            {
              maxImageWidth: u,
              maxImageHeight: p
            } = t.getMaxImageSize(n),
            f = Math.max(a, p * i);
          return {
            verticalLineContentWidth: Math.max(a, u * i),
            horizontalLineContentHeight: f
          }
        }

        function I_(n) {
          switch (n) {
            case "top":
              return 0;
            case "center":
              return .5;
            default:
              return 1
          }
        }

        function X0(n, t, i) {
          return !(n === C.an.horizontal || !t && !Ml(i) || t && (hd[i] || (a = i, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(a)))));
          var a
        }

        function K0(n, t, i, a, u, p) {
          const f = p[n.fontStack],
            g = (function(S, I, k, R) {
              if (S && S.rect) return S;
              const N = I[k.fontStack],
                q = N && N[R];
              return q ? {
                rect: null,
                metrics: q.metrics
              } : null
            })(f && f[t], u, n, t);
          if (g === null) return null;
          let x;
          if (i) x = a.verticalLineContentWidth - n.scale * mn;
          else {
            const S = I_(n.verticalAlign);
            x = (a.horizontalLineContentHeight - n.scale * mn) * S
          }
          return {
            rect: g.rect,
            metrics: g.metrics,
            baselineOffset: x
          }
        }

        function Y0(n, t, i, a, u) {
          const p = u[n.imageName];
          if (!p) return null;
          const f = p.paddedRect,
            g = p.displaySize,
            x = {
              width: g[0],
              height: g[1],
              left: 1,
              top: -3,
              advance: t ? g[1] : g[0]
            };
          let S;
          if (t) S = a.verticalLineContentWidth - g[1] * n.scale;
          else {
            const I = I_(n.verticalAlign);
            S = (a.horizontalLineContentHeight - g[1] * n.scale) * I
          }
          return {
            rect: f,
            metrics: x,
            baselineOffset: S,
            imageOffset: (t ? g[0] : g[1]) * n.scale - mn * i
          }
        }

        function J0(n, t, i, a) {
          if (a === 0) return;
          const u = n[i],
            p = (n[i].x + u.metrics.advance * u.scale) * a;
          for (let f = t; f <= i; f++) n[f].x -= p
        }

        function Q0(n, t, i) {
          const {
            horizontalAlign: a,
            verticalAlign: u
          } = Zp(i), p = t[0] - n.displaySize[0] * a, f = t[1] - n.displaySize[1] * u;
          return {
            image: n,
            top: f,
            bottom: f + n.displaySize[1],
            left: p,
            right: p + n.displaySize[0]
          }
        }

        function M_(n) {
          var t, i;
          let a = n.left,
            u = n.top,
            p = n.right - a,
            f = n.bottom - u;
          const g = (t = n.image.textFitWidth) !== null && t !== void 0 ? t : "stretchOrShrink",
            x = (i = n.image.textFitHeight) !== null && i !== void 0 ? i : "stretchOrShrink",
            S = (n.image.content[2] - n.image.content[0]) / (n.image.content[3] - n.image.content[1]);
          if (x === "proportional") {
            if (g === "stretchOnly" && p / f < S || g === "proportional") {
              const I = Math.ceil(f * S);
              a *= I / p, p = I
            }
          } else if (g === "proportional" && x === "stretchOnly" && S !== 0 && p / f > S) {
            const I = Math.ceil(p / S);
            u *= I / f, f = I
          }
          return {
            x1: a,
            y1: u,
            x2: a + p,
            y2: u + f
          }
        }

        function A_(n, t, i, a, u, p) {
          const f = n.image;
          let g;
          if (f.content) {
            const J = f.content,
              ae = f.pixelRatio || 1;
            g = [J[0] / ae, J[1] / ae, f.displaySize[0] - J[2] / ae, f.displaySize[1] - J[3] / ae]
          }
          const x = t.left * p,
            S = t.right * p;
          let I, k, R, N;
          i === "width" || i === "both" ? (N = u[0] + x - a[3], k = u[0] + S + a[1]) : (N = u[0] + (x + S - f.displaySize[0]) / 2, k = N + f.displaySize[0]);
          const q = t.top * p,
            U = t.bottom * p;
          return i === "height" || i === "both" ? (I = u[1] + q - a[0], R = u[1] + U + a[2]) : (I = u[1] + (q + U - f.displaySize[1]) / 2, R = I + f.displaySize[1]), {
            image: f,
            top: I,
            right: k,
            bottom: R,
            left: N,
            collisionPadding: g
          }
        }
        const vs = 128,
          eo = 32640;

        function k_(n, t) {
          const {
            expression: i
          } = t;
          if (i.kind === "constant") return {
            kind: "constant",
            layoutSize: i.evaluate(new Bi(n + 1))
          };
          if (i.kind === "source") return {
            kind: "source"
          };
          {
            const {
              zoomStops: a,
              interpolationType: u
            } = i;
            let p = 0;
            for (; p < a.length && a[p] <= n;) p++;
            p = Math.max(0, p - 1);
            let f = p;
            for (; f < a.length && a[f] < n + 1;) f++;
            f = Math.min(a.length - 1, f);
            const g = a[p],
              x = a[f];
            return i.kind === "composite" ? {
              kind: "composite",
              minZoom: g,
              maxZoom: x,
              interpolationType: u
            } : {
              kind: "camera",
              minZoom: g,
              maxZoom: x,
              minSize: i.evaluate(new Bi(g)),
              maxSize: i.evaluate(new Bi(x)),
              interpolationType: u
            }
          }
        }

        function $p(n, t, i) {
          let a = "never";
          const u = n.get(t);
          return u ? a = u : n.get(i) && (a = "always"), a
        }
        const ey = du.VectorTileFeature.types,
          ty = [{
            name: "a_fade_opacity",
            components: 1,
            type: "Uint8",
            offset: 0
          }];

        function dd(n, t, i, a, u, p, f, g, x, S, I, k, R) {
          const N = g ? Math.min(eo, Math.round(g[0])) : 0,
            q = g ? Math.min(eo, Math.round(g[1])) : 0;
          n.emplaceBack(t, i, Math.round(32 * a), Math.round(32 * u), p, f, (N << 1) + (x ? 1 : 0), q, 16 * S, 16 * I, 256 * k, 256 * R)
        }

        function Up(n, t, i) {
          n.emplaceBack(t.x, t.y, i), n.emplaceBack(t.x, t.y, i), n.emplaceBack(t.x, t.y, i), n.emplaceBack(t.x, t.y, i)
        }

        function ry(n) {
          for (const t of n.sections)
            if (Wc(t.text)) return !0;
          return !1
        }
        class Gp {
          constructor(t) {
            this.layoutVertexArray = new ei, this.indexArray = new Mi, this.programConfigurations = t, this.segments = new pi, this.dynamicLayoutVertexArray = new xi, this.opacityVertexArray = new qi, this.hasVisibleVertices = !1, this.placedSymbolArray = new ne
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0
          }
          upload(t, i, a, u) {
            this.isEmpty() || (a && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, B0.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, i), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, F0.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, ty, !0), this.opacityVertexBuffer.itemSize = 1), (a || u) && this.programConfigurations.upload(t))
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy())
          }
        }
        Wt("SymbolBuffers", Gp);
        class Hp {
          constructor(t, i, a) {
            this.layoutVertexArray = new t, this.layoutAttributes = i, this.indexArray = new a, this.segments = new pi, this.collisionVertexArray = new Vi
          }
          upload(t) {
            this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, O0.members, !0)
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy())
          }
        }
        Wt("CollisionBuffers", Hp);
        class Nl {
          constructor(t) {
            this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.globalState = t.globalState, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((f => f.id)), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [];
            const i = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = k_(this.zoom, i["text-size"]), this.iconSizeData = k_(this.zoom, i["icon-size"]);
            const a = this.layers[0].layout,
              u = a.get("symbol-sort-key"),
              p = a.get("symbol-z-order");
            this.canOverlap = $p(a, "text-overlap", "text-allow-overlap") !== "never" || $p(a, "icon-overlap", "icon-allow-overlap") !== "never" || a.get("text-ignore-placement") || a.get("icon-ignore-placement"), this.sortFeaturesByKey = p !== "viewport-y" && !u.isConstant(), this.sortFeaturesByY = (p === "viewport-y" || p === "auto" && !this.sortFeaturesByKey) && this.canOverlap, a.get("symbol-placement") === "point" && (this.writingModes = a.get("text-writing-mode").map((f => C.an[f]))), this.stateDependentLayerIds = this.layers.filter((f => f.isStateDependent())).map((f => f.id)), this.sourceID = t.sourceID
          }
          createArrays() {
            this.text = new Gp(new rs(this.layers, this.zoom, (t => /^text/.test(t)))), this.icon = new Gp(new rs(this.layers, this.zoom, (t => /^icon/.test(t)))), this.glyphOffsetArray = new ue, this.lineVertexArray = new be, this.symbolInstances = new me, this.textAnchorOffsets = new pe
          }
          calculateGlyphDependencies(t, i, a, u, p) {
            for (let f = 0; f < t.length; f++)
              if (i[t.charCodeAt(f)] = !0, (a || u) && p) {
                const g = mu[t.charAt(f)];
                g && (i[g.charCodeAt(0)] = !0)
              }
          }
          populate(t, i, a) {
            const u = this.layers[0],
              p = u.layout,
              f = p.get("text-font"),
              g = p.get("text-field"),
              x = p.get("icon-image"),
              S = (g.value.kind !== "constant" || g.value.value instanceof Yi && !g.value.value.isEmpty() || g.value.value.toString().length > 0) && (f.value.kind !== "constant" || f.value.value.length > 0),
              I = x.value.kind !== "constant" || !!x.value.value || Object.keys(x.parameters).length > 0,
              k = p.get("symbol-sort-key");
            if (this.features = [], !S && !I) return;
            const R = i.iconDependencies,
              N = i.glyphDependencies,
              q = i.availableImages,
              U = new Bi(this.zoom, {
                globalState: this.globalState
              });
            for (const {
                feature: J,
                id: ae,
                index: ke,
                sourceLayerIndex: _e
              }
              of t) {
              const O = u._featureFilter.needGeometry,
                Y = Vo(J, O);
              if (!u._featureFilter.filter(U, Y, a)) continue;
              let ge, Xe;
              if (O || (Y.geometry = qo(J)), S) {
                const it = u.getValueAndResolveTokens("text-field", Y, a, q),
                  ut = Yi.factory(it),
                  kt = this.hasRTLText = this.hasRTLText || ry(ut);
                (!kt || Xa.getRTLTextPluginStatus() === "unavailable" || kt && Xa.isParsed()) && (ge = j0(ut, u, Y))
              }
              if (I) {
                const it = u.getValueAndResolveTokens("icon-image", Y, a, q);
                Xe = it instanceof Zn ? it : Zn.fromString(it)
              }
              if (!ge && !Xe) continue;
              const wt = this.sortFeaturesByKey ? k.evaluate(Y, {}, a) : void 0;
              if (this.features.push({
                  id: ae,
                  text: ge,
                  icon: Xe,
                  index: ke,
                  sourceLayerIndex: _e,
                  geometry: Y.geometry,
                  properties: J.properties,
                  type: ey[J.type],
                  sortKey: wt
                }), Xe && (R[Xe.name] = !0), ge) {
                const it = f.evaluate(Y, {}, a).join(","),
                  ut = p.get("text-rotation-alignment") !== "viewport" && p.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(C.an.vertical) >= 0;
                for (const kt of ge.sections)
                  if (kt.image) R[kt.image.name] = !0;
                  else {
                    const Ct = Uc(ge.toString()),
                      zt = kt.fontStack || it,
                      mt = N[zt] = N[zt] || {};
                    this.calculateGlyphDependencies(kt.text, mt, ut, this.allowVerticalPlacement, Ct)
                  }
              }
            }
            p.get("symbol-placement") === "line" && (this.features = (function(J) {
              const ae = {},
                ke = {},
                _e = [];
              let O = 0;

              function Y(it) {
                _e.push(J[it]), O++
              }

              function ge(it, ut, kt) {
                const Ct = ke[it];
                return delete ke[it], ke[ut] = Ct, _e[Ct].geometry[0].pop(), _e[Ct].geometry[0] = _e[Ct].geometry[0].concat(kt[0]), Ct
              }

              function Xe(it, ut, kt) {
                const Ct = ae[ut];
                return delete ae[ut], ae[it] = Ct, _e[Ct].geometry[0].shift(), _e[Ct].geometry[0] = kt[0].concat(_e[Ct].geometry[0]), Ct
              }

              function wt(it, ut, kt) {
                const Ct = kt ? ut[0][ut[0].length - 1] : ut[0][0];
                return `${it}:${Ct.x}:${Ct.y}`
              }
              for (let it = 0; it < J.length; it++) {
                const ut = J[it],
                  kt = ut.geometry,
                  Ct = ut.text ? ut.text.toString() : null;
                if (!Ct) {
                  Y(it);
                  continue
                }
                const zt = wt(Ct, kt),
                  mt = wt(Ct, kt, !0);
                if (zt in ke && mt in ae && ke[zt] !== ae[mt]) {
                  const ir = Xe(zt, mt, kt),
                    Mr = ge(zt, mt, _e[ir].geometry);
                  delete ae[zt], delete ke[mt], ke[wt(Ct, _e[Mr].geometry, !0)] = Mr, _e[ir].geometry = null
                } else zt in ke ? ge(zt, mt, kt) : mt in ae ? Xe(zt, mt, kt) : (Y(it), ae[zt] = O - 1, ke[mt] = O - 1)
              }
              return _e.filter((it => it.geometry))
            })(this.features)), this.sortFeaturesByKey && this.features.sort(((J, ae) => J.sortKey - ae.sortKey))
          }
          update(t, i, a) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, i, this.layers, a), this.icon.programConfigurations.updatePaintArrays(t, i, this.layers, a))
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload
          }
          upload(t) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy()
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData()
          }
          addToLineVertexArray(t, i) {
            const a = this.lineVertexArray.length;
            if (t.segment !== void 0) {
              let u = t.dist(i[t.segment + 1]),
                p = t.dist(i[t.segment]);
              const f = {};
              for (let g = t.segment + 1; g < i.length; g++) f[g] = {
                x: i[g].x,
                y: i[g].y,
                tileUnitDistanceFromAnchor: u
              }, g < i.length - 1 && (u += i[g + 1].dist(i[g]));
              for (let g = t.segment || 0; g >= 0; g--) f[g] = {
                x: i[g].x,
                y: i[g].y,
                tileUnitDistanceFromAnchor: p
              }, g > 0 && (p += i[g - 1].dist(i[g]));
              for (let g = 0; g < i.length; g++) {
                const x = f[g];
                this.lineVertexArray.emplaceBack(x.x, x.y, x.tileUnitDistanceFromAnchor)
              }
            }
            return {
              lineStartIndex: a,
              lineLength: this.lineVertexArray.length - a
            }
          }
          addSymbols(t, i, a, u, p, f, g, x, S, I, k, R) {
            const N = t.indexArray,
              q = t.layoutVertexArray,
              U = t.segments.prepareSegment(4 * i.length, q, N, this.canOverlap ? f.sortKey : void 0),
              J = this.glyphOffsetArray.length,
              ae = U.vertexLength,
              ke = this.allowVerticalPlacement && g === C.an.vertical ? Math.PI / 2 : 0,
              _e = f.text && f.text.sections;
            for (let O = 0; O < i.length; O++) {
              const {
                tl: Y,
                tr: ge,
                bl: Xe,
                br: wt,
                tex: it,
                pixelOffsetTL: ut,
                pixelOffsetBR: kt,
                minFontScaleX: Ct,
                minFontScaleY: zt,
                glyphOffset: mt,
                isSDF: ir,
                sectionIndex: Mr
              } = i[O], Sr = U.vertexLength, pr = mt[1];
              dd(q, x.x, x.y, Y.x, pr + Y.y, it.x, it.y, a, ir, ut.x, ut.y, Ct, zt), dd(q, x.x, x.y, ge.x, pr + ge.y, it.x + it.w, it.y, a, ir, kt.x, ut.y, Ct, zt), dd(q, x.x, x.y, Xe.x, pr + Xe.y, it.x, it.y + it.h, a, ir, ut.x, kt.y, Ct, zt), dd(q, x.x, x.y, wt.x, pr + wt.y, it.x + it.w, it.y + it.h, a, ir, kt.x, kt.y, Ct, zt), Up(t.dynamicLayoutVertexArray, x, ke), N.emplaceBack(Sr, Sr + 2, Sr + 1), N.emplaceBack(Sr + 1, Sr + 2, Sr + 3), U.vertexLength += 4, U.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(mt[0]), O !== i.length - 1 && Mr === i[O + 1].sectionIndex || t.programConfigurations.populatePaintArrays(q.length, f, f.index, {}, R, _e && _e[Mr])
            }
            t.placedSymbolArray.emplaceBack(x.x, x.y, J, this.glyphOffsetArray.length - J, ae, S, I, x.segment, a ? a[0] : 0, a ? a[1] : 0, u[0], u[1], g, 0, !1, 0, k)
          }
          _addCollisionDebugVertex(t, i, a, u, p, f) {
            return i.emplaceBack(0, 0), t.emplaceBack(a.x, a.y, u, p, Math.round(f.x), Math.round(f.y))
          }
          addCollisionDebugVertices(t, i, a, u, p, f, g) {
            const x = p.segments.prepareSegment(4, p.layoutVertexArray, p.indexArray),
              S = x.vertexLength,
              I = p.layoutVertexArray,
              k = p.collisionVertexArray,
              R = g.anchorX,
              N = g.anchorY;
            this._addCollisionDebugVertex(I, k, f, R, N, new le(t, i)), this._addCollisionDebugVertex(I, k, f, R, N, new le(a, i)), this._addCollisionDebugVertex(I, k, f, R, N, new le(a, u)), this._addCollisionDebugVertex(I, k, f, R, N, new le(t, u)), x.vertexLength += 4;
            const q = p.indexArray;
            q.emplaceBack(S, S + 1), q.emplaceBack(S + 1, S + 2), q.emplaceBack(S + 2, S + 3), q.emplaceBack(S + 3, S), x.primitiveLength += 4
          }
          addDebugCollisionBoxes(t, i, a, u) {
            for (let p = t; p < i; p++) {
              const f = this.collisionBoxArray.get(p);
              this.addCollisionDebugVertices(f.x1, f.y1, f.x2, f.y2, u ? this.textCollisionBox : this.iconCollisionBox, f.anchorPoint, a)
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Hp(Si, g_.members, Pi), this.iconCollisionBox = new Hp(Si, g_.members, Pi);
            for (let t = 0; t < this.symbolInstances.length; t++) {
              const i = this.symbolInstances.get(t);
              this.addDebugCollisionBoxes(i.textBoxStartIndex, i.textBoxEndIndex, i, !0), this.addDebugCollisionBoxes(i.verticalTextBoxStartIndex, i.verticalTextBoxEndIndex, i, !0), this.addDebugCollisionBoxes(i.iconBoxStartIndex, i.iconBoxEndIndex, i, !1), this.addDebugCollisionBoxes(i.verticalIconBoxStartIndex, i.verticalIconBoxEndIndex, i, !1)
            }
          }
          _deserializeCollisionBoxesForSymbol(t, i, a, u, p, f, g, x, S) {
            const I = {};
            for (let k = i; k < a; k++) {
              const R = t.get(k);
              I.textBox = {
                x1: R.x1,
                y1: R.y1,
                x2: R.x2,
                y2: R.y2,
                anchorPointX: R.anchorPointX,
                anchorPointY: R.anchorPointY
              }, I.textFeatureIndex = R.featureIndex;
              break
            }
            for (let k = u; k < p; k++) {
              const R = t.get(k);
              I.verticalTextBox = {
                x1: R.x1,
                y1: R.y1,
                x2: R.x2,
                y2: R.y2,
                anchorPointX: R.anchorPointX,
                anchorPointY: R.anchorPointY
              }, I.verticalTextFeatureIndex = R.featureIndex;
              break
            }
            for (let k = f; k < g; k++) {
              const R = t.get(k);
              I.iconBox = {
                x1: R.x1,
                y1: R.y1,
                x2: R.x2,
                y2: R.y2,
                anchorPointX: R.anchorPointX,
                anchorPointY: R.anchorPointY
              }, I.iconFeatureIndex = R.featureIndex;
              break
            }
            for (let k = x; k < S; k++) {
              const R = t.get(k);
              I.verticalIconBox = {
                x1: R.x1,
                y1: R.y1,
                x2: R.x2,
                y2: R.y2,
                anchorPointX: R.anchorPointX,
                anchorPointY: R.anchorPointY
              }, I.verticalIconFeatureIndex = R.featureIndex;
              break
            }
            return I
          }
          deserializeCollisionBoxes(t) {
            this.collisionArrays = [];
            for (let i = 0; i < this.symbolInstances.length; i++) {
              const a = this.symbolInstances.get(i);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, a.textBoxStartIndex, a.textBoxEndIndex, a.verticalTextBoxStartIndex, a.verticalTextBoxEndIndex, a.iconBoxStartIndex, a.iconBoxEndIndex, a.verticalIconBoxStartIndex, a.verticalIconBoxEndIndex))
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0
          }
          hasIconData() {
            return this.icon.segments.get().length > 0
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0
          }
          addIndicesForPlacedSymbol(t, i) {
            const a = t.placedSymbolArray.get(i),
              u = a.vertexStartIndex + 4 * a.numGlyphs;
            for (let p = a.vertexStartIndex; p < u; p += 4) t.indexArray.emplaceBack(p, p + 2, p + 1), t.indexArray.emplaceBack(p + 1, p + 2, p + 3)
          }
          getSortedSymbolIndexes(t) {
            if (this.sortedAngle === t && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
            const i = Math.sin(t),
              a = Math.cos(t),
              u = [],
              p = [],
              f = [];
            for (let g = 0; g < this.symbolInstances.length; ++g) {
              f.push(g);
              const x = this.symbolInstances.get(g);
              u.push(0 | Math.round(i * x.anchorX + a * x.anchorY)), p.push(x.featureIndex)
            }
            return f.sort(((g, x) => u[g] - u[x] || p[x] - p[g])), f
          }
          addToSortKeyRanges(t, i) {
            const a = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            a && a.sortKey === i ? a.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({
              sortKey: i,
              symbolInstanceStart: t,
              symbolInstanceEnd: t + 1
            })
          }
          sortFeatures(t) {
            if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const i of this.symbolInstanceIndexes) {
                const a = this.symbolInstances.get(i);
                this.featureSortOrder.push(a.featureIndex), [a.rightJustifiedTextSymbolIndex, a.centerJustifiedTextSymbolIndex, a.leftJustifiedTextSymbolIndex].forEach(((u, p, f) => {
                  u >= 0 && f.indexOf(u) === p && this.addIndicesForPlacedSymbol(this.text, u)
                })), a.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, a.verticalPlacedTextSymbolIndex), a.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, a.placedIconSymbolIndex), a.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, a.verticalPlacedIconSymbolIndex)
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray)
            }
          }
        }
        let E_, z_;
        Wt("SymbolBucket", Nl, {
          omit: ["layers", "collisionBoxArray", "features", "compareText"]
        }), Nl.MAX_GLYPHS = 65535, Nl.addDynamicAttributes = Up;
        var Wp = {
          get paint() {
            return z_ = z_ || new Fn({
              "icon-opacity": new Lr(ve.paint_symbol["icon-opacity"]),
              "icon-color": new Lr(ve.paint_symbol["icon-color"]),
              "icon-halo-color": new Lr(ve.paint_symbol["icon-halo-color"]),
              "icon-halo-width": new Lr(ve.paint_symbol["icon-halo-width"]),
              "icon-halo-blur": new Lr(ve.paint_symbol["icon-halo-blur"]),
              "icon-translate": new ar(ve.paint_symbol["icon-translate"]),
              "icon-translate-anchor": new ar(ve.paint_symbol["icon-translate-anchor"]),
              "text-opacity": new Lr(ve.paint_symbol["text-opacity"]),
              "text-color": new Lr(ve.paint_symbol["text-color"], {
                runtimeType: ai,
                getOverride: n => n.textColor,
                hasOverride: n => !!n.textColor
              }),
              "text-halo-color": new Lr(ve.paint_symbol["text-halo-color"]),
              "text-halo-width": new Lr(ve.paint_symbol["text-halo-width"]),
              "text-halo-blur": new Lr(ve.paint_symbol["text-halo-blur"]),
              "text-translate": new ar(ve.paint_symbol["text-translate"]),
              "text-translate-anchor": new ar(ve.paint_symbol["text-translate-anchor"])
            })
          },
          get layout() {
            return E_ = E_ || new Fn({
              "symbol-placement": new ar(ve.layout_symbol["symbol-placement"]),
              "symbol-spacing": new ar(ve.layout_symbol["symbol-spacing"]),
              "symbol-avoid-edges": new ar(ve.layout_symbol["symbol-avoid-edges"]),
              "symbol-sort-key": new Lr(ve.layout_symbol["symbol-sort-key"]),
              "symbol-z-order": new ar(ve.layout_symbol["symbol-z-order"]),
              "icon-allow-overlap": new ar(ve.layout_symbol["icon-allow-overlap"]),
              "icon-overlap": new ar(ve.layout_symbol["icon-overlap"]),
              "icon-ignore-placement": new ar(ve.layout_symbol["icon-ignore-placement"]),
              "icon-optional": new ar(ve.layout_symbol["icon-optional"]),
              "icon-rotation-alignment": new ar(ve.layout_symbol["icon-rotation-alignment"]),
              "icon-size": new Lr(ve.layout_symbol["icon-size"]),
              "icon-text-fit": new ar(ve.layout_symbol["icon-text-fit"]),
              "icon-text-fit-padding": new ar(ve.layout_symbol["icon-text-fit-padding"]),
              "icon-image": new Lr(ve.layout_symbol["icon-image"]),
              "icon-rotate": new Lr(ve.layout_symbol["icon-rotate"]),
              "icon-padding": new Lr(ve.layout_symbol["icon-padding"]),
              "icon-keep-upright": new ar(ve.layout_symbol["icon-keep-upright"]),
              "icon-offset": new Lr(ve.layout_symbol["icon-offset"]),
              "icon-anchor": new Lr(ve.layout_symbol["icon-anchor"]),
              "icon-pitch-alignment": new ar(ve.layout_symbol["icon-pitch-alignment"]),
              "text-pitch-alignment": new ar(ve.layout_symbol["text-pitch-alignment"]),
              "text-rotation-alignment": new ar(ve.layout_symbol["text-rotation-alignment"]),
              "text-field": new Lr(ve.layout_symbol["text-field"]),
              "text-font": new Lr(ve.layout_symbol["text-font"]),
              "text-size": new Lr(ve.layout_symbol["text-size"]),
              "text-max-width": new Lr(ve.layout_symbol["text-max-width"]),
              "text-line-height": new ar(ve.layout_symbol["text-line-height"]),
              "text-letter-spacing": new Lr(ve.layout_symbol["text-letter-spacing"]),
              "text-justify": new Lr(ve.layout_symbol["text-justify"]),
              "text-radial-offset": new Lr(ve.layout_symbol["text-radial-offset"]),
              "text-variable-anchor": new ar(ve.layout_symbol["text-variable-anchor"]),
              "text-variable-anchor-offset": new Lr(ve.layout_symbol["text-variable-anchor-offset"]),
              "text-anchor": new Lr(ve.layout_symbol["text-anchor"]),
              "text-max-angle": new ar(ve.layout_symbol["text-max-angle"]),
              "text-writing-mode": new ar(ve.layout_symbol["text-writing-mode"]),
              "text-rotate": new Lr(ve.layout_symbol["text-rotate"]),
              "text-padding": new ar(ve.layout_symbol["text-padding"]),
              "text-keep-upright": new ar(ve.layout_symbol["text-keep-upright"]),
              "text-transform": new Lr(ve.layout_symbol["text-transform"]),
              "text-offset": new Lr(ve.layout_symbol["text-offset"]),
              "text-allow-overlap": new ar(ve.layout_symbol["text-allow-overlap"]),
              "text-overlap": new ar(ve.layout_symbol["text-overlap"]),
              "text-ignore-placement": new ar(ve.layout_symbol["text-ignore-placement"]),
              "text-optional": new ar(ve.layout_symbol["text-optional"])
            })
          }
        };
        class L_ {
          constructor(t) {
            if (t.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = t.property.overrides ? t.property.overrides.runtimeType : Xr, this.defaultValue = t
          }
          evaluate(t) {
            if (t.formattedSection) {
              const i = this.defaultValue.property.overrides;
              if (i && i.hasOverride(t.formattedSection)) return i.getOverride(t.formattedSection)
            }
            return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default
          }
          eachChild(t) {
            this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression)
          }
          outputDefined() {
            return !1
          }
          serialize() {
            return null
          }
        }
        Wt("FormatSectionOverride", L_, {
          omit: ["defaultValue"]
        });
        class pd extends wn {
          constructor(t) {
            super(t, Wp)
          }
          recalculate(t, i) {
            if (super.recalculate(t, i), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
              const a = this.layout.get("text-writing-mode");
              if (a) {
                const u = [];
                for (const p of a) u.indexOf(p) < 0 && u.push(p);
                this.layout._values["text-writing-mode"] = u
              } else this.layout._values["text-writing-mode"] = ["horizontal"]
            }
            this._setPaintOverrides()
          }
          getValueAndResolveTokens(t, i, a, u) {
            const p = this.layout.get(t).evaluate(i, {}, a, u),
              f = this._unevaluatedLayout._values[t];
            return f.isDataDriven() || _l(f.value) || !p ? p : (function(g, x) {
              return x.replace(/{([^{}]+)}/g, ((S, I) => g && I in g ? String(g[I]) : ""))
            })(i.properties, p)
          }
          createBucket(t) {
            return new Nl(t)
          }
          queryRadius() {
            return 0
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex")
          }
          _setPaintOverrides() {
            for (const t of Wp.paint.overridableProperties) {
              if (!pd.hasPaintOverride(this.layout, t)) continue;
              const i = this.paint.get(t),
                a = new L_(i),
                u = new ml(a, i.property.specification);
              let p = null;
              p = i.value.kind === "constant" || i.value.kind === "source" ? new Co("source", u) : new vl("composite", u, i.value.zoomStops), this.paint._values[t] = new Ia(i.property, p, i.parameters)
            }
          }
          _handleOverridablePaintPropertyUpdate(t, i, a) {
            return !(!this.layout || i.isDataDriven() || a.isDataDriven()) && pd.hasPaintOverride(this.layout, t)
          }
          static hasPaintOverride(t, i) {
            const a = t.get("text-field"),
              u = Wp.paint.properties[i];
            let p = !1;
            const f = g => {
              for (const x of g)
                if (u.overrides && u.overrides.hasOverride(x)) return void(p = !0)
            };
            if (a.value.kind === "constant" && a.value.value instanceof Yi) f(a.value.value.sections);
            else if (a.value.kind === "source") {
              const g = S => {
                  p || (S instanceof Dn && Nr(S.value) === Ar ? f(S.value.sections) : S instanceof go ? f(S.sections) : S.eachChild(g))
                },
                x = a.value;
              x._styleExpression && g(x._styleExpression.expression)
            }
            return p
          }
        }
        let D_;
        var iy = {
          get paint() {
            return D_ = D_ || new Fn({
              "background-color": new ar(ve.paint_background["background-color"]),
              "background-pattern": new Kc(ve.paint_background["background-pattern"]),
              "background-opacity": new ar(ve.paint_background["background-opacity"])
            })
          }
        };
        class ny extends wn {
          constructor(t) {
            super(t, iy)
          }
        }
        let R_;
        var ay = {
          get paint() {
            return R_ = R_ || new Fn({
              "raster-opacity": new ar(ve.paint_raster["raster-opacity"]),
              "raster-hue-rotate": new ar(ve.paint_raster["raster-hue-rotate"]),
              "raster-brightness-min": new ar(ve.paint_raster["raster-brightness-min"]),
              "raster-brightness-max": new ar(ve.paint_raster["raster-brightness-max"]),
              "raster-saturation": new ar(ve.paint_raster["raster-saturation"]),
              "raster-contrast": new ar(ve.paint_raster["raster-contrast"]),
              "raster-resampling": new ar(ve.paint_raster["raster-resampling"]),
              "raster-fade-duration": new ar(ve.paint_raster["raster-fade-duration"])
            })
          }
        };
        class sy extends wn {
          constructor(t) {
            super(t, ay)
          }
        }
        class oy extends wn {
          constructor(t) {
            super(t, {}), this.onAdd = i => {
              this.implementation.onAdd && this.implementation.onAdd(i, i.painter.context.gl)
            }, this.onRemove = i => {
              this.implementation.onRemove && this.implementation.onRemove(i, i.painter.context.gl)
            }, this.implementation = t
          }
          is3D() {
            return this.implementation.renderingMode === "3d"
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0
          }
          recalculate() {}
          updateTransitions() {}
          hasTransition() {
            return !1
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized")
          }
        }
        class ly {
          constructor(t) {
            this._methodToThrottle = t, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel, this._channel.port2.onmessage = () => {
              this._triggered = !1, this._methodToThrottle()
            })
          }
          trigger() {
            this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout((() => {
              this._triggered = !1, this._methodToThrottle()
            }), 0))
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {}
          }
        }
        const cy = {
            once: !0
          },
          Xp = 63710088e-1;
        class to {
          constructor(t, i) {
            if (isNaN(t) || isNaN(i)) throw new Error(`Invalid LngLat object: (${t}, ${i})`);
            if (this.lng = +t, this.lat = +i, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90")
          }
          wrap() {
            return new to(yt(this.lng, -180, 180), this.lat)
          }
          toArray() {
            return [this.lng, this.lat]
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`
          }
          distanceTo(t) {
            const i = Math.PI / 180,
              a = this.lat * i,
              u = t.lat * i,
              p = Math.sin(a) * Math.sin(u) + Math.cos(a) * Math.cos(u) * Math.cos((t.lng - this.lng) * i);
            return Xp * Math.acos(Math.min(p, 1))
          }
          static convert(t) {
            if (t instanceof to) return t;
            if (Array.isArray(t) && (t.length === 2 || t.length === 3)) return new to(Number(t[0]), Number(t[1]));
            if (!Array.isArray(t) && typeof t == "object" && t !== null) return new to(Number("lng" in t ? t.lng : t.lon), Number(t.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")
          }
        }
        const B_ = 2 * Math.PI * Xp;

        function F_(n) {
          return B_ * Math.cos(n * Math.PI / 180)
        }

        function O_(n) {
          return (180 + n) / 360
        }

        function N_(n) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + n * Math.PI / 360))) / 360
        }

        function j_(n, t) {
          return n / F_(t)
        }

        function Kp(n) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n) * Math.PI / 180)) - 90
        }

        function q_(n, t) {
          return n * F_(Kp(t))
        }
        class gu {
          constructor(t, i, a = 0) {
            this.x = +t, this.y = +i, this.z = +a
          }
          static fromLngLat(t, i = 0) {
            const a = to.convert(t);
            return new gu(O_(a.lng), N_(a.lat), j_(i, a.lat))
          }
          toLngLat() {
            return new to(360 * this.x - 180, Kp(this.y))
          }
          toAltitude() {
            return q_(this.z, this.y)
          }
          meterInMercatorCoordinateUnits() {
            return 1 / B_ * (t = Kp(this.y), 1 / Math.cos(t * Math.PI / 180));
            var t
          }
        }

        function V_(n, t, i) {
          var a = 2 * Math.PI * 6378137 / 256 / Math.pow(2, i);
          return [n * a - 2 * Math.PI * 6378137 / 2, t * a - 2 * Math.PI * 6378137 / 2]
        }
        class Yp {
          constructor(t, i, a) {
            if (!(function(u, p, f) {
                return !(u < 0 || u > 25 || f < 0 || f >= Math.pow(2, u) || p < 0 || p >= Math.pow(2, u))
              })(t, i, a)) throw new Error(`x=${i}, y=${a}, z=${t} outside of bounds. 0<=x<${Math.pow(2,t)}, 0<=y<${Math.pow(2,t)} 0<=z<=25 `);
            this.z = t, this.x = i, this.y = a, this.key = jl(0, t, t, i, a)
          }
          equals(t) {
            return this.z === t.z && this.x === t.x && this.y === t.y
          }
          url(t, i, a) {
            const u = (f = this.y, g = this.z, x = V_(256 * (p = this.x), 256 * (f = Math.pow(2, g) - f - 1), g), S = V_(256 * (p + 1), 256 * (f + 1), g), x[0] + "," + x[1] + "," + S[0] + "," + S[1]);
            var p, f, g, x, S;
            const I = (function(k, R, N) {
              let q, U = "";
              for (let J = k; J > 0; J--) q = 1 << J - 1, U += (R & q ? 1 : 0) + (N & q ? 2 : 0);
              return U
            })(this.z, this.x, this.y);
            return t[(this.x + this.y) % t.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(a === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, i > 1 ? "@2x" : "").replace(/{quadkey}/g, I).replace(/{bbox-epsg-3857}/g, u)
          }
          isChildOf(t) {
            const i = this.z - t.z;
            return i > 0 && t.x === this.x >> i && t.y === this.y >> i
          }
          getTilePoint(t) {
            const i = Math.pow(2, this.z);
            return new le((t.x * i - this.x) * Ke, (t.y * i - this.y) * Ke)
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`
          }
        }
        class Z_ {
          constructor(t, i) {
            this.wrap = t, this.canonical = i, this.key = jl(t, i.z, i.z, i.x, i.y)
          }
        }
        class va {
          constructor(t, i, a, u, p) {
            if (this.terrainRttPosMatrix32f = null, t < a) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t}; z = ${a}`);
            this.overscaledZ = t, this.wrap = i, this.canonical = new Yp(a, +u, +p), this.key = jl(i, t, a, u, p)
          }
          clone() {
            return new va(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          equals(t) {
            return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical)
          }
          scaledTo(t) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const i = this.canonical.z - t;
            return t > this.canonical.z ? new va(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new va(t, this.wrap, t, this.canonical.x >> i, this.canonical.y >> i)
          }
          calculateScaledKey(t, i) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const a = this.canonical.z - t;
            return t > this.canonical.z ? jl(this.wrap * +i, t, this.canonical.z, this.canonical.x, this.canonical.y) : jl(this.wrap * +i, t, t, this.canonical.x >> a, this.canonical.y >> a)
          }
          isChildOf(t) {
            if (t.wrap !== this.wrap) return !1;
            const i = this.canonical.z - t.canonical.z;
            return t.overscaledZ === 0 || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> i && t.canonical.y === this.canonical.y >> i
          }
          children(t) {
            if (this.overscaledZ >= t) return [new va(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const i = this.canonical.z + 1,
              a = 2 * this.canonical.x,
              u = 2 * this.canonical.y;
            return [new va(i, this.wrap, i, a, u), new va(i, this.wrap, i, a + 1, u), new va(i, this.wrap, i, a, u + 1), new va(i, this.wrap, i, a + 1, u + 1)]
          }
          isLessThan(t) {
            return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y))
          }
          wrapped() {
            return new va(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          unwrapTo(t) {
            return new va(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y)
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z)
          }
          toUnwrapped() {
            return new Z_(this.wrap, this.canonical)
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`
          }
          getTilePoint(t) {
            return this.canonical.getTilePoint(new gu(t.x - this.wrap, t.y))
          }
        }

        function jl(n, t, i, a, u) {
          (n *= 2) < 0 && (n = -1 * n - 1);
          const p = 1 << i;
          return (p * p * n + p * u + a).toString(36) + i.toString(36) + t.toString(36)
        }
        Wt("CanonicalTileID", Yp), Wt("OverscaledTileID", va, {
          omit: ["terrainRttPosMatrix32f"]
        });
        class Uo {
          constructor() {
            this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0
          }
          extend(t) {
            return this.minX = Math.min(this.minX, t.x), this.minY = Math.min(this.minY, t.y), this.maxX = Math.max(this.maxX, t.x), this.maxY = Math.max(this.maxY, t.y), this
          }
          expandBy(t) {
            return this.minX -= t, this.minY -= t, this.maxX += t, this.maxY += t, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0), this
          }
          shrinkBy(t) {
            return this.expandBy(-t)
          }
          map(t) {
            const i = new Uo;
            return i.extend(t(new le(this.minX, this.minY))), i.extend(t(new le(this.maxX, this.minY))), i.extend(t(new le(this.minX, this.maxY))), i.extend(t(new le(this.maxX, this.maxY))), i
          }
          static fromPoints(t) {
            const i = new Uo;
            for (const a of t) i.extend(a);
            return i
          }
          contains(t) {
            return t.x >= this.minX && t.x <= this.maxX && t.y >= this.minY && t.y <= this.maxY
          }
          empty() {
            return this.minX > this.maxX
          }
          width() {
            return this.maxX - this.minX
          }
          height() {
            return this.maxY - this.minY
          }
          covers(t) {
            return !this.empty() && !t.empty() && t.minX >= this.minX && t.maxX <= this.maxX && t.minY >= this.minY && t.maxY <= this.maxY
          }
          intersects(t) {
            return !this.empty() && !t.empty() && t.minX <= this.maxX && t.maxX >= this.minX && t.minY <= this.maxY && t.maxY >= this.minY
          }
        }
        class $_ {
          constructor(t) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let i = 0; i < t.length; i++) {
              const a = t[i];
              this._stringToNumber[a] = i, this._numberToString[i] = a
            }
          }
          encode(t) {
            return this._stringToNumber[t]
          }
          decode(t) {
            if (t >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[t]
          }
        }
        class U_ {
          constructor(t, i, a, u, p) {
            this.type = "Feature", this._vectorTileFeature = t, t._z = i, t._x = a, t._y = u, this.properties = t.properties, this.id = p
          }
          get geometry() {
            return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry
          }
          set geometry(t) {
            this._geometry = t
          }
          toJSON() {
            const t = {
              geometry: this.geometry
            };
            for (const i in this) i !== "_geometry" && i !== "_vectorTileFeature" && (t[i] = this[i]);
            return t
          }
        }
        class G_ {
          constructor(t, i) {
            this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new Xs(Ke, 16, 0), this.grid3D = new Xs(Ke, 16, 0), this.featureIndexArray = new Je, this.promoteId = i
          }
          insert(t, i, a, u, p, f) {
            const g = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(a, u, p);
            const x = f ? this.grid3D : this.grid;
            for (let S = 0; S < i.length; S++) {
              const I = i[S],
                k = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let R = 0; R < I.length; R++) {
                const N = I[R];
                k[0] = Math.min(k[0], N.x), k[1] = Math.min(k[1], N.y), k[2] = Math.max(k[2], N.x), k[3] = Math.max(k[3], N.y)
              }
              k[0] < Ke && k[1] < Ke && k[2] >= 0 && k[3] >= 0 && x.insert(g, k[0], k[1], k[2], k[3])
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new du.VectorTile(new jp(this.rawTileData)).layers, this.sourceLayerCoder = new $_(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers
          }
          query(t, i, a, u) {
            this.loadVTLayers();
            const p = t.params,
              f = Ke / t.tileSize / t.scale,
              g = Ha(p.filter),
              x = t.queryGeometry,
              S = t.queryPadding * f,
              I = Uo.fromPoints(x),
              k = this.grid.query(I.minX - S, I.minY - S, I.maxX + S, I.maxY + S),
              R = Uo.fromPoints(t.cameraQueryGeometry).expandBy(S),
              N = this.grid3D.query(R.minX, R.minY, R.maxX, R.maxY, ((J, ae, ke, _e) => (function(O, Y, ge, Xe, wt) {
                for (const ut of O)
                  if (Y <= ut.x && ge <= ut.y && Xe >= ut.x && wt >= ut.y) return !0;
                const it = [new le(Y, ge), new le(Y, wt), new le(Xe, wt), new le(Xe, ge)];
                if (O.length > 2) {
                  for (const ut of it)
                    if (Dl(O, ut)) return !0
                }
                for (let ut = 0; ut < O.length - 1; ut++)
                  if (Kv(O[ut], O[ut + 1], it)) return !0;
                return !1
              })(t.cameraQueryGeometry, J - S, ae - S, ke + S, _e + S)));
            for (const J of N) k.push(J);
            k.sort(uy);
            const q = {};
            let U;
            for (let J = 0; J < k.length; J++) {
              const ae = k[J];
              if (ae === U) continue;
              U = ae;
              const ke = this.featureIndexArray.get(ae);
              let _e = null;
              this.loadMatchingFeature(q, ke.bucketIndex, ke.sourceLayerIndex, ke.featureIndex, g, p.layers, p.availableImages, i, a, u, ((O, Y, ge) => (_e || (_e = qo(O)), Y.queryIntersectsFeature({
                queryGeometry: x,
                feature: O,
                featureState: ge,
                geometry: _e,
                zoom: this.z,
                transform: t.transform,
                pixelsToTileUnits: f,
                pixelPosMatrix: t.pixelPosMatrix,
                unwrappedTileID: this.tileID.toUnwrapped(),
                getElevation: t.getElevation
              }))))
            }
            return q
          }
          loadMatchingFeature(t, i, a, u, p, f, g, x, S, I, k) {
            const R = this.bucketLayerIDs[i];
            if (f && !R.some((J => f.has(J)))) return;
            const N = this.sourceLayerCoder.decode(a),
              q = this.vtLayers[N].feature(u);
            if (p.needGeometry) {
              const J = Vo(q, !0);
              if (!p.filter(new Bi(this.tileID.overscaledZ), J, this.tileID.canonical)) return
            } else if (!p.filter(new Bi(this.tileID.overscaledZ), q)) return;
            const U = this.getId(q, N);
            for (let J = 0; J < R.length; J++) {
              const ae = R[J];
              if (f && !f.has(ae)) continue;
              const ke = x[ae];
              if (!ke) continue;
              let _e = {};
              U && I && (_e = I.getState(ke.sourceLayer || "_geojsonTileLayer", U));
              const O = St({}, S[ae]);
              O.paint = H_(O.paint, ke.paint, q, _e, g), O.layout = H_(O.layout, ke.layout, q, _e, g);
              const Y = !k || k(q, ke, _e);
              if (!Y) continue;
              const ge = new U_(q, this.z, this.x, this.y, U);
              ge.layer = O;
              let Xe = t[ae];
              Xe === void 0 && (Xe = t[ae] = []), Xe.push({
                featureIndex: u,
                feature: ge,
                intersectionZ: Y
              })
            }
          }
          lookupSymbolFeatures(t, i, a, u, p, f, g, x) {
            const S = {};
            this.loadVTLayers();
            const I = Ha(p);
            for (const k of t) this.loadMatchingFeature(S, a, u, k, I, f, g, x, i);
            return S
          }
          hasLayer(t) {
            for (const i of this.bucketLayerIDs)
              for (const a of i)
                if (t === a) return !0;
            return !1
          }
          getId(t, i) {
            var a;
            let u = t.id;
            return this.promoteId && (u = t.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[i]], typeof u == "boolean" && (u = Number(u)), u === void 0 && (!((a = t.properties) === null || a === void 0) && a.cluster) && this.promoteId && (u = Number(t.properties.cluster_id))), u
          }
        }

        function H_(n, t, i, a, u) {
          return Lt(n, ((p, f) => {
            const g = t instanceof kl ? t.get(f) : null;
            return g && g.evaluate ? g.evaluate(i, a, u) : g
          }))
        }

        function uy(n, t) {
          return t - n
        }

        function W_(n, t, i, a, u) {
          const p = [];
          for (let f = 0; f < n.length; f++) {
            const g = n[f];
            let x;
            for (let S = 0; S < g.length - 1; S++) {
              let I = g[S],
                k = g[S + 1];
              I.x < t && k.x < t || (I.x < t ? I = new le(t, I.y + (t - I.x) / (k.x - I.x) * (k.y - I.y))._round() : k.x < t && (k = new le(t, I.y + (t - I.x) / (k.x - I.x) * (k.y - I.y))._round()), I.y < i && k.y < i || (I.y < i ? I = new le(I.x + (i - I.y) / (k.y - I.y) * (k.x - I.x), i)._round() : k.y < i && (k = new le(I.x + (i - I.y) / (k.y - I.y) * (k.x - I.x), i)._round()), I.x >= a && k.x >= a || (I.x >= a ? I = new le(a, I.y + (a - I.x) / (k.x - I.x) * (k.y - I.y))._round() : k.x >= a && (k = new le(a, I.y + (a - I.x) / (k.x - I.x) * (k.y - I.y))._round()), I.y >= u && k.y >= u || (I.y >= u ? I = new le(I.x + (u - I.y) / (k.y - I.y) * (k.x - I.x), u)._round() : k.y >= u && (k = new le(I.x + (u - I.y) / (k.y - I.y) * (k.x - I.x), u)._round()), x && I.equals(x[x.length - 1]) || (x = [I], p.push(x)), x.push(k)))))
            }
          }
          return p
        }
        Wt("FeatureIndex", G_, {
          omit: ["rawTileData", "sourceLayerCoder"]
        });
        class ro extends le {
          constructor(t, i, a, u) {
            super(t, i), this.angle = a, u !== void 0 && (this.segment = u)
          }
          clone() {
            return new ro(this.x, this.y, this.angle, this.segment)
          }
        }

        function X_(n, t, i, a, u) {
          if (t.segment === void 0 || i === 0) return !0;
          let p = t,
            f = t.segment + 1,
            g = 0;
          for (; g > -i / 2;) {
            if (f--, f < 0) return !1;
            g -= n[f].dist(p), p = n[f]
          }
          g += n[f].dist(n[f + 1]), f++;
          const x = [];
          let S = 0;
          for (; g < i / 2;) {
            const I = n[f],
              k = n[f + 1];
            if (!k) return !1;
            let R = n[f - 1].angleTo(I) - I.angleTo(k);
            for (R = Math.abs((R + 3 * Math.PI) % (2 * Math.PI) - Math.PI), x.push({
                distance: g,
                angleDelta: R
              }), S += R; g - x[0].distance > a;) S -= x.shift().angleDelta;
            if (S > u) return !1;
            f++, g += I.dist(k)
          }
          return !0
        }

        function K_(n) {
          let t = 0;
          for (let i = 0; i < n.length - 1; i++) t += n[i].dist(n[i + 1]);
          return t
        }

        function Y_(n, t, i) {
          return n ? .6 * t * i : 0
        }

        function J_(n, t) {
          return Math.max(n ? n.right - n.left : 0, t ? t.right - t.left : 0)
        }

        function hy(n, t, i, a, u, p) {
          const f = Y_(i, u, p),
            g = J_(i, a) * p;
          let x = 0;
          const S = K_(n) / 2;
          for (let I = 0; I < n.length - 1; I++) {
            const k = n[I],
              R = n[I + 1],
              N = k.dist(R);
            if (x + N > S) {
              const q = (S - x) / N,
                U = ta.number(k.x, R.x, q),
                J = ta.number(k.y, R.y, q),
                ae = new ro(U, J, R.angleTo(k), I);
              return ae._round(), !f || X_(n, ae, g, f, t) ? ae : void 0
            }
            x += N
          }
        }

        function dy(n, t, i, a, u, p, f, g, x) {
          const S = Y_(a, p, f),
            I = J_(a, u),
            k = I * f,
            R = n[0].x === 0 || n[0].x === x || n[0].y === 0 || n[0].y === x;
          return t - k < t / 4 && (t = k + t / 4), Q_(n, R ? t / 2 * g % t : (I / 2 + 2 * p) * f * g % t, t, S, i, k, R, !1, x)
        }

        function Q_(n, t, i, a, u, p, f, g, x) {
          const S = p / 2,
            I = K_(n);
          let k = 0,
            R = t - i,
            N = [];
          for (let q = 0; q < n.length - 1; q++) {
            const U = n[q],
              J = n[q + 1],
              ae = U.dist(J),
              ke = J.angleTo(U);
            for (; R + i < k + ae;) {
              R += i;
              const _e = (R - k) / ae,
                O = ta.number(U.x, J.x, _e),
                Y = ta.number(U.y, J.y, _e);
              if (O >= 0 && O < x && Y >= 0 && Y < x && R - S >= 0 && R + S <= I) {
                const ge = new ro(O, Y, ke, q);
                ge._round(), a && !X_(n, ge, p, a, u) || N.push(ge)
              }
            }
            k += ae
          }
          return g || N.length || f || (N = Q_(n, k / 2, i, a, u, p, f, !0, x)), N
        }

        function eg(n, t, i, a) {
          const u = [],
            p = n.image,
            f = p.pixelRatio,
            g = p.paddedRect.w - 2,
            x = p.paddedRect.h - 2;
          let S = {
            x1: n.left,
            y1: n.top,
            x2: n.right,
            y2: n.bottom
          };
          const I = p.stretchX || [
              [0, g]
            ],
            k = p.stretchY || [
              [0, x]
            ],
            R = (mt, ir) => mt + ir[1] - ir[0],
            N = I.reduce(R, 0),
            q = k.reduce(R, 0),
            U = g - N,
            J = x - q;
          let ae = 0,
            ke = N,
            _e = 0,
            O = q,
            Y = 0,
            ge = U,
            Xe = 0,
            wt = J;
          if (p.content && a) {
            const mt = p.content,
              ir = mt[2] - mt[0],
              Mr = mt[3] - mt[1];
            (p.textFitWidth || p.textFitHeight) && (S = M_(n)), ae = fd(I, 0, mt[0]), _e = fd(k, 0, mt[1]), ke = fd(I, mt[0], mt[2]), O = fd(k, mt[1], mt[3]), Y = mt[0] - ae, Xe = mt[1] - _e, ge = ir - ke, wt = Mr - O
          }
          const it = S.x1,
            ut = S.y1,
            kt = S.x2 - it,
            Ct = S.y2 - ut,
            zt = (mt, ir, Mr, Sr) => {
              const pr = md(mt.stretch - ae, ke, kt, it),
                ui = _d(mt.fixed - Y, ge, mt.stretch, N),
                Gi = md(ir.stretch - _e, O, Ct, ut),
                on = _d(ir.fixed - Xe, wt, ir.stretch, q),
                Ln = md(Mr.stretch - ae, ke, kt, it),
                ya = _d(Mr.fixed - Y, ge, Mr.stretch, N),
                ia = md(Sr.stretch - _e, O, Ct, ut),
                Pn = _d(Sr.fixed - Xe, wt, Sr.stretch, q),
                Zi = new le(pr, Gi),
                _n = new le(Ln, Gi),
                In = new le(Ln, ia),
                Mn = new le(pr, ia),
                Wn = new le(ui / f, on / f),
                xa = new le(ya / f, Pn / f),
                gn = t * Math.PI / 180;
              if (gn) {
                const vn = Math.sin(gn),
                  yn = Math.cos(gn),
                  rn = [yn, -vn, vn, yn];
                Zi._matMult(rn), _n._matMult(rn), Mn._matMult(rn), In._matMult(rn)
              }
              const na = mt.stretch + mt.fixed,
                ln = ir.stretch + ir.fixed;
              return {
                tl: Zi,
                tr: _n,
                bl: Mn,
                br: In,
                tex: {
                  x: p.paddedRect.x + 1 + na,
                  y: p.paddedRect.y + 1 + ln,
                  w: Mr.stretch + Mr.fixed - na,
                  h: Sr.stretch + Sr.fixed - ln
                },
                writingMode: void 0,
                glyphOffset: [0, 0],
                sectionIndex: 0,
                pixelOffsetTL: Wn,
                pixelOffsetBR: xa,
                minFontScaleX: ge / f / kt,
                minFontScaleY: wt / f / Ct,
                isSDF: i
              }
            };
          if (a && (p.stretchX || p.stretchY)) {
            const mt = tg(I, U, N),
              ir = tg(k, J, q);
            for (let Mr = 0; Mr < mt.length - 1; Mr++) {
              const Sr = mt[Mr],
                pr = mt[Mr + 1];
              for (let ui = 0; ui < ir.length - 1; ui++) u.push(zt(Sr, ir[ui], pr, ir[ui + 1]))
            }
          } else u.push(zt({
            fixed: 0,
            stretch: -1
          }, {
            fixed: 0,
            stretch: -1
          }, {
            fixed: 0,
            stretch: g + 1
          }, {
            fixed: 0,
            stretch: x + 1
          }));
          return u
        }

        function fd(n, t, i) {
          let a = 0;
          for (const u of n) a += Math.max(t, Math.min(i, u[1])) - Math.max(t, Math.min(i, u[0]));
          return a
        }

        function tg(n, t, i) {
          const a = [{
            fixed: -1,
            stretch: 0
          }];
          for (const [u, p] of n) {
            const f = a[a.length - 1];
            a.push({
              fixed: u - f.stretch,
              stretch: f.stretch
            }), a.push({
              fixed: u - f.stretch,
              stretch: f.stretch + (p - u)
            })
          }
          return a.push({
            fixed: t + 1,
            stretch: i
          }), a
        }

        function md(n, t, i, a) {
          return n / t * i + a
        }

        function _d(n, t, i, a) {
          return n - t * i / a
        }
        Wt("Anchor", ro);
        class gd {
          constructor(t, i, a, u, p, f, g, x, S, I) {
            var k;
            if (this.boxStartIndex = t.length, S) {
              let R = f.top,
                N = f.bottom;
              const q = f.collisionPadding;
              q && (R -= q[1], N += q[3]);
              let U = N - R;
              U > 0 && (U = Math.max(10, U), this.circleDiameter = U)
            } else {
              const R = !((k = f.image) === null || k === void 0) && k.content && (f.image.textFitWidth || f.image.textFitHeight) ? M_(f) : {
                x1: f.left,
                y1: f.top,
                x2: f.right,
                y2: f.bottom
              };
              R.y1 = R.y1 * g - x[0], R.y2 = R.y2 * g + x[2], R.x1 = R.x1 * g - x[3], R.x2 = R.x2 * g + x[1];
              const N = f.collisionPadding;
              if (N && (R.x1 -= N[0] * g, R.y1 -= N[1] * g, R.x2 += N[2] * g, R.y2 += N[3] * g), I) {
                const q = new le(R.x1, R.y1),
                  U = new le(R.x2, R.y1),
                  J = new le(R.x1, R.y2),
                  ae = new le(R.x2, R.y2),
                  ke = I * Math.PI / 180;
                q._rotate(ke), U._rotate(ke), J._rotate(ke), ae._rotate(ke), R.x1 = Math.min(q.x, U.x, J.x, ae.x), R.x2 = Math.max(q.x, U.x, J.x, ae.x), R.y1 = Math.min(q.y, U.y, J.y, ae.y), R.y2 = Math.max(q.y, U.y, J.y, ae.y)
              }
              t.emplaceBack(i.x, i.y, R.x1, R.y1, R.x2, R.y2, a, u, p)
            }
            this.boxEndIndex = t.length
          }
        }
        class py {
          constructor(t = [], i = (a, u) => a < u ? -1 : a > u ? 1 : 0) {
            if (this.data = t, this.length = this.data.length, this.compare = i, this.length > 0)
              for (let a = (this.length >> 1) - 1; a >= 0; a--) this._down(a)
          }
          push(t) {
            this.data.push(t), this._up(this.length++)
          }
          pop() {
            if (this.length === 0) return;
            const t = this.data[0],
              i = this.data.pop();
            return --this.length > 0 && (this.data[0] = i, this._down(0)), t
          }
          peek() {
            return this.data[0]
          }
          _up(t) {
            const {
              data: i,
              compare: a
            } = this, u = i[t];
            for (; t > 0;) {
              const p = t - 1 >> 1,
                f = i[p];
              if (a(u, f) >= 0) break;
              i[t] = f, t = p
            }
            i[t] = u
          }
          _down(t) {
            const {
              data: i,
              compare: a
            } = this, u = this.length >> 1, p = i[t];
            for (; t < u;) {
              let f = 1 + (t << 1);
              const g = f + 1;
              if (g < this.length && a(i[g], i[f]) < 0 && (f = g), a(i[f], p) >= 0) break;
              i[t] = i[f], t = f
            }
            i[t] = p
          }
        }

        function fy(n, t = 1, i = !1) {
          const a = Uo.fromPoints(n[0]),
            u = Math.min(a.width(), a.height());
          let p = u / 2;
          const f = new py([], my),
            {
              minX: g,
              minY: x,
              maxX: S,
              maxY: I
            } = a;
          if (u === 0) return new le(g, x);
          for (let N = g; N < S; N += u)
            for (let q = x; q < I; q += u) f.push(new ql(N + p, q + p, p, n));
          let k = (function(N) {
              let q = 0,
                U = 0,
                J = 0;
              const ae = N[0];
              for (let ke = 0, _e = ae.length, O = _e - 1; ke < _e; O = ke++) {
                const Y = ae[ke],
                  ge = ae[O],
                  Xe = Y.x * ge.y - ge.x * Y.y;
                U += (Y.x + ge.x) * Xe, J += (Y.y + ge.y) * Xe, q += 3 * Xe
              }
              return new ql(U / q, J / q, 0, N)
            })(n),
            R = f.length;
          for (; f.length;) {
            const N = f.pop();
            (N.d > k.d || !k.d) && (k = N, i && console.log("found best %d after %d probes", Math.round(1e4 * N.d) / 1e4, R)), N.max - k.d <= t || (p = N.h / 2, f.push(new ql(N.p.x - p, N.p.y - p, p, n)), f.push(new ql(N.p.x + p, N.p.y - p, p, n)), f.push(new ql(N.p.x - p, N.p.y + p, p, n)), f.push(new ql(N.p.x + p, N.p.y + p, p, n)), R += 4)
          }
          return i && (console.log(`num probes: ${R}`), console.log(`best distance: ${k.d}`)), k.p
        }

        function my(n, t) {
          return t.max - n.max
        }

        function ql(n, t, i, a) {
          this.p = new le(n, t), this.h = i, this.d = (function(u, p) {
            let f = !1,
              g = 1 / 0;
            for (let x = 0; x < p.length; x++) {
              const S = p[x];
              for (let I = 0, k = S.length, R = k - 1; I < k; R = I++) {
                const N = S[I],
                  q = S[R];
                N.y > u.y != q.y > u.y && u.x < (q.x - N.x) * (u.y - N.y) / (q.y - N.y) + N.x && (f = !f), g = Math.min(g, Dm(u, N, q))
              }
            }
            return (f ? 1 : -1) * Math.sqrt(g)
          })(this.p, a), this.max = this.d + this.h * Math.SQRT2
        }
        var zn;
        C.aD = void 0, (zn = C.aD || (C.aD = {}))[zn.center = 1] = "center", zn[zn.left = 2] = "left", zn[zn.right = 3] = "right", zn[zn.top = 4] = "top", zn[zn.bottom = 5] = "bottom", zn[zn["top-left"] = 6] = "top-left", zn[zn["top-right"] = 7] = "top-right", zn[zn["bottom-left"] = 8] = "bottom-left", zn[zn["bottom-right"] = 9] = "bottom-right";
        const Jp = Number.POSITIVE_INFINITY;

        function rg(n, t) {
          return t[1] !== Jp ? (function(i, a, u) {
            let p = 0,
              f = 0;
            switch (a = Math.abs(a), u = Math.abs(u), i) {
              case "top-right":
              case "top-left":
              case "top":
                f = u - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                f = 7 - u
            }
            switch (i) {
              case "top-right":
              case "bottom-right":
              case "right":
                p = -a;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                p = a
            }
            return [p, f]
          })(n, t[0], t[1]) : (function(i, a) {
            let u = 0,
              p = 0;
            a < 0 && (a = 0);
            const f = a / Math.SQRT2;
            switch (i) {
              case "top-right":
              case "top-left":
                p = f - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                p = 7 - f;
                break;
              case "bottom":
                p = 7 - a;
                break;
              case "top":
                p = a - 7
            }
            switch (i) {
              case "top-right":
              case "bottom-right":
                u = -f;
                break;
              case "top-left":
              case "bottom-left":
                u = f;
                break;
              case "left":
                u = a;
                break;
              case "right":
                u = -a
            }
            return [u, p]
          })(n, t[0])
        }

        function ig(n, t, i) {
          var a;
          const u = n.layout,
            p = (a = u.get("text-variable-anchor-offset")) === null || a === void 0 ? void 0 : a.evaluate(t, {}, i);
          if (p) {
            const g = p.values,
              x = [];
            for (let S = 0; S < g.length; S += 2) {
              const I = x[S] = g[S],
                k = g[S + 1].map((R => R * mn));
              I.startsWith("top") ? k[1] -= 7 : I.startsWith("bottom") && (k[1] += 7), x[S + 1] = k
            }
            return new di(x)
          }
          const f = u.get("text-variable-anchor");
          if (f) {
            let g;
            g = n._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [u.get("text-radial-offset").evaluate(t, {}, i) * mn, Jp] : u.get("text-offset").evaluate(t, {}, i).map((S => S * mn));
            const x = [];
            for (const S of f) x.push(S, rg(S, g));
            return new di(x)
          }
          return null
        }

        function Qp(n) {
          switch (n) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left"
          }
          return "center"
        }

        function _y(n, t, i, a, u, p, f, g, x, S, I, k) {
          let R = p.textMaxSize.evaluate(t, {});
          R === void 0 && (R = f);
          const N = n.layers[0].layout,
            q = N.get("icon-offset").evaluate(t, {}, I),
            U = ag(i.horizontal),
            J = f / 24,
            ae = n.tilePixelRatio * J,
            ke = n.tilePixelRatio * R / 24,
            _e = n.tilePixelRatio * g,
            O = n.tilePixelRatio * N.get("symbol-spacing"),
            Y = N.get("text-padding") * n.tilePixelRatio,
            ge = (function(Mr, Sr, pr, ui = 1) {
              const Gi = Mr.get("icon-padding").evaluate(Sr, {}, pr),
                on = Gi && Gi.values;
              return [on[0] * ui, on[1] * ui, on[2] * ui, on[3] * ui]
            })(N, t, I, n.tilePixelRatio),
            Xe = N.get("text-max-angle") / 180 * Math.PI,
            wt = N.get("text-rotation-alignment") !== "viewport" && N.get("symbol-placement") !== "point",
            it = N.get("icon-rotation-alignment") === "map" && N.get("symbol-placement") !== "point",
            ut = N.get("symbol-placement"),
            kt = O / 2,
            Ct = N.get("icon-text-fit");
          let zt;
          a && Ct !== "none" && (n.allowVerticalPlacement && i.vertical && (zt = A_(a, i.vertical, Ct, N.get("icon-text-fit-padding"), q, J)), U && (a = A_(a, U, Ct, N.get("icon-text-fit-padding"), q, J)));
          const mt = I ? k.line.getGranularityForZoomLevel(I.z) : 1,
            ir = (Mr, Sr) => {
              Sr.x < 0 || Sr.x >= Ke || Sr.y < 0 || Sr.y >= Ke || (function(pr, ui, Gi, on, Ln, ya, ia, Pn, Zi, _n, In, Mn, Wn, xa, gn, na, ln, vn, yn, rn, Ri, Fa, Vl, Oa, yy) {
                const Zl = pr.addToLineVertexArray(ui, Gi);
                let Go, $l, Ul, Gl, cg = 0,
                  ug = 0,
                  hg = 0,
                  dg = 0,
                  lf = -1,
                  cf = -1;
                const ys = {};
                let pg = Hn("");
                if (pr.allowVerticalPlacement && on.vertical) {
                  const Nn = Pn.layout.get("text-rotate").evaluate(Ri, {}, Oa) + 90;
                  Ul = new gd(Zi, ui, _n, In, Mn, on.vertical, Wn, xa, gn, Nn), ia && (Gl = new gd(Zi, ui, _n, In, Mn, ia, ln, vn, gn, Nn))
                }
                if (Ln) {
                  const Nn = Pn.layout.get("icon-rotate").evaluate(Ri, {}),
                    ba = Pn.layout.get("icon-text-fit") !== "none",
                    Ho = eg(Ln, Nn, Vl, ba),
                    ja = ia ? eg(ia, Nn, Vl, ba) : void 0;
                  $l = new gd(Zi, ui, _n, In, Mn, Ln, ln, vn, !1, Nn), cg = 4 * Ho.length;
                  const Wo = pr.iconSizeData;
                  let is = null;
                  Wo.kind === "source" ? (is = [vs * Pn.layout.get("icon-size").evaluate(Ri, {})], is[0] > eo && Qt(`${pr.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : Wo.kind === "composite" && (is = [vs * Fa.compositeIconSizes[0].evaluate(Ri, {}, Oa), vs * Fa.compositeIconSizes[1].evaluate(Ri, {}, Oa)], (is[0] > eo || is[1] > eo) && Qt(`${pr.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), pr.addSymbols(pr.icon, Ho, is, rn, yn, Ri, C.an.none, ui, Zl.lineStartIndex, Zl.lineLength, -1, Oa), lf = pr.icon.placedSymbolArray.length - 1, ja && (ug = 4 * ja.length, pr.addSymbols(pr.icon, ja, is, rn, yn, Ri, C.an.vertical, ui, Zl.lineStartIndex, Zl.lineLength, -1, Oa), cf = pr.icon.placedSymbolArray.length - 1)
                }
                const fg = Object.keys(on.horizontal);
                for (const Nn of fg) {
                  const ba = on.horizontal[Nn];
                  if (!Go) {
                    pg = Hn(ba.text);
                    const ja = Pn.layout.get("text-rotate").evaluate(Ri, {}, Oa);
                    Go = new gd(Zi, ui, _n, In, Mn, ba, Wn, xa, gn, ja)
                  }
                  const Ho = ba.positionedLines.length === 1;
                  if (hg += ng(pr, ui, ba, ya, Pn, gn, Ri, na, Zl, on.vertical ? C.an.horizontal : C.an.horizontalOnly, Ho ? fg : [Nn], ys, lf, Fa, Oa), Ho) break
                }
                on.vertical && (dg += ng(pr, ui, on.vertical, ya, Pn, gn, Ri, na, Zl, C.an.vertical, ["vertical"], ys, cf, Fa, Oa));
                const xy = Go ? Go.boxStartIndex : pr.collisionBoxArray.length,
                  by = Go ? Go.boxEndIndex : pr.collisionBoxArray.length,
                  wy = Ul ? Ul.boxStartIndex : pr.collisionBoxArray.length,
                  Ty = Ul ? Ul.boxEndIndex : pr.collisionBoxArray.length,
                  Cy = $l ? $l.boxStartIndex : pr.collisionBoxArray.length,
                  Sy = $l ? $l.boxEndIndex : pr.collisionBoxArray.length,
                  Py = Gl ? Gl.boxStartIndex : pr.collisionBoxArray.length,
                  Iy = Gl ? Gl.boxEndIndex : pr.collisionBoxArray.length;
                let Na = -1;
                const yd = (Nn, ba) => Nn && Nn.circleDiameter ? Math.max(Nn.circleDiameter, ba) : ba;
                Na = yd(Go, Na), Na = yd(Ul, Na), Na = yd($l, Na), Na = yd(Gl, Na);
                const mg = Na > -1 ? 1 : 0;
                mg && (Na *= yy / mn), pr.glyphOffsetArray.length >= Nl.MAX_GLYPHS && Qt("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), Ri.sortKey !== void 0 && pr.addToSortKeyRanges(pr.symbolInstances.length, Ri.sortKey);
                const My = ig(Pn, Ri, Oa),
                  [Ay, ky] = (function(Nn, ba) {
                    const Ho = Nn.length,
                      ja = ba == null ? void 0 : ba.values;
                    if ((ja == null ? void 0 : ja.length) > 0)
                      for (let Wo = 0; Wo < ja.length; Wo += 2) {
                        const is = ja[Wo + 1];
                        Nn.emplaceBack(C.aD[ja[Wo]], is[0], is[1])
                      }
                    return [Ho, Nn.length]
                  })(pr.textAnchorOffsets, My);
                pr.symbolInstances.emplaceBack(ui.x, ui.y, ys.right >= 0 ? ys.right : -1, ys.center >= 0 ? ys.center : -1, ys.left >= 0 ? ys.left : -1, ys.vertical || -1, lf, cf, pg, xy, by, wy, Ty, Cy, Sy, Py, Iy, _n, hg, dg, cg, ug, mg, 0, Wn, Na, Ay, ky)
              })(n, Sr, Mr, i, a, u, zt, n.layers[0], n.collisionBoxArray, t.index, t.sourceLayerIndex, n.index, ae, [Y, Y, Y, Y], wt, x, _e, ge, it, q, t, p, S, I, f)
            };
          if (ut === "line")
            for (const Mr of W_(t.geometry, 0, 0, Ke, Ke)) {
              const Sr = $o(Mr, mt),
                pr = dy(Sr, O, Xe, i.vertical || U, a, 24, ke, n.overscaling, Ke);
              for (const ui of pr) U && gy(n, U.text, kt, ui) || ir(Sr, ui)
            } else if (ut === "line-center") {
              for (const Mr of t.geometry)
                if (Mr.length > 1) {
                  const Sr = $o(Mr, mt),
                    pr = hy(Sr, Xe, i.vertical || U, a, 24, ke);
                  pr && ir(Sr, pr)
                }
            } else if (t.type === "Polygon")
            for (const Mr of ll(t.geometry, 0)) {
              const Sr = fy(Mr, 16);
              ir($o(Mr[0], mt, !0), new ro(Sr.x, Sr.y, 0))
            } else if (t.type === "LineString")
              for (const Mr of t.geometry) {
                const Sr = $o(Mr, mt);
                ir(Sr, new ro(Sr[0].x, Sr[0].y, 0))
              } else if (t.type === "Point")
                for (const Mr of t.geometry)
                  for (const Sr of Mr) ir([Sr], new ro(Sr.x, Sr.y, 0))
        }

        function ng(n, t, i, a, u, p, f, g, x, S, I, k, R, N, q) {
          const U = (function(ke, _e, O, Y, ge, Xe, wt, it) {
              const ut = Y.layout.get("text-rotate").evaluate(Xe, {}) * Math.PI / 180,
                kt = [];
              for (const Ct of _e.positionedLines)
                for (const zt of Ct.positionedGlyphs) {
                  if (!zt.rect) continue;
                  const mt = zt.rect || {};
                  let ir = 4,
                    Mr = !0,
                    Sr = 1,
                    pr = 0;
                  const ui = (ge || it) && zt.vertical,
                    Gi = zt.metrics.advance * zt.scale / 2;
                  if (it && _e.verticalizable && (pr = Ct.lineOffset / 2 - (zt.imageName ? -(mn - zt.metrics.width * zt.scale) / 2 : (zt.scale - 1) * mn)), zt.imageName) {
                    const vn = wt[zt.imageName];
                    Mr = vn.sdf, Sr = vn.pixelRatio, ir = 1 / Sr
                  }
                  const on = ge ? [zt.x + Gi, zt.y] : [0, 0];
                  let Ln = ge ? [0, 0] : [zt.x + Gi + O[0], zt.y + O[1] - pr],
                    ya = [0, 0];
                  ui && (ya = Ln, Ln = [0, 0]);
                  const ia = zt.metrics.isDoubleResolution ? 2 : 1,
                    Pn = (zt.metrics.left - ir) * zt.scale - Gi + Ln[0],
                    Zi = (-zt.metrics.top - ir) * zt.scale + Ln[1],
                    _n = Pn + mt.w / ia * zt.scale / Sr,
                    In = Zi + mt.h / ia * zt.scale / Sr,
                    Mn = new le(Pn, Zi),
                    Wn = new le(_n, Zi),
                    xa = new le(Pn, In),
                    gn = new le(_n, In);
                  if (ui) {
                    const vn = new le(-Gi, Gi - -17),
                      yn = -Math.PI / 2,
                      rn = 12 - Gi,
                      Ri = new le(22 - rn, -(zt.imageName ? rn : 0)),
                      Fa = new le(...ya);
                    Mn._rotateAround(yn, vn)._add(Ri)._add(Fa), Wn._rotateAround(yn, vn)._add(Ri)._add(Fa), xa._rotateAround(yn, vn)._add(Ri)._add(Fa), gn._rotateAround(yn, vn)._add(Ri)._add(Fa)
                  }
                  if (ut) {
                    const vn = Math.sin(ut),
                      yn = Math.cos(ut),
                      rn = [yn, -vn, vn, yn];
                    Mn._matMult(rn), Wn._matMult(rn), xa._matMult(rn), gn._matMult(rn)
                  }
                  const na = new le(0, 0),
                    ln = new le(0, 0);
                  kt.push({
                    tl: Mn,
                    tr: Wn,
                    bl: xa,
                    br: gn,
                    tex: mt,
                    writingMode: _e.writingMode,
                    glyphOffset: on,
                    sectionIndex: zt.sectionIndex,
                    isSDF: Mr,
                    pixelOffsetTL: na,
                    pixelOffsetBR: ln,
                    minFontScaleX: 0,
                    minFontScaleY: 0
                  })
                }
              return kt
            })(0, i, g, u, p, f, a, n.allowVerticalPlacement),
            J = n.textSizeData;
          let ae = null;
          J.kind === "source" ? (ae = [vs * u.layout.get("text-size").evaluate(f, {})], ae[0] > eo && Qt(`${n.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : J.kind === "composite" && (ae = [vs * N.compositeTextSizes[0].evaluate(f, {}, q), vs * N.compositeTextSizes[1].evaluate(f, {}, q)], (ae[0] > eo || ae[1] > eo) && Qt(`${n.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), n.addSymbols(n.text, U, ae, g, p, f, S, t, x.lineStartIndex, x.lineLength, R, q);
          for (const ke of I) k[ke] = n.text.placedSymbolArray.length - 1;
          return 4 * U.length
        }

        function ag(n) {
          for (const t in n) return n[t];
          return null
        }

        function gy(n, t, i, a) {
          const u = n.compareText;
          if (t in u) {
            const p = u[t];
            for (let f = p.length - 1; f >= 0; f--)
              if (a.dist(p[f]) < i) return !0
          } else u[t] = [];
          return u[t].push(a), !1
        }
        const sg = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class ef {
          static from(t) {
            if (!(t instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [i, a] = new Uint8Array(t, 0, 2);
            if (i !== 219) throw new Error("Data does not appear to be in a KDBush format.");
            const u = a >> 4;
            if (u !== 1) throw new Error(`Got v${u} data when expected v1.`);
            const p = sg[15 & a];
            if (!p) throw new Error("Unrecognized array type.");
            const [f] = new Uint16Array(t, 2, 1), [g] = new Uint32Array(t, 4, 1);
            return new ef(g, f, p, t)
          }
          constructor(t, i = 64, a = Float64Array, u) {
            if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
            this.numItems = +t, this.nodeSize = Math.min(Math.max(+i, 2), 65535), this.ArrayType = a, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
            const p = sg.indexOf(this.ArrayType),
              f = 2 * t * this.ArrayType.BYTES_PER_ELEMENT,
              g = t * this.IndexArrayType.BYTES_PER_ELEMENT,
              x = (8 - g % 8) % 8;
            if (p < 0) throw new Error(`Unexpected typed array class: ${a}.`);
            u && u instanceof ArrayBuffer ? (this.data = u, this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + g + x, 2 * t), this._pos = 2 * t, this._finished = !0) : (this.data = new ArrayBuffer(8 + f + g + x), this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + g + x, 2 * t), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + p]), new Uint16Array(this.data, 2, 1)[0] = i, new Uint32Array(this.data, 4, 1)[0] = t)
          }
          add(t, i) {
            const a = this._pos >> 1;
            return this.ids[a] = a, this.coords[this._pos++] = t, this.coords[this._pos++] = i, a
          }
          finish() {
            const t = this._pos >> 1;
            if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`);
            return tf(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this
          }
          range(t, i, a, u) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const {
              ids: p,
              coords: f,
              nodeSize: g
            } = this, x = [0, p.length - 1, 0], S = [];
            for (; x.length;) {
              const I = x.pop() || 0,
                k = x.pop() || 0,
                R = x.pop() || 0;
              if (k - R <= g) {
                for (let J = R; J <= k; J++) {
                  const ae = f[2 * J],
                    ke = f[2 * J + 1];
                  ae >= t && ae <= a && ke >= i && ke <= u && S.push(p[J])
                }
                continue
              }
              const N = R + k >> 1,
                q = f[2 * N],
                U = f[2 * N + 1];
              q >= t && q <= a && U >= i && U <= u && S.push(p[N]), (I === 0 ? t <= q : i <= U) && (x.push(R), x.push(N - 1), x.push(1 - I)), (I === 0 ? a >= q : u >= U) && (x.push(N + 1), x.push(k), x.push(1 - I))
            }
            return S
          }
          within(t, i, a) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const {
              ids: u,
              coords: p,
              nodeSize: f
            } = this, g = [0, u.length - 1, 0], x = [], S = a * a;
            for (; g.length;) {
              const I = g.pop() || 0,
                k = g.pop() || 0,
                R = g.pop() || 0;
              if (k - R <= f) {
                for (let J = R; J <= k; J++) lg(p[2 * J], p[2 * J + 1], t, i) <= S && x.push(u[J]);
                continue
              }
              const N = R + k >> 1,
                q = p[2 * N],
                U = p[2 * N + 1];
              lg(q, U, t, i) <= S && x.push(u[N]), (I === 0 ? t - a <= q : i - a <= U) && (g.push(R), g.push(N - 1), g.push(1 - I)), (I === 0 ? t + a >= q : i + a >= U) && (g.push(N + 1), g.push(k), g.push(1 - I))
            }
            return x
          }
        }

        function tf(n, t, i, a, u, p) {
          if (u - a <= i) return;
          const f = a + u >> 1;
          og(n, t, f, a, u, p), tf(n, t, i, a, f - 1, 1 - p), tf(n, t, i, f + 1, u, 1 - p)
        }

        function og(n, t, i, a, u, p) {
          for (; u > a;) {
            if (u - a > 600) {
              const S = u - a + 1,
                I = i - a + 1,
                k = Math.log(S),
                R = .5 * Math.exp(2 * k / 3),
                N = .5 * Math.sqrt(k * R * (S - R) / S) * (I - S / 2 < 0 ? -1 : 1);
              og(n, t, i, Math.max(a, Math.floor(i - I * R / S + N)), Math.min(u, Math.floor(i + (S - I) * R / S + N)), p)
            }
            const f = t[2 * i + p];
            let g = a,
              x = u;
            for (vu(n, t, a, i), t[2 * u + p] > f && vu(n, t, a, u); g < x;) {
              for (vu(n, t, g, x), g++, x--; t[2 * g + p] < f;) g++;
              for (; t[2 * x + p] > f;) x--
            }
            t[2 * a + p] === f ? vu(n, t, a, x) : (x++, vu(n, t, x, u)), x <= i && (a = x + 1), i <= x && (u = x - 1)
          }
        }

        function vu(n, t, i, a) {
          rf(n, i, a), rf(t, 2 * i, 2 * a), rf(t, 2 * i + 1, 2 * a + 1)
        }

        function rf(n, t, i) {
          const a = n[t];
          n[t] = n[i], n[i] = a
        }

        function lg(n, t, i, a) {
          const u = n - i,
            p = t - a;
          return u * u + p * p
        }
        var nf;
        C.cw = void 0, (nf = C.cw || (C.cw = {})).create = "create", nf.load = "load", nf.fullLoad = "fullLoad";
        let vd = null,
          yu = [];
        const af = 1e3 / 60,
          sf = "loadTime",
          of = "fullLoadTime",
          vy = {
            mark(n) {
              performance.mark(n)
            },
            frame(n) {
              const t = n;
              vd != null && yu.push(t - vd), vd = t
            },
            clearMetrics() {
              vd = null, yu = [], performance.clearMeasures(sf), performance.clearMeasures(of);
              for (const n in C.cw) performance.clearMarks(C.cw[n])
            },
            getPerformanceMetrics() {
              performance.measure(sf, C.cw.create, C.cw.load), performance.measure(of, C.cw.create, C.cw.fullLoad);
              const n = performance.getEntriesByName(sf)[0].duration,
                t = performance.getEntriesByName(of)[0].duration,
                i = yu.length,
                a = 1 / (yu.reduce(((p, f) => p + f), 0) / i / 1e3),
                u = yu.filter((p => p > af)).reduce(((p, f) => p + (f - af) / af), 0);
              return {
                loadTime: n,
                fullLoadTime: t,
                fps: a,
                percentDroppedFrames: u / (i + u) * 100,
                totalFrames: i
              }
            }
          };
        C.$ = Ke, C.A = nt, C.B = function([n, t, i]) {
          return t += 90, t *= Math.PI / 180, i *= Math.PI / 180, {
            x: n * Math.cos(t) * Math.sin(i),
            y: n * Math.sin(t) * Math.sin(i),
            z: n * Math.cos(i)
          }
        }, C.C = ta, C.D = ar, C.E = We, C.F = Bi, C.G = Pl, C.H = function(n) {
          if (Ir == null) {
            const t = n.navigator ? n.navigator.userAgent : null;
            Ir = !!n.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome")))
          }
          return Ir
        }, C.I = qp, C.J = class {
          constructor(n, t) {
            this.target = n, this.mapId = t, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new ly((() => this.process())), this.subscription = zr(this.target, "message", (i => this.receive(i)), !1), this.globalScope = Dt(self) ? n : window
          }
          registerMessageHandler(n, t) {
            this.messageHandlers[n] = t
          }
          sendAsync(n, t) {
            return new Promise(((i, a) => {
              const u = Math.round(1e18 * Math.random()).toString(36).substring(0, 10),
                p = t ? zr(t.signal, "abort", (() => {
                  p == null || p.unsubscribe(), delete this.resolveRejects[u];
                  const x = {
                    id: u,
                    type: "<cancel>",
                    origin: location.origin,
                    targetMapId: n.targetMapId,
                    sourceMapId: this.mapId
                  };
                  this.target.postMessage(x)
                }), cy) : null;
              this.resolveRejects[u] = {
                resolve: x => {
                  p == null || p.unsubscribe(), i(x)
                },
                reject: x => {
                  p == null || p.unsubscribe(), a(x)
                }
              };
              const f = [],
                g = Object.assign(Object.assign({}, n), {
                  id: u,
                  sourceMapId: this.mapId,
                  origin: location.origin,
                  data: zo(n.data, f)
                });
              this.target.postMessage(g, {
                transfer: f
              })
            }))
          }
          receive(n) {
            const t = n.data,
              i = t.id;
            if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== "resource://android" && location.origin !== "resource://android" && t.origin !== location.origin || t.targetMapId && this.mapId !== t.targetMapId)) {
              if (t.type === "<cancel>") {
                delete this.tasks[i];
                const a = this.abortControllers[i];
                return delete this.abortControllers[i], void(a && a.abort())
              }
              if (Dt(self) || t.mustQueue) return this.tasks[i] = t, this.taskQueue.push(i), void this.invoker.trigger();
              this.processTask(i, t)
            }
          }
          process() {
            if (this.taskQueue.length === 0) return;
            const n = this.taskQueue.shift(),
              t = this.tasks[n];
            delete this.tasks[n], this.taskQueue.length > 0 && this.invoker.trigger(), t && this.processTask(n, t)
          }
          processTask(n, t) {
            return o(this, void 0, void 0, (function*() {
              if (t.type === "<response>") {
                const u = this.resolveRejects[n];
                return delete this.resolveRejects[n], u ? void(t.error ? u.reject(Ks(t.error)) : u.resolve(Ks(t.data))) : void 0
              }
              if (!this.messageHandlers[t.type]) return void this.completeTask(n, new Error(`Could not find a registered handler for ${t.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const i = Ks(t.data),
                a = new AbortController;
              this.abortControllers[n] = a;
              try {
                const u = yield this.messageHandlers[t.type](t.sourceMapId, i, a);
                this.completeTask(n, null, u)
              } catch (u) {
                this.completeTask(n, u)
              }
            }))
          }
          completeTask(n, t, i) {
            const a = [];
            delete this.abortControllers[n];
            const u = {
              id: n,
              type: "<response>",
              sourceMapId: this.mapId,
              origin: location.origin,
              error: t ? zo(t) : null,
              data: zo(i, a)
            };
            this.target.postMessage(u, {
              transfer: a
            })
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe()
          }
        }, C.K = X, C.L = function() {
          var n = new nt(16);
          return nt != Float32Array && (n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0), n[0] = 1, n[5] = 1, n[10] = 1, n[15] = 1, n
        }, C.M = function(n, t, i) {
          var a, u, p, f, g, x, S, I, k, R, N, q, U = i[0],
            J = i[1],
            ae = i[2];
          return t === n ? (n[12] = t[0] * U + t[4] * J + t[8] * ae + t[12], n[13] = t[1] * U + t[5] * J + t[9] * ae + t[13], n[14] = t[2] * U + t[6] * J + t[10] * ae + t[14], n[15] = t[3] * U + t[7] * J + t[11] * ae + t[15]) : (u = t[1], p = t[2], f = t[3], g = t[4], x = t[5], S = t[6], I = t[7], k = t[8], R = t[9], N = t[10], q = t[11], n[0] = a = t[0], n[1] = u, n[2] = p, n[3] = f, n[4] = g, n[5] = x, n[6] = S, n[7] = I, n[8] = k, n[9] = R, n[10] = N, n[11] = q, n[12] = a * U + g * J + k * ae + t[12], n[13] = u * U + x * J + R * ae + t[13], n[14] = p * U + S * J + N * ae + t[14], n[15] = f * U + I * J + q * ae + t[15]), n
        }, C.N = function(n, t, i) {
          var a = i[0],
            u = i[1],
            p = i[2];
          return n[0] = t[0] * a, n[1] = t[1] * a, n[2] = t[2] * a, n[3] = t[3] * a, n[4] = t[4] * u, n[5] = t[5] * u, n[6] = t[6] * u, n[7] = t[7] * u, n[8] = t[8] * p, n[9] = t[9] * p, n[10] = t[10] * p, n[11] = t[11] * p, n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15], n
        }, C.O = function(n, t, i) {
          var a = t[0],
            u = t[1],
            p = t[2],
            f = t[3],
            g = t[4],
            x = t[5],
            S = t[6],
            I = t[7],
            k = t[8],
            R = t[9],
            N = t[10],
            q = t[11],
            U = t[12],
            J = t[13],
            ae = t[14],
            ke = t[15],
            _e = i[0],
            O = i[1],
            Y = i[2],
            ge = i[3];
          return n[0] = _e * a + O * g + Y * k + ge * U, n[1] = _e * u + O * x + Y * R + ge * J, n[2] = _e * p + O * S + Y * N + ge * ae, n[3] = _e * f + O * I + Y * q + ge * ke, n[4] = (_e = i[4]) * a + (O = i[5]) * g + (Y = i[6]) * k + (ge = i[7]) * U, n[5] = _e * u + O * x + Y * R + ge * J, n[6] = _e * p + O * S + Y * N + ge * ae, n[7] = _e * f + O * I + Y * q + ge * ke, n[8] = (_e = i[8]) * a + (O = i[9]) * g + (Y = i[10]) * k + (ge = i[11]) * U, n[9] = _e * u + O * x + Y * R + ge * J, n[10] = _e * p + O * S + Y * N + ge * ae, n[11] = _e * f + O * I + Y * q + ge * ke, n[12] = (_e = i[12]) * a + (O = i[13]) * g + (Y = i[14]) * k + (ge = i[15]) * U, n[13] = _e * u + O * x + Y * R + ge * J, n[14] = _e * p + O * S + Y * N + ge * ae, n[15] = _e * f + O * I + Y * q + ge * ke, n
        }, C.P = le, C.Q = function(n, t) {
          const i = {};
          for (let a = 0; a < t.length; a++) {
            const u = t[a];
            u in n && (i[u] = n[u])
          }
          return i
        }, C.R = ra, C.S = to, C.T = Pp, C.U = N_, C.V = O_, C.W = Oe, C.X = Ve, C.Y = Fr, C.Z = va, C._ = o, C.a = j, C.a$ = function(n, t, i) {
          return n[0] = t[0] * i, n[1] = t[1] * i, n[2] = t[2] * i, n[3] = t[3] * i, n
        }, C.a0 = gu, C.a1 = Uo, C.a2 = 25, C.a3 = Yp, C.a4 = n => {
          const t = window.document.createElement("video");
          return t.muted = !0, new Promise((i => {
            t.onloadstart = () => {
              i(t)
            };
            for (const a of n) {
              const u = window.document.createElement("source");
              Ze(a) || (t.crossOrigin = "Anonymous"), u.src = a, t.appendChild(u)
            }
          }))
        }, C.a5 = je, C.a6 = function() {
          return jt++
        }, C.a7 = te, C.a8 = Nl, C.a9 = Ha, C.aA = mn, C.aB = tt, C.aC = function(n, t, i, a, u = !1) {
          if (!i[0] && !i[1]) return [0, 0];
          const p = u ? a === "map" ? -n.bearingInRadians : 0 : a === "viewport" ? n.bearingInRadians : 0;
          if (p) {
            const f = Math.sin(p),
              g = Math.cos(p);
            i = [i[0] * g - i[1] * f, i[0] * f + i[1] * g]
          }
          return [u ? i[0] : tt(t, i[0], n.zoom), u ? i[1] : tt(t, i[1], n.zoom)]
        }, C.aE = $p, C.aF = Qp, C.aG = Zp, C.aH = ef, C.aI = Ui, C.aJ = od, C.aK = Ge, C.aL = pi, C.aM = Mi, C.aN = yt, C.aO = br, C.aP = q_, C.aQ = ht, C.aR = at, C.aS = function(n) {
          var t = new nt(3);
          return t[0] = n[0], t[1] = n[1], t[2] = n[2], t
        }, C.aT = function(n, t, i) {
          return n[0] = t[0] - i[0], n[1] = t[1] - i[1], n[2] = t[2] - i[2], n
        }, C.aU = function(n, t) {
          var i = t[0],
            a = t[1],
            u = t[2],
            p = i * i + a * a + u * u;
          return p > 0 && (p = 1 / Math.sqrt(p)), n[0] = t[0] * p, n[1] = t[1] * p, n[2] = t[2] * p, n
        }, C.aV = Re, C.aW = function(n, t) {
          return n[0] * t[0] + n[1] * t[1] + n[2] * t[2]
        }, C.aX = function(n, t, i) {
          return n[0] = t[0] * i[0], n[1] = t[1] * i[1], n[2] = t[2] * i[2], n[3] = t[3] * i[3], n
        }, C.aY = qe, C.aZ = function(n, t, i) {
          const a = t[0] * i[0] + t[1] * i[1] + t[2] * i[2];
          return a === 0 ? null : (-(n[0] * i[0] + n[1] * i[1] + n[2] * i[2]) - i[3]) / a
        }, C.a_ = Q, C.aa = Vo, C.ab = U_, C.ac = function(n) {
          const t = {};
          if (n.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((i, a, u, p) => {
              const f = u || p;
              return t[a] = !f || f.toLowerCase(), ""
            })), t["max-age"]) {
            const i = parseInt(t["max-age"], 10);
            isNaN(i) ? delete t["max-age"] : t["max-age"] = i
          }
          return t
        }, C.ad = tr, C.ae = function(n) {
          return Math.pow(2, n)
        }, C.af = dt, C.ag = Mt, C.ah = 85.051129, C.ai = j_, C.aj = function(n) {
          return Math.log(n) / Math.LN2
        }, C.ak = function(n) {
          var t = n[0],
            i = n[1];
          return t * t + i * i
        }, C.al = function(n, t) {
          const i = [];
          for (const a in n) a in t || i.push(a);
          return i
        }, C.am = function(n, t) {
          let i = 0,
            a = 0;
          if (n.kind === "constant") a = n.layoutSize;
          else if (n.kind !== "source") {
            const {
              interpolationType: u,
              minZoom: p,
              maxZoom: f
            } = n, g = u ? Mt(Rn.interpolationFactor(u, t, p, f), 0, 1) : 0;
            n.kind === "camera" ? a = ta.number(n.minSize, n.maxSize, g) : i = g
          }
          return {
            uSizeT: i,
            uSize: a
          }
        }, C.ao = function(n, {
          uSize: t,
          uSizeT: i
        }, {
          lowerSize: a,
          upperSize: u
        }) {
          return n.kind === "source" ? a / vs : n.kind === "composite" ? ta.number(a / vs, u / vs, i) : t
        }, C.ap = function(n, t) {
          var i = t[0],
            a = t[1],
            u = t[2],
            p = t[3],
            f = t[4],
            g = t[5],
            x = t[6],
            S = t[7],
            I = t[8],
            k = t[9],
            R = t[10],
            N = t[11],
            q = t[12],
            U = t[13],
            J = t[14],
            ae = t[15],
            ke = i * g - a * f,
            _e = i * x - u * f,
            O = i * S - p * f,
            Y = a * x - u * g,
            ge = a * S - p * g,
            Xe = u * S - p * x,
            wt = I * U - k * q,
            it = I * J - R * q,
            ut = I * ae - N * q,
            kt = k * J - R * U,
            Ct = k * ae - N * U,
            zt = R * ae - N * J,
            mt = ke * zt - _e * Ct + O * kt + Y * ut - ge * it + Xe * wt;
          return mt ? (n[0] = (g * zt - x * Ct + S * kt) * (mt = 1 / mt), n[1] = (u * Ct - a * zt - p * kt) * mt, n[2] = (U * Xe - J * ge + ae * Y) * mt, n[3] = (R * ge - k * Xe - N * Y) * mt, n[4] = (x * ut - f * zt - S * it) * mt, n[5] = (i * zt - u * ut + p * it) * mt, n[6] = (J * O - q * Xe - ae * _e) * mt, n[7] = (I * Xe - R * O + N * _e) * mt, n[8] = (f * Ct - g * ut + S * wt) * mt, n[9] = (a * ut - i * Ct - p * wt) * mt, n[10] = (q * ge - U * O + ae * ke) * mt, n[11] = (k * O - I * ge - N * ke) * mt, n[12] = (g * it - f * kt - x * wt) * mt, n[13] = (i * kt - a * it + u * wt) * mt, n[14] = (U * _e - q * Y - J * ke) * mt, n[15] = (I * Y - k * _e + R * ke) * mt, n) : null
        }, C.aq = Ee, C.ar = function(n) {
          return Math.hypot(n[0], n[1])
        }, C.as = function(n) {
          return n[0] = 0, n[1] = 0, n
        }, C.at = function(n, t, i) {
          return n[0] = t[0] * i, n[1] = t[1] * i, n
        }, C.au = Up, C.av = re, C.aw = function(n, t, i, a) {
          const u = t.y - n.y,
            p = t.x - n.x,
            f = a.y - i.y,
            g = a.x - i.x,
            x = f * p - g * u;
          if (x === 0) return null;
          const S = (g * (n.y - i.y) - f * (n.x - i.x)) / x;
          return new le(n.x + S * p, n.y + S * u)
        }, C.ax = W_, C.ay = zm, C.az = function(n) {
          let t = 1 / 0,
            i = 1 / 0,
            a = -1 / 0,
            u = -1 / 0;
          for (const p of n) t = Math.min(t, p.x), i = Math.min(i, p.y), a = Math.max(a, p.x), u = Math.max(u, p.y);
          return [t, i, a, u]
        }, C.b = Tr, C.b$ = N0, C.b0 = function(n, t) {
          return n[0] * t[0] + n[1] * t[1] + n[2] * t[2] + n[3]
        }, C.b1 = Z_, C.b2 = jl, C.b3 = function(n, t, i, a, u) {
          var p, f = 1 / Math.tan(t / 2);
          return n[0] = f / i, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = f, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[11] = -1, n[12] = 0, n[13] = 0, n[15] = 0, u != null && u !== 1 / 0 ? (n[10] = (u + a) * (p = 1 / (a - u)), n[14] = 2 * u * a * p) : (n[10] = -1, n[14] = -2 * a), n
        }, C.b4 = function(n) {
          var t = new nt(16);
          return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], t
        }, C.b5 = function(n, t, i) {
          var a = Math.sin(i),
            u = Math.cos(i),
            p = t[0],
            f = t[1],
            g = t[2],
            x = t[3],
            S = t[4],
            I = t[5],
            k = t[6],
            R = t[7];
          return t !== n && (n[8] = t[8], n[9] = t[9], n[10] = t[10], n[11] = t[11], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15]), n[0] = p * u + S * a, n[1] = f * u + I * a, n[2] = g * u + k * a, n[3] = x * u + R * a, n[4] = S * u - p * a, n[5] = I * u - f * a, n[6] = k * u - g * a, n[7] = R * u - x * a, n
        }, C.b6 = function(n, t, i) {
          var a = Math.sin(i),
            u = Math.cos(i),
            p = t[4],
            f = t[5],
            g = t[6],
            x = t[7],
            S = t[8],
            I = t[9],
            k = t[10],
            R = t[11];
          return t !== n && (n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15]), n[4] = p * u + S * a, n[5] = f * u + I * a, n[6] = g * u + k * a, n[7] = x * u + R * a, n[8] = S * u - p * a, n[9] = I * u - f * a, n[10] = k * u - g * a, n[11] = R * u - x * a, n
        }, C.b7 = function() {
          const n = new Float32Array(16);
          return dt(n), n
        }, C.b8 = function() {
          const n = new Float64Array(16);
          return dt(n), n
        }, C.b9 = function() {
          return new Float64Array(16)
        }, C.bA = function(n) {
          return n[0] = 0, n[1] = 0, n[2] = 0, n
        }, C.bB = function(n, t, i, a) {
          const u = Math.sqrt(n * n + t * t),
            p = Math.sqrt(i * i + a * a);
          n /= u, t /= u, i /= p, a /= p;
          const f = Math.acos(n * i + t * a);
          return -t * i + n * a > 0 ? f : -f
        }, C.bC = function(n, t) {
          const i = ot(n, 2 * Math.PI),
            a = ot(t, 2 * Math.PI);
          return Math.min(Math.abs(i - a), Math.abs(i - a + 2 * Math.PI), Math.abs(i - a - 2 * Math.PI))
        }, C.bD = function() {
          const n = {},
            t = ve.$version;
          for (const i in ve.$root) {
            const a = ve.$root[i];
            if (a.required) {
              let u = null;
              u = i === "version" ? t : a.type === "array" ? [] : {}, u != null && (n[i] = u)
            }
          }
          return n
        }, C.bE = $c, C.bF = we, C.bG = function n(t, i) {
          if (Array.isArray(t)) {
            if (!Array.isArray(i) || t.length !== i.length) return !1;
            for (let a = 0; a < t.length; a++)
              if (!n(t[a], i[a])) return !1;
            return !0
          }
          if (typeof t == "object" && t !== null && i !== null) {
            if (typeof i != "object" || Object.keys(t).length !== Object.keys(i).length) return !1;
            for (const a in t)
              if (!n(t[a], i[a])) return !1;
            return !0
          }
          return t === i
        }, C.bH = function(n) {
          n = n.slice();
          const t = Object.create(null);
          for (let i = 0; i < n.length; i++) t[n[i].id] = n[i];
          for (let i = 0; i < n.length; i++) "ref" in n[i] && (n[i] = Xt(n[i], t[n[i].ref]));
          return n
        }, C.bI = function(n) {
          if (n.type === "custom") return new oy(n);
          switch (n.type) {
            case "background":
              return new ny(n);
            case "circle":
              return new Jv(n);
            case "color-relief":
              return new n0(n);
            case "fill":
              return new y0(n);
            case "fill-extrusion":
              return new I0(n);
            case "heatmap":
              return new e0(n);
            case "hillshade":
              return new r0(n);
            case "line":
              return new R0(n);
            case "raster":
              return new sy(n);
            case "symbol":
              return new pd(n)
          }
        }, C.bJ = gr, C.bK = function(n, t) {
          if (!n) return [{
            command: "setStyle",
            args: [t]
          }];
          let i = [];
          try {
            if (!Nt(n.version, t.version)) return [{
              command: "setStyle",
              args: [t]
            }];
            Nt(n.center, t.center) || i.push({
              command: "setCenter",
              args: [t.center]
            }), Nt(n.state, t.state) || i.push({
              command: "setGlobalState",
              args: [t.state]
            }), Nt(n.centerAltitude, t.centerAltitude) || i.push({
              command: "setCenterAltitude",
              args: [t.centerAltitude]
            }), Nt(n.zoom, t.zoom) || i.push({
              command: "setZoom",
              args: [t.zoom]
            }), Nt(n.bearing, t.bearing) || i.push({
              command: "setBearing",
              args: [t.bearing]
            }), Nt(n.pitch, t.pitch) || i.push({
              command: "setPitch",
              args: [t.pitch]
            }), Nt(n.roll, t.roll) || i.push({
              command: "setRoll",
              args: [t.roll]
            }), Nt(n.sprite, t.sprite) || i.push({
              command: "setSprite",
              args: [t.sprite]
            }), Nt(n.glyphs, t.glyphs) || i.push({
              command: "setGlyphs",
              args: [t.glyphs]
            }), Nt(n.transition, t.transition) || i.push({
              command: "setTransition",
              args: [t.transition]
            }), Nt(n.light, t.light) || i.push({
              command: "setLight",
              args: [t.light]
            }), Nt(n.terrain, t.terrain) || i.push({
              command: "setTerrain",
              args: [t.terrain]
            }), Nt(n.sky, t.sky) || i.push({
              command: "setSky",
              args: [t.sky]
            }), Nt(n.projection, t.projection) || i.push({
              command: "setProjection",
              args: [t.projection]
            });
            const a = {},
              u = [];
            (function(f, g, x, S) {
              let I;
              for (I in g = g || {}, f = f || {}) Object.prototype.hasOwnProperty.call(f, I) && (Object.prototype.hasOwnProperty.call(g, I) || ri(I, x, S));
              for (I in g) Object.prototype.hasOwnProperty.call(g, I) && (Object.prototype.hasOwnProperty.call(f, I) ? Nt(f[I], g[I]) || (f[I].type === "geojson" && g[I].type === "geojson" && Wr(f, g, I) ? Ht(x, {
                command: "setGeoJSONSourceData",
                args: [I, g[I].data]
              }) : ti(I, g, x, S)) : or(I, g, x))
            })(n.sources, t.sources, u, a);
            const p = [];
            n.layers && n.layers.forEach((f => {
              "source" in f && a[f.source] ? i.push({
                command: "removeLayer",
                args: [f.id]
              }) : p.push(f)
            })), i = i.concat(u), (function(f, g, x) {
              g = g || [];
              const S = (f = f || []).map(ii),
                I = g.map(ii),
                k = f.reduce(Hi, {}),
                R = g.reduce(Hi, {}),
                N = S.slice(),
                q = Object.create(null);
              let U, J, ae, ke, _e;
              for (let O = 0, Y = 0; O < S.length; O++) U = S[O], Object.prototype.hasOwnProperty.call(R, U) ? Y++ : (Ht(x, {
                command: "removeLayer",
                args: [U]
              }), N.splice(N.indexOf(U, Y), 1));
              for (let O = 0, Y = 0; O < I.length; O++) U = I[I.length - 1 - O], N[N.length - 1 - O] !== U && (Object.prototype.hasOwnProperty.call(k, U) ? (Ht(x, {
                command: "removeLayer",
                args: [U]
              }), N.splice(N.lastIndexOf(U, N.length - Y), 1)) : Y++, ke = N[N.length - O], Ht(x, {
                command: "addLayer",
                args: [R[U], ke]
              }), N.splice(N.length - O, 0, U), q[U] = !0);
              for (let O = 0; O < I.length; O++)
                if (U = I[O], J = k[U], ae = R[U], !q[U] && !Nt(J, ae))
                  if (Nt(J.source, ae.source) && Nt(J["source-layer"], ae["source-layer"]) && Nt(J.type, ae.type)) {
                    for (_e in Cr(J.layout, ae.layout, x, U, null, "setLayoutProperty"), Cr(J.paint, ae.paint, x, U, null, "setPaintProperty"), Nt(J.filter, ae.filter) || Ht(x, {
                        command: "setFilter",
                        args: [U, ae.filter]
                      }), Nt(J.minzoom, ae.minzoom) && Nt(J.maxzoom, ae.maxzoom) || Ht(x, {
                        command: "setLayerZoomRange",
                        args: [U, ae.minzoom, ae.maxzoom]
                      }), J) Object.prototype.hasOwnProperty.call(J, _e) && _e !== "layout" && _e !== "paint" && _e !== "filter" && _e !== "metadata" && _e !== "minzoom" && _e !== "maxzoom" && (_e.indexOf("paint.") === 0 ? Cr(J[_e], ae[_e], x, U, _e.slice(6), "setPaintProperty") : Nt(J[_e], ae[_e]) || Ht(x, {
                      command: "setLayerProperty",
                      args: [U, _e, ae[_e]]
                    }));
                    for (_e in ae) Object.prototype.hasOwnProperty.call(ae, _e) && !Object.prototype.hasOwnProperty.call(J, _e) && _e !== "layout" && _e !== "paint" && _e !== "filter" && _e !== "metadata" && _e !== "minzoom" && _e !== "maxzoom" && (_e.indexOf("paint.") === 0 ? Cr(J[_e], ae[_e], x, U, _e.slice(6), "setPaintProperty") : Nt(J[_e], ae[_e]) || Ht(x, {
                      command: "setLayerProperty",
                      args: [U, _e, ae[_e]]
                    }))
                  } else Ht(x, {
                    command: "removeLayer",
                    args: [U]
                  }), ke = N[N.lastIndexOf(U) + 1], Ht(x, {
                    command: "addLayer",
                    args: [ae, ke]
                  })
            })(p, t.layers, i)
          } catch (a) {
            console.warn("Unable to compute style diff:", a), i = [{
              command: "setStyle",
              args: [t]
            }]
          }
          return i
        }, C.bL = function(n) {
          const t = [],
            i = n.id;
          return i === void 0 && t.push({
            message: `layers.${i}: missing required property "id"`
          }), n.render === void 0 && t.push({
            message: `layers.${i}: missing required method "render"`
          }), n.renderingMode && n.renderingMode !== "2d" && n.renderingMode !== "3d" && t.push({
            message: `layers.${i}: property "renderingMode" must be either "2d" or "3d"`
          }), t
        }, C.bM = Lt, C.bN = Gt, C.bO = class extends Di {
          constructor(n, t) {
            super(n, t), this.current = 0
          }
          set(n) {
            this.current !== n && (this.current = n, this.gl.uniform1i(this.location, n))
          }
        }, C.bP = rd, C.bQ = class extends Di {
          constructor(n, t) {
            super(n, t), this.current = yp
          }
          set(n) {
            if (n[12] !== this.current[12] || n[0] !== this.current[0]) return this.current = n, void this.gl.uniformMatrix4fv(this.location, !1, n);
            for (let t = 1; t < 16; t++)
              if (n[t] !== this.current[t]) {
                this.current = n, this.gl.uniformMatrix4fv(this.location, !1, n);
                break
              }
          }
        }, C.bR = sn, C.bS = class extends Di {
          constructor(n, t) {
            super(n, t), this.current = [0, 0, 0]
          }
          set(n) {
            n[0] === this.current[0] && n[1] === this.current[1] && n[2] === this.current[2] || (this.current = n, this.gl.uniform3f(this.location, n[0], n[1], n[2]))
          }
        }, C.bT = class extends Di {
          constructor(n, t) {
            super(n, t), this.current = [0, 0]
          }
          set(n) {
            n[0] === this.current[0] && n[1] === this.current[1] || (this.current = n, this.gl.uniform2f(this.location, n[0], n[1]))
          }
        }, C.bU = Ye, C.bV = function(n, t) {
          var i = Math.sin(t),
            a = Math.cos(t);
          return n[0] = a, n[1] = i, n[2] = 0, n[3] = -i, n[4] = a, n[5] = 0, n[6] = 0, n[7] = 0, n[8] = 1, n
        }, C.bW = function(n, t, i) {
          var a = t[0],
            u = t[1],
            p = t[2];
          return n[0] = a * i[0] + u * i[3] + p * i[6], n[1] = a * i[1] + u * i[4] + p * i[7], n[2] = a * i[2] + u * i[5] + p * i[8], n
        }, C.bX = function(n, t, i, a, u, p, f) {
          var g = 1 / (t - i),
            x = 1 / (a - u),
            S = 1 / (p - f);
          return n[0] = -2 * g, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = -2 * x, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 2 * S, n[11] = 0, n[12] = (t + i) * g, n[13] = (u + a) * x, n[14] = (f + p) * S, n[15] = 1, n
        }, C.bY = class extends Di {
          constructor(n, t) {
            super(n, t), this.current = new Array
          }
          set(n) {
            if (n != this.current) {
              this.current = n;
              const t = new Float32Array(4 * n.length);
              for (let i = 0; i < n.length; i++) t[4 * i] = n[i].r, t[4 * i + 1] = n[i].g, t[4 * i + 2] = n[i].b, t[4 * i + 3] = n[i].a;
              this.gl.uniform4fv(this.location, t)
            }
          }
        }, C.bZ = class extends Di {
          constructor(n, t) {
            super(n, t), this.current = new Array
          }
          set(n) {
            if (n != this.current) {
              this.current = n;
              const t = new Float32Array(n);
              this.gl.uniform1fv(this.location, t)
            }
          }
        }, C.b_ = class extends s {}, C.ba = function(n, t, i) {
          const a = new Float64Array(4);
          return ce(a, n, t - 90, i), a
        }, C.bb = function(n, t, i, a) {
          var u, p, f, g, x, S = t[0],
            I = t[1],
            k = t[2],
            R = t[3],
            N = i[0],
            q = i[1],
            U = i[2],
            J = i[3];
          return (p = S * N + I * q + k * U + R * J) < 0 && (p = -p, N = -N, q = -q, U = -U, J = -J), 1 - p > ct ? (u = Math.acos(p), f = Math.sin(u), g = Math.sin((1 - a) * u) / f, x = Math.sin(a * u) / f) : (g = 1 - a, x = a), n[0] = g * S + x * N, n[1] = g * I + x * q, n[2] = g * k + x * U, n[3] = g * R + x * J, n
        }, C.bc = function(n) {
          const t = new Float64Array(9);
          var i, a, u, p, f, g, x, S, I, k, R, N, q, U, J, ae, ke, _e;
          k = (u = (a = n)[0]) * (x = u + u), R = (p = a[1]) * x, q = (f = a[2]) * x, U = f * (S = p + p), ae = (g = a[3]) * x, ke = g * S, _e = g * (I = f + f), (i = t)[0] = 1 - (N = p * S) - (J = f * I), i[3] = R - _e, i[6] = q + ke, i[1] = R + _e, i[4] = 1 - k - J, i[7] = U - ae, i[2] = q - ke, i[5] = U + ae, i[8] = 1 - k - N;
          const O = br(-Math.asin(Mt(t[2], -1, 1)));
          let Y, ge;
          return Math.hypot(t[5], t[8]) < .001 ? (Y = 0, ge = -br(Math.atan2(t[3], t[4]))) : (Y = br(t[5] === 0 && t[8] === 0 ? 0 : Math.atan2(t[5], t[8])), ge = br(t[1] === 0 && t[0] === 0 ? 0 : Math.atan2(t[1], t[0]))), {
            roll: Y,
            pitch: O + 90,
            bearing: ge
          }
        }, C.bd = function(n, t) {
          return n.roll == t.roll && n.pitch == t.pitch && n.bearing == t.bearing
        }, C.be = ni, C.bf = On, C.bg = Fl, C.bh = uu, C.bi = Bl, C.bj = ft, C.bk = Bt, C.bl = Hr, C.bm = function(n, t, i, a, u) {
          return ft(a, u, Mt((n - t) / (i - t), 0, 1))
        }, C.bn = ot, C.bo = function() {
          return new Float64Array(3)
        }, C.bp = function(n, t, i, a) {
          return n[0] = t[0] + i[0] * a, n[1] = t[1] + i[1] * a, n[2] = t[2] + i[2] * a, n
        }, C.bq = ce, C.br = function(n, t, i) {
          var a = i[0],
            u = i[1],
            p = i[2],
            f = t[0],
            g = t[1],
            x = t[2],
            S = u * x - p * g,
            I = p * f - a * x,
            k = a * g - u * f,
            R = u * k - p * I,
            N = p * S - a * k,
            q = a * I - u * S,
            U = 2 * i[3];
          return I *= U, k *= U, N *= 2, q *= 2, n[0] = f + (S *= U) + (R *= 2), n[1] = g + I + N, n[2] = x + k + q, n
        }, C.bs = function(n, t, i) {
          const a = (u = [n[0], n[1], n[2], t[0], t[1], t[2], i[0], i[1], i[2]])[0] * ((I = u[8]) * (f = u[4]) - (g = u[5]) * (S = u[7])) + u[1] * (-I * (p = u[3]) + g * (x = u[6])) + u[2] * (S * p - f * x);
          var u, p, f, g, x, S, I;
          if (a === 0) return null;
          const k = Re([], [t[0], t[1], t[2]], [i[0], i[1], i[2]]),
            R = Re([], [i[0], i[1], i[2]], [n[0], n[1], n[2]]),
            N = Re([], [n[0], n[1], n[2]], [t[0], t[1], t[2]]),
            q = ht([], k, -n[3]);
          return at(q, q, ht([], R, -t[3])), at(q, q, ht([], N, -i[3])), ht(q, q, 1 / a), q
        }, C.bt = Xp, C.bu = function() {
          return new Float64Array(4)
        }, C.bv = function(n, t, i, a) {
          var u = [],
            p = [];
          return u[0] = t[0] - i[0], u[1] = t[1] - i[1], u[2] = t[2] - i[2], p[0] = u[0] * Math.cos(a) - u[1] * Math.sin(a), p[1] = u[0] * Math.sin(a) + u[1] * Math.cos(a), p[2] = u[2], n[0] = p[0] + i[0], n[1] = p[1] + i[1], n[2] = p[2] + i[2], n
        }, C.bw = function(n, t, i, a) {
          var u = [],
            p = [];
          return u[0] = t[0] - i[0], u[1] = t[1] - i[1], u[2] = t[2] - i[2], p[0] = u[0], p[1] = u[1] * Math.cos(a) - u[2] * Math.sin(a), p[2] = u[1] * Math.sin(a) + u[2] * Math.cos(a), n[0] = p[0] + i[0], n[1] = p[1] + i[1], n[2] = p[2] + i[2], n
        }, C.bx = function(n, t, i, a) {
          var u = [],
            p = [];
          return u[0] = t[0] - i[0], u[1] = t[1] - i[1], u[2] = t[2] - i[2], p[0] = u[2] * Math.sin(a) + u[0] * Math.cos(a), p[1] = u[1], p[2] = u[2] * Math.cos(a) - u[0] * Math.sin(a), n[0] = p[0] + i[0], n[1] = p[1] + i[1], n[2] = p[2] + i[2], n
        }, C.by = function(n, t, i) {
          var a = Math.sin(i),
            u = Math.cos(i),
            p = t[0],
            f = t[1],
            g = t[2],
            x = t[3],
            S = t[8],
            I = t[9],
            k = t[10],
            R = t[11];
          return t !== n && (n[4] = t[4], n[5] = t[5], n[6] = t[6], n[7] = t[7], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15]), n[0] = p * u - S * a, n[1] = f * u - I * a, n[2] = g * u - k * a, n[3] = x * u - R * a, n[8] = p * a + S * u, n[9] = f * a + I * u, n[10] = g * a + k * u, n[11] = x * a + R * u, n
        }, C.bz = function(n, t) {
          const i = ot(n, 360),
            a = ot(t, 360),
            u = a - i,
            p = a > i ? u - 360 : u + 360;
          return Math.abs(u) < Math.abs(p) ? u : p
        }, C.c = ye, C.c0 = class extends d {}, C.c1 = Sp, C.c2 = function(n) {
          return n <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(n) / Math.LN2))
        }, C.c3 = Vm, C.c4 = function(n, t, i) {
          var a = t[0],
            u = t[1],
            p = t[2],
            f = i[3] * a + i[7] * u + i[11] * p + i[15];
          return n[0] = (i[0] * a + i[4] * u + i[8] * p + i[12]) / (f = f || 1), n[1] = (i[1] * a + i[5] * u + i[9] * p + i[13]) / f, n[2] = (i[2] * a + i[6] * u + i[10] * p + i[14]) / f, n
        }, C.c5 = class extends Yc {}, C.c6 = class extends L {}, C.c7 = function(n, t) {
          return n[0] === t[0] && n[1] === t[1] && n[2] === t[2] && n[3] === t[3] && n[4] === t[4] && n[5] === t[5] && n[6] === t[6] && n[7] === t[7] && n[8] === t[8] && n[9] === t[9] && n[10] === t[10] && n[11] === t[11] && n[12] === t[12] && n[13] === t[13] && n[14] === t[14] && n[15] === t[15]
        }, C.c8 = function(n, t) {
          var i = n[0],
            a = n[1],
            u = n[2],
            p = n[3],
            f = n[4],
            g = n[5],
            x = n[6],
            S = n[7],
            I = n[8],
            k = n[9],
            R = n[10],
            N = n[11],
            q = n[12],
            U = n[13],
            J = n[14],
            ae = n[15],
            ke = t[0],
            _e = t[1],
            O = t[2],
            Y = t[3],
            ge = t[4],
            Xe = t[5],
            wt = t[6],
            it = t[7],
            ut = t[8],
            kt = t[9],
            Ct = t[10],
            zt = t[11],
            mt = t[12],
            ir = t[13],
            Mr = t[14],
            Sr = t[15];
          return Math.abs(i - ke) <= ct * Math.max(1, Math.abs(i), Math.abs(ke)) && Math.abs(a - _e) <= ct * Math.max(1, Math.abs(a), Math.abs(_e)) && Math.abs(u - O) <= ct * Math.max(1, Math.abs(u), Math.abs(O)) && Math.abs(p - Y) <= ct * Math.max(1, Math.abs(p), Math.abs(Y)) && Math.abs(f - ge) <= ct * Math.max(1, Math.abs(f), Math.abs(ge)) && Math.abs(g - Xe) <= ct * Math.max(1, Math.abs(g), Math.abs(Xe)) && Math.abs(x - wt) <= ct * Math.max(1, Math.abs(x), Math.abs(wt)) && Math.abs(S - it) <= ct * Math.max(1, Math.abs(S), Math.abs(it)) && Math.abs(I - ut) <= ct * Math.max(1, Math.abs(I), Math.abs(ut)) && Math.abs(k - kt) <= ct * Math.max(1, Math.abs(k), Math.abs(kt)) && Math.abs(R - Ct) <= ct * Math.max(1, Math.abs(R), Math.abs(Ct)) && Math.abs(N - zt) <= ct * Math.max(1, Math.abs(N), Math.abs(zt)) && Math.abs(q - mt) <= ct * Math.max(1, Math.abs(q), Math.abs(mt)) && Math.abs(U - ir) <= ct * Math.max(1, Math.abs(U), Math.abs(ir)) && Math.abs(J - Mr) <= ct * Math.max(1, Math.abs(J), Math.abs(Mr)) && Math.abs(ae - Sr) <= ct * Math.max(1, Math.abs(ae), Math.abs(Sr))
        }, C.c9 = function(n, t) {
          return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n[6] = t[6], n[7] = t[7], n[8] = t[8], n[9] = t[9], n[10] = t[10], n[11] = t[11], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15], n
        }, C.cA = function(n) {
          delete j.REGISTERED_PROTOCOLS[n]
        }, C.cB = function(n, t) {
          const i = {};
          for (let u = 0; u < n.length; u++) {
            const p = t && t[n[u].id] || bl(n[u]);
            t && (t[n[u].id] = p);
            let f = i[p];
            f || (f = i[p] = []), f.push(n[u])
          }
          const a = [];
          for (const u in i) a.push(i[u]);
          return a
        }, C.cC = Wt, C.cD = $_, C.cE = G_, C.cF = w_, C.cG = function(n) {
          n.bucket.createArrays(), n.bucket.tilePixelRatio = Ke / (512 * n.bucket.overscaling), n.bucket.compareText = {}, n.bucket.iconsNeedLinear = !1;
          const t = n.bucket.layers[0],
            i = t.layout,
            a = t._unevaluatedLayout._values,
            u = {
              layoutIconSize: a["icon-size"].possiblyEvaluate(new Bi(n.bucket.zoom + 1), n.canonical),
              layoutTextSize: a["text-size"].possiblyEvaluate(new Bi(n.bucket.zoom + 1), n.canonical),
              textMaxSize: a["text-size"].possiblyEvaluate(new Bi(18))
            };
          if (n.bucket.textSizeData.kind === "composite") {
            const {
              minZoom: S,
              maxZoom: I
            } = n.bucket.textSizeData;
            u.compositeTextSizes = [a["text-size"].possiblyEvaluate(new Bi(S), n.canonical), a["text-size"].possiblyEvaluate(new Bi(I), n.canonical)]
          }
          if (n.bucket.iconSizeData.kind === "composite") {
            const {
              minZoom: S,
              maxZoom: I
            } = n.bucket.iconSizeData;
            u.compositeIconSizes = [a["icon-size"].possiblyEvaluate(new Bi(S), n.canonical), a["icon-size"].possiblyEvaluate(new Bi(I), n.canonical)]
          }
          const p = i.get("text-line-height") * mn,
            f = i.get("text-rotation-alignment") !== "viewport" && i.get("symbol-placement") !== "point",
            g = i.get("text-keep-upright"),
            x = i.get("text-size");
          for (const S of n.bucket.features) {
            const I = i.get("text-font").evaluate(S, {}, n.canonical).join(","),
              k = x.evaluate(S, {}, n.canonical),
              R = u.layoutTextSize.evaluate(S, {}, n.canonical),
              N = u.layoutIconSize.evaluate(S, {}, n.canonical),
              q = {
                horizontal: {},
                vertical: void 0
              },
              U = S.text;
            let J, ae = [0, 0];
            if (U) {
              const O = U.toString(),
                Y = i.get("text-letter-spacing").evaluate(S, {}, n.canonical) * mn,
                ge = Xh(O) ? Y : 0,
                Xe = i.get("text-anchor").evaluate(S, {}, n.canonical),
                wt = ig(t, S, n.canonical);
              if (!wt) {
                const Ct = i.get("text-radial-offset").evaluate(S, {}, n.canonical);
                ae = Ct ? rg(Xe, [Ct * mn, Jp]) : i.get("text-offset").evaluate(S, {}, n.canonical).map((zt => zt * mn))
              }
              let it = f ? "center" : i.get("text-justify").evaluate(S, {}, n.canonical);
              const ut = i.get("symbol-placement") === "point" ? i.get("text-max-width").evaluate(S, {}, n.canonical) * mn : 1 / 0,
                kt = () => {
                  n.bucket.allowVerticalPlacement && Uc(O) && (q.vertical = ud(U, n.glyphMap, n.glyphPositions, n.imagePositions, I, ut, p, Xe, "left", ge, ae, C.an.vertical, !0, R, k))
                };
              if (!f && wt) {
                const Ct = new Set;
                if (it === "auto")
                  for (let mt = 0; mt < wt.values.length; mt += 2) Ct.add(Qp(wt.values[mt]));
                else Ct.add(it);
                let zt = !1;
                for (const mt of Ct)
                  if (!q.horizontal[mt])
                    if (zt) q.horizontal[mt] = q.horizontal[0];
                    else {
                      const ir = ud(U, n.glyphMap, n.glyphPositions, n.imagePositions, I, ut, p, "center", mt, ge, ae, C.an.horizontal, !1, R, k);
                      ir && (q.horizontal[mt] = ir, zt = ir.positionedLines.length === 1)
                    } kt()
              } else {
                it === "auto" && (it = Qp(Xe));
                const Ct = ud(U, n.glyphMap, n.glyphPositions, n.imagePositions, I, ut, p, Xe, it, ge, ae, C.an.horizontal, !1, R, k);
                Ct && (q.horizontal[it] = Ct), kt(), Uc(O) && f && g && (q.vertical = ud(U, n.glyphMap, n.glyphPositions, n.imagePositions, I, ut, p, Xe, it, ge, ae, C.an.vertical, !1, R, k))
              }
            }
            let ke = !1;
            if (S.icon && S.icon.name) {
              const O = n.imageMap[S.icon.name];
              O && (J = Q0(n.imagePositions[S.icon.name], i.get("icon-offset").evaluate(S, {}, n.canonical), i.get("icon-anchor").evaluate(S, {}, n.canonical)), ke = !!O.sdf, n.bucket.sdfIcons === void 0 ? n.bucket.sdfIcons = ke : n.bucket.sdfIcons !== ke && Qt("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (O.pixelRatio !== n.bucket.pixelRatio || i.get("icon-rotate").constantOr(1) !== 0) && (n.bucket.iconsNeedLinear = !0))
            }
            const _e = ag(q.horizontal) || q.vertical;
            n.bucket.iconsInText = !!_e && _e.iconsInText, (_e || J) && _y(n.bucket, S, q, J, n.imageMap, u, R, N, ae, ke, n.canonical, n.subdivisionGranularity)
          }
          n.showCollisionBoxes && n.bucket.generateCollisionDebugBuffers()
        }, C.cH = Fp, C.cI = Ep, C.cJ = Bp, C.cK = du, C.cL = jp, C.cM = class {
          constructor(n) {
            this._marks = {
              start: [n.url, "start"].join("#"),
              end: [n.url, "end"].join("#"),
              measure: n.url.toString()
            }, performance.mark(this._marks.start)
          }
          finish() {
            performance.mark(this._marks.end);
            let n = performance.getEntriesByName(this._marks.measure);
            return n.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), n = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), n
          }
        }, C.cN = function(n, t, i, a, u) {
          return o(this, void 0, void 0, (function*() {
            if (Ve()) try {
              return yield Fr(n, t, i, a, u)
            } catch {}
            return (function(p, f, g, x, S) {
              const I = p.width,
                k = p.height;
              dr && Or || (dr = new OffscreenCanvas(I, k), Or = dr.getContext("2d", {
                willReadFrequently: !0
              })), dr.width = I, dr.height = k, Or.drawImage(p, 0, 0, I, k);
              const R = Or.getImageData(f, g, x, S);
              return Or.clearRect(0, 0, I, k), R.data
            })(n, t, i, a, u)
          }))
        }, C.cO = Um, C.cP = K, C.cQ = de, C.cR = l_, C.cS = x_, C.cT = gl, C.cU = Xa, C.ca = n => n.type === "symbol", C.cb = n => n.type === "circle", C.cc = n => n.type === "heatmap", C.cd = n => n.type === "line", C.ce = n => n.type === "fill", C.cf = n => n.type === "fill-extrusion", C.cg = n => n.type === "hillshade", C.ch = n => n.type === "color-relief", C.ci = n => n.type === "raster", C.cj = n => n.type === "background", C.ck = n => n.type === "custom", C.cl = At, C.cm = function(n, t, i) {
          const a = Be(t.x - i.x, t.y - i.y),
            u = Be(n.x - i.x, n.y - i.y);
          var p, f;
          return br(Math.atan2(a[0] * u[1] - a[1] * u[0], (p = a)[0] * (f = u)[0] + p[1] * f[1]))
        }, C.cn = cr, C.co = function(n, t) {
          return yr[t] && (n instanceof MouseEvent || n instanceof WheelEvent)
        }, C.cp = function(n, t) {
          return $t[t] && "touches" in n
        }, C.cq = function(n) {
          return $t[n] || yr[n]
        }, C.cr = function(n, t, i) {
          var a = t[0],
            u = t[1];
          return n[0] = i[0] * a + i[4] * u + i[12], n[1] = i[1] * a + i[5] * u + i[13], n
        }, C.cs = function(n, t) {
          const {
            x: i,
            y: a
          } = gu.fromLngLat(t);
          return !(n < 0 || n > 25 || a < 0 || a >= 1 || i < 0 || i >= 1)
        }, C.ct = function(n, t) {
          return n[0] = t[0], n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = t[1], n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = t[2], n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n
        }, C.cu = class extends Ya {}, C.cv = vy, C.cx = function(n) {
          return n.message === jr
        }, C.cy = se, C.cz = function(n, t) {
          j.REGISTERED_PROTOCOLS[n] = t
        }, C.d = Ze, C.e = St, C.f = n => o(void 0, void 0, void 0, (function*() {
          if (n.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
          const t = new Blob([new Uint8Array(n)], {
            type: "image/png"
          });
          try {
            return createImageBitmap(t)
          } catch (i) {
            throw new Error(`Could not load image because of ${i.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`)
          }
        })), C.g = V, C.h = n => new Promise(((t, i) => {
          const a = new Image;
          a.onload = () => {
            t(a), URL.revokeObjectURL(a.src), a.onload = null, window.requestAnimationFrame((() => {
              a.src = Dr
            }))
          }, a.onerror = () => i(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const u = new Blob([new Uint8Array(n)], {
            type: "image/png"
          });
          a.src = n.byteLength ? URL.createObjectURL(u) : Dr
        })), C.i = Dt, C.j = (n, t) => Ae(St(n, {
          type: "json"
        }), t), C.k = Ie, C.l = ze, C.m = Ae, C.n = (n, t) => Ae(St(n, {
          type: "arrayBuffer"
        }), t), C.o = function(n) {
          return new jp(n).readFields(V0, [])
        }, C.p = b_, C.q = au, C.r = Fn, C.s = zr, C.t = Xc, C.u = li, C.v = ve, C.w = Qt, C.x = pp, C.y = ko, C.z = Ws
      })), z("worker", ["./shared"], (function(C) {
        class o {
          constructor(j) {
            this.keyCache = {}, j && this.replace(j)
          }
          replace(j) {
            this._layerConfigs = {}, this._layers = {}, this.update(j, [])
          }
          update(j, V) {
            for (const se of j) {
              this._layerConfigs[se.id] = se;
              const we = this._layers[se.id] = C.bI(se);
              we._featureFilter = C.a9(we.filter), this.keyCache[se.id] && delete this.keyCache[se.id]
            }
            for (const se of V) delete this.keyCache[se], delete this._layerConfigs[se], delete this._layers[se];
            this.familiesBySource = {};
            const X = C.cB(Object.values(this._layerConfigs), this.keyCache);
            for (const se of X) {
              const we = se.map((Ie => this._layers[Ie.id])),
                Ae = we[0];
              if (Ae.visibility === "none") continue;
              const Ze = Ae.source || "";
              let Se = this.familiesBySource[Ze];
              Se || (Se = this.familiesBySource[Ze] = {});
              const Ne = Ae.sourceLayer || "_geojsonTileLayer";
              let ze = Se[Ne];
              ze || (ze = Se[Ne] = []), ze.push(we)
            }
          }
        }
        class K {
          constructor(j) {
            const V = {},
              X = [];
            for (const Ze in j) {
              const Se = j[Ze],
                Ne = V[Ze] = {};
              for (const ze in Se) {
                const Ie = Se[+ze];
                if (!Ie || Ie.bitmap.width === 0 || Ie.bitmap.height === 0) continue;
                const We = {
                  x: 0,
                  y: 0,
                  w: Ie.bitmap.width + 2,
                  h: Ie.bitmap.height + 2
                };
                X.push(We), Ne[ze] = {
                  rect: We,
                  metrics: Ie.metrics
                }
              }
            }
            const {
              w: se,
              h: we
            } = C.p(X), Ae = new C.q({
              width: se || 1,
              height: we || 1
            });
            for (const Ze in j) {
              const Se = j[Ze];
              for (const Ne in Se) {
                const ze = Se[+Ne];
                if (!ze || ze.bitmap.width === 0 || ze.bitmap.height === 0) continue;
                const Ie = V[Ze][Ne].rect;
                C.q.copy(ze.bitmap, Ae, {
                  x: 0,
                  y: 0
                }, {
                  x: Ie.x + 1,
                  y: Ie.y + 1
                }, ze.bitmap)
              }
            }
            this.image = Ae, this.positions = V
          }
        }
        C.cC("GlyphAtlas", K);
        class G {
          constructor(j) {
            this.tileID = new C.Z(j.tileID.overscaledZ, j.tileID.wrap, j.tileID.canonical.z, j.tileID.canonical.x, j.tileID.canonical.y), this.uid = j.uid, this.zoom = j.zoom, this.pixelRatio = j.pixelRatio, this.tileSize = j.tileSize, this.source = j.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = j.showCollisionBoxes, this.collectResourceTiming = !!j.collectResourceTiming, this.returnDependencies = !!j.returnDependencies, this.promoteId = j.promoteId, this.inFlightDependencies = [], this.globalState = j.globalState
          }
          parse(j, V, X, se, we) {
            return C._(this, void 0, void 0, (function*() {
              this.status = "parsing", this.data = j, this.collisionBoxArray = new C.a7;
              const Ae = new C.cD(Object.keys(j.layers).sort()),
                Ze = new C.cE(this.tileID, this.promoteId);
              Ze.bucketLayerIDs = [];
              const Se = {},
                Ne = {
                  featureIndex: Ze,
                  iconDependencies: {},
                  patternDependencies: {},
                  glyphDependencies: {},
                  availableImages: X,
                  subdivisionGranularity: we
                },
                ze = V.familiesBySource[this.source];
              for (const Cr in ze) {
                const ii = j.layers[Cr];
                if (!ii) continue;
                ii.version === 1 && C.w(`Vector tile source "${this.source}" layer "${Cr}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const Hi = Ae.encode(Cr),
                  je = [];
                for (let Ut = 0; Ut < ii.length; Ut++) {
                  const nr = ii.feature(Ut),
                    Gr = Ze.getId(nr, Cr);
                  je.push({
                    feature: nr,
                    id: Gr,
                    index: Ut,
                    sourceLayerIndex: Hi
                  })
                }
                for (const Ut of ze[Cr]) {
                  const nr = Ut[0];
                  nr.source !== this.source && C.w(`layer.source = ${nr.source} does not equal this.source = ${this.source}`), nr.minzoom && this.zoom < Math.floor(nr.minzoom) || nr.maxzoom && this.zoom >= nr.maxzoom || nr.visibility !== "none" && (ie(Ut, this.zoom, X), (Se[nr.id] = nr.createBucket({
                    index: Ze.bucketLayerIDs.length,
                    layers: Ut,
                    zoom: this.zoom,
                    pixelRatio: this.pixelRatio,
                    overscaling: this.overscaling,
                    collisionBoxArray: this.collisionBoxArray,
                    sourceLayerIndex: Hi,
                    sourceID: this.source,
                    globalState: this.globalState
                  })).populate(je, Ne, this.tileID.canonical), Ze.bucketLayerIDs.push(Ut.map((Gr => Gr.id))))
                }
              }
              const Ie = C.bM(Ne.glyphDependencies, (Cr => Object.keys(Cr).map(Number)));
              this.inFlightDependencies.forEach((Cr => Cr == null ? void 0 : Cr.abort())), this.inFlightDependencies = [];
              let We = Promise.resolve({});
              if (Object.keys(Ie).length) {
                const Cr = new AbortController;
                this.inFlightDependencies.push(Cr), We = se.sendAsync({
                  type: "GG",
                  data: {
                    stacks: Ie,
                    source: this.source,
                    tileID: this.tileID,
                    type: "glyphs"
                  }
                }, Cr)
              }
              const ve = Object.keys(Ne.iconDependencies);
              let Pt = Promise.resolve({});
              if (ve.length) {
                const Cr = new AbortController;
                this.inFlightDependencies.push(Cr), Pt = se.sendAsync({
                  type: "GI",
                  data: {
                    icons: ve,
                    source: this.source,
                    tileID: this.tileID,
                    type: "icons"
                  }
                }, Cr)
              }
              const Xt = Object.keys(Ne.patternDependencies);
              let Nt = Promise.resolve({});
              if (Xt.length) {
                const Cr = new AbortController;
                this.inFlightDependencies.push(Cr), Nt = se.sendAsync({
                  type: "GI",
                  data: {
                    icons: Xt,
                    source: this.source,
                    tileID: this.tileID,
                    type: "patterns"
                  }
                }, Cr)
              }
              const [Ht, or, ri] = yield Promise.all([We, Pt, Nt]), ti = new K(Ht), Wr = new C.cF(or, ri);
              for (const Cr in Se) {
                const ii = Se[Cr];
                ii instanceof C.a8 ? (ie(ii.layers, this.zoom, X), C.cG({
                  bucket: ii,
                  glyphMap: Ht,
                  glyphPositions: ti.positions,
                  imageMap: or,
                  imagePositions: Wr.iconPositions,
                  showCollisionBoxes: this.showCollisionBoxes,
                  canonical: this.tileID.canonical,
                  subdivisionGranularity: Ne.subdivisionGranularity
                })) : ii.hasPattern && (ii instanceof C.cH || ii instanceof C.cI || ii instanceof C.cJ) && (ie(ii.layers, this.zoom, X), ii.addFeatures(Ne, this.tileID.canonical, Wr.patternPositions))
              }
              return this.status = "done", {
                buckets: Object.values(Se).filter((Cr => !Cr.isEmpty())),
                featureIndex: Ze,
                collisionBoxArray: this.collisionBoxArray,
                glyphAtlasImage: ti.image,
                imageAtlas: Wr,
                glyphMap: this.returnDependencies ? Ht : null,
                iconMap: this.returnDependencies ? or : null,
                glyphPositions: this.returnDependencies ? ti.positions : null
              }
            }))
          }
        }

        function ie(ye, j, V) {
          const X = new C.F(j);
          for (const se of ye) se.recalculate(X, V)
        }
        class de {
          constructor(j, V, X) {
            this.actor = j, this.layerIndex = V, this.availableImages = X, this.fetching = {}, this.loading = {}, this.loaded = {}
          }
          loadVectorTile(j, V) {
            return C._(this, void 0, void 0, (function*() {
              const X = yield C.n(j.request, V);
              try {
                return {
                  vectorTile: new C.cK.VectorTile(new C.cL(X.data)),
                  rawData: X.data,
                  cacheControl: X.cacheControl,
                  expires: X.expires
                }
              } catch (se) {
                const we = new Uint8Array(X.data);
                let Ae = `Unable to parse the tile at ${j.request.url}, `;
                throw Ae += we[0] === 31 && we[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${se.message}`, new Error(Ae)
              }
            }))
          }
          loadTile(j) {
            return C._(this, void 0, void 0, (function*() {
              const V = j.uid,
                X = !!(j && j.request && j.request.collectResourceTiming) && new C.cM(j.request),
                se = new G(j);
              this.loading[V] = se;
              const we = new AbortController;
              se.abort = we;
              try {
                const Ae = yield this.loadVectorTile(j, we);
                if (delete this.loading[V], !Ae) return null;
                const Ze = Ae.rawData,
                  Se = {};
                Ae.expires && (Se.expires = Ae.expires), Ae.cacheControl && (Se.cacheControl = Ae.cacheControl);
                const Ne = {};
                if (X) {
                  const Ie = X.finish();
                  Ie && (Ne.resourceTiming = JSON.parse(JSON.stringify(Ie)))
                }
                se.vectorTile = Ae.vectorTile;
                const ze = se.parse(Ae.vectorTile, this.layerIndex, this.availableImages, this.actor, j.subdivisionGranularity);
                this.loaded[V] = se, this.fetching[V] = {
                  rawTileData: Ze,
                  cacheControl: Se,
                  resourceTiming: Ne
                };
                try {
                  const Ie = yield ze;
                  return C.e({
                    rawTileData: Ze.slice(0)
                  }, Ie, Se, Ne)
                } finally {
                  delete this.fetching[V]
                }
              } catch (Ae) {
                throw delete this.loading[V], se.status = "done", this.loaded[V] = se, Ae
              }
            }))
          }
          reloadTile(j) {
            return C._(this, void 0, void 0, (function*() {
              const V = j.uid;
              if (!this.loaded || !this.loaded[V]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const X = this.loaded[V];
              if (X.showCollisionBoxes = j.showCollisionBoxes, X.globalState = j.globalState, X.status === "parsing") {
                const se = yield X.parse(X.vectorTile, this.layerIndex, this.availableImages, this.actor, j.subdivisionGranularity);
                let we;
                if (this.fetching[V]) {
                  const {
                    rawTileData: Ae,
                    cacheControl: Ze,
                    resourceTiming: Se
                  } = this.fetching[V];
                  delete this.fetching[V], we = C.e({
                    rawTileData: Ae.slice(0)
                  }, se, Ze, Se)
                } else we = se;
                return we
              }
              if (X.status === "done" && X.vectorTile) return X.parse(X.vectorTile, this.layerIndex, this.availableImages, this.actor, j.subdivisionGranularity)
            }))
          }
          abortTile(j) {
            return C._(this, void 0, void 0, (function*() {
              const V = this.loading,
                X = j.uid;
              V && V[X] && V[X].abort && (V[X].abort.abort(), delete V[X])
            }))
          }
          removeTile(j) {
            return C._(this, void 0, void 0, (function*() {
              this.loaded && this.loaded[j.uid] && delete this.loaded[j.uid]
            }))
          }
        }
        class fe {
          constructor() {
            this.loaded = {}
          }
          loadTile(j) {
            return C._(this, void 0, void 0, (function*() {
              const {
                uid: V,
                encoding: X,
                rawImageData: se,
                redFactor: we,
                greenFactor: Ae,
                blueFactor: Ze,
                baseShift: Se
              } = j, Ne = se.width + 2, ze = se.height + 2, Ie = C.b(se) ? new C.R({
                width: Ne,
                height: ze
              }, yield C.cN(se, -1, -1, Ne, ze)) : se, We = new C.cO(V, Ie, X, we, Ae, Ze, Se);
              return this.loaded = this.loaded || {}, this.loaded[V] = We, We
            }))
          }
          removeTile(j) {
            const V = this.loaded,
              X = j.uid;
            V && V[X] && delete V[X]
          }
        }
        var W, le, Ce = (function() {
            if (le) return W;

            function ye(V, X) {
              if (V.length !== 0) {
                j(V[0], X);
                for (var se = 1; se < V.length; se++) j(V[se], !X)
              }
            }

            function j(V, X) {
              for (var se = 0, we = 0, Ae = 0, Ze = V.length, Se = Ze - 1; Ae < Ze; Se = Ae++) {
                var Ne = (V[Ae][0] - V[Se][0]) * (V[Se][1] + V[Ae][1]),
                  ze = se + Ne;
                we += Math.abs(se) >= Math.abs(Ne) ? se - ze + Ne : Ne - ze + se, se = ze
              }
              se + we >= 0 != !!X && V.reverse()
            }
            return le = 1, W = function V(X, se) {
              var we, Ae = X && X.type;
              if (Ae === "FeatureCollection")
                for (we = 0; we < X.features.length; we++) V(X.features[we], se);
              else if (Ae === "GeometryCollection")
                for (we = 0; we < X.geometries.length; we++) V(X.geometries[we], se);
              else if (Ae === "Feature") V(X.geometry, se);
              else if (Ae === "Polygon") ye(X.coordinates, se);
              else if (Ae === "MultiPolygon")
                for (we = 0; we < X.coordinates.length; we++) ye(X.coordinates[we], se);
              return X
            }
          })(),
          Me = C.cP(Ce);
        const Le = C.cK.VectorTileFeature.prototype.toGeoJSON;
        class $e {
          constructor(j) {
            this._feature = j, this.extent = C.$, this.type = j.type, this.properties = j.tags, "id" in j && !isNaN(j.id) && (this.id = parseInt(j.id, 10))
          }
          loadGeometry() {
            if (this._feature.type === 1) {
              const j = [];
              for (const V of this._feature.geometry) j.push([new C.P(V[0], V[1])]);
              return j
            } {
              const j = [];
              for (const V of this._feature.geometry) {
                const X = [];
                for (const se of V) X.push(new C.P(se[0], se[1]));
                j.push(X)
              }
              return j
            }
          }
          toGeoJSON(j, V, X) {
            return Le.call(this, j, V, X)
          }
        }
        class Oe {
          constructor(j) {
            this.layers = {
              _geojsonTileLayer: this
            }, this.name = "_geojsonTileLayer", this.extent = C.$, this.length = j.length, this._features = j
          }
          feature(j) {
            return new $e(this._features[j])
          }
        }
        var Ve, ct, nt, Ye = {
            exports: {}
          },
          dt = (function() {
            if (nt) return Ye.exports;
            nt = 1;
            var ye = C.cS(),
              j = (function() {
                if (ct) return Ve;
                ct = 1;
                var ze = C.cQ(),
                  Ie = C.cR().VectorTileFeature;

                function We(Pt, Xt) {
                  this.options = Xt || {}, this.features = Pt, this.length = Pt.length
                }

                function ve(Pt, Xt) {
                  this.id = typeof Pt.id == "number" ? Pt.id : void 0, this.type = Pt.type, this.rawGeometry = Pt.type === 1 ? [Pt.geometry] : Pt.geometry, this.properties = Pt.tags, this.extent = Xt || 4096
                }
                return Ve = We, We.prototype.feature = function(Pt) {
                  return new ve(this.features[Pt], this.options.extent)
                }, ve.prototype.loadGeometry = function() {
                  var Pt = this.rawGeometry;
                  this.geometry = [];
                  for (var Xt = 0; Xt < Pt.length; Xt++) {
                    for (var Nt = Pt[Xt], Ht = [], or = 0; or < Nt.length; or++) Ht.push(new ze(Nt[or][0], Nt[or][1]));
                    this.geometry.push(Ht)
                  }
                  return this.geometry
                }, ve.prototype.bbox = function() {
                  this.geometry || this.loadGeometry();
                  for (var Pt = this.geometry, Xt = 1 / 0, Nt = -1 / 0, Ht = 1 / 0, or = -1 / 0, ri = 0; ri < Pt.length; ri++)
                    for (var ti = Pt[ri], Wr = 0; Wr < ti.length; Wr++) {
                      var Cr = ti[Wr];
                      Xt = Math.min(Xt, Cr.x), Nt = Math.max(Nt, Cr.x), Ht = Math.min(Ht, Cr.y), or = Math.max(or, Cr.y)
                    }
                  return [Xt, Ht, Nt, or]
                }, ve.prototype.toGeoJSON = Ie.prototype.toGeoJSON, Ve
              })();

            function V(ze) {
              var Ie = new ye;
              return (function(We, ve) {
                for (var Pt in We.layers) ve.writeMessage(3, X, We.layers[Pt])
              })(ze, Ie), Ie.finish()
            }

            function X(ze, Ie) {
              var We;
              Ie.writeVarintField(15, ze.version || 1), Ie.writeStringField(1, ze.name || ""), Ie.writeVarintField(5, ze.extent || 4096);
              var ve = {
                keys: [],
                values: [],
                keycache: {},
                valuecache: {}
              };
              for (We = 0; We < ze.length; We++) ve.feature = ze.feature(We), Ie.writeMessage(2, se, ve);
              var Pt = ve.keys;
              for (We = 0; We < Pt.length; We++) Ie.writeStringField(3, Pt[We]);
              var Xt = ve.values;
              for (We = 0; We < Xt.length; We++) Ie.writeMessage(4, Ne, Xt[We])
            }

            function se(ze, Ie) {
              var We = ze.feature;
              We.id !== void 0 && Ie.writeVarintField(1, We.id), Ie.writeMessage(2, we, ze), Ie.writeVarintField(3, We.type), Ie.writeMessage(4, Se, We)
            }

            function we(ze, Ie) {
              var We = ze.feature,
                ve = ze.keys,
                Pt = ze.values,
                Xt = ze.keycache,
                Nt = ze.valuecache;
              for (var Ht in We.properties) {
                var or = We.properties[Ht],
                  ri = Xt[Ht];
                if (or !== null) {
                  ri === void 0 && (ve.push(Ht), Xt[Ht] = ri = ve.length - 1), Ie.writeVarint(ri);
                  var ti = typeof or;
                  ti !== "string" && ti !== "boolean" && ti !== "number" && (or = JSON.stringify(or));
                  var Wr = ti + ":" + or,
                    Cr = Nt[Wr];
                  Cr === void 0 && (Pt.push(or), Nt[Wr] = Cr = Pt.length - 1), Ie.writeVarint(Cr)
                }
              }
            }

            function Ae(ze, Ie) {
              return (Ie << 3) + (7 & ze)
            }

            function Ze(ze) {
              return ze << 1 ^ ze >> 31
            }

            function Se(ze, Ie) {
              for (var We = ze.loadGeometry(), ve = ze.type, Pt = 0, Xt = 0, Nt = We.length, Ht = 0; Ht < Nt; Ht++) {
                var or = We[Ht],
                  ri = 1;
                ve === 1 && (ri = or.length), Ie.writeVarint(Ae(1, ri));
                for (var ti = ve === 3 ? or.length - 1 : or.length, Wr = 0; Wr < ti; Wr++) {
                  Wr === 1 && ve !== 1 && Ie.writeVarint(Ae(2, ti - 1));
                  var Cr = or[Wr].x - Pt,
                    ii = or[Wr].y - Xt;
                  Ie.writeVarint(Ze(Cr)), Ie.writeVarint(Ze(ii)), Pt += Cr, Xt += ii
                }
                ve === 3 && Ie.writeVarint(Ae(7, 1))
              }
            }

            function Ne(ze, Ie) {
              var We = typeof ze;
              We === "string" ? Ie.writeStringField(1, ze) : We === "boolean" ? Ie.writeBooleanField(7, ze) : We === "number" && (ze % 1 != 0 ? Ie.writeDoubleField(3, ze) : ze < 0 ? Ie.writeSVarintField(6, ze) : Ie.writeVarintField(5, ze))
            }
            return Ye.exports = V, Ye.exports.fromVectorTileJs = V, Ye.exports.fromGeojsonVt = function(ze, Ie) {
              Ie = Ie || {};
              var We = {};
              for (var ve in ze) We[ve] = new j(ze[ve].features, Ie), We[ve].name = ve, We[ve].version = Ie.version, We[ve].extent = Ie.extent;
              return V({
                layers: We
              })
            }, Ye.exports.GeoJSONWrapper = j, Ye.exports
          })(),
          rt = C.cP(dt);
        const qe = {
            minZoom: 0,
            maxZoom: 16,
            minPoints: 2,
            radius: 40,
            extent: 512,
            nodeSize: 64,
            log: !1,
            generateId: !1,
            reduce: null,
            map: ye => ye
          },
          pt = Math.fround || (at = new Float32Array(1), ye => (at[0] = +ye, at[0]));
        var at;
        class ht {
          constructor(j) {
            this.options = Object.assign(Object.create(qe), j), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = []
          }
          load(j) {
            const {
              log: V,
              minZoom: X,
              maxZoom: se
            } = this.options;
            V && console.time("total time");
            const we = `prepare ${j.length} points`;
            V && console.time(we), this.points = j;
            const Ae = [];
            for (let Se = 0; Se < j.length; Se++) {
              const Ne = j[Se];
              if (!Ne.geometry) continue;
              const [ze, Ie] = Ne.geometry.coordinates, We = pt(Q(ze)), ve = pt(re(Ie));
              Ae.push(We, ve, 1 / 0, Se, -1, 1), this.options.reduce && Ae.push(0)
            }
            let Ze = this.trees[se + 1] = this._createTree(Ae);
            V && console.timeEnd(we);
            for (let Se = se; Se >= X; Se--) {
              const Ne = +Date.now();
              Ze = this.trees[Se] = this._createTree(this._cluster(Ze, Se)), V && console.log("z%d: %d clusters in %dms", Se, Ze.numItems, +Date.now() - Ne)
            }
            return V && console.timeEnd("total time"), this
          }
          getClusters(j, V) {
            let X = ((j[0] + 180) % 360 + 360) % 360 - 180;
            const se = Math.max(-90, Math.min(90, j[1]));
            let we = j[2] === 180 ? 180 : ((j[2] + 180) % 360 + 360) % 360 - 180;
            const Ae = Math.max(-90, Math.min(90, j[3]));
            if (j[2] - j[0] >= 360) X = -180, we = 180;
            else if (X > we) {
              const Ie = this.getClusters([X, se, 180, Ae], V),
                We = this.getClusters([-180, se, we, Ae], V);
              return Ie.concat(We)
            }
            const Ze = this.trees[this._limitZoom(V)],
              Se = Ze.range(Q(X), re(Ae), Q(we), re(se)),
              Ne = Ze.data,
              ze = [];
            for (const Ie of Se) {
              const We = this.stride * Ie;
              ze.push(Ne[We + 5] > 1 ? Re(Ne, We, this.clusterProps) : this.points[Ne[We + 3]])
            }
            return ze
          }
          getChildren(j) {
            const V = this._getOriginId(j),
              X = this._getOriginZoom(j),
              se = "No cluster with the specified id.",
              we = this.trees[X];
            if (!we) throw new Error(se);
            const Ae = we.data;
            if (V * this.stride >= Ae.length) throw new Error(se);
            const Ze = this.options.radius / (this.options.extent * Math.pow(2, X - 1)),
              Se = we.within(Ae[V * this.stride], Ae[V * this.stride + 1], Ze),
              Ne = [];
            for (const ze of Se) {
              const Ie = ze * this.stride;
              Ae[Ie + 4] === j && Ne.push(Ae[Ie + 5] > 1 ? Re(Ae, Ie, this.clusterProps) : this.points[Ae[Ie + 3]])
            }
            if (Ne.length === 0) throw new Error(se);
            return Ne
          }
          getLeaves(j, V, X) {
            const se = [];
            return this._appendLeaves(se, j, V = V || 10, X = X || 0, 0), se
          }
          getTile(j, V, X) {
            const se = this.trees[this._limitZoom(j)],
              we = Math.pow(2, j),
              {
                extent: Ae,
                radius: Ze
              } = this.options,
              Se = Ze / Ae,
              Ne = (X - Se) / we,
              ze = (X + 1 + Se) / we,
              Ie = {
                features: []
              };
            return this._addTileFeatures(se.range((V - Se) / we, Ne, (V + 1 + Se) / we, ze), se.data, V, X, we, Ie), V === 0 && this._addTileFeatures(se.range(1 - Se / we, Ne, 1, ze), se.data, we, X, we, Ie), V === we - 1 && this._addTileFeatures(se.range(0, Ne, Se / we, ze), se.data, -1, X, we, Ie), Ie.features.length ? Ie : null
          }
          getClusterExpansionZoom(j) {
            let V = this._getOriginZoom(j) - 1;
            for (; V <= this.options.maxZoom;) {
              const X = this.getChildren(j);
              if (V++, X.length !== 1) break;
              j = X[0].properties.cluster_id
            }
            return V
          }
          _appendLeaves(j, V, X, se, we) {
            const Ae = this.getChildren(V);
            for (const Ze of Ae) {
              const Se = Ze.properties;
              if (Se && Se.cluster ? we + Se.point_count <= se ? we += Se.point_count : we = this._appendLeaves(j, Se.cluster_id, X, se, we) : we < se ? we++ : j.push(Ze), j.length === X) break
            }
            return we
          }
          _createTree(j) {
            const V = new C.aH(j.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let X = 0; X < j.length; X += this.stride) V.add(j[X], j[X + 1]);
            return V.finish(), V.data = j, V
          }
          _addTileFeatures(j, V, X, se, we, Ae) {
            for (const Ze of j) {
              const Se = Ze * this.stride,
                Ne = V[Se + 5] > 1;
              let ze, Ie, We;
              if (Ne) ze = xt(V, Se, this.clusterProps), Ie = V[Se], We = V[Se + 1];
              else {
                const Xt = this.points[V[Se + 3]];
                ze = Xt.properties;
                const [Nt, Ht] = Xt.geometry.coordinates;
                Ie = Q(Nt), We = re(Ht)
              }
              const ve = {
                type: 1,
                geometry: [
                  [Math.round(this.options.extent * (Ie * we - X)), Math.round(this.options.extent * (We * we - se))]
                ],
                tags: ze
              };
              let Pt;
              Pt = Ne || this.options.generateId ? V[Se + 3] : this.points[V[Se + 3]].id, Pt !== void 0 && (ve.id = Pt), Ae.features.push(ve)
            }
          }
          _limitZoom(j) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+j), this.options.maxZoom + 1))
          }
          _cluster(j, V) {
            const {
              radius: X,
              extent: se,
              reduce: we,
              minPoints: Ae
            } = this.options, Ze = X / (se * Math.pow(2, V)), Se = j.data, Ne = [], ze = this.stride;
            for (let Ie = 0; Ie < Se.length; Ie += ze) {
              if (Se[Ie + 2] <= V) continue;
              Se[Ie + 2] = V;
              const We = Se[Ie],
                ve = Se[Ie + 1],
                Pt = j.within(Se[Ie], Se[Ie + 1], Ze),
                Xt = Se[Ie + 5];
              let Nt = Xt;
              for (const Ht of Pt) {
                const or = Ht * ze;
                Se[or + 2] > V && (Nt += Se[or + 5])
              }
              if (Nt > Xt && Nt >= Ae) {
                let Ht, or = We * Xt,
                  ri = ve * Xt,
                  ti = -1;
                const Wr = (Ie / ze << 5) + (V + 1) + this.points.length;
                for (const Cr of Pt) {
                  const ii = Cr * ze;
                  if (Se[ii + 2] <= V) continue;
                  Se[ii + 2] = V;
                  const Hi = Se[ii + 5];
                  or += Se[ii] * Hi, ri += Se[ii + 1] * Hi, Se[ii + 4] = Wr, we && (Ht || (Ht = this._map(Se, Ie, !0), ti = this.clusterProps.length, this.clusterProps.push(Ht)), we(Ht, this._map(Se, ii)))
                }
                Se[Ie + 4] = Wr, Ne.push(or / Nt, ri / Nt, 1 / 0, Wr, -1, Nt), we && Ne.push(ti)
              } else {
                for (let Ht = 0; Ht < ze; Ht++) Ne.push(Se[Ie + Ht]);
                if (Nt > 1)
                  for (const Ht of Pt) {
                    const or = Ht * ze;
                    if (!(Se[or + 2] <= V)) {
                      Se[or + 2] = V;
                      for (let ri = 0; ri < ze; ri++) Ne.push(Se[or + ri])
                    }
                  }
              }
            }
            return Ne
          }
          _getOriginId(j) {
            return j - this.points.length >> 5
          }
          _getOriginZoom(j) {
            return (j - this.points.length) % 32
          }
          _map(j, V, X) {
            if (j[V + 5] > 1) {
              const Ae = this.clusterProps[j[V + 6]];
              return X ? Object.assign({}, Ae) : Ae
            }
            const se = this.points[j[V + 3]].properties,
              we = this.options.map(se);
            return X && we === se ? Object.assign({}, we) : we
          }
        }

        function Re(ye, j, V) {
          return {
            type: "Feature",
            id: ye[j + 3],
            properties: xt(ye, j, V),
            geometry: {
              type: "Point",
              coordinates: [(X = ye[j], 360 * (X - .5)), xe(ye[j + 1])]
            }
          };
          var X
        }

        function xt(ye, j, V) {
          const X = ye[j + 5],
            se = X >= 1e4 ? `${Math.round(X/1e3)}k` : X >= 1e3 ? Math.round(X / 100) / 10 + "k" : X,
            we = ye[j + 6],
            Ae = we === -1 ? {} : Object.assign({}, V[we]);
          return Object.assign(Ae, {
            cluster: !0,
            cluster_id: ye[j + 3],
            point_count: X,
            point_count_abbreviated: se
          })
        }

        function Q(ye) {
          return ye / 360 + .5
        }

        function re(ye) {
          const j = Math.sin(ye * Math.PI / 180),
            V = .5 - .25 * Math.log((1 + j) / (1 - j)) / Math.PI;
          return V < 0 ? 0 : V > 1 ? 1 : V
        }

        function xe(ye) {
          const j = (180 - 360 * ye) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(j)) / Math.PI - 90
        }

        function ce(ye, j, V, X) {
          let se = X;
          const we = j + (V - j >> 1);
          let Ae, Ze = V - j;
          const Se = ye[j],
            Ne = ye[j + 1],
            ze = ye[V],
            Ie = ye[V + 1];
          for (let We = j + 3; We < V; We += 3) {
            const ve = Ee(ye[We], ye[We + 1], Se, Ne, ze, Ie);
            if (ve > se) Ae = We, se = ve;
            else if (ve === se) {
              const Pt = Math.abs(We - we);
              Pt < Ze && (Ae = We, Ze = Pt)
            }
          }
          se > X && (Ae - j > 3 && ce(ye, j, Ae, X), ye[Ae + 2] = se, V - Ae > 3 && ce(ye, Ae, V, X))
        }

        function Ee(ye, j, V, X, se, we) {
          let Ae = se - V,
            Ze = we - X;
          if (Ae !== 0 || Ze !== 0) {
            const Se = ((ye - V) * Ae + (j - X) * Ze) / (Ae * Ae + Ze * Ze);
            Se > 1 ? (V = se, X = we) : Se > 0 && (V += Ae * Se, X += Ze * Se)
          }
          return Ae = ye - V, Ze = j - X, Ae * Ae + Ze * Ze
        }

        function Be(ye, j, V, X) {
          const se = {
            id: ye ?? null,
            type: j,
            geometry: V,
            tags: X,
            minX: 1 / 0,
            minY: 1 / 0,
            maxX: -1 / 0,
            maxY: -1 / 0
          };
          if (j === "Point" || j === "MultiPoint" || j === "LineString") Ke(se, V);
          else if (j === "Polygon") Ke(se, V[0]);
          else if (j === "MultiLineString")
            for (const we of V) Ke(se, we);
          else if (j === "MultiPolygon")
            for (const we of V) Ke(se, we[0]);
          return se
        }

        function Ke(ye, j) {
          for (let V = 0; V < j.length; V += 3) ye.minX = Math.min(ye.minX, j[V]), ye.minY = Math.min(ye.minY, j[V + 1]), ye.maxX = Math.max(ye.maxX, j[V]), ye.maxY = Math.max(ye.maxY, j[V + 1])
        }

        function tt(ye, j, V, X) {
          if (!j.geometry) return;
          const se = j.geometry.coordinates;
          if (se && se.length === 0) return;
          const we = j.geometry.type,
            Ae = Math.pow(V.tolerance / ((1 << V.maxZoom) * V.extent), 2);
          let Ze = [],
            Se = j.id;
          if (V.promoteId ? Se = j.properties[V.promoteId] : V.generateId && (Se = X || 0), we === "Point") ot(se, Ze);
          else if (we === "MultiPoint")
            for (const Ne of se) ot(Ne, Ze);
          else if (we === "LineString") ft(se, Ze, Ae, !1);
          else if (we === "MultiLineString") {
            if (V.lineMetrics) {
              for (const Ne of se) Ze = [], ft(Ne, Ze, Ae, !1), ye.push(Be(Se, "LineString", Ze, j.properties));
              return
            }
            Bt(se, Ze, Ae, !1)
          } else if (we === "Polygon") Bt(se, Ze, Ae, !0);
          else {
            if (we !== "MultiPolygon") {
              if (we === "GeometryCollection") {
                for (const Ne of j.geometry.geometries) tt(ye, {
                  id: Se,
                  geometry: Ne,
                  properties: j.properties
                }, V, X);
                return
              }
              throw new Error("Input data is not a valid GeoJSON object.")
            }
            for (const Ne of se) {
              const ze = [];
              Bt(Ne, ze, Ae, !0), Ze.push(ze)
            }
          }
          ye.push(Be(Se, we, Ze, j.properties))
        }

        function ot(ye, j) {
          j.push(At(ye[0]), cr(ye[1]), 0)
        }

        function ft(ye, j, V, X) {
          let se, we, Ae = 0;
          for (let Se = 0; Se < ye.length; Se++) {
            const Ne = At(ye[Se][0]),
              ze = cr(ye[Se][1]);
            j.push(Ne, ze, 0), Se > 0 && (Ae += X ? (se * ze - Ne * we) / 2 : Math.sqrt(Math.pow(Ne - se, 2) + Math.pow(ze - we, 2))), se = Ne, we = ze
          }
          const Ze = j.length - 3;
          j[2] = 1, ce(j, 0, Ze, V), j[Ze + 2] = 1, j.size = Math.abs(Ae), j.start = 0, j.end = j.size
        }

        function Bt(ye, j, V, X) {
          for (let se = 0; se < ye.length; se++) {
            const we = [];
            ft(ye[se], we, V, X), j.push(we)
          }
        }

        function At(ye) {
          return ye / 360 + .5
        }

        function cr(ye) {
          const j = Math.sin(ye * Math.PI / 180),
            V = .5 - .25 * Math.log((1 + j) / (1 - j)) / Math.PI;
          return V < 0 ? 0 : V > 1 ? 1 : V
        }

        function Mt(ye, j, V, X, se, we, Ae, Ze) {
          if (X /= j, we >= (V /= j) && Ae < X) return ye;
          if (Ae < V || we >= X) return null;
          const Se = [];
          for (const Ne of ye) {
            const ze = Ne.geometry;
            let Ie = Ne.type;
            const We = se === 0 ? Ne.minX : Ne.minY,
              ve = se === 0 ? Ne.maxX : Ne.maxY;
            if (We >= V && ve < X) {
              Se.push(Ne);
              continue
            }
            if (ve < V || We >= X) continue;
            let Pt = [];
            if (Ie === "Point" || Ie === "MultiPoint") yt(ze, Pt, V, X, se);
            else if (Ie === "LineString") St(ze, Pt, V, X, se, !1, Ze.lineMetrics);
            else if (Ie === "MultiLineString") Lt(ze, Pt, V, X, se, !1);
            else if (Ie === "Polygon") Lt(ze, Pt, V, X, se, !0);
            else if (Ie === "MultiPolygon")
              for (const Xt of ze) {
                const Nt = [];
                Lt(Xt, Nt, V, X, se, !0), Nt.length && Pt.push(Nt)
              }
            if (Pt.length) {
              if (Ze.lineMetrics && Ie === "LineString") {
                for (const Xt of Pt) Se.push(Be(Ne.id, Ie, Xt, Ne.tags));
                continue
              }
              Ie !== "LineString" && Ie !== "MultiLineString" || (Pt.length === 1 ? (Ie = "LineString", Pt = Pt[0]) : Ie = "MultiLineString"), Ie !== "Point" && Ie !== "MultiPoint" || (Ie = Pt.length === 3 ? "Point" : "MultiPoint"), Se.push(Be(Ne.id, Ie, Pt, Ne.tags))
            }
          }
          return Se.length ? Se : null
        }

        function yt(ye, j, V, X, se) {
          for (let we = 0; we < ye.length; we += 3) {
            const Ae = ye[we + se];
            Ae >= V && Ae <= X && Gt(j, ye[we], ye[we + 1], ye[we + 2])
          }
        }

        function St(ye, j, V, X, se, we, Ae) {
          let Ze = jt(ye);
          const Se = se === 0 ? gr : ur;
          let Ne, ze, Ie = ye.start;
          for (let Nt = 0; Nt < ye.length - 3; Nt += 3) {
            const Ht = ye[Nt],
              or = ye[Nt + 1],
              ri = ye[Nt + 2],
              ti = ye[Nt + 3],
              Wr = ye[Nt + 4],
              Cr = se === 0 ? Ht : or,
              ii = se === 0 ? ti : Wr;
            let Hi = !1;
            Ae && (Ne = Math.sqrt(Math.pow(Ht - ti, 2) + Math.pow(or - Wr, 2))), Cr < V ? ii > V && (ze = Se(Ze, Ht, or, ti, Wr, V), Ae && (Ze.start = Ie + Ne * ze)) : Cr > X ? ii < X && (ze = Se(Ze, Ht, or, ti, Wr, X), Ae && (Ze.start = Ie + Ne * ze)) : Gt(Ze, Ht, or, ri), ii < V && Cr >= V && (ze = Se(Ze, Ht, or, ti, Wr, V), Hi = !0), ii > X && Cr <= X && (ze = Se(Ze, Ht, or, ti, Wr, X), Hi = !0), !we && Hi && (Ae && (Ze.end = Ie + Ne * ze), j.push(Ze), Ze = jt(ye)), Ae && (Ie += Ne)
          }
          let We = ye.length - 3;
          const ve = ye[We],
            Pt = ye[We + 1],
            Xt = se === 0 ? ve : Pt;
          Xt >= V && Xt <= X && Gt(Ze, ve, Pt, ye[We + 2]), We = Ze.length - 3, we && We >= 3 && (Ze[We] !== Ze[0] || Ze[We + 1] !== Ze[1]) && Gt(Ze, Ze[0], Ze[1], Ze[2]), Ze.length && j.push(Ze)
        }

        function jt(ye) {
          const j = [];
          return j.size = ye.size, j.start = ye.start, j.end = ye.end, j
        }

        function Lt(ye, j, V, X, se, we) {
          for (const Ae of ye) St(Ae, j, V, X, se, we, !1)
        }

        function Gt(ye, j, V, X) {
          ye.push(j, V, X)
        }

        function gr(ye, j, V, X, se, we) {
          const Ae = (we - j) / (X - j);
          return Gt(ye, we, V + (se - V) * Ae, 1), Ae
        }

        function ur(ye, j, V, X, se, we) {
          const Ae = (we - V) / (se - V);
          return Gt(ye, j + (X - j) * Ae, we, 1), Ae
        }

        function Qt(ye, j) {
          const V = [];
          for (let X = 0; X < ye.length; X++) {
            const se = ye[X],
              we = se.type;
            let Ae;
            if (we === "Point" || we === "MultiPoint" || we === "LineString") Ae = er(se.geometry, j);
            else if (we === "MultiLineString" || we === "Polygon") {
              Ae = [];
              for (const Ze of se.geometry) Ae.push(er(Ze, j))
            } else if (we === "MultiPolygon") {
              Ae = [];
              for (const Ze of se.geometry) {
                const Se = [];
                for (const Ne of Ze) Se.push(er(Ne, j));
                Ae.push(Se)
              }
            }
            V.push(Be(se.id, we, Ae, se.tags))
          }
          return V
        }

        function er(ye, j) {
          const V = [];
          V.size = ye.size, ye.start !== void 0 && (V.start = ye.start, V.end = ye.end);
          for (let X = 0; X < ye.length; X += 3) V.push(ye[X] + j, ye[X + 1], ye[X + 2]);
          return V
        }

        function Dt(ye, j) {
          if (ye.transformed) return ye;
          const V = 1 << ye.z,
            X = ye.x,
            se = ye.y;
          for (const we of ye.features) {
            const Ae = we.geometry,
              Ze = we.type;
            if (we.geometry = [], Ze === 1)
              for (let Se = 0; Se < Ae.length; Se += 2) we.geometry.push(Ir(Ae[Se], Ae[Se + 1], j, V, X, se));
            else
              for (let Se = 0; Se < Ae.length; Se++) {
                const Ne = [];
                for (let ze = 0; ze < Ae[Se].length; ze += 2) Ne.push(Ir(Ae[Se][ze], Ae[Se][ze + 1], j, V, X, se));
                we.geometry.push(Ne)
              }
          }
          return ye.transformed = !0, ye
        }

        function Ir(ye, j, V, X, se, we) {
          return [Math.round(V * (ye * X - se)), Math.round(V * (j * X - we))]
        }

        function Tr(ye, j, V, X, se) {
          const we = j === se.maxZoom ? 0 : se.tolerance / ((1 << j) * se.extent),
            Ae = {
              features: [],
              numPoints: 0,
              numSimplified: 0,
              numFeatures: ye.length,
              source: null,
              x: V,
              y: X,
              z: j,
              transformed: !1,
              minX: 2,
              minY: 1,
              maxX: -1,
              maxY: 0
            };
          for (const Ze of ye) Dr(Ae, Ze, we, se);
          return Ae
        }

        function Dr(ye, j, V, X) {
          const se = j.geometry,
            we = j.type,
            Ae = [];
          if (ye.minX = Math.min(ye.minX, j.minX), ye.minY = Math.min(ye.minY, j.minY), ye.maxX = Math.max(ye.maxX, j.maxX), ye.maxY = Math.max(ye.maxY, j.maxY), we === "Point" || we === "MultiPoint")
            for (let Ze = 0; Ze < se.length; Ze += 3) Ae.push(se[Ze], se[Ze + 1]), ye.numPoints++, ye.numSimplified++;
          else if (we === "LineString") Fr(Ae, se, ye, V, !1, !1);
          else if (we === "MultiLineString" || we === "Polygon")
            for (let Ze = 0; Ze < se.length; Ze++) Fr(Ae, se[Ze], ye, V, we === "Polygon", Ze === 0);
          else if (we === "MultiPolygon")
            for (let Ze = 0; Ze < se.length; Ze++) {
              const Se = se[Ze];
              for (let Ne = 0; Ne < Se.length; Ne++) Fr(Ae, Se[Ne], ye, V, !0, Ne === 0)
            }
          if (Ae.length) {
            let Ze = j.tags || null;
            if (we === "LineString" && X.lineMetrics) {
              Ze = {};
              for (const Ne in j.tags) Ze[Ne] = j.tags[Ne];
              Ze.mapbox_clip_start = se.start / se.size, Ze.mapbox_clip_end = se.end / se.size
            }
            const Se = {
              geometry: Ae,
              type: we === "Polygon" || we === "MultiPolygon" ? 3 : we === "LineString" || we === "MultiLineString" ? 2 : 1,
              tags: Ze
            };
            j.id !== null && (Se.id = j.id), ye.features.push(Se)
          }
        }

        function Fr(ye, j, V, X, se, we) {
          const Ae = X * X;
          if (X > 0 && j.size < (se ? Ae : X)) return void(V.numPoints += j.length / 3);
          const Ze = [];
          for (let Se = 0; Se < j.length; Se += 3)(X === 0 || j[Se + 2] > Ae) && (V.numSimplified++, Ze.push(j[Se], j[Se + 1])), V.numPoints++;
          se && (function(Se, Ne) {
            let ze = 0;
            for (let Ie = 0, We = Se.length, ve = We - 2; Ie < We; ve = Ie, Ie += 2) ze += (Se[Ie] - Se[ve]) * (Se[Ie + 1] + Se[ve + 1]);
            if (ze > 0 === Ne)
              for (let Ie = 0, We = Se.length; Ie < We / 2; Ie += 2) {
                const ve = Se[Ie],
                  Pt = Se[Ie + 1];
                Se[Ie] = Se[We - 2 - Ie], Se[Ie + 1] = Se[We - 1 - Ie], Se[We - 2 - Ie] = ve, Se[We - 1 - Ie] = Pt
              }
          })(Ze, we), ye.push(Ze)
        }
        const dr = {
          maxZoom: 14,
          indexMaxZoom: 5,
          indexMaxPoints: 1e5,
          tolerance: 3,
          extent: 4096,
          buffer: 64,
          lineMetrics: !1,
          promoteId: null,
          generateId: !1,
          debug: 0
        };
        class Or {
          constructor(j, V) {
            const X = (V = this.options = (function(we, Ae) {
              for (const Ze in Ae) we[Ze] = Ae[Ze];
              return we
            })(Object.create(dr), V)).debug;
            if (X && console.time("preprocess data"), V.maxZoom < 0 || V.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (V.promoteId && V.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let se = (function(we, Ae) {
              const Ze = [];
              if (we.type === "FeatureCollection")
                for (let Se = 0; Se < we.features.length; Se++) tt(Ze, we.features[Se], Ae, Se);
              else tt(Ze, we.type === "Feature" ? we : {
                geometry: we
              }, Ae);
              return Ze
            })(j, V);
            this.tiles = {}, this.tileCoords = [], X && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", V.indexMaxZoom, V.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), se = (function(we, Ae) {
              const Ze = Ae.buffer / Ae.extent;
              let Se = we;
              const Ne = Mt(we, 1, -1 - Ze, Ze, 0, -1, 2, Ae),
                ze = Mt(we, 1, 1 - Ze, 2 + Ze, 0, -1, 2, Ae);
              return (Ne || ze) && (Se = Mt(we, 1, -Ze, 1 + Ze, 0, -1, 2, Ae) || [], Ne && (Se = Qt(Ne, 1).concat(Se)), ze && (Se = Se.concat(Qt(ze, -1)))), Se
            })(se, V), se.length && this.splitTile(se, 0, 0, 0), X && (se.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)))
          }
          splitTile(j, V, X, se, we, Ae, Ze) {
            const Se = [j, V, X, se],
              Ne = this.options,
              ze = Ne.debug;
            for (; Se.length;) {
              se = Se.pop(), X = Se.pop(), V = Se.pop(), j = Se.pop();
              const Ie = 1 << V,
                We = zr(V, X, se);
              let ve = this.tiles[We];
              if (!ve && (ze > 1 && console.time("creation"), ve = this.tiles[We] = Tr(j, V, X, se, Ne), this.tileCoords.push({
                  z: V,
                  x: X,
                  y: se
                }), ze)) {
                ze > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", V, X, se, ve.numFeatures, ve.numPoints, ve.numSimplified), console.timeEnd("creation"));
                const Hi = `z${V}`;
                this.stats[Hi] = (this.stats[Hi] || 0) + 1, this.total++
              }
              if (ve.source = j, we == null) {
                if (V === Ne.indexMaxZoom || ve.numPoints <= Ne.indexMaxPoints) continue
              } else {
                if (V === Ne.maxZoom || V === we) continue;
                if (we != null) {
                  const Hi = we - V;
                  if (X !== Ae >> Hi || se !== Ze >> Hi) continue
                }
              }
              if (ve.source = null, j.length === 0) continue;
              ze > 1 && console.time("clipping");
              const Pt = .5 * Ne.buffer / Ne.extent,
                Xt = .5 - Pt,
                Nt = .5 + Pt,
                Ht = 1 + Pt;
              let or = null,
                ri = null,
                ti = null,
                Wr = null,
                Cr = Mt(j, Ie, X - Pt, X + Nt, 0, ve.minX, ve.maxX, Ne),
                ii = Mt(j, Ie, X + Xt, X + Ht, 0, ve.minX, ve.maxX, Ne);
              j = null, Cr && (or = Mt(Cr, Ie, se - Pt, se + Nt, 1, ve.minY, ve.maxY, Ne), ri = Mt(Cr, Ie, se + Xt, se + Ht, 1, ve.minY, ve.maxY, Ne), Cr = null), ii && (ti = Mt(ii, Ie, se - Pt, se + Nt, 1, ve.minY, ve.maxY, Ne), Wr = Mt(ii, Ie, se + Xt, se + Ht, 1, ve.minY, ve.maxY, Ne), ii = null), ze > 1 && console.timeEnd("clipping"), Se.push(or || [], V + 1, 2 * X, 2 * se), Se.push(ri || [], V + 1, 2 * X, 2 * se + 1), Se.push(ti || [], V + 1, 2 * X + 1, 2 * se), Se.push(Wr || [], V + 1, 2 * X + 1, 2 * se + 1)
            }
          }
          getTile(j, V, X) {
            j = +j, V = +V, X = +X;
            const se = this.options,
              {
                extent: we,
                debug: Ae
              } = se;
            if (j < 0 || j > 24) return null;
            const Ze = 1 << j,
              Se = zr(j, V = V + Ze & Ze - 1, X);
            if (this.tiles[Se]) return Dt(this.tiles[Se], we);
            Ae > 1 && console.log("drilling down to z%d-%d-%d", j, V, X);
            let Ne, ze = j,
              Ie = V,
              We = X;
            for (; !Ne && ze > 0;) ze--, Ie >>= 1, We >>= 1, Ne = this.tiles[zr(ze, Ie, We)];
            return Ne && Ne.source ? (Ae > 1 && (console.log("found parent tile z%d-%d-%d", ze, Ie, We), console.time("drilling down")), this.splitTile(Ne.source, ze, Ie, We, j, V, X), Ae > 1 && console.timeEnd("drilling down"), this.tiles[Se] ? Dt(this.tiles[Se], we) : null) : null
          }
        }

        function zr(ye, j, V) {
          return 32 * ((1 << ye) * V + j) + ye
        }

        function tr(ye, j) {
          return j ? ye.properties[j] : ye.id
        }

        function br(ye, j) {
          if (ye == null) return !0;
          if (ye.type === "Feature") return tr(ye, j) != null;
          if (ye.type === "FeatureCollection") {
            const V = new Set;
            for (const X of ye.features) {
              const se = tr(X, j);
              if (se == null || V.has(se)) return !1;
              V.add(se)
            }
            return !0
          }
          return !1
        }

        function $t(ye, j) {
          const V = new Map;
          if (ye != null)
            if (ye.type === "Feature") V.set(tr(ye, j), ye);
            else
              for (const X of ye.features) V.set(tr(X, j), X);
          return V
        }
        class yr extends de {
          constructor() {
            super(...arguments), this._dataUpdateable = new Map
          }
          loadVectorTile(j, V) {
            return C._(this, void 0, void 0, (function*() {
              const X = j.tileID.canonical;
              if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
              const se = this._geoJSONIndex.getTile(X.z, X.x, X.y);
              if (!se) return null;
              const we = new Oe(se.features);
              let Ae = rt(we);
              return Ae.byteOffset === 0 && Ae.byteLength === Ae.buffer.byteLength || (Ae = new Uint8Array(Ae)), {
                vectorTile: we,
                rawData: Ae.buffer
              }
            }))
          }
          loadData(j) {
            return C._(this, void 0, void 0, (function*() {
              var V;
              (V = this._pendingRequest) === null || V === void 0 || V.abort();
              const X = !!(j && j.request && j.request.collectResourceTiming) && new C.cM(j.request);
              this._pendingRequest = new AbortController;
              try {
                this._pendingData = this.loadAndProcessGeoJSON(j, this._pendingRequest), this._geoJSONIndex = j.cluster ? new ht((function({
                  superclusterOptions: Ae,
                  clusterProperties: Ze
                }) {
                  if (!Ze || !Ae) return Ae;
                  const Se = {},
                    Ne = {},
                    ze = {
                      accumulated: null,
                      zoom: 0
                    },
                    Ie = {
                      properties: null
                    },
                    We = Object.keys(Ze);
                  for (const ve of We) {
                    const [Pt, Xt] = Ze[ve], Nt = C.cT(Xt), Ht = C.cT(typeof Pt == "string" ? [Pt, ["accumulated"],
                      ["get", ve]
                    ] : Pt);
                    Se[ve] = Nt.value, Ne[ve] = Ht.value
                  }
                  return Ae.map = ve => {
                    Ie.properties = ve;
                    const Pt = {};
                    for (const Xt of We) Pt[Xt] = Se[Xt].evaluate(ze, Ie);
                    return Pt
                  }, Ae.reduce = (ve, Pt) => {
                    Ie.properties = Pt;
                    for (const Xt of We) ze.accumulated = ve[Xt], ve[Xt] = Ne[Xt].evaluate(ze, Ie)
                  }, Ae
                })(j)).load((yield this._pendingData).features) : (se = yield this._pendingData, new Or(se, j.geojsonVtOptions)), this.loaded = {};
                const we = {};
                if (X) {
                  const Ae = X.finish();
                  Ae && (we.resourceTiming = {}, we.resourceTiming[j.source] = JSON.parse(JSON.stringify(Ae)))
                }
                return we
              } catch (we) {
                if (delete this._pendingRequest, C.cx(we)) return {
                  abandoned: !0
                };
                throw we
              }
              var se
            }))
          }
          getData() {
            return C._(this, void 0, void 0, (function*() {
              return this._pendingData
            }))
          }
          reloadTile(j) {
            const V = this.loaded;
            return V && V[j.uid] ? super.reloadTile(j) : this.loadTile(j)
          }
          loadAndProcessGeoJSON(j, V) {
            return C._(this, void 0, void 0, (function*() {
              let X = yield this.loadGeoJSON(j, V);
              if (delete this._pendingRequest, typeof X != "object") throw new Error(`Input data given to '${j.source}' is not a valid GeoJSON object.`);
              if (Me(X, !0), j.filter) {
                const se = C.cT(j.filter, {
                  type: "boolean",
                  "property-type": "data-driven",
                  overridable: !1,
                  transition: !1
                });
                if (se.result === "error") throw new Error(se.value.map((Ae => `${Ae.key}: ${Ae.message}`)).join(", "));
                X = {
                  type: "FeatureCollection",
                  features: X.features.filter((Ae => se.value.evaluate({
                    zoom: 0
                  }, Ae)))
                }
              }
              return X
            }))
          }
          loadGeoJSON(j, V) {
            return C._(this, void 0, void 0, (function*() {
              const {
                promoteId: X
              } = j;
              if (j.request) {
                const se = yield C.j(j.request, V);
                return this._dataUpdateable = br(se.data, X) ? $t(se.data, X) : void 0, se.data
              }
              if (typeof j.data == "string") try {
                const se = JSON.parse(j.data);
                return this._dataUpdateable = br(se, X) ? $t(se, X) : void 0, se
              } catch {
                throw new Error(`Input data given to '${j.source}' is not a valid GeoJSON object.`)
              }
              if (!j.dataDiff) throw new Error(`Input data given to '${j.source}' is not a valid GeoJSON object.`);
              if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${j.source}`);
              return (function(se, we, Ae) {
                var Ze, Se, Ne, ze;
                if (we.removeAll && se.clear(), we.remove)
                  for (const Ie of we.remove) se.delete(Ie);
                if (we.add)
                  for (const Ie of we.add) {
                    const We = tr(Ie, Ae);
                    We != null && se.set(We, Ie)
                  }
                if (we.update)
                  for (const Ie of we.update) {
                    let We = se.get(Ie.id);
                    if (We == null) continue;
                    const ve = !Ie.removeAllProperties && (((Ze = Ie.removeProperties) === null || Ze === void 0 ? void 0 : Ze.length) > 0 || ((Se = Ie.addOrUpdateProperties) === null || Se === void 0 ? void 0 : Se.length) > 0);
                    if ((Ie.newGeometry || Ie.removeAllProperties || ve) && (We = Object.assign({}, We), se.set(Ie.id, We), ve && (We.properties = Object.assign({}, We.properties))), Ie.newGeometry && (We.geometry = Ie.newGeometry), Ie.removeAllProperties) We.properties = {};
                    else if (((Ne = Ie.removeProperties) === null || Ne === void 0 ? void 0 : Ne.length) > 0)
                      for (const Pt of Ie.removeProperties) Object.prototype.hasOwnProperty.call(We.properties, Pt) && delete We.properties[Pt];
                    if (((ze = Ie.addOrUpdateProperties) === null || ze === void 0 ? void 0 : ze.length) > 0)
                      for (const {
                          key: Pt,
                          value: Xt
                        }
                        of Ie.addOrUpdateProperties) We.properties[Pt] = Xt
                  }
              })(this._dataUpdateable, j.dataDiff, X), {
                type: "FeatureCollection",
                features: Array.from(this._dataUpdateable.values())
              }
            }))
          }
          removeSource(j) {
            return C._(this, void 0, void 0, (function*() {
              this._pendingRequest && this._pendingRequest.abort()
            }))
          }
          getClusterExpansionZoom(j) {
            return this._geoJSONIndex.getClusterExpansionZoom(j.clusterId)
          }
          getClusterChildren(j) {
            return this._geoJSONIndex.getChildren(j.clusterId)
          }
          getClusterLeaves(j) {
            return this._geoJSONIndex.getLeaves(j.clusterId, j.limit, j.offset)
          }
        }
        class jr {
          constructor(j) {
            this.self = j, this.actor = new C.J(j), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (V, X) => {
              if (this.externalWorkerSourceTypes[V]) throw new Error(`Worker source with name "${V}" already registered.`);
              this.externalWorkerSourceTypes[V] = X
            }, this.self.addProtocol = C.cz, this.self.removeProtocol = C.cA, this.self.registerRTLTextPlugin = V => {
              C.cU.setMethods(V)
            }, this.actor.registerMessageHandler("LDT", ((V, X) => this._getDEMWorkerSource(V, X.source).loadTile(X))), this.actor.registerMessageHandler("RDT", ((V, X) => C._(this, void 0, void 0, (function*() {
              this._getDEMWorkerSource(V, X.source).removeTile(X)
            })))), this.actor.registerMessageHandler("GCEZ", ((V, X) => C._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(V, X.type, X.source).getClusterExpansionZoom(X)
            })))), this.actor.registerMessageHandler("GCC", ((V, X) => C._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(V, X.type, X.source).getClusterChildren(X)
            })))), this.actor.registerMessageHandler("GCL", ((V, X) => C._(this, void 0, void 0, (function*() {
              return this._getWorkerSource(V, X.type, X.source).getClusterLeaves(X)
            })))), this.actor.registerMessageHandler("LD", ((V, X) => this._getWorkerSource(V, X.type, X.source).loadData(X))), this.actor.registerMessageHandler("GD", ((V, X) => this._getWorkerSource(V, X.type, X.source).getData())), this.actor.registerMessageHandler("LT", ((V, X) => this._getWorkerSource(V, X.type, X.source).loadTile(X))), this.actor.registerMessageHandler("RT", ((V, X) => this._getWorkerSource(V, X.type, X.source).reloadTile(X))), this.actor.registerMessageHandler("AT", ((V, X) => this._getWorkerSource(V, X.type, X.source).abortTile(X))), this.actor.registerMessageHandler("RMT", ((V, X) => this._getWorkerSource(V, X.type, X.source).removeTile(X))), this.actor.registerMessageHandler("RS", ((V, X) => C._(this, void 0, void 0, (function*() {
              if (!this.workerSources[V] || !this.workerSources[V][X.type] || !this.workerSources[V][X.type][X.source]) return;
              const se = this.workerSources[V][X.type][X.source];
              delete this.workerSources[V][X.type][X.source], se.removeSource !== void 0 && se.removeSource(X)
            })))), this.actor.registerMessageHandler("RM", (V => C._(this, void 0, void 0, (function*() {
              delete this.layerIndexes[V], delete this.availableImages[V], delete this.workerSources[V], delete this.demWorkerSources[V]
            })))), this.actor.registerMessageHandler("SR", ((V, X) => C._(this, void 0, void 0, (function*() {
              this.referrer = X
            })))), this.actor.registerMessageHandler("SRPS", ((V, X) => this._syncRTLPluginState(V, X))), this.actor.registerMessageHandler("IS", ((V, X) => C._(this, void 0, void 0, (function*() {
              this.self.importScripts(X)
            })))), this.actor.registerMessageHandler("SI", ((V, X) => this._setImages(V, X))), this.actor.registerMessageHandler("UL", ((V, X) => C._(this, void 0, void 0, (function*() {
              this._getLayerIndex(V).update(X.layers, X.removedIds)
            })))), this.actor.registerMessageHandler("SL", ((V, X) => C._(this, void 0, void 0, (function*() {
              this._getLayerIndex(V).replace(X)
            }))))
          }
          _setImages(j, V) {
            return C._(this, void 0, void 0, (function*() {
              this.availableImages[j] = V;
              for (const X in this.workerSources[j]) {
                const se = this.workerSources[j][X];
                for (const we in se) se[we].availableImages = V
              }
            }))
          }
          _syncRTLPluginState(j, V) {
            return C._(this, void 0, void 0, (function*() {
              return yield C.cU.syncState(V, this.self.importScripts)
            }))
          }
          _getAvailableImages(j) {
            let V = this.availableImages[j];
            return V || (V = []), V
          }
          _getLayerIndex(j) {
            let V = this.layerIndexes[j];
            return V || (V = this.layerIndexes[j] = new o), V
          }
          _getWorkerSource(j, V, X) {
            if (this.workerSources[j] || (this.workerSources[j] = {}), this.workerSources[j][V] || (this.workerSources[j][V] = {}), !this.workerSources[j][V][X]) {
              const se = {
                sendAsync: (we, Ae) => (we.targetMapId = j, this.actor.sendAsync(we, Ae))
              };
              switch (V) {
                case "vector":
                  this.workerSources[j][V][X] = new de(se, this._getLayerIndex(j), this._getAvailableImages(j));
                  break;
                case "geojson":
                  this.workerSources[j][V][X] = new yr(se, this._getLayerIndex(j), this._getAvailableImages(j));
                  break;
                default:
                  this.workerSources[j][V][X] = new this.externalWorkerSourceTypes[V](se, this._getLayerIndex(j), this._getAvailableImages(j))
              }
            }
            return this.workerSources[j][V][X]
          }
          _getDEMWorkerSource(j, V) {
            return this.demWorkerSources[j] || (this.demWorkerSources[j] = {}), this.demWorkerSources[j][V] || (this.demWorkerSources[j][V] = new fe), this.demWorkerSources[j][V]
          }
        }
        return C.i(self) && (self.worker = new jr(self)), jr
      })), z("index", ["exports", "./shared"], (function(C, o) {
        var K = "5.6.1";

        function G() {
          var h = new o.A(4);
          return o.A != Float32Array && (h[1] = 0, h[2] = 0), h[0] = 1, h[3] = 1, h
        }
        let ie, de;
        const fe = {
          now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date),
          frame(h, e, r) {
            const s = requestAnimationFrame((d => {
                c(), e(d)
              })),
              {
                unsubscribe: c
              } = o.s(h.signal, "abort", (() => {
                c(), cancelAnimationFrame(s), r(o.c())
              }), !1)
          },
          frameAsync(h) {
            return new Promise(((e, r) => {
              this.frame(h, e, r)
            }))
          },
          getImageData(h, e = 0) {
            return this.getImageCanvasContext(h).getImageData(-e, -e, h.width + 2 * e, h.height + 2 * e)
          },
          getImageCanvasContext(h) {
            const e = window.document.createElement("canvas"),
              r = e.getContext("2d", {
                willReadFrequently: !0
              });
            if (!r) throw new Error("failed to create canvas 2d context");
            return e.width = h.width, e.height = h.height, r.drawImage(h, 0, 0, h.width, h.height), r
          },
          resolveURL: h => (ie || (ie = document.createElement("a")), ie.href = h, ie.href),
          hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4,
          get prefersReducedMotion() {
            return !!matchMedia && (de == null && (de = matchMedia("(prefers-reduced-motion: reduce)")), de.matches)
          }
        };
        class W {
          static testProp(e) {
            if (!W.docStyle) return e[0];
            for (let r = 0; r < e.length; r++)
              if (e[r] in W.docStyle) return e[r];
            return e[0]
          }
          static create(e, r, s) {
            const c = window.document.createElement(e);
            return r !== void 0 && (c.className = r), s && s.appendChild(c), c
          }
          static createNS(e, r) {
            return window.document.createElementNS(e, r)
          }
          static disableDrag() {
            W.docStyle && W.selectProp && (W.userSelect = W.docStyle[W.selectProp], W.docStyle[W.selectProp] = "none")
          }
          static enableDrag() {
            W.docStyle && W.selectProp && (W.docStyle[W.selectProp] = W.userSelect)
          }
          static setTransform(e, r) {
            e.style[W.transformProp] = r
          }
          static addEventListener(e, r, s, c = {}) {
            e.addEventListener(r, s, "passive" in c ? c : c.capture)
          }
          static removeEventListener(e, r, s, c = {}) {
            e.removeEventListener(r, s, "passive" in c ? c : c.capture)
          }
          static suppressClickInternal(e) {
            e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", W.suppressClickInternal, !0)
          }
          static suppressClick() {
            window.addEventListener("click", W.suppressClickInternal, !0), window.setTimeout((() => {
              window.removeEventListener("click", W.suppressClickInternal, !0)
            }), 0)
          }
          static getScale(e) {
            const r = e.getBoundingClientRect();
            return {
              x: r.width / e.offsetWidth || 1,
              y: r.height / e.offsetHeight || 1,
              boundingClientRect: r
            }
          }
          static getPoint(e, r, s) {
            const c = r.boundingClientRect;
            return new o.P((s.clientX - c.left) / r.x - e.clientLeft, (s.clientY - c.top) / r.y - e.clientTop)
          }
          static mousePos(e, r) {
            const s = W.getScale(e);
            return W.getPoint(e, s, r)
          }
          static touchPos(e, r) {
            const s = [],
              c = W.getScale(e);
            for (let d = 0; d < r.length; d++) s.push(W.getPoint(e, c, r[d]));
            return s
          }
          static mouseButton(e) {
            return e.button
          }
          static remove(e) {
            e.parentNode && e.parentNode.removeChild(e)
          }
          static sanitize(e) {
            const r = new DOMParser().parseFromString(e, "text/html").body || document.createElement("body"),
              s = r.querySelectorAll("script");
            for (const c of s) c.remove();
            return W.clean(r), r.innerHTML
          }
          static isPossiblyDangerous(e, r) {
            const s = r.replace(/\s+/g, "").toLowerCase();
            return !(!["src", "href", "xlink:href"].includes(e) || !s.includes("javascript:") && !s.includes("data:")) || !!e.startsWith("on") || void 0
          }
          static clean(e) {
            const r = e.children;
            for (const s of r) W.removeAttributes(s), W.clean(s)
          }
          static removeAttributes(e) {
            for (const {
                name: r,
                value: s
              }
              of e.attributes) W.isPossiblyDangerous(r, s) && e.removeAttribute(r)
          }
        }
        W.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, W.selectProp = W.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), W.transformProp = W.testProp(["transform", "WebkitTransform"]);
        const le = {
          supported: !1,
          testSupport: function(h) {
            !Le && Me && ($e ? Oe(h) : Ce = h)
          }
        };
        let Ce, Me, Le = !1,
          $e = !1;

        function Oe(h) {
          const e = h.createTexture();
          h.bindTexture(h.TEXTURE_2D, e);
          try {
            if (h.texImage2D(h.TEXTURE_2D, 0, h.RGBA, h.RGBA, h.UNSIGNED_BYTE, Me), h.isContextLost()) return;
            le.supported = !0
          } catch {}
          h.deleteTexture(e), Le = !0
        }
        var Ve;
        typeof document < "u" && (Me = document.createElement("img"), Me.onload = () => {
          Ce && Oe(Ce), Ce = null, $e = !0
        }, Me.onerror = () => {
          Le = !0, Ce = null
        }, Me.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), (function(h) {
          let e, r, s, c;
          h.resetRequestQueue = () => {
            e = [], r = 0, s = 0, c = {}
          }, h.addThrottleControl = w => {
            const P = s++;
            return c[P] = w, P
          }, h.removeThrottleControl = w => {
            delete c[w], m()
          }, h.getImage = (w, P, M = !0) => new Promise(((D, L) => {
            le.supported && (w.headers || (w.headers = {}), w.headers.accept = "image/webp,*/*"), o.e(w, {
              type: "image"
            }), e.push({
              abortController: P,
              requestParameters: w,
              supportImageRefresh: M,
              state: "queued",
              onError: B => {
                L(B)
              },
              onSuccess: B => {
                D(B)
              }
            }), m()
          }));
          const d = w => o._(this, void 0, void 0, (function*() {
              w.state = "running";
              const {
                requestParameters: P,
                supportImageRefresh: M,
                onError: D,
                onSuccess: L,
                abortController: B
              } = w, Z = M === !1 && !o.i(self) && !o.g(P.url) && (!P.headers || Object.keys(P.headers).reduce(((ne, oe) => ne && oe === "accept"), !0));
              r++;
              const te = Z ? v(P, B) : o.m(P, B);
              try {
                const ne = yield te;
                delete w.abortController, w.state = "completed", ne.data instanceof HTMLImageElement || o.b(ne.data) ? L(ne) : ne.data && L({
                  data: yield(ee = ne.data, typeof createImageBitmap == "function" ? o.f(ee) : o.h(ee)),
                  cacheControl: ne.cacheControl,
                  expires: ne.expires
                })
              } catch (ne) {
                delete w.abortController, D(ne)
              } finally {
                r--, m()
              }
              var ee
            })),
            m = () => {
              const w = (() => {
                for (const P of Object.keys(c))
                  if (c[P]()) return !0;
                return !1
              })() ? o.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : o.a.MAX_PARALLEL_IMAGE_REQUESTS;
              for (let P = r; P < w && e.length > 0; P++) {
                const M = e.shift();
                M.abortController.signal.aborted ? P-- : d(M)
              }
            },
            v = (w, P) => new Promise(((M, D) => {
              const L = new Image,
                B = w.url,
                Z = w.credentials;
              Z && Z === "include" ? L.crossOrigin = "use-credentials" : (Z && Z === "same-origin" || !o.d(B)) && (L.crossOrigin = "anonymous"), P.signal.addEventListener("abort", (() => {
                L.src = "", D(o.c())
              })), L.fetchPriority = "high", L.onload = () => {
                L.onerror = L.onload = null, M({
                  data: L
                })
              }, L.onerror = () => {
                L.onerror = L.onload = null, P.signal.aborted || D(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."))
              }, L.src = B
            }))
        })(Ve || (Ve = {})), Ve.resetRequestQueue();
        class ct {
          constructor(e) {
            this._transformRequestFn = e
          }
          transformRequest(e, r) {
            return this._transformRequestFn && this._transformRequestFn(e, r) || {
              url: e
            }
          }
          setTransformRequest(e) {
            this._transformRequestFn = e
          }
        }

        function nt(h) {
          const e = [];
          if (typeof h == "string") e.push({
            id: "default",
            url: h
          });
          else if (h && h.length > 0) {
            const r = [];
            for (const {
                id: s,
                url: c
              }
              of h) {
              const d = `${s}${c}`;
              r.indexOf(d) === -1 && (r.push(d), e.push({
                id: s,
                url: c
              }))
            }
          }
          return e
        }

        function Ye(h, e, r) {
          try {
            const s = new URL(h);
            return s.pathname += `${e}${r}`, s.toString()
          } catch {
            throw new Error(`Invalid sprite URL "${h}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`)
          }
        }

        function dt(h) {
          const {
            userImage: e
          } = h;
          return !!(e && e.render && e.render()) && (h.data.replace(new Uint8Array(e.data.buffer)), !0)
        }
        class rt extends o.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new o.R({
              width: 1,
              height: 1
            }), this.dirty = !0
          }
          isLoaded() {
            return this.loaded
          }
          setLoaded(e) {
            if (this.loaded !== e && (this.loaded = e, e)) {
              for (const {
                  ids: r,
                  promiseResolve: s
                }
                of this.requestors) s(this._getImagesForIds(r));
              this.requestors = []
            }
          }
          getImage(e) {
            const r = this.images[e];
            if (r && !r.data && r.spriteData) {
              const s = r.spriteData;
              r.data = new o.R({
                width: s.width,
                height: s.height
              }, s.context.getImageData(s.x, s.y, s.width, s.height).data), r.spriteData = null
            }
            return r
          }
          addImage(e, r) {
            if (this.images[e]) throw new Error(`Image id ${e} already exist, use updateImage instead`);
            this._validate(e, r) && (this.images[e] = r)
          }
          _validate(e, r) {
            let s = !0;
            const c = r.data || r.spriteData;
            return this._validateStretch(r.stretchX, c && c.width) || (this.fire(new o.k(new Error(`Image "${e}" has invalid "stretchX" value`))), s = !1), this._validateStretch(r.stretchY, c && c.height) || (this.fire(new o.k(new Error(`Image "${e}" has invalid "stretchY" value`))), s = !1), this._validateContent(r.content, r) || (this.fire(new o.k(new Error(`Image "${e}" has invalid "content" value`))), s = !1), s
          }
          _validateStretch(e, r) {
            if (!e) return !0;
            let s = 0;
            for (const c of e) {
              if (c[0] < s || c[1] < c[0] || r < c[1]) return !1;
              s = c[1]
            }
            return !0
          }
          _validateContent(e, r) {
            if (!e) return !0;
            if (e.length !== 4) return !1;
            const s = r.spriteData,
              c = s && s.width || r.data.width,
              d = s && s.height || r.data.height;
            return !(e[0] < 0 || c < e[0] || e[1] < 0 || d < e[1] || e[2] < 0 || c < e[2] || e[3] < 0 || d < e[3] || e[2] < e[0] || e[3] < e[1])
          }
          updateImage(e, r, s = !0) {
            const c = this.getImage(e);
            if (s && (c.data.width !== r.data.width || c.data.height !== r.data.height)) throw new Error(`size mismatch between old image (${c.data.width}x${c.data.height}) and new image (${r.data.width}x${r.data.height}).`);
            r.version = c.version + 1, this.images[e] = r, this.updatedImages[e] = !0
          }
          removeImage(e) {
            const r = this.images[e];
            delete this.images[e], delete this.patterns[e], r.userImage && r.userImage.onRemove && r.userImage.onRemove()
          }
          listImages() {
            return Object.keys(this.images)
          }
          getImages(e) {
            return new Promise(((r, s) => {
              let c = !0;
              if (!this.isLoaded())
                for (const d of e) this.images[d] || (c = !1);
              this.isLoaded() || c ? r(this._getImagesForIds(e)) : this.requestors.push({
                ids: e,
                promiseResolve: r
              })
            }))
          }
          _getImagesForIds(e) {
            const r = {};
            for (const s of e) {
              let c = this.getImage(s);
              c || (this.fire(new o.l("styleimagemissing", {
                id: s
              })), c = this.getImage(s)), c ? r[s] = {
                data: c.data.clone(),
                pixelRatio: c.pixelRatio,
                sdf: c.sdf,
                version: c.version,
                stretchX: c.stretchX,
                stretchY: c.stretchY,
                content: c.content,
                textFitWidth: c.textFitWidth,
                textFitHeight: c.textFitHeight,
                hasRenderCallback: !!(c.userImage && c.userImage.render)
              } : o.w(`Image "${s}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`)
            }
            return r
          }
          getPixelSize() {
            const {
              width: e,
              height: r
            } = this.atlasImage;
            return {
              width: e,
              height: r
            }
          }
          getPattern(e) {
            const r = this.patterns[e],
              s = this.getImage(e);
            if (!s) return null;
            if (r && r.position.version === s.version) return r.position;
            if (r) r.position.version = s.version;
            else {
              const c = {
                  w: s.data.width + 2,
                  h: s.data.height + 2,
                  x: 0,
                  y: 0
                },
                d = new o.I(c, s);
              this.patterns[e] = {
                bin: c,
                position: d
              }
            }
            return this._updatePatternAtlas(), this.patterns[e].position
          }
          bind(e) {
            const r = e.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new o.T(e, this.atlasImage, r.RGBA), this.atlasTexture.bind(r.LINEAR, r.CLAMP_TO_EDGE)
          }
          _updatePatternAtlas() {
            const e = [];
            for (const d in this.patterns) e.push(this.patterns[d].bin);
            const {
              w: r,
              h: s
            } = o.p(e), c = this.atlasImage;
            c.resize({
              width: r || 1,
              height: s || 1
            });
            for (const d in this.patterns) {
              const {
                bin: m
              } = this.patterns[d], v = m.x + 1, w = m.y + 1, P = this.getImage(d).data, M = P.width, D = P.height;
              o.R.copy(P, c, {
                x: 0,
                y: 0
              }, {
                x: v,
                y: w
              }, {
                width: M,
                height: D
              }), o.R.copy(P, c, {
                x: 0,
                y: D - 1
              }, {
                x: v,
                y: w - 1
              }, {
                width: M,
                height: 1
              }), o.R.copy(P, c, {
                x: 0,
                y: 0
              }, {
                x: v,
                y: w + D
              }, {
                width: M,
                height: 1
              }), o.R.copy(P, c, {
                x: M - 1,
                y: 0
              }, {
                x: v - 1,
                y: w
              }, {
                width: 1,
                height: D
              }), o.R.copy(P, c, {
                x: 0,
                y: 0
              }, {
                x: v + M,
                y: w
              }, {
                width: 1,
                height: D
              })
            }
            this.dirty = !0
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {}
          }
          dispatchRenderCallbacks(e) {
            for (const r of e) {
              if (this.callbackDispatchedThisFrame[r]) continue;
              this.callbackDispatchedThisFrame[r] = !0;
              const s = this.getImage(r);
              s || o.w(`Image with ID: "${r}" was not found`), dt(s) && this.updateImage(r, s)
            }
          }
        }
        const qe = 1e20;

        function pt(h, e, r, s, c, d, m, v, w) {
          for (let P = e; P < e + s; P++) at(h, r * d + P, d, c, m, v, w);
          for (let P = r; P < r + c; P++) at(h, P * d + e, 1, s, m, v, w)
        }

        function at(h, e, r, s, c, d, m) {
          d[0] = 0, m[0] = -qe, m[1] = qe, c[0] = h[e];
          for (let v = 1, w = 0, P = 0; v < s; v++) {
            c[v] = h[e + v * r];
            const M = v * v;
            do {
              const D = d[w];
              P = (c[v] - c[D] + M - D * D) / (v - D) / 2
            } while (P <= m[w] && --w > -1);
            w++, d[w] = v, m[w] = P, m[w + 1] = qe
          }
          for (let v = 0, w = 0; v < s; v++) {
            for (; m[w + 1] < v;) w++;
            const P = d[w],
              M = v - P;
            h[e + v * r] = c[P] + M * M
          }
        }
        class ht {
          constructor(e, r) {
            this.requestManager = e, this.localIdeographFontFamily = r, this.entries = {}
          }
          setURL(e) {
            this.url = e
          }
          getGlyphs(e) {
            return o._(this, void 0, void 0, (function*() {
              const r = [];
              for (const d in e)
                for (const m of e[d]) r.push(this._getAndCacheGlyphsPromise(d, m));
              const s = yield Promise.all(r), c = {};
              for (const {
                  stack: d,
                  id: m,
                  glyph: v
                }
                of s) c[d] || (c[d] = {}), c[d][m] = v && {
                id: v.id,
                bitmap: v.bitmap.clone(),
                metrics: v.metrics
              };
              return c
            }))
          }
          _getAndCacheGlyphsPromise(e, r) {
            return o._(this, void 0, void 0, (function*() {
              let s = this.entries[e];
              s || (s = this.entries[e] = {
                glyphs: {},
                requests: {},
                ranges: {}
              });
              let c = s.glyphs[r];
              if (c !== void 0) return {
                stack: e,
                id: r,
                glyph: c
              };
              if (c = this._tinySDF(s, e, r), c) return s.glyphs[r] = c, {
                stack: e,
                id: r,
                glyph: c
              };
              const d = Math.floor(r / 256);
              if (256 * d > 65535) throw new Error("glyphs > 65535 not supported");
              if (s.ranges[d]) return {
                stack: e,
                id: r,
                glyph: c
              };
              if (!this.url) throw new Error("glyphsUrl is not set");
              if (!s.requests[d]) {
                const v = ht.loadGlyphRange(e, d, this.url, this.requestManager);
                s.requests[d] = v
              }
              const m = yield s.requests[d];
              for (const v in m) this._doesCharSupportLocalGlyph(+v) || (s.glyphs[+v] = m[+v]);
              return s.ranges[d] = !0, {
                stack: e,
                id: r,
                glyph: m[r] || null
              }
            }))
          }
          _doesCharSupportLocalGlyph(e) {
            return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(e)) || o.u["CJK Unified Ideographs"](e) || o.u["Hangul Syllables"](e) || o.u.Hiragana(e) || o.u.Katakana(e) || o.u["CJK Symbols and Punctuation"](e) || o.u["Halfwidth and Fullwidth Forms"](e))
          }
          _tinySDF(e, r, s) {
            const c = this.localIdeographFontFamily;
            if (!c || !this._doesCharSupportLocalGlyph(s)) return;
            let d = e.tinySDF;
            if (!d) {
              let v = "400";
              /bold/i.test(r) ? v = "900" : /medium/i.test(r) ? v = "500" : /light/i.test(r) && (v = "200"), d = e.tinySDF = new ht.TinySDF({
                fontSize: 48,
                buffer: 6,
                radius: 16,
                cutoff: .25,
                fontFamily: c,
                fontWeight: v
              })
            }
            const m = d.draw(String.fromCharCode(s));
            return {
              id: s,
              bitmap: new o.q({
                width: m.width || 60,
                height: m.height || 60
              }, m.data),
              metrics: {
                width: m.glyphWidth / 2 || 24,
                height: m.glyphHeight / 2 || 24,
                left: m.glyphLeft / 2 + .5 || 0,
                top: m.glyphTop / 2 - 27.5 || -8,
                advance: m.glyphAdvance / 2 || 24,
                isDoubleResolution: !0
              }
            }
          }
        }
        ht.loadGlyphRange = function(h, e, r, s) {
          return o._(this, void 0, void 0, (function*() {
            const c = 256 * e,
              d = c + 255,
              m = s.transformRequest(r.replace("{fontstack}", h).replace("{range}", `${c}-${d}`), "Glyphs"),
              v = yield o.n(m, new AbortController);
            if (!v || !v.data) throw new Error(`Could not load glyph range. range: ${e}, ${c}-${d}`);
            const w = {};
            for (const P of o.o(v.data)) w[P.id] = P;
            return w
          }))
        }, ht.TinySDF = class {
          constructor({
            fontSize: h = 24,
            buffer: e = 3,
            radius: r = 8,
            cutoff: s = .25,
            fontFamily: c = "sans-serif",
            fontWeight: d = "normal",
            fontStyle: m = "normal"
          } = {}) {
            this.buffer = e, this.cutoff = s, this.radius = r;
            const v = this.size = h + 4 * e,
              w = this._createCanvas(v),
              P = this.ctx = w.getContext("2d", {
                willReadFrequently: !0
              });
            P.font = `${m} ${d} ${h}px ${c}`, P.textBaseline = "alphabetic", P.textAlign = "left", P.fillStyle = "black", this.gridOuter = new Float64Array(v * v), this.gridInner = new Float64Array(v * v), this.f = new Float64Array(v), this.z = new Float64Array(v + 1), this.v = new Uint16Array(v)
          }
          _createCanvas(h) {
            const e = document.createElement("canvas");
            return e.width = e.height = h, e
          }
          draw(h) {
            const {
              width: e,
              actualBoundingBoxAscent: r,
              actualBoundingBoxDescent: s,
              actualBoundingBoxLeft: c,
              actualBoundingBoxRight: d
            } = this.ctx.measureText(h), m = Math.ceil(r), v = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(d - c))), w = Math.min(this.size - this.buffer, m + Math.ceil(s)), P = v + 2 * this.buffer, M = w + 2 * this.buffer, D = Math.max(P * M, 0), L = new Uint8ClampedArray(D), B = {
              data: L,
              width: P,
              height: M,
              glyphWidth: v,
              glyphHeight: w,
              glyphTop: m,
              glyphLeft: 0,
              glyphAdvance: e
            };
            if (v === 0 || w === 0) return B;
            const {
              ctx: Z,
              buffer: te,
              gridInner: ee,
              gridOuter: ne
            } = this;
            Z.clearRect(te, te, v, w), Z.fillText(h, te, te + m);
            const oe = Z.getImageData(te, te, v, w);
            ne.fill(qe, 0, D), ee.fill(0, 0, D);
            for (let me = 0; me < w; me++)
              for (let ue = 0; ue < v; ue++) {
                const be = oe.data[4 * (me * v + ue) + 3] / 255;
                if (be === 0) continue;
                const Pe = (me + te) * P + ue + te;
                if (be === 1) ne[Pe] = 0, ee[Pe] = qe;
                else {
                  const pe = .5 - be;
                  ne[Pe] = pe > 0 ? pe * pe : 0, ee[Pe] = pe < 0 ? pe * pe : 0
                }
              }
            pt(ne, 0, 0, P, M, P, this.f, this.v, this.z), pt(ee, te, te, v, w, P, this.f, this.v, this.z);
            for (let me = 0; me < D; me++) {
              const ue = Math.sqrt(ne[me]) - Math.sqrt(ee[me]);
              L[me] = Math.round(255 - 255 * (ue / this.radius + this.cutoff))
            }
            return B
          }
        };
        class Re {
          constructor() {
            this.specification = o.v.light.position
          }
          possiblyEvaluate(e, r) {
            return o.B(e.expression.evaluate(r))
          }
          interpolate(e, r, s) {
            return {
              x: o.C.number(e.x, r.x, s),
              y: o.C.number(e.y, r.y, s),
              z: o.C.number(e.z, r.z, s)
            }
          }
        }
        let xt;
        class Q extends o.E {
          constructor(e) {
            super(), xt = xt || new o.r({
              anchor: new o.D(o.v.light.anchor),
              position: new Re,
              color: new o.D(o.v.light.color),
              intensity: new o.D(o.v.light.intensity)
            }), this._transitionable = new o.t(xt), this.setLight(e), this._transitioning = this._transitionable.untransitioned()
          }
          getLight() {
            return this._transitionable.serialize()
          }
          setLight(e, r = {}) {
            if (!this._validate(o.x, e, r))
              for (const s in e) {
                const c = e[s];
                s.endsWith("-transition") ? this._transitionable.setTransition(s.slice(0, -11), c) : this._transitionable.setValue(s, c)
              }
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          _validate(e, r, s) {
            return (!s || s.validate !== !1) && o.y(this, e.call(o.z, {
              value: r,
              style: {
                glyphs: !0,
                sprite: !0
              },
              styleSpec: o.v
            }))
          }
        }
        const re = new o.r({
          "sky-color": new o.D(o.v.sky["sky-color"]),
          "horizon-color": new o.D(o.v.sky["horizon-color"]),
          "fog-color": new o.D(o.v.sky["fog-color"]),
          "fog-ground-blend": new o.D(o.v.sky["fog-ground-blend"]),
          "horizon-fog-blend": new o.D(o.v.sky["horizon-fog-blend"]),
          "sky-horizon-blend": new o.D(o.v.sky["sky-horizon-blend"]),
          "atmosphere-blend": new o.D(o.v.sky["atmosphere-blend"])
        });
        class xe extends o.E {
          constructor(e) {
            super(), this._transitionable = new o.t(re), this.setSky(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new o.F(0))
          }
          setSky(e, r = {}) {
            if (!this._validate(o.G, e, r)) {
              e || (e = {
                "sky-color": "transparent",
                "horizon-color": "transparent",
                "fog-color": "transparent",
                "fog-ground-blend": 1,
                "atmosphere-blend": 0
              });
              for (const s in e) {
                const c = e[s];
                s.endsWith("-transition") ? this._transitionable.setTransition(s.slice(0, -11), c) : this._transitionable.setValue(s, c)
              }
            }
          }
          getSky() {
            return this._transitionable.serialize()
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          _validate(e, r, s = {}) {
            return (s == null ? void 0 : s.validate) !== !1 && o.y(this, e.call(o.z, o.e({
              value: r,
              style: {
                glyphs: !0,
                sprite: !0
              },
              styleSpec: o.v
            })))
          }
          calculateFogBlendOpacity(e) {
            return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1
          }
        }
        class ce {
          constructor(e, r) {
            this.width = e, this.height = r, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {}
          }
          getDash(e, r) {
            const s = e.join(",") + String(r);
            return this.dashEntry[s] || (this.dashEntry[s] = this.addDash(e, r)), this.dashEntry[s]
          }
          getDashRanges(e, r, s) {
            const c = [];
            let d = e.length % 2 == 1 ? -e[e.length - 1] * s : 0,
              m = e[0] * s,
              v = !0;
            c.push({
              left: d,
              right: m,
              isDash: v,
              zeroLength: e[0] === 0
            });
            let w = e[0];
            for (let P = 1; P < e.length; P++) {
              v = !v;
              const M = e[P];
              d = w * s, w += M, m = w * s, c.push({
                left: d,
                right: m,
                isDash: v,
                zeroLength: M === 0
              })
            }
            return c
          }
          addRoundDash(e, r, s) {
            const c = r / 2;
            for (let d = -s; d <= s; d++) {
              const m = this.width * (this.nextRow + s + d);
              let v = 0,
                w = e[v];
              for (let P = 0; P < this.width; P++) {
                P / w.right > 1 && (w = e[++v]);
                const M = Math.abs(P - w.left),
                  D = Math.abs(P - w.right),
                  L = Math.min(M, D);
                let B;
                const Z = d / s * (c + 1);
                if (w.isDash) {
                  const te = c - Math.abs(Z);
                  B = Math.sqrt(L * L + te * te)
                } else B = c - Math.sqrt(L * L + Z * Z);
                this.data[m + P] = Math.max(0, Math.min(255, B + 128))
              }
            }
          }
          addRegularDash(e) {
            for (let v = e.length - 1; v >= 0; --v) {
              const w = e[v],
                P = e[v + 1];
              w.zeroLength ? e.splice(v, 1) : P && P.isDash === w.isDash && (P.left = w.left, e.splice(v, 1))
            }
            const r = e[0],
              s = e[e.length - 1];
            r.isDash === s.isDash && (r.left = s.left - this.width, s.right = r.right + this.width);
            const c = this.width * this.nextRow;
            let d = 0,
              m = e[d];
            for (let v = 0; v < this.width; v++) {
              v / m.right > 1 && (m = e[++d]);
              const w = Math.abs(v - m.left),
                P = Math.abs(v - m.right),
                M = Math.min(w, P);
              this.data[c + v] = Math.max(0, Math.min(255, (m.isDash ? M : -M) + 128))
            }
          }
          addDash(e, r) {
            const s = r ? 7 : 0,
              c = 2 * s + 1;
            if (this.nextRow + c > this.height) return o.w("LineAtlas out of space"), null;
            let d = 0;
            for (let v = 0; v < e.length; v++) d += e[v];
            if (d !== 0) {
              const v = this.width / d,
                w = this.getDashRanges(e, this.width, v);
              r ? this.addRoundDash(w, v, s) : this.addRegularDash(w)
            }
            const m = {
              y: (this.nextRow + s + .5) / this.height,
              height: 2 * s / this.height,
              width: d
            };
            return this.nextRow += c, this.dirty = !0, m
          }
          bind(e) {
            const r = e.gl;
            this.texture ? (r.bindTexture(r.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, r.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, this.width, this.height, r.ALPHA, r.UNSIGNED_BYTE, this.data))) : (this.texture = r.createTexture(), r.bindTexture(r.TEXTURE_2D, this.texture), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.REPEAT), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.REPEAT), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR), r.texImage2D(r.TEXTURE_2D, 0, r.ALPHA, this.width, this.height, 0, r.ALPHA, r.UNSIGNED_BYTE, this.data))
          }
        }
        const Ee = "maplibre_preloaded_worker_pool";
        class Be {
          constructor() {
            this.active = {}
          }
          acquire(e) {
            if (!this.workers)
              for (this.workers = []; this.workers.length < Be.workerCount;) this.workers.push(new Worker(o.a.WORKER_URL));
            return this.active[e] = !0, this.workers.slice()
          }
          release(e) {
            delete this.active[e], this.numActive() === 0 && (this.workers.forEach((r => {
              r.terminate()
            })), this.workers = null)
          }
          isPreloaded() {
            return !!this.active[Ee]
          }
          numActive() {
            return Object.keys(this.active).length
          }
        }
        const Ke = Math.floor(fe.hardwareConcurrency / 2);
        let tt, ot;

        function ft() {
          return tt || (tt = new Be), tt
        }
        Be.workerCount = o.H(globalThis) ? Math.max(Math.min(Ke, 3), 1) : 1;
        class Bt {
          constructor(e, r) {
            this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = r;
            const s = this.workerPool.acquire(r);
            for (let c = 0; c < s.length; c++) {
              const d = new o.J(s[c], r);
              d.name = `Worker ${c}`, this.actors.push(d)
            }
            if (!this.actors.length) throw new Error("No actors found")
          }
          broadcast(e, r) {
            const s = [];
            for (const c of this.actors) s.push(c.sendAsync({
              type: e,
              data: r
            }));
            return Promise.all(s)
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor]
          }
          remove(e = !0) {
            this.actors.forEach((r => {
              r.remove()
            })), this.actors = [], e && this.workerPool.release(this.id)
          }
          registerMessageHandler(e, r) {
            for (const s of this.actors) s.registerMessageHandler(e, r)
          }
        }

        function At() {
          return ot || (ot = new Bt(ft(), o.K), ot.registerMessageHandler("GR", ((h, e, r) => o.m(e, r)))), ot
        }

        function cr(h, e) {
          const r = o.L();
          return o.M(r, r, [1, 1, 0]), o.N(r, r, [.5 * h.width, .5 * h.height, 1]), h.calculatePosMatrix ? o.O(r, r, h.calculatePosMatrix(e.toUnwrapped())) : r
        }

        function Mt(h, e, r, s, c, d, m) {
          var v;
          const w = (function(L, B, Z) {
              if (L)
                for (const te of L) {
                  const ee = B[te];
                  if (ee && ee.source === Z && ee.type === "fill-extrusion") return !0
                } else
                  for (const te in B) {
                    const ee = B[te];
                    if (ee.source === Z && ee.type === "fill-extrusion") return !0
                  }
              return !1
            })((v = c == null ? void 0 : c.layers) !== null && v !== void 0 ? v : null, e, h.id),
            P = d.maxPitchScaleFactor(),
            M = h.tilesIn(s, P, w);
          M.sort(yt);
          const D = [];
          for (const L of M) D.push({
            wrappedTileID: L.tileID.wrapped().key,
            queryResults: L.tile.queryRenderedFeatures(e, r, h._state, L.queryGeometry, L.cameraQueryGeometry, L.scale, c, d, P, cr(h.transform, L.tileID), m ? (B, Z) => m(L.tileID, B, Z) : void 0)
          });
          return (function(L, B) {
            for (const Z in L)
              for (const te of L[Z]) St(te, B);
            return L
          })((function(L) {
            const B = {},
              Z = {};
            for (const te of L) {
              const ee = te.queryResults,
                ne = te.wrappedTileID,
                oe = Z[ne] = Z[ne] || {};
              for (const me in ee) {
                const ue = ee[me],
                  be = oe[me] = oe[me] || {},
                  Pe = B[me] = B[me] || [];
                for (const pe of ue) be[pe.featureIndex] || (be[pe.featureIndex] = !0, Pe.push(pe))
              }
            }
            return B
          })(D), h)
        }

        function yt(h, e) {
          const r = h.tileID,
            s = e.tileID;
          return r.overscaledZ - s.overscaledZ || r.canonical.y - s.canonical.y || r.wrap - s.wrap || r.canonical.x - s.canonical.x
        }

        function St(h, e) {
          const r = h.feature,
            s = e.getFeatureState(r.layer["source-layer"], r.id);
          r.source = r.layer.source, r.layer["source-layer"] && (r.sourceLayer = r.layer["source-layer"]), r.state = s
        }

        function jt(h, e, r) {
          return o._(this, void 0, void 0, (function*() {
            let s = h;
            if (h.url ? s = (yield o.j(e.transformRequest(h.url, "Source"), r)).data : yield fe.frameAsync(r), !s) return null;
            const c = o.Q(o.e(s, h), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in s && s.vector_layers && (c.vectorLayerIds = s.vector_layers.map((d => d.id))), c
          }))
        }
        class Lt {
          constructor(e, r) {
            e && (r ? this.setSouthWest(e).setNorthEast(r) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])))
          }
          setNorthEast(e) {
            return this._ne = e instanceof o.S ? new o.S(e.lng, e.lat) : o.S.convert(e), this
          }
          setSouthWest(e) {
            return this._sw = e instanceof o.S ? new o.S(e.lng, e.lat) : o.S.convert(e), this
          }
          extend(e) {
            const r = this._sw,
              s = this._ne;
            let c, d;
            if (e instanceof o.S) c = e, d = e;
            else {
              if (!(e instanceof Lt)) return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(Lt.convert(e)) : this.extend(o.S.convert(e)) : e && ("lng" in e || "lon" in e) && "lat" in e ? this.extend(o.S.convert(e)) : this;
              if (c = e._sw, d = e._ne, !c || !d) return this
            }
            return r || s ? (r.lng = Math.min(c.lng, r.lng), r.lat = Math.min(c.lat, r.lat), s.lng = Math.max(d.lng, s.lng), s.lat = Math.max(d.lat, s.lat)) : (this._sw = new o.S(c.lng, c.lat), this._ne = new o.S(d.lng, d.lat)), this
          }
          getCenter() {
            return new o.S((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2)
          }
          getSouthWest() {
            return this._sw
          }
          getNorthEast() {
            return this._ne
          }
          getNorthWest() {
            return new o.S(this.getWest(), this.getNorth())
          }
          getSouthEast() {
            return new o.S(this.getEast(), this.getSouth())
          }
          getWest() {
            return this._sw.lng
          }
          getSouth() {
            return this._sw.lat
          }
          getEast() {
            return this._ne.lng
          }
          getNorth() {
            return this._ne.lat
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()]
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`
          }
          isEmpty() {
            return !(this._sw && this._ne)
          }
          contains(e) {
            const {
              lng: r,
              lat: s
            } = o.S.convert(e);
            let c = this._sw.lng <= r && r <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (c = this._sw.lng >= r && r >= this._ne.lng), this._sw.lat <= s && s <= this._ne.lat && c
          }
          static convert(e) {
            return e instanceof Lt ? e : e && new Lt(e)
          }
          static fromLngLat(e, r = 0) {
            const s = 360 * r / 40075017,
              c = s / Math.cos(Math.PI / 180 * e.lat);
            return new Lt(new o.S(e.lng - c, e.lat - s), new o.S(e.lng + c, e.lat + s))
          }
          adjustAntiMeridian() {
            const e = new o.S(this._sw.lng, this._sw.lat),
              r = new o.S(this._ne.lng, this._ne.lat);
            return new Lt(e, e.lng > r.lng ? new o.S(r.lng + 360, r.lat) : r)
          }
        }
        class Gt {
          constructor(e, r, s) {
            this.bounds = Lt.convert(this.validateBounds(e)), this.minzoom = r || 0, this.maxzoom = s || 24
          }
          validateBounds(e) {
            return Array.isArray(e) && e.length === 4 ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90]
          }
          contains(e) {
            const r = Math.pow(2, e.z),
              s = Math.floor(o.V(this.bounds.getWest()) * r),
              c = Math.floor(o.U(this.bounds.getNorth()) * r),
              d = Math.ceil(o.V(this.bounds.getEast()) * r),
              m = Math.ceil(o.U(this.bounds.getSouth()) * r);
            return e.x >= s && e.x < d && e.y >= c && e.y < m
          }
        }
        class gr extends o.E {
          constructor(e, r, s, c) {
            if (super(), this.id = e, this.dispatcher = s, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, o.e(this, o.Q(r, ["url", "scheme", "tileSize", "promoteId"])), this._options = o.e({
                type: "vector"
              }, r), this._collectResourceTiming = r.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(c)
          }
          load() {
            return o._(this, void 0, void 0, (function*() {
              this._loaded = !1, this.fire(new o.l("dataloading", {
                dataType: "source"
              })), this._tileJSONRequest = new AbortController;
              try {
                const e = yield jt(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), e && (o.e(this, e), e.bounds && (this.tileBounds = new Gt(e.bounds, this.minzoom, this.maxzoom)), this.fire(new o.l("data", {
                  dataType: "source",
                  sourceDataType: "metadata"
                })), this.fire(new o.l("data", {
                  dataType: "source",
                  sourceDataType: "content"
                })))
              } catch (e) {
                this._tileJSONRequest = null, this.fire(new o.k(e))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical)
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          setSourceProperty(e) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load()
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e
            })), this
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e
            })), this
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null)
          }
          serialize() {
            return o.e({}, this._options)
          }
          loadTile(e) {
            return o._(this, void 0, void 0, (function*() {
              const r = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme),
                s = {
                  request: this.map._requestManager.transformRequest(r, "Tile"),
                  uid: e.uid,
                  tileID: e.tileID,
                  zoom: e.tileID.overscaledZ,
                  tileSize: this.tileSize * e.tileID.overscaleFactor(),
                  type: this.type,
                  source: this.id,
                  pixelRatio: this.map.getPixelRatio(),
                  showCollisionBoxes: this.map.showCollisionBoxes,
                  promoteId: this.promoteId,
                  subdivisionGranularity: this.map.style.projection.subdivisionGranularity,
                  globalState: this.map.getGlobalState()
                };
              s.request.collectResourceTiming = this._collectResourceTiming;
              let c = "RT";
              if (e.actor && e.state !== "expired") {
                if (e.state === "loading") return new Promise(((d, m) => {
                  e.reloadPromise = {
                    resolve: d,
                    reject: m
                  }
                }))
              } else e.actor = this.dispatcher.getActor(), c = "LT";
              e.abortController = new AbortController;
              try {
                const d = yield e.actor.sendAsync({
                  type: c,
                  data: s
                }, e.abortController);
                if (delete e.abortController, e.aborted) return;
                this._afterTileLoadWorkerResponse(e, d)
              } catch (d) {
                if (delete e.abortController, e.aborted) return;
                if (d && d.status !== 404) throw d;
                this._afterTileLoadWorkerResponse(e, null)
              }
            }))
          }
          _afterTileLoadWorkerResponse(e, r) {
            if (r && r.resourceTiming && (e.resourceTiming = r.resourceTiming), r && this.map._refreshExpiredTiles && e.setExpiryData(r), e.loadVectorData(r, this.map.painter), e.reloadPromise) {
              const s = e.reloadPromise;
              e.reloadPromise = null, this.loadTile(e).then(s.resolve).catch(s.reject)
            }
          }
          abortTile(e) {
            return o._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && (yield e.actor.sendAsync({
                type: "AT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              }))
            }))
          }
          unloadTile(e) {
            return o._(this, void 0, void 0, (function*() {
              e.unloadVectorData(), e.actor && (yield e.actor.sendAsync({
                type: "RMT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              }))
            }))
          }
          hasTransition() {
            return !1
          }
        }
        class ur extends o.E {
          constructor(e, r, s, c) {
            super(), this.id = e, this.dispatcher = s, this.setEventedParent(c), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = o.e({
              type: "raster"
            }, r), o.e(this, o.Q(r, ["url", "scheme", "tileSize"]))
          }
          load() {
            return o._(this, arguments, void 0, (function*(e = !1) {
              this._loaded = !1, this.fire(new o.l("dataloading", {
                dataType: "source"
              })), this._tileJSONRequest = new AbortController;
              try {
                const r = yield jt(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, r && (o.e(this, r), r.bounds && (this.tileBounds = new Gt(r.bounds, this.minzoom, this.maxzoom)), this.fire(new o.l("data", {
                  dataType: "source",
                  sourceDataType: "metadata"
                })), this.fire(new o.l("data", {
                  dataType: "source",
                  sourceDataType: "content",
                  sourceDataChanged: e
                })))
              } catch (r) {
                this._tileJSONRequest = null, this.fire(new o.k(r))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null)
          }
          setSourceProperty(e) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e(), this.load(!0)
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e
            })), this
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e
            })), this
          }
          serialize() {
            return o.e({}, this._options)
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical)
          }
          loadTile(e) {
            return o._(this, void 0, void 0, (function*() {
              const r = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              e.abortController = new AbortController;
              try {
                const s = yield Ve.getImage(this.map._requestManager.transformRequest(r, "Tile"), e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void(e.state = "unloaded");
                if (s && s.data) {
                  this.map._refreshExpiredTiles && (s.cacheControl || s.expires) && e.setExpiryData({
                    cacheControl: s.cacheControl,
                    expires: s.expires
                  });
                  const c = this.map.painter.context,
                    d = c.gl,
                    m = s.data;
                  e.texture = this.map.painter.getTileTexture(m.width), e.texture ? e.texture.update(m, {
                    useMipmap: !0
                  }) : (e.texture = new o.T(c, m, d.RGBA, {
                    useMipmap: !0
                  }), e.texture.bind(d.LINEAR, d.CLAMP_TO_EDGE, d.LINEAR_MIPMAP_NEAREST)), e.state = "loaded"
                }
              } catch (s) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (s) throw e.state = "errored", s
              }
            }))
          }
          abortTile(e) {
            return o._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController)
            }))
          }
          unloadTile(e) {
            return o._(this, void 0, void 0, (function*() {
              e.texture && this.map.painter.saveTileTexture(e.texture)
            }))
          }
          hasTransition() {
            return !1
          }
        }
        class Qt extends ur {
          constructor(e, r, s, c) {
            super(e, r, s, c), this.type = "raster-dem", this.maxzoom = 22, this._options = o.e({
              type: "raster-dem"
            }, r), this.encoding = r.encoding || "mapbox", this.redFactor = r.redFactor, this.greenFactor = r.greenFactor, this.blueFactor = r.blueFactor, this.baseShift = r.baseShift
          }
          loadTile(e) {
            return o._(this, void 0, void 0, (function*() {
              const r = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme),
                s = this.map._requestManager.transformRequest(r, "Tile");
              e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController;
              try {
                const c = yield Ve.getImage(s, e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void(e.state = "unloaded");
                if (c && c.data) {
                  const d = c.data;
                  this.map._refreshExpiredTiles && (c.cacheControl || c.expires) && e.setExpiryData({
                    cacheControl: c.cacheControl,
                    expires: c.expires
                  });
                  const m = o.b(d) && o.W() ? d : yield this.readImageNow(d), v = {
                    type: this.type,
                    uid: e.uid,
                    source: this.id,
                    rawImageData: m,
                    encoding: this.encoding,
                    redFactor: this.redFactor,
                    greenFactor: this.greenFactor,
                    blueFactor: this.blueFactor,
                    baseShift: this.baseShift
                  };
                  if (!e.actor || e.state === "expired") {
                    e.actor = this.dispatcher.getActor();
                    const w = yield e.actor.sendAsync({
                      type: "LDT",
                      data: v
                    });
                    e.dem = w, e.needsHillshadePrepare = !0, e.needsTerrainPrepare = !0, e.state = "loaded"
                  }
                }
              } catch (c) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (c) throw e.state = "errored", c
              }
            }))
          }
          readImageNow(e) {
            return o._(this, void 0, void 0, (function*() {
              if (typeof VideoFrame < "u" && o.X()) {
                const r = e.width + 2,
                  s = e.height + 2;
                try {
                  return new o.R({
                    width: r,
                    height: s
                  }, yield o.Y(e, -1, -1, r, s))
                } catch {}
              }
              return fe.getImageData(e, 1)
            }))
          }
          _getNeighboringTiles(e) {
            const r = e.canonical,
              s = Math.pow(2, r.z),
              c = (r.x - 1 + s) % s,
              d = r.x === 0 ? e.wrap - 1 : e.wrap,
              m = (r.x + 1 + s) % s,
              v = r.x + 1 === s ? e.wrap + 1 : e.wrap,
              w = {};
            return w[new o.Z(e.overscaledZ, d, r.z, c, r.y).key] = {
              backfilled: !1
            }, w[new o.Z(e.overscaledZ, v, r.z, m, r.y).key] = {
              backfilled: !1
            }, r.y > 0 && (w[new o.Z(e.overscaledZ, d, r.z, c, r.y - 1).key] = {
              backfilled: !1
            }, w[new o.Z(e.overscaledZ, e.wrap, r.z, r.x, r.y - 1).key] = {
              backfilled: !1
            }, w[new o.Z(e.overscaledZ, v, r.z, m, r.y - 1).key] = {
              backfilled: !1
            }), r.y + 1 < s && (w[new o.Z(e.overscaledZ, d, r.z, c, r.y + 1).key] = {
              backfilled: !1
            }, w[new o.Z(e.overscaledZ, e.wrap, r.z, r.x, r.y + 1).key] = {
              backfilled: !1
            }, w[new o.Z(e.overscaledZ, v, r.z, m, r.y + 1).key] = {
              backfilled: !1
            }), w
          }
          unloadTile(e) {
            return o._(this, void 0, void 0, (function*() {
              e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && (yield e.actor.sendAsync({
                type: "RDT",
                data: {
                  type: this.type,
                  uid: e.uid,
                  source: this.id
                }
              }))
            }))
          }
        }
        class er extends o.E {
          constructor(e, r, s, c) {
            super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._pendingLoads = 0, this.actor = s.getActor(), this.setEventedParent(c), this._data = r.data, this._options = o.e({}, r), this._collectResourceTiming = r.collectResourceTiming, r.maxzoom !== void 0 && (this.maxzoom = r.maxzoom), r.type && (this.type = r.type), r.attribution && (this.attribution = r.attribution), this.promoteId = r.promoteId, r.clusterMaxZoom !== void 0 && this.maxzoom <= r.clusterMaxZoom && o.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${r.clusterMaxZoom}".`), this.workerOptions = o.e({
              source: this.id,
              cluster: r.cluster || !1,
              geojsonVtOptions: {
                buffer: this._pixelsToTileUnits(r.buffer !== void 0 ? r.buffer : 128),
                tolerance: this._pixelsToTileUnits(r.tolerance !== void 0 ? r.tolerance : .375),
                extent: o.$,
                maxZoom: this.maxzoom,
                lineMetrics: r.lineMetrics || !1,
                generateId: r.generateId || !1
              },
              superclusterOptions: {
                maxZoom: this._getClusterMaxZoom(r.clusterMaxZoom),
                minPoints: Math.max(2, r.clusterMinPoints || 2),
                extent: o.$,
                radius: this._pixelsToTileUnits(r.clusterRadius || 50),
                log: !1,
                generateId: r.generateId || !1
              },
              clusterProperties: r.clusterProperties,
              filter: r.filter
            }, r.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId)
          }
          _pixelsToTileUnits(e) {
            return e * (o.$ / this.tileSize)
          }
          _getClusterMaxZoom(e) {
            const r = e ? Math.round(e) : this.maxzoom - 1;
            return Number.isInteger(e) || e === void 0 || o.w(`Integer expected for option 'clusterMaxZoom': provided value "${e}" rounded to "${r}"`), r
          }
          load() {
            return o._(this, void 0, void 0, (function*() {
              yield this._updateWorkerData()
            }))
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          setData(e) {
            return this._data = e, this._updateWorkerData(), this
          }
          updateData(e) {
            return this._updateWorkerData(e), this
          }
          getData() {
            return o._(this, void 0, void 0, (function*() {
              const e = o.e({
                type: this.type
              }, this.workerOptions);
              return this.actor.sendAsync({
                type: "GD",
                data: e
              })
            }))
          }
          getCoordinatesFromGeometry(e) {
            return e.type === "GeometryCollection" ? e.geometries.map((r => r.coordinates)).flat(1 / 0) : e.coordinates.flat(1 / 0)
          }
          getBounds() {
            return o._(this, void 0, void 0, (function*() {
              const e = new Lt,
                r = yield this.getData();
              let s;
              switch (r.type) {
                case "FeatureCollection":
                  s = r.features.map((c => this.getCoordinatesFromGeometry(c.geometry))).flat(1 / 0);
                  break;
                case "Feature":
                  s = this.getCoordinatesFromGeometry(r.geometry);
                  break;
                default:
                  s = this.getCoordinatesFromGeometry(r)
              }
              if (s.length == 0) return e;
              for (let c = 0; c < s.length - 1; c += 2) e.extend([s[c], s[c + 1]]);
              return e
            }))
          }
          setClusterOptions(e) {
            return this.workerOptions.cluster = e.cluster, e && (e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e.clusterRadius)), e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(e.clusterMaxZoom))), this._updateWorkerData(), this
          }
          getClusterExpansionZoom(e) {
            return this.actor.sendAsync({
              type: "GCEZ",
              data: {
                type: this.type,
                clusterId: e,
                source: this.id
              }
            })
          }
          getClusterChildren(e) {
            return this.actor.sendAsync({
              type: "GCC",
              data: {
                type: this.type,
                clusterId: e,
                source: this.id
              }
            })
          }
          getClusterLeaves(e, r, s) {
            return this.actor.sendAsync({
              type: "GCL",
              data: {
                type: this.type,
                source: this.id,
                clusterId: e,
                limit: r,
                offset: s
              }
            })
          }
          _updateWorkerData(e) {
            return o._(this, void 0, void 0, (function*() {
              const r = o.e({
                type: this.type
              }, this.workerOptions);
              e ? r.dataDiff = e : typeof this._data == "string" ? (r.request = this.map._requestManager.transformRequest(fe.resolveURL(this._data), "Source"), r.request.collectResourceTiming = this._collectResourceTiming) : r.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new o.l("dataloading", {
                dataType: "source"
              }));
              try {
                const s = yield this.actor.sendAsync({
                  type: "LD",
                  data: r
                });
                if (this._pendingLoads--, this._removed || s.abandoned) return void this.fire(new o.l("dataabort", {
                  dataType: "source"
                }));
                let c = null;
                s.resourceTiming && s.resourceTiming[this.id] && (c = s.resourceTiming[this.id].slice(0));
                const d = {
                  dataType: "source"
                };
                this._collectResourceTiming && c && c.length > 0 && o.e(d, {
                  resourceTiming: c
                }), this.fire(new o.l("data", Object.assign(Object.assign({}, d), {
                  sourceDataType: "metadata"
                }))), this.fire(new o.l("data", Object.assign(Object.assign({}, d), {
                  sourceDataType: "content"
                })))
              } catch (s) {
                if (this._pendingLoads--, this._removed) return void this.fire(new o.l("dataabort", {
                  dataType: "source"
                }));
                this.fire(new o.k(s))
              }
            }))
          }
          loaded() {
            return this._pendingLoads === 0
          }
          loadTile(e) {
            return o._(this, void 0, void 0, (function*() {
              const r = e.actor ? "RT" : "LT";
              e.actor = this.actor;
              const s = {
                type: this.type,
                uid: e.uid,
                tileID: e.tileID,
                zoom: e.tileID.overscaledZ,
                maxZoom: this.maxzoom,
                tileSize: this.tileSize,
                source: this.id,
                pixelRatio: this.map.getPixelRatio(),
                showCollisionBoxes: this.map.showCollisionBoxes,
                promoteId: this.promoteId,
                subdivisionGranularity: this.map.style.projection.subdivisionGranularity,
                globalState: this.map.getGlobalState()
              };
              e.abortController = new AbortController;
              const c = yield this.actor.sendAsync({
                type: r,
                data: s
              }, e.abortController);
              delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(c, this.map.painter, r === "RT")
            }))
          }
          abortTile(e) {
            return o._(this, void 0, void 0, (function*() {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = !0
            }))
          }
          unloadTile(e) {
            return o._(this, void 0, void 0, (function*() {
              e.unloadVectorData(), yield this.actor.sendAsync({
                type: "RMT",
                data: {
                  uid: e.uid,
                  type: this.type,
                  source: this.id
                }
              })
            }))
          }
          onRemove() {
            this._removed = !0, this.actor.sendAsync({
              type: "RS",
              data: {
                type: this.type,
                source: this.id
              }
            })
          }
          serialize() {
            return o.e({}, this._options, {
              type: this.type,
              data: this._data
            })
          }
          hasTransition() {
            return !1
          }
        }
        class Dt extends o.E {
          constructor(e, r, s, c) {
            super(), this.flippedWindingOrder = !1, this.id = e, this.dispatcher = s, this.coordinates = r.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(c), this.options = r
          }
          load(e) {
            return o._(this, void 0, void 0, (function*() {
              this._loaded = !1, this.fire(new o.l("dataloading", {
                dataType: "source"
              })), this.url = this.options.url, this._request = new AbortController;
              try {
                const r = yield Ve.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = !0, r && r.data && (this.image = r.data, e && (this.coordinates = e), this._finishLoading())
              } catch (r) {
                this._request = null, this._loaded = !0, this.fire(new o.k(r))
              }
            }))
          }
          loaded() {
            return this._loaded
          }
          updateImage(e) {
            return e.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e.url, this.load(e.coordinates).finally((() => {
              this.texture = null
            })), this) : this
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new o.l("data", {
              dataType: "source",
              sourceDataType: "metadata"
            })))
          }
          onAdd(e) {
            this.map = e, this.load()
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null)
          }
          setCoordinates(e) {
            this.coordinates = e;
            const r = e.map(o.a0.fromLngLat);
            var s;
            return this.tileID = (function(c) {
              const d = o.a1.fromPoints(c),
                m = d.width(),
                v = d.height(),
                w = Math.max(m, v),
                P = Math.max(0, Math.floor(-Math.log(w) / Math.LN2)),
                M = Math.pow(2, P);
              return new o.a3(P, Math.floor((d.minX + d.maxX) / 2 * M), Math.floor((d.minY + d.maxY) / 2 * M))
            })(r), this.terrainTileRanges = this._getOverlappingTileRanges(r), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = r.map((c => this.tileID.getTilePoint(c)._round())), this.flippedWindingOrder = ((s = this.tileCoords)[1].x - s[0].x) * (s[2].y - s[0].y) - (s[1].y - s[0].y) * (s[2].x - s[0].x) < 0, this.fire(new o.l("data", {
              dataType: "source",
              sourceDataType: "content"
            })), this
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || !this.image) return;
            const e = this.map.painter.context,
              r = e.gl;
            this.texture || (this.texture = new o.T(e, this.image, r.RGBA), this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE));
            let s = !1;
            for (const c in this.tiles) {
              const d = this.tiles[c];
              d.state !== "loaded" && (d.state = "loaded", d.texture = this.texture, s = !0)
            }
            s && this.fire(new o.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          loadTile(e) {
            return o._(this, void 0, void 0, (function*() {
              this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}) : e.state = "errored"
            }))
          }
          serialize() {
            return {
              type: "image",
              url: this.options.url,
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return !1
          }
          _getOverlappingTileRanges(e) {
            const {
              minX: r,
              minY: s,
              maxX: c,
              maxY: d
            } = o.a1.fromPoints(e), m = {};
            for (let v = 0; v <= o.a2; v++) {
              const w = Math.pow(2, v),
                P = Math.floor(r * w),
                M = Math.floor(s * w),
                D = Math.floor(c * w),
                L = Math.floor(d * w);
              m[v] = {
                minTileX: P,
                minTileY: M,
                maxTileX: D,
                maxTileY: L
              }
            }
            return m
          }
        }
        class Ir extends Dt {
          constructor(e, r, s, c) {
            super(e, r, s, c), this.roundZoom = !0, this.type = "video", this.options = r
          }
          load() {
            return o._(this, void 0, void 0, (function*() {
              this._loaded = !1;
              const e = this.options;
              this.urls = [];
              for (const r of e.urls) this.urls.push(this.map._requestManager.transformRequest(r, "Source").url);
              try {
                const r = yield o.a4(this.urls);
                if (this._loaded = !0, !r) return;
                this.video = r, this.video.loop = !0, this.video.addEventListener("playing", (() => {
                  this.map.triggerRepaint()
                })), this.map && this.video.play(), this._finishLoading()
              } catch (r) {
                this.fire(new o.k(r))
              }
            }))
          }
          pause() {
            this.video && this.video.pause()
          }
          play() {
            this.video && this.video.play()
          }
          seek(e) {
            if (this.video) {
              const r = this.video.seekable;
              e < r.start(0) || e > r.end(0) ? this.fire(new o.k(new o.a5(`sources.${this.id}`, null, `Playback for this video can be set only between the ${r.start(0)} and ${r.end(0)}-second mark.`))) : this.video.currentTime = e
            }
          }
          getVideo() {
            return this.video
          }
          onAdd(e) {
            this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)))
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
            const e = this.map.painter.context,
              r = e.gl;
            this.texture ? this.video.paused || (this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE), r.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, r.RGBA, r.UNSIGNED_BYTE, this.video)) : (this.texture = new o.T(e, this.video, r.RGBA), this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE));
            let s = !1;
            for (const c in this.tiles) {
              const d = this.tiles[c];
              d.state !== "loaded" && (d.state = "loaded", d.texture = this.texture, s = !0)
            }
            s && this.fire(new o.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          serialize() {
            return {
              type: "video",
              urls: this.urls,
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return this.video && !this.video.paused
          }
        }
        class Tr extends Dt {
          constructor(e, r, s, c) {
            super(e, r, s, c), r.coordinates ? Array.isArray(r.coordinates) && r.coordinates.length === 4 && !r.coordinates.some((d => !Array.isArray(d) || d.length !== 2 || d.some((m => typeof m != "number")))) || this.fire(new o.k(new o.a5(`sources.${e}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new o.k(new o.a5(`sources.${e}`, null, 'missing required property "coordinates"'))), r.animate && typeof r.animate != "boolean" && this.fire(new o.k(new o.a5(`sources.${e}`, null, 'optional "animate" property must be a boolean value'))), r.canvas ? typeof r.canvas == "string" || r.canvas instanceof HTMLCanvasElement || this.fire(new o.k(new o.a5(`sources.${e}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new o.k(new o.a5(`sources.${e}`, null, 'missing required property "canvas"'))), this.options = r, this.animate = r.animate === void 0 || r.animate
          }
          load() {
            return o._(this, void 0, void 0, (function*() {
              this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new o.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = !0, this.map.triggerRepaint()
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = !1)
              }, this._finishLoading())
            }))
          }
          getCanvas() {
            return this.canvas
          }
          onAdd(e) {
            this.map = e, this.load(), this.canvas && this.animate && this.play()
          }
          onRemove() {
            this.pause()
          }
          prepare() {
            let e = !1;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
            const r = this.map.painter.context,
              s = r.gl;
            this.texture ? (e || this._playing) && this.texture.update(this.canvas, {
              premultiply: !0
            }) : this.texture = new o.T(r, this.canvas, s.RGBA, {
              premultiply: !0
            });
            let c = !1;
            for (const d in this.tiles) {
              const m = this.tiles[d];
              m.state !== "loaded" && (m.state = "loaded", m.texture = this.texture, c = !0)
            }
            c && this.fire(new o.l("data", {
              dataType: "source",
              sourceDataType: "idle",
              sourceId: this.id
            }))
          }
          serialize() {
            return {
              type: "canvas",
              coordinates: this.coordinates
            }
          }
          hasTransition() {
            return this._playing
          }
          _hasInvalidDimensions() {
            for (const e of [this.canvas.width, this.canvas.height])
              if (isNaN(e) || e <= 0) return !0;
            return !1
          }
        }
        const Dr = {},
          Fr = h => {
            switch (h) {
              case "geojson":
                return er;
              case "image":
                return Dt;
              case "raster":
                return ur;
              case "raster-dem":
                return Qt;
              case "vector":
                return gr;
              case "video":
                return Ir;
              case "canvas":
                return Tr
            }
            return Dr[h]
          },
          dr = "RTLPluginLoaded";
        class Or extends o.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = At()
          }
          _syncState(e) {
            return this.status = e, this.dispatcher.broadcast("SRPS", {
              pluginStatus: e,
              pluginURL: this.url
            }).catch((r => {
              throw this.status = "error", r
            }))
          }
          getRTLTextPluginStatus() {
            return this.status
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null
          }
          setRTLTextPlugin(e) {
            return o._(this, arguments, void 0, (function*(r, s = !1) {
              if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (this.url = fe.resolveURL(r), !this.url) throw new Error(`requested url ${r} is invalid`);
              if (this.status === "unavailable") {
                if (!s) return this._requestImport();
                this.status = "deferred", this._syncState(this.status)
              } else if (this.status === "requested") return this._requestImport()
            }))
          }
          _requestImport() {
            return o._(this, void 0, void 0, (function*() {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new o.l(dr))
            }))
          }
          lazyLoad() {
            this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport()
          }
        }
        let zr = null;

        function tr() {
          return zr || (zr = new Or), zr
        }
        class br {
          constructor(e, r) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = e, this.uid = o.a6(), this.uses = 0, this.tileSize = r, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading"
          }
          registerFadeDuration(e) {
            const r = e + this.timeAdded;
            r < this.fadeEndTime || (this.fadeEndTime = r)
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading"
          }
          clearTextures(e) {
            this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null
          }
          loadVectorData(e, r, s) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e) {
              e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = (function(c, d) {
                const m = {};
                if (!d) return m;
                for (const v of c) {
                  const w = v.layerIds.map((P => d.getLayer(P))).filter(Boolean);
                  if (w.length !== 0) {
                    v.layers = w, v.stateDependentLayerIds && (v.stateDependentLayers = v.stateDependentLayerIds.map((P => w.filter((M => M.id === P))[0])));
                    for (const P of w) m[P.id] = v
                  }
                }
                return m
              })(e.buckets, r == null ? void 0 : r.style), this.hasSymbolBuckets = !1;
              for (const c in this.buckets) {
                const d = this.buckets[c];
                if (d instanceof o.a8) {
                  if (this.hasSymbolBuckets = !0, !s) break;
                  d.justReloaded = !0
                }
              }
              if (this.hasRTLText = !1, this.hasSymbolBuckets)
                for (const c in this.buckets) {
                  const d = this.buckets[c];
                  if (d instanceof o.a8 && d.hasRTLText) {
                    this.hasRTLText = !0, tr().lazyLoad();
                    break
                  }
                }
              this.queryPadding = 0;
              for (const c in this.buckets) {
                const d = this.buckets[c];
                this.queryPadding = Math.max(this.queryPadding, r.style.getLayer(c).queryRadius(d))
              }
              e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage)
            } else this.collisionBoxArray = new o.a7
          }
          unloadVectorData() {
            for (const e in this.buckets) this.buckets[e].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded"
          }
          getBucket(e) {
            return this.buckets[e.id]
          }
          upload(e) {
            for (const s in this.buckets) {
              const c = this.buckets[s];
              c.uploadPending() && c.upload(e)
            }
            const r = e.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new o.T(e, this.imageAtlas.image, r.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new o.T(e, this.glyphAtlasImage, r.ALPHA), this.glyphAtlasImage = null)
          }
          prepare(e) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture)
          }
          queryRenderedFeatures(e, r, s, c, d, m, v, w, P, M, D) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
              queryGeometry: c,
              cameraQueryGeometry: d,
              scale: m,
              tileSize: this.tileSize,
              pixelPosMatrix: M,
              transform: w,
              params: v,
              queryPadding: this.queryPadding * P,
              getElevation: D
            }, e, r, s) : {}
          }
          querySourceFeatures(e, r) {
            const s = this.latestFeatureIndex;
            if (!s || !s.rawTileData) return;
            const c = s.loadVTLayers(),
              d = r && r.sourceLayer ? r.sourceLayer : "",
              m = c._geojsonTileLayer || c[d];
            if (!m) return;
            const v = o.a9(r && r.filter),
              {
                z: w,
                x: P,
                y: M
              } = this.tileID.canonical,
              D = {
                z: w,
                x: P,
                y: M
              };
            for (let L = 0; L < m.length; L++) {
              const B = m.feature(L);
              if (v.needGeometry) {
                const ee = o.aa(B, !0);
                if (!v.filter(new o.F(this.tileID.overscaledZ), ee, this.tileID.canonical)) continue
              } else if (!v.filter(new o.F(this.tileID.overscaledZ), B)) continue;
              const Z = s.getId(B, d),
                te = new o.ab(B, w, P, M, Z);
              te.tile = D, e.push(te)
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired"
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length
          }
          setExpiryData(e) {
            const r = this.expirationTime;
            if (e.cacheControl) {
              const s = o.ac(e.cacheControl);
              s["max-age"] && (this.expirationTime = Date.now() + 1e3 * s["max-age"])
            } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
            if (this.expirationTime) {
              const s = Date.now();
              let c = !1;
              if (this.expirationTime > s) c = !1;
              else if (r)
                if (this.expirationTime < r) c = !0;
                else {
                  const d = this.expirationTime - r;
                  d ? this.expirationTime = s + Math.max(d, 3e4) : c = !0
                }
              else c = !0;
              c ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1)
          }
          setFeatureState(e, r) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0) return;
            const s = this.latestFeatureIndex.loadVTLayers();
            for (const c in this.buckets) {
              if (!r.style.hasLayer(c)) continue;
              const d = this.buckets[c],
                m = d.layers[0].sourceLayer || "_geojsonTileLayer",
                v = s[m],
                w = e[m];
              if (!v || !w || Object.keys(w).length === 0) continue;
              d.update(w, v, this.imageAtlas && this.imageAtlas.patternPositions || {});
              const P = r && r.style && r.style.getLayer(c);
              P && (this.queryPadding = Math.max(this.queryPadding, P.queryRadius(d)))
            }
          }
          holdingForFade() {
            return this.symbolFadeHoldUntil !== void 0
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < fe.now()
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0
          }
          setHoldDuration(e) {
            this.symbolFadeHoldUntil = fe.now() + e
          }
          setDependencies(e, r) {
            const s = {};
            for (const c of r) s[c] = !0;
            this.dependencies[e] = s
          }
          hasDependency(e, r) {
            for (const s of e) {
              const c = this.dependencies[s];
              if (c) {
                for (const d of r)
                  if (c[d]) return !0
              }
            }
            return !1
          }
        }
        class $t {
          constructor(e, r) {
            this.max = e, this.onRemove = r, this.reset()
          }
          reset() {
            for (const e in this.data)
              for (const r of this.data[e]) r.timeout && clearTimeout(r.timeout), this.onRemove(r.value);
            return this.data = {}, this.order = [], this
          }
          add(e, r, s) {
            const c = e.wrapped().key;
            this.data[c] === void 0 && (this.data[c] = []);
            const d = {
              value: r,
              timeout: void 0
            };
            if (s !== void 0 && (d.timeout = setTimeout((() => {
                this.remove(e, d)
              }), s)), this.data[c].push(d), this.order.push(c), this.order.length > this.max) {
              const m = this._getAndRemoveByKey(this.order[0]);
              m && this.onRemove(m)
            }
            return this
          }
          has(e) {
            return e.wrapped().key in this.data
          }
          getAndRemove(e) {
            return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null
          }
          _getAndRemoveByKey(e) {
            const r = this.data[e].shift();
            return r.timeout && clearTimeout(r.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), r.value
          }
          getByKey(e) {
            const r = this.data[e];
            return r ? r[0].value : null
          }
          get(e) {
            return this.has(e) ? this.data[e.wrapped().key][0].value : null
          }
          remove(e, r) {
            if (!this.has(e)) return this;
            const s = e.wrapped().key,
              c = r === void 0 ? 0 : this.data[s].indexOf(r),
              d = this.data[s][c];
            return this.data[s].splice(c, 1), d.timeout && clearTimeout(d.timeout), this.data[s].length === 0 && delete this.data[s], this.onRemove(d.value), this.order.splice(this.order.indexOf(s), 1), this
          }
          setMaxSize(e) {
            for (this.max = e; this.order.length > this.max;) {
              const r = this._getAndRemoveByKey(this.order[0]);
              r && this.onRemove(r)
            }
            return this
          }
          filter(e) {
            const r = [];
            for (const s in this.data)
              for (const c of this.data[s]) e(c.value) || r.push(c);
            for (const s of r) this.remove(s.value.tileID, s)
          }
        }
        class yr {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {}
          }
          updateState(e, r, s) {
            const c = String(r);
            if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][c] = this.stateChanges[e][c] || {}, o.e(this.stateChanges[e][c], s), this.deletedStates[e] === null) {
              this.deletedStates[e] = {};
              for (const d in this.state[e]) d !== c && (this.deletedStates[e][d] = null)
            } else if (this.deletedStates[e] && this.deletedStates[e][c] === null) {
              this.deletedStates[e][c] = {};
              for (const d in this.state[e][c]) s[d] || (this.deletedStates[e][c][d] = null)
            } else
              for (const d in s) this.deletedStates[e] && this.deletedStates[e][c] && this.deletedStates[e][c][d] === null && delete this.deletedStates[e][c][d]
          }
          removeFeatureState(e, r, s) {
            if (this.deletedStates[e] === null) return;
            const c = String(r);
            if (this.deletedStates[e] = this.deletedStates[e] || {}, s && r !== void 0) this.deletedStates[e][c] !== null && (this.deletedStates[e][c] = this.deletedStates[e][c] || {}, this.deletedStates[e][c][s] = null);
            else if (r !== void 0)
              if (this.stateChanges[e] && this.stateChanges[e][c])
                for (s in this.deletedStates[e][c] = {}, this.stateChanges[e][c]) this.deletedStates[e][c][s] = null;
              else this.deletedStates[e][c] = null;
            else this.deletedStates[e] = null
          }
          getState(e, r) {
            const s = String(r),
              c = o.e({}, (this.state[e] || {})[s], (this.stateChanges[e] || {})[s]);
            if (this.deletedStates[e] === null) return {};
            if (this.deletedStates[e]) {
              const d = this.deletedStates[e][r];
              if (d === null) return {};
              for (const m in d) delete c[m]
            }
            return c
          }
          initializeTileState(e, r) {
            e.setFeatureState(this.state, r)
          }
          coalesceChanges(e, r) {
            const s = {};
            for (const c in this.stateChanges) {
              this.state[c] = this.state[c] || {};
              const d = {};
              for (const m in this.stateChanges[c]) this.state[c][m] || (this.state[c][m] = {}), o.e(this.state[c][m], this.stateChanges[c][m]), d[m] = this.state[c][m];
              s[c] = d
            }
            for (const c in this.deletedStates) {
              this.state[c] = this.state[c] || {};
              const d = {};
              if (this.deletedStates[c] === null)
                for (const m in this.state[c]) d[m] = {}, this.state[c][m] = {};
              else
                for (const m in this.deletedStates[c]) {
                  if (this.deletedStates[c][m] === null) this.state[c][m] = {};
                  else
                    for (const v of Object.keys(this.deletedStates[c][m])) delete this.state[c][m][v];
                  d[m] = this.state[c][m]
                }
              s[c] = s[c] || {}, o.e(s[c], d)
            }
            if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(s).length !== 0)
              for (const c in e) e[c].setFeatureState(s, r)
          }
        }
        const jr = 89.25;

        function ye(h, e) {
          const r = o.ag(e.lat, -o.ah, o.ah);
          return new o.P(o.V(e.lng) * h, o.U(r) * h)
        }

        function j(h, e) {
          return new o.a0(e.x / h, e.y / h).toLngLat()
        }

        function V(h) {
          return h.cameraToCenterDistance * Math.min(.85 * Math.tan(o.ad(90 - h.pitch)), Math.tan(o.ad(jr - h.pitch)))
        }

        function X(h, e) {
          const r = h.canonical,
            s = e / o.ae(r.z),
            c = r.x + Math.pow(2, r.z) * h.wrap,
            d = o.af(new Float64Array(16));
          return o.M(d, d, [c * s, r.y * s, 0]), o.N(d, d, [s / o.$, s / o.$, 1]), d
        }

        function se(h, e, r, s, c) {
          const d = o.a0.fromLngLat(h, e),
            m = c * o.ai(1, h.lat),
            v = m * Math.cos(o.ad(r)),
            w = Math.sqrt(m * m - v * v),
            P = w * Math.sin(o.ad(-s)),
            M = w * Math.cos(o.ad(-s));
          return new o.a0(d.x + P, d.y + M, d.z + v)
        }

        function we(h, e, r) {
          const s = e.intersectsFrustum(h);
          if (!r || s === 0) return s;
          const c = e.intersectsPlane(r);
          return c === 0 ? 0 : s === 2 && c === 2 ? 2 : 1
        }

        function Ae(h, e, r) {
          let s = 0;
          const c = (r - e) / 10;
          for (let d = 0; d < 10; d++) s += c * Math.pow(Math.cos(e + (d + .5) / 10 * (r - e)), h);
          return s
        }

        function Ze(h, e) {
          return function(r, s, c, d, m) {
            const v = 2 * ((h - 1) / o.aj(Math.cos(o.ad(jr - m)) / Math.cos(o.ad(jr))) - 1),
              w = Math.acos(c / d),
              P = 2 * Ae(v - 1, 0, o.ad(m / 2)),
              M = Math.min(o.ad(jr), w + o.ad(m / 2)),
              D = Ae(v - 1, Math.min(M, w - o.ad(m / 2)), M),
              L = Math.atan(s / c),
              B = Math.hypot(s, c);
            let Z = r;
            return Z += o.aj(d / B / Math.max(.5, Math.cos(o.ad(m / 2)))), Z += v * o.aj(Math.cos(L)) / 2, Z -= o.aj(Math.max(1, D / P / e)) / 2, Z
          }
        }
        const Se = Ze(9.314, 3);

        function Ne(h, e) {
          const r = (e.roundZoom ? Math.round : Math.floor)(h.zoom + o.aj(h.tileSize / e.tileSize));
          return Math.max(0, r)
        }

        function ze(h, e) {
          const r = h.getCameraFrustum(),
            s = h.getClippingPlane(),
            c = h.screenPointToMercatorCoordinate(h.getCameraPoint()),
            d = o.a0.fromLngLat(h.center, h.elevation);
          c.z = d.z + Math.cos(h.pitchInRadians) * h.cameraToCenterDistance / h.worldSize;
          const m = h.getCoveringTilesDetailsProvider(),
            v = m.allowVariableZoom(h, e),
            w = Ne(h, e),
            P = e.minzoom || 0,
            M = e.maxzoom !== void 0 ? e.maxzoom : h.maxZoom,
            D = Math.min(Math.max(0, w), M),
            L = Math.pow(2, D),
            B = [L * c.x, L * c.y, 0],
            Z = [L * d.x, L * d.y, 0],
            te = Math.hypot(d.x - c.x, d.y - c.y),
            ee = Math.abs(d.z - c.z),
            ne = Math.hypot(te, ee),
            oe = be => ({
              zoom: 0,
              x: 0,
              y: 0,
              wrap: be,
              fullyVisible: !1
            }),
            me = [],
            ue = [];
          if (h.renderWorldCopies && m.allowWorldCopies())
            for (let be = 1; be <= 3; be++) me.push(oe(-be)), me.push(oe(be));
          for (me.push(oe(0)); me.length > 0;) {
            const be = me.pop(),
              Pe = be.x,
              pe = be.y;
            let Fe = be.fullyVisible;
            const Je = {
                x: Pe,
                y: pe,
                z: be.zoom
              },
              Ge = m.getTileBoundingVolume(Je, be.wrap, h.elevation, e);
            if (!Fe) {
              const Ft = we(r, Ge, s);
              if (Ft === 0) continue;
              Fe = Ft === 2
            }
            const He = m.distanceToTile2d(c.x, c.y, Je, Ge);
            let Qe = w;
            v && (Qe = (e.calculateTileZoom || Se)(h.zoom + o.aj(h.tileSize / e.tileSize), He, ee, ne, h.fov)), Qe = (e.roundZoom ? Math.round : Math.floor)(Qe), Qe = Math.max(0, Qe);
            const qt = Math.min(Qe, M);
            if (be.wrap = m.getWrap(d, Je, be.wrap), be.zoom >= qt) {
              if (be.zoom < P) continue;
              const Ft = D - be.zoom,
                Tt = B[0] - .5 - (Pe << Ft),
                rr = B[1] - .5 - (pe << Ft),
                ei = e.reparseOverscaled ? Math.max(be.zoom, Qe) : be.zoom;
              ue.push({
                tileID: new o.Z(be.zoom === M ? ei : be.zoom, be.wrap, be.zoom, Pe, pe),
                distanceSq: o.ak([Z[0] - .5 - Pe, Z[1] - .5 - pe]),
                tileDistanceToCamera: Math.sqrt(Tt * Tt + rr * rr)
              })
            } else
              for (let Ft = 0; Ft < 4; Ft++) me.push({
                zoom: be.zoom + 1,
                x: (Pe << 1) + Ft % 2,
                y: (pe << 1) + (Ft >> 1),
                wrap: be.wrap,
                fullyVisible: Fe
              })
          }
          return ue.sort(((be, Pe) => be.distanceSq - Pe.distanceSq)).map((be => be.tileID))
        }
        const Ie = o.a1.fromPoints([new o.P(0, 0), new o.P(o.$, o.$)]);
        class We extends o.E {
          constructor(e, r, s) {
            super(), this.id = e, this.dispatcher = s, this.on("data", (c => this._dataHandler(c))), this.on("dataloading", (() => {
              this._sourceErrored = !1
            })), this.on("error", (() => {
              this._sourceErrored = this._source.loaded()
            })), this._source = ((c, d, m, v) => {
              const w = new(Fr(d.type))(c, d, m, v);
              if (w.id !== c) throw new Error(`Expected Source id to be ${c} instead of ${w.id}`);
              return w
            })(e, r, s, this), this._tiles = {}, this._cache = new $t(0, (c => this._unloadTile(c))), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new yr, this._didEmitContent = !1, this._updated = !1
          }
          onAdd(e) {
            this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e)
          }
          onRemove(e) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e)
          }
          loaded() {
            if (this._sourceErrored) return !0;
            if (!this._sourceLoaded || !this._source.loaded()) return !1;
            if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
            if (!this._updated) return !1;
            for (const e in this._tiles) {
              const r = this._tiles[e];
              if (r.state !== "loaded" && r.state !== "errored") return !1
            }
            return !0
          }
          getSource() {
            return this._source
          }
          pause() {
            this._paused = !0
          }
          resume() {
            if (!this._paused) return;
            const e = this._shouldReloadOnResume;
            this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform, this.terrain)
          }
          _loadTile(e, r, s) {
            return o._(this, void 0, void 0, (function*() {
              try {
                yield this._source.loadTile(e), this._tileLoaded(e, r, s)
              } catch (c) {
                e.state = "errored", c.status !== 404 ? this._source.fire(new o.k(c, {
                  tile: e
                })) : this.update(this.transform, this.terrain)
              }
            }))
          }
          _unloadTile(e) {
            this._source.unloadTile && this._source.unloadTile(e)
          }
          _abortTile(e) {
            this._source.abortTile && this._source.abortTile(e), this._source.fire(new o.l("dataabort", {
              tile: e,
              coord: e.tileID,
              dataType: "source"
            }))
          }
          serialize() {
            return this._source.serialize()
          }
          prepare(e) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const r in this._tiles) {
              const s = this._tiles[r];
              s.upload(e), s.prepare(this.map.style.imageManager)
            }
          }
          getIds() {
            return Object.values(this._tiles).map((e => e.tileID)).sort(ve).map((e => e.key))
          }
          getRenderableIds(e) {
            const r = [];
            for (const s in this._tiles) this._isIdRenderable(s, e) && r.push(this._tiles[s]);
            return e ? r.sort(((s, c) => {
              const d = s.tileID,
                m = c.tileID,
                v = new o.P(d.canonical.x, d.canonical.y)._rotate(-this.transform.bearingInRadians),
                w = new o.P(m.canonical.x, m.canonical.y)._rotate(-this.transform.bearingInRadians);
              return d.overscaledZ - m.overscaledZ || w.y - v.y || w.x - v.x
            })).map((s => s.tileID.key)) : r.map((s => s.tileID)).sort(ve).map((s => s.key))
          }
          hasRenderableParent(e) {
            const r = this.findLoadedParent(e, 0);
            return !!r && this._isIdRenderable(r.tileID.key)
          }
          _isIdRenderable(e, r) {
            return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (r || !this._tiles[e].holdingForFade())
          }
          reload(e) {
            if (this._paused) this._shouldReloadOnResume = !0;
            else {
              this._cache.reset();
              for (const r in this._tiles) e ? this._reloadTile(r, "expired") : this._tiles[r].state !== "errored" && this._reloadTile(r, "reloading")
            }
          }
          _reloadTile(e, r) {
            return o._(this, void 0, void 0, (function*() {
              const s = this._tiles[e];
              s && (s.state !== "loading" && (s.state = r), yield this._loadTile(s, e, r))
            }))
          }
          _tileLoaded(e, r, s) {
            e.timeAdded = fe.now(), s === "expired" && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(r, e), this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new o.l("data", {
              dataType: "source",
              tile: e,
              coord: e.tileID
            }))
          }
          _backfillDEM(e) {
            const r = this.getRenderableIds();
            for (let c = 0; c < r.length; c++) {
              const d = r[c];
              if (e.neighboringTiles && e.neighboringTiles[d]) {
                const m = this.getTileByID(d);
                s(e, m), s(m, e)
              }
            }

            function s(c, d) {
              c.needsHillshadePrepare = !0, c.needsTerrainPrepare = !0;
              let m = d.tileID.canonical.x - c.tileID.canonical.x;
              const v = d.tileID.canonical.y - c.tileID.canonical.y,
                w = Math.pow(2, c.tileID.canonical.z),
                P = d.tileID.key;
              m === 0 && v === 0 || Math.abs(v) > 1 || (Math.abs(m) > 1 && (Math.abs(m + w) === 1 ? m += w : Math.abs(m - w) === 1 && (m -= w)), d.dem && c.dem && (c.dem.backfillBorder(d.dem, m, v), c.neighboringTiles && c.neighboringTiles[P] && (c.neighboringTiles[P].backfilled = !0)))
            }
          }
          getTile(e) {
            return this.getTileByID(e.key)
          }
          getTileByID(e) {
            return this._tiles[e]
          }
          _retainLoadedChildren(e, r, s, c) {
            for (const d in this._tiles) {
              let m = this._tiles[d];
              if (c[d] || !m.hasData() || m.tileID.overscaledZ <= r || m.tileID.overscaledZ > s) continue;
              let v = m.tileID;
              for (; m && m.tileID.overscaledZ > r + 1;) {
                const P = m.tileID.scaledTo(m.tileID.overscaledZ - 1);
                m = this._tiles[P.key], m && m.hasData() && (v = P)
              }
              let w = v;
              for (; w.overscaledZ > r;)
                if (w = w.scaledTo(w.overscaledZ - 1), e[w.key] || e[w.canonical.key]) {
                  c[v.key] = v;
                  break
                }
            }
          }
          findLoadedParent(e, r) {
            if (e.key in this._loadedParentTiles) {
              const s = this._loadedParentTiles[e.key];
              return s && s.tileID.overscaledZ >= r ? s : null
            }
            for (let s = e.overscaledZ - 1; s >= r; s--) {
              const c = e.scaledTo(s),
                d = this._getLoadedTile(c);
              if (d) return d
            }
          }
          findLoadedSibling(e) {
            return this._getLoadedTile(e)
          }
          _getLoadedTile(e) {
            const r = this._tiles[e.key];
            return r && r.hasData() ? r : this._cache.getByKey(e.wrapped().key)
          }
          updateCacheSize(e) {
            const r = Math.ceil(e.width / this._source.tileSize) + 1,
              s = Math.ceil(e.height / this._source.tileSize) + 1,
              c = Math.floor(r * s * (this._maxTileCacheZoomLevels === null ? o.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)),
              d = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, c) : c;
            this._cache.setMaxSize(d)
          }
          handleWrapJump(e) {
            const r = Math.round((e - (this._prevLng === void 0 ? e : this._prevLng)) / 360);
            if (this._prevLng = e, r) {
              const s = {};
              for (const c in this._tiles) {
                const d = this._tiles[c];
                d.tileID = d.tileID.unwrapTo(d.tileID.wrap + r), s[d.tileID.key] = d
              }
              this._tiles = s;
              for (const c in this._timers) clearTimeout(this._timers[c]), delete this._timers[c];
              for (const c in this._tiles) this._setTileReloadTimer(c, this._tiles[c])
            }
          }
          _updateCoveredAndRetainedTiles(e, r, s, c, d, m) {
            const v = {},
              w = {},
              P = Object.keys(e),
              M = fe.now();
            for (const D of P) {
              const L = e[D],
                B = this._tiles[D];
              if (!B || B.fadeEndTime !== 0 && B.fadeEndTime <= M) continue;
              const Z = this.findLoadedParent(L, r),
                te = this.findLoadedSibling(L),
                ee = Z || te || null;
              ee && (this._addTile(ee.tileID), v[ee.tileID.key] = ee.tileID), w[D] = L
            }
            this._retainLoadedChildren(w, c, s, e);
            for (const D in v) e[D] || (this._coveredTiles[D] = !0, e[D] = v[D]);
            if (m) {
              const D = {},
                L = {};
              for (const B of d) this._tiles[B.key].hasData() ? D[B.key] = B : L[B.key] = B;
              for (const B in L) {
                const Z = L[B].children(this._source.maxzoom);
                this._tiles[Z[0].key] && this._tiles[Z[1].key] && this._tiles[Z[2].key] && this._tiles[Z[3].key] && (D[Z[0].key] = e[Z[0].key] = Z[0], D[Z[1].key] = e[Z[1].key] = Z[1], D[Z[2].key] = e[Z[2].key] = Z[2], D[Z[3].key] = e[Z[3].key] = Z[3], delete L[B])
              }
              for (const B in L) {
                const Z = L[B],
                  te = this.findLoadedParent(Z, this._source.minzoom),
                  ee = this.findLoadedSibling(Z),
                  ne = te || ee || null;
                if (ne) {
                  D[ne.tileID.key] = e[ne.tileID.key] = ne.tileID;
                  for (const oe in D) D[oe].isChildOf(ne.tileID) && delete D[oe]
                }
              }
              for (const B in this._tiles) D[B] || (this._coveredTiles[B] = !0)
            }
          }
          update(e, r) {
            if (!this._sourceLoaded || this._paused) return;
            let s;
            this.transform = e, this.terrain = r, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? s = e.getVisibleUnwrappedCoordinates(this._source.tileID).map((M => new o.Z(M.canonical.z, M.wrap, M.canonical.z, M.canonical.x, M.canonical.y))) : (s = ze(e, {
              tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize,
              minzoom: this._source.minzoom,
              maxzoom: this._source.maxzoom,
              roundZoom: !this.usedForTerrain && this._source.roundZoom,
              reparseOverscaled: this._source.reparseOverscaled,
              terrain: r,
              calculateTileZoom: this._source.calculateTileZoom
            }), this._source.hasTile && (s = s.filter((M => this._source.hasTile(M))))) : s = [];
            const c = Ne(e, this._source),
              d = Math.max(c - We.maxOverzooming, this._source.minzoom),
              m = Math.max(c + We.maxUnderzooming, this._source.minzoom);
            if (this.usedForTerrain) {
              const M = {};
              for (const D of s)
                if (D.canonical.z > this._source.minzoom) {
                  const L = D.scaledTo(D.canonical.z - 1);
                  M[L.key] = L;
                  const B = D.scaledTo(Math.max(this._source.minzoom, Math.min(D.canonical.z, 5)));
                  M[B.key] = B
                } s = s.concat(Object.values(M))
            }
            const v = s.length === 0 && !this._updated && this._didEmitContent;
            this._updated = !0, v && this.fire(new o.l("data", {
              sourceDataType: "idle",
              dataType: "source",
              sourceId: this.id
            }));
            const w = this._updateRetainedTiles(s, c);
            Pt(this._source.type) && this._updateCoveredAndRetainedTiles(w, d, m, c, s, r);
            for (const M in w) this._tiles[M].clearFadeHold();
            const P = o.al(this._tiles, w);
            for (const M of P) {
              const D = this._tiles[M];
              D.hasSymbolBuckets && !D.holdingForFade() ? D.setHoldDuration(this.map._fadeDuration) : D.hasSymbolBuckets && !D.symbolFadeFinished() || this._removeTile(M)
            }
            this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache()
          }
          releaseSymbolFadeTiles() {
            for (const e in this._tiles) this._tiles[e].holdingForFade() && this._removeTile(e)
          }
          _updateRetainedTiles(e, r) {
            var s;
            const c = {},
              d = {},
              m = Math.max(r - We.maxOverzooming, this._source.minzoom),
              v = Math.max(r + We.maxUnderzooming, this._source.minzoom),
              w = {};
            for (const P of e) {
              const M = this._addTile(P);
              c[P.key] = P, M.hasData() || r < this._source.maxzoom && (w[P.key] = P)
            }
            this._retainLoadedChildren(w, r, v, c);
            for (const P of e) {
              let M = this._tiles[P.key];
              if (M.hasData()) continue;
              if (r + 1 > this._source.maxzoom) {
                const L = P.children(this._source.maxzoom)[0],
                  B = this.getTile(L);
                if (B && B.hasData()) {
                  c[L.key] = L;
                  continue
                }
              } else {
                const L = P.children(this._source.maxzoom);
                if (c[L[0].key] && c[L[1].key] && c[L[2].key] && c[L[3].key]) continue
              }
              let D = M.wasRequested();
              for (let L = P.overscaledZ - 1; L >= m; --L) {
                const B = P.scaledTo(L);
                if (d[B.key]) break;
                if (d[B.key] = !0, M = this.getTile(B), !M && D && (M = this._addTile(B)), M) {
                  const Z = M.hasData();
                  if ((Z || !(!((s = this.map) === null || s === void 0) && s.cancelPendingTileRequestsWhileZooming) || D) && (c[B.key] = B), D = M.wasRequested(), Z) break
                }
              }
            }
            return c
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const e in this._tiles) {
              const r = [];
              let s, c = this._tiles[e].tileID;
              for (; c.overscaledZ > 0;) {
                if (c.key in this._loadedParentTiles) {
                  s = this._loadedParentTiles[c.key];
                  break
                }
                r.push(c.key);
                const d = c.scaledTo(c.overscaledZ - 1);
                if (s = this._getLoadedTile(d), s) break;
                c = d
              }
              for (const d of r) this._loadedParentTiles[d] = s
            }
          }
          _updateLoadedSiblingTileCache() {
            this._loadedSiblingTiles = {};
            for (const e in this._tiles) {
              const r = this._tiles[e].tileID,
                s = this._getLoadedTile(r);
              this._loadedSiblingTiles[r.key] = s
            }
          }
          _addTile(e) {
            let r = this._tiles[e.key];
            if (r) return r;
            r = this._cache.getAndRemove(e), r && (this._setTileReloadTimer(e.key, r), r.tileID = e, this._state.initializeTileState(r, this.map ? this.map.painter : null), this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, r)));
            const s = r;
            return r || (r = new br(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(r, e.key, r.state)), r.uses++, this._tiles[e.key] = r, s || this._source.fire(new o.l("dataloading", {
              tile: r,
              coord: r.tileID,
              dataType: "source"
            })), r
          }
          _setTileReloadTimer(e, r) {
            e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]);
            const s = r.getExpiryTimeout();
            s && (this._timers[e] = setTimeout((() => {
              this._reloadTile(e, "expired"), delete this._timers[e]
            }), s))
          }
          refreshTiles(e) {
            for (const r in this._tiles)(this._isIdRenderable(r) || this._tiles[r].state == "errored") && e.some((s => s.equals(this._tiles[r].tileID.canonical))) && this._reloadTile(r, "expired")
          }
          _removeTile(e) {
            const r = this._tiles[e];
            r && (r.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), r.uses > 0 || (r.hasData() && r.state !== "reloading" ? this._cache.add(r.tileID, r, r.getExpiryTimeout()) : (r.aborted = !0, this._abortTile(r), this._unloadTile(r))))
          }
          _dataHandler(e) {
            const r = e.sourceDataType;
            e.dataType === "source" && r === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && e.dataType === "source" && r === "content" && (this.reload(e.sourceDataChanged), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0)
          }
          clearTiles() {
            this._shouldReloadOnResume = !1, this._paused = !1;
            for (const e in this._tiles) this._removeTile(e);
            this._cache.reset()
          }
          tilesIn(e, r, s) {
            const c = [],
              d = this.transform;
            if (!d) return c;
            const m = d.getCoveringTilesDetailsProvider().allowWorldCopies(),
              v = s ? d.getCameraQueryGeometry(e) : e,
              w = B => d.screenPointToMercatorCoordinate(B, this.terrain),
              P = this.transformBbox(e, w, !m),
              M = this.transformBbox(v, w, !m),
              D = this.getIds(),
              L = o.a1.fromPoints(M);
            for (let B = 0; B < D.length; B++) {
              const Z = this._tiles[D[B]];
              if (Z.holdingForFade()) continue;
              const te = m ? [Z.tileID] : [Z.tileID.unwrapTo(-1), Z.tileID.unwrapTo(0)],
                ee = Math.pow(2, d.zoom - Z.tileID.overscaledZ),
                ne = r * Z.queryPadding * o.$ / Z.tileSize / ee;
              for (const oe of te) {
                const me = L.map((ue => oe.getTilePoint(new o.a0(ue.x, ue.y))));
                if (me.expandBy(ne), me.intersects(Ie)) {
                  const ue = P.map((Pe => oe.getTilePoint(Pe))),
                    be = M.map((Pe => oe.getTilePoint(Pe)));
                  c.push({
                    tile: Z,
                    tileID: m ? oe : oe.unwrapTo(0),
                    queryGeometry: ue,
                    cameraQueryGeometry: be,
                    scale: ee
                  })
                }
              }
            }
            return c
          }
          transformBbox(e, r, s) {
            let c = e.map(r);
            if (s) {
              const d = o.a1.fromPoints(e);
              d.shrinkBy(.001 * Math.min(d.width(), d.height()));
              const m = d.map(r);
              o.a1.fromPoints(c).covers(m) || (c = c.map((v => v.x > .5 ? new o.a0(v.x - 1, v.y, v.z) : v)))
            }
            return c
          }
          getVisibleCoordinates(e) {
            const r = this.getRenderableIds(e).map((s => this._tiles[s].tileID));
            return this.transform && this.transform.populateCache(r), r
          }
          hasTransition() {
            if (this._source.hasTransition()) return !0;
            if (Pt(this._source.type)) {
              const e = fe.now();
              for (const r in this._tiles)
                if (this._tiles[r].fadeEndTime >= e) return !0
            }
            return !1
          }
          setFeatureState(e, r, s) {
            this._state.updateState(e = e || "_geojsonTileLayer", r, s)
          }
          removeFeatureState(e, r, s) {
            this._state.removeFeatureState(e = e || "_geojsonTileLayer", r, s)
          }
          getFeatureState(e, r) {
            return this._state.getState(e = e || "_geojsonTileLayer", r)
          }
          setDependencies(e, r, s) {
            const c = this._tiles[e];
            c && c.setDependencies(r, s)
          }
          reloadTilesForDependencies(e, r) {
            for (const s in this._tiles) this._tiles[s].hasDependency(e, r) && this._reloadTile(s, "reloading");
            this._cache.filter((s => !s.hasDependency(e, r)))
          }
        }

        function ve(h, e) {
          const r = Math.abs(2 * h.wrap) - +(h.wrap < 0),
            s = Math.abs(2 * e.wrap) - +(e.wrap < 0);
          return h.overscaledZ - e.overscaledZ || s - r || e.canonical.y - h.canonical.y || e.canonical.x - h.canonical.x
        }

        function Pt(h) {
          return h === "raster" || h === "image" || h === "video"
        }
        We.maxOverzooming = 10, We.maxUnderzooming = 3;
        class Xt {
          constructor(e, r) {
            this.reset(e, r)
          }
          reset(e, r) {
            this.points = e || [], this._distances = [0];
            for (let s = 1; s < this.points.length; s++) this._distances[s] = this._distances[s - 1] + this.points[s].dist(this.points[s - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(r || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding
          }
          lerp(e) {
            if (this.points.length === 1) return this.points[0];
            e = o.ag(e, 0, 1);
            let r = 1,
              s = this._distances[r];
            const c = e * this.paddedLength + this.padding;
            for (; s < c && r < this._distances.length;) s = this._distances[++r];
            const d = r - 1,
              m = this._distances[d],
              v = s - m,
              w = v > 0 ? (c - m) / v : 0;
            return this.points[d].mult(1 - w).add(this.points[r].mult(w))
          }
        }

        function Nt(h, e) {
          let r = !0;
          return h === "always" || h !== "never" && e !== "never" || (r = !1), r
        }
        class Ht {
          constructor(e, r, s) {
            const c = this.boxCells = [],
              d = this.circleCells = [];
            this.xCellCount = Math.ceil(e / s), this.yCellCount = Math.ceil(r / s);
            for (let m = 0; m < this.xCellCount * this.yCellCount; m++) c.push([]), d.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = r, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / r, this.boxUid = 0, this.circleUid = 0
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length
          }
          insert(e, r, s, c, d) {
            this._forEachCell(r, s, c, d, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(r), this.bboxes.push(s), this.bboxes.push(c), this.bboxes.push(d)
          }
          insertCircle(e, r, s, c) {
            this._forEachCell(r - c, s - c, r + c, s + c, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(r), this.circles.push(s), this.circles.push(c)
          }
          _insertBoxCell(e, r, s, c, d, m) {
            this.boxCells[d].push(m)
          }
          _insertCircleCell(e, r, s, c, d, m) {
            this.circleCells[d].push(m)
          }
          _query(e, r, s, c, d, m, v) {
            if (s < 0 || e > this.width || c < 0 || r > this.height) return [];
            const w = [];
            if (e <= 0 && r <= 0 && this.width <= s && this.height <= c) {
              if (d) return [{
                key: null,
                x1: e,
                y1: r,
                x2: s,
                y2: c
              }];
              for (let P = 0; P < this.boxKeys.length; P++) w.push({
                key: this.boxKeys[P],
                x1: this.bboxes[4 * P],
                y1: this.bboxes[4 * P + 1],
                x2: this.bboxes[4 * P + 2],
                y2: this.bboxes[4 * P + 3]
              });
              for (let P = 0; P < this.circleKeys.length; P++) {
                const M = this.circles[3 * P],
                  D = this.circles[3 * P + 1],
                  L = this.circles[3 * P + 2];
                w.push({
                  key: this.circleKeys[P],
                  x1: M - L,
                  y1: D - L,
                  x2: M + L,
                  y2: D + L
                })
              }
            } else this._forEachCell(e, r, s, c, this._queryCell, w, {
              hitTest: d,
              overlapMode: m,
              seenUids: {
                box: {},
                circle: {}
              }
            }, v);
            return w
          }
          query(e, r, s, c) {
            return this._query(e, r, s, c, !1, null)
          }
          hitTest(e, r, s, c, d, m) {
            return this._query(e, r, s, c, !0, d, m).length > 0
          }
          hitTestCircle(e, r, s, c, d) {
            const m = e - s,
              v = e + s,
              w = r - s,
              P = r + s;
            if (v < 0 || m > this.width || P < 0 || w > this.height) return !1;
            const M = [];
            return this._forEachCell(m, w, v, P, this._queryCellCircle, M, {
              hitTest: !0,
              overlapMode: c,
              circle: {
                x: e,
                y: r,
                radius: s
              },
              seenUids: {
                box: {},
                circle: {}
              }
            }, d), M.length > 0
          }
          _queryCell(e, r, s, c, d, m, v, w) {
            const {
              seenUids: P,
              hitTest: M,
              overlapMode: D
            } = v, L = this.boxCells[d];
            if (L !== null) {
              const Z = this.bboxes;
              for (const te of L)
                if (!P.box[te]) {
                  P.box[te] = !0;
                  const ee = 4 * te,
                    ne = this.boxKeys[te];
                  if (e <= Z[ee + 2] && r <= Z[ee + 3] && s >= Z[ee + 0] && c >= Z[ee + 1] && (!w || w(ne)) && (!M || !Nt(D, ne.overlapMode)) && (m.push({
                      key: ne,
                      x1: Z[ee],
                      y1: Z[ee + 1],
                      x2: Z[ee + 2],
                      y2: Z[ee + 3]
                    }), M)) return !0
                }
            }
            const B = this.circleCells[d];
            if (B !== null) {
              const Z = this.circles;
              for (const te of B)
                if (!P.circle[te]) {
                  P.circle[te] = !0;
                  const ee = 3 * te,
                    ne = this.circleKeys[te];
                  if (this._circleAndRectCollide(Z[ee], Z[ee + 1], Z[ee + 2], e, r, s, c) && (!w || w(ne)) && (!M || !Nt(D, ne.overlapMode))) {
                    const oe = Z[ee],
                      me = Z[ee + 1],
                      ue = Z[ee + 2];
                    if (m.push({
                        key: ne,
                        x1: oe - ue,
                        y1: me - ue,
                        x2: oe + ue,
                        y2: me + ue
                      }), M) return !0
                  }
                }
            }
            return !1
          }
          _queryCellCircle(e, r, s, c, d, m, v, w) {
            const {
              circle: P,
              seenUids: M,
              overlapMode: D
            } = v, L = this.boxCells[d];
            if (L !== null) {
              const Z = this.bboxes;
              for (const te of L)
                if (!M.box[te]) {
                  M.box[te] = !0;
                  const ee = 4 * te,
                    ne = this.boxKeys[te];
                  if (this._circleAndRectCollide(P.x, P.y, P.radius, Z[ee + 0], Z[ee + 1], Z[ee + 2], Z[ee + 3]) && (!w || w(ne)) && !Nt(D, ne.overlapMode)) return m.push(!0), !0
                }
            }
            const B = this.circleCells[d];
            if (B !== null) {
              const Z = this.circles;
              for (const te of B)
                if (!M.circle[te]) {
                  M.circle[te] = !0;
                  const ee = 3 * te,
                    ne = this.circleKeys[te];
                  if (this._circlesCollide(Z[ee], Z[ee + 1], Z[ee + 2], P.x, P.y, P.radius) && (!w || w(ne)) && !Nt(D, ne.overlapMode)) return m.push(!0), !0
                }
            }
          }
          _forEachCell(e, r, s, c, d, m, v, w) {
            const P = this._convertToXCellCoord(e),
              M = this._convertToYCellCoord(r),
              D = this._convertToXCellCoord(s),
              L = this._convertToYCellCoord(c);
            for (let B = P; B <= D; B++)
              for (let Z = M; Z <= L; Z++)
                if (d.call(this, e, r, s, c, this.xCellCount * Z + B, m, v, w)) return
          }
          _convertToXCellCoord(e) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)))
          }
          _convertToYCellCoord(e) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)))
          }
          _circlesCollide(e, r, s, c, d, m) {
            const v = c - e,
              w = d - r,
              P = s + m;
            return P * P > v * v + w * w
          }
          _circleAndRectCollide(e, r, s, c, d, m, v) {
            const w = (m - c) / 2,
              P = Math.abs(e - (c + w));
            if (P > w + s) return !1;
            const M = (v - d) / 2,
              D = Math.abs(r - (d + M));
            if (D > M + s) return !1;
            if (P <= w || D <= M) return !0;
            const L = P - w,
              B = D - M;
            return L * L + B * B <= s * s
          }
        }

        function or(h, e, r) {
          const s = o.L();
          if (!h) {
            const {
              vecSouth: D,
              vecEast: L
            } = ti(e), B = G();
            B[0] = L[0], B[1] = L[1], B[2] = D[0], B[3] = D[1], c = B, (M = (m = (d = B)[0]) * (P = d[3]) - (w = d[2]) * (v = d[1])) && (c[0] = P * (M = 1 / M), c[1] = -v * M, c[2] = -w * M, c[3] = m * M), s[0] = B[0], s[1] = B[1], s[4] = B[2], s[5] = B[3]
          }
          var c, d, m, v, w, P, M;
          return o.N(s, s, [1 / r, 1 / r, 1]), s
        }

        function ri(h, e, r, s) {
          if (h) {
            const c = o.L();
            if (!e) {
              const {
                vecSouth: d,
                vecEast: m
              } = ti(r);
              c[0] = m[0], c[1] = m[1], c[4] = d[0], c[5] = d[1]
            }
            return o.N(c, c, [s, s, 1]), c
          }
          return r.pixelsToClipSpaceMatrix
        }

        function ti(h) {
          const e = Math.cos(h.rollInRadians),
            r = Math.sin(h.rollInRadians),
            s = Math.cos(h.pitchInRadians),
            c = Math.cos(h.bearingInRadians),
            d = Math.sin(h.bearingInRadians),
            m = o.aq();
          m[0] = -c * s * r - d * e, m[1] = -d * s * r + c * e;
          const v = o.ar(m);
          v < 1e-9 ? o.as(m) : o.at(m, m, 1 / v);
          const w = o.aq();
          w[0] = c * s * e - d * r, w[1] = d * s * e + c * r;
          const P = o.ar(w);
          return P < 1e-9 ? o.as(w) : o.at(w, w, 1 / P), {
            vecEast: w,
            vecSouth: m
          }
        }

        function Wr(h, e, r, s) {
          let c;
          s ? (c = [h, e, s(h, e), 1], o.av(c, c, r)) : (c = [h, e, 0, 1], Ar(c, c, r));
          const d = c[3];
          return {
            point: new o.P(c[0] / d, c[1] / d),
            signedDistanceFromCamera: d,
            isOccluded: !1
          }
        }

        function Cr(h, e) {
          return .5 + h / e * .5
        }

        function ii(h, e) {
          return h.x >= -e[0] && h.x <= e[0] && h.y >= -e[1] && h.y <= e[1]
        }

        function Hi(h, e, r, s, c, d, m, v, w, P, M, D, L) {
          const B = r ? h.textSizeData : h.iconSizeData,
            Z = o.am(B, e.transform.zoom),
            te = [256 / e.width * 2 + 1, 256 / e.height * 2 + 1],
            ee = r ? h.text.dynamicLayoutVertexArray : h.icon.dynamicLayoutVertexArray;
          ee.clear();
          const ne = h.lineVertexArray,
            oe = r ? h.text.placedSymbolArray : h.icon.placedSymbolArray,
            me = e.transform.width / e.transform.height;
          let ue = !1;
          for (let be = 0; be < oe.length; be++) {
            const Pe = oe.get(be);
            if (Pe.hidden || Pe.writingMode === o.an.vertical && !ue) {
              Ti(Pe.numGlyphs, ee);
              continue
            }
            ue = !1;
            const pe = new o.P(Pe.anchorX, Pe.anchorY),
              Fe = {
                getElevation: L,
                pitchedLabelPlaneMatrix: s,
                lineVertexArray: ne,
                pitchWithMap: d,
                projectionCache: {
                  projections: {},
                  offsets: {},
                  cachedAnchorPoint: void 0,
                  anyProjectionOccluded: !1
                },
                transform: e.transform,
                tileAnchorPoint: pe,
                unwrappedTileID: w,
                width: P,
                height: M,
                translation: D
              },
              Je = xr(Pe.anchorX, Pe.anchorY, Fe);
            if (!ii(Je.point, te)) {
              Ti(Pe.numGlyphs, ee);
              continue
            }
            const Ge = Cr(e.transform.cameraToCenterDistance, Je.signedDistanceFromCamera),
              He = o.ao(B, Z, Pe),
              Qe = d ? He * e.transform.getPitchedTextCorrection(Pe.anchorX, Pe.anchorY, w) / Ge : He * Ge,
              qt = nr({
                projectionContext: Fe,
                pitchedLabelPlaneMatrixInverse: c,
                symbol: Pe,
                fontSize: Qe,
                flip: !1,
                keepUpright: m,
                glyphOffsetArray: h.glyphOffsetArray,
                dynamicLayoutVertexArray: ee,
                aspectRatio: me,
                rotateToLine: v
              });
            ue = qt.useVertical, (qt.notEnoughRoom || ue || qt.needsFlipping && nr({
              projectionContext: Fe,
              pitchedLabelPlaneMatrixInverse: c,
              symbol: Pe,
              fontSize: Qe,
              flip: !0,
              keepUpright: m,
              glyphOffsetArray: h.glyphOffsetArray,
              dynamicLayoutVertexArray: ee,
              aspectRatio: me,
              rotateToLine: v
            }).notEnoughRoom) && Ti(Pe.numGlyphs, ee)
          }
          r ? h.text.dynamicLayoutVertexBuffer.updateData(ee) : h.icon.dynamicLayoutVertexBuffer.updateData(ee)
        }

        function je(h, e, r, s, c, d, m, v) {
          const w = d.glyphStartIndex + d.numGlyphs,
            P = d.lineStartIndex,
            M = d.lineStartIndex + d.lineLength,
            D = e.getoffsetX(d.glyphStartIndex),
            L = e.getoffsetX(w - 1),
            B = _i(h * D, r, s, c, d.segment, P, M, v, m);
          if (!B) return null;
          const Z = _i(h * L, r, s, c, d.segment, P, M, v, m);
          return Z ? v.projectionCache.anyProjectionOccluded ? null : {
            first: B,
            last: Z
          } : null
        }

        function Ut(h, e, r, s) {
          return h === o.an.horizontal && Math.abs(r.y - e.y) > Math.abs(r.x - e.x) * s ? {
            useVertical: !0
          } : (h === o.an.vertical ? e.y < r.y : e.x > r.x) ? {
            needsFlipping: !0
          } : null
        }

        function nr(h) {
          const {
            projectionContext: e,
            pitchedLabelPlaneMatrixInverse: r,
            symbol: s,
            fontSize: c,
            flip: d,
            keepUpright: m,
            glyphOffsetArray: v,
            dynamicLayoutVertexArray: w,
            aspectRatio: P,
            rotateToLine: M
          } = h, D = c / 24, L = s.lineOffsetX * D, B = s.lineOffsetY * D;
          let Z;
          if (s.numGlyphs > 1) {
            const te = s.glyphStartIndex + s.numGlyphs,
              ee = s.lineStartIndex,
              ne = s.lineStartIndex + s.lineLength,
              oe = je(D, v, L, B, d, s, M, e);
            if (!oe) return {
              notEnoughRoom: !0
            };
            const me = hr(oe.first.point.x, oe.first.point.y, e, r),
              ue = hr(oe.last.point.x, oe.last.point.y, e, r);
            if (m && !d) {
              const be = Ut(s.writingMode, me, ue, P);
              if (be) return be
            }
            Z = [oe.first];
            for (let be = s.glyphStartIndex + 1; be < te - 1; be++) {
              const Pe = _i(D * v.getoffsetX(be), L, B, d, s.segment, ee, ne, e, M);
              if (!Pe) return {
                notEnoughRoom: !0
              };
              Z.push(Pe)
            }
            Z.push(oe.last)
          } else {
            if (m && !d) {
              const ee = gt(e.tileAnchorPoint.x, e.tileAnchorPoint.y, e).point,
                ne = s.lineStartIndex + s.segment + 1,
                oe = new o.P(e.lineVertexArray.getx(ne), e.lineVertexArray.gety(ne)),
                me = gt(oe.x, oe.y, e),
                ue = me.signedDistanceFromCamera > 0 ? me.point : Gr(e.tileAnchorPoint, oe, ee, 1, e),
                be = hr(ee.x, ee.y, e, r),
                Pe = hr(ue.x, ue.y, e, r),
                pe = Ut(s.writingMode, be, Pe, P);
              if (pe) return pe
            }
            const te = _i(D * v.getoffsetX(s.glyphStartIndex), L, B, d, s.segment, s.lineStartIndex, s.lineStartIndex + s.lineLength, e, M);
            if (!te || e.projectionCache.anyProjectionOccluded) return {
              notEnoughRoom: !0
            };
            Z = [te]
          }
          for (const te of Z) o.au(w, te.point, te.angle);
          return {}
        }

        function Gr(h, e, r, s, c) {
          const d = h.add(h.sub(e)._unit()),
            m = gt(d.x, d.y, c).point,
            v = r.sub(m);
          return r.add(v._mult(s / v.mag()))
        }

        function Xr(h, e, r) {
          const s = e.projectionCache;
          if (s.projections[h]) return s.projections[h];
          const c = new o.P(e.lineVertexArray.getx(h), e.lineVertexArray.gety(h)),
            d = gt(c.x, c.y, e);
          if (d.signedDistanceFromCamera > 0) return s.projections[h] = d.point, s.anyProjectionOccluded = s.anyProjectionOccluded || d.isOccluded, d.point;
          const m = h - r.direction;
          return Gr(r.distanceFromAnchor === 0 ? e.tileAnchorPoint : new o.P(e.lineVertexArray.getx(m), e.lineVertexArray.gety(m)), c, r.previousVertex, r.absOffsetX - r.distanceFromAnchor + 1, e)
        }

        function gt(h, e, r) {
          const s = h + r.translation[0],
            c = e + r.translation[1];
          let d;
          return r.pitchWithMap ? (d = Wr(s, c, r.pitchedLabelPlaneMatrix, r.getElevation), d.isOccluded = !1) : (d = r.transform.projectTileCoordinates(s, c, r.unwrappedTileID, r.getElevation), d.point.x = (.5 * d.point.x + .5) * r.width, d.point.y = (.5 * -d.point.y + .5) * r.height), d
        }

        function hr(h, e, r, s) {
          if (r.pitchWithMap) {
            const c = [h, e, 0, 1];
            return o.av(c, c, s), r.transform.projectTileCoordinates(c[0] / c[3], c[1] / c[3], r.unwrappedTileID, r.getElevation).point
          }
          return {
            x: h / r.width * 2 - 1,
            y: 1 - e / r.height * 2
          }
        }

        function xr(h, e, r) {
          return r.transform.projectTileCoordinates(h, e, r.unwrappedTileID, r.getElevation)
        }

        function ai(h, e, r) {
          return h._unit()._perp()._mult(e * r)
        }

        function ki(h, e, r, s, c, d, m, v, w) {
          if (v.projectionCache.offsets[h]) return v.projectionCache.offsets[h];
          const P = r.add(e);
          if (h + w.direction < s || h + w.direction >= c) return v.projectionCache.offsets[h] = P, P;
          const M = Xr(h + w.direction, v, w),
            D = ai(M.sub(r), m, w.direction),
            L = r.add(D),
            B = M.add(D);
          return v.projectionCache.offsets[h] = o.aw(d, P, L, B) || P, v.projectionCache.offsets[h]
        }

        function _i(h, e, r, s, c, d, m, v, w) {
          const P = s ? h - e : h + e;
          let M = P > 0 ? 1 : -1,
            D = 0;
          s && (M *= -1, D = Math.PI), M < 0 && (D += Math.PI);
          let L, B = M > 0 ? d + c : d + c + 1;
          v.projectionCache.cachedAnchorPoint ? L = v.projectionCache.cachedAnchorPoint : (L = gt(v.tileAnchorPoint.x, v.tileAnchorPoint.y, v).point, v.projectionCache.cachedAnchorPoint = L);
          let Z, te, ee = L,
            ne = L,
            oe = 0,
            me = 0;
          const ue = Math.abs(P),
            be = [];
          let Pe;
          for (; oe + me <= ue;) {
            if (B += M, B < d || B >= m) return null;
            oe += me, ne = ee, te = Z;
            const Je = {
              absOffsetX: ue,
              direction: M,
              distanceFromAnchor: oe,
              previousVertex: ne
            };
            if (ee = Xr(B, v, Je), r === 0) be.push(ne), Pe = ee.sub(ne);
            else {
              let Ge;
              const He = ee.sub(ne);
              Ge = He.mag() === 0 ? ai(Xr(B + M, v, Je).sub(ee), r, M) : ai(He, r, M), te || (te = ne.add(Ge)), Z = ki(B, Ge, ee, d, m, te, r, v, Je), be.push(te), Pe = Z.sub(te)
            }
            me = Pe.mag()
          }
          const pe = Pe._mult((ue - oe) / me)._add(te || ne),
            Fe = D + Math.atan2(ee.y - ne.y, ee.x - ne.x);
          return be.push(pe), {
            point: pe,
            angle: w ? Fe : 0,
            path: be
          }
        }
        const _r = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);

        function Ti(h, e) {
          for (let r = 0; r < h; r++) {
            const s = e.length;
            e.resize(s + 4), e.float32.set(_r, 3 * s)
          }
        }

        function Ar(h, e, r) {
          const s = e[0],
            c = e[1];
          return h[0] = r[0] * s + r[4] * c + r[12], h[1] = r[1] * s + r[5] * c + r[13], h[3] = r[3] * s + r[7] * c + r[15], h
        }
        const qr = 100;
        class fi {
          constructor(e, r = new Ht(e.width + 200, e.height + 200, 25), s = new Ht(e.width + 200, e.height + 200, 25)) {
            this.transform = e, this.grid = r, this.ignoredGrid = s, this.pitchFactor = Math.cos(e.pitch * Math.PI / 180) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + qr, this.screenBottomBoundary = e.height + qr, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.perspectiveRatioCutoff = .6
          }
          placeCollisionBox(e, r, s, c, d, m, v, w, P, M, D, L) {
            const B = this.projectAndGetPerspectiveRatio(e.anchorPointX + w[0], e.anchorPointY + w[1], d, M, L),
              Z = s * B.perspectiveRatio;
            let te;
            if (m || v) te = this._projectCollisionBox(e, Z, c, d, m, v, w, B, M, D, L);
            else {
              const Pe = B.x + (D ? D.x * Z : 0),
                pe = B.y + (D ? D.y * Z : 0);
              te = {
                allPointsOccluded: !1,
                box: [Pe + e.x1 * Z, pe + e.y1 * Z, Pe + e.x2 * Z, pe + e.y2 * Z]
              }
            }
            const [ee, ne, oe, me] = te.box, ue = m ? te.allPointsOccluded : B.isOccluded;
            let be = ue;
            return be || (be = B.perspectiveRatio < this.perspectiveRatioCutoff), be || (be = !this.isInsideGrid(ee, ne, oe, me)), be || r !== "always" && this.grid.hitTest(ee, ne, oe, me, r, P) ? {
              box: [ee, ne, oe, me],
              placeable: !1,
              offscreen: !1,
              occluded: ue
            } : {
              box: [ee, ne, oe, me],
              placeable: !0,
              offscreen: this.isOffscreen(ee, ne, oe, me),
              occluded: ue
            }
          }
          placeCollisionCircles(e, r, s, c, d, m, v, w, P, M, D, L, B, Z) {
            const te = [],
              ee = new o.P(r.anchorX, r.anchorY),
              ne = this.getPerspectiveRatio(ee.x, ee.y, m, Z),
              oe = (P ? d * this.transform.getPitchedTextCorrection(r.anchorX, r.anchorY, m) / ne : d * ne) / o.aA,
              me = {
                getElevation: Z,
                pitchedLabelPlaneMatrix: v,
                lineVertexArray: s,
                pitchWithMap: P,
                projectionCache: {
                  projections: {},
                  offsets: {},
                  cachedAnchorPoint: void 0,
                  anyProjectionOccluded: !1
                },
                transform: this.transform,
                tileAnchorPoint: ee,
                unwrappedTileID: m,
                width: this.transform.width,
                height: this.transform.height,
                translation: B
              },
              ue = je(oe, c, r.lineOffsetX * oe, r.lineOffsetY * oe, !1, r, !1, me);
            let be = !1,
              Pe = !1,
              pe = !0;
            if (ue) {
              const Fe = .5 * D * ne + L,
                Je = new o.P(-100, -100),
                Ge = new o.P(this.screenRightBoundary, this.screenBottomBoundary),
                He = new Xt,
                Qe = ue.first,
                qt = ue.last;
              let Ft = [];
              for (let ei = Qe.path.length - 1; ei >= 1; ei--) Ft.push(Qe.path[ei]);
              for (let ei = 1; ei < qt.path.length; ei++) Ft.push(qt.path[ei]);
              const Tt = 2.5 * Fe;
              if (P) {
                const ei = this.projectPathToScreenSpace(Ft, me);
                Ft = ei.some((xi => xi.signedDistanceFromCamera <= 0)) ? [] : ei.map((xi => xi.point))
              }
              let rr = [];
              if (Ft.length > 0) {
                const ei = Ft[0].clone(),
                  xi = Ft[0].clone();
                for (let qi = 1; qi < Ft.length; qi++) ei.x = Math.min(ei.x, Ft[qi].x), ei.y = Math.min(ei.y, Ft[qi].y), xi.x = Math.max(xi.x, Ft[qi].x), xi.y = Math.max(xi.y, Ft[qi].y);
                rr = ei.x >= Je.x && xi.x <= Ge.x && ei.y >= Je.y && xi.y <= Ge.y ? [Ft] : xi.x < Je.x || ei.x > Ge.x || xi.y < Je.y || ei.y > Ge.y ? [] : o.ax([Ft], Je.x, Je.y, Ge.x, Ge.y)
              }
              for (const ei of rr) {
                He.reset(ei, .25 * Fe);
                let xi = 0;
                xi = He.length <= .5 * Fe ? 1 : Math.ceil(He.paddedLength / Tt) + 1;
                for (let qi = 0; qi < xi; qi++) {
                  const Si = qi / Math.max(xi - 1, 1),
                    Vi = He.lerp(Si),
                    Mi = Vi.x + qr,
                    Pi = Vi.y + qr;
                  te.push(Mi, Pi, Fe, 0);
                  const Ai = Mi - Fe,
                    Tn = Pi - Fe,
                    pi = Mi + Fe,
                    fn = Pi + Fe;
                  if (pe = pe && this.isOffscreen(Ai, Tn, pi, fn), Pe = Pe || this.isInsideGrid(Ai, Tn, pi, fn), e !== "always" && this.grid.hitTestCircle(Mi, Pi, Fe, e, M) && (be = !0, !w)) return {
                    circles: [],
                    offscreen: !1,
                    collisionDetected: be
                  }
                }
              }
            }
            return {
              circles: !w && be || !Pe || ne < this.perspectiveRatioCutoff ? [] : te,
              offscreen: pe,
              collisionDetected: be
            }
          }
          projectPathToScreenSpace(e, r) {
            const s = (function(c, d) {
              const m = o.L();
              return o.ap(m, d.pitchedLabelPlaneMatrix), c.map((v => {
                const w = Wr(v.x, v.y, m, d.getElevation),
                  P = d.transform.projectTileCoordinates(w.point.x, w.point.y, d.unwrappedTileID, d.getElevation);
                return P.point.x = (.5 * P.point.x + .5) * d.width, P.point.y = (.5 * -P.point.y + .5) * d.height, P
              }))
            })(e, r);
            return (function(c) {
              let d = 0,
                m = 0,
                v = 0,
                w = 0;
              for (let P = 0; P < c.length; P++) c[P].isOccluded ? (v = P + 1, w = 0) : (w++, w > m && (m = w, d = v));
              return c.slice(d, d + m)
            })(s)
          }
          queryRenderedSymbols(e) {
            if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
            const r = [],
              s = new o.a1;
            for (const D of e) {
              const L = new o.P(D.x + qr, D.y + qr);
              s.extend(L), r.push(L)
            }
            const {
              minX: c,
              minY: d,
              maxX: m,
              maxY: v
            } = s, w = this.grid.query(c, d, m, v).concat(this.ignoredGrid.query(c, d, m, v)), P = {}, M = {};
            for (const D of w) {
              const L = D.key;
              if (P[L.bucketInstanceId] === void 0 && (P[L.bucketInstanceId] = {}), P[L.bucketInstanceId][L.featureIndex]) continue;
              const B = [new o.P(D.x1, D.y1), new o.P(D.x2, D.y1), new o.P(D.x2, D.y2), new o.P(D.x1, D.y2)];
              o.ay(r, B) && (P[L.bucketInstanceId][L.featureIndex] = !0, M[L.bucketInstanceId] === void 0 && (M[L.bucketInstanceId] = []), M[L.bucketInstanceId].push(L.featureIndex))
            }
            return M
          }
          insertCollisionBox(e, r, s, c, d, m) {
            (s ? this.ignoredGrid : this.grid).insert({
              bucketInstanceId: c,
              featureIndex: d,
              collisionGroupID: m,
              overlapMode: r
            }, e[0], e[1], e[2], e[3])
          }
          insertCollisionCircles(e, r, s, c, d, m) {
            const v = s ? this.ignoredGrid : this.grid,
              w = {
                bucketInstanceId: c,
                featureIndex: d,
                collisionGroupID: m,
                overlapMode: r
              };
            for (let P = 0; P < e.length; P += 4) v.insertCircle(w, e[P], e[P + 1], e[P + 2])
          }
          projectAndGetPerspectiveRatio(e, r, s, c, d) {
            if (d) {
              let m;
              c ? (m = [e, r, c(e, r), 1], o.av(m, m, d)) : (m = [e, r, 0, 1], Ar(m, m, d));
              const v = m[3];
              return {
                x: (m[0] / v + 1) / 2 * this.transform.width + qr,
                y: (-m[1] / v + 1) / 2 * this.transform.height + qr,
                perspectiveRatio: .5 + this.transform.cameraToCenterDistance / v * .5,
                isOccluded: !1,
                signedDistanceFromCamera: v
              }
            } {
              const m = this.transform.projectTileCoordinates(e, r, s, c);
              return {
                x: (m.point.x + 1) / 2 * this.transform.width + qr,
                y: (1 - m.point.y) / 2 * this.transform.height + qr,
                perspectiveRatio: .5 + this.transform.cameraToCenterDistance / m.signedDistanceFromCamera * .5,
                isOccluded: m.isOccluded,
                signedDistanceFromCamera: m.signedDistanceFromCamera
              }
            }
          }
          getPerspectiveRatio(e, r, s, c) {
            const d = this.transform.projectTileCoordinates(e, r, s, c);
            return .5 + this.transform.cameraToCenterDistance / d.signedDistanceFromCamera * .5
          }
          isOffscreen(e, r, s, c) {
            return s < qr || e >= this.screenRightBoundary || c < qr || r > this.screenBottomBoundary
          }
          isInsideGrid(e, r, s, c) {
            return s >= 0 && e < this.gridRightBoundary && c >= 0 && r < this.gridBottomBoundary
          }
          getViewportMatrix() {
            const e = o.af([]);
            return o.M(e, e, [-100, -100, 0]), e
          }
          _projectCollisionBox(e, r, s, c, d, m, v, w, P, M, D) {
            let L = 1,
              B = 0,
              Z = 0,
              te = 1;
            const ee = e.anchorPointX + v[0],
              ne = e.anchorPointY + v[1];
            if (m && !d) {
              const Ft = this.projectAndGetPerspectiveRatio(ee + 1, ne, c, P, D),
                Tt = Ft.x - w.x,
                rr = Math.atan((Ft.y - w.y) / Tt) + (Tt < 0 ? Math.PI : 0),
                ei = Math.sin(rr),
                xi = Math.cos(rr);
              L = xi, B = ei, Z = -ei, te = xi
            } else if (!m && d) {
              const Ft = ti(this.transform);
              L = Ft.vecEast[0], B = Ft.vecEast[1], Z = Ft.vecSouth[0], te = Ft.vecSouth[1]
            }
            let oe = w.x,
              me = w.y,
              ue = r;
            d && (oe = ee, me = ne, ue = Math.pow(2, -(this.transform.zoom - s.overscaledZ)), ue *= this.transform.getPitchedTextCorrection(ee, ne, c), M || (ue *= o.ag(.5 + w.signedDistanceFromCamera / this.transform.cameraToCenterDistance * .5, 0, 4))), M && (oe += L * M.x * ue + Z * M.y * ue, me += B * M.x * ue + te * M.y * ue);
            const be = e.x1 * ue,
              Pe = e.x2 * ue,
              pe = (be + Pe) / 2,
              Fe = e.y1 * ue,
              Je = e.y2 * ue,
              Ge = (Fe + Je) / 2,
              He = [{
                offsetX: be,
                offsetY: Fe
              }, {
                offsetX: pe,
                offsetY: Fe
              }, {
                offsetX: Pe,
                offsetY: Fe
              }, {
                offsetX: Pe,
                offsetY: Ge
              }, {
                offsetX: Pe,
                offsetY: Je
              }, {
                offsetX: pe,
                offsetY: Je
              }, {
                offsetX: be,
                offsetY: Je
              }, {
                offsetX: be,
                offsetY: Ge
              }];
            let Qe = [];
            for (const {
                offsetX: Ft,
                offsetY: Tt
              }
              of He) Qe.push(new o.P(oe + L * Ft + Z * Tt, me + B * Ft + te * Tt));
            let qt = !1;
            if (d) {
              const Ft = Qe.map((Tt => this.projectAndGetPerspectiveRatio(Tt.x, Tt.y, c, P, D)));
              qt = Ft.some((Tt => !Tt.isOccluded)), Qe = Ft.map((Tt => new o.P(Tt.x, Tt.y)))
            } else qt = !0;
            return {
              box: o.az(Qe),
              allPointsOccluded: !qt
            }
          }
        }
        class nn {
          constructor(e, r, s, c) {
            this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? r : -r))) : c && s ? 1 : 0, this.placed = s
          }
          isHidden() {
            return this.opacity === 0 && !this.placed
          }
        }
        class un {
          constructor(e, r, s, c, d) {
            this.text = new nn(e ? e.text : null, r, s, d), this.icon = new nn(e ? e.icon : null, r, c, d)
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden()
          }
        }
        class bt {
          constructor(e, r, s) {
            this.text = e, this.icon = r, this.skipFade = s
          }
        }
        class Rt {
          constructor(e, r, s, c, d) {
            this.bucketInstanceId = e, this.featureIndex = r, this.sourceLayerIndex = s, this.bucketIndex = c, this.tileID = d
          }
        }
        class Zt {
          constructor(e) {
            this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {}
          }
          get(e) {
            if (this.crossSourceCollisions) return {
              ID: 0,
              predicate: null
            };
            if (!this.collisionGroups[e]) {
              const r = ++this.maxGroupID;
              this.collisionGroups[e] = {
                ID: r,
                predicate: s => s.collisionGroupID === r
              }
            }
            return this.collisionGroups[e]
          }
        }

        function hi(h, e, r, s, c) {
          const {
            horizontalAlign: d,
            verticalAlign: m
          } = o.aG(h);
          return new o.P(-(d - .5) * e + s[0] * c, -(m - .5) * r + s[1] * c)
        }
        class gi {
          constructor(e, r, s, c, d) {
            this.transform = e.clone(), this.terrain = r, this.collisionIndex = new fi(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = s, this.retainedQueryData = {}, this.collisionGroups = new Zt(c), this.collisionCircleArrays = {}, this.collisionBoxArrays = new Map, this.prevPlacement = d, d && (d.prevPlacement = void 0), this.placedOrientations = {}
          }
          _getTerrainElevationFunc(e) {
            const r = this.terrain;
            return r ? (s, c) => r.getElevation(e, s, c) : null
          }
          getBucketParts(e, r, s, c) {
            const d = s.getBucket(r),
              m = s.latestFeatureIndex;
            if (!d || !m || r.id !== d.layerIds[0]) return;
            const v = s.collisionBoxArray,
              w = d.layers[0].layout,
              P = d.layers[0].paint,
              M = Math.pow(2, this.transform.zoom - s.tileID.overscaledZ),
              D = s.tileSize / o.$,
              L = s.tileID.toUnwrapped(),
              B = w.get("text-rotation-alignment") === "map",
              Z = o.aB(s, 1, this.transform.zoom),
              te = o.aC(this.collisionIndex.transform, s, P.get("text-translate"), P.get("text-translate-anchor")),
              ee = o.aC(this.collisionIndex.transform, s, P.get("icon-translate"), P.get("icon-translate-anchor")),
              ne = or(B, this.transform, Z);
            this.retainedQueryData[d.bucketInstanceId] = new Rt(d.bucketInstanceId, m, d.sourceLayerIndex, d.index, s.tileID);
            const oe = {
              bucket: d,
              layout: w,
              translationText: te,
              translationIcon: ee,
              unwrappedTileID: L,
              pitchedLabelPlaneMatrix: ne,
              scale: M,
              textPixelRatio: D,
              holdingForFade: s.holdingForFade(),
              collisionBoxArray: v,
              partiallyEvaluatedTextSize: o.am(d.textSizeData, this.transform.zoom),
              collisionGroup: this.collisionGroups.get(d.sourceID)
            };
            if (c)
              for (const me of d.sortKeyRanges) {
                const {
                  sortKey: ue,
                  symbolInstanceStart: be,
                  symbolInstanceEnd: Pe
                } = me;
                e.push({
                  sortKey: ue,
                  symbolInstanceStart: be,
                  symbolInstanceEnd: Pe,
                  parameters: oe
                })
              } else e.push({
                symbolInstanceStart: 0,
                symbolInstanceEnd: d.symbolInstances.length,
                parameters: oe
              })
          }
          attemptAnchorPlacement(e, r, s, c, d, m, v, w, P, M, D, L, B, Z, te, ee, ne, oe, me, ue) {
            const be = o.aD[e.textAnchor],
              Pe = [e.textOffset0, e.textOffset1],
              pe = hi(be, s, c, Pe, d),
              Fe = this.collisionIndex.placeCollisionBox(r, L, w, P, M, v, m, ee, D.predicate, me, pe, ue);
            if ((!oe || this.collisionIndex.placeCollisionBox(oe, L, w, P, M, v, m, ne, D.predicate, me, pe, ue).placeable) && Fe.placeable) {
              let Je;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[B.crossTileID] && this.prevPlacement.placements[B.crossTileID] && this.prevPlacement.placements[B.crossTileID].text && (Je = this.prevPlacement.variableOffsets[B.crossTileID].anchor), B.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[B.crossTileID] = {
                textOffset: Pe,
                width: s,
                height: c,
                anchor: be,
                textBoxScale: d,
                prevAnchor: Je
              }, this.markUsedJustification(Z, be, B, te), Z.allowVerticalPlacement && (this.markUsedOrientation(Z, te, B), this.placedOrientations[B.crossTileID] = te), {
                shift: pe,
                placedGlyphBoxes: Fe
              }
            }
          }
          placeLayerBucketPart(e, r, s) {
            const {
              bucket: c,
              layout: d,
              translationText: m,
              translationIcon: v,
              unwrappedTileID: w,
              pitchedLabelPlaneMatrix: P,
              textPixelRatio: M,
              holdingForFade: D,
              collisionBoxArray: L,
              partiallyEvaluatedTextSize: B,
              collisionGroup: Z
            } = e.parameters, te = d.get("text-optional"), ee = d.get("icon-optional"), ne = o.aE(d, "text-overlap", "text-allow-overlap"), oe = ne === "always", me = o.aE(d, "icon-overlap", "icon-allow-overlap"), ue = me === "always", be = d.get("text-rotation-alignment") === "map", Pe = d.get("text-pitch-alignment") === "map", pe = d.get("icon-text-fit") !== "none", Fe = d.get("symbol-z-order") === "viewport-y", Je = oe && (ue || !c.hasIconData() || ee), Ge = ue && (oe || !c.hasTextData() || te);
            !c.collisionArrays && L && c.deserializeCollisionBoxes(L);
            const He = this.retainedQueryData[c.bucketInstanceId].tileID,
              Qe = this._getTerrainElevationFunc(He),
              qt = this.transform.getFastPathSimpleProjectionMatrix(He),
              Ft = (Tt, rr, ei) => {
                var xi, qi;
                if (r[Tt.crossTileID]) return;
                if (D) return void(this.placements[Tt.crossTileID] = new bt(!1, !1, !1));
                let Si = !1,
                  Vi = !1,
                  Mi = !0,
                  Pi = null,
                  Ai = {
                    box: null,
                    placeable: !1,
                    offscreen: null,
                    occluded: !1
                  },
                  Tn = {
                    placeable: !1
                  },
                  pi = null,
                  fn = null,
                  Cn = null,
                  Ja = 0,
                  Qa = 0,
                  es = 0;
                rr.textFeatureIndex ? Ja = rr.textFeatureIndex : Tt.useRuntimeCollisionCircles && (Ja = Tt.featureIndex), rr.verticalTextFeatureIndex && (Qa = rr.verticalTextFeatureIndex);
                const Ma = rr.textBox;
                if (Ma) {
                  const Hn = Wi => {
                      let Di = o.an.horizontal;
                      if (c.allowVerticalPlacement && !Wi && this.prevPlacement) {
                        const On = this.prevPlacement.placedOrientations[Tt.crossTileID];
                        On && (this.placedOrientations[Tt.crossTileID] = On, Di = On, this.markUsedOrientation(c, Di, Tt))
                      }
                      return Di
                    },
                    ga = (Wi, Di) => {
                      if (c.allowVerticalPlacement && Tt.numVerticalGlyphVertices > 0 && rr.verticalTextBox) {
                        for (const On of c.writingModes)
                          if (On === o.an.vertical ? (Ai = Di(), Tn = Ai) : Ai = Wi(), Ai && Ai.placeable) break
                      } else Ai = Wi()
                    },
                    ts = Tt.textAnchorOffsetStartIndex,
                    gs = Tt.textAnchorOffsetEndIndex;
                  if (gs === ts) {
                    const Wi = (Di, On) => {
                      const sn = this.collisionIndex.placeCollisionBox(Di, ne, M, He, w, Pe, be, m, Z.predicate, Qe, void 0, qt);
                      return sn && sn.placeable && (this.markUsedOrientation(c, On, Tt), this.placedOrientations[Tt.crossTileID] = On), sn
                    };
                    ga((() => Wi(Ma, o.an.horizontal)), (() => {
                      const Di = rr.verticalTextBox;
                      return c.allowVerticalPlacement && Tt.numVerticalGlyphVertices > 0 && Di ? Wi(Di, o.an.vertical) : {
                        box: null,
                        offscreen: null
                      }
                    })), Hn(Ai && Ai.placeable)
                  } else {
                    let Wi = o.aD[(qi = (xi = this.prevPlacement) === null || xi === void 0 ? void 0 : xi.variableOffsets[Tt.crossTileID]) === null || qi === void 0 ? void 0 : qi.anchor];
                    const Di = (sn, rd, yp) => {
                      const eu = sn.x2 - sn.x1,
                        No = sn.y2 - sn.y1,
                        Js = Tt.textBoxScale,
                        Ra = pe && me === "never" ? rd : null;
                      let Sn = null,
                        Ba = ne === "never" ? 1 : 2,
                        tu = "never";
                      Wi && Ba++;
                      for (let rs = 0; rs < Ba; rs++) {
                        for (let ru = ts; ru < gs; ru++) {
                          const iu = c.textAnchorOffsets.get(ru);
                          if (Wi && iu.textAnchor !== Wi) continue;
                          const jo = this.attemptAnchorPlacement(iu, sn, eu, No, Js, be, Pe, M, He, w, Z, tu, Tt, c, yp, m, v, Ra, Qe);
                          if (jo && (Sn = jo.placedGlyphBoxes, Sn && Sn.placeable)) return Si = !0, Pi = jo.shift, Sn
                        }
                        Wi ? Wi = null : tu = ne
                      }
                      return s && !Sn && (Sn = {
                        box: this.collisionIndex.placeCollisionBox(Ma, "always", M, He, w, Pe, be, m, Z.predicate, Qe, void 0, qt).box,
                        offscreen: !1,
                        placeable: !1,
                        occluded: !1
                      }), Sn
                    };
                    ga((() => Di(Ma, rr.iconBox, o.an.horizontal)), (() => {
                      const sn = rr.verticalTextBox;
                      return c.allowVerticalPlacement && (!Ai || !Ai.placeable) && Tt.numVerticalGlyphVertices > 0 && sn ? Di(sn, rr.verticalIconBox, o.an.vertical) : {
                        box: null,
                        occluded: !0,
                        offscreen: null
                      }
                    })), Ai && (Si = Ai.placeable, Mi = Ai.offscreen);
                    const On = Hn(Ai && Ai.placeable);
                    if (!Si && this.prevPlacement) {
                      const sn = this.prevPlacement.variableOffsets[Tt.crossTileID];
                      sn && (this.variableOffsets[Tt.crossTileID] = sn, this.markUsedJustification(c, sn.anchor, Tt, On))
                    }
                  }
                }
                if (pi = Ai, Si = pi && pi.placeable, Mi = pi && pi.offscreen, Tt.useRuntimeCollisionCircles) {
                  const Hn = c.text.placedSymbolArray.get(Tt.centerJustifiedTextSymbolIndex),
                    ga = o.ao(c.textSizeData, B, Hn),
                    ts = d.get("text-padding");
                  fn = this.collisionIndex.placeCollisionCircles(ne, Hn, c.lineVertexArray, c.glyphOffsetArray, ga, w, P, s, Pe, Z.predicate, Tt.collisionCircleDiameter, ts, m, Qe), fn.circles.length && fn.collisionDetected && !s && o.w("Collisions detected, but collision boxes are not shown"), Si = oe || fn.circles.length > 0 && !fn.collisionDetected, Mi = Mi && fn.offscreen
                }
                if (rr.iconFeatureIndex && (es = rr.iconFeatureIndex), rr.iconBox) {
                  const Hn = ga => this.collisionIndex.placeCollisionBox(ga, me, M, He, w, Pe, be, v, Z.predicate, Qe, pe && Pi ? Pi : void 0, qt);
                  Tn && Tn.placeable && rr.verticalIconBox ? (Cn = Hn(rr.verticalIconBox), Vi = Cn.placeable) : (Cn = Hn(rr.iconBox), Vi = Cn.placeable), Mi = Mi && Cn.offscreen
                }
                const Fo = te || Tt.numHorizontalGlyphVertices === 0 && Tt.numVerticalGlyphVertices === 0,
                  Oo = ee || Tt.numIconVertices === 0;
                Fo || Oo ? Oo ? Fo || (Vi = Vi && Si) : Si = Vi && Si : Vi = Si = Vi && Si;
                const Ys = Vi && Cn.placeable;
                if (Si && pi.placeable && this.collisionIndex.insertCollisionBox(pi.box, ne, d.get("text-ignore-placement"), c.bucketInstanceId, Tn && Tn.placeable && Qa ? Qa : Ja, Z.ID), Ys && this.collisionIndex.insertCollisionBox(Cn.box, me, d.get("icon-ignore-placement"), c.bucketInstanceId, es, Z.ID), fn && Si && this.collisionIndex.insertCollisionCircles(fn.circles, ne, d.get("text-ignore-placement"), c.bucketInstanceId, Ja, Z.ID), s && this.storeCollisionData(c.bucketInstanceId, ei, rr, pi, Cn, fn), Tt.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
                if (c.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
                this.placements[Tt.crossTileID] = new bt((Si || Je) && !(pi != null && pi.occluded), (Vi || Ge) && !(Cn != null && Cn.occluded), Mi || c.justReloaded), r[Tt.crossTileID] = !0
              };
            if (Fe) {
              if (e.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
              const Tt = c.getSortedSymbolIndexes(-this.transform.bearingInRadians);
              for (let rr = Tt.length - 1; rr >= 0; --rr) {
                const ei = Tt[rr];
                Ft(c.symbolInstances.get(ei), c.collisionArrays[ei], ei)
              }
            } else
              for (let Tt = e.symbolInstanceStart; Tt < e.symbolInstanceEnd; Tt++) Ft(c.symbolInstances.get(Tt), c.collisionArrays[Tt], Tt);
            c.justReloaded = !1
          }
          storeCollisionData(e, r, s, c, d, m) {
            if (s.textBox || s.iconBox) {
              let v, w;
              this.collisionBoxArrays.has(e) ? v = this.collisionBoxArrays.get(e) : (v = new Map, this.collisionBoxArrays.set(e, v)), v.has(r) ? w = v.get(r) : (w = {
                text: null,
                icon: null
              }, v.set(r, w)), s.textBox && (w.text = c.box), s.iconBox && (w.icon = d.box)
            }
            if (m) {
              let v = this.collisionCircleArrays[e];
              v === void 0 && (v = this.collisionCircleArrays[e] = []);
              for (let w = 0; w < m.circles.length; w += 4) v.push(m.circles[w + 0] - qr), v.push(m.circles[w + 1] - qr), v.push(m.circles[w + 2]), v.push(m.collisionDetected ? 1 : 0)
            }
          }
          markUsedJustification(e, r, s, c) {
            let d;
            d = c === o.an.vertical ? s.verticalPlacedTextSymbolIndex : {
              left: s.leftJustifiedTextSymbolIndex,
              center: s.centerJustifiedTextSymbolIndex,
              right: s.rightJustifiedTextSymbolIndex
            } [o.aF(r)];
            const m = [s.leftJustifiedTextSymbolIndex, s.centerJustifiedTextSymbolIndex, s.rightJustifiedTextSymbolIndex, s.verticalPlacedTextSymbolIndex];
            for (const v of m) v >= 0 && (e.text.placedSymbolArray.get(v).crossTileID = d >= 0 && v !== d ? 0 : s.crossTileID)
          }
          markUsedOrientation(e, r, s) {
            const c = r === o.an.horizontal || r === o.an.horizontalOnly ? r : 0,
              d = r === o.an.vertical ? r : 0,
              m = [s.leftJustifiedTextSymbolIndex, s.centerJustifiedTextSymbolIndex, s.rightJustifiedTextSymbolIndex];
            for (const v of m) e.text.placedSymbolArray.get(v).placedOrientation = c;
            s.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(s.verticalPlacedTextSymbolIndex).placedOrientation = d)
          }
          commit(e) {
            this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const r = this.prevPlacement;
            let s = !1;
            this.prevZoomAdjustment = r ? r.zoomAdjustment(this.transform.zoom) : 0;
            const c = r ? r.symbolFadeChange(e) : 1,
              d = r ? r.opacities : {},
              m = r ? r.variableOffsets : {},
              v = r ? r.placedOrientations : {};
            for (const w in this.placements) {
              const P = this.placements[w],
                M = d[w];
              M ? (this.opacities[w] = new un(M, c, P.text, P.icon), s = s || P.text !== M.text.placed || P.icon !== M.icon.placed) : (this.opacities[w] = new un(null, c, P.text, P.icon, P.skipFade), s = s || P.text || P.icon)
            }
            for (const w in d) {
              const P = d[w];
              if (!this.opacities[w]) {
                const M = new un(P, c, !1, !1);
                M.isHidden() || (this.opacities[w] = M, s = s || P.text.placed || P.icon.placed)
              }
            }
            for (const w in m) this.variableOffsets[w] || !this.opacities[w] || this.opacities[w].isHidden() || (this.variableOffsets[w] = m[w]);
            for (const w in v) this.placedOrientations[w] || !this.opacities[w] || this.opacities[w].isHidden() || (this.placedOrientations[w] = v[w]);
            if (r && r.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
            s ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = r ? r.lastPlacementChangeTime : e)
          }
          updateLayerOpacities(e, r) {
            const s = {};
            for (const c of r) {
              const d = c.getBucket(e);
              d && c.latestFeatureIndex && e.id === d.layerIds[0] && this.updateBucketOpacities(d, c.tileID, s, c.collisionBoxArray)
            }
          }
          updateBucketOpacities(e, r, s, c) {
            e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = !1), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = !1), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
            const d = e.layers[0],
              m = d.layout,
              v = new un(null, 0, !1, !1, !0),
              w = m.get("text-allow-overlap"),
              P = m.get("icon-allow-overlap"),
              M = d._unevaluatedLayout.hasValue("text-variable-anchor") || d._unevaluatedLayout.hasValue("text-variable-anchor-offset"),
              D = m.get("text-rotation-alignment") === "map",
              L = m.get("text-pitch-alignment") === "map",
              B = m.get("icon-text-fit") !== "none",
              Z = new un(null, 0, w && (P || !e.hasIconData() || m.get("icon-optional")), P && (w || !e.hasTextData() || m.get("text-optional")), !0);
            !e.collisionArrays && c && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(c);
            const te = (ne, oe, me) => {
                for (let ue = 0; ue < oe / 4; ue++) ne.opacityVertexArray.emplaceBack(me);
                ne.hasVisibleVertices = ne.hasVisibleVertices || me !== Yr
              },
              ee = this.collisionBoxArrays.get(e.bucketInstanceId);
            for (let ne = 0; ne < e.symbolInstances.length; ne++) {
              const oe = e.symbolInstances.get(ne),
                {
                  numHorizontalGlyphVertices: me,
                  numVerticalGlyphVertices: ue,
                  crossTileID: be
                } = oe;
              let Pe = this.opacities[be];
              s[be] ? Pe = v : Pe || (Pe = Z, this.opacities[be] = Pe), s[be] = !0;
              const pe = oe.numIconVertices > 0,
                Fe = this.placedOrientations[oe.crossTileID],
                Je = Fe === o.an.vertical,
                Ge = Fe === o.an.horizontal || Fe === o.an.horizontalOnly;
              if (me > 0 || ue > 0) {
                const Qe = bi(Pe.text);
                te(e.text, me, Je ? Yr : Qe), te(e.text, ue, Ge ? Yr : Qe);
                const qt = Pe.text.isHidden();
                [oe.rightJustifiedTextSymbolIndex, oe.centerJustifiedTextSymbolIndex, oe.leftJustifiedTextSymbolIndex].forEach((rr => {
                  rr >= 0 && (e.text.placedSymbolArray.get(rr).hidden = qt || Je ? 1 : 0)
                })), oe.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(oe.verticalPlacedTextSymbolIndex).hidden = qt || Ge ? 1 : 0);
                const Ft = this.variableOffsets[oe.crossTileID];
                Ft && this.markUsedJustification(e, Ft.anchor, oe, Fe);
                const Tt = this.placedOrientations[oe.crossTileID];
                Tt && (this.markUsedJustification(e, "left", oe, Tt), this.markUsedOrientation(e, Tt, oe))
              }
              if (pe) {
                const Qe = bi(Pe.icon),
                  qt = !(B && oe.verticalPlacedIconSymbolIndex && Je);
                oe.placedIconSymbolIndex >= 0 && (te(e.icon, oe.numIconVertices, qt ? Qe : Yr), e.icon.placedSymbolArray.get(oe.placedIconSymbolIndex).hidden = Pe.icon.isHidden()), oe.verticalPlacedIconSymbolIndex >= 0 && (te(e.icon, oe.numVerticalIconVertices, qt ? Yr : Qe), e.icon.placedSymbolArray.get(oe.verticalPlacedIconSymbolIndex).hidden = Pe.icon.isHidden())
              }
              const He = ee && ee.has(ne) ? ee.get(ne) : {
                text: null,
                icon: null
              };
              if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
                const Qe = e.collisionArrays[ne];
                if (Qe) {
                  let qt = new o.P(0, 0);
                  if (Qe.textBox || Qe.verticalTextBox) {
                    let Ft = !0;
                    if (M) {
                      const Tt = this.variableOffsets[be];
                      Tt ? (qt = hi(Tt.anchor, Tt.width, Tt.height, Tt.textOffset, Tt.textBoxScale), D && qt._rotate(L ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : Ft = !1
                    }
                    if (Qe.textBox || Qe.verticalTextBox) {
                      let Tt;
                      Qe.textBox && (Tt = Je), Qe.verticalTextBox && (Tt = Ge), Ei(e.textCollisionBox.collisionVertexArray, Pe.text.placed, !Ft || Tt, He.text, qt.x, qt.y)
                    }
                  }
                  if (Qe.iconBox || Qe.verticalIconBox) {
                    const Ft = !!(!Ge && Qe.verticalIconBox);
                    let Tt;
                    Qe.iconBox && (Tt = Ft), Qe.verticalIconBox && (Tt = !Ft), Ei(e.iconCollisionBox.collisionVertexArray, Pe.icon.placed, Tt, He.icon, B ? qt.x : 0, B ? qt.y : 0)
                  }
                }
              }
            }
            if (e.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`);
            if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`);
            e.bucketInstanceId in this.collisionCircleArrays && (e.collisionCircleArray = this.collisionCircleArrays[e.bucketInstanceId], delete this.collisionCircleArrays[e.bucketInstanceId])
          }
          symbolFadeChange(e) {
            return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment
          }
          zoomAdjustment(e) {
            return Math.max(0, (this.transform.zoom - e) / 1.5)
          }
          hasTransitions(e) {
            return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration
          }
          stillRecent(e, r) {
            const s = this.zoomAtLastRecencyCheck === r ? 1 - this.zoomAdjustment(r) : 1;
            return this.zoomAtLastRecencyCheck = r, this.commitTime + this.fadeDuration * s > e
          }
          setStale() {
            this.stale = !0
          }
        }

        function Ei(h, e, r, s, c, d) {
          s && s.length !== 0 || (s = [0, 0, 0, 0]);
          const m = s[0] - qr,
            v = s[1] - qr,
            w = s[2] - qr,
            P = s[3] - qr;
          h.emplaceBack(e ? 1 : 0, r ? 1 : 0, c || 0, d || 0, m, v), h.emplaceBack(e ? 1 : 0, r ? 1 : 0, c || 0, d || 0, w, v), h.emplaceBack(e ? 1 : 0, r ? 1 : 0, c || 0, d || 0, w, P), h.emplaceBack(e ? 1 : 0, r ? 1 : 0, c || 0, d || 0, m, P)
        }
        const si = Math.pow(2, 25),
          vr = Math.pow(2, 24),
          Xi = Math.pow(2, 17),
          Jt = Math.pow(2, 16),
          Vt = Math.pow(2, 9),
          Ur = Math.pow(2, 8),
          Kr = Math.pow(2, 1);

        function bi(h) {
          if (h.opacity === 0 && !h.placed) return 0;
          if (h.opacity === 1 && h.placed) return 4294967295;
          const e = h.placed ? 1 : 0,
            r = Math.floor(127 * h.opacity);
          return r * si + e * vr + r * Xi + e * Jt + r * Vt + e * Ur + r * Kr + e
        }
        const Yr = 0;
        class wi {
          constructor(e) {
            this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = []
          }
          continuePlacement(e, r, s, c, d) {
            const m = this._bucketParts;
            for (; this._currentTileIndex < e.length;)
              if (r.getBucketParts(m, c, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, d()) return !0;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, m.sort(((v, w) => v.sortKey - w.sortKey))); this._currentPartIndex < m.length;)
              if (r.placeLayerBucketPart(m[this._currentPartIndex], this._seenCrossTileIDs, s), this._currentPartIndex++, d()) return !0;
            return !1
          }
        }
        class Fi {
          constructor(e, r, s, c, d, m, v, w) {
            this.placement = new gi(e, r, m, v, w), this._currentPlacementIndex = s.length - 1, this._forceFullPlacement = c, this._showCollisionBoxes = d, this._done = !1
          }
          isDone() {
            return this._done
          }
          continuePlacement(e, r, s) {
            const c = fe.now(),
              d = () => !this._forceFullPlacement && fe.now() - c > 2;
            for (; this._currentPlacementIndex >= 0;) {
              const m = r[e[this._currentPlacementIndex]],
                v = this.placement.collisionIndex.transform.zoom;
              if (m.type === "symbol" && (!m.minzoom || m.minzoom <= v) && (!m.maxzoom || m.maxzoom > v)) {
                if (this._inProgressLayer || (this._inProgressLayer = new wi(m)), this._inProgressLayer.continuePlacement(s[m.source], this.placement, this._showCollisionBoxes, m, d)) return;
                delete this._inProgressLayer
              }
              this._currentPlacementIndex--
            }
            this._done = !0
          }
          commit(e) {
            return this.placement.commit(e), this.placement
          }
        }
        const Ci = 512 / o.$ / 2;
        class zi {
          constructor(e, r, s) {
            this.tileID = e, this.bucketInstanceId = s, this._symbolsByKey = {};
            const c = new Map;
            for (let d = 0; d < r.length; d++) {
              const m = r.get(d),
                v = m.key,
                w = c.get(v);
              w ? w.push(m) : c.set(v, [m])
            }
            for (const [d, m] of c) {
              const v = {
                positions: m.map((w => ({
                  x: Math.floor(w.anchorX * Ci),
                  y: Math.floor(w.anchorY * Ci)
                }))),
                crossTileIDs: m.map((w => w.crossTileID))
              };
              if (v.positions.length > 128) {
                const w = new o.aH(v.positions.length, 16, Uint16Array);
                for (const {
                    x: P,
                    y: M
                  }
                  of v.positions) w.add(P, M);
                w.finish(), delete v.positions, v.index = w
              }
              this._symbolsByKey[d] = v
            }
          }
          getScaledCoordinates(e, r) {
            const {
              x: s,
              y: c,
              z: d
            } = this.tileID.canonical, {
              x: m,
              y: v,
              z: w
            } = r.canonical, P = Ci / Math.pow(2, w - d), M = (v * o.$ + e.anchorY) * P, D = c * o.$ * Ci;
            return {
              x: Math.floor((m * o.$ + e.anchorX) * P - s * o.$ * Ci),
              y: Math.floor(M - D)
            }
          }
          findMatches(e, r, s) {
            const c = this.tileID.canonical.z < r.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - r.canonical.z);
            for (let d = 0; d < e.length; d++) {
              const m = e.get(d);
              if (m.crossTileID) continue;
              const v = this._symbolsByKey[m.key];
              if (!v) continue;
              const w = this.getScaledCoordinates(m, r);
              if (v.index) {
                const P = v.index.range(w.x - c, w.y - c, w.x + c, w.y + c).sort();
                for (const M of P) {
                  const D = v.crossTileIDs[M];
                  if (!s[D]) {
                    s[D] = !0, m.crossTileID = D;
                    break
                  }
                }
              } else if (v.positions)
                for (let P = 0; P < v.positions.length; P++) {
                  const M = v.positions[P],
                    D = v.crossTileIDs[P];
                  if (Math.abs(M.x - w.x) <= c && Math.abs(M.y - w.y) <= c && !s[D]) {
                    s[D] = !0, m.crossTileID = D;
                    break
                  }
                }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map((({
              crossTileIDs: e
            }) => e))
          }
        }
        class Li {
          constructor() {
            this.maxCrossTileID = 0
          }
          generate() {
            return ++this.maxCrossTileID
          }
        }
        class vi {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0
          }
          handleWrapJump(e) {
            const r = Math.round((e - this.lng) / 360);
            if (r !== 0)
              for (const s in this.indexes) {
                const c = this.indexes[s],
                  d = {};
                for (const m in c) {
                  const v = c[m];
                  v.tileID = v.tileID.unwrapTo(v.tileID.wrap + r), d[v.tileID.key] = v
                }
                this.indexes[s] = d
              }
            this.lng = e
          }
          addBucket(e, r, s) {
            if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
              if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === r.bucketInstanceId) return !1;
              this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key])
            }
            for (let d = 0; d < r.symbolInstances.length; d++) r.symbolInstances.get(d).crossTileID = 0;
            this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
            const c = this.usedCrossTileIDs[e.overscaledZ];
            for (const d in this.indexes) {
              const m = this.indexes[d];
              if (Number(d) > e.overscaledZ)
                for (const v in m) {
                  const w = m[v];
                  w.tileID.isChildOf(e) && w.findMatches(r.symbolInstances, e, c)
                } else {
                  const v = m[e.scaledTo(Number(d)).key];
                  v && v.findMatches(r.symbolInstances, e, c)
                }
            }
            for (let d = 0; d < r.symbolInstances.length; d++) {
              const m = r.symbolInstances.get(d);
              m.crossTileID || (m.crossTileID = s.generate(), c[m.crossTileID] = !0)
            }
            return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new zi(e, r.symbolInstances, r.bucketInstanceId), !0
          }
          removeBucketCrossTileIDs(e, r) {
            for (const s of r.getCrossTileIDsLists())
              for (const c of s) delete this.usedCrossTileIDs[e][c]
          }
          removeStaleBuckets(e) {
            let r = !1;
            for (const s in this.indexes) {
              const c = this.indexes[s];
              for (const d in c) e[c[d].bucketInstanceId] || (this.removeBucketCrossTileIDs(s, c[d]), delete c[d], r = !0)
            }
            return r
          }
        }
        class an {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new Li, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {}
          }
          addLayer(e, r, s) {
            let c = this.layerIndexes[e.id];
            c === void 0 && (c = this.layerIndexes[e.id] = new vi);
            let d = !1;
            const m = {};
            c.handleWrapJump(s);
            for (const v of r) {
              const w = v.getBucket(e);
              w && e.id === w.layerIds[0] && (w.bucketInstanceId || (w.bucketInstanceId = ++this.maxBucketInstanceId), c.addBucket(v.tileID, w, this.crossTileIDs) && (d = !0), m[w.bucketInstanceId] = !0)
            }
            return c.removeStaleBuckets(m) && (d = !0), d
          }
          pruneUnusedLayers(e) {
            const r = {};
            e.forEach((s => {
              r[s] = !0
            }));
            for (const s in this.layerIndexes) r[s] || delete this.layerIndexes[s]
          }
        }
        var Jn = "void main() {fragColor=vec4(1.0);}";
        const Ki = {
          prelude: Jr(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`),
          projectionMercator: Jr("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"),
          projectionGlobe: Jr("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`),
          background: Jr(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
          backgroundPattern: Jr(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"),
          circle: Jr(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`),
          clippingMask: Jr(Jn, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
          heatmap: Jr(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`),
          heatmapTexture: Jr(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"),
          collisionBox: Jr("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
          collisionCircle: Jr("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
          colorRelief: Jr(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
          debug: Jr("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"),
          depth: Jr(Jn, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`),
          fill: Jr(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`),
          fillOutline: Jr(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`),
          fillOutlinePattern: Jr(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`),
          fillPattern: Jr(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`),
          fillExtrusion: Jr(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`),
          fillExtrusionPattern: Jr(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`),
          hillshadePrepare: Jr(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
          hillshade: Jr(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
          line: Jr(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
          lineGradient: Jr(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
          linePattern: Jr(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`),
          lineSDF: Jr(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`),
          raster: Jr(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`),
          symbolIcon: Jr(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`),
          symbolSDF: Jr(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`),
          symbolTextAndIcon: Jr(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`),
          terrain: Jr("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"),
          terrainDepth: Jr("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"),
          terrainCoords: Jr("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"),
          projectionErrorMeasurement: Jr("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"),
          atmosphere: Jr(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"),
          sky: Jr("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}")
        };

        function Jr(h, e) {
          const r = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g,
            s = e.match(/in ([\w]+) ([\w]+)/g),
            c = h.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
            d = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
            m = d ? d.concat(c) : c,
            v = {};
          return {
            fragmentSource: h = h.replace(r, ((w, P, M, D, L) => (v[L] = !0, P === "define" ? `
#ifndef HAS_UNIFORM_u_${L}
in ${M} ${D} ${L};
#else
uniform ${M} ${D} u_${L};
#endif
` : `
#ifdef HAS_UNIFORM_u_${L}
    ${M} ${D} ${L} = u_${L};
#endif
`))),
            vertexSource: e = e.replace(r, ((w, P, M, D, L) => {
              const B = D === "float" ? "vec2" : "vec4",
                Z = L.match(/color/) ? "color" : B;
              return v[L] ? P === "define" ? `
#ifndef HAS_UNIFORM_u_${L}
uniform lowp float u_${L}_t;
in ${M} ${B} a_${L};
out ${M} ${D} ${L};
#else
uniform ${M} ${D} u_${L};
#endif
` : Z === "vec4" ? `
#ifndef HAS_UNIFORM_u_${L}
    ${L} = a_${L};
#else
    ${M} ${D} ${L} = u_${L};
#endif
` : `
#ifndef HAS_UNIFORM_u_${L}
    ${L} = unpack_mix_${Z}(a_${L}, u_${L}_t);
#else
    ${M} ${D} ${L} = u_${L};
#endif
` : P === "define" ? `
#ifndef HAS_UNIFORM_u_${L}
uniform lowp float u_${L}_t;
in ${M} ${B} a_${L};
#else
uniform ${M} ${D} u_${L};
#endif
` : Z === "vec4" ? `
#ifndef HAS_UNIFORM_u_${L}
    ${M} ${D} ${L} = a_${L};
#else
    ${M} ${D} ${L} = u_${L};
#endif
` : `
#ifndef HAS_UNIFORM_u_${L}
    ${M} ${D} ${L} = unpack_mix_${Z}(a_${L}, u_${L}_t);
#else
    ${M} ${D} ${L} = u_${L};
#endif
`
            })),
            staticAttributes: s,
            staticUniforms: m
          }
        }
        class Qn {
          constructor(e, r, s) {
            this.vertexBuffer = e, this.indexBuffer = r, this.segments = s
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null
          }
        }
        var oa = o.aI([{
          name: "a_pos",
          type: "Int16",
          components: 2
        }]);
        const pa = "#define PROJECTION_MERCATOR",
          os = "mercator";
        class Ps {
          constructor() {
            this._cachedMesh = null
          }
          get name() {
            return "mercator"
          }
          get useSubdivision() {
            return !1
          }
          get shaderVariantName() {
            return os
          }
          get shaderDefine() {
            return pa
          }
          get shaderPreludeCode() {
            return Ki.projectionMercator
          }
          get vertexShaderPreludeCode() {
            return Ki.projectionMercator.vertexSource
          }
          get subdivisionGranularity() {
            return o.aJ.noSubdivision
          }
          get useGlobeControls() {
            return !1
          }
          get transitionState() {
            return 0
          }
          get latitudeErrorCorrectionRadians() {
            return 0
          }
          destroy() {}
          updateGPUdependent(e) {}
          getMeshFromTileID(e, r, s, c, d) {
            if (this._cachedMesh) return this._cachedMesh;
            const m = new o.aK;
            m.emplaceBack(0, 0), m.emplaceBack(o.$, 0), m.emplaceBack(0, o.$), m.emplaceBack(o.$, o.$);
            const v = e.createVertexBuffer(m, oa.members),
              w = o.aL.simpleSegment(0, 0, 4, 2),
              P = new o.aM;
            P.emplaceBack(1, 0, 2), P.emplaceBack(1, 2, 3);
            const M = e.createIndexBuffer(P);
            return this._cachedMesh = new Qn(v, M, w), this._cachedMesh
          }
          recalculate() {}
          hasTransition() {
            return !1
          }
          setErrorQueryLatitudeDegrees(e) {}
        }
        class Vn {
          constructor(e = 0, r = 0, s = 0, c = 0) {
            if (isNaN(e) || e < 0 || isNaN(r) || r < 0 || isNaN(s) || s < 0 || isNaN(c) || c < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = e, this.bottom = r, this.left = s, this.right = c
          }
          interpolate(e, r, s) {
            return r.top != null && e.top != null && (this.top = o.C.number(e.top, r.top, s)), r.bottom != null && e.bottom != null && (this.bottom = o.C.number(e.bottom, r.bottom, s)), r.left != null && e.left != null && (this.left = o.C.number(e.left, r.left, s)), r.right != null && e.right != null && (this.right = o.C.number(e.right, r.right, s)), this
          }
          getCenter(e, r) {
            const s = o.ag((this.left + e - this.right) / 2, 0, e),
              c = o.ag((this.top + r - this.bottom) / 2, 0, r);
            return new o.P(s, c)
          }
          equals(e) {
            return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right
          }
          clone() {
            return new Vn(this.top, this.bottom, this.left, this.right)
          }
          toJSON() {
            return {
              top: this.top,
              bottom: this.bottom,
              left: this.left,
              right: this.right
            }
          }
        }

        function ea(h, e) {
          if (!h.renderWorldCopies || h.lngRange) return;
          const r = e.lng - h.center.lng;
          e.lng += r > 180 ? -360 : r < -180 ? 360 : 0
        }

        function ni(h) {
          return Math.max(0, Math.floor(h))
        }
        class Ua {
          constructor(e, r, s, c, d, m) {
            this._callbacks = e, this._tileSize = 512, this._renderWorldCopies = m === void 0 || !!m, this._minZoom = r || 0, this._maxZoom = s || 22, this._minPitch = c ?? 0, this._maxPitch = d ?? 60, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new o.S(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = ni(this._zoom), this._scale = o.ae(this._zoom), this._bearingInRadians = 0, this._fovInRadians = .6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new Vn, this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0
          }
          apply(e, r, s) {
            this._latRange = e.latRange, this._lngRange = e.lngRange, this._width = e.width, this._height = e.height, this._center = e.center, this._elevation = e.elevation, this._minElevationForCurrentTile = e.minElevationForCurrentTile, this._zoom = e.zoom, this._tileZoom = ni(this._zoom), this._scale = o.ae(this._zoom), this._bearingInRadians = e.bearingInRadians, this._fovInRadians = e.fovInRadians, this._pitchInRadians = e.pitchInRadians, this._rollInRadians = e.rollInRadians, this._unmodified = e.unmodified, this._edgeInsets = new Vn(e.padding.top, e.padding.bottom, e.padding.left, e.padding.right), this._minZoom = e.minZoom, this._maxZoom = e.maxZoom, this._minPitch = e.minPitch, this._maxPitch = e.maxPitch, this._renderWorldCopies = e.renderWorldCopies, this._cameraToCenterDistance = e.cameraToCenterDistance, this._nearZ = e.nearZ, this._farZ = e.farZ, this._autoCalculateNearFarZ = !s && e.autoCalculateNearFarZ, r && this._constrain(), this._calcMatrices()
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile
          }
          setMinElevationForCurrentTile(e) {
            this._minElevationForCurrentTile = e
          }
          get tileSize() {
            return this._tileSize
          }
          get tileZoom() {
            return this._tileZoom
          }
          get scale() {
            return this._scale
          }
          get width() {
            return this._width
          }
          get height() {
            return this._height
          }
          get bearingInRadians() {
            return this._bearingInRadians
          }
          get lngRange() {
            return this._lngRange
          }
          get latRange() {
            return this._latRange
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits
          }
          get minZoom() {
            return this._minZoom
          }
          setMinZoom(e) {
            this._minZoom !== e && (this._minZoom = e, this.setZoom(this.getConstrained(this._center, this.zoom).zoom))
          }
          get maxZoom() {
            return this._maxZoom
          }
          setMaxZoom(e) {
            this._maxZoom !== e && (this._maxZoom = e, this.setZoom(this.getConstrained(this._center, this.zoom).zoom))
          }
          get minPitch() {
            return this._minPitch
          }
          setMinPitch(e) {
            this._minPitch !== e && (this._minPitch = e, this.setPitch(Math.max(this.pitch, e)))
          }
          get maxPitch() {
            return this._maxPitch
          }
          setMaxPitch(e) {
            this._maxPitch !== e && (this._maxPitch = e, this.setPitch(Math.min(this.pitch, e)))
          }
          get renderWorldCopies() {
            return this._renderWorldCopies
          }
          setRenderWorldCopies(e) {
            e === void 0 ? e = !0 : e === null && (e = !1), this._renderWorldCopies = e
          }
          get worldSize() {
            return this._tileSize * this._scale
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2))
          }
          get size() {
            return new o.P(this._width, this._height)
          }
          get bearing() {
            return this._bearingInRadians / Math.PI * 180
          }
          setBearing(e) {
            const r = o.aN(e, -180, 180) * Math.PI / 180;
            var s, c, d, m, v, w, P, M, D;
            this._bearingInRadians !== r && (this._unmodified = !1, this._bearingInRadians = r, this._calcMatrices(), this._rotationMatrix = G(), s = this._rotationMatrix, d = -this._bearingInRadians, m = (c = this._rotationMatrix)[0], v = c[1], w = c[2], P = c[3], M = Math.sin(d), D = Math.cos(d), s[0] = m * D + w * M, s[1] = v * D + P * M, s[2] = m * -M + w * D, s[3] = v * -M + P * D)
          }
          get rotationMatrix() {
            return this._rotationMatrix
          }
          get pitchInRadians() {
            return this._pitchInRadians
          }
          get pitch() {
            return this._pitchInRadians / Math.PI * 180
          }
          setPitch(e) {
            const r = o.ag(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitchInRadians !== r && (this._unmodified = !1, this._pitchInRadians = r, this._calcMatrices())
          }
          get rollInRadians() {
            return this._rollInRadians
          }
          get roll() {
            return this._rollInRadians / Math.PI * 180
          }
          setRoll(e) {
            const r = e / 180 * Math.PI;
            this._rollInRadians !== r && (this._unmodified = !1, this._rollInRadians = r, this._calcMatrices())
          }
          get fovInRadians() {
            return this._fovInRadians
          }
          get fov() {
            return o.aO(this._fovInRadians)
          }
          setFov(e) {
            e = o.ag(e, .1, 150), this.fov !== e && (this._unmodified = !1, this._fovInRadians = o.ad(e), this._calcMatrices())
          }
          get zoom() {
            return this._zoom
          }
          setZoom(e) {
            const r = this.getConstrained(this._center, e).zoom;
            this._zoom !== r && (this._unmodified = !1, this._zoom = r, this._tileZoom = Math.max(0, Math.floor(r)), this._scale = o.ae(r), this._constrain(), this._calcMatrices())
          }
          get center() {
            return this._center
          }
          setCenter(e) {
            e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this._constrain(), this._calcMatrices())
          }
          get elevation() {
            return this._elevation
          }
          setElevation(e) {
            e !== this._elevation && (this._elevation = e, this._constrain(), this._calcMatrices())
          }
          get padding() {
            return this._edgeInsets.toJSON()
          }
          setPadding(e) {
            this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices())
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height)
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter
          }
          get unmodified() {
            return this._unmodified
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance
          }
          get nearZ() {
            return this._nearZ
          }
          get farZ() {
            return this._farZ
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ
          }
          overrideNearFarZ(e, r) {
            this._autoCalculateNearFarZ = !1, this._nearZ = e, this._farZ = r, this._calcMatrices()
          }
          clearNearFarZOverride() {
            this._autoCalculateNearFarZ = !0, this._calcMatrices()
          }
          isPaddingEqual(e) {
            return this._edgeInsets.equals(e)
          }
          interpolatePadding(e, r, s) {
            this._unmodified = !1, this._edgeInsets.interpolate(e, r, s), this._constrain(), this._calcMatrices()
          }
          resize(e, r, s = !0) {
            this._width = e, this._height = r, s && this._constrain(), this._calcMatrices()
          }
          getMaxBounds() {
            return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new Lt([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null
          }
          setMaxBounds(e) {
            e ? (this._lngRange = [e.getWest(), e.getEast()], this._latRange = [e.getSouth(), e.getNorth()], this._constrain()) : (this._lngRange = null, this._latRange = [-o.ah, o.ah])
          }
          getConstrained(e, r) {
            return this._callbacks.getConstrained(e, r)
          }
          getCameraQueryGeometry(e, r) {
            if (r.length === 1) return [r[0], e];
            {
              const {
                minX: s,
                minY: c,
                maxX: d,
                maxY: m
              } = o.a1.fromPoints(r).extend(e);
              return [new o.P(s, c), new o.P(d, c), new o.P(d, m), new o.P(s, m), new o.P(s, c)]
            }
          }
          _constrain() {
            if (!this.center || !this._width || !this._height || this._constraining) return;
            this._constraining = !0;
            const e = this._unmodified,
              {
                center: r,
                zoom: s
              } = this.getConstrained(this.center, this.zoom);
            this.setCenter(r), this.setZoom(s), this._unmodified = e, this._constraining = !1
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let e = o.af(new Float64Array(16));
              o.N(e, e, [this._width / 2, -this._height / 2, 1]), o.M(e, e, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e, e = o.af(new Float64Array(16)), o.N(e, e, [1, -1, 1]), o.M(e, e, [-1, -1, 0]), o.N(e, e, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e, this._cameraToCenterDistance = .5 / Math.tan(this.fovInRadians / 2) * this._height
            }
            this._callbacks.calcMatrices()
          }
          calculateCenterFromCameraLngLatAlt(e, r, s, c) {
            const d = s !== void 0 ? s : this.bearing,
              m = c = c !== void 0 ? c : this.pitch,
              v = o.a0.fromLngLat(e, r),
              w = -Math.cos(o.ad(m)),
              P = Math.sin(o.ad(m)),
              M = P * Math.sin(o.ad(d)),
              D = -P * Math.cos(o.ad(d));
            let L = this.elevation;
            const B = r - L;
            let Z;
            w * B >= 0 || Math.abs(w) < .1 ? (Z = 1e4, L = r + Z * w) : Z = -B / w;
            let te, ee, ne = o.aP(1, v.y),
              oe = 0;
            do {
              if (oe += 1, oe > 10) break;
              ee = Z / ne, te = new o.a0(v.x + M * ee, v.y + D * ee), ne = 1 / te.meterInMercatorCoordinateUnits()
            } while (Math.abs(Z - ee * ne) > 1e-12);
            return {
              center: te.toLngLat(),
              elevation: L,
              zoom: o.aj(this.height / 2 / Math.tan(this.fovInRadians / 2) / ee / this.tileSize)
            }
          }
          recalculateZoomAndCenter(e) {
            if (this.elevation - e == 0) return;
            const r = o.ai(1, this.center.lat) * this.worldSize,
              s = this.cameraToCenterDistance / r,
              c = o.a0.fromLngLat(this.center, this.elevation),
              d = se(this.center, this.elevation, this.pitch, this.bearing, s);
            this._elevation = e;
            const m = this.calculateCenterFromCameraLngLatAlt(d.toLngLat(), o.aP(d.z, c.y), this.bearing, this.pitch);
            this._elevation = m.elevation, this._center = m.center, this.setZoom(m.zoom)
          }
          getCameraPoint() {
            const e = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new o.P(e * Math.sin(this.rollInRadians), e * Math.cos(this.rollInRadians)))
          }
          getCameraAltitude() {
            return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation
          }
          getCameraLngLat() {
            const e = o.ai(1, this.center.lat) * this.worldSize;
            return se(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e).toLngLat()
          }
          getMercatorTileCoordinates(e) {
            if (!e) return [0, 0, 1, 1];
            const r = e.canonical.z >= 0 ? 1 << e.canonical.z : Math.pow(2, e.canonical.z);
            return [e.canonical.x / r, e.canonical.y / r, 1 / r / o.$, 1 / r / o.$]
          }
        }
        class La {
          constructor(e, r) {
            this.min = e, this.max = r, this.center = o.aQ([], o.aR([], this.min, this.max), .5)
          }
          quadrant(e) {
            const r = [e % 2 == 0, e < 2],
              s = o.aS(this.min),
              c = o.aS(this.max);
            for (let d = 0; d < r.length; d++) s[d] = r[d] ? this.min[d] : this.center[d], c[d] = r[d] ? this.center[d] : this.max[d];
            return c[2] = this.max[2], new La(s, c)
          }
          distanceX(e) {
            return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0]
          }
          distanceY(e) {
            return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1]
          }
          intersectsFrustum(e) {
            let r = !0;
            for (let s = 0; s < e.planes.length; s++) {
              const c = this.intersectsPlane(e.planes[s]);
              if (c === 0) return 0;
              c === 1 && (r = !1)
            }
            return r ? 2 : e.aabb.min[0] > this.max[0] || e.aabb.min[1] > this.max[1] || e.aabb.min[2] > this.max[2] || e.aabb.max[0] < this.min[0] || e.aabb.max[1] < this.min[1] || e.aabb.max[2] < this.min[2] ? 0 : 1
          }
          intersectsPlane(e) {
            let r = e[3],
              s = e[3];
            for (let c = 0; c < 3; c++) e[c] > 0 ? (r += e[c] * this.min[c], s += e[c] * this.max[c]) : (s += e[c] * this.min[c], r += e[c] * this.max[c]);
            return r >= 0 ? 2 : s < 0 ? 0 : 1
          }
        }
        class co {
          distanceToTile2d(e, r, s, c) {
            const d = c.distanceX([e, r]),
              m = c.distanceY([e, r]);
            return Math.hypot(d, m)
          }
          getWrap(e, r, s) {
            return s
          }
          getTileBoundingVolume(e, r, s, c) {
            var d, m;
            let v = s,
              w = s;
            if (c != null && c.terrain) {
              const M = new o.Z(e.z, r, e.z, e.x, e.y),
                D = c.terrain.getMinMaxElevation(M);
              v = (d = D.minElevation) !== null && d !== void 0 ? d : s, w = (m = D.maxElevation) !== null && m !== void 0 ? m : s
            }
            const P = 1 << e.z;
            return new La([r + e.x / P, e.y / P, v], [r + (e.x + 1) / P, (e.y + 1) / P, w])
          }
          allowVariableZoom(e, r) {
            const s = e.fov * (Math.abs(Math.cos(e.rollInRadians)) * e.height + Math.abs(Math.sin(e.rollInRadians)) * e.width) / e.height,
              c = o.ag(78.5 - s / 2, 0, 60);
            return !!r.terrain || e.pitch > c
          }
          allowWorldCopies() {
            return !0
          }
          prepareNextFrame() {}
        }
        class Yi {
          constructor(e, r, s) {
            this.points = e, this.planes = r, this.aabb = s
          }
          static fromInvProjectionMatrix(e, r = 1, s = 0, c, d) {
            const m = d ? [
                [6, 5, 4],
                [0, 1, 2],
                [0, 3, 7],
                [2, 1, 5],
                [3, 2, 6],
                [0, 4, 5]
              ] : [
                [0, 1, 2],
                [6, 5, 4],
                [0, 3, 7],
                [2, 1, 5],
                [3, 2, 6],
                [0, 4, 5]
              ],
              v = Math.pow(2, s),
              w = [
                [-1, 1, -1, 1],
                [1, 1, -1, 1],
                [1, -1, -1, 1],
                [-1, -1, -1, 1],
                [-1, 1, 1, 1],
                [1, 1, 1, 1],
                [1, -1, 1, 1],
                [-1, -1, 1, 1]
              ].map((L => (function(B, Z, te, ee) {
                const ne = o.av([], B, Z),
                  oe = 1 / ne[3] / te * ee;
                return o.aX(ne, ne, [oe, oe, 1 / ne[3], oe])
              })(L, e, r, v)));
            c && (function(L, B, Z, te) {
              const ee = te ? 4 : 0,
                ne = te ? 0 : 4;
              let oe = 0;
              const me = [],
                ue = [];
              for (let pe = 0; pe < 4; pe++) {
                const Fe = o.aT([], L[pe + ne], L[pe + ee]),
                  Je = o.aY(Fe);
                o.aQ(Fe, Fe, 1 / Je), me.push(Je), ue.push(Fe)
              }
              for (let pe = 0; pe < 4; pe++) {
                const Fe = o.aZ(L[pe + ee], ue[pe], Z);
                oe = Fe !== null && Fe >= 0 ? Math.max(oe, Fe) : Math.max(oe, me[pe])
              }
              const be = (function(pe, Fe) {
                  const Je = o.aT([], pe[Fe[0]], pe[Fe[1]]),
                    Ge = o.aT([], pe[Fe[2]], pe[Fe[1]]),
                    He = [0, 0, 0, 0];
                  return o.aU(He, o.aV([], Je, Ge)), He[3] = -o.aW(He, pe[Fe[0]]), He
                })(L, B),
                Pe = (function(pe, Fe) {
                  const Je = o.a_(pe),
                    Ge = o.a$([], pe, 1 / Je),
                    He = o.aT([], Fe, o.aQ([], Ge, o.aW(Fe, Ge))),
                    Qe = o.a_(He);
                  if (Qe > 0) {
                    const qt = Math.sqrt(1 - Ge[3] * Ge[3]),
                      Ft = o.aQ([], Ge, -Ge[3]),
                      Tt = o.aR([], Ft, o.aQ([], He, qt / Qe));
                    return o.b0(Fe, Tt)
                  }
                  return null
                })(Z, be);
              if (Pe !== null) {
                const pe = Pe / o.aW(ue[0], be);
                oe = Math.min(oe, pe)
              }
              for (let pe = 0; pe < 4; pe++) {
                const Fe = Math.min(oe, me[pe]);
                L[pe + ne] = [L[pe + ee][0] + ue[pe][0] * Fe, L[pe + ee][1] + ue[pe][1] * Fe, L[pe + ee][2] + ue[pe][2] * Fe, 1]
              }
            })(w, m[0], c, d);
            const P = m.map((L => {
                const B = o.aT([], w[L[0]], w[L[1]]),
                  Z = o.aT([], w[L[2]], w[L[1]]),
                  te = o.aU([], o.aV([], B, Z)),
                  ee = -o.aW(te, w[L[1]]);
                return te.concat(ee)
              })),
              M = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],
              D = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
            for (const L of w)
              for (let B = 0; B < 3; B++) M[B] = Math.min(M[B], L[B]), D[B] = Math.max(D[B], L[B]);
            return new Yi(w, P, new La(M, D))
          }
        }
        class Oi {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, r, s) {
            return this._helper.interpolatePadding(e, r, s)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, r, s = !0) {
            this._helper.resize(e, r, s)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          overrideNearFarZ(e, r) {
            this._helper.overrideNearFarZ(e, r)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          setTransitionState(e, r) {}
          constructor(e, r, s, c, d) {
            this._posMatrixCache = new Map, this._alignedPosMatrixCache = new Map, this._fogMatrixCacheF32 = new Map, this._helper = new Ua({
              calcMatrices: () => {
                this._calcMatrices()
              },
              getConstrained: (m, v) => this.getConstrained(m, v)
            }, e, r, s, c, d), this._coveringTilesDetailsProvider = new co
          }
          clone() {
            const e = new Oi;
            return e.apply(this), e
          }
          apply(e, r, s) {
            this._helper.apply(e, r, s)
          }
          get cameraPosition() {
            return this._cameraPosition
          }
          get projectionMatrix() {
            return this._projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix
          }
          get mercatorMatrix() {
            return this._mercatorMatrix
          }
          getVisibleUnwrappedCoordinates(e) {
            const r = [new o.b1(0, e)];
            if (this._helper._renderWorldCopies) {
              const s = this.screenPointToMercatorCoordinate(new o.P(0, 0)),
                c = this.screenPointToMercatorCoordinate(new o.P(this._helper._width, 0)),
                d = this.screenPointToMercatorCoordinate(new o.P(this._helper._width, this._helper._height)),
                m = this.screenPointToMercatorCoordinate(new o.P(0, this._helper._height)),
                v = Math.floor(Math.min(s.x, c.x, d.x, m.x)),
                w = Math.floor(Math.max(s.x, c.x, d.x, m.x)),
                P = 1;
              for (let M = v - P; M <= w + P; M++) M !== 0 && r.push(new o.b1(M, e))
            }
            return r
          }
          getCameraFrustum() {
            return Yi.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize)
          }
          getClippingPlane() {
            return null
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider
          }
          recalculateZoomAndCenter(e) {
            const r = this.screenPointToLocation(this.centerPoint, e),
              s = e ? e.getElevationForLngLatZoom(r, this._helper._tileZoom) : 0;
            this._helper.recalculateZoomAndCenter(s)
          }
          setLocationAtPoint(e, r) {
            const s = o.ai(this.elevation, this.center.lat),
              c = this.screenPointToMercatorCoordinateAtZ(r, s),
              d = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, s),
              m = o.a0.fromLngLat(e),
              v = new o.a0(m.x - (c.x - d.x), m.y - (c.y - d.y));
            this.setCenter(v == null ? void 0 : v.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap())
          }
          locationToScreenPoint(e, r) {
            return r ? this.coordinatePoint(o.a0.fromLngLat(e), r.getElevationForLngLatZoom(e, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(o.a0.fromLngLat(e))
          }
          screenPointToLocation(e, r) {
            var s;
            return (s = this.screenPointToMercatorCoordinate(e, r)) === null || s === void 0 ? void 0 : s.toLngLat()
          }
          screenPointToMercatorCoordinate(e, r) {
            if (r) {
              const s = r.pointCoordinate(e);
              if (s != null) return s
            }
            return this.screenPointToMercatorCoordinateAtZ(e)
          }
          screenPointToMercatorCoordinateAtZ(e, r) {
            const s = r || 0,
              c = [e.x, e.y, 0, 1],
              d = [e.x, e.y, 1, 1];
            o.av(c, c, this._pixelMatrixInverse), o.av(d, d, this._pixelMatrixInverse);
            const m = c[3],
              v = d[3],
              w = c[1] / m,
              P = d[1] / v,
              M = c[2] / m,
              D = d[2] / v,
              L = M === D ? 0 : (s - M) / (D - M);
            return new o.a0(o.C.number(c[0] / m, d[0] / v, L) / this.worldSize, o.C.number(w, P, L) / this.worldSize, s)
          }
          coordinatePoint(e, r = 0, s = this._pixelMatrix) {
            const c = [e.x * this.worldSize, e.y * this.worldSize, r, 1];
            return o.av(c, c, s), new o.P(c[0] / c[3], c[1] / c[3])
          }
          getBounds() {
            const e = Math.max(0, this._helper._height / 2 - V(this));
            return new Lt().extend(this.screenPointToLocation(new o.P(0, e))).extend(this.screenPointToLocation(new o.P(this._helper._width, e))).extend(this.screenPointToLocation(new o.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new o.P(0, this._helper._height)))
          }
          isPointOnMapSurface(e, r) {
            return r ? r.pointCoordinate(e) != null : e.y > this.height / 2 - V(this)
          }
          calculatePosMatrix(e, r = !1, s) {
            var c;
            const d = (c = e.key) !== null && c !== void 0 ? c : o.b2(e.wrap, e.canonical.z, e.canonical.z, e.canonical.x, e.canonical.y),
              m = r ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (m.has(d)) {
              const P = m.get(d);
              return s ? P.f32 : P.f64
            }
            const v = X(e, this.worldSize);
            o.O(v, r ? this._alignedProjMatrix : this._viewProjMatrix, v);
            const w = {
              f64: v,
              f32: new Float32Array(v)
            };
            return m.set(d, w), s ? w.f32 : w.f64
          }
          calculateFogMatrix(e) {
            const r = e.key,
              s = this._fogMatrixCacheF32;
            if (s.has(r)) return s.get(r);
            const c = X(e, this.worldSize);
            return o.O(c, this._fogMatrix, c), s.set(r, new Float32Array(c)), s.get(r)
          }
          getConstrained(e, r) {
            r = o.ag(+r, this.minZoom, this.maxZoom);
            const s = {
              center: new o.S(e.lng, e.lat),
              zoom: r
            };
            let c = this._helper._lngRange;
            if (!this._helper._renderWorldCopies && c === null) {
              const me = 179.9999999999;
              c = [-me, me]
            }
            const d = this.tileSize * o.ae(s.zoom);
            let m = 0,
              v = d,
              w = 0,
              P = d,
              M = 0,
              D = 0;
            const {
              x: L,
              y: B
            } = this.size;
            if (this._helper._latRange) {
              const me = this._helper._latRange;
              m = o.U(me[1]) * d, v = o.U(me[0]) * d, v - m < B && (M = B / (v - m))
            }
            c && (w = o.aN(o.V(c[0]) * d, 0, d), P = o.aN(o.V(c[1]) * d, 0, d), P < w && (P += d), P - w < L && (D = L / (P - w)));
            const {
              x: Z,
              y: te
            } = ye(d, e);
            let ee, ne;
            const oe = Math.max(D || 0, M || 0);
            if (oe) {
              const me = new o.P(D ? (P + w) / 2 : Z, M ? (v + m) / 2 : te);
              return s.center = j(d, me).wrap(), s.zoom += o.aj(oe), s
            }
            if (this._helper._latRange) {
              const me = B / 2;
              te - me < m && (ne = m + me), te + me > v && (ne = v - me)
            }
            if (c) {
              const me = (w + P) / 2;
              let ue = Z;
              this._helper._renderWorldCopies && (ue = o.aN(Z, me - d / 2, me + d / 2));
              const be = L / 2;
              ue - be < w && (ee = w + be), ue + be > P && (ee = P - be)
            }
            if (ee !== void 0 || ne !== void 0) {
              const me = new o.P(ee ?? Z, ne ?? te);
              s.center = j(d, me).wrap()
            }
            return s
          }
          calculateCenterFromCameraLngLatAlt(e, r, s, c) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, r, s, c)
          }
          _calculateNearFarZIfNeeded(e, r, s) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const c = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100),
              d = e - c * this._helper._pixelPerMeter / Math.cos(r),
              m = c < 0 ? d : e,
              v = Math.PI / 2 + this.pitchInRadians,
              w = o.ad(this.fov) * (Math.abs(Math.cos(o.ad(this.roll))) * this.height + Math.abs(Math.sin(o.ad(this.roll))) * this.width) / this.height * (.5 + s.y / this.height),
              P = Math.sin(w) * m / Math.sin(o.ag(Math.PI - v - w, .01, Math.PI - .01)),
              M = V(this),
              D = Math.atan(M / this._helper.cameraToCenterDistance),
              L = o.ad(.75),
              B = D > L ? 2 * D * (.5 + s.y / (2 * M)) : L,
              Z = Math.sin(B) * m / Math.sin(o.ag(Math.PI - v - B, .01, Math.PI - .01)),
              te = Math.min(P, Z);
            this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - r) * te + m), this._helper._nearZ = this._helper._height / 50
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const e = this.centerOffset,
              r = ye(this.worldSize, this.center),
              s = r.x,
              c = r.y;
            this._helper._pixelPerMeter = o.ai(1, this.center.lat) * this.worldSize;
            const d = o.ad(Math.min(this.pitch, jr)),
              m = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(d));
            let v;
            this._calculateNearFarZIfNeeded(m, d, e), v = new Float64Array(16), o.b3(v, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), o.ap(this._invProjMatrix, v), v[8] = 2 * -e.x / this._helper._width, v[9] = 2 * e.y / this._helper._height, this._projectionMatrix = o.b4(v), o.N(v, v, [1, -1, 1]), o.M(v, v, [0, 0, -this._helper.cameraToCenterDistance]), o.b5(v, v, -this.rollInRadians), o.b6(v, v, this.pitchInRadians), o.b5(v, v, -this.bearingInRadians), o.M(v, v, [-s, -c, 0]), this._mercatorMatrix = o.N([], v, [this.worldSize, this.worldSize, this.worldSize]), o.N(v, v, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = o.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, v), o.M(v, v, [0, 0, -this.elevation]), this._viewProjMatrix = v, this._invViewProjMatrix = o.ap([], v);
            const w = [0, 0, -1, 1];
            o.av(w, w, this._invViewProjMatrix), this._cameraPosition = [w[0] / w[3], w[1] / w[3], w[2] / w[3]], this._fogMatrix = new Float64Array(16), o.b3(this._fogMatrix, this.fovInRadians, this.width / this.height, m, this._helper._farZ), this._fogMatrix[8] = 2 * -e.x / this.width, this._fogMatrix[9] = 2 * e.y / this.height, o.N(this._fogMatrix, this._fogMatrix, [1, -1, 1]), o.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), o.b5(this._fogMatrix, this._fogMatrix, -this.rollInRadians), o.b6(this._fogMatrix, this._fogMatrix, this.pitchInRadians), o.b5(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), o.M(this._fogMatrix, this._fogMatrix, [-s, -c, 0]), o.N(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), o.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = o.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, v);
            const P = this._helper._width % 2 / 2,
              M = this._helper._height % 2 / 2,
              D = Math.cos(this.bearingInRadians),
              L = Math.sin(-this.bearingInRadians),
              B = s - Math.round(s) + D * P + L * M,
              Z = c - Math.round(c) + D * M + L * P,
              te = new Float64Array(v);
            if (o.M(te, te, [B > .5 ? B - 1 : B, Z > .5 ? Z - 1 : Z, 0]), this._alignedProjMatrix = te, v = o.ap(new Float64Array(16), this._pixelMatrix), !v) throw new Error("failed to invert matrix");
            this._pixelMatrixInverse = v, this._clearMatrixCaches()
          }
          _clearMatrixCaches() {
            this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear()
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const e = this.screenPointToMercatorCoordinate(new o.P(0, 0)),
              r = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
            return o.av(r, r, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            const e = o.ai(1, this.center.lat) * this.worldSize;
            return se(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e).toLngLat()
          }
          lngLatToCameraDepth(e, r) {
            const s = o.a0.fromLngLat(e),
              c = [s.x * this.worldSize, s.y * this.worldSize, r, 1];
            return o.av(c, c, this._viewProjMatrix), c[2] / c[3]
          }
          getProjectionData(e) {
            const {
              overscaledTileID: r,
              aligned: s,
              applyTerrainMatrix: c
            } = e, d = this._helper.getMercatorTileCoordinates(r), m = r ? this.calculatePosMatrix(r, s, !0) : null;
            let v;
            return v = r && r.terrainRttPosMatrix32f && c ? r.terrainRttPosMatrix32f : m || o.b7(), {
              mainMatrix: v,
              tileMercatorCoords: d,
              clippingPlane: [0, 0, 0, 0],
              projectionTransition: 0,
              fallbackMatrix: v
            }
          }
          isLocationOccluded(e) {
            return !1
          }
          getPixelScale() {
            return 1
          }
          getCircleRadiusCorrection() {
            return 1
          }
          getPitchedTextCorrection(e, r, s) {
            return 1
          }
          transformLightDirection(e) {
            return o.aS(e)
          }
          getRayDirectionFromPixel(e) {
            throw new Error("Not implemented.")
          }
          projectTileCoordinates(e, r, s, c) {
            const d = this.calculatePosMatrix(s);
            let m;
            c ? (m = [e, r, c(e, r), 1], o.av(m, m, d)) : (m = [e, r, 0, 1], Ar(m, m, d));
            const v = m[3];
            return {
              point: new o.P(m[0] / v, m[1] / v),
              signedDistanceFromCamera: v,
              isOccluded: !1
            }
          }
          populateCache(e) {
            for (const r of e) this.calculatePosMatrix(r)
          }
          getMatrixForModel(e, r) {
            const s = o.a0.fromLngLat(e, r),
              c = s.meterInMercatorCoordinateUnits(),
              d = o.b8();
            return o.M(d, d, [s.x, s.y, s.z]), o.b5(d, d, Math.PI), o.b6(d, d, Math.PI / 2), o.N(d, d, [-c, c, c]), d
          }
          getProjectionDataForCustomLayer(e = !0) {
            const r = new o.Z(0, 0, 0, 0, 0),
              s = this.getProjectionData({
                overscaledTileID: r,
                applyGlobeMatrix: e
              }),
              c = X(r, this.worldSize);
            o.O(c, this._viewProjMatrix, c), s.tileMercatorCoords = [0, 0, 1, 1];
            const d = [o.$, o.$, this.worldSize / this._helper.pixelsPerMeter],
              m = o.b9();
            return o.N(m, c, d), s.fallbackMatrix = m, s.mainMatrix = m, s
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.calculatePosMatrix(e)
          }
        }

        function hn() {
          o.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.")
        }

        function dn(h) {
          if (h.useSlerp)
            if (h.k < 1) {
              const e = o.ba(h.startEulerAngles.roll, h.startEulerAngles.pitch, h.startEulerAngles.bearing),
                r = o.ba(h.endEulerAngles.roll, h.endEulerAngles.pitch, h.endEulerAngles.bearing),
                s = new Float64Array(4);
              o.bb(s, e, r, h.k);
              const c = o.bc(s);
              h.tr.setRoll(c.roll), h.tr.setPitch(c.pitch), h.tr.setBearing(c.bearing)
            } else h.tr.setRoll(h.endEulerAngles.roll), h.tr.setPitch(h.endEulerAngles.pitch), h.tr.setBearing(h.endEulerAngles.bearing);
          else h.tr.setRoll(o.C.number(h.startEulerAngles.roll, h.endEulerAngles.roll, h.k)), h.tr.setPitch(o.C.number(h.startEulerAngles.pitch, h.endEulerAngles.pitch, h.k)), h.tr.setBearing(o.C.number(h.startEulerAngles.bearing, h.endEulerAngles.bearing, h.k))
        }

        function Ni(h, e, r, s, c) {
          const d = c.padding,
            m = ye(c.worldSize, r.getNorthWest()),
            v = ye(c.worldSize, r.getNorthEast()),
            w = ye(c.worldSize, r.getSouthEast()),
            P = ye(c.worldSize, r.getSouthWest()),
            M = o.ad(-s),
            D = m.rotate(M),
            L = v.rotate(M),
            B = w.rotate(M),
            Z = P.rotate(M),
            te = new o.P(Math.max(D.x, L.x, Z.x, B.x), Math.max(D.y, L.y, Z.y, B.y)),
            ee = new o.P(Math.min(D.x, L.x, Z.x, B.x), Math.min(D.y, L.y, Z.y, B.y)),
            ne = te.sub(ee),
            oe = (c.width - (d.left + d.right + e.left + e.right)) / ne.x,
            me = (c.height - (d.top + d.bottom + e.top + e.bottom)) / ne.y;
          if (me < 0 || oe < 0) return void hn();
          const ue = Math.min(o.aj(c.scale * Math.min(oe, me)), h.maxZoom),
            be = o.P.convert(h.offset),
            Pe = new o.P((e.left - e.right) / 2, (e.top - e.bottom) / 2).rotate(o.ad(s)),
            pe = be.add(Pe).mult(c.scale / o.ae(ue));
          return {
            center: j(c.worldSize, m.add(w).div(2).sub(pe)),
            zoom: ue,
            bearing: s
          }
        }
        class rl {
          get useGlobeControls() {
            return !1
          }
          handlePanInertia(e, r) {
            return {
              easingOffset: e,
              easingCenter: r.center
            }
          }
          handleMapControlsRollPitchBearingZoom(e, r) {
            e.bearingDelta && r.setBearing(r.bearing + e.bearingDelta), e.pitchDelta && r.setPitch(r.pitch + e.pitchDelta), e.rollDelta && r.setRoll(r.roll + e.rollDelta), e.zoomDelta && r.setZoom(r.zoom + e.zoomDelta)
          }
          handleMapControlsPan(e, r, s) {
            e.around.distSqr(r.centerPoint) < .01 || r.setLocationAtPoint(s, e.around)
          }
          cameraForBoxAndBearing(e, r, s, c, d) {
            return Ni(e, r, s, c, d)
          }
          handleJumpToCenterZoom(e, r) {
            e.zoom !== (r.zoom !== void 0 ? +r.zoom : e.zoom) && e.setZoom(+r.zoom), r.center !== void 0 && e.setCenter(o.S.convert(r.center))
          }
          handleEaseTo(e, r) {
            const s = e.zoom,
              c = e.padding,
              d = {
                roll: e.roll,
                pitch: e.pitch,
                bearing: e.bearing
              },
              m = {
                roll: r.roll === void 0 ? e.roll : r.roll,
                pitch: r.pitch === void 0 ? e.pitch : r.pitch,
                bearing: r.bearing === void 0 ? e.bearing : r.bearing
              },
              v = r.zoom !== void 0,
              w = !e.isPaddingEqual(r.padding);
            let P = !1;
            const M = v ? +r.zoom : e.zoom;
            let D = e.centerPoint.add(r.offsetAsPoint);
            const L = e.screenPointToLocation(D),
              {
                center: B,
                zoom: Z
              } = e.getConstrained(o.S.convert(r.center || L), M ?? s);
            ea(e, B);
            const te = ye(e.worldSize, L),
              ee = ye(e.worldSize, B).sub(te),
              ne = o.ae(Z - s);
            return P = Z !== s, {
              easeFunc: oe => {
                if (P && e.setZoom(o.C.number(s, Z, oe)), o.bd(d, m) || dn({
                    startEulerAngles: d,
                    endEulerAngles: m,
                    tr: e,
                    k: oe,
                    useSlerp: d.roll != m.roll
                  }), w && (e.interpolatePadding(c, r.padding, oe), D = e.centerPoint.add(r.offsetAsPoint)), r.around) e.setLocationAtPoint(r.around, r.aroundPoint);
                else {
                  const me = o.ae(e.zoom - s),
                    ue = Z > s ? Math.min(2, ne) : Math.max(.5, ne),
                    be = Math.pow(ue, 1 - oe),
                    Pe = j(e.worldSize, te.add(ee.mult(oe * be)).mult(me));
                  e.setLocationAtPoint(e.renderWorldCopies ? Pe.wrap() : Pe, D)
                }
              },
              isZooming: P,
              elevationCenter: B
            }
          }
          handleFlyTo(e, r) {
            const s = r.zoom !== void 0,
              c = e.zoom,
              d = e.getConstrained(o.S.convert(r.center || r.locationAtOffset), s ? +r.zoom : c),
              m = d.center,
              v = d.zoom;
            ea(e, m);
            const w = ye(e.worldSize, r.locationAtOffset),
              P = ye(e.worldSize, m).sub(w),
              M = P.mag(),
              D = o.ae(v - c);
            let L;
            if (r.minZoom !== void 0) {
              const B = Math.min(+r.minZoom, c, v),
                Z = e.getConstrained(m, B).zoom;
              L = o.ae(Z - c)
            }
            return {
              easeFunc: (B, Z, te, ee) => {
                e.setZoom(B === 1 ? v : c + o.aj(Z));
                const ne = B === 1 ? m : j(e.worldSize, w.add(P.mult(te)).mult(Z));
                e.setLocationAtPoint(e.renderWorldCopies ? ne.wrap() : ne, ee)
              },
              scaleOfZoom: D,
              targetCenter: m,
              scaleOfMinZoom: L,
              pixelPathLength: M
            }
          }
        }
        class di {
          constructor(e, r, s) {
            this.blendFunction = e, this.blendColor = r, this.mask = s
          }
        }
        di.Replace = [1, 0], di.disabled = new di(di.Replace, o.be.transparent, [!1, !1, !1, !1]), di.unblended = new di(di.Replace, o.be.transparent, [!0, !0, !0, !0]), di.alphaBlended = new di([1, 771], o.be.transparent, [!0, !0, !0, !0]);
        const Zn = 2305;
        class Hr {
          constructor(e, r, s) {
            this.enable = e, this.mode = r, this.frontFace = s
          }
        }
        Hr.disabled = new Hr(!1, 1029, Zn), Hr.backCCW = new Hr(!0, 1029, Zn), Hr.frontCCW = new Hr(!0, 1028, Zn);
        class Qr {
          constructor(e, r, s) {
            this.func = e, this.mask = r, this.range = s
          }
        }
        Qr.ReadOnly = !1, Qr.ReadWrite = !0, Qr.disabled = new Qr(519, Qr.ReadOnly, [0, 1]);
        const ls = 7680;
        class Nr {
          constructor(e, r, s, c, d, m) {
            this.test = e, this.ref = r, this.mask = s, this.fail = c, this.depthFail = d, this.pass = m
          }
        }
        Nr.disabled = new Nr({
          func: 519,
          mask: 0
        }, 0, 0, ls, ls, ls);
        const cs = new WeakMap;

        function Dn(h) {
          var e;
          if (cs.has(h)) return cs.get(h);
          {
            const r = (e = h.getParameter(h.VERSION)) === null || e === void 0 ? void 0 : e.startsWith("WebGL 2.0");
            return cs.set(h, r), r
          }
        }
        class Is {
          get awaitingQuery() {
            return !!this._readbackQueue
          }
          constructor(e) {
            this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e;
            const r = e.context,
              s = r.gl;
            this._texFormat = s.RGBA, this._texType = s.UNSIGNED_BYTE;
            const c = new o.aK;
            c.emplaceBack(-1, -1), c.emplaceBack(2, -1), c.emplaceBack(-1, 2);
            const d = new o.aM;
            d.emplaceBack(0, 1, 2), this._fullscreenTriangle = new Qn(r.createVertexBuffer(c, oa.members), r.createIndexBuffer(d), o.aL.simpleSegment(0, 0, c.length, d.length)), this._resultBuffer = new Uint8Array(4), r.activeTexture.set(s.TEXTURE1);
            const m = s.createTexture();
            s.bindTexture(s.TEXTURE_2D, m), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.NEAREST), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, s.NEAREST), s.texImage2D(s.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = r.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(m), Dn(s) && (this._pbo = s.createBuffer(), s.bindBuffer(s.PIXEL_PACK_BUFFER, this._pbo), s.bufferData(s.PIXEL_PACK_BUFFER, 4, s.STREAM_READ), s.bindBuffer(s.PIXEL_PACK_BUFFER, null))
          }
          destroy() {
            const e = this._cachedRenderContext.context.gl;
            this._fullscreenTriangle.destroy(), this._fbo.destroy(), e.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null
          }
          updateErrorLoop(e, r) {
            const s = this._updateCount;
            return this._readbackQueue ? s >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : s >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e, r), this._updateCount++, this._measuredError
          }
          _bindFramebuffer() {
            const e = this._cachedRenderContext.context,
              r = e.gl;
            e.activeTexture.set(r.TEXTURE1), r.bindTexture(r.TEXTURE_2D, this._fbo.colorAttachment.get()), e.bindFramebuffer.set(this._fbo.framebuffer)
          }
          _renderErrorTexture(e, r) {
            const s = this._cachedRenderContext.context,
              c = s.gl;
            if (this._bindFramebuffer(), s.viewport.set([0, 0, this._texWidth, this._texHeight]), s.clear({
                color: o.be.transparent
              }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(s, c.TRIANGLES, Qr.disabled, Nr.disabled, di.unblended, Hr.disabled, ((d, m) => ({
                u_input: d,
                u_output_expected: m
              }))(e, r), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && Dn(c)) {
              c.bindBuffer(c.PIXEL_PACK_BUFFER, this._pbo), c.readBuffer(c.COLOR_ATTACHMENT0), c.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), c.bindBuffer(c.PIXEL_PACK_BUFFER, null);
              const d = c.fenceSync(c.SYNC_GPU_COMMANDS_COMPLETE, 0);
              c.flush(), this._readbackQueue = {
                frameNumberIssued: this._updateCount,
                sync: d
              }
            } else this._readbackQueue = {
              frameNumberIssued: this._updateCount,
              sync: null
            }
          }
          _tryReadback() {
            const e = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && Dn(e)) {
              const r = e.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (r === e.WAIT_FAILED) return o.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void(this._lastReadbackFrame = this._updateCount);
              if (r === e.TIMEOUT_EXPIRED) return;
              e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo), e.getBufferSubData(e.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e.bindBuffer(e.PIXEL_PACK_BUFFER, null)
            } else this._bindFramebuffer(), e.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
            this._readbackQueue = null, this._measuredError = Is._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount
          }
          static _parseRGBA8float(e) {
            let r = 0;
            return r += e[0] / 256, r += e[1] / 65536, r += e[2] / 16777216, e[3] < 127 && (r = -r), r / 128
          }
        }
        const $n = o.$ / 128;

        function fc(h, e) {
          const r = h.granularity !== void 0 ? Math.max(h.granularity, 1) : 1,
            s = r + (h.generateBorders ? 2 : 0),
            c = r + (h.extendToNorthPole || h.generateBorders ? 1 : 0) + (h.extendToSouthPole || h.generateBorders ? 1 : 0),
            d = s + 1,
            m = c + 1,
            v = h.generateBorders ? -1 : 0,
            w = h.generateBorders || h.extendToNorthPole ? -1 : 0,
            P = r + (h.generateBorders ? 1 : 0),
            M = r + (h.generateBorders || h.extendToSouthPole ? 1 : 0),
            D = d * m,
            L = s * c * 6,
            B = d * m > 65536;
          if (B && e === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
          const Z = B || e === "32bit",
            te = new Int16Array(2 * D);
          let ee = 0;
          for (let me = w; me <= M; me++)
            for (let ue = v; ue <= P; ue++) {
              let be = ue / r * o.$;
              ue === -1 && (be = -$n), ue === r + 1 && (be = o.$ + $n);
              let Pe = me / r * o.$;
              me === -1 && (Pe = h.extendToNorthPole ? o.bg : -$n), me === r + 1 && (Pe = h.extendToSouthPole ? o.bh : o.$ + $n), te[ee++] = be, te[ee++] = Pe
            }
          const ne = Z ? new Uint32Array(L) : new Uint16Array(L);
          let oe = 0;
          for (let me = 0; me < c; me++)
            for (let ue = 0; ue < s; ue++) {
              const be = ue + 1 + me * d,
                Pe = ue + (me + 1) * d,
                pe = ue + 1 + (me + 1) * d;
              ne[oe++] = ue + me * d, ne[oe++] = Pe, ne[oe++] = be, ne[oe++] = be, ne[oe++] = Pe, ne[oe++] = pe
            }
          return {
            vertices: te.buffer.slice(0),
            indices: ne.buffer.slice(0),
            uses32bitIndices: Z
          }
        }
        const Ca = new o.aJ({
          fill: new o.bi(128, 2),
          line: new o.bi(512, 0),
          tile: new o.bi(128, 32),
          stencil: new o.bi(128, 1),
          circle: 3
        });
        class gh {
          constructor() {
            this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3
          }
          get name() {
            return "vertical-perspective"
          }
          get transitionState() {
            return 1
          }
          get useSubdivision() {
            return !0
          }
          get shaderVariantName() {
            return "globe"
          }
          get shaderDefine() {
            return "#define GLOBE"
          }
          get shaderPreludeCode() {
            return Ki.projectionGlobe
          }
          get vertexShaderPreludeCode() {
            return Ki.projectionMercator.vertexSource
          }
          get subdivisionGranularity() {
            return Ca
          }
          get useGlobeControls() {
            return !0
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy()
          }
          updateGPUdependent(e) {
            this._errorMeasurement || (this._errorMeasurement = new Is(e));
            const r = o.U(this._errorQueryLatitudeDegrees),
              s = 2 * Math.atan(Math.exp(Math.PI - r * Math.PI * 2)) - .5 * Math.PI,
              c = this._errorMeasurement.updateErrorLoop(r, s),
              d = fe.now();
            c !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = c, this._errorMeasurementLastChangeTime = d);
            const m = Math.min(Math.max((d - this._errorMeasurementLastChangeTime) / 1e3 / .5, 0), 1);
            this._errorCorrectionUsable = o.bj(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, o.bk(m))
          }
          _getMeshKey(e) {
            return `${e.granularity.toString(36)}_${e.generateBorders?"b":""}${e.extendToNorthPole?"n":""}${e.extendToSouthPole?"s":""}`
          }
          getMeshFromTileID(e, r, s, c, d) {
            const m = (d === "stencil" ? Ca.stencil : Ca.tile).getGranularityForZoomLevel(r.z);
            return this._getMesh(e, {
              granularity: m,
              generateBorders: s,
              extendToNorthPole: r.y === 0 && c,
              extendToSouthPole: r.y === (1 << r.z) - 1 && c
            })
          }
          _getMesh(e, r) {
            const s = this._getMeshKey(r);
            if (s in this._tileMeshCache) return this._tileMeshCache[s];
            const c = (function(d, m) {
              const v = fc(m, "16bit"),
                w = o.aK.deserialize({
                  arrayBuffer: v.vertices,
                  length: v.vertices.byteLength / 2 / 2
                }),
                P = o.aM.deserialize({
                  arrayBuffer: v.indices,
                  length: v.indices.byteLength / 2 / 3
                });
              return new Qn(d.createVertexBuffer(w, oa.members), d.createIndexBuffer(P), o.aL.simpleSegment(0, 0, w.length, P.length))
            })(e, r);
            return this._tileMeshCache[s] = c, c
          }
          recalculate(e) {}
          hasTransition() {
            const e = fe.now();
            let r = !1;
            return r = r || (e - this._errorMeasurementLastChangeTime) / 1e3 < .7, r = r || this._errorMeasurement && this._errorMeasurement.awaitingQuery, r
          }
          setErrorQueryLatitudeDegrees(e) {
            this._errorQueryLatitudeDegrees = e
          }
        }
        const vh = new o.r({
          type: new o.D(o.v.projection.type)
        });
        class uo extends o.E {
          constructor(e) {
            super(), this._transitionable = new o.t(vh), this.setProjection(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new o.F(0)), this._mercatorProjection = new Ps, this._verticalPerspectiveProjection = new gh
          }
          get transitionState() {
            const e = this.properties.get("type");
            if (typeof e == "string" && e === "mercator") return 0;
            if (typeof e == "string" && e === "vertical-perspective") return 1;
            if (e instanceof o.bl) {
              if (e.from === "vertical-perspective" && e.to === "mercator") return 1 - e.transition;
              if (e.from === "mercator" && e.to === "vertical-perspective") return e.transition
            }
            return 1
          }
          get useGlobeRendering() {
            return this.transitionState > 0
          }
          get latitudeErrorCorrectionRadians() {
            return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians
          }
          get currentProjection() {
            return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection
          }
          get name() {
            return "globe"
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity
          }
          get useGlobeControls() {
            return this.transitionState > 0
          }
          destroy() {
            this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy()
          }
          updateGPUdependent(e) {
            this._mercatorProjection.updateGPUdependent(e), this._verticalPerspectiveProjection.updateGPUdependent(e)
          }
          getMeshFromTileID(e, r, s, c, d) {
            return this.currentProjection.getMeshFromTileID(e, r, s, c, d)
          }
          setProjection(e) {
            this._transitionable.setValue("type", (e == null ? void 0 : e.type) || "mercator")
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning)
          }
          hasTransition() {
            return this._transitioning.hasTransition() || this.currentProjection.hasTransition()
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e)
          }
          setErrorQueryLatitudeDegrees(e) {
            this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e), this._mercatorProjection.setErrorQueryLatitudeDegrees(e)
          }
        }

        function ho(h) {
          const e = Ms(h.worldSize, h.center.lat);
          return 2 * Math.PI * e
        }

        function fa(h, e, r, s, c) {
          const d = 1 / (1 << c),
            m = e / o.$ * d + s * d,
            v = o.bn((h / o.$ * d + r * d) * Math.PI * 2 + Math.PI, 2 * Math.PI),
            w = 2 * Math.atan(Math.exp(Math.PI - m * Math.PI * 2)) - .5 * Math.PI,
            P = Math.cos(w),
            M = new Float64Array(3);
          return M[0] = Math.sin(v) * P, M[1] = Math.sin(w), M[2] = Math.cos(v) * P, M
        }

        function pn(h) {
          return (function(e, r) {
            const s = Math.cos(r),
              c = new Float64Array(3);
            return c[0] = Math.sin(e) * s, c[1] = Math.sin(r), c[2] = Math.cos(e) * s, c
          })(h.lng * Math.PI / 180, h.lat * Math.PI / 180)
        }

        function Ms(h, e) {
          return h / (2 * Math.PI) / Math.cos(e * Math.PI / 180)
        }

        function po(h) {
          const e = Math.asin(h[1]) / Math.PI * 180,
            r = Math.sqrt(h[0] * h[0] + h[2] * h[2]);
          if (r > 1e-6) {
            const s = h[0] / r,
              c = Math.acos(h[2] / r),
              d = (s > 0 ? c : -c) / Math.PI * 180;
            return new o.S(o.aN(d, -180, 180), e)
          }
          return new o.S(0, e)
        }

        function As(h) {
          return Math.cos(h * Math.PI / 180)
        }

        function tn(h, e) {
          const r = As(h),
            s = As(e);
          return o.aj(s / r)
        }

        function fo(h, e) {
          const r = h.rotate(e.bearingInRadians),
            s = e.zoom + tn(e.center.lat, 0),
            c = o.bj(1 / As(e.center.lat), 1 / As(Math.min(Math.abs(e.center.lat), 60)), o.bm(s, 7, 3, 0, 1)),
            d = 360 / ho({
              worldSize: e.worldSize,
              center: {
                lat: e.center.lat
              }
            });
          return new o.S(e.center.lng - r.x * d * c, o.ag(e.center.lat + r.y * d, -o.ah, o.ah))
        }

        function ks(h) {
          const e = .5 * h,
            r = Math.sin(e),
            s = Math.cos(e);
          return Math.log(r + s) - Math.log(s - r)
        }

        function Es(h, e, r, s) {
          const c = h.lat + r * s;
          if (Math.abs(r) > 1) {
            const d = (Math.sign(h.lat + r) !== Math.sign(h.lat) ? -Math.abs(h.lat) : Math.abs(h.lat)) * Math.PI / 180,
              m = Math.abs(h.lat + r) * Math.PI / 180,
              v = ks(d + s * (m - d)),
              w = ks(d),
              P = ks(m);
            return new o.S(h.lng + e * ((v - w) / (P - w)), c)
          }
          return new o.S(h.lng + e * s, c)
        }
        class Wd {
          constructor(e) {
            this._cachePrevious = new Map, this._cache = new Map, this._hadAnyChanges = !1, this._boundingVolumeFactory = e
          }
          swapBuffers() {
            if (!this._hadAnyChanges) return;
            const e = this._cachePrevious;
            this._cachePrevious = this._cache, this._cache = e, this._cache.clear(), this._hadAnyChanges = !1
          }
          getTileBoundingVolume(e, r, s, c) {
            const d = `${e.z}_${e.x}_${e.y}_${c!=null&&c.terrain?"t":""}`,
              m = this._cache.get(d);
            if (m) return m;
            const v = this._cachePrevious.get(d);
            if (v) return this._cache.set(d, v), v;
            const w = this._boundingVolumeFactory(e, r, s, c);
            return this._cache.set(d, w), this._hadAnyChanges = !0, w
          }
        }
        class Ga {
          constructor(e, r, s, c) {
            this.min = s, this.max = c, this.points = e, this.planes = r
          }
          static fromAabb(e, r) {
            const s = [];
            for (let c = 0; c < 8; c++) s.push([1 & ~c ? e[0] : r[0], (c >> 1 & 1) == 1 ? r[1] : e[1], (c >> 2 & 1) == 1 ? r[2] : e[2]]);
            return new Ga(s, [
              [-1, 0, 0, r[0]],
              [1, 0, 0, -e[0]],
              [0, -1, 0, r[1]],
              [0, 1, 0, -e[1]],
              [0, 0, -1, r[2]],
              [0, 0, 1, -e[2]]
            ], e, r)
          }
          static fromCenterSizeAngles(e, r, s) {
            const c = o.bq([], s[0], s[1], s[2]),
              d = o.br([], [r[0], 0, 0], c),
              m = o.br([], [0, r[1], 0], c),
              v = o.br([], [0, 0, r[2]], c),
              w = [...e],
              P = [...e];
            for (let D = 0; D < 8; D++)
              for (let L = 0; L < 3; L++) {
                const B = e[L] + d[L] * (1 & ~D ? -1 : 1) + m[L] * ((D >> 1 & 1) == 1 ? 1 : -1) + v[L] * ((D >> 2 & 1) == 1 ? 1 : -1);
                w[L] = Math.min(w[L], B), P[L] = Math.max(P[L], B)
              }
            const M = [];
            for (let D = 0; D < 8; D++) {
              const L = [...e];
              o.aR(L, L, o.aQ([], d, 1 & ~D ? -1 : 1)), o.aR(L, L, o.aQ([], m, (D >> 1 & 1) == 1 ? 1 : -1)), o.aR(L, L, o.aQ([], v, (D >> 2 & 1) == 1 ? 1 : -1)), M.push(L)
            }
            return new Ga(M, [
              [...d, -o.aW(d, M[0])],
              [...m, -o.aW(m, M[0])],
              [...v, -o.aW(v, M[0])],
              [-d[0], -d[1], -d[2], -o.aW(d, M[7])],
              [-m[0], -m[1], -m[2], -o.aW(m, M[7])],
              [-v[0], -v[1], -v[2], -o.aW(v, M[7])]
            ], w, P)
          }
          intersectsFrustum(e) {
            let r = !0;
            const s = this.points.length,
              c = this.planes.length,
              d = e.planes.length,
              m = e.points.length;
            for (let v = 0; v < d; v++) {
              const w = e.planes[v];
              let P = 0;
              for (let M = 0; M < s; M++) {
                const D = this.points[M];
                w[0] * D[0] + w[1] * D[1] + w[2] * D[2] + w[3] >= 0 && P++
              }
              if (P === 0) return 0;
              P < s && (r = !1)
            }
            if (r) return 2;
            for (let v = 0; v < c; v++) {
              const w = this.planes[v];
              let P = 0;
              for (let M = 0; M < m; M++) {
                const D = e.points[M];
                w[0] * D[0] + w[1] * D[1] + w[2] * D[2] + w[3] >= 0 && P++
              }
              if (P === 0) return 0
            }
            return 1
          }
          intersectsPlane(e) {
            const r = this.points.length;
            let s = 0;
            for (let c = 0; c < r; c++) {
              const d = this.points[c];
              e[0] * d[0] + e[1] * d[1] + e[2] * d[2] + e[3] >= 0 && s++
            }
            return s === r ? 2 : s === 0 ? 0 : 1
          }
        }

        function mo(h, e, r) {
          const s = h - e;
          return s < 0 ? -s : Math.max(0, s - r)
        }

        function mc(h, e, r, s, c) {
          const d = h - r;
          let m;
          return m = d < 0 ? Math.min(-d, 1 + d - c) : d > 1 ? Math.min(Math.max(d - c, 0), 1 - d) : 0, Math.max(m, mo(e, s, c))
        }
        class Xd {
          constructor() {
            this._boundingVolumeCache = new Wd(this._computeTileBoundingVolume)
          }
          prepareNextFrame() {
            this._boundingVolumeCache.swapBuffers()
          }
          distanceToTile2d(e, r, s, c) {
            const d = 1 << s.z,
              m = 1 / d,
              v = s.x / d,
              w = s.y / d;
            let P = 2;
            return P = Math.min(P, mc(e, r, v, w, m)), P = Math.min(P, mc(e, r, v + .5, -w - m, m)), P = Math.min(P, mc(e, r, v + .5, 2 - w - m, m)), P
          }
          getWrap(e, r, s) {
            const c = 1 << r.z,
              d = 1 / c,
              m = r.x / c,
              v = mo(e.x, m, d),
              w = mo(e.x, m - 1, d),
              P = mo(e.x, m + 1, d),
              M = Math.min(v, w, P);
            return M === P ? 1 : M === w ? -1 : 0
          }
          allowVariableZoom(e, r) {
            return Ne(e, r) > 4
          }
          allowWorldCopies() {
            return !1
          }
          getTileBoundingVolume(e, r, s, c) {
            return this._boundingVolumeCache.getTileBoundingVolume(e, r, s, c)
          }
          _computeTileBoundingVolume(e, r, s, c) {
            var d, m;
            let v = s,
              w = s;
            if (c != null && c.terrain) {
              const P = new o.Z(e.z, r, e.z, e.x, e.y),
                M = c.terrain.getMinMaxElevation(P);
              v = (d = M.minElevation) !== null && d !== void 0 ? d : s, w = (m = M.maxElevation) !== null && m !== void 0 ? m : s
            }
            if (v /= o.bt, w /= o.bt, v += 1, w += 1, e.z <= 0) return Ga.fromAabb([-w, -w, -w], [w, w, w]);
            if (e.z === 1) return Ga.fromAabb([e.x === 0 ? -w : 0, e.y === 0 ? 0 : -w, -w], [e.x === 0 ? 0 : w, e.y === 0 ? w : 0, w]);
            {
              const P = [fa(0, 0, e.x, e.y, e.z), fa(o.$, 0, e.x, e.y, e.z), fa(o.$, o.$, e.x, e.y, e.z), fa(0, o.$, e.x, e.y, e.z)],
                M = [];
              for (const He of P) M.push(o.aQ([], He, w));
              if (w !== v)
                for (const He of P) M.push(o.aQ([], He, v));
              e.y === 0 && M.push([0, 1, 0]), e.y === (1 << e.z) - 1 && M.push([0, -1, 0]);
              const D = [1, 1, 1],
                L = [-1, -1, -1];
              for (const He of M)
                for (let Qe = 0; Qe < 3; Qe++) D[Qe] = Math.min(D[Qe], He[Qe]), L[Qe] = Math.max(L[Qe], He[Qe]);
              const B = fa(o.$ / 2, o.$ / 2, e.x, e.y, e.z),
                Z = o.aV([], [0, 1, 0], B);
              o.aU(Z, Z);
              const te = o.aV([], B, Z);
              o.aU(te, te);
              const ee = o.aV([], P[2], P[1]);
              o.aU(ee, ee);
              const ne = o.aV([], P[0], P[3]);
              o.aU(ne, ne), M.push(o.aQ([], B, w)), e.y >= (1 << e.z) / 2 && M.push(o.aQ([], fa(o.$ / 2, 0, e.x, e.y, e.z), w)), e.y < (1 << e.z) / 2 && M.push(o.aQ([], fa(o.$ / 2, o.$, e.x, e.y, e.z), w));
              const oe = Rn(B, M),
                me = Rn(te, M),
                ue = [-B[0], -B[1], -B[2], oe.max],
                be = [B[0], B[1], B[2], -oe.min],
                Pe = [-te[0], -te[1], -te[2], me.max],
                pe = [te[0], te[1], te[2], -me.min],
                Fe = [...ee, 0],
                Je = [...ne, 0],
                Ge = [];
              return e.y === 0 ? Ge.push(o.bs(Je, Fe, ue), o.bs(Je, Fe, be)) : Ge.push(o.bs(Pe, Fe, ue), o.bs(Pe, Fe, be), o.bs(Pe, Je, ue), o.bs(Pe, Je, be)), e.y === (1 << e.z) - 1 ? Ge.push(o.bs(Je, Fe, ue), o.bs(Je, Fe, be)) : Ge.push(o.bs(pe, Fe, ue), o.bs(pe, Fe, be), o.bs(pe, Je, ue), o.bs(pe, Je, be)), new Ga(Ge, [ue, be, Pe, pe, Fe, Je], D, L)
            }
          }
        }

        function Rn(h, e) {
          let r = 1 / 0,
            s = -1 / 0;
          for (const c of e) {
            const d = o.aW(h, c);
            r = Math.min(r, d), s = Math.max(s, d)
          }
          return {
            min: r,
            max: s
          }
        }
        class zs {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, r, s) {
            return this._helper.interpolatePadding(e, r, s)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, r) {
            this._helper.resize(e, r)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          overrideNearFarZ(e, r) {
            this._helper.overrideNearFarZ(e, r)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          setTransitionState(e) {}
          constructor() {
            this._cachedClippingPlane = o.bu(), this._projectionMatrix = o.b8(), this._globeViewProjMatrix32f = o.b7(), this._globeViewProjMatrixNoCorrection = o.b8(), this._globeViewProjMatrixNoCorrectionInverted = o.b8(), this._globeProjMatrixInverted = o.b8(), this._cameraPosition = o.bo(), this._globeLatitudeErrorCorrectionRadians = 0, this._helper = new Ua({
              calcMatrices: () => {
                this._calcMatrices()
              },
              getConstrained: (e, r) => this.getConstrained(e, r)
            }), this._coveringTilesDetailsProvider = new Xd
          }
          clone() {
            const e = new zs;
            return e.apply(this), e
          }
          apply(e, r) {
            this._globeLatitudeErrorCorrectionRadians = r || 0, this._helper.apply(e)
          }
          get projectionMatrix() {
            return this._projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted
          }
          get cameraPosition() {
            const e = o.bo();
            return e[0] = this._cameraPosition[0], e[1] = this._cameraPosition[1], e[2] = this._cameraPosition[2], e
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          getProjectionData(e) {
            const {
              overscaledTileID: r,
              applyGlobeMatrix: s
            } = e, c = this._helper.getMercatorTileCoordinates(r);
            return {
              mainMatrix: this._globeViewProjMatrix32f,
              tileMercatorCoords: c,
              clippingPlane: this._cachedClippingPlane,
              projectionTransition: s ? 1 : 0,
              fallbackMatrix: this._globeViewProjMatrix32f
            }
          }
          _computeClippingPlane(e) {
            const r = this.pitchInRadians,
              s = this.cameraToCenterDistance / e,
              c = Math.sin(r) * s,
              d = Math.cos(r) * s + 1,
              m = 1 / Math.sqrt(c * c + d * d) * 1;
            let v = -c,
              w = d;
            const P = Math.sqrt(v * v + w * w);
            v /= P, w /= P;
            const M = [0, v, w];
            o.bv(M, M, [0, 0, 0], -this.bearingInRadians), o.bw(M, M, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), o.bx(M, M, [0, 0, 0], this.center.lng * Math.PI / 180);
            const D = 1 / o.aY(M);
            return o.aQ(M, M, D), [...M, -m * D]
          }
          isLocationOccluded(e) {
            return !this.isSurfacePointVisible(pn(e))
          }
          transformLightDirection(e) {
            const r = this._helper._center.lng * Math.PI / 180,
              s = this._helper._center.lat * Math.PI / 180,
              c = Math.cos(s),
              d = [Math.sin(r) * c, Math.sin(s), Math.cos(r) * c],
              m = [d[2], 0, -d[0]],
              v = [0, 0, 0];
            o.aV(v, m, d), o.aU(m, m), o.aU(v, v);
            const w = [0, 0, 0];
            return o.aU(w, [m[0] * e[0] + v[0] * e[1] + d[0] * e[2], m[1] * e[0] + v[1] * e[1] + d[1] * e[2], m[2] * e[0] + v[2] * e[1] + d[2] * e[2]]), w
          }
          getPixelScale() {
            return 1 / Math.cos(this._helper._center.lat * Math.PI / 180)
          }
          getCircleRadiusCorrection() {
            return Math.cos(this._helper._center.lat * Math.PI / 180)
          }
          getPitchedTextCorrection(e, r, s) {
            const c = (function(v, w, P) {
                const M = 1 / (1 << P.z);
                return new o.a0(v / o.$ * M + P.x * M, w / o.$ * M + P.y * M)
              })(e, r, s.canonical),
              d = (m = c.y, [o.bn(c.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - m * Math.PI * 2)) - .5 * Math.PI]);
            var m;
            return this.getCircleRadiusCorrection() / Math.cos(d[1])
          }
          projectTileCoordinates(e, r, s, c) {
            const d = s.canonical,
              m = fa(e, r, d.x, d.y, d.z),
              v = 1 + (c ? c(e, r) : 0) / o.bt,
              w = [m[0] * v, m[1] * v, m[2] * v, 1];
            o.av(w, w, this._globeViewProjMatrixNoCorrection);
            const P = this._cachedClippingPlane,
              M = P[0] * m[0] + P[1] * m[1] + P[2] * m[2] + P[3] < 0;
            return {
              point: new o.P(w[0] / w[3], w[1] / w[3]),
              signedDistanceFromCamera: w[3],
              isOccluded: M
            }
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const e = Ms(this.worldSize, this.center.lat),
              r = o.b9(),
              s = o.b9();
            this._helper.autoCalculateNearFarZ && (this._helper._nearZ = .5, this._helper._farZ = this.cameraToCenterDistance + 2 * e), o.b3(r, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
            const c = this.centerOffset;
            r[8] = 2 * -c.x / this._helper._width, r[9] = 2 * c.y / this._helper._height, this._projectionMatrix = o.b4(r), this._globeProjMatrixInverted = o.b9(), o.ap(this._globeProjMatrixInverted, r), o.M(r, r, [0, 0, -this.cameraToCenterDistance]), o.b5(r, r, this.rollInRadians), o.b6(r, r, -this.pitchInRadians), o.b5(r, r, this.bearingInRadians), o.M(r, r, [0, 0, -e]);
            const d = o.bo();
            d[0] = e, d[1] = e, d[2] = e, o.b6(s, r, this.center.lat * Math.PI / 180), o.by(s, s, -this.center.lng * Math.PI / 180), o.N(s, s, d), this._globeViewProjMatrixNoCorrection = s, o.b6(r, r, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), o.by(r, r, -this.center.lng * Math.PI / 180), o.N(r, r, d), this._globeViewProjMatrix32f = new Float32Array(r), this._globeViewProjMatrixNoCorrectionInverted = o.b9(), o.ap(this._globeViewProjMatrixNoCorrectionInverted, s);
            const m = o.bo();
            this._cameraPosition = o.bo(), this._cameraPosition[2] = this.cameraToCenterDistance / e, o.bv(this._cameraPosition, this._cameraPosition, m, -this.rollInRadians), o.bw(this._cameraPosition, this._cameraPosition, m, this.pitchInRadians), o.bv(this._cameraPosition, this._cameraPosition, m, -this.bearingInRadians), o.aR(this._cameraPosition, this._cameraPosition, [0, 0, 1]), o.bw(this._cameraPosition, this._cameraPosition, m, -this.center.lat * Math.PI / 180), o.bx(this._cameraPosition, this._cameraPosition, m, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e);
            const v = o.b4(this._globeViewProjMatrixNoCorrectionInverted);
            o.N(v, v, [1, 1, -1]), this._cachedFrustum = Yi.fromInvProjectionMatrix(v, 1, 0, this._cachedClippingPlane, !0)
          }
          calculateFogMatrix(e) {
            o.w("calculateFogMatrix is not supported on globe projection.");
            const r = o.b9();
            return o.af(r), r
          }
          getVisibleUnwrappedCoordinates(e) {
            return [new o.b1(0, e)]
          }
          getCameraFrustum() {
            return this._cachedFrustum
          }
          getClippingPlane() {
            return this._cachedClippingPlane
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider
          }
          recalculateZoomAndCenter(e) {
            e && o.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0)
          }
          maxPitchScaleFactor() {
            return 1
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat()
          }
          lngLatToCameraDepth(e, r) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const s = pn(e);
            o.aQ(s, s, 1 + r / o.bt);
            const c = o.bu();
            return o.av(c, [s[0], s[1], s[2], 1], this._globeViewProjMatrixNoCorrection), c[2] / c[3]
          }
          populateCache(e) {}
          getBounds() {
            const e = .5 * this.width,
              r = .5 * this.height,
              s = [new o.P(0, 0), new o.P(e, 0), new o.P(this.width, 0), new o.P(this.width, r), new o.P(this.width, this.height), new o.P(e, this.height), new o.P(0, this.height), new o.P(0, r)],
              c = [];
            for (const D of s) c.push(this.unprojectScreenPoint(D));
            let d = 0,
              m = 0,
              v = 0,
              w = 0;
            const P = this.center;
            for (const D of c) {
              const L = o.bz(P.lng, D.lng),
                B = o.bz(P.lat, D.lat);
              L < m && (m = L), L > d && (d = L), B < w && (w = B), B > v && (v = B)
            }
            const M = [P.lng + m, P.lat + w, P.lng + d, P.lat + v];
            return this.isSurfacePointOnScreen([0, 1, 0]) && (M[3] = 90, M[0] = -180, M[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (M[1] = -90, M[0] = -180, M[2] = 180), new Lt(M)
          }
          getConstrained(e, r) {
            const s = o.ag(e.lat, -o.ah, o.ah),
              c = o.ag(+r, this.minZoom + tn(0, s), this.maxZoom);
            return {
              center: new o.S(e.lng, s),
              zoom: c
            }
          }
          calculateCenterFromCameraLngLatAlt(e, r, s, c) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, r, s, c)
          }
          setLocationAtPoint(e, r) {
            const s = pn(this.unprojectScreenPoint(r)),
              c = pn(e),
              d = o.bo();
            o.bA(d);
            const m = o.bo();
            o.bx(m, s, d, -this.center.lng * Math.PI / 180), o.bw(m, m, d, this.center.lat * Math.PI / 180);
            const v = c[0] * c[0] + c[2] * c[2],
              w = m[0] * m[0];
            if (v < w) return;
            const P = Math.sqrt(v - w),
              M = -P,
              D = o.bB(c[0], c[2], m[0], P),
              L = o.bB(c[0], c[2], m[0], M),
              B = o.bo();
            o.bx(B, c, d, -D);
            const Z = o.bB(B[1], B[2], m[1], m[2]),
              te = o.bo();
            o.bx(te, c, d, -L);
            const ee = o.bB(te[1], te[2], m[1], m[2]),
              ne = .5 * Math.PI,
              oe = Z >= -ne && Z <= ne,
              me = ee >= -ne && ee <= ne;
            let ue, be;
            if (oe && me) {
              const Je = this.center.lng * Math.PI / 180,
                Ge = this.center.lat * Math.PI / 180;
              o.bC(D, Je) + o.bC(Z, Ge) < o.bC(L, Je) + o.bC(ee, Ge) ? (ue = D, be = Z) : (ue = L, be = ee)
            } else if (oe) ue = D, be = Z;
            else {
              if (!me) return;
              ue = L, be = ee
            }
            const Pe = ue / Math.PI * 180,
              pe = be / Math.PI * 180,
              Fe = this.center.lat;
            this.setCenter(new o.S(Pe, o.ag(pe, -90, 90))), this.setZoom(this.zoom + tn(Fe, this.center.lat))
          }
          locationToScreenPoint(e, r) {
            const s = pn(e);
            if (r) {
              const c = r.getElevationForLngLatZoom(e, this._helper._tileZoom);
              o.aQ(s, s, 1 + c / o.bt)
            }
            return this._projectSurfacePointToScreen(s)
          }
          _projectSurfacePointToScreen(e) {
            const r = o.bu();
            return o.av(r, [...e, 1], this._globeViewProjMatrixNoCorrection), r[0] /= r[3], r[1] /= r[3], new o.P((.5 * r[0] + .5) * this.width, (.5 * -r[1] + .5) * this.height)
          }
          screenPointToMercatorCoordinate(e, r) {
            if (r) {
              const s = r.pointCoordinate(e);
              if (s) return s
            }
            return o.a0.fromLngLat(this.unprojectScreenPoint(e))
          }
          screenPointToLocation(e, r) {
            var s;
            return (s = this.screenPointToMercatorCoordinate(e, r)) === null || s === void 0 ? void 0 : s.toLngLat()
          }
          isPointOnMapSurface(e, r) {
            const s = this._cameraPosition,
              c = this.getRayDirectionFromPixel(e);
            return !!this.rayPlanetIntersection(s, c)
          }
          getRayDirectionFromPixel(e) {
            const r = o.bu();
            r[0] = e.x / this.width * 2 - 1, r[1] = -1 * (e.y / this.height * 2 - 1), r[2] = 1, r[3] = 1, o.av(r, r, this._globeViewProjMatrixNoCorrectionInverted), r[0] /= r[3], r[1] /= r[3], r[2] /= r[3];
            const s = o.bo();
            s[0] = r[0] - this._cameraPosition[0], s[1] = r[1] - this._cameraPosition[1], s[2] = r[2] - this._cameraPosition[2];
            const c = o.bo();
            return o.aU(c, s), c
          }
          isSurfacePointVisible(e) {
            const r = this._cachedClippingPlane;
            return r[0] * e[0] + r[1] * e[1] + r[2] * e[2] + r[3] >= 0
          }
          isSurfacePointOnScreen(e) {
            if (!this.isSurfacePointVisible(e)) return !1;
            const r = o.bu();
            return o.av(r, [...e, 1], this._globeViewProjMatrixNoCorrection), r[0] /= r[3], r[1] /= r[3], r[2] /= r[3], r[0] > -1 && r[0] < 1 && r[1] > -1 && r[1] < 1 && r[2] > -1 && r[2] < 1
          }
          rayPlanetIntersection(e, r) {
            const s = o.aW(e, r),
              c = o.bo(),
              d = o.bo();
            o.aQ(d, r, s), o.aT(c, e, d);
            const m = 1 - o.aW(c, c);
            if (m < 0) return null;
            const v = o.aW(e, e) - 1,
              w = -s + (s < 0 ? 1 : -1) * Math.sqrt(m),
              P = v / w,
              M = w;
            return {
              tMin: Math.min(P, M),
              tMax: Math.max(P, M)
            }
          }
          unprojectScreenPoint(e) {
            const r = this._cameraPosition,
              s = this.getRayDirectionFromPixel(e),
              c = this.rayPlanetIntersection(r, s);
            if (c) {
              const M = o.bo();
              o.aR(M, r, [s[0] * c.tMin, s[1] * c.tMin, s[2] * c.tMin]);
              const D = o.bo();
              return o.aU(D, M), po(D)
            }
            const d = this._cachedClippingPlane,
              m = d[0] * s[0] + d[1] * s[1] + d[2] * s[2],
              v = -o.b0(d, r) / m,
              w = o.bo();
            if (v > 0) o.aR(w, r, [s[0] * v, s[1] * v, s[2] * v]);
            else {
              const M = o.bo();
              o.aR(M, r, [2 * s[0], 2 * s[1], 2 * s[2]]);
              const D = o.b0(this._cachedClippingPlane, M);
              o.aT(w, M, [this._cachedClippingPlane[0] * D, this._cachedClippingPlane[1] * D, this._cachedClippingPlane[2] * D])
            }
            const P = (function(M) {
              const D = o.bo();
              return D[0] = M[0] * -M[3], D[1] = M[1] * -M[3], D[2] = M[2] * -M[3], {
                center: D,
                radius: Math.sqrt(1 - M[3] * M[3])
              }
            })(d);
            return po((function(M, D, L) {
              const B = o.bo();
              o.aT(B, L, M);
              const Z = o.bo();
              return o.bp(Z, M, B, D / o.a_(B)), Z
            })(P.center, P.radius, w))
          }
          getMatrixForModel(e, r) {
            const s = o.S.convert(e),
              c = 1 / o.bt,
              d = o.b8();
            return o.by(d, d, s.lng / 180 * Math.PI), o.b6(d, d, -s.lat / 180 * Math.PI), o.M(d, d, [0, 0, 1 + r / o.bt]), o.b6(d, d, .5 * Math.PI), o.N(d, d, [c, c, c]), d
          }
          getProjectionDataForCustomLayer(e = !0) {
            const r = this.getProjectionData({
              overscaledTileID: new o.Z(0, 0, 0, 0, 0),
              applyGlobeMatrix: e
            });
            return r.tileMercatorCoords = [0, 0, 1, 1], r
          }
          getFastPathSimpleProjectionMatrix(e) {}
        }
        class ta {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits
          }
          get centerOffset() {
            return this._helper.centerOffset
          }
          get size() {
            return this._helper.size
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix
          }
          get centerPoint() {
            return this._helper.centerPoint
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e)
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e)
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e)
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e)
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e)
          }
          setBearing(e) {
            this._helper.setBearing(e)
          }
          setPitch(e) {
            this._helper.setPitch(e)
          }
          setRoll(e) {
            this._helper.setRoll(e)
          }
          setFov(e) {
            this._helper.setFov(e)
          }
          setZoom(e) {
            this._helper.setZoom(e)
          }
          setCenter(e) {
            this._helper.setCenter(e)
          }
          setElevation(e) {
            this._helper.setElevation(e)
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e)
          }
          setPadding(e) {
            this._helper.setPadding(e)
          }
          interpolatePadding(e, r, s) {
            return this._helper.interpolatePadding(e, r, s)
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e)
          }
          resize(e, r, s = !0) {
            this._helper.resize(e, r, s)
          }
          getMaxBounds() {
            return this._helper.getMaxBounds()
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e)
          }
          overrideNearFarZ(e, r) {
            this._helper.overrideNearFarZ(e, r)
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride()
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
          }
          get tileSize() {
            return this._helper.tileSize
          }
          get tileZoom() {
            return this._helper.tileZoom
          }
          get scale() {
            return this._helper.scale
          }
          get worldSize() {
            return this._helper.worldSize
          }
          get width() {
            return this._helper.width
          }
          get height() {
            return this._helper.height
          }
          get lngRange() {
            return this._helper.lngRange
          }
          get latRange() {
            return this._helper.latRange
          }
          get minZoom() {
            return this._helper.minZoom
          }
          get maxZoom() {
            return this._helper.maxZoom
          }
          get zoom() {
            return this._helper.zoom
          }
          get center() {
            return this._helper.center
          }
          get minPitch() {
            return this._helper.minPitch
          }
          get maxPitch() {
            return this._helper.maxPitch
          }
          get pitch() {
            return this._helper.pitch
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians
          }
          get roll() {
            return this._helper.roll
          }
          get rollInRadians() {
            return this._helper.rollInRadians
          }
          get bearing() {
            return this._helper.bearing
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians
          }
          get fov() {
            return this._helper.fov
          }
          get fovInRadians() {
            return this._helper.fovInRadians
          }
          get elevation() {
            return this._helper.elevation
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile
          }
          get padding() {
            return this._helper.padding
          }
          get unmodified() {
            return this._helper.unmodified
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance
          }
          get nearZ() {
            return this._helper.nearZ
          }
          get farZ() {
            return this._helper.farZ
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ
          }
          get isGlobeRendering() {
            return this._globeness > 0
          }
          setTransitionState(e, r) {
            this._globeness = e, this._globeLatitudeErrorCorrectionRadians = r, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame()
          }
          get currentTransform() {
            return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform
          }
          constructor() {
            this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this._helper = new Ua({
              calcMatrices: () => {
                this._calcMatrices()
              },
              getConstrained: (e, r) => this.getConstrained(e, r)
            }), this._globeness = 1, this._mercatorTransform = new Oi, this._verticalPerspectiveTransform = new zs
          }
          clone() {
            const e = new ta;
            return e._globeness = this._globeness, e._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e.apply(this), e
          }
          apply(e) {
            this._helper.apply(e), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians)
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition
          }
          getProjectionData(e) {
            const r = this._mercatorTransform.getProjectionData(e),
              s = this._verticalPerspectiveTransform.getProjectionData(e);
            return {
              mainMatrix: this.isGlobeRendering ? s.mainMatrix : r.mainMatrix,
              clippingPlane: s.clippingPlane,
              tileMercatorCoords: s.tileMercatorCoords,
              projectionTransition: e.applyGlobeMatrix ? this._globeness : 0,
              fallbackMatrix: r.fallbackMatrix
            }
          }
          isLocationOccluded(e) {
            return this.currentTransform.isLocationOccluded(e)
          }
          transformLightDirection(e) {
            return this.currentTransform.transformLightDirection(e)
          }
          getPixelScale() {
            return o.bj(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness)
          }
          getCircleRadiusCorrection() {
            return o.bj(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness)
          }
          getPitchedTextCorrection(e, r, s) {
            const c = this._mercatorTransform.getPitchedTextCorrection(e, r, s),
              d = this._verticalPerspectiveTransform.getPitchedTextCorrection(e, r, s);
            return o.bj(c, d, this._globeness)
          }
          projectTileCoordinates(e, r, s, c) {
            return this.currentTransform.projectTileCoordinates(e, r, s, c)
          }
          _calcMatrices() {
            this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ)
          }
          calculateFogMatrix(e) {
            return this.currentTransform.calculateFogMatrix(e)
          }
          getVisibleUnwrappedCoordinates(e) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(e)
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum()
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane()
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider()
          }
          recalculateZoomAndCenter(e) {
            this._mercatorTransform.recalculateZoomAndCenter(e), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e)
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor()
          }
          getCameraPoint() {
            return this._helper.getCameraPoint()
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude()
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat()
          }
          lngLatToCameraDepth(e, r) {
            return this.currentTransform.lngLatToCameraDepth(e, r)
          }
          populateCache(e) {
            this._mercatorTransform.populateCache(e), this._verticalPerspectiveTransform.populateCache(e)
          }
          getBounds() {
            return this.currentTransform.getBounds()
          }
          getConstrained(e, r) {
            return this.currentTransform.getConstrained(e, r)
          }
          calculateCenterFromCameraLngLatAlt(e, r, s, c) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, r, s, c)
          }
          setLocationAtPoint(e, r) {
            if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e, r), void this.apply(this._mercatorTransform);
            this._verticalPerspectiveTransform.setLocationAtPoint(e, r), this.apply(this._verticalPerspectiveTransform)
          }
          locationToScreenPoint(e, r) {
            return this.currentTransform.locationToScreenPoint(e, r)
          }
          screenPointToMercatorCoordinate(e, r) {
            return this.currentTransform.screenPointToMercatorCoordinate(e, r)
          }
          screenPointToLocation(e, r) {
            return this.currentTransform.screenPointToLocation(e, r)
          }
          isPointOnMapSurface(e, r) {
            return this.currentTransform.isPointOnMapSurface(e, r)
          }
          getRayDirectionFromPixel(e) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e)
          }
          getMatrixForModel(e, r) {
            return this.currentTransform.getMatrixForModel(e, r)
          }
          getProjectionDataForCustomLayer(e = !0) {
            const r = this._mercatorTransform.getProjectionDataForCustomLayer(e);
            if (!this.isGlobeRendering) return r;
            const s = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e);
            return s.fallbackMatrix = r.mainMatrix, s
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(e)
          }
        }
        class Un {
          get useGlobeControls() {
            return !0
          }
          handlePanInertia(e, r) {
            const s = fo(e, r);
            return Math.abs(s.lng - r.center.lng) > 180 && (s.lng = r.center.lng + 179.5 * Math.sign(s.lng - r.center.lng)), {
              easingCenter: s,
              easingOffset: new o.P(0, 0)
            }
          }
          handleMapControlsRollPitchBearingZoom(e, r) {
            const s = e.around,
              c = r.screenPointToLocation(s);
            e.bearingDelta && r.setBearing(r.bearing + e.bearingDelta), e.pitchDelta && r.setPitch(r.pitch + e.pitchDelta), e.rollDelta && r.setRoll(r.roll + e.rollDelta);
            const d = r.zoom;
            e.zoomDelta && r.setZoom(r.zoom + e.zoomDelta);
            const m = r.zoom - d;
            if (m === 0) return;
            const v = o.bz(r.center.lng, c.lng),
              w = v / (Math.abs(v / 180) + 1),
              P = o.bz(r.center.lat, c.lat),
              M = r.getRayDirectionFromPixel(s),
              D = r.cameraPosition,
              L = -1 * o.aW(D, M),
              B = o.bo();
            o.aR(B, D, [M[0] * L, M[1] * L, M[2] * L]);
            const Z = o.aY(B) - 1,
              te = Math.exp(.5 * -Math.max(Z - .3, 0)),
              ee = Ms(r.worldSize, r.center.lat) / Math.min(r.width, r.height),
              ne = o.bm(ee, .9, .5, 1, .25),
              oe = (1 - o.ae(-m)) * Math.min(te, ne),
              me = r.center.lat,
              ue = r.zoom,
              be = new o.S(r.center.lng + w * oe, o.ag(r.center.lat + P * oe, -o.ah, o.ah));
            r.setLocationAtPoint(c, s);
            const Pe = r.center,
              pe = o.bm(Math.abs(v), 45, 85, 0, 1),
              Fe = o.bm(ee, .75, .35, 0, 1),
              Je = Math.pow(Math.max(pe, Fe), .25),
              Ge = o.bz(Pe.lng, be.lng),
              He = o.bz(Pe.lat, be.lat);
            r.setCenter(new o.S(Pe.lng + Ge * Je, Pe.lat + He * Je).wrap()), r.setZoom(ue + tn(me, r.center.lat))
          }
          handleMapControlsPan(e, r, s) {
            if (!e.panDelta) return;
            const c = r.center.lat,
              d = r.zoom;
            r.setCenter(fo(e.panDelta, r).wrap()), r.setZoom(d + tn(c, r.center.lat))
          }
          cameraForBoxAndBearing(e, r, s, c, d) {
            const m = Ni(e, r, s, c, d),
              v = r.left / d.width * 2 - 1,
              w = (d.width - r.right) / d.width * 2 - 1,
              P = r.top / d.height * -2 + 1,
              M = (d.height - r.bottom) / d.height * -2 + 1,
              D = o.bz(s.getWest(), s.getEast()) < 0,
              L = D ? s.getEast() : s.getWest(),
              B = D ? s.getWest() : s.getEast(),
              Z = Math.max(s.getNorth(), s.getSouth()),
              te = Math.min(s.getNorth(), s.getSouth()),
              ee = L + .5 * o.bz(L, B),
              ne = Z + .5 * o.bz(Z, te),
              oe = d.clone();
            oe.setCenter(m.center), oe.setBearing(m.bearing), oe.setPitch(0), oe.setRoll(0), oe.setZoom(m.zoom);
            const me = oe.modelViewProjectionMatrix,
              ue = [pn(s.getNorthWest()), pn(s.getNorthEast()), pn(s.getSouthWest()), pn(s.getSouthEast()), pn(new o.S(B, ne)), pn(new o.S(L, ne)), pn(new o.S(ee, Z)), pn(new o.S(ee, te))],
              be = pn(m.center);
            let Pe = Number.POSITIVE_INFINITY;
            for (const pe of ue) v < 0 && (Pe = Un.getLesserNonNegativeNonNull(Pe, Un.solveVectorScale(pe, be, me, "x", v))), w > 0 && (Pe = Un.getLesserNonNegativeNonNull(Pe, Un.solveVectorScale(pe, be, me, "x", w))), P > 0 && (Pe = Un.getLesserNonNegativeNonNull(Pe, Un.solveVectorScale(pe, be, me, "y", P))), M < 0 && (Pe = Un.getLesserNonNegativeNonNull(Pe, Un.solveVectorScale(pe, be, me, "y", M)));
            if (Number.isFinite(Pe) && Pe !== 0) return m.zoom = oe.zoom + o.aj(Pe), m;
            hn()
          }
          handleJumpToCenterZoom(e, r) {
            const s = e.center.lat,
              c = e.getConstrained(r.center ? o.S.convert(r.center) : e.center, e.zoom).center;
            e.setCenter(c.wrap());
            const d = r.zoom !== void 0 ? +r.zoom : e.zoom + tn(s, c.lat);
            e.zoom !== d && e.setZoom(d)
          }
          handleEaseTo(e, r) {
            const s = e.zoom,
              c = e.center,
              d = e.padding,
              m = {
                roll: e.roll,
                pitch: e.pitch,
                bearing: e.bearing
              },
              v = {
                roll: r.roll === void 0 ? e.roll : r.roll,
                pitch: r.pitch === void 0 ? e.pitch : r.pitch,
                bearing: r.bearing === void 0 ? e.bearing : r.bearing
              },
              w = r.zoom !== void 0,
              P = !e.isPaddingEqual(r.padding);
            let M = !1;
            const D = r.center ? o.S.convert(r.center) : c,
              L = e.getConstrained(D, s).center;
            ea(e, L);
            const B = e.clone();
            B.setCenter(L), B.setZoom(w ? +r.zoom : s + tn(c.lat, D.lat)), B.setBearing(r.bearing);
            const Z = new o.P(o.ag(e.centerPoint.x + r.offsetAsPoint.x, 0, e.width), o.ag(e.centerPoint.y + r.offsetAsPoint.y, 0, e.height));
            B.setLocationAtPoint(L, Z);
            const te = (r.offset && r.offsetAsPoint.mag()) > 0 ? B.center : L,
              ee = w ? +r.zoom : s + tn(c.lat, te.lat),
              ne = s + tn(c.lat, 0),
              oe = ee + tn(te.lat, 0),
              me = o.bz(c.lng, te.lng),
              ue = o.bz(c.lat, te.lat),
              be = o.ae(oe - ne);
            return M = ee !== s, {
              easeFunc: Pe => {
                if (o.bd(m, v) || dn({
                    startEulerAngles: m,
                    endEulerAngles: v,
                    tr: e,
                    k: Pe,
                    useSlerp: m.roll != v.roll
                  }), P && e.interpolatePadding(d, r.padding, Pe), r.around) o.w("Easing around a point is not supported under globe projection."), e.setLocationAtPoint(r.around, r.aroundPoint);
                else {
                  const pe = oe > ne ? Math.min(2, be) : Math.max(.5, be),
                    Fe = Math.pow(pe, 1 - Pe),
                    Je = Es(c, me, ue, Pe * Fe);
                  e.setCenter(Je.wrap())
                }
                if (M) {
                  const pe = o.C.number(ne, oe, Pe) + tn(0, e.center.lat);
                  e.setZoom(pe)
                }
              },
              isZooming: M,
              elevationCenter: te
            }
          }
          handleFlyTo(e, r) {
            const s = r.zoom !== void 0,
              c = e.center,
              d = e.zoom,
              m = e.padding,
              v = !e.isPaddingEqual(r.padding),
              w = e.getConstrained(o.S.convert(r.center || r.locationAtOffset), d).center,
              P = s ? +r.zoom : e.zoom + tn(e.center.lat, w.lat),
              M = e.clone();
            M.setCenter(w), M.setZoom(P), M.setBearing(r.bearing);
            const D = new o.P(o.ag(e.centerPoint.x + r.offsetAsPoint.x, 0, e.width), o.ag(e.centerPoint.y + r.offsetAsPoint.y, 0, e.height));
            M.setLocationAtPoint(w, D);
            const L = M.center;
            ea(e, L);
            const B = (function(ue, be, Pe) {
                const pe = pn(be),
                  Fe = pn(Pe),
                  Je = o.aW(pe, Fe),
                  Ge = Math.acos(Je),
                  He = ho(ue);
                return Ge / (2 * Math.PI) * He
              })(e, c, L),
              Z = d + tn(c.lat, 0),
              te = P + tn(L.lat, 0),
              ee = o.ae(te - Z);
            let ne;
            if (typeof r.minZoom == "number") {
              const ue = +r.minZoom + tn(L.lat, 0),
                be = Math.min(ue, Z, te) + tn(0, L.lat),
                Pe = e.getConstrained(L, be).zoom + tn(L.lat, 0);
              ne = o.ae(Pe - Z)
            }
            const oe = o.bz(c.lng, L.lng),
              me = o.bz(c.lat, L.lat);
            return {
              easeFunc: (ue, be, Pe, pe) => {
                const Fe = Es(c, oe, me, Pe);
                v && e.interpolatePadding(m, r.padding, ue);
                const Je = ue === 1 ? L : Fe;
                e.setCenter(Je.wrap());
                const Ge = Z + o.aj(be);
                e.setZoom(ue === 1 ? P : Ge + tn(0, Je.lat))
              },
              scaleOfZoom: ee,
              targetCenter: L,
              scaleOfMinZoom: ne,
              pixelPathLength: B
            }
          }
          static solveVectorScale(e, r, s, c, d) {
            const m = c === "x" ? [s[0], s[4], s[8], s[12]] : [s[1], s[5], s[9], s[13]],
              v = [s[3], s[7], s[11], s[15]],
              w = e[0] * m[0] + e[1] * m[1] + e[2] * m[2],
              P = e[0] * v[0] + e[1] * v[1] + e[2] * v[2],
              M = r[0] * m[0] + r[1] * m[1] + r[2] * m[2],
              D = r[0] * v[0] + r[1] * v[1] + r[2] * v[2];
            return M + d * P === w + d * D || v[3] * (w - M) + m[3] * (D - P) + w * D == M * P ? null : (M + m[3] - d * D - d * v[3]) / (M - w - d * D + d * P)
          }
          static getLesserNonNegativeNonNull(e, r) {
            return r !== null && r >= 0 && r < e ? r : e
          }
        }
        class _c {
          constructor(e) {
            this._globe = e, this._mercatorCameraHelper = new rl, this._verticalPerspectiveCameraHelper = new Un
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering
          }
          get currentHelper() {
            return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper
          }
          handlePanInertia(e, r) {
            return this.currentHelper.handlePanInertia(e, r)
          }
          handleMapControlsRollPitchBearingZoom(e, r) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(e, r)
          }
          handleMapControlsPan(e, r, s) {
            this.currentHelper.handleMapControlsPan(e, r, s)
          }
          cameraForBoxAndBearing(e, r, s, c, d) {
            return this.currentHelper.cameraForBoxAndBearing(e, r, s, c, d)
          }
          handleJumpToCenterZoom(e, r) {
            this.currentHelper.handleJumpToCenterZoom(e, r)
          }
          handleEaseTo(e, r) {
            return this.currentHelper.handleEaseTo(e, r)
          }
          handleFlyTo(e, r) {
            return this.currentHelper.handleFlyTo(e, r)
          }
        }
        const _o = (h, e) => o.y(h, e && e.filter((r => r.identifier !== "source.canvas"))),
          Ls = o.bD();
        class gc extends o.E {
          constructor(e, r = {}) {
            super(), this._rtlPluginLoaded = () => {
              for (const s in this.sourceCaches) {
                const c = this.sourceCaches[s].getSource().type;
                c !== "vector" && c !== "geojson" || this.sourceCaches[s].reload()
              }
            }, this.map = e, this.dispatcher = new Bt(ft(), e._getMapId()), this.dispatcher.registerMessageHandler("GG", ((s, c) => this.getGlyphs(s, c))), this.dispatcher.registerMessageHandler("GI", ((s, c) => this.getImages(s, c))), this.imageManager = new rt, this.imageManager.setEventedParent(this), this.glyphManager = new ht(e._requestManager, r.localIdeographFontFamily), this.lineAtlas = new ce(256, 512), this.crossTileSymbolIndex = new an, this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new o.bE, this._loaded = !1, this._availableImages = [], this._globalState = {}, this._resetUpdates(), this.dispatcher.broadcast("SR", o.bF()), tr().on(dr, this._rtlPluginLoaded), this.on("data", (s => {
              if (s.dataType !== "source" || s.sourceDataType !== "metadata") return;
              const c = this.sourceCaches[s.sourceId];
              if (!c) return;
              const d = c.getSource();
              if (d && d.vectorLayerIds)
                for (const m in this._layers) {
                  const v = this._layers[m];
                  v.source === d.id && this._validateLayer(v)
                }
            }))
          }
          setGlobalStateProperty(e, r) {
            var s, c, d;
            this._checkLoaded();
            const m = r === null ? (d = (c = (s = this.stylesheet.state) === null || s === void 0 ? void 0 : s[e]) === null || c === void 0 ? void 0 : c.default) !== null && d !== void 0 ? d : null : r;
            if (o.bG(m, this._globalState[e])) return this;
            this._globalState[e] = m;
            const v = this._findGlobalStateAffectedSources([e]);
            for (const w in this.sourceCaches) v.has(w) && (this._reloadSource(w), this._changed = !0)
          }
          getGlobalState() {
            return this._globalState
          }
          setGlobalState(e) {
            this._checkLoaded();
            const r = [];
            for (const c in e) !o.bG(this._globalState[c], e[c].default) && (r.push(c), this._globalState[c] = e[c].default);
            const s = this._findGlobalStateAffectedSources(r);
            for (const c in this.sourceCaches) s.has(c) && (this._reloadSource(c), this._changed = !0)
          }
          _findGlobalStateAffectedSources(e) {
            if (e.length === 0) return new Set;
            const r = new Set;
            for (const s in this._layers) {
              const c = this._layers[s],
                d = c.getLayoutAffectingGlobalStateRefs();
              for (const m of e) d.has(m) && r.add(c.source)
            }
            return r
          }
          loadURL(e, r = {}, s) {
            this.fire(new o.l("dataloading", {
              dataType: "style"
            })), r.validate = typeof r.validate != "boolean" || r.validate;
            const c = this.map._requestManager.transformRequest(e, "Style");
            this._loadStyleRequest = new AbortController;
            const d = this._loadStyleRequest;
            o.j(c, this._loadStyleRequest).then((m => {
              this._loadStyleRequest = null, this._load(m.data, r, s)
            })).catch((m => {
              this._loadStyleRequest = null, m && !d.signal.aborted && this.fire(new o.k(m))
            }))
          }
          loadJSON(e, r = {}, s) {
            this.fire(new o.l("dataloading", {
              dataType: "style"
            })), this._frameRequest = new AbortController, fe.frameAsync(this._frameRequest).then((() => {
              this._frameRequest = null, r.validate = r.validate !== !1, this._load(e, r, s)
            })).catch((() => {}))
          }
          loadEmpty() {
            this.fire(new o.l("dataloading", {
              dataType: "style"
            })), this._load(Ls, {
              validate: !1
            })
          }
          _load(e, r, s) {
            var c, d, m;
            const v = r.transformStyle ? r.transformStyle(s, e) : e;
            if (!r.validate || !_o(this, o.z(v))) {
              this._loaded = !0, this.stylesheet = v;
              for (const w in v.sources) this.addSource(w, v.sources[w], {
                validate: !1
              });
              v.sprite ? this._loadSprite(v.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(v.glyphs), this._createLayers(), this.light = new Q(this.stylesheet.light), this._setProjectionInternal(((c = this.stylesheet.projection) === null || c === void 0 ? void 0 : c.type) || "mercator"), this.sky = new xe(this.stylesheet.sky), this.map.setTerrain((d = this.stylesheet.terrain) !== null && d !== void 0 ? d : null), this.setGlobalState((m = this.stylesheet.state) !== null && m !== void 0 ? m : null), this.fire(new o.l("data", {
                dataType: "style"
              })), this.fire(new o.l("style.load"))
            }
          }
          _createLayers() {
            const e = o.bH(this.stylesheet.layers);
            this.dispatcher.broadcast("SL", e), this._order = e.map((r => r.id)), this._layers = {}, this._serializedLayers = null;
            for (const r of e) {
              const s = o.bI(r);
              s.setEventedParent(this, {
                layer: {
                  id: r.id
                }
              }), this._layers[r.id] = s
            }
          }
          _loadSprite(e, r = !1, s = void 0) {
            let c;
            this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController, (function(d, m, v, w) {
              return o._(this, void 0, void 0, (function*() {
                const P = nt(d),
                  M = v > 1 ? "@2x" : "",
                  D = {},
                  L = {};
                for (const {
                    id: B,
                    url: Z
                  }
                  of P) {
                  const te = m.transformRequest(Ye(Z, M, ".json"), "SpriteJSON");
                  D[B] = o.j(te, w);
                  const ee = m.transformRequest(Ye(Z, M, ".png"), "SpriteImage");
                  L[B] = Ve.getImage(ee, w)
                }
                return yield Promise.all([...Object.values(D), ...Object.values(L)]), (function(B, Z) {
                  return o._(this, void 0, void 0, (function*() {
                    const te = {};
                    for (const ee in B) {
                      te[ee] = {};
                      const ne = fe.getImageCanvasContext((yield Z[ee]).data),
                        oe = (yield B[ee]).data;
                      for (const me in oe) {
                        const {
                          width: ue,
                          height: be,
                          x: Pe,
                          y: pe,
                          sdf: Fe,
                          pixelRatio: Je,
                          stretchX: Ge,
                          stretchY: He,
                          content: Qe,
                          textFitWidth: qt,
                          textFitHeight: Ft
                        } = oe[me];
                        te[ee][me] = {
                          data: null,
                          pixelRatio: Je,
                          sdf: Fe,
                          stretchX: Ge,
                          stretchY: He,
                          content: Qe,
                          textFitWidth: qt,
                          textFitHeight: Ft,
                          spriteData: {
                            width: ue,
                            height: be,
                            x: Pe,
                            y: pe,
                            context: ne
                          }
                        }
                      }
                    }
                    return te
                  }))
                })(D, L)
              }))
            })(e, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((d => {
              if (this._spriteRequest = null, d)
                for (const m in d) {
                  this._spritesImagesIds[m] = [];
                  const v = this._spritesImagesIds[m] ? this._spritesImagesIds[m].filter((w => !(w in d))) : [];
                  for (const w of v) this.imageManager.removeImage(w), this._changedImages[w] = !0;
                  for (const w in d[m]) {
                    const P = m === "default" ? w : `${m}:${w}`;
                    this._spritesImagesIds[m].push(P), P in this.imageManager.images ? this.imageManager.updateImage(P, d[m][w], !1) : this.imageManager.addImage(P, d[m][w]), r && (this._changedImages[P] = !0)
                  }
                }
            })).catch((d => {
              this._spriteRequest = null, c = d, this.fire(new o.k(c))
            })).finally((() => {
              this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), r && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.l("data", {
                dataType: "style"
              })), s && s(c)
            }))
          }
          _unloadSprite() {
            for (const e of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e), this._changedImages[e] = !0;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.l("data", {
              dataType: "style"
            }))
          }
          _validateLayer(e) {
            const r = this.sourceCaches[e.source];
            if (!r) return;
            const s = e.sourceLayer;
            if (!s) return;
            const c = r.getSource();
            (c.type === "geojson" || c.vectorLayerIds && c.vectorLayerIds.indexOf(s) === -1) && this.fire(new o.k(new Error(`Source layer "${s}" does not exist on source "${c.id}" as specified by style layer "${e.id}".`)))
          }
          loaded() {
            if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
            for (const e in this.sourceCaches)
              if (!this.sourceCaches[e].loaded()) return !1;
            return !!this.imageManager.isLoaded()
          }
          _serializeByIds(e, r = !1) {
            const s = this._serializedAllLayers();
            if (!e || e.length === 0) return Object.values(r ? o.bJ(s) : s);
            const c = [];
            for (const d of e)
              if (s[d]) {
                const m = r ? o.bJ(s[d]) : s[d];
                c.push(m)
              } return c
          }
          _serializedAllLayers() {
            let e = this._serializedLayers;
            if (e) return e;
            e = this._serializedLayers = {};
            const r = Object.keys(this._layers);
            for (const s of r) {
              const c = this._layers[s];
              c.type !== "custom" && (e[s] = c.serialize())
            }
            return e
          }
          hasTransitions() {
            var e, r, s;
            if (!((e = this.light) === null || e === void 0) && e.hasTransition() || !((r = this.sky) === null || r === void 0) && r.hasTransition() || !((s = this.projection) === null || s === void 0) && s.hasTransition()) return !0;
            for (const c in this.sourceCaches)
              if (this.sourceCaches[c].hasTransition()) return !0;
            for (const c in this._layers)
              if (this._layers[c].hasTransition()) return !0;
            return !1
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.")
          }
          update(e) {
            if (!this._loaded) return;
            const r = this._changed;
            if (r) {
              const c = Object.keys(this._updatedLayers),
                d = Object.keys(this._removedLayers);
              (c.length || d.length) && this._updateWorkerLayers(c, d);
              for (const m in this._updatedSources) {
                const v = this._updatedSources[m];
                if (v === "reload") this._reloadSource(m);
                else {
                  if (v !== "clear") throw new Error(`Invalid action ${v}`);
                  this._clearSource(m)
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const m in this._updatedPaintProps) this._layers[m].updateTransitions(e);
              this.light.updateTransitions(e), this.sky.updateTransitions(e), this._resetUpdates()
            }
            const s = {};
            for (const c in this.sourceCaches) {
              const d = this.sourceCaches[c];
              s[c] = d.used, d.used = !1
            }
            for (const c of this._order) {
              const d = this._layers[c];
              d.recalculate(e, this._availableImages), !d.isHidden(e.zoom) && d.source && (this.sourceCaches[d.source].used = !0)
            }
            for (const c in s) {
              const d = this.sourceCaches[c];
              !!s[c] != !!d.used && d.fire(new o.l("data", {
                sourceDataType: "visibility",
                dataType: "source",
                sourceId: c
              }))
            }
            this.light.recalculate(e), this.sky.recalculate(e), this.projection.recalculate(e), this.z = e.zoom, r && this.fire(new o.l("data", {
              dataType: "style"
            }))
          }
          _updateTilesForChangedImages() {
            const e = Object.keys(this._changedImages);
            if (e.length) {
              for (const r in this.sourceCaches) this.sourceCaches[r].reloadTilesForDependencies(["icons", "patterns"], e);
              this._changedImages = {}
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const e in this.sourceCaches) this.sourceCaches[e].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = !1
            }
          }
          _updateWorkerLayers(e, r) {
            this.dispatcher.broadcast("UL", {
              layers: this._serializeByIds(e, !1),
              removedIds: r
            })
          }
          _resetUpdates() {
            this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1
          }
          setState(e, r = {}) {
            var s;
            this._checkLoaded();
            const c = this.serialize();
            if (e = r.transformStyle ? r.transformStyle(c, e) : e, ((s = r.validate) === null || s === void 0 || s) && _o(this, o.z(e))) return !1;
            (e = o.bJ(e)).layers = o.bH(e.layers);
            const d = o.bK(c, e),
              m = this._getOperationsToPerform(d);
            if (m.unimplemented.length > 0) throw new Error(`Unimplemented: ${m.unimplemented.join(", ")}.`);
            if (m.operations.length === 0) return !1;
            for (const v of m.operations) v();
            return this.stylesheet = e, this._serializedLayers = null, !0
          }
          _getOperationsToPerform(e) {
            const r = [],
              s = [];
            for (const c of e) switch (c.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
              case "setRoll":
                continue;
              case "addLayer":
                r.push((() => this.addLayer.apply(this, c.args)));
                break;
              case "removeLayer":
                r.push((() => this.removeLayer.apply(this, c.args)));
                break;
              case "setPaintProperty":
                r.push((() => this.setPaintProperty.apply(this, c.args)));
                break;
              case "setLayoutProperty":
                r.push((() => this.setLayoutProperty.apply(this, c.args)));
                break;
              case "setFilter":
                r.push((() => this.setFilter.apply(this, c.args)));
                break;
              case "addSource":
                r.push((() => this.addSource.apply(this, c.args)));
                break;
              case "removeSource":
                r.push((() => this.removeSource.apply(this, c.args)));
                break;
              case "setLayerZoomRange":
                r.push((() => this.setLayerZoomRange.apply(this, c.args)));
                break;
              case "setLight":
                r.push((() => this.setLight.apply(this, c.args)));
                break;
              case "setGeoJSONSourceData":
                r.push((() => this.setGeoJSONSourceData.apply(this, c.args)));
                break;
              case "setGlyphs":
                r.push((() => this.setGlyphs.apply(this, c.args)));
                break;
              case "setSprite":
                r.push((() => this.setSprite.apply(this, c.args)));
                break;
              case "setTerrain":
                r.push((() => this.map.setTerrain.apply(this, c.args)));
                break;
              case "setSky":
                r.push((() => this.setSky.apply(this, c.args)));
                break;
              case "setProjection":
                this.setProjection.apply(this, c.args);
                break;
              case "setGlobalState":
                r.push((() => this.setGlobalState.apply(this, c.args)));
                break;
              case "setTransition":
                r.push((() => {}));
                break;
              default:
                s.push(c.command)
            }
            return {
              operations: r,
              unimplemented: s
            }
          }
          addImage(e, r) {
            if (this.getImage(e)) return this.fire(new o.k(new Error(`An image named "${e}" already exists.`)));
            this.imageManager.addImage(e, r), this._afterImageUpdated(e)
          }
          updateImage(e, r) {
            this.imageManager.updateImage(e, r)
          }
          getImage(e) {
            return this.imageManager.getImage(e)
          }
          removeImage(e) {
            if (!this.getImage(e)) return this.fire(new o.k(new Error(`An image named "${e}" does not exist.`)));
            this.imageManager.removeImage(e), this._afterImageUpdated(e)
          }
          _afterImageUpdated(e) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[e] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.l("data", {
              dataType: "style"
            }))
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages()
          }
          addSource(e, r, s = {}) {
            if (this._checkLoaded(), this.sourceCaches[e] !== void 0) throw new Error(`Source "${e}" already exists.`);
            if (!r.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(r).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(r.type) >= 0 && this._validate(o.z.source, `sources.${e}`, r, null, s)) return;
            this.map && this.map._collectResourceTiming && (r.collectResourceTiming = !0);
            const c = this.sourceCaches[e] = new We(e, r, this.dispatcher);
            c.style = this, c.setEventedParent(this, (() => ({
              isSourceLoaded: c.loaded(),
              source: c.serialize(),
              sourceId: e
            }))), c.onAdd(this.map), this._changed = !0
          }
          removeSource(e) {
            if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error("There is no source with this ID");
            for (const s in this._layers)
              if (this._layers[s].source === e) return this.fire(new o.k(new Error(`Source "${e}" cannot be removed while layer "${s}" is using it.`)));
            const r = this.sourceCaches[e];
            delete this.sourceCaches[e], delete this._updatedSources[e], r.fire(new o.l("data", {
              sourceDataType: "metadata",
              dataType: "source",
              sourceId: e
            })), r.setEventedParent(null), r.onRemove(this.map), this._changed = !0
          }
          setGeoJSONSourceData(e, r) {
            if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error(`There is no source with this ID=${e}`);
            const s = this.sourceCaches[e].getSource();
            if (s.type !== "geojson") throw new Error(`geojsonSource.type is ${s.type}, which is !== 'geojson`);
            s.setData(r), this._changed = !0
          }
          getSource(e) {
            return this.sourceCaches[e] && this.sourceCaches[e].getSource()
          }
          addLayer(e, r, s = {}) {
            this._checkLoaded();
            const c = e.id;
            if (this.getLayer(c)) return void this.fire(new o.k(new Error(`Layer "${c}" already exists on this map.`)));
            let d;
            if (e.type === "custom") {
              if (_o(this, o.bL(e))) return;
              d = o.bI(e)
            } else {
              if ("source" in e && typeof e.source == "object" && (this.addSource(c, e.source), e = o.bJ(e), e = o.e(e, {
                  source: c
                })), this._validate(o.z.layer, `layers.${c}`, e, {
                  arrayIndex: -1
                }, s)) return;
              d = o.bI(e), this._validateLayer(d), d.setEventedParent(this, {
                layer: {
                  id: c
                }
              })
            }
            const m = r ? this._order.indexOf(r) : this._order.length;
            if (r && m === -1) this.fire(new o.k(new Error(`Cannot add layer "${c}" before non-existing layer "${r}".`)));
            else {
              if (this._order.splice(m, 0, c), this._layerOrderChanged = !0, this._layers[c] = d, this._removedLayers[c] && d.source && d.type !== "custom") {
                const v = this._removedLayers[c];
                delete this._removedLayers[c], v.type !== d.type ? this._updatedSources[d.source] = "clear" : (this._updatedSources[d.source] = "reload", this.sourceCaches[d.source].pause())
              }
              this._updateLayer(d), d.onAdd && d.onAdd(this.map)
            }
          }
          moveLayer(e, r) {
            if (this._checkLoaded(), this._changed = !0, !this._layers[e]) return void this.fire(new o.k(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
            if (e === r) return;
            const s = this._order.indexOf(e);
            this._order.splice(s, 1);
            const c = r ? this._order.indexOf(r) : this._order.length;
            r && c === -1 ? this.fire(new o.k(new Error(`Cannot move layer "${e}" before non-existing layer "${r}".`))) : (this._order.splice(c, 0, e), this._layerOrderChanged = !0)
          }
          removeLayer(e) {
            this._checkLoaded();
            const r = this._layers[e];
            if (!r) return void this.fire(new o.k(new Error(`Cannot remove non-existing layer "${e}".`)));
            r.setEventedParent(null);
            const s = this._order.indexOf(e);
            this._order.splice(s, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e] = r, delete this._layers[e], this._serializedLayers && delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], r.onRemove && r.onRemove(this.map)
          }
          getLayer(e) {
            return this._layers[e]
          }
          getLayersOrder() {
            return [...this._order]
          }
          hasLayer(e) {
            return e in this._layers
          }
          setLayerZoomRange(e, r, s) {
            this._checkLoaded();
            const c = this.getLayer(e);
            c ? c.minzoom === r && c.maxzoom === s || (r != null && (c.minzoom = r), s != null && (c.maxzoom = s), this._updateLayer(c)) : this.fire(new o.k(new Error(`Cannot set the zoom range of non-existing layer "${e}".`)))
          }
          setFilter(e, r, s = {}) {
            this._checkLoaded();
            const c = this.getLayer(e);
            if (c) {
              if (!o.bG(c.filter, r)) return r == null ? (c.setFilter(void 0), void this._updateLayer(c)) : void(this._validate(o.z.filter, `layers.${c.id}.filter`, r, null, s) || (c.setFilter(o.bJ(r)), this._updateLayer(c)))
            } else this.fire(new o.k(new Error(`Cannot filter non-existing layer "${e}".`)))
          }
          getFilter(e) {
            return o.bJ(this.getLayer(e).filter)
          }
          setLayoutProperty(e, r, s, c = {}) {
            this._checkLoaded();
            const d = this.getLayer(e);
            d ? o.bG(d.getLayoutProperty(r), s) || (d.setLayoutProperty(r, s, c), this._updateLayer(d)) : this.fire(new o.k(new Error(`Cannot style non-existing layer "${e}".`)))
          }
          getLayoutProperty(e, r) {
            const s = this.getLayer(e);
            if (s) return s.getLayoutProperty(r);
            this.fire(new o.k(new Error(`Cannot get style of non-existing layer "${e}".`)))
          }
          setPaintProperty(e, r, s, c = {}) {
            this._checkLoaded();
            const d = this.getLayer(e);
            d ? o.bG(d.getPaintProperty(r), s) || (d.setPaintProperty(r, s, c) && this._updateLayer(d), this._changed = !0, this._updatedPaintProps[e] = !0, this._serializedLayers = null) : this.fire(new o.k(new Error(`Cannot style non-existing layer "${e}".`)))
          }
          getPaintProperty(e, r) {
            return this.getLayer(e).getPaintProperty(r)
          }
          setFeatureState(e, r) {
            this._checkLoaded();
            const s = e.source,
              c = e.sourceLayer,
              d = this.sourceCaches[s];
            if (d === void 0) return void this.fire(new o.k(new Error(`The source '${s}' does not exist in the map's style.`)));
            const m = d.getSource().type;
            m === "geojson" && c ? this.fire(new o.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : m !== "vector" || c ? (e.id === void 0 && this.fire(new o.k(new Error("The feature id parameter must be provided."))), d.setFeatureState(c, e.id, r)) : this.fire(new o.k(new Error("The sourceLayer parameter must be provided for vector source types.")))
          }
          removeFeatureState(e, r) {
            this._checkLoaded();
            const s = e.source,
              c = this.sourceCaches[s];
            if (c === void 0) return void this.fire(new o.k(new Error(`The source '${s}' does not exist in the map's style.`)));
            const d = c.getSource().type,
              m = d === "vector" ? e.sourceLayer : void 0;
            d !== "vector" || m ? r && typeof e.id != "string" && typeof e.id != "number" ? this.fire(new o.k(new Error("A feature id is required to remove its specific state property."))) : c.removeFeatureState(m, e.id, r) : this.fire(new o.k(new Error("The sourceLayer parameter must be provided for vector source types.")))
          }
          getFeatureState(e) {
            this._checkLoaded();
            const r = e.source,
              s = e.sourceLayer,
              c = this.sourceCaches[r];
            if (c !== void 0) return c.getSource().type !== "vector" || s ? (e.id === void 0 && this.fire(new o.k(new Error("The feature id parameter must be provided."))), c.getFeatureState(s, e.id)) : void this.fire(new o.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new o.k(new Error(`The source '${r}' does not exist in the map's style.`)))
          }
          getTransition() {
            return o.e({
              duration: 300,
              delay: 0
            }, this.stylesheet && this.stylesheet.transition)
          }
          serialize() {
            if (!this._loaded) return;
            const e = o.bM(this.sourceCaches, (d => d.serialize())),
              r = this._serializeByIds(this._order, !0),
              s = this.map.getTerrain() || void 0,
              c = this.stylesheet;
            return o.bN({
              version: c.version,
              name: c.name,
              metadata: c.metadata,
              light: c.light,
              sky: c.sky,
              center: c.center,
              zoom: c.zoom,
              bearing: c.bearing,
              pitch: c.pitch,
              sprite: c.sprite,
              glyphs: c.glyphs,
              transition: c.transition,
              projection: c.projection,
              sources: e,
              layers: r,
              terrain: s
            }, (d => d !== void 0))
          }
          _updateLayer(e) {
            this._updatedLayers[e.id] = !0, e.source && !this._updatedSources[e.source] && this.sourceCaches[e.source].getSource().type !== "raster" && (this._updatedSources[e.source] = "reload", this.sourceCaches[e.source].pause()), this._serializedLayers = null, this._changed = !0
          }
          _flattenAndSortRenderedFeatures(e) {
            const r = m => this._layers[m].type === "fill-extrusion",
              s = {},
              c = [];
            for (let m = this._order.length - 1; m >= 0; m--) {
              const v = this._order[m];
              if (r(v)) {
                s[v] = m;
                for (const w of e) {
                  const P = w[v];
                  if (P)
                    for (const M of P) c.push(M)
                }
              }
            }
            c.sort(((m, v) => v.intersectionZ - m.intersectionZ));
            const d = [];
            for (let m = this._order.length - 1; m >= 0; m--) {
              const v = this._order[m];
              if (r(v))
                for (let w = c.length - 1; w >= 0; w--) {
                  const P = c[w].feature;
                  if (s[P.layer.id] < m) break;
                  d.push(P), c.pop()
                } else
                  for (const w of e) {
                    const P = w[v];
                    if (P)
                      for (const M of P) d.push(M.feature)
                  }
            }
            return d
          }
          queryRenderedFeatures(e, r, s) {
            r && r.filter && this._validate(o.z.filter, "queryRenderedFeatures.filter", r.filter, null, r);
            const c = {};
            if (r && r.layers) {
              if (!(Array.isArray(r.layers) || r.layers instanceof Set)) return this.fire(new o.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
              for (const P of r.layers) {
                const M = this._layers[P];
                if (!M) return this.fire(new o.k(new Error(`The layer '${P}' does not exist in the map's style and cannot be queried for features.`))), [];
                c[M.source] = !0
              }
            }
            const d = [];
            r.availableImages = this._availableImages;
            const m = this._serializedAllLayers(),
              v = r.layers instanceof Set ? r.layers : Array.isArray(r.layers) ? new Set(r.layers) : null,
              w = Object.assign(Object.assign({}, r), {
                layers: v
              });
            for (const P in this.sourceCaches) r.layers && !c[P] || d.push(Mt(this.sourceCaches[P], this._layers, m, e, w, s, this.map.terrain ? (M, D, L) => this.map.terrain.getElevation(M, D, L) : void 0));
            return this.placement && d.push((function(P, M, D, L, B, Z, te) {
              const ee = {},
                ne = Z.queryRenderedSymbols(L),
                oe = [];
              for (const me of Object.keys(ne).map(Number)) oe.push(te[me]);
              oe.sort(yt);
              for (const me of oe) {
                const ue = me.featureIndex.lookupSymbolFeatures(ne[me.bucketInstanceId], M, me.bucketIndex, me.sourceLayerIndex, B.filter, B.layers, B.availableImages, P);
                for (const be in ue) {
                  const Pe = ee[be] = ee[be] || [],
                    pe = ue[be];
                  pe.sort(((Fe, Je) => {
                    const Ge = me.featureSortOrder;
                    if (Ge) {
                      const He = Ge.indexOf(Fe.featureIndex);
                      return Ge.indexOf(Je.featureIndex) - He
                    }
                    return Je.featureIndex - Fe.featureIndex
                  }));
                  for (const Fe of pe) Pe.push(Fe)
                }
              }
              return (function(me, ue, be) {
                for (const Pe in me)
                  for (const pe of me[Pe]) St(pe, be[ue[Pe].source]);
                return me
              })(ee, P, D)
            })(this._layers, m, this.sourceCaches, e, w, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(d)
          }
          querySourceFeatures(e, r) {
            r && r.filter && this._validate(o.z.filter, "querySourceFeatures.filter", r.filter, null, r);
            const s = this.sourceCaches[e];
            return s ? (function(c, d) {
              const m = c.getRenderableIds().map((P => c.getTileByID(P))),
                v = [],
                w = {};
              for (let P = 0; P < m.length; P++) {
                const M = m[P],
                  D = M.tileID.canonical.key;
                w[D] || (w[D] = !0, M.querySourceFeatures(v, d))
              }
              return v
            })(s, r) : []
          }
          getLight() {
            return this.light.getLight()
          }
          setLight(e, r = {}) {
            this._checkLoaded();
            const s = this.light.getLight();
            let c = !1;
            for (const m in e)
              if (!o.bG(e[m], s[m])) {
                c = !0;
                break
              } if (!c) return;
            const d = {
              now: fe.now(),
              transition: o.e({
                duration: 300,
                delay: 0
              }, this.stylesheet.transition)
            };
            this.light.setLight(e, r), this.light.updateTransitions(d)
          }
          getProjection() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.projection
          }
          setProjection(e) {
            if (this._checkLoaded(), this.projection) {
              if (this.projection.name === e.type) return;
              this.projection.destroy(), delete this.projection
            }
            this.stylesheet.projection = e, this._setProjectionInternal(e.type)
          }
          getSky() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.sky
          }
          setSky(e, r = {}) {
            this._checkLoaded();
            const s = this.getSky();
            let c = !1;
            if (!e && !s) return;
            if (e && !s) c = !0;
            else if (!e && s) c = !0;
            else
              for (const m in e)
                if (!o.bG(e[m], s[m])) {
                  c = !0;
                  break
                } if (!c) return;
            const d = {
              now: fe.now(),
              transition: o.e({
                duration: 300,
                delay: 0
              }, this.stylesheet.transition)
            };
            this.stylesheet.sky = e, this.sky.setSky(e, r), this.sky.updateTransitions(d)
          }
          _setProjectionInternal(e) {
            const r = (function(s) {
              if (Array.isArray(s)) {
                const c = new uo({
                  type: s
                });
                return {
                  projection: c,
                  transform: new ta,
                  cameraHelper: new _c(c)
                }
              }
              switch (s) {
                case "mercator":
                  return {
                    projection: new Ps, transform: new Oi, cameraHelper: new rl
                  };
                case "globe": {
                  const c = new uo({
                    type: ["interpolate", ["linear"],
                      ["zoom"], 11, "vertical-perspective", 12, "mercator"
                    ]
                  });
                  return {
                    projection: c,
                    transform: new ta,
                    cameraHelper: new _c(c)
                  }
                }
                case "vertical-perspective":
                  return {
                    projection: new gh, transform: new zs, cameraHelper: new Un
                  };
                default:
                  return o.w(`Unknown projection name: ${s}. Falling back to mercator projection.`), {
                    projection: new Ps,
                    transform: new Oi,
                    cameraHelper: new rl
                  }
              }
            })(e);
            this.projection = r.projection, this.map.migrateProjection(r.transform, r.cameraHelper);
            for (const s in this.sourceCaches) this.sourceCaches[s].reload()
          }
          _validate(e, r, s, c, d = {}) {
            return (!d || d.validate !== !1) && _o(this, e.call(o.z, o.e({
              key: r,
              style: this.serialize(),
              value: s,
              styleSpec: o.v
            }, c)))
          }
          _remove(e = !0) {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), tr().off(dr, this._rtlPluginLoaded);
            for (const r in this._layers) this._layers[r].setEventedParent(null);
            for (const r in this.sourceCaches) {
              const s = this.sourceCaches[r];
              s.setEventedParent(null), s.onRemove(this.map)
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), e && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e)
          }
          _clearSource(e) {
            this.sourceCaches[e].clearTiles()
          }
          _reloadSource(e) {
            this.sourceCaches[e].resume(), this.sourceCaches[e].reload()
          }
          _updateSources(e) {
            for (const r in this.sourceCaches) this.sourceCaches[r].update(e, this.map.terrain)
          }
          _generateCollisionBoxes() {
            for (const e in this.sourceCaches) this._reloadSource(e)
          }
          _updatePlacement(e, r, s, c, d = !1) {
            let m = !1,
              v = !1;
            const w = {};
            for (const P of this._order) {
              const M = this._layers[P];
              if (M.type !== "symbol") continue;
              if (!w[M.source]) {
                const L = this.sourceCaches[M.source];
                w[M.source] = L.getRenderableIds(!0).map((B => L.getTileByID(B))).sort(((B, Z) => Z.tileID.overscaledZ - B.tileID.overscaledZ || (B.tileID.isLessThan(Z.tileID) ? -1 : 1)))
              }
              const D = this.crossTileSymbolIndex.addLayer(M, w[M.source], e.center.lng);
              m = m || D
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((d = d || this._layerOrderChanged || s === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(fe.now(), e.zoom)) && (this.pauseablePlacement = new Fi(e, this.map.terrain, this._order, d, r, s, c, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, w), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(fe.now()), v = !0), m && this.pauseablePlacement.placement.setStale()), v || m)
              for (const P of this._order) {
                const M = this._layers[P];
                M.type === "symbol" && this.placement.updateLayerOpacities(M, w[M.source])
              }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(fe.now())
          }
          _releaseSymbolFadeTiles() {
            for (const e in this.sourceCaches) this.sourceCaches[e].releaseSymbolFadeTiles()
          }
          getImages(e, r) {
            return o._(this, void 0, void 0, (function*() {
              const s = yield this.imageManager.getImages(r.icons);
              this._updateTilesForChangedImages();
              const c = this.sourceCaches[r.source];
              return c && c.setDependencies(r.tileID.key, r.type, r.icons), s
            }))
          }
          getGlyphs(e, r) {
            return o._(this, void 0, void 0, (function*() {
              const s = yield this.glyphManager.getGlyphs(r.stacks), c = this.sourceCaches[r.source];
              return c && c.setDependencies(r.tileID.key, r.type, [""]), s
            }))
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null
          }
          setGlyphs(e, r = {}) {
            this._checkLoaded(), e && this._validate(o.z.glyphs, "glyphs", e, null, r) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = e, this.glyphManager.entries = {}, this.glyphManager.setURL(e))
          }
          addSprite(e, r, s = {}, c) {
            this._checkLoaded();
            const d = [{
                id: e,
                url: r
              }],
              m = [...nt(this.stylesheet.sprite), ...d];
            this._validate(o.z.sprite, "sprite", m, null, s) || (this.stylesheet.sprite = m, this._loadSprite(d, !0, c))
          }
          removeSprite(e) {
            this._checkLoaded();
            const r = nt(this.stylesheet.sprite);
            if (r.find((s => s.id === e))) {
              if (this._spritesImagesIds[e])
                for (const s of this._spritesImagesIds[e]) this.imageManager.removeImage(s), this._changedImages[s] = !0;
              r.splice(r.findIndex((s => s.id === e)), 1), this.stylesheet.sprite = r.length > 0 ? r : void 0, delete this._spritesImagesIds[e], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.l("data", {
                dataType: "style"
              }))
            } else this.fire(new o.k(new Error(`Sprite "${e}" doesn't exists on this map.`)))
          }
          getSprite() {
            return nt(this.stylesheet.sprite)
          }
          setSprite(e, r = {}, s) {
            this._checkLoaded(), e && this._validate(o.z.sprite, "sprite", e, null, r) || (this.stylesheet.sprite = e, e ? this._loadSprite(e, !0, s) : (this._unloadSprite(), s && s(null)))
          }
        }
        var Kd = o.aI([{
          name: "a_pos",
          type: "Int16",
          components: 2
        }, {
          name: "a_texture_pos",
          type: "Int16",
          components: 2
        }]);
        class Yd {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null
          }
          bind(e, r, s, c, d, m, v, w, P) {
            this.context = e;
            let M = this.boundPaintVertexBuffers.length !== c.length;
            for (let D = 0; !M && D < c.length; D++) this.boundPaintVertexBuffers[D] !== c[D] && (M = !0);
            !this.vao || this.boundProgram !== r || this.boundLayoutVertexBuffer !== s || M || this.boundIndexBuffer !== d || this.boundVertexOffset !== m || this.boundDynamicVertexBuffer !== v || this.boundDynamicVertexBuffer2 !== w || this.boundDynamicVertexBuffer3 !== P ? this.freshBind(r, s, c, d, m, v, w, P) : (e.bindVertexArray.set(this.vao), v && v.bind(), d && d.dynamicDraw && d.bind(), w && w.bind(), P && P.bind())
          }
          freshBind(e, r, s, c, d, m, v, w) {
            const P = e.numAttributes,
              M = this.context,
              D = M.gl;
            this.vao && this.destroy(), this.vao = M.createVertexArray(), M.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = r, this.boundPaintVertexBuffers = s, this.boundIndexBuffer = c, this.boundVertexOffset = d, this.boundDynamicVertexBuffer = m, this.boundDynamicVertexBuffer2 = v, this.boundDynamicVertexBuffer3 = w, r.enableAttributes(D, e);
            for (const L of s) L.enableAttributes(D, e);
            m && m.enableAttributes(D, e), v && v.enableAttributes(D, e), w && w.enableAttributes(D, e), r.bind(), r.setVertexAttribPointers(D, e, d);
            for (const L of s) L.bind(), L.setVertexAttribPointers(D, e, d);
            m && (m.bind(), m.setVertexAttribPointers(D, e, d)), c && c.bind(), v && (v.bind(), v.setVertexAttribPointers(D, e, d)), w && (w.bind(), w.setVertexAttribPointers(D, e, d)), M.currentNumAttributes = P
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null)
          }
        }
        const Jd = (h, e, r, s, c) => ({
            u_texture: 0,
            u_ele_delta: h,
            u_fog_matrix: e,
            u_fog_color: r ? r.properties.get("fog-color") : o.be.white,
            u_fog_ground_blend: r ? r.properties.get("fog-ground-blend") : 1,
            u_fog_ground_blend_opacity: c ? 0 : r ? r.calculateFogBlendOpacity(s) : 0,
            u_horizon_color: r ? r.properties.get("horizon-color") : o.be.white,
            u_horizon_fog_blend: r ? r.properties.get("horizon-fog-blend") : 1,
            u_is_globe_mode: c ? 1 : 0
          }),
          Qd = {
            mainMatrix: "u_projection_matrix",
            tileMercatorCoords: "u_projection_tile_mercator_coords",
            clippingPlane: "u_projection_clipping_plane",
            projectionTransition: "u_projection_transition",
            fallbackMatrix: "u_projection_fallback_matrix"
          };

        function il(h) {
          const e = [];
          for (let r = 0; r < h.length; r++) {
            if (h[r] === null) continue;
            const s = h[r].split(" ");
            e.push(s.pop())
          }
          return e
        }
        class nl {
          constructor(e, r, s, c, d, m, v, w, P = []) {
            const M = e.gl;
            this.program = M.createProgram();
            const D = il(r.staticAttributes),
              L = s ? s.getBinderAttributes() : [],
              B = D.concat(L),
              Z = Ki.prelude.staticUniforms ? il(Ki.prelude.staticUniforms) : [],
              te = v.staticUniforms ? il(v.staticUniforms) : [],
              ee = r.staticUniforms ? il(r.staticUniforms) : [],
              ne = s ? s.getBinderUniforms() : [],
              oe = Z.concat(te).concat(ee).concat(ne),
              me = [];
            for (const Ge of oe) me.indexOf(Ge) < 0 && me.push(Ge);
            const ue = s ? s.defines() : [];
            Dn(M) && ue.unshift("#version 300 es"), d && ue.push("#define OVERDRAW_INSPECTOR;"), m && ue.push("#define TERRAIN3D;"), w && ue.push(w), P && ue.push(...P);
            let be = ue.concat(Ki.prelude.fragmentSource, v.fragmentSource, r.fragmentSource).join(`
`),
              Pe = ue.concat(Ki.prelude.vertexSource, v.vertexSource, r.vertexSource).join(`
`);
            Dn(M) || (be = (function(Ge) {
              return Ge.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(")
            })(be), Pe = (function(Ge) {
              return Ge.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(")
            })(Pe));
            const pe = M.createShader(M.FRAGMENT_SHADER);
            if (M.isContextLost()) return void(this.failedToCreate = !0);
            if (M.shaderSource(pe, be), M.compileShader(pe), !M.getShaderParameter(pe, M.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${M.getShaderInfoLog(pe)}`);
            M.attachShader(this.program, pe);
            const Fe = M.createShader(M.VERTEX_SHADER);
            if (M.isContextLost()) return void(this.failedToCreate = !0);
            if (M.shaderSource(Fe, Pe), M.compileShader(Fe), !M.getShaderParameter(Fe, M.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${M.getShaderInfoLog(Fe)}`);
            M.attachShader(this.program, Fe), this.attributes = {};
            const Je = {};
            this.numAttributes = B.length;
            for (let Ge = 0; Ge < this.numAttributes; Ge++) B[Ge] && (M.bindAttribLocation(this.program, Ge, B[Ge]), this.attributes[B[Ge]] = Ge);
            if (M.linkProgram(this.program), !M.getProgramParameter(this.program, M.LINK_STATUS)) throw new Error(`Program failed to link: ${M.getProgramInfoLog(this.program)}`);
            M.deleteShader(Fe), M.deleteShader(pe);
            for (let Ge = 0; Ge < me.length; Ge++) {
              const He = me[Ge];
              if (He && !Je[He]) {
                const Qe = M.getUniformLocation(this.program, He);
                Qe && (Je[He] = Qe)
              }
            }
            this.fixedUniforms = c(e, Je), this.terrainUniforms = ((Ge, He) => ({
              u_depth: new o.bO(Ge, He.u_depth),
              u_terrain: new o.bO(Ge, He.u_terrain),
              u_terrain_dim: new o.bf(Ge, He.u_terrain_dim),
              u_terrain_matrix: new o.bQ(Ge, He.u_terrain_matrix),
              u_terrain_unpack: new o.bR(Ge, He.u_terrain_unpack),
              u_terrain_exaggeration: new o.bf(Ge, He.u_terrain_exaggeration)
            }))(e, Je), this.projectionUniforms = ((Ge, He) => ({
              u_projection_matrix: new o.bQ(Ge, He.u_projection_matrix),
              u_projection_tile_mercator_coords: new o.bR(Ge, He.u_projection_tile_mercator_coords),
              u_projection_clipping_plane: new o.bR(Ge, He.u_projection_clipping_plane),
              u_projection_transition: new o.bf(Ge, He.u_projection_transition),
              u_projection_fallback_matrix: new o.bQ(Ge, He.u_projection_fallback_matrix)
            }))(e, Je), this.binderUniforms = s ? s.getUniforms(e, Je) : []
          }
          draw(e, r, s, c, d, m, v, w, P, M, D, L, B, Z, te, ee, ne, oe, me) {
            const ue = e.gl;
            if (this.failedToCreate) return;
            if (e.program.set(this.program), e.setDepthMode(s), e.setStencilMode(c), e.setColorMode(d), e.setCullFace(m), w) {
              e.activeTexture.set(ue.TEXTURE2), ue.bindTexture(ue.TEXTURE_2D, w.depthTexture), e.activeTexture.set(ue.TEXTURE3), ue.bindTexture(ue.TEXTURE_2D, w.texture);
              for (const Pe in this.terrainUniforms) this.terrainUniforms[Pe].set(w[Pe])
            }
            if (P)
              for (const Pe in P) this.projectionUniforms[Qd[Pe]].set(P[Pe]);
            if (v)
              for (const Pe in this.fixedUniforms) this.fixedUniforms[Pe].set(v[Pe]);
            ee && ee.setUniforms(e, this.binderUniforms, Z, {
              zoom: te
            });
            let be = 0;
            switch (r) {
              case ue.LINES:
                be = 2;
                break;
              case ue.TRIANGLES:
                be = 3;
                break;
              case ue.LINE_STRIP:
                be = 1
            }
            for (const Pe of B.get()) {
              const pe = Pe.vaos || (Pe.vaos = {});
              (pe[M] || (pe[M] = new Yd)).bind(e, this, D, ee ? ee.getPaintVertexBuffers() : [], L, Pe.vertexOffset, ne, oe, me), ue.drawElements(r, Pe.primitiveLength * be, ue.UNSIGNED_SHORT, Pe.primitiveOffset * be * 2)
            }
          }
        }

        function al(h, e, r) {
          const s = 1 / o.aB(r, 1, e.transform.tileZoom),
            c = Math.pow(2, r.tileID.overscaledZ),
            d = r.tileSize * Math.pow(2, e.transform.tileZoom) / c,
            m = d * (r.tileID.canonical.x + r.tileID.wrap * c),
            v = d * r.tileID.canonical.y;
          return {
            u_image: 0,
            u_texsize: r.imageAtlasTexture.size,
            u_scale: [s, h.fromScale, h.toScale],
            u_fade: h.t,
            u_pixel_coord_upper: [m >> 16, v >> 16],
            u_pixel_coord_lower: [65535 & m, 65535 & v]
          }
        }
        const go = (h, e, r, s) => {
            const c = h.style.light,
              d = c.properties.get("position"),
              m = [d.x, d.y, d.z],
              v = o.bU();
            c.properties.get("anchor") === "viewport" && o.bV(v, h.transform.bearingInRadians), o.bW(m, m, v);
            const w = h.transform.transformLightDirection(m),
              P = c.properties.get("color");
            return {
              u_lightpos: m,
              u_lightpos_globe: w,
              u_lightintensity: c.properties.get("intensity"),
              u_lightcolor: [P.r, P.g, P.b],
              u_vertical_gradient: +e,
              u_opacity: r,
              u_fill_translate: s
            }
          },
          vc = (h, e, r, s, c, d, m) => o.e(go(h, e, r, s), al(d, h, m), {
            u_height_factor: -Math.pow(2, c.overscaledZ) / m.tileSize / 8
          }),
          sl = (h, e, r, s) => o.e(al(e, h, r), {
            u_fill_translate: s
          }),
          Sa = (h, e) => ({
            u_world: h,
            u_fill_translate: e
          }),
          ep = (h, e, r, s, c) => o.e(sl(h, e, r, c), {
            u_world: s
          }),
          yc = (h, e, r, s, c) => {
            const d = h.transform;
            let m, v, w = 0;
            if (r.paint.get("circle-pitch-alignment") === "map") {
              const P = o.aB(e, 1, d.zoom);
              m = !0, v = [P, P], w = P / (o.$ * Math.pow(2, e.tileID.overscaledZ)) * 2 * Math.PI * c
            } else m = !1, v = d.pixelsToGLUnits;
            return {
              u_camera_to_center_distance: d.cameraToCenterDistance,
              u_scale_with_map: +(r.paint.get("circle-pitch-scale") === "map"),
              u_pitch_with_map: +m,
              u_device_pixel_ratio: h.pixelRatio,
              u_extrude_scale: v,
              u_globe_extrude_scale: w,
              u_translate: s
            }
          },
          vo = h => ({
            u_pixel_extrude_scale: [1 / h.width, 1 / h.height]
          }),
          yo = h => ({
            u_viewport_size: [h.width, h.height]
          }),
          yh = (h, e = 1) => ({
            u_color: h,
            u_overlay: 0,
            u_overlay_scale: e
          }),
          xo = (h, e, r, s) => {
            const c = o.aB(h, 1, e) / (o.$ * Math.pow(2, h.tileID.overscaledZ)) * 2 * Math.PI * s;
            return {
              u_extrude_scale: o.aB(h, 1, e),
              u_intensity: r,
              u_globe_extrude_scale: c
            }
          },
          xh = (h, e, r, s) => {
            const c = o.L();
            o.bX(c, 0, h.width, h.height, 0, 0, 1);
            const d = h.context.gl;
            return {
              u_matrix: c,
              u_world: [d.drawingBufferWidth, d.drawingBufferHeight],
              u_image: r,
              u_color_ramp: s,
              u_opacity: e.paint.get("heatmap-opacity")
            }
          },
          Ds = (h, e, r) => {
            const s = r.paint.get("hillshade-accent-color");
            let c;
            switch (r.paint.get("hillshade-method")) {
              case "basic":
                c = 4;
                break;
              case "combined":
                c = 1;
                break;
              case "igor":
                c = 2;
                break;
              case "multidirectional":
                c = 3;
                break;
              default:
                c = 0
            }
            const d = r.getIlluminationProperties();
            for (let m = 0; m < d.directionRadians.length; m++) r.paint.get("hillshade-illumination-anchor") === "viewport" && (d.directionRadians[m] += h.transform.bearingInRadians);
            return {
              u_image: 0,
              u_latrange: bh(0, e.tileID),
              u_exaggeration: r.paint.get("hillshade-exaggeration"),
              u_altitudes: d.altitudeRadians,
              u_azimuths: d.directionRadians,
              u_accent: s,
              u_method: c,
              u_highlights: d.highlightColor,
              u_shadows: d.shadowColor
            }
          },
          tp = (h, e) => {
            const r = e.stride,
              s = o.L();
            return o.bX(s, 0, o.$, -o.$, 0, 0, 1), o.M(s, s, [0, -o.$, 0]), {
              u_matrix: s,
              u_image: 1,
              u_dimension: [r, r],
              u_zoom: h.overscaledZ,
              u_unpack: e.getUnpackVector()
            }
          };

        function bh(h, e) {
          const r = Math.pow(2, e.canonical.z),
            s = e.canonical.y;
          return [new o.a0(0, s / r).toLngLat().lat, new o.a0(0, (s + 1) / r).toLngLat().lat]
        }
        const rp = (h, e, r = 0) => ({
            u_image: 0,
            u_unpack: e.getUnpackVector(),
            u_dimension: [e.stride, e.stride],
            u_elevation_stops: 1,
            u_color_stops: 4,
            u_color_ramp_size: r,
            u_opacity: h.paint.get("color-relief-opacity")
          }),
          ol = (h, e, r, s) => {
            const c = h.transform;
            return {
              u_translation: wc(h, e, r),
              u_ratio: s / o.aB(e, 1, c.zoom),
              u_device_pixel_ratio: h.pixelRatio,
              u_units_to_pixels: [1 / c.pixelsToGLUnits[0], 1 / c.pixelsToGLUnits[1]]
            }
          },
          xc = (h, e, r, s, c) => o.e(ol(h, e, r, s), {
            u_image: 0,
            u_image_height: c
          }),
          wh = (h, e, r, s, c) => {
            const d = h.transform,
              m = bc(e, d);
            return {
              u_translation: wc(h, e, r),
              u_texsize: e.imageAtlasTexture.size,
              u_ratio: s / o.aB(e, 1, d.zoom),
              u_device_pixel_ratio: h.pixelRatio,
              u_image: 0,
              u_scale: [m, c.fromScale, c.toScale],
              u_fade: c.t,
              u_units_to_pixels: [1 / d.pixelsToGLUnits[0], 1 / d.pixelsToGLUnits[1]]
            }
          },
          Th = (h, e, r, s, c, d) => {
            const m = h.lineAtlas,
              v = bc(e, h.transform),
              w = r.layout.get("line-cap") === "round",
              P = m.getDash(c.from, w),
              M = m.getDash(c.to, w),
              D = P.width * d.fromScale,
              L = M.width * d.toScale;
            return o.e(ol(h, e, r, s), {
              u_patternscale_a: [v / D, -P.height / 2],
              u_patternscale_b: [v / L, -M.height / 2],
              u_sdfgamma: m.width / (256 * Math.min(D, L) * h.pixelRatio) / 2,
              u_image: 0,
              u_tex_y_a: P.y,
              u_tex_y_b: M.y,
              u_mix: d.t
            })
          };

        function bc(h, e) {
          return 1 / o.aB(h, 1, e.tileZoom)
        }

        function wc(h, e, r) {
          return o.aC(h.transform, e, r.paint.get("line-translate"), r.paint.get("line-translate-anchor"))
        }
        const us = (h, e, r, s, c) => {
          return {
            u_tl_parent: h,
            u_scale_parent: e,
            u_buffer_scale: 1,
            u_fade_t: r.mix,
            u_opacity: r.opacity * s.paint.get("raster-opacity"),
            u_image0: 0,
            u_image1: 1,
            u_brightness_low: s.paint.get("raster-brightness-min"),
            u_brightness_high: s.paint.get("raster-brightness-max"),
            u_saturation_factor: (m = s.paint.get("raster-saturation"), m > 0 ? 1 - 1 / (1.001 - m) : -m),
            u_contrast_factor: (d = s.paint.get("raster-contrast"), d > 0 ? 1 / (1 - d) : 1 + d),
            u_spin_weights: Ch(s.paint.get("raster-hue-rotate")),
            u_coords_top: [c[0].x, c[0].y, c[1].x, c[1].y],
            u_coords_bottom: [c[3].x, c[3].y, c[2].x, c[2].y]
          };
          var d, m
        };

        function Ch(h) {
          h *= Math.PI / 180;
          const e = Math.sin(h),
            r = Math.cos(h);
          return [(2 * r + 1) / 3, (-Math.sqrt(3) * e - r + 1) / 3, (Math.sqrt(3) * e - r + 1) / 3]
        }
        const Tc = (h, e, r, s, c, d, m, v, w, P, M, D, L) => {
            const B = m.transform;
            return {
              u_is_size_zoom_constant: +(h === "constant" || h === "source"),
              u_is_size_feature_constant: +(h === "constant" || h === "camera"),
              u_size_t: e ? e.uSizeT : 0,
              u_size: e ? e.uSize : 0,
              u_camera_to_center_distance: B.cameraToCenterDistance,
              u_pitch: B.pitch / 360 * 2 * Math.PI,
              u_rotate_symbol: +r,
              u_aspect_ratio: B.width / B.height,
              u_fade_change: m.options.fadeDuration ? m.symbolFadeChange : 1,
              u_label_plane_matrix: v,
              u_coord_matrix: w,
              u_is_text: +M,
              u_pitch_with_map: +s,
              u_is_along_line: c,
              u_is_variable_anchor: d,
              u_texsize: D,
              u_texture: 0,
              u_translation: P,
              u_pitched_scale: L
            }
          },
          Rs = (h, e, r, s, c, d, m, v, w, P, M, D, L, B) => {
            const Z = m.transform;
            return o.e(Tc(h, e, r, s, c, d, m, v, w, P, M, D, B), {
              u_gamma_scale: s ? Math.cos(Z.pitch * Math.PI / 180) * Z.cameraToCenterDistance : 1,
              u_device_pixel_ratio: m.pixelRatio,
              u_is_halo: 1
            })
          },
          ip = (h, e, r, s, c, d, m, v, w, P, M, D, L) => o.e(Rs(h, e, r, s, c, d, m, v, w, P, !0, M, 0, L), {
            u_texsize_icon: D,
            u_texture_icon: 1
          }),
          ll = (h, e) => ({
            u_opacity: h,
            u_color: e
          }),
          np = (h, e, r, s, c) => o.e((function(d, m, v, w) {
            const P = v.imageManager.getPattern(d.from.toString()),
              M = v.imageManager.getPattern(d.to.toString()),
              {
                width: D,
                height: L
              } = v.imageManager.getPixelSize(),
              B = Math.pow(2, w.tileID.overscaledZ),
              Z = w.tileSize * Math.pow(2, v.transform.tileZoom) / B,
              te = Z * (w.tileID.canonical.x + w.tileID.wrap * B),
              ee = Z * w.tileID.canonical.y;
            return {
              u_image: 0,
              u_pattern_tl_a: P.tl,
              u_pattern_br_a: P.br,
              u_pattern_tl_b: M.tl,
              u_pattern_br_b: M.br,
              u_texsize: [D, L],
              u_mix: m.t,
              u_pattern_size_a: P.displaySize,
              u_pattern_size_b: M.displaySize,
              u_scale_a: m.fromScale,
              u_scale_b: m.toScale,
              u_tile_units_to_pixels: 1 / o.aB(w, 1, v.transform.tileZoom),
              u_pixel_coord_upper: [te >> 16, ee >> 16],
              u_pixel_coord_lower: [65535 & te, 65535 & ee]
            }
          })(r, c, e, s), {
            u_opacity: h
          }),
          Sh = (h, e) => {},
          Ph = {
            fillExtrusion: (h, e) => ({
              u_lightpos: new o.bS(h, e.u_lightpos),
              u_lightpos_globe: new o.bS(h, e.u_lightpos_globe),
              u_lightintensity: new o.bf(h, e.u_lightintensity),
              u_lightcolor: new o.bS(h, e.u_lightcolor),
              u_vertical_gradient: new o.bf(h, e.u_vertical_gradient),
              u_opacity: new o.bf(h, e.u_opacity),
              u_fill_translate: new o.bT(h, e.u_fill_translate)
            }),
            fillExtrusionPattern: (h, e) => ({
              u_lightpos: new o.bS(h, e.u_lightpos),
              u_lightpos_globe: new o.bS(h, e.u_lightpos_globe),
              u_lightintensity: new o.bf(h, e.u_lightintensity),
              u_lightcolor: new o.bS(h, e.u_lightcolor),
              u_vertical_gradient: new o.bf(h, e.u_vertical_gradient),
              u_height_factor: new o.bf(h, e.u_height_factor),
              u_opacity: new o.bf(h, e.u_opacity),
              u_fill_translate: new o.bT(h, e.u_fill_translate),
              u_image: new o.bO(h, e.u_image),
              u_texsize: new o.bT(h, e.u_texsize),
              u_pixel_coord_upper: new o.bT(h, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new o.bT(h, e.u_pixel_coord_lower),
              u_scale: new o.bS(h, e.u_scale),
              u_fade: new o.bf(h, e.u_fade)
            }),
            fill: (h, e) => ({
              u_fill_translate: new o.bT(h, e.u_fill_translate)
            }),
            fillPattern: (h, e) => ({
              u_image: new o.bO(h, e.u_image),
              u_texsize: new o.bT(h, e.u_texsize),
              u_pixel_coord_upper: new o.bT(h, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new o.bT(h, e.u_pixel_coord_lower),
              u_scale: new o.bS(h, e.u_scale),
              u_fade: new o.bf(h, e.u_fade),
              u_fill_translate: new o.bT(h, e.u_fill_translate)
            }),
            fillOutline: (h, e) => ({
              u_world: new o.bT(h, e.u_world),
              u_fill_translate: new o.bT(h, e.u_fill_translate)
            }),
            fillOutlinePattern: (h, e) => ({
              u_world: new o.bT(h, e.u_world),
              u_image: new o.bO(h, e.u_image),
              u_texsize: new o.bT(h, e.u_texsize),
              u_pixel_coord_upper: new o.bT(h, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new o.bT(h, e.u_pixel_coord_lower),
              u_scale: new o.bS(h, e.u_scale),
              u_fade: new o.bf(h, e.u_fade),
              u_fill_translate: new o.bT(h, e.u_fill_translate)
            }),
            circle: (h, e) => ({
              u_camera_to_center_distance: new o.bf(h, e.u_camera_to_center_distance),
              u_scale_with_map: new o.bO(h, e.u_scale_with_map),
              u_pitch_with_map: new o.bO(h, e.u_pitch_with_map),
              u_extrude_scale: new o.bT(h, e.u_extrude_scale),
              u_device_pixel_ratio: new o.bf(h, e.u_device_pixel_ratio),
              u_globe_extrude_scale: new o.bf(h, e.u_globe_extrude_scale),
              u_translate: new o.bT(h, e.u_translate)
            }),
            collisionBox: (h, e) => ({
              u_pixel_extrude_scale: new o.bT(h, e.u_pixel_extrude_scale)
            }),
            collisionCircle: (h, e) => ({
              u_viewport_size: new o.bT(h, e.u_viewport_size)
            }),
            debug: (h, e) => ({
              u_color: new o.bP(h, e.u_color),
              u_overlay: new o.bO(h, e.u_overlay),
              u_overlay_scale: new o.bf(h, e.u_overlay_scale)
            }),
            depth: Sh,
            clippingMask: Sh,
            heatmap: (h, e) => ({
              u_extrude_scale: new o.bf(h, e.u_extrude_scale),
              u_intensity: new o.bf(h, e.u_intensity),
              u_globe_extrude_scale: new o.bf(h, e.u_globe_extrude_scale)
            }),
            heatmapTexture: (h, e) => ({
              u_matrix: new o.bQ(h, e.u_matrix),
              u_world: new o.bT(h, e.u_world),
              u_image: new o.bO(h, e.u_image),
              u_color_ramp: new o.bO(h, e.u_color_ramp),
              u_opacity: new o.bf(h, e.u_opacity)
            }),
            hillshade: (h, e) => ({
              u_image: new o.bO(h, e.u_image),
              u_latrange: new o.bT(h, e.u_latrange),
              u_exaggeration: new o.bf(h, e.u_exaggeration),
              u_altitudes: new o.bZ(h, e.u_altitudes),
              u_azimuths: new o.bZ(h, e.u_azimuths),
              u_accent: new o.bP(h, e.u_accent),
              u_method: new o.bO(h, e.u_method),
              u_shadows: new o.bY(h, e.u_shadows),
              u_highlights: new o.bY(h, e.u_highlights)
            }),
            hillshadePrepare: (h, e) => ({
              u_matrix: new o.bQ(h, e.u_matrix),
              u_image: new o.bO(h, e.u_image),
              u_dimension: new o.bT(h, e.u_dimension),
              u_zoom: new o.bf(h, e.u_zoom),
              u_unpack: new o.bR(h, e.u_unpack)
            }),
            colorRelief: (h, e) => ({
              u_image: new o.bO(h, e.u_image),
              u_unpack: new o.bR(h, e.u_unpack),
              u_dimension: new o.bT(h, e.u_dimension),
              u_elevation_stops: new o.bO(h, e.u_elevation_stops),
              u_color_stops: new o.bO(h, e.u_color_stops),
              u_color_ramp_size: new o.bO(h, e.u_color_ramp_size),
              u_opacity: new o.bf(h, e.u_opacity)
            }),
            line: (h, e) => ({
              u_translation: new o.bT(h, e.u_translation),
              u_ratio: new o.bf(h, e.u_ratio),
              u_device_pixel_ratio: new o.bf(h, e.u_device_pixel_ratio),
              u_units_to_pixels: new o.bT(h, e.u_units_to_pixels)
            }),
            lineGradient: (h, e) => ({
              u_translation: new o.bT(h, e.u_translation),
              u_ratio: new o.bf(h, e.u_ratio),
              u_device_pixel_ratio: new o.bf(h, e.u_device_pixel_ratio),
              u_units_to_pixels: new o.bT(h, e.u_units_to_pixels),
              u_image: new o.bO(h, e.u_image),
              u_image_height: new o.bf(h, e.u_image_height)
            }),
            linePattern: (h, e) => ({
              u_translation: new o.bT(h, e.u_translation),
              u_texsize: new o.bT(h, e.u_texsize),
              u_ratio: new o.bf(h, e.u_ratio),
              u_device_pixel_ratio: new o.bf(h, e.u_device_pixel_ratio),
              u_image: new o.bO(h, e.u_image),
              u_units_to_pixels: new o.bT(h, e.u_units_to_pixels),
              u_scale: new o.bS(h, e.u_scale),
              u_fade: new o.bf(h, e.u_fade)
            }),
            lineSDF: (h, e) => ({
              u_translation: new o.bT(h, e.u_translation),
              u_ratio: new o.bf(h, e.u_ratio),
              u_device_pixel_ratio: new o.bf(h, e.u_device_pixel_ratio),
              u_units_to_pixels: new o.bT(h, e.u_units_to_pixels),
              u_patternscale_a: new o.bT(h, e.u_patternscale_a),
              u_patternscale_b: new o.bT(h, e.u_patternscale_b),
              u_sdfgamma: new o.bf(h, e.u_sdfgamma),
              u_image: new o.bO(h, e.u_image),
              u_tex_y_a: new o.bf(h, e.u_tex_y_a),
              u_tex_y_b: new o.bf(h, e.u_tex_y_b),
              u_mix: new o.bf(h, e.u_mix)
            }),
            raster: (h, e) => ({
              u_tl_parent: new o.bT(h, e.u_tl_parent),
              u_scale_parent: new o.bf(h, e.u_scale_parent),
              u_buffer_scale: new o.bf(h, e.u_buffer_scale),
              u_fade_t: new o.bf(h, e.u_fade_t),
              u_opacity: new o.bf(h, e.u_opacity),
              u_image0: new o.bO(h, e.u_image0),
              u_image1: new o.bO(h, e.u_image1),
              u_brightness_low: new o.bf(h, e.u_brightness_low),
              u_brightness_high: new o.bf(h, e.u_brightness_high),
              u_saturation_factor: new o.bf(h, e.u_saturation_factor),
              u_contrast_factor: new o.bf(h, e.u_contrast_factor),
              u_spin_weights: new o.bS(h, e.u_spin_weights),
              u_coords_top: new o.bR(h, e.u_coords_top),
              u_coords_bottom: new o.bR(h, e.u_coords_bottom)
            }),
            symbolIcon: (h, e) => ({
              u_is_size_zoom_constant: new o.bO(h, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new o.bO(h, e.u_is_size_feature_constant),
              u_size_t: new o.bf(h, e.u_size_t),
              u_size: new o.bf(h, e.u_size),
              u_camera_to_center_distance: new o.bf(h, e.u_camera_to_center_distance),
              u_pitch: new o.bf(h, e.u_pitch),
              u_rotate_symbol: new o.bO(h, e.u_rotate_symbol),
              u_aspect_ratio: new o.bf(h, e.u_aspect_ratio),
              u_fade_change: new o.bf(h, e.u_fade_change),
              u_label_plane_matrix: new o.bQ(h, e.u_label_plane_matrix),
              u_coord_matrix: new o.bQ(h, e.u_coord_matrix),
              u_is_text: new o.bO(h, e.u_is_text),
              u_pitch_with_map: new o.bO(h, e.u_pitch_with_map),
              u_is_along_line: new o.bO(h, e.u_is_along_line),
              u_is_variable_anchor: new o.bO(h, e.u_is_variable_anchor),
              u_texsize: new o.bT(h, e.u_texsize),
              u_texture: new o.bO(h, e.u_texture),
              u_translation: new o.bT(h, e.u_translation),
              u_pitched_scale: new o.bf(h, e.u_pitched_scale)
            }),
            symbolSDF: (h, e) => ({
              u_is_size_zoom_constant: new o.bO(h, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new o.bO(h, e.u_is_size_feature_constant),
              u_size_t: new o.bf(h, e.u_size_t),
              u_size: new o.bf(h, e.u_size),
              u_camera_to_center_distance: new o.bf(h, e.u_camera_to_center_distance),
              u_pitch: new o.bf(h, e.u_pitch),
              u_rotate_symbol: new o.bO(h, e.u_rotate_symbol),
              u_aspect_ratio: new o.bf(h, e.u_aspect_ratio),
              u_fade_change: new o.bf(h, e.u_fade_change),
              u_label_plane_matrix: new o.bQ(h, e.u_label_plane_matrix),
              u_coord_matrix: new o.bQ(h, e.u_coord_matrix),
              u_is_text: new o.bO(h, e.u_is_text),
              u_pitch_with_map: new o.bO(h, e.u_pitch_with_map),
              u_is_along_line: new o.bO(h, e.u_is_along_line),
              u_is_variable_anchor: new o.bO(h, e.u_is_variable_anchor),
              u_texsize: new o.bT(h, e.u_texsize),
              u_texture: new o.bO(h, e.u_texture),
              u_gamma_scale: new o.bf(h, e.u_gamma_scale),
              u_device_pixel_ratio: new o.bf(h, e.u_device_pixel_ratio),
              u_is_halo: new o.bO(h, e.u_is_halo),
              u_translation: new o.bT(h, e.u_translation),
              u_pitched_scale: new o.bf(h, e.u_pitched_scale)
            }),
            symbolTextAndIcon: (h, e) => ({
              u_is_size_zoom_constant: new o.bO(h, e.u_is_size_zoom_constant),
              u_is_size_feature_constant: new o.bO(h, e.u_is_size_feature_constant),
              u_size_t: new o.bf(h, e.u_size_t),
              u_size: new o.bf(h, e.u_size),
              u_camera_to_center_distance: new o.bf(h, e.u_camera_to_center_distance),
              u_pitch: new o.bf(h, e.u_pitch),
              u_rotate_symbol: new o.bO(h, e.u_rotate_symbol),
              u_aspect_ratio: new o.bf(h, e.u_aspect_ratio),
              u_fade_change: new o.bf(h, e.u_fade_change),
              u_label_plane_matrix: new o.bQ(h, e.u_label_plane_matrix),
              u_coord_matrix: new o.bQ(h, e.u_coord_matrix),
              u_is_text: new o.bO(h, e.u_is_text),
              u_pitch_with_map: new o.bO(h, e.u_pitch_with_map),
              u_is_along_line: new o.bO(h, e.u_is_along_line),
              u_is_variable_anchor: new o.bO(h, e.u_is_variable_anchor),
              u_texsize: new o.bT(h, e.u_texsize),
              u_texsize_icon: new o.bT(h, e.u_texsize_icon),
              u_texture: new o.bO(h, e.u_texture),
              u_texture_icon: new o.bO(h, e.u_texture_icon),
              u_gamma_scale: new o.bf(h, e.u_gamma_scale),
              u_device_pixel_ratio: new o.bf(h, e.u_device_pixel_ratio),
              u_is_halo: new o.bO(h, e.u_is_halo),
              u_translation: new o.bT(h, e.u_translation),
              u_pitched_scale: new o.bf(h, e.u_pitched_scale)
            }),
            background: (h, e) => ({
              u_opacity: new o.bf(h, e.u_opacity),
              u_color: new o.bP(h, e.u_color)
            }),
            backgroundPattern: (h, e) => ({
              u_opacity: new o.bf(h, e.u_opacity),
              u_image: new o.bO(h, e.u_image),
              u_pattern_tl_a: new o.bT(h, e.u_pattern_tl_a),
              u_pattern_br_a: new o.bT(h, e.u_pattern_br_a),
              u_pattern_tl_b: new o.bT(h, e.u_pattern_tl_b),
              u_pattern_br_b: new o.bT(h, e.u_pattern_br_b),
              u_texsize: new o.bT(h, e.u_texsize),
              u_mix: new o.bf(h, e.u_mix),
              u_pattern_size_a: new o.bT(h, e.u_pattern_size_a),
              u_pattern_size_b: new o.bT(h, e.u_pattern_size_b),
              u_scale_a: new o.bf(h, e.u_scale_a),
              u_scale_b: new o.bf(h, e.u_scale_b),
              u_pixel_coord_upper: new o.bT(h, e.u_pixel_coord_upper),
              u_pixel_coord_lower: new o.bT(h, e.u_pixel_coord_lower),
              u_tile_units_to_pixels: new o.bf(h, e.u_tile_units_to_pixels)
            }),
            terrain: (h, e) => ({
              u_texture: new o.bO(h, e.u_texture),
              u_ele_delta: new o.bf(h, e.u_ele_delta),
              u_fog_matrix: new o.bQ(h, e.u_fog_matrix),
              u_fog_color: new o.bP(h, e.u_fog_color),
              u_fog_ground_blend: new o.bf(h, e.u_fog_ground_blend),
              u_fog_ground_blend_opacity: new o.bf(h, e.u_fog_ground_blend_opacity),
              u_horizon_color: new o.bP(h, e.u_horizon_color),
              u_horizon_fog_blend: new o.bf(h, e.u_horizon_fog_blend),
              u_is_globe_mode: new o.bf(h, e.u_is_globe_mode)
            }),
            terrainDepth: (h, e) => ({
              u_ele_delta: new o.bf(h, e.u_ele_delta)
            }),
            terrainCoords: (h, e) => ({
              u_texture: new o.bO(h, e.u_texture),
              u_terrain_coords_id: new o.bf(h, e.u_terrain_coords_id),
              u_ele_delta: new o.bf(h, e.u_ele_delta)
            }),
            projectionErrorMeasurement: (h, e) => ({
              u_input: new o.bf(h, e.u_input),
              u_output_expected: new o.bf(h, e.u_output_expected)
            }),
            atmosphere: (h, e) => ({
              u_sun_pos: new o.bS(h, e.u_sun_pos),
              u_atmosphere_blend: new o.bf(h, e.u_atmosphere_blend),
              u_globe_position: new o.bS(h, e.u_globe_position),
              u_globe_radius: new o.bf(h, e.u_globe_radius),
              u_inv_proj_matrix: new o.bQ(h, e.u_inv_proj_matrix)
            }),
            sky: (h, e) => ({
              u_sky_color: new o.bP(h, e.u_sky_color),
              u_horizon_color: new o.bP(h, e.u_horizon_color),
              u_horizon: new o.bT(h, e.u_horizon),
              u_horizon_normal: new o.bT(h, e.u_horizon_normal),
              u_sky_horizon_blend: new o.bf(h, e.u_sky_horizon_blend),
              u_sky_blend: new o.bf(h, e.u_sky_blend)
            })
          };
        class Ih {
          constructor(e, r, s) {
            this.context = e;
            const c = e.gl;
            this.buffer = c.createBuffer(), this.dynamicDraw = !!s, this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), c.bufferData(c.ELEMENT_ARRAY_BUFFER, r.arrayBuffer, this.dynamicDraw ? c.DYNAMIC_DRAW : c.STATIC_DRAW), this.dynamicDraw || delete r.arrayBuffer
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer)
          }
          updateData(e) {
            const r = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), r.bufferSubData(r.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer)
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer)
          }
        }
        const Mh = {
          Int8: "BYTE",
          Uint8: "UNSIGNED_BYTE",
          Int16: "SHORT",
          Uint16: "UNSIGNED_SHORT",
          Int32: "INT",
          Uint32: "UNSIGNED_INT",
          Float32: "FLOAT"
        };
        class Cc {
          constructor(e, r, s, c) {
            this.length = r.length, this.attributes = s, this.itemSize = r.bytesPerElement, this.dynamicDraw = c, this.context = e;
            const d = e.gl;
            this.buffer = d.createBuffer(), e.bindVertexBuffer.set(this.buffer), d.bufferData(d.ARRAY_BUFFER, r.arrayBuffer, this.dynamicDraw ? d.DYNAMIC_DRAW : d.STATIC_DRAW), this.dynamicDraw || delete r.arrayBuffer
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer)
          }
          updateData(e) {
            if (e.length !== this.length) throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`);
            const r = this.context.gl;
            this.bind(), r.bufferSubData(r.ARRAY_BUFFER, 0, e.arrayBuffer)
          }
          enableAttributes(e, r) {
            for (let s = 0; s < this.attributes.length; s++) {
              const c = r.attributes[this.attributes[s].name];
              c !== void 0 && e.enableVertexAttribArray(c)
            }
          }
          setVertexAttribPointers(e, r, s) {
            for (let c = 0; c < this.attributes.length; c++) {
              const d = this.attributes[c],
                m = r.attributes[d.name];
              m !== void 0 && e.vertexAttribPointer(m, d.components, e[Mh[d.type]], !1, this.itemSize, d.offset + this.itemSize * (s || 0))
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer)
          }
        }
        class yi {
          constructor(e) {
            this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1
          }
          get() {
            return this.current
          }
          set(e) {}
          getDefault() {
            return this.default
          }
          setDefault() {
            this.set(this.default)
          }
        }
        class cl extends yi {
          getDefault() {
            return o.be.transparent
          }
          set(e) {
            const r = this.current;
            (e.r !== r.r || e.g !== r.g || e.b !== r.b || e.a !== r.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1)
          }
        }
        class Da extends yi {
          getDefault() {
            return 1
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1)
          }
        }
        class Sc extends yi {
          getDefault() {
            return 0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1)
          }
        }
        class Pc extends yi {
          getDefault() {
            return [!0, !0, !0, !0]
          }
          set(e) {
            const r = this.current;
            (e[0] !== r[0] || e[1] !== r[1] || e[2] !== r[2] || e[3] !== r[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1)
          }
        }
        class Ic extends yi {
          getDefault() {
            return !0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1)
          }
        }
        class Ah extends yi {
          getDefault() {
            return 255
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1)
          }
        }
        class Mc extends yi {
          getDefault() {
            return {
              func: this.gl.ALWAYS,
              ref: 0,
              mask: 255
            }
          }
          set(e) {
            const r = this.current;
            (e.func !== r.func || e.ref !== r.ref || e.mask !== r.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1)
          }
        }
        class hs extends yi {
          getDefault() {
            const e = this.gl;
            return [e.KEEP, e.KEEP, e.KEEP]
          }
          set(e) {
            const r = this.current;
            (e[0] !== r[0] || e[1] !== r[1] || e[2] !== r[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1)
          }
        }
        class Ac extends yi {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            e ? r.enable(r.STENCIL_TEST) : r.disable(r.STENCIL_TEST), this.current = e, this.dirty = !1
          }
        }
        class ap extends yi {
          getDefault() {
            return [0, 1]
          }
          set(e) {
            const r = this.current;
            (e[0] !== r[0] || e[1] !== r[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1)
          }
        }
        class sp extends yi {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            e ? r.enable(r.DEPTH_TEST) : r.disable(r.DEPTH_TEST), this.current = e, this.dirty = !1
          }
        }
        class op extends yi {
          getDefault() {
            return this.gl.LESS
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1)
          }
        }
        class lp extends yi {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            e ? r.enable(r.BLEND) : r.disable(r.BLEND), this.current = e, this.dirty = !1
          }
        }
        class kh extends yi {
          getDefault() {
            const e = this.gl;
            return [e.ONE, e.ZERO]
          }
          set(e) {
            const r = this.current;
            (e[0] !== r[0] || e[1] !== r[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1)
          }
        }
        class cp extends yi {
          getDefault() {
            return o.be.transparent
          }
          set(e) {
            const r = this.current;
            (e.r !== r.r || e.g !== r.g || e.b !== r.b || e.a !== r.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1)
          }
        }
        class Eh extends yi {
          getDefault() {
            return this.gl.FUNC_ADD
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = !1)
          }
        }
        class ul extends yi {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            e ? r.enable(r.CULL_FACE) : r.disable(r.CULL_FACE), this.current = e, this.dirty = !1
          }
        }
        class hl extends yi {
          getDefault() {
            return this.gl.BACK
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1)
          }
        }
        class dl extends yi {
          getDefault() {
            return this.gl.CCW
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1)
          }
        }
        class kc extends yi {
          getDefault() {
            return null
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1)
          }
        }
        class ds extends yi {
          getDefault() {
            return this.gl.TEXTURE0
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1)
          }
        }
        class bo extends yi {
          getDefault() {
            const e = this.gl;
            return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight]
          }
          set(e) {
            const r = this.current;
            (e[0] !== r[0] || e[1] !== r[1] || e[2] !== r[2] || e[3] !== r[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1)
          }
        }
        class Bs extends yi {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            r.bindFramebuffer(r.FRAMEBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class la extends yi {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            r.bindRenderbuffer(r.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class zh extends yi {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            r.bindTexture(r.TEXTURE_2D, e), this.current = e, this.dirty = !1
          }
        }
        class Lh extends yi {
          getDefault() {
            return null
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            r.bindBuffer(r.ARRAY_BUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class Ec extends yi {
          getDefault() {
            return null
          }
          set(e) {
            const r = this.gl;
            r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class ps extends yi {
          getDefault() {
            return null
          }
          set(e) {
            var r;
            if (e === this.current && !this.dirty) return;
            const s = this.gl;
            Dn(s) ? s.bindVertexArray(e) : (r = s.getExtension("OES_vertex_array_object")) === null || r === void 0 || r.bindVertexArrayOES(e), this.current = e, this.dirty = !1
          }
        }
        class pl extends yi {
          getDefault() {
            return 4
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            r.pixelStorei(r.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1
          }
        }
        class fl extends yi {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1
          }
        }
        class wo extends yi {
          getDefault() {
            return !1
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const r = this.gl;
            r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1
          }
        }
        class Fs extends yi {
          constructor(e, r) {
            super(e), this.context = e, this.parent = r
          }
          getDefault() {
            return null
          }
        }
        class Dh extends Fs {
          setDirty() {
            this.dirty = !0
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const r = this.gl;
            r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1
          }
        }
        class Os extends Fs {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const r = this.gl;
            r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        class Ns extends Fs {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const r = this.gl;
            r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, e), this.current = e, this.dirty = !1
          }
        }
        const zc = "Framebuffer is not complete";
        class Lc {
          constructor(e, r, s, c, d) {
            this.context = e, this.width = r, this.height = s;
            const m = e.gl,
              v = this.framebuffer = m.createFramebuffer();
            if (this.colorAttachment = new Dh(e, v), c) this.depthAttachment = d ? new Ns(e, v) : new Os(e, v);
            else if (d) throw new Error("Stencil cannot be set without depth");
            if (m.checkFramebufferStatus(m.FRAMEBUFFER) !== m.FRAMEBUFFER_COMPLETE) throw new Error(zc)
          }
          destroy() {
            const e = this.context.gl,
              r = this.colorAttachment.get();
            if (r && e.deleteTexture(r), this.depthAttachment) {
              const s = this.depthAttachment.get();
              s && e.deleteRenderbuffer(s)
            }
            e.deleteFramebuffer(this.framebuffer)
          }
        }
        class oi {
          constructor(e) {
            var r, s;
            if (this.gl = e, this.clearColor = new cl(this), this.clearDepth = new Da(this), this.clearStencil = new Sc(this), this.colorMask = new Pc(this), this.depthMask = new Ic(this), this.stencilMask = new Ah(this), this.stencilFunc = new Mc(this), this.stencilOp = new hs(this), this.stencilTest = new Ac(this), this.depthRange = new ap(this), this.depthTest = new sp(this), this.depthFunc = new op(this), this.blend = new lp(this), this.blendFunc = new kh(this), this.blendColor = new cp(this), this.blendEquation = new Eh(this), this.cullFace = new ul(this), this.cullFaceSide = new hl(this), this.frontFace = new dl(this), this.program = new kc(this), this.activeTexture = new ds(this), this.viewport = new bo(this), this.bindFramebuffer = new Bs(this), this.bindRenderbuffer = new la(this), this.bindTexture = new zh(this), this.bindVertexBuffer = new Lh(this), this.bindElementBuffer = new Ec(this), this.bindVertexArray = new ps(this), this.pixelStoreUnpack = new pl(this), this.pixelStoreUnpackPremultiplyAlpha = new fl(this), this.pixelStoreUnpackFlipY = new wo(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), Dn(e)) {
              this.HALF_FLOAT = e.HALF_FLOAT;
              const c = e.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = (r = e.RGBA16F) !== null && r !== void 0 ? r : c == null ? void 0 : c.RGBA16F_EXT, this.RGB16F = (s = e.RGB16F) !== null && s !== void 0 ? s : c == null ? void 0 : c.RGB16F_EXT, e.getExtension("EXT_color_buffer_float")
            } else {
              e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear");
              const c = e.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = c == null ? void 0 : c.HALF_FLOAT_OES
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault()
          }
          setDirty() {
            this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0
          }
          createIndexBuffer(e, r) {
            return new Ih(this, e, r)
          }
          createVertexBuffer(e, r, s) {
            return new Cc(this, e, r, s)
          }
          createRenderbuffer(e, r, s) {
            const c = this.gl,
              d = c.createRenderbuffer();
            return this.bindRenderbuffer.set(d), c.renderbufferStorage(c.RENDERBUFFER, e, r, s), this.bindRenderbuffer.set(null), d
          }
          createFramebuffer(e, r, s, c) {
            return new Lc(this, e, r, s, c)
          }
          clear({
            color: e,
            depth: r,
            stencil: s
          }) {
            const c = this.gl;
            let d = 0;
            e && (d |= c.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), r !== void 0 && (d |= c.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(r), this.depthMask.set(!0)), s !== void 0 && (d |= c.STENCIL_BUFFER_BIT, this.clearStencil.set(s), this.stencilMask.set(255)), c.clear(d)
          }
          setCullFace(e) {
            e.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace))
          }
          setDepthMode(e) {
            e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1)
          }
          setStencilMode(e) {
            e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({
              func: e.test.func,
              ref: e.ref,
              mask: e.test.mask
            })) : this.stencilTest.set(!1)
          }
          setColorMode(e) {
            o.bG(e.blendFunction, di.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask)
          }
          createVertexArray() {
            var e;
            return Dn(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) === null || e === void 0 ? void 0 : e.createVertexArrayOES()
          }
          deleteVertexArray(e) {
            var r;
            return Dn(this.gl) ? this.gl.deleteVertexArray(e) : (r = this.gl.getExtension("OES_vertex_array_object")) === null || r === void 0 ? void 0 : r.deleteVertexArrayOES(e)
          }
          unbindVAO() {
            this.bindVertexArray.set(null)
          }
        }
        let fs;

        function Rh(h, e, r, s, c) {
          const d = h.context,
            m = h.transform,
            v = d.gl,
            w = h.useProgram("collisionBox"),
            P = [];
          let M = 0,
            D = 0;
          for (let ne = 0; ne < s.length; ne++) {
            const oe = s[ne],
              me = e.getTile(oe).getBucket(r);
            if (!me) continue;
            const ue = c ? me.textCollisionBox : me.iconCollisionBox,
              be = me.collisionCircleArray;
            be.length > 0 && (P.push({
              circleArray: be,
              circleOffset: D,
              coord: oe
            }), M += be.length / 4, D = M), ue && w.draw(d, v.LINES, Qr.disabled, Nr.disabled, h.colorModeForRenderPass(), Hr.disabled, vo(h.transform), h.style.map.terrain && h.style.map.terrain.getTerrainData(oe), m.getProjectionData({
              overscaledTileID: oe,
              applyGlobeMatrix: !0,
              applyTerrainMatrix: !0
            }), r.id, ue.layoutVertexBuffer, ue.indexBuffer, ue.segments, null, h.transform.zoom, null, null, ue.collisionVertexBuffer)
          }
          if (!c || !P.length) return;
          const L = h.useProgram("collisionCircle"),
            B = new o.b_;
          B.resize(4 * M), B._trim();
          let Z = 0;
          for (const ne of P)
            for (let oe = 0; oe < ne.circleArray.length / 4; oe++) {
              const me = 4 * oe,
                ue = ne.circleArray[me + 0],
                be = ne.circleArray[me + 1],
                Pe = ne.circleArray[me + 2],
                pe = ne.circleArray[me + 3];
              B.emplace(Z++, ue, be, Pe, pe, 0), B.emplace(Z++, ue, be, Pe, pe, 1), B.emplace(Z++, ue, be, Pe, pe, 2), B.emplace(Z++, ue, be, Pe, pe, 3)
            }(!fs || fs.length < 2 * M) && (fs = (function(ne) {
              const oe = 2 * ne,
                me = new o.c0;
              me.resize(oe), me._trim();
              for (let ue = 0; ue < oe; ue++) {
                const be = 6 * ue;
                me.uint16[be + 0] = 4 * ue + 0, me.uint16[be + 1] = 4 * ue + 1, me.uint16[be + 2] = 4 * ue + 2, me.uint16[be + 3] = 4 * ue + 2, me.uint16[be + 4] = 4 * ue + 3, me.uint16[be + 5] = 4 * ue + 0
              }
              return me
            })(M));
          const te = d.createIndexBuffer(fs, !0),
            ee = d.createVertexBuffer(B, o.b$.members, !0);
          for (const ne of P) {
            const oe = yo(h.transform);
            L.draw(d, v.TRIANGLES, Qr.disabled, Nr.disabled, h.colorModeForRenderPass(), Hr.disabled, oe, h.style.map.terrain && h.style.map.terrain.getTerrainData(ne.coord), null, r.id, ee, te, o.aL.simpleSegment(0, 2 * ne.circleOffset, ne.circleArray.length, ne.circleArray.length / 2), null, h.transform.zoom, null, null, null)
          }
          ee.destroy(), te.destroy()
        }
        const Bh = o.af(new Float32Array(16));

        function To(h, e, r, s, c, d) {
          const {
            horizontalAlign: m,
            verticalAlign: v
          } = o.aG(h);
          return new o.P((-(m - .5) * e / c + s[0]) * d, (-(v - .5) * r / c + s[1]) * d)
        }

        function up(h, e, r, s, c, d) {
          const m = e.tileAnchorPoint.add(new o.P(e.translation[0], e.translation[1]));
          if (e.pitchWithMap) {
            let v = s.mult(d);
            r || (v = v.rotate(-c));
            const w = m.add(v);
            return Wr(w.x, w.y, e.pitchedLabelPlaneMatrix, e.getElevation).point
          }
          if (r) {
            const v = gt(e.tileAnchorPoint.x + 1, e.tileAnchorPoint.y, e).point.sub(h),
              w = Math.atan(v.y / v.x) + (v.x < 0 ? Math.PI : 0);
            return h.add(s.rotate(w))
          }
          return h.add(s)
        }

        function hp(h, e, r, s, c, d, m, v, w, P, M, D) {
          const L = h.text.placedSymbolArray,
            B = h.text.dynamicLayoutVertexArray,
            Z = h.icon.dynamicLayoutVertexArray,
            te = {};
          B.clear();
          for (let ee = 0; ee < L.length; ee++) {
            const ne = L.get(ee),
              oe = ne.hidden || !ne.crossTileID || h.allowVerticalPlacement && !ne.placedOrientation ? null : s[ne.crossTileID];
            if (oe) {
              const me = new o.P(ne.anchorX, ne.anchorY),
                ue = {
                  getElevation: D,
                  width: c.width,
                  height: c.height,
                  pitchedLabelPlaneMatrix: d,
                  pitchWithMap: r,
                  transform: c,
                  tileAnchorPoint: me,
                  translation: P,
                  unwrappedTileID: M
                },
                be = r ? xr(me.x, me.y, ue) : gt(me.x, me.y, ue),
                Pe = Cr(c.cameraToCenterDistance, be.signedDistanceFromCamera);
              let pe = o.ao(h.textSizeData, v, ne) * Pe / o.aA;
              r && (pe *= h.tilePixelRatio / m);
              const {
                width: Fe,
                height: Je,
                anchor: Ge,
                textOffset: He,
                textBoxScale: Qe
              } = oe, qt = To(Ge, Fe, Je, He, Qe, pe), Ft = c.getPitchedTextCorrection(me.x + P[0], me.y + P[1], M), Tt = up(be.point, ue, e, qt, -c.bearingInRadians, Ft), rr = h.allowVerticalPlacement && ne.placedOrientation === o.an.vertical ? Math.PI / 2 : 0;
              for (let ei = 0; ei < ne.numGlyphs; ei++) o.au(B, Tt, rr);
              w && ne.associatedIconIndex >= 0 && (te[ne.associatedIconIndex] = {
                shiftedAnchor: Tt,
                angle: rr
              })
            } else Ti(ne.numGlyphs, B)
          }
          if (w) {
            Z.clear();
            const ee = h.icon.placedSymbolArray;
            for (let ne = 0; ne < ee.length; ne++) {
              const oe = ee.get(ne);
              if (oe.hidden) Ti(oe.numGlyphs, Z);
              else {
                const me = te[ne];
                if (me)
                  for (let ue = 0; ue < oe.numGlyphs; ue++) o.au(Z, me.shiftedAnchor, me.angle);
                else Ti(oe.numGlyphs, Z)
              }
            }
            h.icon.dynamicLayoutVertexBuffer.updateData(Z)
          }
          h.text.dynamicLayoutVertexBuffer.updateData(B)
        }

        function Fh(h, e, r) {
          return r.iconsInText && e ? "symbolTextAndIcon" : h ? "symbolSDF" : "symbolIcon"
        }

        function Oh(h, e, r, s, c, d, m, v, w, P, M, D, L) {
          const B = h.context,
            Z = B.gl,
            te = h.transform,
            ee = v === "map",
            ne = w === "map",
            oe = v !== "viewport" && r.layout.get("symbol-placement") !== "point",
            me = ee && !ne && !oe,
            ue = !r.layout.get("symbol-sort-key").isConstant();
          let be = !1;
          const Pe = h.getDepthModeForSublayer(0, Qr.ReadOnly),
            pe = r._unevaluatedLayout.hasValue("text-variable-anchor") || r._unevaluatedLayout.hasValue("text-variable-anchor-offset"),
            Fe = [],
            Je = te.getCircleRadiusCorrection();
          for (const Ge of s) {
            const He = e.getTile(Ge),
              Qe = He.getBucket(r);
            if (!Qe) continue;
            const qt = c ? Qe.text : Qe.icon;
            if (!qt || !qt.segments.get().length || !qt.hasVisibleVertices) continue;
            const Ft = qt.programConfigurations.get(r.id),
              Tt = c || Qe.sdfIcons,
              rr = c ? Qe.textSizeData : Qe.iconSizeData,
              ei = ne || te.pitch !== 0,
              xi = h.useProgram(Fh(Tt, c, Qe), Ft),
              qi = o.am(rr, te.zoom),
              Si = h.style.map.terrain && h.style.map.terrain.getTerrainData(Ge);
            let Vi, Mi, Pi, Ai, Tn = [0, 0],
              pi = null;
            if (c) Mi = He.glyphAtlasTexture, Pi = Z.LINEAR, Vi = He.glyphAtlasTexture.size, Qe.iconsInText && (Tn = He.imageAtlasTexture.size, pi = He.imageAtlasTexture, Ai = ei || h.options.rotating || h.options.zooming || rr.kind === "composite" || rr.kind === "camera" ? Z.LINEAR : Z.NEAREST);
            else {
              const Wi = r.layout.get("icon-size").constantOr(0) !== 1 || Qe.iconsNeedLinear;
              Mi = He.imageAtlasTexture, Pi = Tt || h.options.rotating || h.options.zooming || Wi || ei ? Z.LINEAR : Z.NEAREST, Vi = He.imageAtlasTexture.size
            }
            const fn = o.aB(He, 1, h.transform.zoom),
              Cn = or(ee, h.transform, fn),
              Ja = o.L();
            o.ap(Ja, Cn);
            const Qa = ri(ne, ee, h.transform, fn),
              es = o.aC(te, He, d, m),
              Ma = te.getProjectionData({
                overscaledTileID: Ge,
                applyGlobeMatrix: !L,
                applyTerrainMatrix: !0
              }),
              Fo = pe && Qe.hasTextData(),
              Oo = r.layout.get("icon-text-fit") !== "none" && Fo && Qe.hasIconData();
            if (oe) {
              const Wi = h.style.map.terrain ? (On, sn) => h.style.map.terrain.getElevation(Ge, On, sn) : null,
                Di = r.layout.get("text-rotation-alignment") === "map";
              Hi(Qe, h, c, Cn, Ja, ne, P, Di, Ge.toUnwrapped(), te.width, te.height, es, Wi)
            }
            const Ys = c && pe || Oo,
              Hn = oe || Ys ? Bh : ne ? Cn : h.transform.clipSpaceToPixelsMatrix,
              ga = Tt && r.paint.get(c ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
            let ts;
            ts = Tt ? Qe.iconsInText ? ip(rr.kind, qi, me, ne, oe, Ys, h, Hn, Qa, es, Vi, Tn, Je) : Rs(rr.kind, qi, me, ne, oe, Ys, h, Hn, Qa, es, c, Vi, 0, Je) : Tc(rr.kind, qi, me, ne, oe, Ys, h, Hn, Qa, es, c, Vi, Je);
            const gs = {
              program: xi,
              buffers: qt,
              uniformValues: ts,
              projectionData: Ma,
              atlasTexture: Mi,
              atlasTextureIcon: pi,
              atlasInterpolation: Pi,
              atlasInterpolationIcon: Ai,
              isSDF: Tt,
              hasHalo: ga
            };
            if (ue && Qe.canOverlap) {
              be = !0;
              const Wi = qt.segments.get();
              for (const Di of Wi) Fe.push({
                segments: new o.aL([Di]),
                sortKey: Di.sortKey,
                state: gs,
                terrainData: Si
              })
            } else Fe.push({
              segments: qt.segments,
              sortKey: 0,
              state: gs,
              terrainData: Si
            })
          }
          be && Fe.sort(((Ge, He) => Ge.sortKey - He.sortKey));
          for (const Ge of Fe) {
            const He = Ge.state;
            if (B.activeTexture.set(Z.TEXTURE0), He.atlasTexture.bind(He.atlasInterpolation, Z.CLAMP_TO_EDGE), He.atlasTextureIcon && (B.activeTexture.set(Z.TEXTURE1), He.atlasTextureIcon && He.atlasTextureIcon.bind(He.atlasInterpolationIcon, Z.CLAMP_TO_EDGE)), He.isSDF) {
              const Qe = He.uniformValues;
              He.hasHalo && (Qe.u_is_halo = 1, ml(He.buffers, Ge.segments, r, h, He.program, Pe, M, D, Qe, He.projectionData, Ge.terrainData)), Qe.u_is_halo = 0
            }
            ml(He.buffers, Ge.segments, r, h, He.program, Pe, M, D, He.uniformValues, He.projectionData, Ge.terrainData)
          }
        }

        function ml(h, e, r, s, c, d, m, v, w, P, M) {
          const D = s.context;
          c.draw(D, D.gl.TRIANGLES, d, m, v, Hr.backCCW, w, M, P, r.id, h.layoutVertexBuffer, h.indexBuffer, e, r.paint, s.transform.zoom, h.programConfigurations.get(r.id), h.dynamicLayoutVertexBuffer, h.opacityVertexBuffer)
        }

        function _l(h, e, r, s, c) {
          const d = h.context,
            m = d.gl,
            v = Nr.disabled,
            w = new di([m.ONE, m.ONE], o.be.transparent, [!0, !0, !0, !0]),
            P = e.getBucket(r);
          if (!P) return;
          const M = s.key;
          let D = r.heatmapFbos.get(M);
          D || (D = Co(d, e.tileSize, e.tileSize), r.heatmapFbos.set(M, D)), d.bindFramebuffer.set(D.framebuffer), d.viewport.set([0, 0, e.tileSize, e.tileSize]), d.clear({
            color: o.be.transparent
          });
          const L = P.programConfigurations.get(r.id),
            B = h.useProgram("heatmap", L, !c),
            Z = h.transform.getProjectionData({
              overscaledTileID: e.tileID,
              applyGlobeMatrix: !0,
              applyTerrainMatrix: !0
            }),
            te = h.style.map.terrain.getTerrainData(s);
          B.draw(d, m.TRIANGLES, Qr.disabled, v, w, Hr.disabled, xo(e, h.transform.zoom, r.paint.get("heatmap-intensity"), 1), te, Z, r.id, P.layoutVertexBuffer, P.indexBuffer, P.segments, r.paint, h.transform.zoom, L)
        }

        function gl(h, e, r, s, c) {
          const d = h.context,
            m = d.gl,
            v = h.transform;
          d.setColorMode(h.colorModeForRenderPass());
          const w = vl(d, e),
            P = r.key,
            M = e.heatmapFbos.get(P);
          if (!M) return;
          d.activeTexture.set(m.TEXTURE0), m.bindTexture(m.TEXTURE_2D, M.colorAttachment.get()), d.activeTexture.set(m.TEXTURE1), w.bind(m.LINEAR, m.CLAMP_TO_EDGE);
          const D = v.getProjectionData({
            overscaledTileID: r,
            applyTerrainMatrix: c,
            applyGlobeMatrix: !s
          });
          h.useProgram("heatmapTexture").draw(d, m.TRIANGLES, Qr.disabled, Nr.disabled, h.colorModeForRenderPass(), Hr.disabled, xh(h, e, 0, 1), null, D, e.id, h.rasterBoundsBuffer, h.quadTriangleIndexBuffer, h.rasterBoundsSegments, e.paint, v.zoom), M.destroy(), e.heatmapFbos.delete(P)
        }

        function Co(h, e, r) {
          var s, c;
          const d = h.gl,
            m = d.createTexture();
          d.bindTexture(d.TEXTURE_2D, m), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_S, d.CLAMP_TO_EDGE), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_T, d.CLAMP_TO_EDGE), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MIN_FILTER, d.LINEAR), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MAG_FILTER, d.LINEAR);
          const v = (s = h.HALF_FLOAT) !== null && s !== void 0 ? s : d.UNSIGNED_BYTE,
            w = (c = h.RGBA16F) !== null && c !== void 0 ? c : d.RGBA;
          d.texImage2D(d.TEXTURE_2D, 0, w, e, r, 0, d.RGBA, v, null);
          const P = h.createFramebuffer(e, r, !1, !1);
          return P.colorAttachment.set(m), P
        }

        function vl(h, e) {
          return e.colorRampTexture || (e.colorRampTexture = new o.T(h, e.colorRamp, h.gl.RGBA)), e.colorRampTexture
        }

        function Dc(h, e, r, s, c) {
          if (!r || !s || !s.imageAtlas) return;
          const d = s.imageAtlas.patternPositions;
          let m = d[r.to.toString()],
            v = d[r.from.toString()];
          if (!m && v && (m = v), !v && m && (v = m), !m || !v) {
            const w = c.getPaintProperty(e);
            m = d[w], v = d[w]
          }
          m && v && h.setConstantPatternPositions(m, v)
        }

        function So(h, e, r, s, c, d, m, v) {
          const w = h.context.gl,
            P = "fill-pattern",
            M = r.paint.get(P),
            D = M && M.constantOr(1),
            L = r.getCrossfadeParameters();
          let B, Z, te, ee, ne;
          const oe = h.transform,
            me = r.paint.get("fill-translate"),
            ue = r.paint.get("fill-translate-anchor");
          m ? (Z = D && !r.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", B = w.LINES) : (Z = D ? "fillPattern" : "fill", B = w.TRIANGLES);
          const be = M.constantOr(null);
          for (const Pe of s) {
            const pe = e.getTile(Pe);
            if (D && !pe.patternsLoaded()) continue;
            const Fe = pe.getBucket(r);
            if (!Fe) continue;
            const Je = Fe.programConfigurations.get(r.id),
              Ge = h.useProgram(Z, Je),
              He = h.style.map.terrain && h.style.map.terrain.getTerrainData(Pe);
            D && (h.context.activeTexture.set(w.TEXTURE0), pe.imageAtlasTexture.bind(w.LINEAR, w.CLAMP_TO_EDGE), Je.updatePaintBuffers(L)), Dc(Je, P, be, pe, r);
            const Qe = oe.getProjectionData({
                overscaledTileID: Pe,
                applyGlobeMatrix: !v,
                applyTerrainMatrix: !0
              }),
              qt = o.aC(oe, pe, me, ue);
            if (m) {
              ee = Fe.indexBuffer2, ne = Fe.segments2;
              const Tt = [w.drawingBufferWidth, w.drawingBufferHeight];
              te = Z === "fillOutlinePattern" && D ? ep(h, L, pe, Tt, qt) : Sa(Tt, qt)
            } else ee = Fe.indexBuffer, ne = Fe.segments, te = D ? sl(h, L, pe, qt) : {
              u_fill_translate: qt
            };
            const Ft = h.stencilModeForClipping(Pe);
            Ge.draw(h.context, B, c, Ft, d, Hr.backCCW, te, He, Qe, r.id, Fe.layoutVertexBuffer, ee, ne, r.paint, h.transform.zoom, Je)
          }
        }

        function js(h, e, r, s, c, d, m, v) {
          const w = h.context,
            P = w.gl,
            M = "fill-extrusion-pattern",
            D = r.paint.get(M),
            L = D.constantOr(1),
            B = r.getCrossfadeParameters(),
            Z = r.paint.get("fill-extrusion-opacity"),
            te = D.constantOr(null),
            ee = h.transform;
          for (const ne of s) {
            const oe = e.getTile(ne),
              me = oe.getBucket(r);
            if (!me) continue;
            const ue = h.style.map.terrain && h.style.map.terrain.getTerrainData(ne),
              be = me.programConfigurations.get(r.id),
              Pe = h.useProgram(L ? "fillExtrusionPattern" : "fillExtrusion", be);
            L && (h.context.activeTexture.set(P.TEXTURE0), oe.imageAtlasTexture.bind(P.LINEAR, P.CLAMP_TO_EDGE), be.updatePaintBuffers(B));
            const pe = ee.getProjectionData({
              overscaledTileID: ne,
              applyGlobeMatrix: !v,
              applyTerrainMatrix: !0
            });
            Dc(be, M, te, oe, r);
            const Fe = o.aC(ee, oe, r.paint.get("fill-extrusion-translate"), r.paint.get("fill-extrusion-translate-anchor")),
              Je = r.paint.get("fill-extrusion-vertical-gradient"),
              Ge = L ? vc(h, Je, Z, Fe, ne, B, oe) : go(h, Je, Z, Fe);
            Pe.draw(w, w.gl.TRIANGLES, c, d, m, Hr.backCCW, Ge, ue, pe, r.id, me.layoutVertexBuffer, me.indexBuffer, me.segments, r.paint, h.transform.zoom, be, h.style.map.terrain && me.centroidVertexBuffer)
          }
        }

        function qs(h, e, r, s, c, d, m, v, w) {
          var P;
          const M = h.style.projection,
            D = h.context,
            L = h.transform,
            B = D.gl,
            Z = [`#define NUM_ILLUMINATION_SOURCES ${r.paint.get("hillshade-highlight-color").values.length}`],
            te = h.useProgram("hillshade", null, !1, Z),
            ee = !h.options.moving;
          for (const ne of s) {
            const oe = e.getTile(ne),
              me = oe.fbo;
            if (!me) continue;
            const ue = M.getMeshFromTileID(D, ne.canonical, v, !0, "raster"),
              be = (P = h.style.map.terrain) === null || P === void 0 ? void 0 : P.getTerrainData(ne);
            D.activeTexture.set(B.TEXTURE0), B.bindTexture(B.TEXTURE_2D, me.colorAttachment.get());
            const Pe = L.getProjectionData({
              overscaledTileID: ne,
              aligned: ee,
              applyGlobeMatrix: !w,
              applyTerrainMatrix: !0
            });
            te.draw(D, B.TRIANGLES, d, c[ne.overscaledZ], m, Hr.backCCW, Ds(h, oe, r), be, Pe, r.id, ue.vertexBuffer, ue.indexBuffer, ue.segments)
          }
        }

        function Po(h, e, r, s, c, d, m, v, w) {
          var P;
          const M = h.style.projection,
            D = h.context,
            L = h.transform,
            B = D.gl,
            Z = h.useProgram("colorRelief"),
            te = !h.options.moving;
          let ee = !0,
            ne = 0;
          for (const oe of s) {
            const me = e.getTile(oe),
              ue = me.dem;
            if (ee) {
              const Ge = B.getParameter(B.MAX_TEXTURE_SIZE),
                {
                  elevationTexture: He,
                  colorTexture: Qe
                } = r.getColorRampTextures(D, Ge, ue.getUnpackVector());
              D.activeTexture.set(B.TEXTURE1), He.bind(B.NEAREST, B.CLAMP_TO_EDGE), D.activeTexture.set(B.TEXTURE4), Qe.bind(B.LINEAR, B.CLAMP_TO_EDGE), ee = !1, ne = He.size[0]
            }
            if (!ue || !ue.data) continue;
            const be = ue.stride,
              Pe = ue.getPixels();
            if (D.activeTexture.set(B.TEXTURE0), D.pixelStoreUnpackPremultiplyAlpha.set(!1), me.demTexture = me.demTexture || h.getTileTexture(be), me.demTexture) {
              const Ge = me.demTexture;
              Ge.update(Pe, {
                premultiply: !1
              }), Ge.bind(B.LINEAR, B.CLAMP_TO_EDGE)
            } else me.demTexture = new o.T(D, Pe, B.RGBA, {
              premultiply: !1
            }), me.demTexture.bind(B.LINEAR, B.CLAMP_TO_EDGE);
            const pe = M.getMeshFromTileID(D, oe.canonical, v, !0, "raster"),
              Fe = (P = h.style.map.terrain) === null || P === void 0 ? void 0 : P.getTerrainData(oe),
              Je = L.getProjectionData({
                overscaledTileID: oe,
                aligned: te,
                applyGlobeMatrix: !w,
                applyTerrainMatrix: !0
              });
            Z.draw(D, B.TRIANGLES, d, c[oe.overscaledZ], m, Hr.backCCW, rp(r, me.dem, ne), Fe, Je, r.id, pe.vertexBuffer, pe.indexBuffer, pe.segments)
          }
        }
        const Rc = [new o.P(0, 0), new o.P(o.$, 0), new o.P(o.$, o.$), new o.P(0, o.$)];

        function Ha(h, e, r, s, c, d, m, v, w = !1, P = !1) {
          const M = s[s.length - 1].overscaledZ,
            D = h.context,
            L = D.gl,
            B = h.useProgram("raster"),
            Z = h.transform,
            te = h.style.projection,
            ee = h.colorModeForRenderPass(),
            ne = !h.options.moving;
          for (const oe of s) {
            const me = h.getDepthModeForSublayer(oe.overscaledZ - M, r.paint.get("raster-opacity") === 1 ? Qr.ReadWrite : Qr.ReadOnly, L.LESS),
              ue = e.getTile(oe);
            ue.registerFadeDuration(r.paint.get("raster-fade-duration"));
            const be = e.findLoadedParent(oe, 0),
              Pe = e.findLoadedSibling(oe),
              pe = dp(ue, be || Pe || null, e, r, h.transform, h.style.map.terrain);
            let Fe, Je;
            const Ge = r.paint.get("raster-resampling") === "nearest" ? L.NEAREST : L.LINEAR;
            D.activeTexture.set(L.TEXTURE0), ue.texture.bind(Ge, L.CLAMP_TO_EDGE, L.LINEAR_MIPMAP_NEAREST), D.activeTexture.set(L.TEXTURE1), be ? (be.texture.bind(Ge, L.CLAMP_TO_EDGE, L.LINEAR_MIPMAP_NEAREST), Fe = Math.pow(2, be.tileID.overscaledZ - ue.tileID.overscaledZ), Je = [ue.tileID.canonical.x * Fe % 1, ue.tileID.canonical.y * Fe % 1]) : ue.texture.bind(Ge, L.CLAMP_TO_EDGE, L.LINEAR_MIPMAP_NEAREST), ue.texture.useMipmap && D.extTextureFilterAnisotropic && h.transform.pitch > 20 && L.texParameterf(L.TEXTURE_2D, D.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, D.extTextureFilterAnisotropicMax);
            const He = h.style.map.terrain && h.style.map.terrain.getTerrainData(oe),
              Qe = Z.getProjectionData({
                overscaledTileID: oe,
                aligned: ne,
                applyGlobeMatrix: !P,
                applyTerrainMatrix: !0
              }),
              qt = us(Je || [0, 0], Fe || 1, pe, r, v),
              Ft = te.getMeshFromTileID(D, oe.canonical, d, m, "raster");
            B.draw(D, L.TRIANGLES, me, c ? c[oe.overscaledZ] : Nr.disabled, ee, w ? Hr.frontCCW : Hr.backCCW, qt, He, Qe, r.id, Ft.vertexBuffer, Ft.indexBuffer, Ft.segments)
          }
        }

        function dp(h, e, r, s, c, d) {
          const m = s.paint.get("raster-fade-duration");
          if (!d && m > 0) {
            const v = fe.now(),
              w = (v - h.timeAdded) / m,
              P = e ? (v - e.timeAdded) / m : -1,
              M = r.getSource(),
              D = Ne(c, {
                tileSize: M.tileSize,
                roundZoom: M.roundZoom
              }),
              L = !e || Math.abs(e.tileID.overscaledZ - D) > Math.abs(h.tileID.overscaledZ - D),
              B = L && h.refreshedUponExpiration ? 1 : o.ag(L ? w : 1 - P, 0, 1);
            return h.refreshedUponExpiration && w >= 1 && (h.refreshedUponExpiration = !1), e ? {
              opacity: 1,
              mix: 1 - B
            } : {
              opacity: B,
              mix: 0
            }
          }
          return {
            opacity: 1,
            mix: 0
          }
        }
        const Nh = new o.be(1, 0, 0, 1),
          yl = new o.be(0, 1, 0, 1),
          Bc = new o.be(0, 0, 1, 1),
          jh = new o.be(1, 0, 1, 1),
          qh = new o.be(0, 1, 1, 1);

        function Io(h, e, r, s) {
          bl(h, 0, e + r / 2, h.transform.width, r, s)
        }

        function xl(h, e, r, s) {
          bl(h, e - r / 2, 0, r, h.transform.height, s)
        }

        function bl(h, e, r, s, c, d) {
          const m = h.context,
            v = m.gl;
          v.enable(v.SCISSOR_TEST), v.scissor(e * h.pixelRatio, r * h.pixelRatio, s * h.pixelRatio, c * h.pixelRatio), m.clear({
            color: d
          }), v.disable(v.SCISSOR_TEST)
        }

        function Vh(h, e, r) {
          const s = h.context,
            c = s.gl,
            d = h.useProgram("debug"),
            m = Qr.disabled,
            v = Nr.disabled,
            w = h.colorModeForRenderPass(),
            P = "$debug",
            M = h.style.map.terrain && h.style.map.terrain.getTerrainData(r);
          s.activeTexture.set(c.TEXTURE0);
          const D = e.getTileByID(r.key).latestRawTileData,
            L = Math.floor((D && D.byteLength || 0) / 1024),
            B = e.getTile(r).tileSize,
            Z = 512 / Math.min(B, 512) * (r.overscaledZ / h.transform.zoom) * .5;
          let te = r.canonical.toString();
          r.overscaledZ !== r.canonical.z && (te += ` => ${r.overscaledZ}`), (function(ne, oe) {
            ne.initDebugOverlayCanvas();
            const me = ne.debugOverlayCanvas,
              ue = ne.context.gl,
              be = ne.debugOverlayCanvas.getContext("2d");
            be.clearRect(0, 0, me.width, me.height), be.shadowColor = "white", be.shadowBlur = 2, be.lineWidth = 1.5, be.strokeStyle = "white", be.textBaseline = "top", be.font = "bold 36px Open Sans, sans-serif", be.fillText(oe, 5, 5), be.strokeText(oe, 5, 5), ne.debugOverlayTexture.update(me), ne.debugOverlayTexture.bind(ue.LINEAR, ue.CLAMP_TO_EDGE)
          })(h, `${te} ${L}kB`);
          const ee = h.transform.getProjectionData({
            overscaledTileID: r,
            applyGlobeMatrix: !0,
            applyTerrainMatrix: !0
          });
          d.draw(s, c.TRIANGLES, m, v, di.alphaBlended, Hr.disabled, yh(o.be.transparent, Z), null, ee, P, h.debugBuffer, h.quadTriangleIndexBuffer, h.debugSegments), d.draw(s, c.LINE_STRIP, m, v, w, Hr.disabled, yh(o.be.red), M, ee, P, h.debugBuffer, h.tileBorderIndexBuffer, h.debugSegments)
        }

        function $i(h, e, r, s) {
          const {
            isRenderingGlobe: c
          } = s, d = h.context, m = d.gl, v = h.transform, w = h.colorModeForRenderPass(), P = h.getDepthModeFor3D(), M = h.useProgram("terrain");
          d.bindFramebuffer.set(null), d.viewport.set([0, 0, h.width, h.height]);
          for (const D of r) {
            const L = e.getTerrainMesh(D.tileID),
              B = h.renderToTexture.getTexture(D),
              Z = e.getTerrainData(D.tileID);
            d.activeTexture.set(m.TEXTURE0), m.bindTexture(m.TEXTURE_2D, B.texture);
            const te = e.getMeshFrameDelta(v.zoom),
              ee = v.calculateFogMatrix(D.tileID.toUnwrapped()),
              ne = Jd(te, ee, h.style.sky, v.pitch, c),
              oe = v.getProjectionData({
                overscaledTileID: D.tileID,
                applyTerrainMatrix: !1,
                applyGlobeMatrix: !0
              });
            M.draw(d, m.TRIANGLES, P, Nr.disabled, w, Hr.backCCW, ne, Z, oe, "terrain", L.vertexBuffer, L.indexBuffer, L.segments)
          }
        }

        function Wa(h, e) {
          if (!e.mesh) {
            const r = new o.aK;
            r.emplaceBack(-1, -1), r.emplaceBack(1, -1), r.emplaceBack(1, 1), r.emplaceBack(-1, 1);
            const s = new o.aM;
            s.emplaceBack(0, 1, 2), s.emplaceBack(0, 2, 3), e.mesh = new Qn(h.createVertexBuffer(r, oa.members), h.createIndexBuffer(s), o.aL.simpleSegment(0, 0, r.length, s.length))
          }
          return e.mesh
        }
        class ca {
          constructor(e, r) {
            this.context = new oi(e), this.transform = r, this._tileTextures = {}, this.terrainFacilitator = {
              dirty: !0,
              matrix: o.af(new Float64Array(16)),
              renderTime: 0
            }, this.setup(), this.numSublayers = We.maxUnderzooming + We.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new an
          }
          resize(e, r, s) {
            if (this.width = Math.floor(e * s), this.height = Math.floor(r * s), this.pixelRatio = s, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
              for (const c of this.style._order) this.style._layers[c].resize()
          }
          setup() {
            const e = this.context,
              r = new o.aK;
            r.emplaceBack(0, 0), r.emplaceBack(o.$, 0), r.emplaceBack(0, o.$), r.emplaceBack(o.$, o.$), this.tileExtentBuffer = e.createVertexBuffer(r, oa.members), this.tileExtentSegments = o.aL.simpleSegment(0, 0, 4, 2);
            const s = new o.aK;
            s.emplaceBack(0, 0), s.emplaceBack(o.$, 0), s.emplaceBack(0, o.$), s.emplaceBack(o.$, o.$), this.debugBuffer = e.createVertexBuffer(s, oa.members), this.debugSegments = o.aL.simpleSegment(0, 0, 4, 5);
            const c = new o.c5;
            c.emplaceBack(0, 0, 0, 0), c.emplaceBack(o.$, 0, o.$, 0), c.emplaceBack(0, o.$, 0, o.$), c.emplaceBack(o.$, o.$, o.$, o.$), this.rasterBoundsBuffer = e.createVertexBuffer(c, Kd.members), this.rasterBoundsSegments = o.aL.simpleSegment(0, 0, 4, 2);
            const d = new o.aK;
            d.emplaceBack(0, 0), d.emplaceBack(o.$, 0), d.emplaceBack(0, o.$), d.emplaceBack(o.$, o.$), this.rasterBoundsBufferPosOnly = e.createVertexBuffer(d, oa.members), this.rasterBoundsSegmentsPosOnly = o.aL.simpleSegment(0, 0, 4, 5);
            const m = new o.aK;
            m.emplaceBack(0, 0), m.emplaceBack(1, 0), m.emplaceBack(0, 1), m.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(m, oa.members), this.viewportSegments = o.aL.simpleSegment(0, 0, 4, 2);
            const v = new o.c6;
            v.emplaceBack(0), v.emplaceBack(1), v.emplaceBack(3), v.emplaceBack(2), v.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(v);
            const w = new o.aM;
            w.emplaceBack(1, 0, 2), w.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(w);
            const P = this.context.gl;
            this.stencilClearMode = new Nr({
              func: P.ALWAYS,
              mask: 0
            }, 0, 255, P.ZERO, P.ZERO, P.ZERO), this.tileExtentMesh = new Qn(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments)
          }
          clearStencil() {
            const e = this.context,
              r = e.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const s = o.L();
            o.bX(s, 0, this.width, this.height, 0, 0, 1), o.N(s, s, [r.drawingBufferWidth, r.drawingBufferHeight, 0]);
            const c = {
              mainMatrix: s,
              tileMercatorCoords: [0, 0, 1, 1],
              clippingPlane: [0, 0, 0, 0],
              projectionTransition: 0,
              fallbackMatrix: s
            };
            this.useProgram("clippingMask", null, !0).draw(e, r.TRIANGLES, Qr.disabled, this.stencilClearMode, di.disabled, Hr.disabled, null, null, c, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments)
          }
          _renderTileClippingMasks(e, r, s) {
            if (this.currentStencilSource === e.source || !e.isTileClipped() || !r || !r.length) return;
            this.currentStencilSource = e.source, this.nextStencilID + r.length > 256 && this.clearStencil();
            const c = this.context;
            c.setColorMode(di.disabled), c.setDepthMode(Qr.disabled);
            const d = {};
            for (const m of r) d[m.key] = this.nextStencilID++;
            this._renderTileMasks(d, r, s, !0), this._renderTileMasks(d, r, s, !1), this._tileClippingMaskIDs = d
          }
          _renderTileMasks(e, r, s, c) {
            const d = this.context,
              m = d.gl,
              v = this.style.projection,
              w = this.transform,
              P = this.useProgram("clippingMask");
            for (const M of r) {
              const D = e[M.key],
                L = this.style.map.terrain && this.style.map.terrain.getTerrainData(M),
                B = v.getMeshFromTileID(this.context, M.canonical, c, !0, "stencil"),
                Z = w.getProjectionData({
                  overscaledTileID: M,
                  applyGlobeMatrix: !s,
                  applyTerrainMatrix: !0
                });
              P.draw(d, m.TRIANGLES, Qr.disabled, new Nr({
                func: m.ALWAYS,
                mask: 0
              }, D, 255, m.KEEP, m.KEEP, m.REPLACE), di.disabled, s ? Hr.disabled : Hr.backCCW, null, L, Z, "$clipping", B.vertexBuffer, B.indexBuffer, B.segments)
            }
          }
          _renderTilesDepthBuffer() {
            const e = this.context,
              r = e.gl,
              s = this.style.projection,
              c = this.transform,
              d = this.useProgram("depth"),
              m = this.getDepthModeFor3D(),
              v = ze(c, {
                tileSize: c.tileSize
              });
            for (const w of v) {
              const P = this.style.map.terrain && this.style.map.terrain.getTerrainData(w),
                M = s.getMeshFromTileID(this.context, w.canonical, !0, !0, "raster"),
                D = c.getProjectionData({
                  overscaledTileID: w,
                  applyGlobeMatrix: !0,
                  applyTerrainMatrix: !0
                });
              d.draw(e, r.TRIANGLES, m, Nr.disabled, di.disabled, Hr.backCCW, null, P, D, "$clipping", M.vertexBuffer, M.indexBuffer, M.segments)
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const e = this.nextStencilID++,
              r = this.context.gl;
            return new Nr({
              func: r.NOTEQUAL,
              mask: 255
            }, e, 255, r.KEEP, r.KEEP, r.REPLACE)
          }
          stencilModeForClipping(e) {
            const r = this.context.gl;
            return new Nr({
              func: r.EQUAL,
              mask: 255
            }, this._tileClippingMaskIDs[e.key], 0, r.KEEP, r.KEEP, r.REPLACE)
          }
          getStencilConfigForOverlapAndUpdateStencilID(e) {
            const r = this.context.gl,
              s = e.sort(((m, v) => v.overscaledZ - m.overscaledZ)),
              c = s[s.length - 1].overscaledZ,
              d = s[0].overscaledZ - c + 1;
            if (d > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + d > 256 && this.clearStencil();
              const m = {};
              for (let v = 0; v < d; v++) m[v + c] = new Nr({
                func: r.GEQUAL,
                mask: 255
              }, v + this.nextStencilID, 255, r.KEEP, r.KEEP, r.REPLACE);
              return this.nextStencilID += d, [m, s]
            }
            return [{
              [c]: Nr.disabled
            }, s]
          }
          stencilConfigForOverlapTwoPass(e) {
            const r = this.context.gl,
              s = e.sort(((m, v) => v.overscaledZ - m.overscaledZ)),
              c = s[s.length - 1].overscaledZ,
              d = s[0].overscaledZ - c + 1;
            if (this.clearStencil(), d > 1) {
              const m = {},
                v = {};
              for (let w = 0; w < d; w++) m[w + c] = new Nr({
                func: r.GREATER,
                mask: 255
              }, d + 1 + w, 255, r.KEEP, r.KEEP, r.REPLACE), v[w + c] = new Nr({
                func: r.GREATER,
                mask: 255
              }, 1 + w, 255, r.KEEP, r.KEEP, r.REPLACE);
              return this.nextStencilID = 2 * d + 1, [m, v, s]
            }
            return this.nextStencilID = 3, [{
              [c]: new Nr({
                func: r.GREATER,
                mask: 255
              }, 2, 255, r.KEEP, r.KEEP, r.REPLACE)
            }, {
              [c]: new Nr({
                func: r.GREATER,
                mask: 255
              }, 1, 255, r.KEEP, r.KEEP, r.REPLACE)
            }, s]
          }
          colorModeForRenderPass() {
            const e = this.context.gl;
            return this._showOverdrawInspector ? new di([e.CONSTANT_COLOR, e.ONE], new o.be(.125, .125, .125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? di.unblended : di.alphaBlended
          }
          getDepthModeForSublayer(e, r, s) {
            if (!this.opaquePassEnabledForLayer()) return Qr.disabled;
            const c = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
            return new Qr(s || this.context.gl.LEQUAL, r, [c, c])
          }
          getDepthModeFor3D() {
            return new Qr(this.context.gl.LEQUAL, Qr.ReadWrite, this.depthRangeFor3D)
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff
          }
          render(e, r) {
            var s, c;
            this.style = e, this.options = r, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(fe.now()), this.imageManager.beginFrame();
            const d = this.style._order,
              m = this.style.sourceCaches,
              v = {},
              w = {},
              P = {},
              M = {
                isRenderingToTexture: !1,
                isRenderingGlobe: ((s = e.projection) === null || s === void 0 ? void 0 : s.transitionState) > 0
              };
            for (const L in m) {
              const B = m[L];
              B.used && B.prepare(this.context), v[L] = B.getVisibleCoordinates(!1), w[L] = v[L].slice().reverse(), P[L] = B.getVisibleCoordinates(!0).reverse()
            }
            this.opaquePassCutoff = 1 / 0;
            for (let L = 0; L < d.length; L++)
              if (this.style._layers[d[L]].is3D()) {
                this.opaquePassCutoff = L;
                break
              } this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const L of d) {
              const B = this.style._layers[L];
              if (!B.hasOffscreenPass() || B.isHidden(this.transform.zoom)) continue;
              const Z = w[B.source];
              (B.type === "custom" || Z.length) && this.renderLayer(this, m[B.source], B, Z, M)
            }
            if ((c = this.style.projection) === null || c === void 0 || c.updateGPUdependent({
                context: this.context,
                useProgram: L => this.useProgram(L)
              }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({
                color: r.showOverdrawInspector ? o.be.black : o.be.transparent,
                depth: 1
              }), this.clearStencil(), this.style.sky && (function(L, B) {
                const Z = L.context,
                  te = Z.gl,
                  ee = ((Pe, pe, Fe) => {
                    const Je = Math.cos(pe.rollInRadians),
                      Ge = Math.sin(pe.rollInRadians),
                      He = V(pe),
                      Qe = pe.getProjectionData({
                        overscaledTileID: null,
                        applyGlobeMatrix: !0,
                        applyTerrainMatrix: !0
                      }).projectionTransition;
                    return {
                      u_sky_color: Pe.properties.get("sky-color"),
                      u_horizon_color: Pe.properties.get("horizon-color"),
                      u_horizon: [(pe.width / 2 - He * Ge) * Fe, (pe.height / 2 + He * Je) * Fe],
                      u_horizon_normal: [-Ge, Je],
                      u_sky_horizon_blend: Pe.properties.get("sky-horizon-blend") * pe.height / 2 * Fe,
                      u_sky_blend: Qe
                    }
                  })(B, L.style.map.transform, L.pixelRatio),
                  ne = new Qr(te.LEQUAL, Qr.ReadWrite, [0, 1]),
                  oe = Nr.disabled,
                  me = L.colorModeForRenderPass(),
                  ue = L.useProgram("sky"),
                  be = Wa(Z, B);
                ue.draw(Z, te.TRIANGLES, ne, oe, me, Hr.disabled, ee, null, void 0, "sky", be.vertexBuffer, be.indexBuffer, be.segments)
              })(this, this.style.sky), this._showOverdrawInspector = r.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture)
              for (this.renderPass = "opaque", this.currentLayer = d.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                const L = this.style._layers[d[this.currentLayer]],
                  B = m[L.source],
                  Z = v[L.source];
                this._renderTileClippingMasks(L, Z, !1), this.renderLayer(this, B, L, Z, M)
              }
            this.renderPass = "translucent";
            let D = !1;
            for (this.currentLayer = 0; this.currentLayer < d.length; this.currentLayer++) {
              const L = this.style._layers[d[this.currentLayer]],
                B = m[L.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer(L, M)) continue;
              this.opaquePassEnabledForLayer() || D || (D = !0, M.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
              const Z = (L.type === "symbol" ? P : w)[L.source];
              this._renderTileClippingMasks(L, v[L.source], !!this.renderToTexture), this.renderLayer(this, B, L, Z, M)
            }
            if (M.isRenderingGlobe && (function(L, B, Z) {
                const te = L.context,
                  ee = te.gl,
                  ne = L.useProgram("atmosphere"),
                  oe = new Qr(ee.LEQUAL, Qr.ReadOnly, [0, 1]),
                  me = L.transform,
                  ue = (function(Qe, qt) {
                    const Ft = Qe.properties.get("position"),
                      Tt = [-Ft.x, -Ft.y, -Ft.z],
                      rr = o.af(new Float64Array(16));
                    return Qe.properties.get("anchor") === "map" && (o.b5(rr, rr, qt.rollInRadians), o.b6(rr, rr, -qt.pitchInRadians), o.b5(rr, rr, qt.bearingInRadians), o.b6(rr, rr, qt.center.lat * Math.PI / 180), o.by(rr, rr, -qt.center.lng * Math.PI / 180)), o.c4(Tt, Tt, rr), Tt
                  })(Z, L.transform),
                  be = me.getProjectionData({
                    overscaledTileID: null,
                    applyGlobeMatrix: !0,
                    applyTerrainMatrix: !0
                  }),
                  Pe = B.properties.get("atmosphere-blend") * be.projectionTransition;
                if (Pe === 0) return;
                const pe = Ms(me.worldSize, me.center.lat),
                  Fe = me.inverseProjectionMatrix,
                  Je = new Float64Array(4);
                Je[3] = 1, o.av(Je, Je, me.modelViewProjectionMatrix), Je[0] /= Je[3], Je[1] /= Je[3], Je[2] /= Je[3], Je[3] = 1, o.av(Je, Je, Fe), Je[0] /= Je[3], Je[1] /= Je[3], Je[2] /= Je[3], Je[3] = 1;
                const Ge = ((Qe, qt, Ft, Tt, rr) => ({
                    u_sun_pos: Qe,
                    u_atmosphere_blend: qt,
                    u_globe_position: Ft,
                    u_globe_radius: Tt,
                    u_inv_proj_matrix: rr
                  }))(ue, Pe, [Je[0], Je[1], Je[2]], pe, Fe),
                  He = Wa(te, B);
                ne.draw(te, ee.TRIANGLES, oe, Nr.disabled, di.alphaBlended, Hr.disabled, Ge, null, null, "atmosphere", He.vertexBuffer, He.indexBuffer, He.segments)
              })(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
              const L = (function(B, Z) {
                let te = null;
                const ee = Object.values(B._layers).flatMap((ue => ue.source && !ue.isHidden(Z) ? [B.sourceCaches[ue.source]] : [])),
                  ne = ee.filter((ue => ue.getSource().type === "vector")),
                  oe = ee.filter((ue => ue.getSource().type !== "vector")),
                  me = ue => {
                    (!te || te.getSource().maxzoom < ue.getSource().maxzoom) && (te = ue)
                  };
                return ne.forEach((ue => me(ue))), te || oe.forEach((ue => me(ue))), te
              })(this.style, this.transform.zoom);
              L && (function(B, Z, te) {
                for (let ee = 0; ee < te.length; ee++) Vh(B, Z, te[ee])
              })(this, L, L.getVisibleCoordinates())
            }
            this.options.showPadding && (function(L) {
              const B = L.transform.padding;
              Io(L, L.transform.height - (B.top || 0), 3, Nh), Io(L, B.bottom || 0, 3, yl), xl(L, B.left || 0, 3, Bc), xl(L, L.transform.width - (B.right || 0), 3, jh);
              const Z = L.transform.centerPoint;
              (function(te, ee, ne, oe) {
                bl(te, ee - 1, ne - 10, 2, 20, oe), bl(te, ee - 10, ne - 1, 20, 2, oe)
              })(L, Z.x, L.transform.height - Z.y, qh)
            })(this), this.context.setDefault()
          }
          maybeDrawDepthAndCoords(e) {
            if (!this.style || !this.style.map || !this.style.map.terrain) return;
            const r = this.terrainFacilitator.matrix,
              s = this.transform.modelViewProjectionMatrix;
            let c = this.terrainFacilitator.dirty;
            c || (c = e ? !o.c7(r, s) : !o.c8(r, s)), c || (c = this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime)), c && (o.c9(r, s), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, (function(d, m) {
              const v = d.context,
                w = v.gl,
                P = d.transform,
                M = di.unblended,
                D = new Qr(w.LEQUAL, Qr.ReadWrite, [0, 1]),
                L = m.sourceCache.getRenderableTiles(),
                B = d.useProgram("terrainDepth");
              v.bindFramebuffer.set(m.getFramebuffer("depth").framebuffer), v.viewport.set([0, 0, d.width / devicePixelRatio, d.height / devicePixelRatio]), v.clear({
                color: o.be.transparent,
                depth: 1
              });
              for (const Z of L) {
                const te = m.getTerrainMesh(Z.tileID),
                  ee = m.getTerrainData(Z.tileID),
                  ne = P.getProjectionData({
                    overscaledTileID: Z.tileID,
                    applyTerrainMatrix: !1,
                    applyGlobeMatrix: !0
                  }),
                  oe = {
                    u_ele_delta: m.getMeshFrameDelta(P.zoom)
                  };
                B.draw(v, w.TRIANGLES, D, Nr.disabled, M, Hr.backCCW, oe, ee, ne, "terrain", te.vertexBuffer, te.indexBuffer, te.segments)
              }
              v.bindFramebuffer.set(null), v.viewport.set([0, 0, d.width, d.height])
            })(this, this.style.map.terrain), (function(d, m) {
              const v = d.context,
                w = v.gl,
                P = d.transform,
                M = di.unblended,
                D = new Qr(w.LEQUAL, Qr.ReadWrite, [0, 1]),
                L = m.getCoordsTexture(),
                B = m.sourceCache.getRenderableTiles(),
                Z = d.useProgram("terrainCoords");
              v.bindFramebuffer.set(m.getFramebuffer("coords").framebuffer), v.viewport.set([0, 0, d.width / devicePixelRatio, d.height / devicePixelRatio]), v.clear({
                color: o.be.transparent,
                depth: 1
              }), m.coordsIndex = [];
              for (const te of B) {
                const ee = m.getTerrainMesh(te.tileID),
                  ne = m.getTerrainData(te.tileID);
                v.activeTexture.set(w.TEXTURE0), w.bindTexture(w.TEXTURE_2D, L.texture);
                const oe = {
                    u_terrain_coords_id: (255 - m.coordsIndex.length) / 255,
                    u_texture: 0,
                    u_ele_delta: m.getMeshFrameDelta(P.zoom)
                  },
                  me = P.getProjectionData({
                    overscaledTileID: te.tileID,
                    applyTerrainMatrix: !1,
                    applyGlobeMatrix: !0
                  });
                Z.draw(v, w.TRIANGLES, D, Nr.disabled, M, Hr.backCCW, oe, ne, me, "terrain", ee.vertexBuffer, ee.indexBuffer, ee.segments), m.coordsIndex.push(te.tileID.key)
              }
              v.bindFramebuffer.set(null), v.viewport.set([0, 0, d.width, d.height])
            })(this, this.style.map.terrain))
          }
          renderLayer(e, r, s, c, d) {
            s.isHidden(this.transform.zoom) || (s.type === "background" || s.type === "custom" || (c || []).length) && (this.id = s.id, o.ca(s) ? (function(m, v, w, P, M, D) {
              if (m.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: L
              } = D, B = Nr.disabled, Z = m.colorModeForRenderPass();
              (w._unevaluatedLayout.hasValue("text-variable-anchor") || w._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && (function(te, ee, ne, oe, me, ue, be, Pe, pe) {
                const Fe = ee.transform,
                  Je = ee.style.map.terrain,
                  Ge = me === "map",
                  He = ue === "map";
                for (const Qe of te) {
                  const qt = oe.getTile(Qe),
                    Ft = qt.getBucket(ne);
                  if (!Ft || !Ft.text || !Ft.text.segments.get().length) continue;
                  const Tt = o.am(Ft.textSizeData, Fe.zoom),
                    rr = o.aB(qt, 1, ee.transform.zoom),
                    ei = or(Ge, ee.transform, rr),
                    xi = ne.layout.get("icon-text-fit") !== "none" && Ft.hasIconData();
                  if (Tt) {
                    const qi = Math.pow(2, Fe.zoom - qt.tileID.overscaledZ),
                      Si = Je ? (Vi, Mi) => Je.getElevation(Qe, Vi, Mi) : null;
                    hp(Ft, Ge, He, pe, Fe, ei, qi, Tt, xi, o.aC(Fe, qt, be, Pe), Qe.toUnwrapped(), Si)
                  }
                }
              })(P, m, w, v, w.layout.get("text-rotation-alignment"), w.layout.get("text-pitch-alignment"), w.paint.get("text-translate"), w.paint.get("text-translate-anchor"), M), w.paint.get("icon-opacity").constantOr(1) !== 0 && Oh(m, v, w, P, !1, w.paint.get("icon-translate"), w.paint.get("icon-translate-anchor"), w.layout.get("icon-rotation-alignment"), w.layout.get("icon-pitch-alignment"), w.layout.get("icon-keep-upright"), B, Z, L), w.paint.get("text-opacity").constantOr(1) !== 0 && Oh(m, v, w, P, !0, w.paint.get("text-translate"), w.paint.get("text-translate-anchor"), w.layout.get("text-rotation-alignment"), w.layout.get("text-pitch-alignment"), w.layout.get("text-keep-upright"), B, Z, L), v.map.showCollisionBoxes && (Rh(m, v, w, P, !0), Rh(m, v, w, P, !1))
            })(e, r, s, c, this.style.placement.variableOffsets, d) : o.cb(s) ? (function(m, v, w, P, M) {
              if (m.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: D
              } = M, L = w.paint.get("circle-opacity"), B = w.paint.get("circle-stroke-width"), Z = w.paint.get("circle-stroke-opacity"), te = !w.layout.get("circle-sort-key").isConstant();
              if (L.constantOr(1) === 0 && (B.constantOr(1) === 0 || Z.constantOr(1) === 0)) return;
              const ee = m.context,
                ne = ee.gl,
                oe = m.transform,
                me = m.getDepthModeForSublayer(0, Qr.ReadOnly),
                ue = Nr.disabled,
                be = m.colorModeForRenderPass(),
                Pe = [],
                pe = oe.getCircleRadiusCorrection();
              for (let Fe = 0; Fe < P.length; Fe++) {
                const Je = P[Fe],
                  Ge = v.getTile(Je),
                  He = Ge.getBucket(w);
                if (!He) continue;
                const Qe = w.paint.get("circle-translate"),
                  qt = w.paint.get("circle-translate-anchor"),
                  Ft = o.aC(oe, Ge, Qe, qt),
                  Tt = He.programConfigurations.get(w.id),
                  rr = m.useProgram("circle", Tt),
                  ei = He.layoutVertexBuffer,
                  xi = He.indexBuffer,
                  qi = m.style.map.terrain && m.style.map.terrain.getTerrainData(Je),
                  Si = {
                    programConfiguration: Tt,
                    program: rr,
                    layoutVertexBuffer: ei,
                    indexBuffer: xi,
                    uniformValues: yc(m, Ge, w, Ft, pe),
                    terrainData: qi,
                    projectionData: oe.getProjectionData({
                      overscaledTileID: Je,
                      applyGlobeMatrix: !D,
                      applyTerrainMatrix: !0
                    })
                  };
                if (te) {
                  const Vi = He.segments.get();
                  for (const Mi of Vi) Pe.push({
                    segments: new o.aL([Mi]),
                    sortKey: Mi.sortKey,
                    state: Si
                  })
                } else Pe.push({
                  segments: He.segments,
                  sortKey: 0,
                  state: Si
                })
              }
              te && Pe.sort(((Fe, Je) => Fe.sortKey - Je.sortKey));
              for (const Fe of Pe) {
                const {
                  programConfiguration: Je,
                  program: Ge,
                  layoutVertexBuffer: He,
                  indexBuffer: Qe,
                  uniformValues: qt,
                  terrainData: Ft,
                  projectionData: Tt
                } = Fe.state;
                Ge.draw(ee, ne.TRIANGLES, me, ue, be, Hr.backCCW, qt, Ft, Tt, w.id, He, Qe, Fe.segments, w.paint, m.transform.zoom, Je)
              }
            })(e, r, s, c, d) : o.cc(s) ? (function(m, v, w, P, M) {
              if (w.paint.get("heatmap-opacity") === 0) return;
              const D = m.context,
                {
                  isRenderingToTexture: L,
                  isRenderingGlobe: B
                } = M;
              if (m.style.map.terrain) {
                for (const Z of P) {
                  const te = v.getTile(Z);
                  v.hasRenderableParent(Z) || (m.renderPass === "offscreen" ? _l(m, te, w, Z, B) : m.renderPass === "translucent" && gl(m, w, Z, L, B))
                }
                D.viewport.set([0, 0, m.width, m.height])
              } else m.renderPass === "offscreen" ? (function(Z, te, ee, ne) {
                const oe = Z.context,
                  me = oe.gl,
                  ue = Z.transform,
                  be = Nr.disabled,
                  Pe = new di([me.ONE, me.ONE], o.be.transparent, [!0, !0, !0, !0]);
                (function(pe, Fe, Je) {
                  const Ge = pe.gl;
                  pe.activeTexture.set(Ge.TEXTURE1), pe.viewport.set([0, 0, Fe.width / 4, Fe.height / 4]);
                  let He = Je.heatmapFbos.get(o.c1);
                  He ? (Ge.bindTexture(Ge.TEXTURE_2D, He.colorAttachment.get()), pe.bindFramebuffer.set(He.framebuffer)) : (He = Co(pe, Fe.width / 4, Fe.height / 4), Je.heatmapFbos.set(o.c1, He))
                })(oe, Z, ee), oe.clear({
                  color: o.be.transparent
                });
                for (let pe = 0; pe < ne.length; pe++) {
                  const Fe = ne[pe];
                  if (te.hasRenderableParent(Fe)) continue;
                  const Je = te.getTile(Fe),
                    Ge = Je.getBucket(ee);
                  if (!Ge) continue;
                  const He = Ge.programConfigurations.get(ee.id),
                    Qe = Z.useProgram("heatmap", He),
                    qt = ue.getProjectionData({
                      overscaledTileID: Fe,
                      applyGlobeMatrix: !0,
                      applyTerrainMatrix: !1
                    }),
                    Ft = ue.getCircleRadiusCorrection();
                  Qe.draw(oe, me.TRIANGLES, Qr.disabled, be, Pe, Hr.backCCW, xo(Je, ue.zoom, ee.paint.get("heatmap-intensity"), Ft), null, qt, ee.id, Ge.layoutVertexBuffer, Ge.indexBuffer, Ge.segments, ee.paint, ue.zoom, He)
                }
                oe.viewport.set([0, 0, Z.width, Z.height])
              })(m, v, w, P) : m.renderPass === "translucent" && (function(Z, te) {
                const ee = Z.context,
                  ne = ee.gl;
                ee.setColorMode(Z.colorModeForRenderPass());
                const oe = te.heatmapFbos.get(o.c1);
                oe && (ee.activeTexture.set(ne.TEXTURE0), ne.bindTexture(ne.TEXTURE_2D, oe.colorAttachment.get()), ee.activeTexture.set(ne.TEXTURE1), vl(ee, te).bind(ne.LINEAR, ne.CLAMP_TO_EDGE), Z.useProgram("heatmapTexture").draw(ee, ne.TRIANGLES, Qr.disabled, Nr.disabled, Z.colorModeForRenderPass(), Hr.disabled, xh(Z, te, 0, 1), null, null, te.id, Z.viewportBuffer, Z.quadTriangleIndexBuffer, Z.viewportSegments, te.paint, Z.transform.zoom))
              })(m, w)
            })(e, r, s, c, d) : o.cd(s) ? (function(m, v, w, P, M) {
              if (m.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: D
              } = M, L = w.paint.get("line-opacity"), B = w.paint.get("line-width");
              if (L.constantOr(1) === 0 || B.constantOr(1) === 0) return;
              const Z = m.getDepthModeForSublayer(0, Qr.ReadOnly),
                te = m.colorModeForRenderPass(),
                ee = w.paint.get("line-dasharray"),
                ne = w.paint.get("line-pattern"),
                oe = ne.constantOr(1),
                me = w.paint.get("line-gradient"),
                ue = w.getCrossfadeParameters(),
                be = oe ? "linePattern" : ee ? "lineSDF" : me ? "lineGradient" : "line",
                Pe = m.context,
                pe = Pe.gl,
                Fe = m.transform;
              let Je = !0;
              for (const Ge of P) {
                const He = v.getTile(Ge);
                if (oe && !He.patternsLoaded()) continue;
                const Qe = He.getBucket(w);
                if (!Qe) continue;
                const qt = Qe.programConfigurations.get(w.id),
                  Ft = m.context.program.get(),
                  Tt = m.useProgram(be, qt),
                  rr = Je || Tt.program !== Ft,
                  ei = m.style.map.terrain && m.style.map.terrain.getTerrainData(Ge),
                  xi = ne.constantOr(null);
                if (xi && He.imageAtlas) {
                  const Pi = He.imageAtlas,
                    Ai = Pi.patternPositions[xi.to.toString()],
                    Tn = Pi.patternPositions[xi.from.toString()];
                  Ai && Tn && qt.setConstantPatternPositions(Ai, Tn)
                }
                const qi = Fe.getProjectionData({
                    overscaledTileID: Ge,
                    applyGlobeMatrix: !D,
                    applyTerrainMatrix: !0
                  }),
                  Si = Fe.getPixelScale(),
                  Vi = oe ? wh(m, He, w, Si, ue) : ee ? Th(m, He, w, Si, ee, ue) : me ? xc(m, He, w, Si, Qe.lineClipsArray.length) : ol(m, He, w, Si);
                if (oe) Pe.activeTexture.set(pe.TEXTURE0), He.imageAtlasTexture.bind(pe.LINEAR, pe.CLAMP_TO_EDGE), qt.updatePaintBuffers(ue);
                else if (ee && (rr || m.lineAtlas.dirty)) Pe.activeTexture.set(pe.TEXTURE0), m.lineAtlas.bind(Pe);
                else if (me) {
                  const Pi = Qe.gradients[w.id];
                  let Ai = Pi.texture;
                  if (w.gradientVersion !== Pi.version) {
                    let Tn = 256;
                    if (w.stepInterpolant) {
                      const pi = v.getSource().maxzoom,
                        fn = Ge.canonical.z === pi ? Math.ceil(1 << m.transform.maxZoom - Ge.canonical.z) : 1;
                      Tn = o.ag(o.c2(Qe.maxLineLength / o.$ * 1024 * fn), 256, Pe.maxTextureSize)
                    }
                    Pi.gradient = o.c3({
                      expression: w.gradientExpression(),
                      evaluationKey: "lineProgress",
                      resolution: Tn,
                      image: Pi.gradient || void 0,
                      clips: Qe.lineClipsArray
                    }), Pi.texture ? Pi.texture.update(Pi.gradient) : Pi.texture = new o.T(Pe, Pi.gradient, pe.RGBA), Pi.version = w.gradientVersion, Ai = Pi.texture
                  }
                  Pe.activeTexture.set(pe.TEXTURE0), Ai.bind(w.stepInterpolant ? pe.NEAREST : pe.LINEAR, pe.CLAMP_TO_EDGE)
                }
                const Mi = m.stencilModeForClipping(Ge);
                Tt.draw(Pe, pe.TRIANGLES, Z, Mi, te, Hr.disabled, Vi, ei, qi, w.id, Qe.layoutVertexBuffer, Qe.indexBuffer, Qe.segments, w.paint, m.transform.zoom, qt, Qe.layoutVertexBuffer2), Je = !1
              }
            })(e, r, s, c, d) : o.ce(s) ? (function(m, v, w, P, M) {
              const D = w.paint.get("fill-color"),
                L = w.paint.get("fill-opacity");
              if (L.constantOr(1) === 0) return;
              const {
                isRenderingToTexture: B
              } = M, Z = m.colorModeForRenderPass(), te = w.paint.get("fill-pattern"), ee = m.opaquePassEnabledForLayer() && !te.constantOr(1) && D.constantOr(o.be.transparent).a === 1 && L.constantOr(0) === 1 ? "opaque" : "translucent";
              if (m.renderPass === ee) {
                const ne = m.getDepthModeForSublayer(1, m.renderPass === "opaque" ? Qr.ReadWrite : Qr.ReadOnly);
                So(m, v, w, P, ne, Z, !1, B)
              }
              if (m.renderPass === "translucent" && w.paint.get("fill-antialias")) {
                const ne = m.getDepthModeForSublayer(w.getPaintProperty("fill-outline-color") ? 2 : 0, Qr.ReadOnly);
                So(m, v, w, P, ne, Z, !0, B)
              }
            })(e, r, s, c, d) : o.cf(s) ? (function(m, v, w, P, M) {
              const D = w.paint.get("fill-extrusion-opacity");
              if (D === 0) return;
              const {
                isRenderingToTexture: L
              } = M;
              if (m.renderPass === "translucent") {
                const B = new Qr(m.context.gl.LEQUAL, Qr.ReadWrite, m.depthRangeFor3D);
                if (D !== 1 || w.paint.get("fill-extrusion-pattern").constantOr(1)) js(m, v, w, P, B, Nr.disabled, di.disabled, L), js(m, v, w, P, B, m.stencilModeFor3D(), m.colorModeForRenderPass(), L);
                else {
                  const Z = m.colorModeForRenderPass();
                  js(m, v, w, P, B, Nr.disabled, Z, L)
                }
              }
            })(e, r, s, c, d) : o.cg(s) ? (function(m, v, w, P, M) {
              if (m.renderPass !== "offscreen" && m.renderPass !== "translucent") return;
              const {
                isRenderingToTexture: D
              } = M, L = m.context, B = m.style.projection.useSubdivision, Z = m.getDepthModeForSublayer(0, Qr.ReadOnly), te = m.colorModeForRenderPass();
              if (m.renderPass === "offscreen")(function(ee, ne, oe, me, ue, be, Pe) {
                const pe = ee.context,
                  Fe = pe.gl;
                for (const Je of oe) {
                  const Ge = ne.getTile(Je),
                    He = Ge.dem;
                  if (!He || !He.data || !Ge.needsHillshadePrepare) continue;
                  const Qe = He.dim,
                    qt = He.stride,
                    Ft = He.getPixels();
                  if (pe.activeTexture.set(Fe.TEXTURE1), pe.pixelStoreUnpackPremultiplyAlpha.set(!1), Ge.demTexture = Ge.demTexture || ee.getTileTexture(qt), Ge.demTexture) {
                    const rr = Ge.demTexture;
                    rr.update(Ft, {
                      premultiply: !1
                    }), rr.bind(Fe.NEAREST, Fe.CLAMP_TO_EDGE)
                  } else Ge.demTexture = new o.T(pe, Ft, Fe.RGBA, {
                    premultiply: !1
                  }), Ge.demTexture.bind(Fe.NEAREST, Fe.CLAMP_TO_EDGE);
                  pe.activeTexture.set(Fe.TEXTURE0);
                  let Tt = Ge.fbo;
                  if (!Tt) {
                    const rr = new o.T(pe, {
                      width: Qe,
                      height: Qe,
                      data: null
                    }, Fe.RGBA);
                    rr.bind(Fe.LINEAR, Fe.CLAMP_TO_EDGE), Tt = Ge.fbo = pe.createFramebuffer(Qe, Qe, !0, !1), Tt.colorAttachment.set(rr.texture)
                  }
                  pe.bindFramebuffer.set(Tt.framebuffer), pe.viewport.set([0, 0, Qe, Qe]), ee.useProgram("hillshadePrepare").draw(pe, Fe.TRIANGLES, ue, be, Pe, Hr.disabled, tp(Ge.tileID, He), null, null, me.id, ee.rasterBoundsBuffer, ee.quadTriangleIndexBuffer, ee.rasterBoundsSegments), Ge.needsHillshadePrepare = !1
                }
              })(m, v, P, w, Z, Nr.disabled, te), L.viewport.set([0, 0, m.width, m.height]);
              else if (m.renderPass === "translucent")
                if (B) {
                  const [ee, ne, oe] = m.stencilConfigForOverlapTwoPass(P);
                  qs(m, v, w, oe, ee, Z, te, !1, D), qs(m, v, w, oe, ne, Z, te, !0, D)
                } else {
                  const [ee, ne] = m.getStencilConfigForOverlapAndUpdateStencilID(P);
                  qs(m, v, w, ne, ee, Z, te, !1, D)
                }
            })(e, r, s, c, d) : o.ch(s) ? (function(m, v, w, P, M) {
              if (m.renderPass !== "translucent" || !P.length) return;
              const {
                isRenderingToTexture: D
              } = M, L = m.style.projection.useSubdivision, B = m.getDepthModeForSublayer(0, Qr.ReadOnly), Z = m.colorModeForRenderPass();
              if (L) {
                const [te, ee, ne] = m.stencilConfigForOverlapTwoPass(P);
                Po(m, v, w, ne, te, B, Z, !1, D), Po(m, v, w, ne, ee, B, Z, !0, D)
              } else {
                const [te, ee] = m.getStencilConfigForOverlapAndUpdateStencilID(P);
                Po(m, v, w, ee, te, B, Z, !1, D)
              }
            })(e, r, s, c, d) : o.ci(s) ? (function(m, v, w, P, M) {
              if (m.renderPass !== "translucent" || w.paint.get("raster-opacity") === 0 || !P.length) return;
              const {
                isRenderingToTexture: D
              } = M, L = v.getSource(), B = m.style.projection.useSubdivision;
              if (L instanceof Dt) Ha(m, v, w, P, null, !1, !1, L.tileCoords, L.flippedWindingOrder, D);
              else if (B) {
                const [Z, te, ee] = m.stencilConfigForOverlapTwoPass(P);
                Ha(m, v, w, ee, Z, !1, !0, Rc, !1, D), Ha(m, v, w, ee, te, !0, !0, Rc, !1, D)
              } else {
                const [Z, te] = m.getStencilConfigForOverlapAndUpdateStencilID(P);
                Ha(m, v, w, te, Z, !1, !0, Rc, !1, D)
              }
            })(e, r, s, c, d) : o.cj(s) ? (function(m, v, w, P, M) {
              const D = w.paint.get("background-color"),
                L = w.paint.get("background-opacity");
              if (L === 0) return;
              const {
                isRenderingToTexture: B
              } = M, Z = m.context, te = Z.gl, ee = m.style.projection, ne = m.transform, oe = ne.tileSize, me = w.paint.get("background-pattern");
              if (m.isPatternMissing(me)) return;
              const ue = !me && D.a === 1 && L === 1 && m.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (m.renderPass !== ue) return;
              const be = Nr.disabled,
                Pe = m.getDepthModeForSublayer(0, ue === "opaque" ? Qr.ReadWrite : Qr.ReadOnly),
                pe = m.colorModeForRenderPass(),
                Fe = m.useProgram(me ? "backgroundPattern" : "background"),
                Je = P || ze(ne, {
                  tileSize: oe,
                  terrain: m.style.map.terrain
                });
              me && (Z.activeTexture.set(te.TEXTURE0), m.imageManager.bind(m.context));
              const Ge = w.getCrossfadeParameters();
              for (const He of Je) {
                const Qe = ne.getProjectionData({
                    overscaledTileID: He,
                    applyGlobeMatrix: !B,
                    applyTerrainMatrix: !0
                  }),
                  qt = me ? np(L, m, me, {
                    tileID: He,
                    tileSize: oe
                  }, Ge) : ll(L, D),
                  Ft = m.style.map.terrain && m.style.map.terrain.getTerrainData(He),
                  Tt = ee.getMeshFromTileID(Z, He.canonical, !1, !0, "raster");
                Fe.draw(Z, te.TRIANGLES, Pe, be, pe, Hr.backCCW, qt, Ft, Qe, w.id, Tt.vertexBuffer, Tt.indexBuffer, Tt.segments)
              }
            })(e, 0, s, c, d) : o.ck(s) && (function(m, v, w, P) {
              const {
                isRenderingGlobe: M
              } = P, D = m.context, L = w.implementation, B = m.style.projection, Z = m.transform, te = Z.getProjectionDataForCustomLayer(M), ee = {
                farZ: Z.farZ,
                nearZ: Z.nearZ,
                fov: Z.fov * Math.PI / 180,
                modelViewProjectionMatrix: Z.modelViewProjectionMatrix,
                projectionMatrix: Z.projectionMatrix,
                shaderData: {
                  variantName: B.shaderVariantName,
                  vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${B.shaderPreludeCode.vertexSource}`,
                  define: B.shaderDefine
                },
                defaultProjectionData: te
              }, ne = L.renderingMode ? L.renderingMode : "2d";
              if (m.renderPass === "offscreen") {
                const oe = L.prerender;
                oe && (m.setCustomLayerDefaults(), D.setColorMode(m.colorModeForRenderPass()), oe.call(L, D.gl, ee), D.setDirty(), m.setBaseState())
              } else if (m.renderPass === "translucent") {
                m.setCustomLayerDefaults(), D.setColorMode(m.colorModeForRenderPass()), D.setStencilMode(Nr.disabled);
                const oe = ne === "3d" ? m.getDepthModeFor3D() : m.getDepthModeForSublayer(0, Qr.ReadOnly);
                D.setDepthMode(oe), L.render(D.gl, ee), D.setDirty(), m.setBaseState(), D.bindFramebuffer.set(null)
              }
            })(e, 0, s, d))
          }
          saveTileTexture(e) {
            const r = this._tileTextures[e.size[0]];
            r ? r.push(e) : this._tileTextures[e.size[0]] = [e]
          }
          getTileTexture(e) {
            const r = this._tileTextures[e];
            return r && r.length > 0 ? r.pop() : null
          }
          isPatternMissing(e) {
            if (!e) return !1;
            if (!e.from || !e.to) return !0;
            const r = this.imageManager.getPattern(e.from.toString()),
              s = this.imageManager.getPattern(e.to.toString());
            return !r || !s
          }
          useProgram(e, r, s = !1, c = []) {
            this.cache = this.cache || {};
            const d = !!this.style.map.terrain,
              m = this.style.projection,
              v = s ? Ki.projectionMercator : m.shaderPreludeCode,
              w = s ? pa : m.shaderDefine,
              P = e + (r ? r.cacheKey : "") + `/${s?os:m.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (d ? "/terrain" : "") + (c ? `/${c.join("/")}` : "");
            return this.cache[P] || (this.cache[P] = new nl(this.context, Ki[e], r, Ph[e], this._showOverdrawInspector, d, v, w, c)), this.cache[P]
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault()
          }
          setBaseState() {
            const e = this.context.gl;
            this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD)
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new o.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA))
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy()
          }
          overLimit() {
            const {
              drawingBufferWidth: e,
              drawingBufferHeight: r
            } = this.context.gl;
            return this.width !== e || this.height !== r
          }
        }

        function wl(h, e) {
          let r, s = !1,
            c = null,
            d = null;
          const m = () => {
            c = null, s && (h.apply(d, r), c = setTimeout(m, e), s = !1)
          };
          return (...v) => (s = !0, d = this, r = v, c || m(), c)
        }
        class Mo {
          constructor(e) {
            this._getCurrentHash = () => {
              const r = window.location.hash.replace("#", "");
              if (this._hashName) {
                let s;
                return r.split("&").map((c => c.split("="))).forEach((c => {
                  c[0] === this._hashName && (s = c)
                })), (s && s[1] || "").split("/")
              }
              return r.split("/")
            }, this._onHashChange = () => {
              const r = this._getCurrentHash();
              if (!this._isValidHash(r)) return !1;
              const s = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(r[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({
                center: [+r[2], +r[1]],
                zoom: +r[0],
                bearing: s,
                pitch: +(r[4] || 0)
              }), !0
            }, this._updateHashUnthrottled = () => {
              const r = window.location.href.replace(/(#.*)?$/, this.getHashString());
              window.history.replaceState(window.history.state, null, r)
            }, this._removeHash = () => {
              const r = this._getCurrentHash();
              if (r.length === 0) return;
              const s = r.join("/");
              let c = s;
              c.split("&").length > 0 && (c = c.split("&")[0]), this._hashName && (c = `${this._hashName}=${s}`);
              let d = window.location.hash.replace(c, "");
              d.startsWith("#&") ? d = d.slice(0, 1) + d.slice(2) : d === "#" && (d = "");
              let m = window.location.href.replace(/(#.+)?$/, d);
              m = m.replace("&&", "&"), window.history.replaceState(window.history.state, null, m)
            }, this._updateHash = wl(this._updateHashUnthrottled, 300), this._hashName = e && encodeURIComponent(e)
          }
          addTo(e) {
            return this._map = e, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this
          }
          getHashString(e) {
            const r = this._map.getCenter(),
              s = Math.round(100 * this._map.getZoom()) / 100,
              c = Math.ceil((s * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10),
              d = Math.pow(10, c),
              m = Math.round(r.lng * d) / d,
              v = Math.round(r.lat * d) / d,
              w = this._map.getBearing(),
              P = this._map.getPitch();
            let M = "";
            if (M += e ? `/${m}/${v}/${s}` : `${s}/${v}/${m}`, (w || P) && (M += "/" + Math.round(10 * w) / 10), P && (M += `/${Math.round(P)}`), this._hashName) {
              const D = this._hashName;
              let L = !1;
              const B = window.location.hash.slice(1).split("&").map((Z => {
                const te = Z.split("=")[0];
                return te === D ? (L = !0, `${te}=${M}`) : Z
              })).filter((Z => Z));
              return L || B.push(`${D}=${M}`), `#${B.join("&")}`
            }
            return `#${M}`
          }
          _isValidHash(e) {
            if (e.length < 3 || e.some(isNaN)) return !1;
            try {
              new o.S(+e[2], +e[1])
            } catch {
              return !1
            }
            const r = +e[0],
              s = +(e[3] || 0),
              c = +(e[4] || 0);
            return r >= this._map.getMinZoom() && r <= this._map.getMaxZoom() && s >= -180 && s <= 180 && c >= this._map.getMinPitch() && c <= this._map.getMaxPitch()
          }
        }
        const Vs = {
            linearity: .3,
            easing: o.cl(0, 0, .3, 1)
          },
          Zs = o.e({
            deceleration: 2500,
            maxSpeed: 1400
          }, Vs),
          Fc = o.e({
            deceleration: 20,
            maxSpeed: 1400
          }, Vs),
          Ao = o.e({
            deceleration: 1e3,
            maxSpeed: 360
          }, Vs),
          Oc = o.e({
            deceleration: 1e3,
            maxSpeed: 90
          }, Vs),
          Zh = o.e({
            deceleration: 1e3,
            maxSpeed: 360
          }, Vs);
        class $h {
          constructor(e) {
            this._map = e, this.clear()
          }
          clear() {
            this._inertiaBuffer = []
          }
          record(e) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({
              time: fe.now(),
              settings: e
            })
          }
          _drainInertiaBuffer() {
            const e = this._inertiaBuffer,
              r = fe.now();
            for (; e.length > 0 && r - e[0].time > 160;) e.shift()
          }
          _onMoveEnd(e) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const r = {
              zoom: 0,
              bearing: 0,
              pitch: 0,
              roll: 0,
              pan: new o.P(0, 0),
              pinchAround: void 0,
              around: void 0
            };
            for (const {
                settings: d
              }
              of this._inertiaBuffer) r.zoom += d.zoomDelta || 0, r.bearing += d.bearingDelta || 0, r.pitch += d.pitchDelta || 0, r.roll += d.rollDelta || 0, d.panDelta && r.pan._add(d.panDelta), d.around && (r.around = d.around), d.pinchAround && (r.pinchAround = d.pinchAround);
            const s = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time,
              c = {};
            if (r.pan.mag()) {
              const d = Us(r.pan.mag(), s, o.e({}, Zs, e || {})),
                m = r.pan.mult(d.amount / r.pan.mag()),
                v = this._map.cameraHelper.handlePanInertia(m, this._map.transform);
              c.center = v.easingCenter, c.offset = v.easingOffset, $s(c, d)
            }
            if (r.zoom) {
              const d = Us(r.zoom, s, Fc);
              c.zoom = this._map.transform.zoom + d.amount, $s(c, d)
            }
            if (r.bearing) {
              const d = Us(r.bearing, s, Ao);
              c.bearing = this._map.transform.bearing + o.ag(d.amount, -179, 179), $s(c, d)
            }
            if (r.pitch) {
              const d = Us(r.pitch, s, Oc);
              c.pitch = this._map.transform.pitch + d.amount, $s(c, d)
            }
            if (r.roll) {
              const d = Us(r.roll, s, Zh);
              c.roll = this._map.transform.roll + o.ag(d.amount, -179, 179), $s(c, d)
            }
            if (c.zoom || c.bearing) {
              const d = r.pinchAround === void 0 ? r.around : r.pinchAround;
              c.around = d ? this._map.unproject(d) : this._map.getCenter()
            }
            return this.clear(), o.e(c, {
              noMoveStart: !0
            })
          }
        }

        function $s(h, e) {
          (!h.duration || h.duration < e.duration) && (h.duration = e.duration, h.easing = e.easing)
        }

        function Us(h, e, r) {
          const {
            maxSpeed: s,
            linearity: c,
            deceleration: d
          } = r, m = o.ag(h * c / (e / 1e3), -s, s), v = Math.abs(m) / (d * c);
          return {
            easing: r.easing,
            duration: 1e3 * v,
            amount: m * (v / 2)
          }
        }
        class Gn extends o.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, r, s, c = {}) {
            s = s instanceof MouseEvent ? s : new MouseEvent(e, s);
            const d = W.mousePos(r.getCanvas(), s),
              m = r.unproject(d);
            super(e, o.e({
              point: d,
              lngLat: m,
              originalEvent: s
            }, c)), this._defaultPrevented = !1, this.target = r
          }
        }
        class ma extends o.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, r, s) {
            const c = e === "touchend" ? s.changedTouches : s.touches,
              d = W.touchPos(r.getCanvasContainer(), c),
              m = d.map((w => r.unproject(w))),
              v = d.reduce(((w, P, M, D) => w.add(P.div(D.length))), new o.P(0, 0));
            super(e, {
              points: d,
              point: v,
              lngLats: m,
              lngLat: r.unproject(v),
              originalEvent: s
            }), this._defaultPrevented = !1
          }
        }
        class Nc extends o.l {
          preventDefault() {
            this._defaultPrevented = !0
          }
          get defaultPrevented() {
            return this._defaultPrevented
          }
          constructor(e, r, s) {
            super(e, {
              originalEvent: s
            }), this._defaultPrevented = !1
          }
        }
        class Uh {
          constructor(e, r) {
            this._map = e, this._clickTolerance = r.clickTolerance
          }
          reset() {
            delete this._mousedownPos
          }
          wheel(e) {
            return this._firePreventable(new Nc(e.type, this._map, e))
          }
          mousedown(e, r) {
            return this._mousedownPos = r, this._firePreventable(new Gn(e.type, this._map, e))
          }
          mouseup(e) {
            this._map.fire(new Gn(e.type, this._map, e))
          }
          click(e, r) {
            this._mousedownPos && this._mousedownPos.dist(r) >= this._clickTolerance || this._map.fire(new Gn(e.type, this._map, e))
          }
          dblclick(e) {
            return this._firePreventable(new Gn(e.type, this._map, e))
          }
          mouseover(e) {
            this._map.fire(new Gn(e.type, this._map, e))
          }
          mouseout(e) {
            this._map.fire(new Gn(e.type, this._map, e))
          }
          touchstart(e) {
            return this._firePreventable(new ma(e.type, this._map, e))
          }
          touchmove(e) {
            this._map.fire(new ma(e.type, this._map, e))
          }
          touchend(e) {
            this._map.fire(new ma(e.type, this._map, e))
          }
          touchcancel(e) {
            this._map.fire(new ma(e.type, this._map, e))
          }
          _firePreventable(e) {
            if (this._map.fire(e), e.defaultPrevented) return {}
          }
          isEnabled() {
            return !0
          }
          isActive() {
            return !1
          }
          enable() {}
          disable() {}
        }
        class Gh {
          constructor(e) {
            this._map = e
          }
          reset() {
            this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent
          }
          mousemove(e) {
            this._map.fire(new Gn(e.type, this._map, e))
          }
          mousedown() {
            this._delayContextMenu = !0, this._ignoreContextMenu = !1
          }
          mouseup() {
            this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Gn("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent)
          }
          contextmenu(e) {
            this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new Gn(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault()
          }
          isEnabled() {
            return !0
          }
          isActive() {
            return !1
          }
          enable() {}
          disable() {}
        }
        class Gs {
          constructor(e) {
            this._map = e
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform
          }
          get center() {
            return {
              lng: this.transform.center.lng,
              lat: this.transform.center.lat
            }
          }
          get zoom() {
            return this.transform.zoom
          }
          get pitch() {
            return this.transform.pitch
          }
          get bearing() {
            return this.transform.bearing
          }
          unproject(e) {
            return this.transform.screenPointToLocation(o.P.convert(e), this._map.terrain)
          }
        }
        class jc {
          constructor(e, r) {
            this._map = e, this._tr = new Gs(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = r.clickTolerance || 1
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active
          }
          enable() {
            this.isEnabled() || (this._enabled = !0)
          }
          disable() {
            this.isEnabled() && (this._enabled = !1)
          }
          mousedown(e, r) {
            this.isEnabled() && e.shiftKey && e.button === 0 && (W.disableDrag(), this._startPos = this._lastPos = r, this._active = !0)
          }
          mousemoveWindow(e, r) {
            if (!this._active) return;
            const s = r;
            if (this._lastPos.equals(s) || !this._box && s.dist(this._startPos) < this._clickTolerance) return;
            const c = this._startPos;
            this._lastPos = s, this._box || (this._box = W.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e));
            const d = Math.min(c.x, s.x),
              m = Math.max(c.x, s.x),
              v = Math.min(c.y, s.y),
              w = Math.max(c.y, s.y);
            W.setTransform(this._box, `translate(${d}px,${v}px)`), this._box.style.width = m - d + "px", this._box.style.height = w - v + "px"
          }
          mouseupWindow(e, r) {
            if (!this._active || e.button !== 0) return;
            const s = this._startPos,
              c = r;
            if (this.reset(), W.suppressClick(), s.x !== c.x || s.y !== c.y) return this._map.fire(new o.l("boxzoomend", {
              originalEvent: e
            })), {
              cameraAnimation: d => d.fitScreenCoordinates(s, c, this._tr.bearing, {
                linear: !0
              })
            };
            this._fireEvent("boxzoomcancel", e)
          }
          keydown(e) {
            this._active && e.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e))
          }
          reset() {
            this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (W.remove(this._box), this._box = null), W.enableDrag(), delete this._startPos, delete this._lastPos
          }
          _fireEvent(e, r) {
            return this._map.fire(new o.l(e, {
              originalEvent: r
            }))
          }
        }

        function Tl(h, e) {
          if (h.length !== e.length) throw new Error(`The number of touches and points are not equal - touches ${h.length}, points ${e.length}`);
          const r = {};
          for (let s = 0; s < h.length; s++) r[h[s].identifier] = e[s];
          return r
        }
        class Hh {
          constructor(e) {
            this.reset(), this.numTouches = e.numTouches
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1
          }
          touchstart(e, r, s) {
            (this.centroid || s.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = e.timeStamp), s.length === this.numTouches && (this.centroid = (function(c) {
              const d = new o.P(0, 0);
              for (const m of c) d._add(m);
              return d.div(c.length)
            })(r), this.touches = Tl(s, r)))
          }
          touchmove(e, r, s) {
            if (this.aborted || !this.centroid) return;
            const c = Tl(s, r);
            for (const d in this.touches) {
              const m = c[d];
              (!m || m.dist(this.touches[d]) > 30) && (this.aborted = !0)
            }
          }
          touchend(e, r, s) {
            if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), s.length === 0) {
              const c = !this.aborted && this.centroid;
              if (this.reset(), c) return c
            }
          }
        }
        class Cl {
          constructor(e) {
            this.singleTap = new Hh(e), this.numTaps = e.numTaps, this.reset()
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset()
          }
          touchstart(e, r, s) {
            this.singleTap.touchstart(e, r, s)
          }
          touchmove(e, r, s) {
            this.singleTap.touchmove(e, r, s)
          }
          touchend(e, r, s) {
            const c = this.singleTap.touchend(e, r, s);
            if (c) {
              const d = e.timeStamp - this.lastTime < 500,
                m = !this.lastTap || this.lastTap.dist(c) < 30;
              if (d && m || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = c, this.count === this.numTaps) return this.reset(), c
            }
          }
        }
        class Sl {
          constructor(e) {
            this._tr = new Gs(e), this._zoomIn = new Cl({
              numTouches: 1,
              numTaps: 2
            }), this._zoomOut = new Cl({
              numTouches: 2,
              numTaps: 1
            }), this.reset()
          }
          reset() {
            this._active = !1, this._zoomIn.reset(), this._zoomOut.reset()
          }
          touchstart(e, r, s) {
            this._zoomIn.touchstart(e, r, s), this._zoomOut.touchstart(e, r, s)
          }
          touchmove(e, r, s) {
            this._zoomIn.touchmove(e, r, s), this._zoomOut.touchmove(e, r, s)
          }
          touchend(e, r, s) {
            const c = this._zoomIn.touchend(e, r, s),
              d = this._zoomOut.touchend(e, r, s),
              m = this._tr;
            return c ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), {
              cameraAnimation: v => v.easeTo({
                duration: 300,
                zoom: m.zoom + 1,
                around: m.unproject(c)
              }, {
                originalEvent: e
              })
            }) : d ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), {
              cameraAnimation: v => v.easeTo({
                duration: 300,
                zoom: m.zoom - 1,
                around: m.unproject(d)
              }, {
                originalEvent: e
              })
            }) : void 0
          }
          touchcancel() {
            this.reset()
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class Hs {
          constructor(e) {
            this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset()
          }
          reset(e) {
            this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(e)
          }
          _move(...e) {
            const r = this._moveFunction(...e);
            if (r.bearingDelta || r.pitchDelta || r.rollDelta || r.around || r.panDelta) return this._active = !0, r
          }
          dragStart(e, r) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = Array.isArray(r) ? r[0] : r, this._activateOnStart && this._lastPoint && (this._active = !0))
          }
          dragMove(e, r) {
            if (!this.isEnabled()) return;
            const s = this._lastPoint;
            if (!s) return;
            if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) return void this.reset(e);
            const c = Array.isArray(r) ? r[0] : r;
            return !this._moved && c.dist(s) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = c, this._move(s, c))
          }
          dragEnd(e) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && W.suppressClick(), this.reset(e))
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
          getClickTolerance() {
            return this._clickTolerance
          }
        }
        const ua = 0,
          _a = 2,
          Wh = {
            [ua]: 1,
            [_a]: 2
          };
        class Bn {
          constructor(e) {
            this._correctEvent = e.checkCorrectEvent
          }
          startMove(e) {
            const r = W.mouseButton(e);
            this._eventButton = r
          }
          endMove(e) {
            delete this._eventButton
          }
          isValidStartEvent(e) {
            return this._correctEvent(e)
          }
          isValidMoveEvent(e) {
            return !(function(r, s) {
              const c = Wh[s];
              return r.buttons === void 0 || (r.buttons & c) !== c
            })(e, this._eventButton)
          }
          isValidEndEvent(e) {
            return W.mouseButton(e) === this._eventButton
          }
        }
        class Ws {
          constructor() {
            this._firstTouch = void 0
          }
          _isOneFingerTouch(e) {
            return e.targetTouches.length === 1
          }
          _isSameTouchEvent(e) {
            return e.targetTouches[0].identifier === this._firstTouch
          }
          startMove(e) {
            this._firstTouch = e.targetTouches[0].identifier
          }
          endMove(e) {
            delete this._firstTouch
          }
          isValidStartEvent(e) {
            return this._isOneFingerTouch(e)
          }
          isValidMoveEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e)
          }
          isValidEndEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e)
          }
        }
        class pp {
          constructor(e = new Bn({
            checkCorrectEvent: () => !0
          }), r = new Ws) {
            this.mouseMoveStateManager = e, this.oneFingerTouchMoveStateManager = r
          }
          _executeRelevantHandler(e, r, s) {
            return e instanceof MouseEvent ? r(e) : typeof TouchEvent < "u" && e instanceof TouchEvent ? s(e) : void 0
          }
          startMove(e) {
            this._executeRelevantHandler(e, (r => this.mouseMoveStateManager.startMove(r)), (r => this.oneFingerTouchMoveStateManager.startMove(r)))
          }
          endMove(e) {
            this._executeRelevantHandler(e, (r => this.mouseMoveStateManager.endMove(r)), (r => this.oneFingerTouchMoveStateManager.endMove(r)))
          }
          isValidStartEvent(e) {
            return this._executeRelevantHandler(e, (r => this.mouseMoveStateManager.isValidStartEvent(r)), (r => this.oneFingerTouchMoveStateManager.isValidStartEvent(r)))
          }
          isValidMoveEvent(e) {
            return this._executeRelevantHandler(e, (r => this.mouseMoveStateManager.isValidMoveEvent(r)), (r => this.oneFingerTouchMoveStateManager.isValidMoveEvent(r)))
          }
          isValidEndEvent(e) {
            return this._executeRelevantHandler(e, (r => this.mouseMoveStateManager.isValidEndEvent(r)), (r => this.oneFingerTouchMoveStateManager.isValidEndEvent(r)))
          }
        }
        const Pl = h => {
          h.mousedown = h.dragStart, h.mousemoveWindow = h.dragMove, h.mouseup = h.dragEnd, h.contextmenu = e => {
            e.preventDefault()
          }
        };
        class fp {
          constructor(e, r) {
            this._clickTolerance = e.clickTolerance || 1, this._map = r, this.reset()
          }
          reset() {
            this._active = !1, this._touches = {}, this._sum = new o.P(0, 0)
          }
          _shouldBePrevented(e) {
            return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1)
          }
          touchstart(e, r, s) {
            return this._calculateTransform(e, r, s)
          }
          touchmove(e, r, s) {
            if (this._active) {
              if (!this._shouldBePrevented(s.length)) return e.preventDefault(), this._calculateTransform(e, r, s);
              this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e)
            }
          }
          touchend(e, r, s) {
            this._calculateTransform(e, r, s), this._active && this._shouldBePrevented(s.length) && this.reset()
          }
          touchcancel() {
            this.reset()
          }
          _calculateTransform(e, r, s) {
            s.length > 0 && (this._active = !0);
            const c = Tl(s, r),
              d = new o.P(0, 0),
              m = new o.P(0, 0);
            let v = 0;
            for (const P in c) {
              const M = c[P],
                D = this._touches[P];
              D && (d._add(M), m._add(M.sub(D)), v++, c[P] = M)
            }
            if (this._touches = c, this._shouldBePrevented(v) || !m.mag()) return;
            const w = m.div(v);
            return this._sum._add(w), this._sum.mag() < this._clickTolerance ? void 0 : {
              around: d.div(v),
              panDelta: w
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class qc {
          constructor() {
            this.reset()
          }
          reset() {
            this._active = !1, delete this._firstTwoTouches
          }
          touchstart(e, r, s) {
            this._firstTwoTouches || s.length < 2 || (this._firstTwoTouches = [s[0].identifier, s[1].identifier], this._start([r[0], r[1]]))
          }
          touchmove(e, r, s) {
            if (!this._firstTwoTouches) return;
            e.preventDefault();
            const [c, d] = this._firstTwoTouches, m = ko(s, r, c), v = ko(s, r, d);
            if (!m || !v) return;
            const w = this._aroundCenter ? null : m.add(v).div(2);
            return this._move([m, v], w, e)
          }
          touchend(e, r, s) {
            if (!this._firstTwoTouches) return;
            const [c, d] = this._firstTwoTouches, m = ko(s, r, c), v = ko(s, r, d);
            m && v || (this._active && W.suppressClick(), this.reset())
          }
          touchcancel() {
            this.reset()
          }
          enable(e) {
            this._enabled = !0, this._aroundCenter = !!e && e.around === "center"
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active
          }
        }

        function ko(h, e, r) {
          for (let s = 0; s < h.length; s++)
            if (h[s].identifier === r) return e[s]
        }

        function Xs(h, e) {
          return Math.log(h / e) / Math.LN2
        }
        class Pa extends qc {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance
          }
          _start(e) {
            this._startDistance = this._distance = e[0].dist(e[1])
          }
          _move(e, r) {
            const s = this._distance;
            if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(Xs(this._distance, this._startDistance)) < .1)) return this._active = !0, {
              zoomDelta: Xs(this._distance, s),
              pinchAround: r
            }
          }
        }

        function Wt(h, e) {
          return 180 * h.angleWith(e) / Math.PI
        }
        class Vc extends qc {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector
          }
          _start(e) {
            this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1])
          }
          _move(e, r, s) {
            const c = this._vector;
            if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, {
              bearingDelta: Wt(this._vector, c),
              pinchAround: r
            }
          }
          _isBelowThreshold(e) {
            this._minDiameter = Math.min(this._minDiameter, e.mag());
            const r = 25 / (Math.PI * this._minDiameter) * 360,
              s = Wt(e, this._startVector);
            return Math.abs(s) < r
          }
        }

        function Eo(h) {
          return Math.abs(h.y) > Math.abs(h.x)
        }
        class Zc extends qc {
          constructor(e) {
            super(), this._currentTouchCount = 0, this._map = e
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints
          }
          touchstart(e, r, s) {
            super.touchstart(e, r, s), this._currentTouchCount = s.length
          }
          _start(e) {
            this._lastPoints = e, Eo(e[0].sub(e[1])) && (this._valid = !1)
          }
          _move(e, r, s) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
            const c = e[0].sub(this._lastPoints[0]),
              d = e[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(c, d, s.timeStamp), this._valid ? (this._lastPoints = e, this._active = !0, {
              pitchDelta: (c.y + d.y) / 2 * -.5
            }) : void 0
          }
          gestureBeginsVertically(e, r, s) {
            if (this._valid !== void 0) return this._valid;
            const c = e.mag() >= 2,
              d = r.mag() >= 2;
            if (!c && !d) return;
            if (!c || !d) return this._firstMove === void 0 && (this._firstMove = s), s - this._firstMove < 100 && void 0;
            const m = e.y > 0 == r.y > 0;
            return Eo(e) && Eo(r) && m
          }
        }
        const zo = {
          panStep: 100,
          bearingStep: 15,
          pitchStep: 10
        };
        class Ks {
          constructor(e) {
            this._tr = new Gs(e);
            const r = zo;
            this._panStep = r.panStep, this._bearingStep = r.bearingStep, this._pitchStep = r.pitchStep, this._rotationDisabled = !1
          }
          reset() {
            this._active = !1
          }
          keydown(e) {
            if (e.altKey || e.ctrlKey || e.metaKey) return;
            let r = 0,
              s = 0,
              c = 0,
              d = 0,
              m = 0;
            switch (e.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                r = 1;
                break;
              case 189:
              case 109:
              case 173:
                r = -1;
                break;
              case 37:
                e.shiftKey ? s = -1 : (e.preventDefault(), d = -1);
                break;
              case 39:
                e.shiftKey ? s = 1 : (e.preventDefault(), d = 1);
                break;
              case 38:
                e.shiftKey ? c = 1 : (e.preventDefault(), m = -1);
                break;
              case 40:
                e.shiftKey ? c = -1 : (e.preventDefault(), m = 1);
                break;
              default:
                return
            }
            return this._rotationDisabled && (s = 0, c = 0), {
              cameraAnimation: v => {
                const w = this._tr;
                v.easeTo({
                  duration: 300,
                  easeId: "keyboardHandler",
                  easing: $c,
                  zoom: r ? Math.round(w.zoom) + r * (e.shiftKey ? 2 : 1) : w.zoom,
                  bearing: w.bearing + s * this._bearingStep,
                  pitch: w.pitch + c * this._pitchStep,
                  offset: [-d * this._panStep, -m * this._panStep],
                  center: w.center
                }, {
                  originalEvent: e
                })
              }
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
          disableRotation() {
            this._rotationDisabled = !0
          }
          enableRotation() {
            this._rotationDisabled = !1
          }
        }

        function $c(h) {
          return h * (2 - h)
        }
        const li = 4.000244140625,
          Uc = 1 / 450;
        class Xh {
          constructor(e, r) {
            this._onTimeout = s => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(s)
            }, this._map = e, this._tr = new Gs(e), this._triggerRenderFrame = r, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = Uc
          }
          setZoomRate(e) {
            this._defaultZoomRate = e
          }
          setWheelZoomRate(e) {
            this._wheelZoomRate = e
          }
          isEnabled() {
            return !!this._enabled
          }
          isActive() {
            return !!this._active || this._finishTimeout !== void 0
          }
          isZooming() {
            return !!this._zooming
          }
          enable(e) {
            this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && e.around === "center")
          }
          disable() {
            this.isEnabled() && (this._enabled = !1)
          }
          _shouldBePrevented(e) {
            return !!this._map.cooperativeGestures.isEnabled() && !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e))
          }
          wheel(e) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(e)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e);
            let r = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;
            const s = fe.now(),
              c = s - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = s, r !== 0 && r % li == 0 ? this._type = "wheel" : r !== 0 && Math.abs(r) < 4 ? this._type = "trackpad" : c > 400 ? (this._type = null, this._lastValue = r, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(c * r) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, r += this._lastValue)), e.shiftKey && r && (r /= 4), this._type && (this._lastWheelEvent = e, this._delta -= r, this._active || this._start(e)), e.preventDefault()
          }
          _start(e) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const r = W.mousePos(this._map.getCanvas(), e),
              s = this._tr;
            this._aroundPoint = this._aroundCenter ? s.transform.locationToScreenPoint(o.S.convert(s.center)) : r, this._frameId || (this._frameId = !0, this._triggerRenderFrame())
          }
          renderFrame() {
            if (!this._frameId || (this._frameId = null, !this.isActive())) return;
            const e = this._tr.transform;
            if (typeof this._lastExpectedZoom == "number") {
              const v = e.zoom - this._lastExpectedZoom;
              typeof this._startZoom == "number" && (this._startZoom += v), typeof this._targetZoom == "number" && (this._targetZoom += v)
            }
            if (this._delta !== 0) {
              const v = this._type === "wheel" && Math.abs(this._delta) > li ? this._wheelZoomRate : this._defaultZoomRate;
              let w = 2 / (1 + Math.exp(-Math.abs(this._delta * v)));
              this._delta < 0 && w !== 0 && (w = 1 / w);
              const P = typeof this._targetZoom != "number" ? e.scale : o.ae(this._targetZoom);
              this._targetZoom = e.getConstrained(e.getCameraLngLat(), o.aj(P * w)).zoom, this._type === "wheel" && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0
            }
            const r = typeof this._targetZoom != "number" ? e.zoom : this._targetZoom,
              s = this._startZoom,
              c = this._easing;
            let d, m = !1;
            if (this._type === "wheel" && s && c) {
              const v = fe.now() - this._lastWheelEventTime,
                w = Math.min((v + 5) / 200, 1),
                P = c(w);
              d = o.C.number(s, r, P), w < 1 ? this._frameId || (this._frameId = !0) : m = !0
            } else d = r, m = !0;
            return this._active = !0, m && (this._active = !1, this._finishTimeout = setTimeout((() => {
              this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout
            }), 200)), this._lastExpectedZoom = d, {
              noInertia: !0,
              needsRenderFrame: !m,
              zoomDelta: d - e.zoom,
              around: this._aroundPoint,
              originalEvent: this._lastWheelEvent
            }
          }
          _smoothOutEasing(e) {
            let r = o.cn;
            if (this._prevEase) {
              const s = this._prevEase,
                c = (fe.now() - s.start) / s.duration,
                d = s.easing(c + .01) - s.easing(c),
                m = .27 / Math.sqrt(d * d + 1e-4) * .01,
                v = Math.sqrt(.0729 - m * m);
              r = o.cl(m, v, .25, 1)
            }
            return this._prevEase = {
              start: fe.now(),
              duration: e,
              easing: r
            }, r
          }
          reset() {
            this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout)
          }
        }
        class Il {
          constructor(e, r) {
            this._clickZoom = e, this._tapZoom = r
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable()
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable()
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled()
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive()
          }
        }
        class mp {
          constructor(e) {
            this._tr = new Gs(e), this.reset()
          }
          reset() {
            this._active = !1
          }
          dblclick(e, r) {
            return e.preventDefault(), {
              cameraAnimation: s => {
                s.easeTo({
                  duration: 300,
                  zoom: this._tr.zoom + (e.shiftKey ? -1 : 1),
                  around: this._tr.unproject(r)
                }, {
                  originalEvent: e
                })
              }
            }
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class _p {
          constructor() {
            this._tap = new Cl({
              numTouches: 1,
              numTaps: 1
            }), this.reset()
          }
          reset() {
            this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset()
          }
          touchstart(e, r, s) {
            if (!this._swipePoint)
              if (this._tapTime) {
                const c = r[0],
                  d = e.timeStamp - this._tapTime < 500,
                  m = this._tapPoint.dist(c) < 30;
                d && m ? s.length > 0 && (this._swipePoint = c, this._swipeTouch = s[0].identifier) : this.reset()
              } else this._tap.touchstart(e, r, s)
          }
          touchmove(e, r, s) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (s[0].identifier !== this._swipeTouch) return;
                const c = r[0],
                  d = c.y - this._swipePoint.y;
                return this._swipePoint = c, e.preventDefault(), this._active = !0, {
                  zoomDelta: d / 128
                }
              }
            } else this._tap.touchmove(e, r, s)
          }
          touchend(e, r, s) {
            if (this._tapTime) this._swipePoint && s.length === 0 && this.reset();
            else {
              const c = this._tap.touchend(e, r, s);
              c && (this._tapTime = e.timeStamp, this._tapPoint = c)
            }
          }
          touchcancel() {
            this.reset()
          }
          enable() {
            this._enabled = !0
          }
          disable() {
            this._enabled = !1, this.reset()
          }
          isEnabled() {
            return this._enabled
          }
          isActive() {
            return this._active
          }
        }
        class Gc {
          constructor(e, r, s) {
            this._el = e, this._mousePan = r, this._touchPan = s
          }
          enable(e) {
            this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan")
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan")
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled()
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive()
          }
        }
        class Ml {
          constructor(e, r, s, c) {
            this._pitchWithRotate = e.pitchWithRotate, this._rollEnabled = e.rollEnabled, this._mouseRotate = r, this._mousePitch = s, this._mouseRoll = c
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable()
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable()
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled())
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive()
          }
        }
        class Hc {
          constructor(e, r, s, c) {
            this._el = e, this._touchZoom = r, this._touchRotate = s, this._tapDragZoom = c, this._rotationDisabled = !1, this._enabled = !0
          }
          enable(e) {
            this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate")
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate")
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled()
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive()
          }
          disableRotation() {
            this._rotationDisabled = !0, this._touchRotate.disable()
          }
          enableRotation() {
            this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable()
          }
        }
        class Kh {
          constructor(e, r) {
            this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = e, this._options = r, this._enabled = !1
          }
          isActive() {
            return !1
          }
          reset() {}
          _setupUI() {
            if (this._container) return;
            const e = this._map.getCanvasContainer();
            e.classList.add("maplibregl-cooperative-gestures"), this._container = W.create("div", "maplibregl-cooperative-gesture-screen", e);
            let r = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            this._bypassKey === "metaKey" && (r = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const s = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"),
              c = document.createElement("div");
            c.className = "maplibregl-desktop-message", c.textContent = r, this._container.appendChild(c);
            const d = document.createElement("div");
            d.className = "maplibregl-mobile-message", d.textContent = s, this._container.appendChild(d), this._container.setAttribute("aria-hidden", "true")
          }
          _destroyUI() {
            this._container && (W.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container
          }
          enable() {
            this._setupUI(), this._enabled = !0
          }
          disable() {
            this._enabled = !1, this._destroyUI()
          }
          isEnabled() {
            return this._enabled
          }
          isBypassed(e) {
            return e[this._bypassKey]
          }
          notifyGestureBlocked(e, r) {
            this._enabled && (this._map.fire(new o.l("cooperativegestureprevented", {
              gestureType: e,
              originalEvent: r
            })), this._container.classList.add("maplibregl-show"), setTimeout((() => {
              this._container.classList.remove("maplibregl-show")
            }), 100))
          }
        }
        const Lo = h => h.zoom || h.drag || h.roll || h.pitch || h.rotate;
        class gp extends o.l {}

        function Wc(h) {
          return h.panDelta && h.panDelta.mag() || h.zoomDelta || h.bearingDelta || h.pitchDelta || h.rollDelta
        }
        class Xa {
          constructor(e, r) {
            this.handleWindowEvent = c => {
              this.handleEvent(c, `${c.type}Window`)
            }, this.handleEvent = (c, d) => {
              if (c.type === "blur") return void this.stop(!0);
              this._updatingCamera = !0;
              const m = c.type === "renderFrame" ? void 0 : c,
                v = {
                  needsRenderFrame: !1
                },
                w = {},
                P = {};
              for (const {
                  handlerName: L,
                  handler: B,
                  allowed: Z
                }
                of this._handlers) {
                if (!B.isEnabled()) continue;
                let te;
                if (this._blockedByActive(P, Z, L)) B.reset();
                else if (B[d || c.type]) {
                  if (o.co(c, d || c.type)) {
                    const ee = W.mousePos(this._map.getCanvas(), c);
                    te = B[d || c.type](c, ee)
                  } else if (o.cp(c, d || c.type)) {
                    const ee = this._getMapTouches(c.touches),
                      ne = W.touchPos(this._map.getCanvas(), ee);
                    te = B[d || c.type](c, ne, ee)
                  } else o.cq(d || c.type) || (te = B[d || c.type](c));
                  this.mergeHandlerResult(v, w, te, L, m), te && te.needsRenderFrame && this._triggerRenderFrame()
                }(te || B.isActive()) && (P[L] = B)
              }
              const M = {};
              for (const L in this._previousActiveHandlers) P[L] || (M[L] = m);
              this._previousActiveHandlers = P, (Object.keys(M).length || Wc(v)) && (this._changes.push([v, w, M]), this._triggerRenderFrame()), (Object.keys(P).length || Wc(v)) && this._map._stop(!0), this._updatingCamera = !1;
              const {
                cameraAnimation: D
              } = v;
              D && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], D(this._map))
            }, this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new $h(e), this._bearingSnap = r.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(r);
            const s = this._el;
            this._listeners = [
              [s, "touchstart", {
                passive: !0
              }],
              [s, "touchmove", {
                passive: !1
              }],
              [s, "touchend", void 0],
              [s, "touchcancel", void 0],
              [s, "mousedown", void 0],
              [s, "mousemove", void 0],
              [s, "mouseup", void 0],
              [document, "mousemove", {
                capture: !0
              }],
              [document, "mouseup", void 0],
              [s, "mouseover", void 0],
              [s, "mouseout", void 0],
              [s, "dblclick", void 0],
              [s, "click", void 0],
              [s, "keydown", {
                capture: !1
              }],
              [s, "keyup", void 0],
              [s, "wheel", {
                passive: !1
              }],
              [s, "contextmenu", void 0],
              [window, "blur", void 0]
            ];
            for (const [c, d, m] of this._listeners) W.addEventListener(c, d, c === document ? this.handleWindowEvent : this.handleEvent, m)
          }
          destroy() {
            for (const [e, r, s] of this._listeners) W.removeEventListener(e, r, e === document ? this.handleWindowEvent : this.handleEvent, s)
          }
          _addDefaultHandlers(e) {
            const r = this._map,
              s = r.getCanvasContainer();
            this._add("mapEvent", new Uh(r, e));
            const c = r.boxZoom = new jc(r, e);
            this._add("boxZoom", c), e.interactive && e.boxZoom && c.enable();
            const d = r.cooperativeGestures = new Kh(r, e.cooperativeGestures);
            this._add("cooperativeGestures", d), e.cooperativeGestures && d.enable();
            const m = new Sl(r),
              v = new mp(r);
            r.doubleClickZoom = new Il(v, m), this._add("tapZoom", m), this._add("clickZoom", v), e.interactive && e.doubleClickZoom && r.doubleClickZoom.enable();
            const w = new _p;
            this._add("tapDragZoom", w);
            const P = r.touchPitch = new Zc(r);
            this._add("touchPitch", P), e.interactive && e.touchPitch && r.touchPitch.enable(e.touchPitch);
            const M = () => r.project(r.getCenter()),
              D = (function({
                enable: ue,
                clickTolerance: be,
                aroundCenter: Pe = !0,
                minPixelCenterThreshold: pe = 100,
                rotateDegreesPerPixelMoved: Fe = .8
              }, Je) {
                const Ge = new Bn({
                  checkCorrectEvent: He => W.mouseButton(He) === 0 && He.ctrlKey || W.mouseButton(He) === 2 && !He.ctrlKey
                });
                return new Hs({
                  clickTolerance: be,
                  move: (He, Qe) => {
                    const qt = Je();
                    if (Pe && Math.abs(qt.y - He.y) > pe) return {
                      bearingDelta: o.cm(new o.P(He.x, Qe.y), Qe, qt)
                    };
                    let Ft = (Qe.x - He.x) * Fe;
                    return Pe && Qe.y < qt.y && (Ft = -Ft), {
                      bearingDelta: Ft
                    }
                  },
                  moveStateManager: Ge,
                  enable: ue,
                  assignEvents: Pl
                })
              })(e, M),
              L = (function({
                enable: ue,
                clickTolerance: be,
                pitchDegreesPerPixelMoved: Pe = -.5
              }) {
                const pe = new Bn({
                  checkCorrectEvent: Fe => W.mouseButton(Fe) === 0 && Fe.ctrlKey || W.mouseButton(Fe) === 2
                });
                return new Hs({
                  clickTolerance: be,
                  move: (Fe, Je) => ({
                    pitchDelta: (Je.y - Fe.y) * Pe
                  }),
                  moveStateManager: pe,
                  enable: ue,
                  assignEvents: Pl
                })
              })(e),
              B = (function({
                enable: ue,
                clickTolerance: be,
                rollDegreesPerPixelMoved: Pe = .3
              }, pe) {
                const Fe = new Bn({
                  checkCorrectEvent: Je => W.mouseButton(Je) === 2 && Je.ctrlKey
                });
                return new Hs({
                  clickTolerance: be,
                  move: (Je, Ge) => {
                    const He = pe();
                    let Qe = (Ge.x - Je.x) * Pe;
                    return Ge.y < He.y && (Qe = -Qe), {
                      rollDelta: Qe
                    }
                  },
                  moveStateManager: Fe,
                  enable: ue,
                  assignEvents: Pl
                })
              })(e, M);
            r.dragRotate = new Ml(e, D, L, B), this._add("mouseRotate", D, ["mousePitch"]), this._add("mousePitch", L, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", B, ["mousePitch"]), e.interactive && e.dragRotate && r.dragRotate.enable();
            const Z = (function({
                enable: ue,
                clickTolerance: be
              }) {
                const Pe = new Bn({
                  checkCorrectEvent: pe => W.mouseButton(pe) === 0 && !pe.ctrlKey
                });
                return new Hs({
                  clickTolerance: be,
                  move: (pe, Fe) => ({
                    around: Fe,
                    panDelta: Fe.sub(pe)
                  }),
                  activateOnStart: !0,
                  moveStateManager: Pe,
                  enable: ue,
                  assignEvents: Pl
                })
              })(e),
              te = new fp(e, r);
            r.dragPan = new Gc(s, Z, te), this._add("mousePan", Z), this._add("touchPan", te, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && r.dragPan.enable(e.dragPan);
            const ee = new Vc,
              ne = new Pa;
            r.touchZoomRotate = new Hc(s, ne, ee, w), this._add("touchRotate", ee, ["touchPan", "touchZoom"]), this._add("touchZoom", ne, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && r.touchZoomRotate.enable(e.touchZoomRotate);
            const oe = r.scrollZoom = new Xh(r, (() => this._triggerRenderFrame()));
            this._add("scrollZoom", oe, ["mousePan"]), e.interactive && e.scrollZoom && r.scrollZoom.enable(e.scrollZoom);
            const me = r.keyboard = new Ks(r);
            this._add("keyboard", me), e.interactive && e.keyboard && r.keyboard.enable(), this._add("blockableMapEvent", new Gh(r))
          }
          _add(e, r, s) {
            this._handlers.push({
              handlerName: e,
              handler: r,
              allowed: s
            }), this._handlersById[e] = r
          }
          stop(e) {
            if (!this._updatingCamera) {
              for (const {
                  handler: r
                }
                of this._handlers) r.reset();
              this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = []
            }
          }
          isActive() {
            for (const {
                handler: e
              }
              of this._handlers)
              if (e.isActive()) return !0;
            return !1
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming()
          }
          isRotating() {
            return !!this._eventsInProgress.rotate
          }
          isMoving() {
            return !!Lo(this._eventsInProgress) || this.isZooming()
          }
          _blockedByActive(e, r, s) {
            for (const c in e)
              if (c !== s && (!r || r.indexOf(c) < 0)) return !0;
            return !1
          }
          _getMapTouches(e) {
            const r = [];
            for (const s of e) this._el.contains(s.target) && r.push(s);
            return r
          }
          mergeHandlerResult(e, r, s, c, d) {
            if (!s) return;
            o.e(e, s);
            const m = {
              handlerName: c,
              originalEvent: s.originalEvent || d
            };
            s.zoomDelta !== void 0 && (r.zoom = m), s.panDelta !== void 0 && (r.drag = m), s.rollDelta !== void 0 && (r.roll = m), s.pitchDelta !== void 0 && (r.pitch = m), s.bearingDelta !== void 0 && (r.rotate = m)
          }
          _applyChanges() {
            const e = {},
              r = {},
              s = {};
            for (const [c, d, m] of this._changes) c.panDelta && (e.panDelta = (e.panDelta || new o.P(0, 0))._add(c.panDelta)), c.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + c.zoomDelta), c.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + c.bearingDelta), c.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + c.pitchDelta), c.rollDelta && (e.rollDelta = (e.rollDelta || 0) + c.rollDelta), c.around !== void 0 && (e.around = c.around), c.pinchAround !== void 0 && (e.pinchAround = c.pinchAround), c.noInertia && (e.noInertia = c.noInertia), o.e(r, d), o.e(s, m);
            this._updateMapTransform(e, r, s), this._changes = []
          }
          _updateMapTransform(e, r, s) {
            const c = this._map,
              d = c._getTransformForUpdate(),
              m = c.terrain;
            if (!(Wc(e) || m && this._terrainMovement)) return this._fireEvents(r, s, !0);
            c._stop(!0);
            let {
              panDelta: v,
              zoomDelta: w,
              bearingDelta: P,
              pitchDelta: M,
              rollDelta: D,
              around: L,
              pinchAround: B
            } = e;
            B !== void 0 && (L = B), L = L || c.transform.centerPoint, m && !d.isPointOnMapSurface(L) && (L = d.centerPoint);
            const Z = {
              panDelta: v,
              zoomDelta: w,
              rollDelta: D,
              pitchDelta: M,
              bearingDelta: P,
              around: L
            };
            this._map.cameraHelper.useGlobeControls && !d.isPointOnMapSurface(L) && (L = d.centerPoint);
            const te = L.distSqr(d.centerPoint) < .01 ? d.center : d.screenPointToLocation(v ? L.sub(v) : L);
            m ? (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(Z, d), this._terrainMovement || !r.drag && !r.zoom ? r.drag && this._terrainMovement ? d.setCenter(d.screenPointToLocation(d.centerPoint.sub(v))) : this._map.cameraHelper.handleMapControlsPan(Z, d, te) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, this._map.cameraHelper.handleMapControlsPan(Z, d, te))) : (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(Z, d), this._map.cameraHelper.handleMapControlsPan(Z, d, te)), c._applyUpdatedTransform(d), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(r, s, !0)
          }
          _fireEvents(e, r, s) {
            const c = Lo(this._eventsInProgress),
              d = Lo(e),
              m = {};
            for (const D in e) {
              const {
                originalEvent: L
              } = e[D];
              this._eventsInProgress[D] || (m[`${D}start`] = L), this._eventsInProgress[D] = e[D]
            }!c && d && this._fireEvent("movestart", d.originalEvent);
            for (const D in m) this._fireEvent(D, m[D]);
            d && this._fireEvent("move", d.originalEvent);
            for (const D in e) {
              const {
                originalEvent: L
              } = e[D];
              this._fireEvent(D, L)
            }
            const v = {};
            let w;
            for (const D in this._eventsInProgress) {
              const {
                handlerName: L,
                originalEvent: B
              } = this._eventsInProgress[D];
              this._handlersById[L].isActive() || (delete this._eventsInProgress[D], w = r[L] || B, v[`${D}end`] = w)
            }
            for (const D in v) this._fireEvent(D, v[D]);
            const P = Lo(this._eventsInProgress),
              M = (c || d) && !P;
            if (M && this._terrainMovement) {
              this._map._elevationFreeze = !1, this._terrainMovement = !1;
              const D = this._map._getTransformForUpdate();
              this._map.getCenterClampedToGround() && D.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(D)
            }
            if (s && M) {
              this._updatingCamera = !0;
              const D = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),
                L = B => B !== 0 && -this._bearingSnap < B && B < this._bearingSnap;
              !D || !D.essential && fe.prefersReducedMotion ? (this._map.fire(new o.l("moveend", {
                originalEvent: w
              })), L(this._map.getBearing()) && this._map.resetNorth()) : (L(D.bearing || this._map.getBearing()) && (D.bearing = 0), D.freezeElevation = !0, this._map.easeTo(D, {
                originalEvent: w
              })), this._updatingCamera = !1
            }
          }
          _fireEvent(e, r) {
            this._map.fire(new o.l(e, r ? {
              originalEvent: r
            } : {}))
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e => {
              delete this._frameId, this.handleEvent(new gp("renderFrame", {
                timeStamp: e
              })), this._applyChanges()
            }))
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame())
          }
        }
        class Bi extends o.E {
          constructor(e, r, s) {
            super(), this._renderFrameCallback = () => {
              const c = Math.min((fe.now() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(c)), c < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop()
            }, this._moving = !1, this._zooming = !1, this.transform = e, this._bearingSnap = s.bearingSnap, this.cameraHelper = r, this.on("moveend", (() => {
              delete this._requestedCameraState
            }))
          }
          migrateProjection(e, r) {
            e.apply(this.transform), this.transform = e, this.cameraHelper = r
          }
          getCenter() {
            return new o.S(this.transform.center.lng, this.transform.center.lat)
          }
          setCenter(e, r) {
            return this.jumpTo({
              center: e
            }, r)
          }
          getCenterElevation() {
            return this.transform.elevation
          }
          setCenterElevation(e, r) {
            return this.jumpTo({
              elevation: e
            }, r), this
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround
          }
          setCenterClampedToGround(e) {
            this._centerClampedToGround = e
          }
          panBy(e, r, s) {
            return e = o.P.convert(e).mult(-1), this.panTo(this.transform.center, o.e({
              offset: e
            }, r), s)
          }
          panTo(e, r, s) {
            return this.easeTo(o.e({
              center: e
            }, r), s)
          }
          getZoom() {
            return this.transform.zoom
          }
          setZoom(e, r) {
            return this.jumpTo({
              zoom: e
            }, r), this
          }
          zoomTo(e, r, s) {
            return this.easeTo(o.e({
              zoom: e
            }, r), s)
          }
          zoomIn(e, r) {
            return this.zoomTo(this.getZoom() + 1, e, r), this
          }
          zoomOut(e, r) {
            return this.zoomTo(this.getZoom() - 1, e, r), this
          }
          getVerticalFieldOfView() {
            return this.transform.fov
          }
          setVerticalFieldOfView(e, r) {
            return e != this.transform.fov && (this.transform.setFov(e), this.fire(new o.l("movestart", r)).fire(new o.l("move", r)).fire(new o.l("moveend", r))), this
          }
          getBearing() {
            return this.transform.bearing
          }
          setBearing(e, r) {
            return this.jumpTo({
              bearing: e
            }, r), this
          }
          getPadding() {
            return this.transform.padding
          }
          setPadding(e, r) {
            return this.jumpTo({
              padding: e
            }, r), this
          }
          rotateTo(e, r, s) {
            return this.easeTo(o.e({
              bearing: e
            }, r), s)
          }
          resetNorth(e, r) {
            return this.rotateTo(0, o.e({
              duration: 1e3
            }, e), r), this
          }
          resetNorthPitch(e, r) {
            return this.easeTo(o.e({
              bearing: 0,
              pitch: 0,
              roll: 0,
              duration: 1e3
            }, e), r), this
          }
          snapToNorth(e, r) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, r) : this
          }
          getPitch() {
            return this.transform.pitch
          }
          setPitch(e, r) {
            return this.jumpTo({
              pitch: e
            }, r), this
          }
          getRoll() {
            return this.transform.roll
          }
          setRoll(e, r) {
            return this.jumpTo({
              roll: e
            }, r), this
          }
          cameraForBounds(e, r) {
            e = Lt.convert(e).adjustAntiMeridian();
            const s = r && r.bearing || 0;
            return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), s, r)
          }
          _cameraForBoxAndBearing(e, r, s, c) {
            const d = {
              top: 0,
              bottom: 0,
              right: 0,
              left: 0
            };
            if (typeof(c = o.e({
                padding: d,
                offset: [0, 0],
                maxZoom: this.transform.maxZoom
              }, c)).padding == "number") {
              const P = c.padding;
              c.padding = {
                top: P,
                bottom: P,
                right: P,
                left: P
              }
            }
            const m = o.e(d, c.padding);
            c.padding = m;
            const v = this.transform,
              w = new Lt(e, r);
            return this.cameraHelper.cameraForBoxAndBearing(c, m, w, s, v)
          }
          fitBounds(e, r, s) {
            return this._fitInternal(this.cameraForBounds(e, r), r, s)
          }
          fitScreenCoordinates(e, r, s, c, d) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(o.P.convert(e)), this.transform.screenPointToLocation(o.P.convert(r)), s, c), c, d)
          }
          _fitInternal(e, r, s) {
            return e ? (delete(r = o.e(e, r)).padding, r.linear ? this.easeTo(r, s) : this.flyTo(r, s)) : this
          }
          jumpTo(e, r) {
            this.stop();
            const s = this._getTransformForUpdate();
            let c = !1,
              d = !1,
              m = !1;
            const v = s.zoom;
            this.cameraHelper.handleJumpToCenterZoom(s, e);
            const w = s.zoom !== v;
            return "elevation" in e && s.elevation !== +e.elevation && s.setElevation(+e.elevation), "bearing" in e && s.bearing !== +e.bearing && (c = !0, s.setBearing(+e.bearing)), "pitch" in e && s.pitch !== +e.pitch && (d = !0, s.setPitch(+e.pitch)), "roll" in e && s.roll !== +e.roll && (m = !0, s.setRoll(+e.roll)), e.padding == null || s.isPaddingEqual(e.padding) || s.setPadding(e.padding), this._applyUpdatedTransform(s), this.fire(new o.l("movestart", r)).fire(new o.l("move", r)), w && this.fire(new o.l("zoomstart", r)).fire(new o.l("zoom", r)).fire(new o.l("zoomend", r)), c && this.fire(new o.l("rotatestart", r)).fire(new o.l("rotate", r)).fire(new o.l("rotateend", r)), d && this.fire(new o.l("pitchstart", r)).fire(new o.l("pitch", r)).fire(new o.l("pitchend", r)), m && this.fire(new o.l("rollstart", r)).fire(new o.l("roll", r)).fire(new o.l("rollend", r)), this.fire(new o.l("moveend", r))
          }
          calculateCameraOptionsFromTo(e, r, s, c = 0) {
            const d = o.a0.fromLngLat(e, r),
              m = o.a0.fromLngLat(s, c),
              v = m.x - d.x,
              w = m.y - d.y,
              P = m.z - d.z,
              M = Math.hypot(v, w, P);
            if (M === 0) throw new Error("Can't calculate camera options with same From and To");
            const D = Math.hypot(v, w),
              L = o.aj(this.transform.cameraToCenterDistance / M / this.transform.tileSize),
              B = 180 * Math.atan2(v, -w) / Math.PI;
            let Z = 180 * Math.acos(D / M) / Math.PI;
            return Z = P < 0 ? 90 - Z : 90 + Z, {
              center: m.toLngLat(),
              elevation: c,
              zoom: L,
              pitch: Z,
              bearing: B
            }
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(e, r, s, c, d) {
            const m = this.transform.calculateCenterFromCameraLngLatAlt(e, r, s, c);
            return {
              center: m.center,
              elevation: m.elevation,
              zoom: m.zoom,
              bearing: s,
              pitch: c,
              roll: d
            }
          }
          easeTo(e, r) {
            this._stop(!1, e.easeId), ((e = o.e({
              offset: [0, 0],
              duration: 500,
              easing: o.cn
            }, e)).animate === !1 || !e.essential && fe.prefersReducedMotion) && (e.duration = 0);
            const s = this._getTransformForUpdate(),
              c = this.getBearing(),
              d = s.pitch,
              m = s.roll,
              v = "bearing" in e ? this._normalizeBearing(e.bearing, c) : c,
              w = "pitch" in e ? +e.pitch : d,
              P = "roll" in e ? this._normalizeBearing(e.roll, m) : m,
              M = "padding" in e ? e.padding : s.padding,
              D = o.P.convert(e.offset);
            let L, B;
            e.around && (L = o.S.convert(e.around), B = s.locationToScreenPoint(L));
            const Z = {
                moving: this._moving,
                zooming: this._zooming,
                rotating: this._rotating,
                pitching: this._pitching,
                rolling: this._rolling
              },
              te = this.cameraHelper.handleEaseTo(s, {
                bearing: v,
                pitch: w,
                roll: P,
                padding: M,
                around: L,
                aroundPoint: B,
                offsetAsPoint: D,
                offset: e.offset,
                zoom: e.zoom,
                center: e.center
              });
            return this._rotating = this._rotating || c !== v, this._pitching = this._pitching || w !== d, this._rolling = this._rolling || P !== m, this._padding = !s.isPaddingEqual(M), this._zooming = this._zooming || te.isZooming, this._easeId = e.easeId, this._prepareEase(r, e.noMoveStart, Z), this.terrain && this._prepareElevation(te.elevationCenter), this._ease((ee => {
              te.easeFunc(ee), this.terrain && !e.freezeElevation && this._updateElevation(ee), this._applyUpdatedTransform(s), this._fireMoveEvents(r)
            }), (ee => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(r, ee)
            }), e), this
          }
          _prepareEase(e, r, s = {}) {
            this._moving = !0, r || s.moving || this.fire(new o.l("movestart", e)), this._zooming && !s.zooming && this.fire(new o.l("zoomstart", e)), this._rotating && !s.rotating && this.fire(new o.l("rotatestart", e)), this._pitching && !s.pitching && this.fire(new o.l("pitchstart", e)), this._rolling && !s.rolling && this.fire(new o.l("rollstart", e))
          }
          _prepareElevation(e) {
            this._elevationCenter = e, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom), this._elevationFreeze = !0
          }
          _updateElevation(e) {
            this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
            const r = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (e < 1 && r !== this._elevationTarget) {
              const s = this._elevationTarget - this._elevationStart;
              this._elevationStart += e * (s - (r - (s * e + this._elevationStart)) / (1 - e)), this._elevationTarget = r
            }
            this.transform.setElevation(o.C.number(this._elevationStart, this._elevationTarget, e))
          }
          _finalizeElevation() {
            this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain)
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform
          }
          _elevateCameraIfInsideTerrain(e) {
            if (!this.terrain && e.elevation >= 0 && e.pitch <= 90) return {};
            const r = e.getCameraLngLat(),
              s = e.getCameraAltitude(),
              c = this.terrain ? this.terrain.getElevationForLngLatZoom(r, e.zoom) : 0;
            if (s < c) {
              const d = this.calculateCameraOptionsFromTo(r, c, e.center, e.elevation);
              return {
                pitch: d.pitch,
                zoom: d.zoom
              }
            }
            return {}
          }
          _applyUpdatedTransform(e) {
            const r = [];
            if (r.push((c => this._elevateCameraIfInsideTerrain(c))), this.transformCameraUpdate && r.push((c => this.transformCameraUpdate(c))), !r.length) return;
            const s = e.clone();
            for (const c of r) {
              const d = s.clone(),
                {
                  center: m,
                  zoom: v,
                  roll: w,
                  pitch: P,
                  bearing: M,
                  elevation: D
                } = c(d);
              m && d.setCenter(m), D !== void 0 && d.setElevation(D), v !== void 0 && d.setZoom(v), w !== void 0 && d.setRoll(w), P !== void 0 && d.setPitch(P), M !== void 0 && d.setBearing(M), s.apply(d)
            }
            this.transform.apply(s)
          }
          _fireMoveEvents(e) {
            this.fire(new o.l("move", e)), this._zooming && this.fire(new o.l("zoom", e)), this._rotating && this.fire(new o.l("rotate", e)), this._pitching && this.fire(new o.l("pitch", e)), this._rolling && this.fire(new o.l("roll", e))
          }
          _afterEase(e, r) {
            if (this._easeId && r && this._easeId === r) return;
            delete this._easeId;
            const s = this._zooming,
              c = this._rotating,
              d = this._pitching,
              m = this._rolling;
            this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, s && this.fire(new o.l("zoomend", e)), c && this.fire(new o.l("rotateend", e)), d && this.fire(new o.l("pitchend", e)), m && this.fire(new o.l("rollend", e)), this.fire(new o.l("moveend", e))
          }
          flyTo(e, r) {
            if (!e.essential && fe.prefersReducedMotion) {
              const Qe = o.Q(e, ["center", "zoom", "bearing", "pitch", "roll", "elevation"]);
              return this.jumpTo(Qe, r)
            }
            this.stop(), e = o.e({
              offset: [0, 0],
              speed: 1.2,
              curve: 1.42,
              easing: o.cn
            }, e);
            const s = this._getTransformForUpdate(),
              c = s.bearing,
              d = s.pitch,
              m = s.roll,
              v = s.padding,
              w = "bearing" in e ? this._normalizeBearing(e.bearing, c) : c,
              P = "pitch" in e ? +e.pitch : d,
              M = "roll" in e ? this._normalizeBearing(e.roll, m) : m,
              D = "padding" in e ? e.padding : s.padding,
              L = o.P.convert(e.offset);
            let B = s.centerPoint.add(L);
            const Z = s.screenPointToLocation(B),
              te = this.cameraHelper.handleFlyTo(s, {
                bearing: w,
                pitch: P,
                roll: M,
                padding: D,
                locationAtOffset: Z,
                offsetAsPoint: L,
                center: e.center,
                minZoom: e.minZoom,
                zoom: e.zoom
              });
            let ee = e.curve;
            const ne = Math.max(s.width, s.height),
              oe = ne / te.scaleOfZoom,
              me = te.pixelPathLength;
            typeof te.scaleOfMinZoom == "number" && (ee = Math.sqrt(ne / te.scaleOfMinZoom / me * 2));
            const ue = ee * ee;

            function be(Qe) {
              const qt = (oe * oe - ne * ne + (Qe ? -1 : 1) * ue * ue * me * me) / (2 * (Qe ? oe : ne) * ue * me);
              return Math.log(Math.sqrt(qt * qt + 1) - qt)
            }

            function Pe(Qe) {
              return (Math.exp(Qe) - Math.exp(-Qe)) / 2
            }

            function pe(Qe) {
              return (Math.exp(Qe) + Math.exp(-Qe)) / 2
            }
            const Fe = be(!1);
            let Je = function(Qe) {
                return pe(Fe) / pe(Fe + ee * Qe)
              },
              Ge = function(Qe) {
                return ne * ((pe(Fe) * (Pe(qt = Fe + ee * Qe) / pe(qt)) - Pe(Fe)) / ue) / me;
                var qt
              },
              He = (be(!0) - Fe) / ee;
            if (Math.abs(me) < 2e-6 || !isFinite(He)) {
              if (Math.abs(ne - oe) < 1e-6) return this.easeTo(e, r);
              const Qe = oe < ne ? -1 : 1;
              He = Math.abs(Math.log(oe / ne)) / ee, Ge = () => 0, Je = qt => Math.exp(Qe * ee * qt)
            }
            return e.duration = "duration" in e ? +e.duration : 1e3 * He / ("screenSpeed" in e ? +e.screenSpeed / ee : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = !0, this._rotating = c !== w, this._pitching = P !== d, this._rolling = M !== m, this._padding = !s.isPaddingEqual(D), this._prepareEase(r, !1), this.terrain && this._prepareElevation(te.targetCenter), this._ease((Qe => {
              const qt = Qe * He,
                Ft = 1 / Je(qt),
                Tt = Ge(qt);
              this._rotating && s.setBearing(o.C.number(c, w, Qe)), this._pitching && s.setPitch(o.C.number(d, P, Qe)), this._rolling && s.setRoll(o.C.number(m, M, Qe)), this._padding && (s.interpolatePadding(v, D, Qe), B = s.centerPoint.add(L)), te.easeFunc(Qe, Ft, Tt, B), this.terrain && !e.freezeElevation && this._updateElevation(Qe), this._applyUpdatedTransform(s), this._fireMoveEvents(r)
            }), (() => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(r)
            }), e), this
          }
          isEasing() {
            return !!this._easeFrameId
          }
          stop() {
            return this._stop()
          }
          _stop(e, r) {
            var s;
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const c = this._onEaseEnd;
              delete this._onEaseEnd, c.call(this, r)
            }
            return e || (s = this.handlers) === null || s === void 0 || s.stop(!1), this
          }
          _ease(e, r, s) {
            s.animate === !1 || s.duration === 0 ? (e(1), r()) : (this._easeStart = fe.now(), this._easeOptions = s, this._onEaseFrame = e, this._onEaseEnd = r, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback))
          }
          _normalizeBearing(e, r) {
            e = o.aN(e, -180, 180);
            const s = Math.abs(e - r);
            return Math.abs(e - 360 - r) < s && (e -= 360), Math.abs(e + 360 - r) < s && (e += 360), e
          }
          queryTerrainElevation(e) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(o.S.convert(e), this.transform.tileZoom) : null
          }
        }
        const Do = {
          compact: !0,
          customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>'
        };
        class Al {
          constructor(e = Do) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")))
            }, this._updateData = r => {
              !r || r.sourceDataType !== "metadata" && r.sourceDataType !== "visibility" && r.dataType !== "style" && r.type !== "terrain" || this._updateAttributions()
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"))
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show")
            }, this.options = e
          }
          getDefaultPosition() {
            return "bottom-right"
          }
          onAdd(e) {
            return this._map = e, this._compact = this.options.compact, this._container = W.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = W.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = W.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container
          }
          onRemove() {
            W.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0
          }
          _setElementTitle(e, r) {
            const s = this._map._getUIString(`AttributionControl.${r}`);
            e.title = s, e.setAttribute("aria-label", s)
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let e = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map((c => typeof c != "string" ? "" : c))) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const c = this._map.style.stylesheet;
              this.styleOwner = c.owner, this.styleId = c.id
            }
            const r = this._map.style.sourceCaches;
            for (const c in r) {
              const d = r[c];
              if (d.used || d.usedForTerrain) {
                const m = d.getSource();
                m.attribution && e.indexOf(m.attribution) < 0 && e.push(m.attribution)
              }
            }
            e = e.filter((c => String(c).trim())), e.sort(((c, d) => c.length - d.length)), e = e.filter(((c, d) => {
              for (let m = d + 1; m < e.length; m++)
                if (e[m].indexOf(c) >= 0) return !1;
              return !0
            }));
            const s = e.join(" | ");
            s !== this._attribHTML && (this._attribHTML = s, e.length ? (this._innerContainer.innerHTML = W.sanitize(s), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null)
          }
        }
        class Xc {
          constructor(e = {}) {
            this._updateCompact = () => {
              const r = this._container.children;
              if (r.length) {
                const s = r[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && s.classList.add("maplibregl-compact") : s.classList.remove("maplibregl-compact")
              }
            }, this.options = e
          }
          getDefaultPosition() {
            return "bottom-left"
          }
          onAdd(e) {
            this._map = e, this._compact = this.options && this.options.compact, this._container = W.create("div", "maplibregl-ctrl");
            const r = W.create("a", "maplibregl-ctrl-logo");
            return r.target = "_blank", r.rel = "noopener nofollow", r.href = "https://maplibre.org/", r.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), r.setAttribute("rel", "noopener nofollow"), this._container.appendChild(r), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container
          }
          onRemove() {
            W.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0
          }
        }
        class Yh {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1
          }
          add(e) {
            const r = ++this._id;
            return this._queue.push({
              callback: e,
              id: r,
              cancelled: !1
            }), r
          }
          remove(e) {
            const r = this._currentlyRunning,
              s = r ? this._queue.concat(r) : this._queue;
            for (const c of s)
              if (c.id === e) return void(c.cancelled = !0)
          }
          run(e = 0) {
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const r = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const s of r)
              if (!s.cancelled && (s.callback(e), this._cleared)) break;
            this._cleared = !1, this._currentlyRunning = !1
          }
          clear() {
            this._currentlyRunning && (this._cleared = !0), this._queue = []
          }
        }
        var Jh = o.aI([{
          name: "a_pos3d",
          type: "Int16",
          components: 3
        }]);
        class vp extends o.E {
          constructor(e) {
            super(), this._lastTilesetChange = fe.now(), this.sourceCache = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e._source.tileSize * 2 ** this.deltaZoom, e.usedForTerrain = !0, e.tileSize = this.tileSize
          }
          destruct() {
            this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null
          }
          update(e, r) {
            this.sourceCache.update(e, r), this._renderableTilesKeys = [];
            const s = {};
            for (const c of ze(e, {
                tileSize: this.tileSize,
                minzoom: this.minzoom,
                maxzoom: this.maxzoom,
                reparseOverscaled: !1,
                terrain: r,
                calculateTileZoom: this.sourceCache._source.calculateTileZoom
              })) s[c.key] = !0, this._renderableTilesKeys.push(c.key), this._tiles[c.key] || (c.terrainRttPosMatrix32f = new Float64Array(16), o.bX(c.terrainRttPosMatrix32f, 0, o.$, o.$, 0, 0, 1), this._tiles[c.key] = new br(c, this.tileSize), this._lastTilesetChange = fe.now());
            for (const c in this._tiles) s[c] || delete this._tiles[c]
          }
          freeRtt(e) {
            for (const r in this._tiles) {
              const s = this._tiles[r];
              (!e || s.tileID.equals(e) || s.tileID.isChildOf(e) || e.isChildOf(s.tileID)) && (s.rtt = [])
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map((e => this.getTileByID(e)))
          }
          getTileByID(e) {
            return this._tiles[e]
          }
          getTerrainCoords(e, r) {
            return r ? this._getTerrainCoordsForTileRanges(e, r) : this._getTerrainCoordsForRegularTile(e)
          }
          _getTerrainCoordsForRegularTile(e) {
            const r = {};
            for (const s of this._renderableTilesKeys) {
              const c = this._tiles[s].tileID,
                d = e.clone(),
                m = o.b9();
              if (c.canonical.equals(e.canonical)) o.bX(m, 0, o.$, o.$, 0, 0, 1);
              else if (c.canonical.isChildOf(e.canonical)) {
                const v = c.canonical.z - e.canonical.z,
                  w = c.canonical.x - (c.canonical.x >> v << v),
                  P = c.canonical.y - (c.canonical.y >> v << v),
                  M = o.$ >> v;
                o.bX(m, 0, M, M, 0, 0, 1), o.M(m, m, [-w * M, -P * M, 0])
              } else {
                if (!e.canonical.isChildOf(c.canonical)) continue;
                {
                  const v = e.canonical.z - c.canonical.z,
                    w = e.canonical.x - (e.canonical.x >> v << v),
                    P = e.canonical.y - (e.canonical.y >> v << v),
                    M = o.$ >> v;
                  o.bX(m, 0, o.$, o.$, 0, 0, 1), o.M(m, m, [w * M, P * M, 0]), o.N(m, m, [1 / 2 ** v, 1 / 2 ** v, 0])
                }
              }
              d.terrainRttPosMatrix32f = new Float32Array(m), r[s] = d
            }
            return r
          }
          _getTerrainCoordsForTileRanges(e, r) {
            const s = {};
            for (const c of this._renderableTilesKeys) {
              const d = this._tiles[c].tileID;
              if (!this._isWithinTileRanges(d, r)) continue;
              const m = e.clone(),
                v = o.b9();
              if (d.canonical.z === e.canonical.z) {
                const w = e.canonical.x - d.canonical.x,
                  P = e.canonical.y - d.canonical.y;
                o.bX(v, 0, o.$, o.$, 0, 0, 1), o.M(v, v, [w * o.$, P * o.$, 0])
              } else if (d.canonical.z > e.canonical.z) {
                const w = d.canonical.z - e.canonical.z,
                  P = d.canonical.x - (d.canonical.x >> w << w),
                  M = d.canonical.y - (d.canonical.y >> w << w),
                  D = e.canonical.x - (d.canonical.x >> w),
                  L = e.canonical.y - (d.canonical.y >> w),
                  B = o.$ >> w;
                o.bX(v, 0, B, B, 0, 0, 1), o.M(v, v, [-P * B + D * o.$, -M * B + L * o.$, 0])
              } else {
                const w = e.canonical.z - d.canonical.z,
                  P = e.canonical.x - (e.canonical.x >> w << w),
                  M = e.canonical.y - (e.canonical.y >> w << w),
                  D = (e.canonical.x >> w) - d.canonical.x,
                  L = (e.canonical.y >> w) - d.canonical.y,
                  B = o.$ << w;
                o.bX(v, 0, B, B, 0, 0, 1), o.M(v, v, [P * o.$ + D * B, M * o.$ + L * B, 0])
              }
              m.terrainRttPosMatrix32f = new Float32Array(v), s[c] = m
            }
            return s
          }
          getSourceTile(e, r) {
            const s = this.sourceCache._source;
            let c = e.overscaledZ - this.deltaZoom;
            if (c > s.maxzoom && (c = s.maxzoom), c < s.minzoom) return null;
            this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(c).key);
            let d = this.sourceCache.getTileByID(this._sourceTileCache[e.key]);
            if ((!d || !d.dem) && r)
              for (; c >= s.minzoom && (!d || !d.dem);) d = this.sourceCache.getTileByID(e.scaledTo(c--).key);
            return d
          }
          anyTilesAfterTime(e = Date.now()) {
            return this._lastTilesetChange >= e
          }
          _isWithinTileRanges(e, r) {
            return r[e.canonical.z] && e.canonical.x >= r[e.canonical.z].minTileX && e.canonical.x <= r[e.canonical.z].maxTileX && e.canonical.y >= r[e.canonical.z].minTileY && e.canonical.y <= r[e.canonical.z].maxTileY
          }
        }
        class Ia {
          constructor(e, r, s) {
            this._meshCache = {}, this.painter = e, this.sourceCache = new vp(r), this.options = s, this.exaggeration = typeof s.exaggeration == "number" ? s.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024
          }
          getDEMElevation(e, r, s, c = o.$) {
            var d;
            if (!(r >= 0 && r < c && s >= 0 && s < c)) return 0;
            const m = this.getTerrainData(e),
              v = (d = m.tile) === null || d === void 0 ? void 0 : d.dem;
            if (!v) return 0;
            const w = o.cr([], [r / c * o.$, s / c * o.$], m.u_terrain_matrix),
              P = [w[0] * v.dim, w[1] * v.dim],
              M = Math.floor(P[0]),
              D = Math.floor(P[1]),
              L = P[0] - M,
              B = P[1] - D;
            return v.get(M, D) * (1 - L) * (1 - B) + v.get(M + 1, D) * L * (1 - B) + v.get(M, D + 1) * (1 - L) * B + v.get(M + 1, D + 1) * L * B
          }
          getElevationForLngLatZoom(e, r) {
            if (!o.cs(r, e.wrap())) return 0;
            const {
              tileID: s,
              mercatorX: c,
              mercatorY: d
            } = this._getOverscaledTileIDFromLngLatZoom(e, r);
            return this.getElevation(s, c % o.$, d % o.$, o.$)
          }
          getElevation(e, r, s, c = o.$) {
            return this.getDEMElevation(e, r, s, c) * this.exaggeration
          }
          getTerrainData(e) {
            if (!this._emptyDemTexture) {
              const c = this.painter.context,
                d = new o.R({
                  width: 1,
                  height: 1
                }, new Uint8Array(4));
              this._emptyDepthTexture = new o.T(c, d, c.gl.RGBA, {
                premultiply: !1
              }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new o.T(c, new o.R({
                width: 1,
                height: 1
              }), c.gl.RGBA, {
                premultiply: !1
              }), this._emptyDemTexture.bind(c.gl.NEAREST, c.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = o.af([])
            }
            const r = this.sourceCache.getSourceTile(e, !0);
            if (r && r.dem && (!r.demTexture || r.needsTerrainPrepare)) {
              const c = this.painter.context;
              r.demTexture = this.painter.getTileTexture(r.dem.stride), r.demTexture ? r.demTexture.update(r.dem.getPixels(), {
                premultiply: !1
              }) : r.demTexture = new o.T(c, r.dem.getPixels(), c.gl.RGBA, {
                premultiply: !1
              }), r.demTexture.bind(c.gl.NEAREST, c.gl.CLAMP_TO_EDGE), r.needsTerrainPrepare = !1
            }
            const s = r && r + r.tileID.key + e.key;
            if (s && !this._demMatrixCache[s]) {
              const c = this.sourceCache.sourceCache._source.maxzoom;
              let d = e.canonical.z - r.tileID.canonical.z;
              e.overscaledZ > e.canonical.z && (e.canonical.z >= c ? d = e.canonical.z - c : o.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const m = e.canonical.x - (e.canonical.x >> d << d),
                v = e.canonical.y - (e.canonical.y >> d << d),
                w = o.ct(new Float64Array(16), [1 / (o.$ << d), 1 / (o.$ << d), 0]);
              o.M(w, w, [m * o.$, v * o.$, 0]), this._demMatrixCache[e.key] = {
                matrix: w,
                coord: e
              }
            }
            return {
              u_depth: 2,
              u_terrain: 3,
              u_terrain_dim: r && r.dem && r.dem.dim || 1,
              u_terrain_matrix: s ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix,
              u_terrain_unpack: r && r.dem && r.dem.getUnpackVector() || this._emptyDemUnpack,
              u_terrain_exaggeration: this.exaggeration,
              texture: (r && r.demTexture || this._emptyDemTexture).texture,
              depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture,
              tile: r
            }
          }
          getFramebuffer(e) {
            const r = this.painter,
              s = r.width / devicePixelRatio,
              c = r.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === s && this._fbo.height === c || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new o.T(r.context, {
              width: s,
              height: c,
              data: null
            }, r.context.gl.RGBA, {
              premultiply: !1
            }), this._fboCoordsTexture.bind(r.context.gl.NEAREST, r.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new o.T(r.context, {
              width: s,
              height: c,
              data: null
            }, r.context.gl.RGBA, {
              premultiply: !1
            }), this._fboDepthTexture.bind(r.context.gl.NEAREST, r.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = r.context.createFramebuffer(s, c, !0, !1), this._fbo.depthAttachment.set(r.context.createRenderbuffer(r.context.gl.DEPTH_COMPONENT16, s, c))), this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo
          }
          getCoordsTexture() {
            const e = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const r = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let d = 0, m = 0; d < this._coordsTextureSize; d++)
              for (let v = 0; v < this._coordsTextureSize; v++, m += 4) r[m + 0] = 255 & v, r[m + 1] = 255 & d, r[m + 2] = v >> 8 << 4 | d >> 8, r[m + 3] = 0;
            const s = new o.R({
                width: this._coordsTextureSize,
                height: this._coordsTextureSize
              }, new Uint8Array(r.buffer)),
              c = new o.T(e, s, e.gl.RGBA, {
                premultiply: !1
              });
            return c.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = c, c
          }
          pointCoordinate(e) {
            this.painter.maybeDrawDepthAndCoords(!0);
            const r = new Uint8Array(4),
              s = this.painter.context,
              c = s.gl,
              d = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio),
              m = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio),
              v = Math.round(this.painter.height / devicePixelRatio);
            s.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), c.readPixels(d, v - m - 1, 1, 1, c.RGBA, c.UNSIGNED_BYTE, r), s.bindFramebuffer.set(null);
            const w = r[0] + (r[2] >> 4 << 8),
              P = r[1] + ((15 & r[2]) << 8),
              M = this.coordsIndex[255 - r[3]],
              D = M && this.sourceCache.getTileByID(M);
            if (!D) return null;
            const L = this._coordsTextureSize,
              B = (1 << D.tileID.canonical.z) * L;
            return new o.a0((D.tileID.canonical.x * L + w) / B + D.tileID.wrap, (D.tileID.canonical.y * L + P) / B, this.getElevation(D.tileID, w, P, L))
          }
          depthAtPoint(e) {
            const r = new Uint8Array(4),
              s = this.painter.context,
              c = s.gl;
            return s.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), c.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, c.RGBA, c.UNSIGNED_BYTE, r), s.bindFramebuffer.set(null), (r[0] / 16777216 + r[1] / 65536 + r[2] / 256 + r[3]) / 256
          }
          getTerrainMesh(e) {
            var r;
            const s = ((r = this.painter.style.projection) === null || r === void 0 ? void 0 : r.transitionState) > 0,
              c = s && e.canonical.y === 0,
              d = s && e.canonical.y === (1 << e.canonical.z) - 1,
              m = `m_${c?"n":""}_${d?"s":""}`;
            if (this._meshCache[m]) return this._meshCache[m];
            const v = this.painter.context,
              w = new o.cu,
              P = new o.aM,
              M = this.meshSize,
              D = o.$ / M,
              L = M * M;
            for (let pe = 0; pe <= M; pe++)
              for (let Fe = 0; Fe <= M; Fe++) w.emplaceBack(Fe * D, pe * D, 0);
            for (let pe = 0; pe < L; pe += M + 1)
              for (let Fe = 0; Fe < M; Fe++) P.emplaceBack(Fe + pe, M + Fe + pe + 1, M + Fe + pe + 2), P.emplaceBack(Fe + pe, M + Fe + pe + 2, Fe + pe + 1);
            const B = w.length,
              Z = B + (M + 1),
              te = (M + 1) * M,
              ee = c ? o.bg : 0,
              ne = c ? 0 : 1,
              oe = d ? o.bh : o.$,
              me = d ? 0 : 1;
            for (let pe = 0; pe <= M; pe++) w.emplaceBack(pe * D, ee, ne);
            for (let pe = 0; pe <= M; pe++) w.emplaceBack(pe * D, oe, me);
            for (let pe = 0; pe < M; pe++) P.emplaceBack(te + pe, Z + pe, Z + pe + 1), P.emplaceBack(te + pe, Z + pe + 1, te + pe + 1), P.emplaceBack(0 + pe, B + pe + 1, B + pe), P.emplaceBack(0 + pe, 0 + pe + 1, B + pe + 1);
            const ue = w.length,
              be = ue + 2 * (M + 1);
            for (const pe of [0, 1])
              for (let Fe = 0; Fe <= M; Fe++)
                for (const Je of [0, 1]) w.emplaceBack(pe * o.$, Fe * D, Je);
            for (let pe = 0; pe < 2 * M; pe += 2) P.emplaceBack(ue + pe, ue + pe + 1, ue + pe + 3), P.emplaceBack(ue + pe, ue + pe + 3, ue + pe + 2), P.emplaceBack(be + pe, be + pe + 3, be + pe + 1), P.emplaceBack(be + pe, be + pe + 2, be + pe + 3);
            const Pe = new Qn(v.createVertexBuffer(w, Jh.members), v.createIndexBuffer(P), o.aL.simpleSegment(0, 0, w.length, P.length));
            return this._meshCache[m] = Pe, Pe
          }
          getMeshFrameDelta(e) {
            return 2 * Math.PI * o.bt / Math.pow(2, Math.max(e, 0)) / 5
          }
          getMinTileElevationForLngLatZoom(e, r) {
            var s;
            const {
              tileID: c
            } = this._getOverscaledTileIDFromLngLatZoom(e, r);
            return (s = this.getMinMaxElevation(c).minElevation) !== null && s !== void 0 ? s : 0
          }
          getMinMaxElevation(e) {
            const r = this.getTerrainData(e).tile,
              s = {
                minElevation: null,
                maxElevation: null
              };
            return r && r.dem && (s.minElevation = r.dem.min * this.exaggeration, s.maxElevation = r.dem.max * this.exaggeration), s
          }
          _getOverscaledTileIDFromLngLatZoom(e, r) {
            const s = o.a0.fromLngLat(e.wrap()),
              c = (1 << r) * o.$,
              d = s.x * c,
              m = s.y * c,
              v = Math.floor(d / o.$),
              w = Math.floor(m / o.$);
            return {
              tileID: new o.Z(r, 0, r, v, w),
              mercatorX: d,
              mercatorY: m
            }
          }
        }
        class kl {
          constructor(e, r, s) {
            this._context = e, this._size = r, this._tileSize = s, this._objects = [], this._recentlyUsed = [], this._stamp = 0
          }
          destruct() {
            for (const e of this._objects) e.texture.destroy(), e.fbo.destroy()
          }
          _createObject(e) {
            const r = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0),
              s = new o.T(this._context, {
                width: this._tileSize,
                height: this._tileSize,
                data: null
              }, this._context.gl.RGBA);
            return s.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), r.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), r.colorAttachment.set(s.texture), {
              id: e,
              fbo: r,
              texture: s,
              stamp: -1,
              inUse: !1
            }
          }
          getObjectForId(e) {
            return this._objects[e]
          }
          useObject(e) {
            e.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter((r => e.id !== r)), this._recentlyUsed.push(e.id)
          }
          stampObject(e) {
            e.stamp = ++this._stamp
          }
          getOrCreateFreeObject() {
            for (const r of this._recentlyUsed)
              if (!this._objects[r].inUse) return this._objects[r];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const e = this._createObject(this._objects.length);
            return this._objects.push(e), e
          }
          freeObject(e) {
            e.inUse = !1
          }
          freeAllObjects() {
            for (const e of this._objects) this.freeObject(e)
          }
          isFull() {
            return !(this._objects.length < this._size) && this._objects.some((e => !e.inUse)) === !1
          }
        }
        const ar = {
          background: !0,
          fill: !0,
          line: !0,
          raster: !0,
          hillshade: !0,
          "color-relief": !0
        };
        class Lr {
          constructor(e, r) {
            this.painter = e, this.terrain = r, this.pool = new kl(e.context, 30, r.sourceCache.tileSize * r.qualityFactor)
          }
          destruct() {
            this.pool.destruct()
          }
          getTexture(e) {
            return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture
          }
          prepareForRender(e, r) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = e._order.filter((s => !e._layers[s].isHidden(r))), this._coordsAscending = {};
            for (const s in e.sourceCaches) {
              this._coordsAscending[s] = {};
              const c = e.sourceCaches[s].getVisibleCoordinates(),
                d = e.sourceCaches[s].getSource(),
                m = d instanceof Dt ? d.terrainTileRanges : null;
              for (const v of c) {
                const w = this.terrain.sourceCache.getTerrainCoords(v, m);
                for (const P in w) this._coordsAscending[s][P] || (this._coordsAscending[s][P] = []), this._coordsAscending[s][P].push(w[P])
              }
            }
            this._coordsAscendingStr = {};
            for (const s of e._order) {
              const c = e._layers[s],
                d = c.source;
              if (ar[c.type] && !this._coordsAscendingStr[d]) {
                this._coordsAscendingStr[d] = {};
                for (const m in this._coordsAscending[d]) this._coordsAscendingStr[d][m] = this._coordsAscending[d][m].map((v => v.key)).sort().join()
              }
            }
            for (const s of this._renderableTiles)
              for (const c in this._coordsAscendingStr) {
                const d = this._coordsAscendingStr[c][s.tileID.key];
                d && d !== s.rttCoords[c] && (s.rtt = [])
              }
          }
          renderLayer(e, r) {
            if (e.isHidden(this.painter.transform.zoom)) return !1;
            const s = Object.assign(Object.assign({}, r), {
                isRenderingToTexture: !0
              }),
              c = e.type,
              d = this.painter,
              m = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
            if (ar[c] && (this._prevType && ar[this._prevType] || this._stacks.push([]), this._prevType = c, this._stacks[this._stacks.length - 1].push(e.id), !m)) return !0;
            if (ar[this._prevType] || ar[c] && m) {
              this._prevType = c;
              const v = this._stacks.length - 1,
                w = this._stacks[v] || [];
              for (const P of this._renderableTiles) {
                if (this.pool.isFull() && ($i(this.painter, this.terrain, this._rttTiles, s), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(P), P.rtt[v]) {
                  const D = this.pool.getObjectForId(P.rtt[v].id);
                  if (D.stamp === P.rtt[v].stamp) {
                    this.pool.useObject(D);
                    continue
                  }
                }
                const M = this.pool.getOrCreateFreeObject();
                this.pool.useObject(M), this.pool.stampObject(M), P.rtt[v] = {
                  id: M.id,
                  stamp: M.stamp
                }, d.context.bindFramebuffer.set(M.fbo.framebuffer), d.context.clear({
                  color: o.be.transparent,
                  stencil: 0
                }), d.currentStencilSource = void 0;
                for (let D = 0; D < w.length; D++) {
                  const L = d.style._layers[w[D]],
                    B = L.source ? this._coordsAscending[L.source][P.tileID.key] : [P.tileID];
                  d.context.viewport.set([0, 0, M.fbo.width, M.fbo.height]), d._renderTileClippingMasks(L, B, !0), d.renderLayer(d, d.style.sourceCaches[L.source], L, B, s), L.source && (P.rttCoords[L.source] = this._coordsAscendingStr[L.source][P.tileID.key])
                }
              }
              return $i(this.painter, this.terrain, this._rttTiles, s), this._rttTiles = [], this.pool.freeAllObjects(), ar[c]
            }
            return !1
          }
        }
        const El = {
            "AttributionControl.ToggleAttribution": "Toggle attribution",
            "AttributionControl.MapFeedback": "Map feedback",
            "FullscreenControl.Enter": "Enter fullscreen",
            "FullscreenControl.Exit": "Exit fullscreen",
            "GeolocateControl.FindMyLocation": "Find my location",
            "GeolocateControl.LocationNotAvailable": "Location not available",
            "LogoControl.Title": "MapLibre logo",
            "Map.Title": "Map",
            "Marker.Title": "Map marker",
            "NavigationControl.ResetBearing": "Reset bearing to north",
            "NavigationControl.ZoomIn": "Zoom in",
            "NavigationControl.ZoomOut": "Zoom out",
            "Popup.Close": "Close popup",
            "ScaleControl.Feet": "ft",
            "ScaleControl.Meters": "m",
            "ScaleControl.Kilometers": "km",
            "ScaleControl.Miles": "mi",
            "ScaleControl.NauticalMiles": "nm",
            "GlobeControl.Enable": "Enable globe",
            "GlobeControl.Disable": "Disable globe",
            "TerrainControl.Enable": "Enable terrain",
            "TerrainControl.Disable": "Disable terrain",
            "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map",
            "CooperativeGesturesHandler.MacHelpText": "Use ⌘ + scroll to zoom the map",
            "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map"
          },
          Kc = K,
          Ro = {
            hash: !1,
            interactive: !0,
            bearingSnap: 7,
            attributionControl: Do,
            maplibreLogo: !1,
            refreshExpiredTiles: !0,
            canvasContextAttributes: {
              antialias: !1,
              preserveDrawingBuffer: !1,
              powerPreference: "high-performance",
              failIfMajorPerformanceCaveat: !1,
              desynchronized: !1,
              contextType: void 0
            },
            scrollZoom: !0,
            minZoom: -2,
            maxZoom: 22,
            minPitch: 0,
            maxPitch: 60,
            boxZoom: !0,
            dragRotate: !0,
            dragPan: !0,
            keyboard: !0,
            doubleClickZoom: !0,
            touchZoomRotate: !0,
            touchPitch: !0,
            cooperativeGestures: !1,
            trackResize: !0,
            center: [0, 0],
            elevation: 0,
            zoom: 0,
            bearing: 0,
            pitch: 0,
            roll: 0,
            renderWorldCopies: !0,
            maxTileCacheSize: null,
            maxTileCacheZoomLevels: o.a.MAX_TILE_CACHE_ZOOM_LEVELS,
            transformRequest: null,
            transformCameraUpdate: null,
            fadeDuration: 300,
            crossSourceCollisions: !0,
            clickTolerance: 3,
            localIdeographFontFamily: "sans-serif",
            pitchWithRotate: !0,
            rollEnabled: !1,
            validateStyle: !0,
            maxCanvasSize: [4096, 4096],
            cancelPendingTileRequestsWhileZooming: !0,
            centerClampedToGround: !0
          },
          Fn = {
            showCompass: !0,
            showZoom: !0,
            visualizePitch: !1,
            visualizeRoll: !0
          };
        class Qh {
          constructor(e, r, s = !1) {
            this.mousedown = d => {
              this.startMove(d, W.mousePos(this.element, d)), W.addEventListener(window, "mousemove", this.mousemove), W.addEventListener(window, "mouseup", this.mouseup)
            }, this.mousemove = d => {
              this.move(d, W.mousePos(this.element, d))
            }, this.mouseup = d => {
              this._rotatePitchHanlder.dragEnd(d), this.offTemp()
            }, this.touchstart = d => {
              d.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = W.touchPos(this.element, d.targetTouches)[0], this.startMove(d, this._startPos), W.addEventListener(window, "touchmove", this.touchmove, {
                passive: !1
              }), W.addEventListener(window, "touchend", this.touchend))
            }, this.touchmove = d => {
              d.targetTouches.length !== 1 ? this.reset() : (this._lastPos = W.touchPos(this.element, d.targetTouches)[0], this.move(d, this._lastPos))
            }, this.touchend = d => {
              d.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp()
            }, this.reset = () => {
              this._rotatePitchHanlder.reset(), delete this._startPos, delete this._lastPos, this.offTemp()
            }, this._clickTolerance = 10, this.element = r;
            const c = new pp;
            this._rotatePitchHanlder = new Hs({
              clickTolerance: 3,
              move: (d, m) => {
                const v = r.getBoundingClientRect(),
                  w = new o.P((v.bottom - v.top) / 2, (v.right - v.left) / 2);
                return {
                  bearingDelta: o.cm(new o.P(d.x, m.y), m, w),
                  pitchDelta: s ? -.5 * (m.y - d.y) : void 0
                }
              },
              moveStateManager: c,
              enable: !0,
              assignEvents: () => {}
            }), this.map = e, W.addEventListener(r, "mousedown", this.mousedown), W.addEventListener(r, "touchstart", this.touchstart, {
              passive: !1
            }), W.addEventListener(r, "touchcancel", this.reset)
          }
          startMove(e, r) {
            this._rotatePitchHanlder.dragStart(e, r), W.disableDrag()
          }
          move(e, r) {
            const s = this.map,
              {
                bearingDelta: c,
                pitchDelta: d
              } = this._rotatePitchHanlder.dragMove(e, r) || {};
            c && s.setBearing(s.getBearing() + c), d && s.setPitch(s.getPitch() + d)
          }
          off() {
            const e = this.element;
            W.removeEventListener(e, "mousedown", this.mousedown), W.removeEventListener(e, "touchstart", this.touchstart, {
              passive: !1
            }), W.removeEventListener(window, "touchmove", this.touchmove, {
              passive: !1
            }), W.removeEventListener(window, "touchend", this.touchend), W.removeEventListener(e, "touchcancel", this.reset), this.offTemp()
          }
          offTemp() {
            W.enableDrag(), W.removeEventListener(window, "mousemove", this.mousemove), W.removeEventListener(window, "mouseup", this.mouseup), W.removeEventListener(window, "touchmove", this.touchmove, {
              passive: !1
            }), W.removeEventListener(window, "touchend", this.touchend)
          }
        }
        let wn;

        function ed(h, e, r, s = !1) {
          if (s || !r.getCoveringTilesDetailsProvider().allowWorldCopies()) return h == null ? void 0 : h.wrap();
          const c = new o.S(h.lng, h.lat);
          if (h = new o.S(h.lng, h.lat), e) {
            const d = new o.S(h.lng - 360, h.lat),
              m = new o.S(h.lng + 360, h.lat),
              v = r.locationToScreenPoint(h).distSqr(e);
            r.locationToScreenPoint(d).distSqr(e) < v ? h = d : r.locationToScreenPoint(m).distSqr(e) < v && (h = m)
          }
          for (; Math.abs(h.lng - r.center.lng) > 180;) {
            const d = r.locationToScreenPoint(h);
            if (d.x >= 0 && d.y >= 0 && d.x <= r.width && d.y <= r.height) break;
            h.lng > r.center.lng ? h.lng -= 360 : h.lng += 360
          }
          return h.lng !== c.lng && r.isPointOnMapSurface(r.locationToScreenPoint(h)) ? h : c
        }
        const ms = {
          center: "translate(-50%,-50%)",
          top: "translate(-50%,0)",
          "top-left": "translate(0,0)",
          "top-right": "translate(-100%,0)",
          bottom: "translate(-50%,-100%)",
          "bottom-left": "translate(0,-100%)",
          "bottom-right": "translate(-100%,-100%)",
          left: "translate(0,-50%)",
          right: "translate(-100%,-50%)"
        };

        function ji(h, e, r) {
          const s = h.classList;
          for (const c in ms) s.remove(`maplibregl-${r}-anchor-${c}`);
          s.add(`maplibregl-${r}-anchor-${e}`)
        }
        class Ui extends o.E {
          constructor(e) {
            if (super(), this._onKeyPress = r => {
                const s = r.code,
                  c = r.charCode || r.keyCode;
                s !== "Space" && s !== "Enter" && c !== 32 && c !== 13 || this.togglePopup()
              }, this._onMapClick = r => {
                const s = r.originalEvent.target,
                  c = this._element;
                this._popup && (s === c || c.contains(s)) && this.togglePopup()
              }, this._update = r => {
                if (!this._map) return;
                const s = this._map.loaded() && !this._map.isMoving();
                ((r == null ? void 0 : r.type) === "terrain" || (r == null ? void 0 : r.type) === "render" && !s) && this._map.once("render", this._update), this._lngLat = ed(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
                let c = "";
                this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? c = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (c = `rotateZ(${this._rotation-this._map.getBearing()}deg)`);
                let d = "";
                this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? d = "rotateX(0deg)" : this._pitchAlignment === "map" && (d = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || r && r.type !== "moveend" || (this._pos = this._pos.round()), W.setTransform(this._element, `${ms[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${d} ${c}`), fe.frameAsync(new AbortController).then((() => {
                  this._updateOpacity(r && r.type === "moveend")
                })).catch((() => {}))
              }, this._onMove = r => {
                if (!this._isDragging) {
                  const s = this._clickTolerance || this._map._clickTolerance;
                  this._isDragging = r.point.dist(this._pointerdownPos) >= s
                }
                this._isDragging && (this._pos = r.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new o.l("dragstart"))), this.fire(new o.l("drag")))
              }, this._onUp = () => {
                this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new o.l("dragend")), this._state = "inactive"
              }, this._addDragHandler = r => {
                this._element.contains(r.originalEvent.target) && (r.preventDefault(), this._positionDelta = r.point.sub(this._pos).add(this._offset), this._pointerdownPos = r.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp))
              }, this._anchor = e && e.anchor || "center", this._color = e && e.color || "#3FB1CE", this._scale = e && e.scale || 1, this._draggable = e && e.draggable || !1, this._clickTolerance = e && e.clickTolerance || 0, this._subpixelPositioning = e && e.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = e && e.rotation || 0, this._rotationAlignment = e && e.rotationAlignment || "auto", this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment !== "auto" ? e.pitchAlignment : this._rotationAlignment, this.setOpacity(e == null ? void 0 : e.opacity, e == null ? void 0 : e.opacityWhenCovered), e && e.element) this._element = e.element, this._offset = o.P.convert(e && e.offset || [0, 0]);
            else {
              this._defaultMarker = !0, this._element = W.create("div");
              const r = W.createNS("http://www.w3.org/2000/svg", "svg"),
                s = 41,
                c = 27;
              r.setAttributeNS(null, "display", "block"), r.setAttributeNS(null, "height", `${s}px`), r.setAttributeNS(null, "width", `${c}px`), r.setAttributeNS(null, "viewBox", `0 0 ${c} ${s}`);
              const d = W.createNS("http://www.w3.org/2000/svg", "g");
              d.setAttributeNS(null, "stroke", "none"), d.setAttributeNS(null, "stroke-width", "1"), d.setAttributeNS(null, "fill", "none"), d.setAttributeNS(null, "fill-rule", "evenodd");
              const m = W.createNS("http://www.w3.org/2000/svg", "g");
              m.setAttributeNS(null, "fill-rule", "nonzero");
              const v = W.createNS("http://www.w3.org/2000/svg", "g");
              v.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), v.setAttributeNS(null, "fill", "#000000");
              const w = [{
                rx: "10.5",
                ry: "5.25002273"
              }, {
                rx: "10.5",
                ry: "5.25002273"
              }, {
                rx: "9.5",
                ry: "4.77275007"
              }, {
                rx: "8.5",
                ry: "4.29549936"
              }, {
                rx: "7.5",
                ry: "3.81822308"
              }, {
                rx: "6.5",
                ry: "3.34094679"
              }, {
                rx: "5.5",
                ry: "2.86367051"
              }, {
                rx: "4.5",
                ry: "2.38636864"
              }];
              for (const ne of w) {
                const oe = W.createNS("http://www.w3.org/2000/svg", "ellipse");
                oe.setAttributeNS(null, "opacity", "0.04"), oe.setAttributeNS(null, "cx", "10.5"), oe.setAttributeNS(null, "cy", "5.80029008"), oe.setAttributeNS(null, "rx", ne.rx), oe.setAttributeNS(null, "ry", ne.ry), v.appendChild(oe)
              }
              const P = W.createNS("http://www.w3.org/2000/svg", "g");
              P.setAttributeNS(null, "fill", this._color);
              const M = W.createNS("http://www.w3.org/2000/svg", "path");
              M.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), P.appendChild(M);
              const D = W.createNS("http://www.w3.org/2000/svg", "g");
              D.setAttributeNS(null, "opacity", "0.25"), D.setAttributeNS(null, "fill", "#000000");
              const L = W.createNS("http://www.w3.org/2000/svg", "path");
              L.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), D.appendChild(L);
              const B = W.createNS("http://www.w3.org/2000/svg", "g");
              B.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), B.setAttributeNS(null, "fill", "#FFFFFF");
              const Z = W.createNS("http://www.w3.org/2000/svg", "g");
              Z.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const te = W.createNS("http://www.w3.org/2000/svg", "circle");
              te.setAttributeNS(null, "fill", "#000000"), te.setAttributeNS(null, "opacity", "0.25"), te.setAttributeNS(null, "cx", "5.5"), te.setAttributeNS(null, "cy", "5.5"), te.setAttributeNS(null, "r", "5.4999962");
              const ee = W.createNS("http://www.w3.org/2000/svg", "circle");
              ee.setAttributeNS(null, "fill", "#FFFFFF"), ee.setAttributeNS(null, "cx", "5.5"), ee.setAttributeNS(null, "cy", "5.5"), ee.setAttributeNS(null, "r", "5.4999962"), Z.appendChild(te), Z.appendChild(ee), m.appendChild(v), m.appendChild(P), m.appendChild(D), m.appendChild(B), m.appendChild(Z), r.appendChild(m), r.setAttributeNS(null, "height", s * this._scale + "px"), r.setAttributeNS(null, "width", c * this._scale + "px"), this._element.appendChild(r), this._offset = o.P.convert(e && e.offset || [0, -14])
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (r => {
                r.preventDefault()
              })), this._element.addEventListener("mousedown", (r => {
                r.preventDefault()
              })), ji(this._element, this._anchor, "marker"), e && e.className)
              for (const r of e.className.split(" ")) this._element.classList.add(r);
            this._popup = null
          }
          addTo(e) {
            return this.remove(), this._map = e, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e._getUIString("Marker.Title")), e.getCanvasContainer().appendChild(this._element), e.on("move", this._update), e.on("moveend", this._update), e.on("terrain", this._update), e.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), W.remove(this._element), this._popup && this._popup.remove(), this
          }
          getLngLat() {
            return this._lngLat
          }
          setLngLat(e) {
            return this._lngLat = o.S.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this
          }
          getElement() {
            return this._element
          }
          setPopup(e) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
              if (!("offset" in e.options)) {
                const c = Math.abs(13.5) / Math.SQRT2;
                e.options.offset = this._defaultMarker ? {
                  top: [0, 0],
                  "top-left": [0, 0],
                  "top-right": [0, 0],
                  bottom: [0, -38.1],
                  "bottom-left": [c, -1 * (38.1 - 13.5 + c)],
                  "bottom-right": [-c, -1 * (38.1 - 13.5 + c)],
                  left: [13.5, -1 * (38.1 - 13.5)],
                  right: [-13.5, -1 * (38.1 - 13.5)]
                } : this._offset
              }
              this._popup = e, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress)
            }
            return this
          }
          setSubpixelPositioning(e) {
            return this._subpixelPositioning = e, this
          }
          getPopup() {
            return this._popup
          }
          togglePopup() {
            const e = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : e ? (e.isOpen() ? e.remove() : (e.setLngLat(this._lngLat), e.addTo(this._map)), this) : this
          }
          _updateOpacity(e = !1) {
            var r, s;
            const c = (r = this._map) === null || r === void 0 ? void 0 : r.terrain,
              d = this._map.transform.isLocationOccluded(this._lngLat);
            if (!c || d) {
              const B = d ? this._opacityWhenCovered : this._opacity;
              return void(this._element.style.opacity !== B && (this._element.style.opacity = B))
            }
            if (e) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout((() => {
                this._opacityTimeout = null
              }), 100)
            }
            const m = this._map,
              v = m.terrain.depthAtPoint(this._pos),
              w = m.terrain.getElevationForLngLatZoom(this._lngLat, m.transform.tileZoom);
            if (m.transform.lngLatToCameraDepth(this._lngLat, w) - v < .006) return void(this._element.style.opacity = this._opacity);
            const P = -this._offset.y / m.transform.pixelsPerMeter,
              M = Math.sin(m.getPitch() * Math.PI / 180) * P,
              D = m.terrain.depthAtPoint(new o.P(this._pos.x, this._pos.y - this._offset.y)),
              L = m.transform.lngLatToCameraDepth(this._lngLat, w + M) - D > .006;
            !((s = this._popup) === null || s === void 0) && s.isOpen() && L && this._popup.remove(), this._element.style.opacity = L ? this._opacityWhenCovered : this._opacity
          }
          getOffset() {
            return this._offset
          }
          setOffset(e) {
            return this._offset = o.P.convert(e), this._update(), this
          }
          addClassName(e) {
            this._element.classList.add(e)
          }
          removeClassName(e) {
            this._element.classList.remove(e)
          }
          toggleClassName(e) {
            return this._element.classList.toggle(e)
          }
          setDraggable(e) {
            return this._draggable = !!e, this._map && (e ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this
          }
          isDraggable() {
            return this._draggable
          }
          setRotation(e) {
            return this._rotation = e || 0, this._update(), this
          }
          getRotation() {
            return this._rotation
          }
          setRotationAlignment(e) {
            return this._rotationAlignment = e || "auto", this._update(), this
          }
          getRotationAlignment() {
            return this._rotationAlignment
          }
          setPitchAlignment(e) {
            return this._pitchAlignment = e && e !== "auto" ? e : this._rotationAlignment, this._update(), this
          }
          getPitchAlignment() {
            return this._pitchAlignment
          }
          setOpacity(e, r) {
            return (this._opacity === void 0 || e === void 0 && r === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), e !== void 0 && (this._opacity = e), r !== void 0 && (this._opacityWhenCovered = r), this._map && this._updateOpacity(!0), this
          }
        }
        const td = {
          positionOptions: {
            enableHighAccuracy: !1,
            maximumAge: 0,
            timeout: 6e3
          },
          fitBoundsOptions: {
            maxZoom: 15
          },
          trackUserLocation: !1,
          showAccuracyCircle: !0,
          showUserLocation: !0
        };
        let Ka = 0,
          Ya = !1;
        const Yc = {
          maxWidth: 100,
          unit: "metric"
        };

        function zl(h, e, r) {
          const s = r && r.maxWidth || 100,
            c = h._container.clientHeight / 2,
            d = h._container.clientWidth / 2,
            m = h.unproject([d - s / 2, c]),
            v = h.unproject([d + s / 2, c]),
            w = Math.round(h.project(v).x - h.project(m).x),
            P = Math.min(s, w, h._container.clientWidth),
            M = m.distanceTo(v);
          if (r && r.unit === "imperial") {
            const D = 3.2808 * M;
            D > 5280 ? _s(e, P, D / 5280, h._getUIString("ScaleControl.Miles")) : _s(e, P, D, h._getUIString("ScaleControl.Feet"))
          } else r && r.unit === "nautical" ? _s(e, P, M / 1852, h._getUIString("ScaleControl.NauticalMiles")) : M >= 1e3 ? _s(e, P, M / 1e3, h._getUIString("ScaleControl.Kilometers")) : _s(e, P, M, h._getUIString("ScaleControl.Meters"))
        }

        function _s(h, e, r, s) {
          const c = (function(d) {
            const m = Math.pow(10, `${Math.floor(d)}`.length - 1);
            let v = d / m;
            return v = v >= 10 ? 10 : v >= 5 ? 5 : v >= 3 ? 3 : v >= 2 ? 2 : v >= 1 ? 1 : (function(w) {
              const P = Math.pow(10, Math.ceil(-Math.log(w) / Math.LN10));
              return Math.round(w * P) / P
            })(v), m * v
          })(r);
          h.style.width = e * (c / r) + "px", h.innerHTML = `${c}&nbsp;${s}`
        }
        const Bo = {
            closeButton: !0,
            closeOnClick: !0,
            focusAfterOpen: !0,
            className: "",
            maxWidth: "240px",
            subpixelPositioning: !1,
            locationOccludedOpacity: void 0
          },
          Jc = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");

        function Ll(h) {
          if (h) {
            if (typeof h == "number") {
              const e = Math.round(Math.abs(h) / Math.SQRT2);
              return {
                center: new o.P(0, 0),
                top: new o.P(0, h),
                "top-left": new o.P(e, e),
                "top-right": new o.P(-e, e),
                bottom: new o.P(0, -h),
                "bottom-left": new o.P(e, -e),
                "bottom-right": new o.P(-e, -e),
                left: new o.P(h, 0),
                right: new o.P(-h, 0)
              }
            }
            if (h instanceof o.P || Array.isArray(h)) {
              const e = o.P.convert(h);
              return {
                center: e,
                top: e,
                "top-left": e,
                "top-right": e,
                bottom: e,
                "bottom-left": e,
                "bottom-right": e,
                left: e,
                right: e
              }
            }
            return {
              center: o.P.convert(h.center || [0, 0]),
              top: o.P.convert(h.top || [0, 0]),
              "top-left": o.P.convert(h["top-left"] || [0, 0]),
              "top-right": o.P.convert(h["top-right"] || [0, 0]),
              bottom: o.P.convert(h.bottom || [0, 0]),
              "bottom-left": o.P.convert(h["bottom-left"] || [0, 0]),
              "bottom-right": o.P.convert(h["bottom-right"] || [0, 0]),
              left: o.P.convert(h.left || [0, 0]),
              right: o.P.convert(h.right || [0, 0])
            }
          }
          return Ll(new o.P(0, 0))
        }
        const Qc = K;
        C.AJAXError = o.cy, C.Event = o.l, C.Evented = o.E, C.LngLat = o.S, C.MercatorCoordinate = o.a0, C.Point = o.P, C.addProtocol = o.cz, C.config = o.a, C.removeProtocol = o.cA, C.AttributionControl = Al, C.BoxZoomHandler = jc, C.CanvasSource = Tr, C.CooperativeGesturesHandler = Kh, C.DoubleClickZoomHandler = Il, C.DragPanHandler = Gc, C.DragRotateHandler = Ml, C.EdgeInsets = Vn, C.FullscreenControl = class extends o.E {
          constructor(h = {}) {
            super(), this._onFullscreenChange = () => {
              var e;
              let r = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; !((e = r == null ? void 0 : r.shadowRoot) === null || e === void 0) && e.fullscreenElement;) r = r.shadowRoot.fullscreenElement;
              r === this._container !== this._fullscreen && this._handleFullscreenChange()
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen()
            }, this._fullscreen = !1, h && h.container && (h.container instanceof HTMLElement ? this._container = h.container : o.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange")
          }
          onAdd(h) {
            return this._map = h, this._container || (this._container = this._map.getContainer()), this._controlContainer = W.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer
          }
          onRemove() {
            W.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange)
          }
          _setupUI() {
            const h = this._fullscreenButton = W.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            W.create("span", "maplibregl-ctrl-icon", h).setAttribute("aria-hidden", "true"), h.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange)
          }
          _updateTitle() {
            const h = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", h), this._fullscreenButton.title = h
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter")
          }
          _isFullscreen() {
            return this._fullscreen
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new o.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new o.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable())
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen()
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen()
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize()
          }
        }, C.GeoJSONSource = er, C.GeolocateControl = class extends o.E {
          constructor(h) {
            super(), this._onSuccess = e => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new o.l("outofmaxbounds", e)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`)
                }
                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new o.l("geolocate", e)), this._finish()
              }
            }, this._updateCamera = e => {
              const r = new o.S(e.coords.longitude, e.coords.latitude),
                s = e.coords.accuracy,
                c = this._map.getBearing(),
                d = o.e({
                  bearing: c
                }, this.options.fitBoundsOptions),
                m = Lt.fromLngLat(r, s);
              this._map.fitBounds(m, d, {
                geolocateSource: !0
              })
            }, this._updateMarker = e => {
              if (e) {
                const r = new o.S(e.coords.longitude, e.coords.latitude);
                this._accuracyCircleMarker.setLngLat(r).addTo(this._map), this._userLocationDotMarker.setLngLat(r).addTo(this._map), this._accuracy = e.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove()
            }, this._onZoom = () => {
              this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
            }, this._onError = e => {
              if (this._map) {
                if (e.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                  const r = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = r, this._geolocateButton.setAttribute("aria-label", r), this._geolocationWatchID !== void 0 && this._clearWatch()
                } else {
                  if (e.code === 3 && Ya) return;
                  this.options.trackUserLocation && this._setErrorState()
                }
                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new o.l("error", e)), this._finish()
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0
            }, this._setupUI = () => {
              this._map && (this._container.addEventListener("contextmenu", (e => e.preventDefault())), this._geolocateButton = W.create("button", "maplibregl-ctrl-geolocate", this._container), W.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0)
            }, this._finishSetupUI = e => {
              if (this._map) {
                if (e === !1) {
                  o.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const r = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = !0, this._geolocateButton.title = r, this._geolocateButton.setAttribute("aria-label", r)
                } else {
                  const r = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.disabled = !1, this._geolocateButton.title = r, this._geolocateButton.setAttribute("aria-label", r)
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = W.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new Ui({
                  element: this._dotElement
                }), this._circleElement = W.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Ui({
                  element: this._circleElement,
                  pitchAlignment: "map"
                }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", (() => this.trigger())), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (r => {
                  r.geolocateSource || this._watchState !== "ACTIVE_LOCK" || r.originalEvent && r.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new o.l("trackuserlocationend")), this.fire(new o.l("userlocationlostfocus")))
                }))
              }
            }, this.options = o.e({}, td, h)
          }
          onAdd(h) {
            return this._map = h, this._container = W.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), (function() {
              return o._(this, arguments, void 0, (function*(e = !1) {
                if (wn !== void 0 && !e) return wn;
                if (window.navigator.permissions === void 0) return wn = !!window.navigator.geolocation, wn;
                try {
                  wn = (yield window.navigator.permissions.query({
                    name: "geolocation"
                  })).state !== "denied"
                } catch {
                  wn = !!window.navigator.geolocation
                }
                return wn
              }))
            })().then((e => this._finishSetupUI(e))), this._container
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), W.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Ka = 0, Ya = !1
          }
          _isOutOfMapMaxBounds(h) {
            const e = this._map.getMaxBounds(),
              r = h.coords;
            return e && (r.longitude < e.getWest() || r.longitude > e.getEast() || r.latitude < e.getSouth() || r.latitude > e.getNorth())
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`)
            }
          }
          _updateCircleRadius() {
            const h = this._map.getBounds(),
              e = h.getSouthEast(),
              r = h.getNorthEast(),
              s = e.distanceTo(r),
              c = Math.ceil(this._accuracy / (s / this._map._container.clientHeight) * 2);
            this._circleElement.style.width = `${c}px`, this._circleElement.style.height = `${c}px`
          }
          trigger() {
            if (!this._setup) return o.w("Geolocate control triggered before added to a map"), !1;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new o.l("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  Ka--, Ya = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new o.l("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new o.l("trackuserlocationstart")), this.fire(new o.l("userlocationfocus"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`)
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`)
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let h;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Ka++, Ka > 1 ? (h = {
                  maximumAge: 6e5,
                  timeout: 0
                }, Ya = !0) : (h = this.options.positionOptions, Ya = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, h)
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return !0
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null)
          }
        }, C.GlobeControl = class {
          constructor() {
            this._toggleProjection = () => {
              var h;
              const e = (h = this._map.getProjection()) === null || h === void 0 ? void 0 : h.type;
              this._map.setProjection(e !== "mercator" && e ? {
                type: "mercator"
              } : {
                type: "globe"
              }), this._updateGlobeIcon()
            }, this._updateGlobeIcon = () => {
              var h;
              this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((h = this._map.getProjection()) === null || h === void 0 ? void 0 : h.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"))
            }
          }
          onAdd(h) {
            return this._map = h, this._container = W.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = W.create("button", "maplibregl-ctrl-globe", this._container), W.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container
          }
          onRemove() {
            W.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0
          }
        }, C.Hash = Mo, C.ImageSource = Dt, C.KeyboardHandler = Ks, C.LngLatBounds = Lt, C.LogoControl = Xc, C.Map = class extends Bi {
          constructor(h) {
            var e, r;
            o.cv.mark(o.cw.create);
            const s = Object.assign(Object.assign(Object.assign({}, Ro), h), {
              canvasContextAttributes: Object.assign(Object.assign({}, Ro.canvasContextAttributes), h.canvasContextAttributes)
            });
            if (s.minZoom != null && s.maxZoom != null && s.minZoom > s.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (s.minPitch != null && s.maxPitch != null && s.minPitch > s.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (s.minPitch != null && s.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (s.maxPitch != null && s.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
            const c = new Oi,
              d = new rl;
            if (s.minZoom !== void 0 && c.setMinZoom(s.minZoom), s.maxZoom !== void 0 && c.setMaxZoom(s.maxZoom), s.minPitch !== void 0 && c.setMinPitch(s.minPitch), s.maxPitch !== void 0 && c.setMaxPitch(s.maxPitch), s.renderWorldCopies !== void 0 && c.setRenderWorldCopies(s.renderWorldCopies), super(c, d, {
                bearingSnap: s.bearingSnap
              }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new Yh, this._controls = [], this._mapId = o.a6(), this._contextLost = v => {
                v.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new o.l("webglcontextlost", {
                  originalEvent: v
                }))
              }, this._contextRestored = v => {
                this._setupPainter(), this.resize(), this._update(), this.fire(new o.l("webglcontextrestored", {
                  originalEvent: v
                }))
              }, this._onMapScroll = v => {
                if (v.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1
              }, this._onWindowOnline = () => {
                this._update()
              }, this._interactive = s.interactive, this._maxTileCacheSize = s.maxTileCacheSize, this._maxTileCacheZoomLevels = s.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, s.canvasContextAttributes), this._trackResize = s.trackResize === !0, this._bearingSnap = s.bearingSnap, this._centerClampedToGround = s.centerClampedToGround, this._refreshExpiredTiles = s.refreshExpiredTiles === !0, this._fadeDuration = s.fadeDuration, this._crossSourceCollisions = s.crossSourceCollisions === !0, this._collectResourceTiming = s.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, El), s.locale), this._clickTolerance = s.clickTolerance, this._overridePixelRatio = s.pixelRatio, this._maxCanvasSize = s.maxCanvasSize, this.transformCameraUpdate = s.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = s.cancelPendingTileRequestsWhileZooming === !0, this._imageQueueHandle = Ve.addThrottleControl((() => this.isMoving())), this._requestManager = new ct(s.transformRequest), typeof s.container == "string") {
              if (this._container = document.getElementById(s.container), !this._container) throw new Error(`Container '${s.container}' not found.`)
            } else {
              if (!(s.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = s.container
            }
            if (s.maxBounds && this.setMaxBounds(s.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", (() => this._update(!1))), this.on("moveend", (() => this._update(!1))), this.on("zoom", (() => this._update(!0))), this.on("terrain", (() => {
                this.painter.terrainFacilitator.dirty = !0, this._update(!0)
              })), this.once("idle", (() => {
                this._idleTriggered = !0
              })), typeof window < "u") {
              addEventListener("online", this._onWindowOnline, !1);
              let v = !1;
              const w = wl((P => {
                this._trackResize && !this._removed && (this.resize(P), this.redraw())
              }), 50);
              this._resizeObserver = new ResizeObserver((P => {
                v ? w(P) : v = !0
              })), this._resizeObserver.observe(this._container)
            }
            this.handlers = new Xa(this, s), this._hash = s.hash && new Mo(typeof s.hash == "string" && s.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({
              center: s.center,
              elevation: s.elevation,
              zoom: s.zoom,
              bearing: s.bearing,
              pitch: s.pitch,
              roll: s.roll
            }), s.bounds && (this.resize(), this.fitBounds(s.bounds, o.e({}, s.fitBoundsOptions, {
              duration: 0
            }))));
            const m = typeof s.style == "string" || ((r = (e = s.style) === null || e === void 0 ? void 0 : e.projection) === null || r === void 0 ? void 0 : r.type) !== "globe";
            this.resize(null, m), this._localIdeographFontFamily = s.localIdeographFontFamily, this._validateStyle = s.validateStyle, s.style && this.setStyle(s.style, {
              localIdeographFontFamily: s.localIdeographFontFamily
            }), s.attributionControl && this.addControl(new Al(typeof s.attributionControl == "boolean" ? void 0 : s.attributionControl)), s.maplibreLogo && this.addControl(new Xc, s.logoPosition), this.on("style.load", (() => {
              if (m || this._resizeTransform(), this.transform.unmodified) {
                const v = o.Q(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                this.jumpTo(v)
              }
            })), this.on("data", (v => {
              this._update(v.dataType === "style"), this.fire(new o.l(`${v.dataType}data`, v))
            })), this.on("dataloading", (v => {
              this.fire(new o.l(`${v.dataType}dataloading`, v))
            })), this.on("dataabort", (v => {
              this.fire(new o.l("sourcedataabort", v))
            }))
          }
          _getMapId() {
            return this._mapId
          }
          setGlobalStateProperty(h, e) {
            return this.style.setGlobalStateProperty(h, e), this._update(!0)
          }
          getGlobalState() {
            return this.style.getGlobalState()
          }
          addControl(h, e) {
            if (e === void 0 && (e = h.getDefaultPosition ? h.getDefaultPosition() : "top-right"), !h || !h.onAdd) return this.fire(new o.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const r = h.onAdd(this);
            this._controls.push(h);
            const s = this._controlPositions[e];
            return e.indexOf("bottom") !== -1 ? s.insertBefore(r, s.firstChild) : s.appendChild(r), this
          }
          removeControl(h) {
            if (!h || !h.onRemove) return this.fire(new o.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const e = this._controls.indexOf(h);
            return e > -1 && this._controls.splice(e, 1), h.onRemove(this), this
          }
          hasControl(h) {
            return this._controls.indexOf(h) > -1
          }
          calculateCameraOptionsFromTo(h, e, r, s) {
            return s == null && this.terrain && (s = this.terrain.getElevationForLngLatZoom(r, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(h, e, r, s)
          }
          resize(h, e = !0) {
            const [r, s] = this._containerDimensions(), c = this._getClampedPixelRatio(r, s);
            if (this._resizeCanvas(r, s, c), this.painter.resize(r, s, c), this.painter.overLimit()) {
              const m = this.painter.context.gl;
              this._maxCanvasSize = [m.drawingBufferWidth, m.drawingBufferHeight];
              const v = this._getClampedPixelRatio(r, s);
              this._resizeCanvas(r, s, v), this.painter.resize(r, s, v)
            }
            this._resizeTransform(e);
            const d = !this._moving;
            return d && (this.stop(), this.fire(new o.l("movestart", h)).fire(new o.l("move", h))), this.fire(new o.l("resize", h)), d && this.fire(new o.l("moveend", h)), this
          }
          _resizeTransform(h = !0) {
            var e;
            const [r, s] = this._containerDimensions();
            this.transform.resize(r, s, h), (e = this._requestedCameraState) === null || e === void 0 || e.resize(r, s, h)
          }
          _getClampedPixelRatio(h, e) {
            const {
              0: r,
              1: s
            } = this._maxCanvasSize, c = this.getPixelRatio(), d = h * c, m = e * c;
            return Math.min(d > r ? r / d : 1, m > s ? s / m : 1) * c
          }
          getPixelRatio() {
            var h;
            return (h = this._overridePixelRatio) !== null && h !== void 0 ? h : devicePixelRatio
          }
          setPixelRatio(h) {
            this._overridePixelRatio = h, this.resize()
          }
          getBounds() {
            return this.transform.getBounds()
          }
          getMaxBounds() {
            return this.transform.getMaxBounds()
          }
          setMaxBounds(h) {
            return this.transform.setMaxBounds(Lt.convert(h)), this._update()
          }
          setMinZoom(h) {
            if ((h = h ?? -2) >= -2 && h <= this.transform.maxZoom) return this.transform.setMinZoom(h), this._update(), this.getZoom() < h && this.setZoom(h), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive")
          }
          getMinZoom() {
            return this.transform.minZoom
          }
          setMaxZoom(h) {
            if ((h = h ?? 22) >= this.transform.minZoom) return this.transform.setMaxZoom(h), this._update(), this.getZoom() > h && this.setZoom(h), this;
            throw new Error("maxZoom must be greater than the current minZoom")
          }
          getMaxZoom() {
            return this.transform.maxZoom
          }
          setMinPitch(h) {
            if ((h = h ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (h >= 0 && h <= this.transform.maxPitch) return this.transform.setMinPitch(h), this._update(), this.getPitch() < h && this.setPitch(h), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive")
          }
          getMinPitch() {
            return this.transform.minPitch
          }
          setMaxPitch(h) {
            if ((h = h ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180");
            if (h >= this.transform.minPitch) return this.transform.setMaxPitch(h), this._update(), this.getPitch() > h && this.setPitch(h), this;
            throw new Error("maxPitch must be greater than the current minPitch")
          }
          getMaxPitch() {
            return this.transform.maxPitch
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies
          }
          setRenderWorldCopies(h) {
            return this.transform.setRenderWorldCopies(h), this._update()
          }
          project(h) {
            return this.transform.locationToScreenPoint(o.S.convert(h), this.style && this.terrain)
          }
          unproject(h) {
            return this.transform.screenPointToLocation(o.P.convert(h), this.terrain)
          }
          isMoving() {
            var h;
            return this._moving || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isMoving())
          }
          isZooming() {
            var h;
            return this._zooming || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isZooming())
          }
          isRotating() {
            var h;
            return this._rotating || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isRotating())
          }
          _createDelegatedListener(h, e, r) {
            if (h === "mouseenter" || h === "mouseover") {
              let s = !1;
              return {
                layers: e,
                listener: r,
                delegates: {
                  mousemove: d => {
                    const m = e.filter((w => this.getLayer(w))),
                      v = m.length !== 0 ? this.queryRenderedFeatures(d.point, {
                        layers: m
                      }) : [];
                    v.length ? s || (s = !0, r.call(this, new Gn(h, this, d.originalEvent, {
                      features: v
                    }))) : s = !1
                  },
                  mouseout: () => {
                    s = !1
                  }
                }
              }
            }
            if (h === "mouseleave" || h === "mouseout") {
              let s = !1;
              return {
                layers: e,
                listener: r,
                delegates: {
                  mousemove: m => {
                    const v = e.filter((w => this.getLayer(w)));
                    (v.length !== 0 ? this.queryRenderedFeatures(m.point, {
                      layers: v
                    }) : []).length ? s = !0 : s && (s = !1, r.call(this, new Gn(h, this, m.originalEvent)))
                  },
                  mouseout: m => {
                    s && (s = !1, r.call(this, new Gn(h, this, m.originalEvent)))
                  }
                }
              }
            } {
              const s = c => {
                const d = e.filter((v => this.getLayer(v))),
                  m = d.length !== 0 ? this.queryRenderedFeatures(c.point, {
                    layers: d
                  }) : [];
                m.length && (c.features = m, r.call(this, c), delete c.features)
              };
              return {
                layers: e,
                listener: r,
                delegates: {
                  [h]: s
                }
              }
            }
          }
          _saveDelegatedListener(h, e) {
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[h] = this._delegatedListeners[h] || [], this._delegatedListeners[h].push(e)
          }
          _removeDelegatedListener(h, e, r) {
            if (!this._delegatedListeners || !this._delegatedListeners[h]) return;
            const s = this._delegatedListeners[h];
            for (let c = 0; c < s.length; c++) {
              const d = s[c];
              if (d.listener === r && d.layers.length === e.length && d.layers.every((m => e.includes(m)))) {
                for (const m in d.delegates) this.off(m, d.delegates[m]);
                return void s.splice(c, 1)
              }
            }
          }
          on(h, e, r) {
            if (r === void 0) return super.on(h, e);
            const s = typeof e == "string" ? [e] : e,
              c = this._createDelegatedListener(h, s, r);
            this._saveDelegatedListener(h, c);
            for (const d in c.delegates) this.on(d, c.delegates[d]);
            return {
              unsubscribe: () => {
                this._removeDelegatedListener(h, s, r)
              }
            }
          }
          once(h, e, r) {
            if (r === void 0) return super.once(h, e);
            const s = typeof e == "string" ? [e] : e,
              c = this._createDelegatedListener(h, s, r);
            for (const d in c.delegates) {
              const m = c.delegates[d];
              c.delegates[d] = (...v) => {
                this._removeDelegatedListener(h, s, r), m(...v)
              }
            }
            this._saveDelegatedListener(h, c);
            for (const d in c.delegates) this.once(d, c.delegates[d]);
            return this
          }
          off(h, e, r) {
            return r === void 0 ? super.off(h, e) : (this._removeDelegatedListener(h, typeof e == "string" ? [e] : e, r), this)
          }
          queryRenderedFeatures(h, e) {
            if (!this.style) return [];
            let r;
            const s = h instanceof o.P || Array.isArray(h),
              c = s ? h : [
                [0, 0],
                [this.transform.width, this.transform.height]
              ];
            if (e = e || (s ? {} : h) || {}, c instanceof o.P || typeof c[0] == "number") r = [o.P.convert(c)];
            else {
              const d = o.P.convert(c[0]),
                m = o.P.convert(c[1]);
              r = [d, new o.P(m.x, d.y), m, new o.P(d.x, m.y), d]
            }
            return this.style.queryRenderedFeatures(r, e, this.transform)
          }
          querySourceFeatures(h, e) {
            return this.style.querySourceFeatures(h, e)
          }
          setStyle(h, e) {
            return (e = o.e({}, {
              localIdeographFontFamily: this._localIdeographFontFamily,
              validate: this._validateStyle
            }, e)).diff !== !1 && e.localIdeographFontFamily === this._localIdeographFontFamily && this.style && h ? (this._diffStyle(h, e), this) : (this._localIdeographFontFamily = e.localIdeographFontFamily, this._updateStyle(h, e))
          }
          setTransformRequest(h) {
            return this._requestManager.setTransformRequest(h), this
          }
          _getUIString(h) {
            const e = this._locale[h];
            if (e == null) throw new Error(`Missing UI string '${h}'`);
            return e
          }
          _updateStyle(h, e) {
            var r, s;
            if (e.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", (() => this._updateStyle(h, e)));
            const c = this.style && e.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!h)), h ? (this.style = new gc(this, e || {}), this.style.setEventedParent(this, {
              style: this.style
            }), typeof h == "string" ? this.style.loadURL(h, e, c) : this.style.loadJSON(h, e, c), this) : ((s = (r = this.style) === null || r === void 0 ? void 0 : r.projection) === null || s === void 0 || s.destroy(), delete this.style, this)
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new gc(this, {}), this.style.setEventedParent(this, {
              style: this.style
            }), this.style.loadEmpty())
          }
          _diffStyle(h, e) {
            if (typeof h == "string") {
              const r = this._requestManager.transformRequest(h, "Style");
              o.j(r, new AbortController).then((s => {
                this._updateDiff(s.data, e)
              })).catch((s => {
                s && this.fire(new o.k(s))
              }))
            } else typeof h == "object" && this._updateDiff(h, e)
          }
          _updateDiff(h, e) {
            try {
              this.style.setState(h, e) && this._update(!0)
            } catch (r) {
              o.w(`Unable to perform style diff: ${r.message||r.error||r}.  Rebuilding the style from scratch.`), this._updateStyle(h, e)
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize()
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : o.w("There is no style added to the map.")
          }
          addSource(h, e) {
            return this._lazyInitEmptyStyle(), this.style.addSource(h, e), this._update(!0)
          }
          isSourceLoaded(h) {
            const e = this.style && this.style.sourceCaches[h];
            if (e !== void 0) return e.loaded();
            this.fire(new o.k(new Error(`There is no source with ID '${h}'`)))
          }
          setTerrain(h) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), h) {
              const e = this.style.sourceCaches[h.source];
              if (!e) throw new Error(`cannot load terrain, because there exists no source with ID: ${h.source}`);
              this.terrain === null && e.reload();
              for (const r in this.style._layers) {
                const s = this.style._layers[r];
                s.type === "hillshade" && s.source === h.source && o.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), s.type === "color-relief" && s.source === h.source && o.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.")
              }
              this.terrain = new Ia(this.painter, e, h), this.painter.renderToTexture = new Lr(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = r => {
                var s;
                r.dataType === "style" ? this.terrain.sourceCache.freeRtt() : r.dataType === "source" && r.tile && (r.sourceId !== h.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), ((s = r.source) === null || s === void 0 ? void 0 : s.type) === "image" ? this.terrain.sourceCache.freeRtt() : this.terrain.sourceCache.freeRtt(r.tile.tileID))
              }, this.style.on("data", this._terrainDataCallback)
            } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
            return this.fire(new o.l("terrain", {
              terrain: h
            })), this
          }
          getTerrain() {
            var h, e;
            return (e = (h = this.terrain) === null || h === void 0 ? void 0 : h.options) !== null && e !== void 0 ? e : null
          }
          areTilesLoaded() {
            const h = this.style && this.style.sourceCaches;
            for (const e in h) {
              const r = h[e]._tiles;
              for (const s in r) {
                const c = r[s];
                if (c.state !== "loaded" && c.state !== "errored") return !1
              }
            }
            return !0
          }
          removeSource(h) {
            return this.style.removeSource(h), this._update(!0)
          }
          getSource(h) {
            return this.style.getSource(h)
          }
          setSourceTileLodParams(h, e, r) {
            if (r) {
              const s = this.getSource(r);
              if (!s) throw new Error(`There is no source with ID "${r}", cannot set LOD parameters`);
              s.calculateTileZoom = Ze(Math.max(1, h), Math.max(1, e))
            } else
              for (const s in this.style.sourceCaches) this.style.sourceCaches[s].getSource().calculateTileZoom = Ze(Math.max(1, h), Math.max(1, e));
            return this._update(!0), this
          }
          refreshTiles(h, e) {
            const r = this.style.sourceCaches[h];
            if (!r) throw new Error(`There is no source cache with ID "${h}", cannot refresh tile`);
            e === void 0 ? r.reload(!0) : r.refreshTiles(e.map((s => new o.a3(s.z, s.x, s.y))))
          }
          addImage(h, e, r = {}) {
            const {
              pixelRatio: s = 1,
              sdf: c = !1,
              stretchX: d,
              stretchY: m,
              content: v,
              textFitWidth: w,
              textFitHeight: P
            } = r;
            if (this._lazyInitEmptyStyle(), !(e instanceof HTMLImageElement || o.b(e))) {
              if (e.width === void 0 || e.height === void 0) return this.fire(new o.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const {
                  width: M,
                  height: D,
                  data: L
                } = e, B = e;
                return this.style.addImage(h, {
                  data: new o.R({
                    width: M,
                    height: D
                  }, new Uint8Array(L)),
                  pixelRatio: s,
                  stretchX: d,
                  stretchY: m,
                  content: v,
                  textFitWidth: w,
                  textFitHeight: P,
                  sdf: c,
                  version: 0,
                  userImage: B
                }), B.onAdd && B.onAdd(this, h), this
              }
            } {
              const {
                width: M,
                height: D,
                data: L
              } = fe.getImageData(e);
              this.style.addImage(h, {
                data: new o.R({
                  width: M,
                  height: D
                }, L),
                pixelRatio: s,
                stretchX: d,
                stretchY: m,
                content: v,
                textFitWidth: w,
                textFitHeight: P,
                sdf: c,
                version: 0
              })
            }
          }
          updateImage(h, e) {
            const r = this.style.getImage(h);
            if (!r) return this.fire(new o.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const s = e instanceof HTMLImageElement || o.b(e) ? fe.getImageData(e) : e,
              {
                width: c,
                height: d,
                data: m
              } = s;
            if (c === void 0 || d === void 0) return this.fire(new o.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (c !== r.data.width || d !== r.data.height) return this.fire(new o.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const v = !(e instanceof HTMLImageElement || o.b(e));
            return r.data.replace(m, v), this.style.updateImage(h, r), this
          }
          getImage(h) {
            return this.style.getImage(h)
          }
          hasImage(h) {
            return h ? !!this.style.getImage(h) : (this.fire(new o.k(new Error("Missing required image id"))), !1)
          }
          removeImage(h) {
            this.style.removeImage(h)
          }
          loadImage(h) {
            return Ve.getImage(this._requestManager.transformRequest(h, "Image"), new AbortController)
          }
          listImages() {
            return this.style.listImages()
          }
          addLayer(h, e) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(h, e), this._update(!0)
          }
          moveLayer(h, e) {
            return this.style.moveLayer(h, e), this._update(!0)
          }
          removeLayer(h) {
            return this.style.removeLayer(h), this._update(!0)
          }
          getLayer(h) {
            return this.style.getLayer(h)
          }
          getLayersOrder() {
            return this.style.getLayersOrder()
          }
          setLayerZoomRange(h, e, r) {
            return this.style.setLayerZoomRange(h, e, r), this._update(!0)
          }
          setFilter(h, e, r = {}) {
            return this.style.setFilter(h, e, r), this._update(!0)
          }
          getFilter(h) {
            return this.style.getFilter(h)
          }
          setPaintProperty(h, e, r, s = {}) {
            return this.style.setPaintProperty(h, e, r, s), this._update(!0)
          }
          getPaintProperty(h, e) {
            return this.style.getPaintProperty(h, e)
          }
          setLayoutProperty(h, e, r, s = {}) {
            return this.style.setLayoutProperty(h, e, r, s), this._update(!0)
          }
          getLayoutProperty(h, e) {
            return this.style.getLayoutProperty(h, e)
          }
          setGlyphs(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(h, e), this._update(!0)
          }
          getGlyphs() {
            return this.style.getGlyphsUrl()
          }
          addSprite(h, e, r = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(h, e, r, (s => {
              s || this._update(!0)
            })), this
          }
          removeSprite(h) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(h), this._update(!0)
          }
          getSprite() {
            return this.style.getSprite()
          }
          setSprite(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(h, e, (r => {
              r || this._update(!0)
            })), this
          }
          setLight(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(h, e), this._update(!0)
          }
          getLight() {
            return this.style.getLight()
          }
          setSky(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSky(h, e), this._update(!0)
          }
          getSky() {
            return this.style.getSky()
          }
          setFeatureState(h, e) {
            return this.style.setFeatureState(h, e), this._update()
          }
          removeFeatureState(h, e) {
            return this.style.removeFeatureState(h, e), this._update()
          }
          getFeatureState(h) {
            return this.style.getFeatureState(h)
          }
          getContainer() {
            return this._container
          }
          getCanvasContainer() {
            return this._canvasContainer
          }
          getCanvas() {
            return this._canvas
          }
          _containerDimensions() {
            let h = 0,
              e = 0;
            return this._container && (h = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [h, e]
          }
          _setupContainer() {
            const h = this._container;
            h.classList.add("maplibregl-map");
            const e = this._canvasContainer = W.create("div", "maplibregl-canvas-container", h);
            this._interactive && e.classList.add("maplibregl-interactive"), this._canvas = W.create("canvas", "maplibregl-canvas", e), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
            const r = this._containerDimensions(),
              s = this._getClampedPixelRatio(r[0], r[1]);
            this._resizeCanvas(r[0], r[1], s);
            const c = this._controlContainer = W.create("div", "maplibregl-control-container", h),
              d = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((m => {
              d[m] = W.create("div", `maplibregl-ctrl-${m} `, c)
            })), this._container.addEventListener("scroll", this._onMapScroll, !1)
          }
          _resizeCanvas(h, e, r) {
            this._canvas.width = Math.floor(r * h), this._canvas.height = Math.floor(r * e), this._canvas.style.width = `${h}px`, this._canvas.style.height = `${e}px`
          }
          _setupPainter() {
            const h = Object.assign(Object.assign({}, this._canvasContextAttributes), {
              alpha: !0,
              depth: !0,
              stencil: !0,
              premultipliedAlpha: !0
            });
            let e = null;
            this._canvas.addEventListener("webglcontextcreationerror", (s => {
              e = {
                requestedAttributes: h
              }, s && (e.statusMessage = s.statusMessage, e.type = s.type)
            }), {
              once: !0
            });
            let r = null;
            if (r = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, h) : this._canvas.getContext("webgl2", h) || this._canvas.getContext("webgl", h), !r) {
              const s = "Failed to initialize WebGL";
              throw e ? (e.message = s, new Error(JSON.stringify(e))) : new Error(s)
            }
            this.painter = new ca(r, this.transform), le.testSupport(r)
          }
          migrateProjection(h, e) {
            super.migrateProjection(h, e), this.painter.transform = h, this.fire(new o.l("projectiontransition", {
              newProjection: this.style.projection.name
            }))
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded()
          }
          _update(h) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || h, this._sourcesDirty = !0, this.triggerRepaint(), this) : this
          }
          _requestRenderFrame(h) {
            return this._update(), this._renderTaskQueue.add(h)
          }
          _cancelRenderFrame(h) {
            this._renderTaskQueue.remove(h)
          }
          _render(h) {
            var e, r, s, c, d;
            const m = this._idleTriggered ? this._fadeDuration : 0,
              v = ((e = this.style.projection) === null || e === void 0 ? void 0 : e.transitionState) > 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(h), this._removed) return;
            let w = !1;
            if (this.style && this._styleDirty) {
              this._styleDirty = !1;
              const D = this.transform.zoom,
                L = fe.now();
              this.style.zoomHistory.update(D, L);
              const B = new o.F(D, {
                  now: L,
                  fadeDuration: m,
                  zoomHistory: this.style.zoomHistory,
                  transition: this.style.getTransition(),
                  globalState: this.style.getGlobalState()
                }),
                Z = B.crossFadingFactor();
              Z === 1 && Z === this._crossFadingFactor || (w = !0, this._crossFadingFactor = Z), this.style.update(B)
            }
            const P = ((r = this.style.projection) === null || r === void 0 ? void 0 : r.transitionState) > 0 !== v;
            (s = this.style.projection) === null || s === void 0 || s.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((c = this.style.projection) === null || c === void 0 ? void 0 : c.transitionState, (d = this.style.projection) === null || d === void 0 ? void 0 : d.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || P) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, m, this._crossSourceCollisions, P), this.painter.render(this.style, {
              showTileBoundaries: this.showTileBoundaries,
              showOverdrawInspector: this._showOverdrawInspector,
              rotating: this.isRotating(),
              zooming: this.isZooming(),
              moving: this.isMoving(),
              fadeDuration: m,
              showPadding: this.showPadding
            }), this.fire(new o.l("render")), this.loaded() && !this._loaded && (this._loaded = !0, o.cv.mark(o.cw.load), this.fire(new o.l("load"))), this.style && (this.style.hasTransitions() || w) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const M = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return M || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new o.l("idle")), !this._loaded || this._fullyLoaded || M || (this._fullyLoaded = !0, o.cv.mark(o.cw.fullLoad)), this
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this
          }
          remove() {
            var h;
            this._hash && this._hash.remove();
            for (const r of this._controls) r.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), Ve.removeThrottleControl(this._imageQueueHandle), (h = this._resizeObserver) === null || h === void 0 || h.disconnect();
            const e = this.painter.context.gl.getExtension("WEBGL_lose_context");
            e != null && e.loseContext && e.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), W.remove(this._canvasContainer), W.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), o.cv.clearMetrics(), this._removed = !0, this.fire(new o.l("remove"))
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController, fe.frame(this._frameRequest, (h => {
              o.cv.frame(h), this._frameRequest = null;
              try {
                this._render(h)
              } catch (e) {
                if (!o.cx(e) && !(function(r) {
                    return r.message === zc
                  })(e)) throw e
              }
            }), (() => {})))
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries
          }
          set showTileBoundaries(h) {
            this._showTileBoundaries !== h && (this._showTileBoundaries = h, this._update())
          }
          get showPadding() {
            return !!this._showPadding
          }
          set showPadding(h) {
            this._showPadding !== h && (this._showPadding = h, this._update())
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes
          }
          set showCollisionBoxes(h) {
            this._showCollisionBoxes !== h && (this._showCollisionBoxes = h, h ? this.style._generateCollisionBoxes() : this._update())
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector
          }
          set showOverdrawInspector(h) {
            this._showOverdrawInspector !== h && (this._showOverdrawInspector = h, this._update())
          }
          get repaint() {
            return !!this._repaint
          }
          set repaint(h) {
            this._repaint !== h && (this._repaint = h, this.triggerRepaint())
          }
          get vertices() {
            return !!this._vertices
          }
          set vertices(h) {
            this._vertices = h, this._update()
          }
          get version() {
            return Kc
          }
          getCameraTargetElevation() {
            return this.transform.elevation
          }
          getProjection() {
            return this.style.getProjection()
          }
          setProjection(h) {
            return this._lazyInitEmptyStyle(), this.style.setProjection(h), this._update(!0)
          }
        }, C.MapMouseEvent = Gn, C.MapTouchEvent = ma, C.MapWheelEvent = Nc, C.Marker = Ui, C.NavigationControl = class {
          constructor(h) {
            this._updateZoomButtons = () => {
              const e = this._map.getZoom(),
                r = e === this._map.getMaxZoom(),
                s = e === this._map.getMinZoom();
              this._zoomInButton.disabled = r, this._zoomOutButton.disabled = s, this._zoomInButton.setAttribute("aria-disabled", r.toString()), this._zoomOutButton.setAttribute("aria-disabled", s.toString())
            }, this._rotateCompassArrow = () => {
              this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1/Math.pow(Math.cos(this._map.transform.pitchInRadians),.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1/Math.pow(Math.cos(this._map.transform.pitchInRadians),.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing-this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`
            }, this._setButtonTitle = (e, r) => {
              const s = this._map._getUIString(`NavigationControl.${r}`);
              e.title = s, e.setAttribute("aria-label", s)
            }, this.options = o.e({}, Fn, h), this._container = W.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (e => e.preventDefault())), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (e => this._map.zoomIn({}, {
              originalEvent: e
            }))), W.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (e => this._map.zoomOut({}, {
              originalEvent: e
            }))), W.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (e => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, {
                originalEvent: e
              }) : this._map.resetNorth({}, {
                originalEvent: e
              })
            })), this._compassIcon = W.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"))
          }
          onAdd(h) {
            return this._map = h, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Qh(this._map, this._compass, this.options.visualizePitch)), this._container
          }
          onRemove() {
            W.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map
          }
          _createButton(h, e) {
            const r = W.create("button", h, this._container);
            return r.type = "button", r.addEventListener("click", e), r
          }
        }, C.Popup = class extends o.E {
          constructor(h) {
            super(), this._updateOpacity = () => {
              this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "")
            }, this.remove = () => (this._content && W.remove(this._content), this._container && (W.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new o.l("close"))), this), this._onMouseUp = e => {
              this._update(e.point)
            }, this._onMouseMove = e => {
              this._update(e.point)
            }, this._onDrag = e => {
              this._update(e.point)
            }, this._update = e => {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = W.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = W.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className)
                  for (const m of this.options.className.split(" ")) this._container.classList.add(m);
                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer")
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = ed(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !e) return;
              const r = this._flatPos = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && e ? e : this._map.transform.locationToScreenPoint(this._lngLat));
              let s = this.options.anchor;
              const c = Ll(this.options.offset);
              if (!s) {
                const m = this._container.offsetWidth,
                  v = this._container.offsetHeight;
                let w;
                w = r.y + c.bottom.y < v ? ["top"] : r.y > this._map.transform.height - v ? ["bottom"] : [], r.x < m / 2 ? w.push("left") : r.x > this._map.transform.width - m / 2 && w.push("right"), s = w.length === 0 ? "bottom" : w.join("-")
              }
              let d = r.add(c[s]);
              this.options.subpixelPositioning || (d = d.round()), W.setTransform(this._container, `${ms[s]} translate(${d.x}px,${d.y}px)`), ji(this._container, s, "popup"), this._updateOpacity()
            }, this._onClose = () => {
              this.remove()
            }, this.options = o.e(Object.create(Bo), h)
          }
          addTo(h) {
            return this._map && this.remove(), this._map = h, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new o.l("open")), this
          }
          isOpen() {
            return !!this._map
          }
          getLngLat() {
            return this._lngLat
          }
          setLngLat(h) {
            return this._lngLat = o.S.convert(h), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this
          }
          trackPointer() {
            return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this
          }
          getElement() {
            return this._container
          }
          setText(h) {
            return this.setDOMContent(document.createTextNode(h))
          }
          setHTML(h) {
            const e = document.createDocumentFragment(),
              r = document.createElement("body");
            let s;
            for (r.innerHTML = h; s = r.firstChild, s;) e.appendChild(s);
            return this.setDOMContent(e)
          }
          getMaxWidth() {
            var h;
            return (h = this._container) === null || h === void 0 ? void 0 : h.style.maxWidth
          }
          setMaxWidth(h) {
            return this.options.maxWidth = h, this._update(), this
          }
          setDOMContent(h) {
            if (this._content)
              for (; this._content.hasChildNodes();) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = W.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(h), this._createCloseButton(), this._update(), this._focusFirstElement(), this
          }
          addClassName(h) {
            return this._container && this._container.classList.add(h), this
          }
          removeClassName(h) {
            return this._container && this._container.classList.remove(h), this
          }
          setOffset(h) {
            return this.options.offset = h, this._update(), this
          }
          toggleClassName(h) {
            if (this._container) return this._container.classList.toggle(h)
          }
          setSubpixelPositioning(h) {
            this.options.subpixelPositioning = h
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = W.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose))
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const h = this._container.querySelector(Jc);
            h && h.focus()
          }
        }, C.RasterDEMTileSource = Qt, C.RasterTileSource = ur, C.ScaleControl = class {
          constructor(h) {
            this._onMove = () => {
              zl(this._map, this._container, this.options)
            }, this.setUnit = e => {
              this.options.unit = e, zl(this._map, this._container, this.options)
            }, this.options = Object.assign(Object.assign({}, Yc), h)
          }
          getDefaultPosition() {
            return "bottom-left"
          }
          onAdd(h) {
            return this._map = h, this._container = W.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", h.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container
          }
          onRemove() {
            W.remove(this._container), this._map.off("move", this._onMove), this._map = void 0
          }
        }, C.ScrollZoomHandler = Xh, C.Style = gc, C.TerrainControl = class {
          constructor(h) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon()
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"))
            }, this.options = h
          }
          onAdd(h) {
            return this._map = h, this._container = W.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = W.create("button", "maplibregl-ctrl-terrain", this._container), W.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container
          }
          onRemove() {
            W.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0
          }
        }, C.TwoFingersTouchPitchHandler = Zc, C.TwoFingersTouchRotateHandler = Vc, C.TwoFingersTouchZoomHandler = Pa, C.TwoFingersTouchZoomRotateHandler = Hc, C.VectorTileSource = gr, C.VideoSource = Ir, C.addSourceType = (h, e) => o._(void 0, void 0, void 0, (function*() {
          if (Fr(h)) throw new Error(`A source type called "${h}" already exists.`);
          ((r, s) => {
            Dr[r] = s
          })(h, e)
        })), C.clearPrewarmedResources = function() {
          const h = tt;
          h && (h.isPreloaded() && h.numActive() === 1 ? (h.release(Ee), tt = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"))
        }, C.createTileMesh = fc, C.getMaxParallelImageRequests = function() {
          return o.a.MAX_PARALLEL_IMAGE_REQUESTS
        }, C.getRTLTextPluginStatus = function() {
          return tr().getRTLTextPluginStatus()
        }, C.getVersion = function() {
          return Qc
        }, C.getWorkerCount = function() {
          return Be.workerCount
        }, C.getWorkerUrl = function() {
          return o.a.WORKER_URL
        }, C.importScriptInWorkers = function(h) {
          return At().broadcast("IS", h)
        }, C.prewarm = function() {
          ft().acquire(Ee)
        }, C.setMaxParallelImageRequests = function(h) {
          o.a.MAX_PARALLEL_IMAGE_REQUESTS = h
        }, C.setRTLTextPlugin = function(h, e) {
          return tr().setRTLTextPlugin(h, e)
        }, C.setWorkerCount = function(h) {
          Be.workerCount = h
        }, C.setWorkerUrl = function(h) {
          o.a.WORKER_URL = h
        }
      }));
      var F = _;
      return F
    }))
  })(Sd)), Sd.exports
}
var dP = hP();
const bd = cm(dP);
class Mg {
  constructor(l) {
    fr(this, "gm");
    fr(this, "markers", new Map);
    fr(this, "canvases", new Map);
    fr(this, "canvasSize");
    fr(this, "canvasOpacity", .8);
    this.input = l, this.gm = new uc(this.input.tileSize);
    const _ = fv(l.img);
    this.canvasSize = Math.ceil(2e3 / _)
  }
  place([l, _]) {
    const T = this.gm.latLonToPixelsFloor(l, _, this.input.zoom),
      z = this.getMarkerId(T),
      F = this.gm.latLonToPixelBoundsLatLon(l, _, this.input.zoom),
      C = this.input.map;
    if (this.input.markerFn && !this.markers.has(z)) {
      const de = this.input.markerFn();
      de.setLngLat({
        lat: F.min[0],
        lng: (F.max[1] + F.min[1]) / 2
      }).addTo(C), this.markers.set(z, de)
    }
    const {
      key: o,
      pos: K,
      innerPos: G
    } = this.getCanvasPos(T);
    let ie = this.canvases.get(o);
    if (!ie) {
      const de = this.canvasSize,
        fe = K.x * de,
        W = K.y * de,
        le = fe + de - 1,
        Ce = W + de - 1,
        Me = this.gm.pixelsToLatLon(fe, Ce + 1, this.input.zoom),
        Le = this.gm.pixelsToLatLon(le + 1, W, this.input.zoom);
      ie = new pP({
        id: `${this.input.id}-${o}`,
        img: this.input.img,
        canvasSize: this.canvasSize,
        coordinates: om({
          min: Me,
          max: Le
        }),
        layerPaint: {
          "raster-resampling": "nearest",
          "raster-opacity": this.canvasOpacity
        }
      }), ie.addTo(this.input.map), this.canvases.set(o, ie)
    }
    ie.place(G.x, G.y)
  }
  clear() {
    const l = this.input.map;
    for (const _ of this.canvases.values()) _.removeFrom(l), _.removeDOM();
    this.canvases.clear();
    for (const _ of this.markers.values()) _.remove();
    this.markers.clear()
  }
  clearAndPlace(l) {
    this.clear(), this.place(l)
  }
  remove([l, _]) {
    let T = !1;
    const z = this.gm.latLonToPixelsFloor(l, _, this.input.zoom),
      {
        key: F,
        innerPos: C
      } = this.getCanvasPos(z),
      o = this.canvases.get(F);
    o && (T = o.remove(C.x, C.y), o.annotationsCount() === 0 && (this.canvases.delete(F), o.removeFrom(this.input.map), o.removeDOM()));
    const K = this.getMarkerId(z),
      G = this.markers.get(K);
    return G == null || G.remove(), this.markers.delete(K), T
  }
  setCanvasOpacity(l) {
    this.canvasOpacity = l;
    for (const _ of this.canvases.values()) _.setOpacity(l)
  }
  getMarkerId([l, _]) {
    return `${this.input.id}:${l},${_}`
  }
  getCanvasPos([l, _]) {
    const T = {
        x: Math.floor(l / this.canvasSize),
        y: Math.floor(_ / this.canvasSize)
      },
      z = {
        x: l % this.canvasSize,
        y: _ % this.canvasSize
      },
      F = `${T.x},${T.y}`;
    return {
      pos: T,
      innerPos: z,
      key: F
    }
  }
}
class pP {
  constructor(l) {
    fr(this, "annotations", new Set);
    fr(this, "canvas");
    fr(this, "imgSize");
    fr(this, "maps", new Set);
    this.input = l, this.imgSize = fv(l.img), this.canvas = document.createElement("canvas"), this.canvas.width = this.input.canvasSize * this.imgSize, this.canvas.height = this.input.canvasSize * this.imgSize
  }
  place(l, _) {
    const T = this.getPixelKey(l, _);
    if (this.annotations.has(T)) return !1;
    const z = this.canvas.getContext("2d");
    if (z) {
      const F = l * this.imgSize,
        C = _ * this.imgSize;
      z.drawImage(this.input.img, F, C)
    }
    return this.annotations.add(T), !0
  }
  remove(l, _) {
    const T = this.getPixelKey(l, _);
    if (!this.annotations.has(T)) return !1;
    const z = this.canvas.getContext("2d");
    if (z) {
      const F = l * this.imgSize,
        C = _ * this.imgSize;
      z.clearRect(F, C, this.imgSize, this.imgSize)
    }
    return this.annotations.delete(T), !0
  }
  addTo(l) {
    const _ = this.input.id;
    l.getSource(_) || l.addSource(_, {
      type: "canvas",
      canvas: this.canvas,
      coordinates: this.input.coordinates
    }), l.getLayer(_) || l.addLayer({
      id: _,
      type: "raster",
      source: _,
      paint: this.input.layerPaint
    }), this.maps.add(l)
  }
  removeFrom(l) {
    const {
      id: _
    } = this.input;
    l.getLayer(_) && l.removeLayer(_), l.getSource(_) && l.removeSource(_), this.maps.delete(l)
  }
  removeDOM() {
    this.canvas.remove()
  }
  annotationsCount() {
    return this.annotations.size
  }
  setOpacity(l) {
    for (const _ of this.maps.values()) _.setPaintProperty(this.input.id, "raster-opacity", l)
  }
  getPixelKey(l, _) {
    return `${l},${_}`
  }
}

function fv(y) {
  return Math.max(y.naturalWidth, y.naturalHeight)
}

function fP() {
  return window.matchMedia("(display-mode: standalone)").matches || "standalone" in window.navigator && window.navigator.standalone === !0
}

function mP(y) {
  const l = {
      opaque: !0
    },
    _ = y.searchParams.get("lat"),
    T = y.searchParams.get("lng");
  _ && T && (l.pos = {
    lat: parseFloat(_),
    lng: parseFloat(T)
  });
  const z = y.searchParams.get("zoom");
  z && (l.zoom = parseFloat(z));
  const F = y.searchParams.get("season");
  F && (l.season = parseInt(F));
  const C = y.searchParams.get("opaque");
  return C && (l.opaque = C !== "0"), y.searchParams.get("select") && (l.select = !0), l.newUser = !!y.searchParams.get("new-user"), l.alliance = !!y.searchParams.get("alliance"), l
}

function _P(y, l) {
  return y = new URL(y), l.pos !== void 0 && (y.searchParams.set("lat", l.pos.lat.toString()), y.searchParams.set("lng", l.pos.lng.toString())), l.zoom !== void 0 && y.searchParams.set("zoom", l.zoom.toString()), l.season !== void 0 && y.searchParams.set("season", l.season.toString()), l.opaque !== void 0 && y.searchParams.set("opaque", l.opaque ? "1" : "0"), l.newUser !== void 0 && y.searchParams.set("new-user", l.newUser ? "1" : "0"), l.alliance !== void 0 && y.searchParams.set("alliance", l.alliance ? "1" : "0"), l.select && y.searchParams.set("alliance", "1"), y
}
const Pd = En({
  shouldReload: !0
});
var gP = De('<legend class="fieldset-legend"> </legend>'),
  vP = De('<span class="text-base-content/80"> </span>'),
  yP = De('<fieldset class="fieldset"><!> <textarea></textarea> <div class="flex items-center justify-between text-xs"><span class="text-error"> </span> <!></div></fieldset>');

function xP(y, l) {
  kr(l, !0);
  let _ = It(l, "value", 15),
    T = It(l, "validate", 15),
    z = _t("");
  const F = vt(() => {
    var Me;
    return ((Me = _()) == null ? void 0 : Me.length) ?? 0
  });
  T(C);

  function C() {
    return l.min !== void 0 && b(F) < l.min ? (he(z, b(F) === 0 ? "Required" : `Min. characters: ${l.min}`, !0), !1) : l.max !== void 0 && b(F) > l.max ? (he(z, `Max. characters: ${l.max}`), !1) : !0
  }
  $r(() => {
    var Me;
    l.max !== void 0 && b(F) > l.max && _((Me = _()) == null ? void 0 : Me.substring(0, l.max))
  });
  var o = yP(),
    K = E(o);
  {
    var G = Me => {
      var Le = gP(),
        $e = E(Le, !0);
      A(Le), lt(() => Te($e, l.label)), H(Me, Le)
    };
    et(K, Me => {
      l.label && Me(G)
    })
  }
  var ie = $(K, 2);
  sx(ie);
  var de = $(ie, 2),
    fe = E(de),
    W = E(fe, !0);
  A(fe);
  var le = $(fe, 2);
  {
    var Ce = Me => {
      var Le = vP(),
        $e = E(Le, !0);
      A(Le), lt(() => Te($e, l.max - b(F))), H(Me, Le)
    };
    et(le, Me => {
      l.max !== void 0 && Me(Ce)
    })
  }
  A(de), A(o), lt(() => {
    Vr(ie, 1, `textarea w-full ${l.class??""}`), Br(ie, "placeholder", l.placeholder), Te(W, b(z))
  }), jd(ie, _), H(y, o), Er()
}
var bP = (y, l) => {
    var _;
    (_ = l()) == null || _.close()
  },
  wP = De('<dialog class="modal"><div class="modal-box max-w-2xl"><h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form><div class="mb-4 mt-2"><!></div> <div class="flex w-full justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-primary"> </button></div></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function TP(y, l) {
  kr(l, !0);
  let _ = It(l, "ref", 15),
    T = _t(!1),
    z = _t(En(l.description)),
    F = _t(void 0);
  Ii(() => {
    const $e = Oe => {
      var Ve;
      Oe.key === "Escape" && ((Ve = _()) == null || Ve.close())
    };
    return document.addEventListener("keydown", $e), () => document.removeEventListener("keydown", $e)
  });
  var C = wP(),
    o = E(C),
    K = E(o),
    G = E(K, !0);
  A(K);
  var ie = $(K, 2),
    de = E(ie),
    fe = E(de);
  {
    let $e = vt(() => lv());
    xP(fe, {
      class: "h-24 rounded-lg",
      get placeholder() {
        return b($e)
      },
      max: 512,
      get value() {
        return b(z)
      },
      set value(Oe) {
        he(z, Oe, !0)
      },
      get validate() {
        return b(F)
      },
      set validate(Oe) {
        he(F, Oe, !0)
      }
    })
  }
  A(de);
  var W = $(de, 2),
    le = E(W);
  le.__click = [bP, _];
  var Ce = E(le, !0);
  A(le);
  var Me = $(le, 2),
    Le = E(Me, !0);
  A(Me), A(W), A(ie), A(o), mi(2), A(C), Ss(C, $e => _($e), () => _()), lt(($e, Oe, Ve) => {
    Te(G, $e), le.disabled = b(T), Te(Ce, Oe), Me.disabled = b(T), Te(Le, Ve)
  }, [() => WT(), () => Jf(), () => YT()]), bn("submit", ie, async () => {
    var $e, Oe, Ve;
    try {
      if (!(($e = b(F)) != null && $e())) return;
      he(T, !0), l.description !== b(z) && await ci.updateAllianceDescription(b(z)), await ((Oe = l.onsuccess) == null ? void 0 : Oe.call(l, b(z))), (Ve = _()) == null || Ve.close()
    } catch (ct) {
      Zr.error(ct.message)
    } finally {
      he(T, !1)
    }
  }), H(y, C), Er()
}
en(["click"]);
var CP = (y, l, _) => {
    navigator.clipboard.writeText(b(l).toString()), he(_, !0), setTimeout(() => {
      he(_, !1)
    }, 1e3)
  },
  SP = De('<span class="loading loading-spinner loading-md center-absolute absolute"></span>'),
  PP = De('<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <span class="text-base-content/80 text-sm"> </span> <div class="relative mt-4"><div><input class="text-base-content/80 min-w-10 grow text-sm font-medium" readonly=""/> <div class="h-10"><button> </button></div></div> <!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function IP(y, l) {
  kr(l, !0);
  let _ = It(l, "open", 15),
    T = _t(""),
    z = _t(!1);
  const F = vt(() => Va.url.origin + `/join?id=${b(T)}`);
  $r(() => {
    _() && ci.getAllianceInvites().then(nt => {
      he(T, nt[0], !0)
    }).catch(nt => {
      Zr.error(nt.message)
    })
  }), Ii(() => {
    const nt = Ye => {
      Ye.key === "Escape" && _(!1)
    };
    return document.addEventListener("keydown", nt), () => document.removeEventListener("keydown", nt)
  });
  var C = PP(),
    o = E(C),
    K = $(E(o), 2),
    G = E(K, !0);
  A(K);
  var ie = $(K, 2),
    de = E(ie, !0);
  A(ie);
  var fe = $(ie, 2),
    W = E(fe);
  let le;
  var Ce = E(W);
  $a(Ce);
  var Me = $(Ce, 2),
    Le = E(Me);
  let $e;
  Le.__click = [CP, F, z];
  var Oe = E(Le, !0);
  A(Le), A(Me), A(W);
  var Ve = $(W, 2);
  {
    var ct = nt => {
      var Ye = SP();
      H(nt, Ye)
    };
    et(Ve, nt => {
      b(T) || nt(ct)
    })
  }
  A(fe), A(o), mi(2), A(C), qn(C, () => nt => {
    $r(() => {
      _() ? nt.show() : nt.close()
    })
  }), lt((nt, Ye, dt, rt, qe, pt) => {
    Te(G, nt), Te(de, Ye), le = Vr(W, 1, "border-base-content/20 rounded-field relative flex w-full items-center gap-1 border-2 py-1.5 pl-4 pr-2.5", null, le, dt), Ug(Ce, rt), $e = Vr(Le, 1, "btn btn-primary", null, $e, qe), Te(Oe, pt)
  }, [() => V5(), () => U5(), () => ({
    invisible: !b(T)
  }), () => b(F).toString(), () => ({
    "btn-success": b(z)
  }), () => b(z) ? ov() : Tf()]), bn("close", C, () => _(!1)), H(y, C), Er()
}
en(["click"]);
var MP = wr('<svg><path d="M216.856 16.597A208.502 208.502 0 0 0 164.042 0c-2.275 4.113-4.933 9.645-6.766 14.046-19.692-2.961-39.203-2.961-58.533 0-1.832-4.4-4.55-9.933-6.846-14.046a207.809 207.809 0 0 0-52.855 16.638C5.618 67.147-3.443 116.4 1.087 164.956c22.169 16.555 43.653 26.612 64.775 33.193A161.094 161.094 0 0 0 79.735 175.3a136.413 136.413 0 0 1-21.846-10.632 108.636 108.636 0 0 0 5.356-4.237c42.122 19.702 87.89 19.702 129.51 0a131.66 131.66 0 0 0 5.355 4.237 136.07 136.07 0 0 1-21.886 10.653c4.006 8.02 8.638 15.67 13.873 22.848 21.142-6.58 42.646-16.637 64.815-33.213 5.316-56.288-9.08-105.09-38.056-148.36ZM85.474 135.095c-12.645 0-23.015-11.805-23.015-26.18s10.149-26.2 23.015-26.2c12.867 0 23.236 11.804 23.015 26.2.02 14.375-10.148 26.18-23.015 26.18Zm85.051 0c-12.645 0-23.014-11.805-23.014-26.18s10.148-26.2 23.014-26.2c12.867 0 23.236 11.804 23.015 26.2 0 14.375-10.148 26.18-23.015 26.18Z" fill="#5865F2"></path></svg>');

function um(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = MP();
  Kt(T, () => ({
    viewBox: "0 0 256 199",
    width: "256",
    height: "199",
    xmlns: "http://www.w3.org/2000/svg",
    preserveAspectRatio: "xMidYMid",
    ..._
  })), H(y, T)
}
var AP = async (y, l) => {
  await navigator.clipboard.writeText(l.username), Zr.info(lC())
}, kP = De('<span class="tooltip h-4"><button><!></button></span>');

function fh(y, l) {
  kr(l, !0);
  var _ = kP(),
    T = E(_);
  T.__click = [AP, l];
  var z = E(T);
  um(z, {
    class: "size-4 opacity-70"
  }), A(T), A(_), lt(() => Br(_, "data-tip", `Discord: ${l.username}`)), H(y, _), Er()
}
en(["click"]);
var EP = De('<input type="radio" class="tab max-[380px]:px-3"/>'),
  zP = De('<div class="tabs tabs-border w-max font-medium"></div>');

function hm(y, l) {
  kr(l, !0);
  const _ = [];
  let T = It(l, "value", 15, "today"),
    z = [{
      value: "today",
      label: Ud()
    }, {
      value: "week",
      label: oT()
    }, {
      value: "month",
      label: uT()
    }, {
      value: "all-time",
      label: pT()
    }];
  var F = zP();
  xn(F, 21, () => z, C => C.value, (C, o) => {
    var K = EP();
    $a(K);
    var G;
    lt(() => {
      Br(K, "aria-label", b(o).label), G !== (G = b(o).value) && (K.value = (K.__value = b(o).value) ?? "")
    }), Qf(_, [], K, () => (b(o).value, T()), T), H(C, K)
  }), A(F), H(y, F), Er()
}
var LP = wr('<svg><path d="M480-480q33 0 56.5-23.5T560-560q0-33-23.5-56.5T480-640q-33 0-56.5 23.5T400-560q0 33 23.5 56.5T480-480Zm0 400Q319-217 239.5-334.5T160-552q0-150 96.5-239T480-880q127 0 223.5 89T800-552q0 100-79.5 217.5T480-80Z"></path></svg>');

function dm(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = LP();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
const DP = typeof window < "u" ? window : void 0;

function RP(y) {
  let l = y.activeElement;
  for (; l != null && l.shadowRoot;) {
    const _ = l.shadowRoot.activeElement;
    if (_ === l) break;
    l = _
  }
  return l
}
var tc, Lu, qg;
let BP = (qg = class {
  constructor(l = {}) {
    Pr(this, tc);
    Pr(this, Lu);
    const {
      window: _ = DP,
      document: T = _ == null ? void 0 : _.document
    } = l;
    _ !== void 0 && (Xn(this, tc, T), Xn(this, Lu, Gg(z => {
      const F = Pu(_, "focusin", z),
        C = Pu(_, "focusout", z);
      return () => {
        F(), C()
      }
    })))
  }
  get current() {
    var l;
    return (l = st(this, Lu)) == null || l.call(this), st(this, tc) ? RP(st(this, tc)) : null
  }
}, tc = new WeakMap, Lu = new WeakMap, qg);
new BP;

function FP(y, l) {
  switch (y) {
    case "post":
      $r(l);
      break;
    case "pre":
      Kf(l);
      break
  }
}

function mv(y, l, _, T = {}) {
  const {
    lazy: z = !1
  } = T;
  let F = !z,
    C = Array.isArray(y) ? [] : void 0;
  FP(l, () => {
    const o = Array.isArray(y) ? y.map(G => G()) : y();
    if (!F) {
      F = !0, C = o;
      return
    }
    const K = so(() => _(o, C));
    return C = o, K
  })
}

function hc(y, l, _) {
  mv(y, "post", l, _)
}

function OP(y, l, _) {
  mv(y, "pre", l, _)
}
hc.pre = OP;

function NP(y) {
  const l = y - 1;
  return l * l * l + 1
}

function Jo(y, {
  from: l,
  to: _
}, T = {}) {
  var {
    delay: z = 0,
    duration: F = nt => Math.sqrt(nt) * 120,
    easing: C = NP
  } = T, o = getComputedStyle(y), K = o.transform === "none" ? "" : o.transform, [G, ie] = o.transformOrigin.split(" ").map(parseFloat);
  G /= y.clientWidth, ie /= y.clientHeight;
  var de = jP(y),
    fe = y.clientWidth / _.width / de,
    W = y.clientHeight / _.height / de,
    le = l.left + l.width * G,
    Ce = l.top + l.height * ie,
    Me = _.left + _.width * G,
    Le = _.top + _.height * ie,
    $e = (le - Me) * fe,
    Oe = (Ce - Le) * W,
    Ve = l.width / _.width,
    ct = l.height / _.height;
  return {
    delay: z,
    duration: typeof F == "function" ? F(Math.sqrt($e * $e + Oe * Oe)) : F,
    easing: C,
    css: (nt, Ye) => {
      var dt = Ye * $e,
        rt = Ye * Oe,
        qe = nt + Ye * Ve,
        pt = nt + Ye * ct;
      return `transform: ${K} translate(${dt}px, ${rt}px) scale(${qe}, ${pt});`
    }
  }
}

function jP(y) {
  if ("currentCSSZoom" in y) return y.currentCSSZoom;
  for (var l = y, _ = 1; l !== null;) _ *= +getComputedStyle(l).zoom, l = l.parentElement;
  return _
}
var qP = De('<span class="loading loading-spinner loading-lg mt-18 mx-auto flex items-center"></span>'),
  VP = De('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  ZP = De('<span class="font-flag tooltip ml-0.5"> </span>'),
  $P = (y, l, _) => {
    l.onlastpixelclick({
      lat: b(_).lastLatitude ?? 0,
      lng: b(_).lastLongitude ?? 0
    })
  },
  UP = De("<button><!></button>"),
  GP = De('<tr><td class="text-base-content/80 font-medium max-[400px]:hidden"> </td><td><div class="flex items-center gap-2"><!> <span> <span class="ml-0.5"> </span></span> <!> <!></div></td><td class="text-base-content/80 relative text-center font-medium"> <!></td></tr>'),
  HP = De('<table class="table"><thead class="text-base-content/80"><tr><th class="max-[400px]:hidden"></th><th> </th><th class="text-center max-sm:px-1"> </th></tr></thead><tbody></tbody></table>'),
  WP = De('<div><!> <div class="mt-4"><!></div></div>');

function XP(y, l) {
  kr(l, !0);
  let _ = It(l, "reload", 15),
    T = _t(!0),
    z = _t([]),
    F = _t(0),
    C = _t("today"),
    o = {};
  _(K);

  function K() {
    const Ce = b(C);
    ci.allianceLeaderboard(l.allianceId, Ce).then(Me => {
      he(z, Me), o = {
        [Ce]: Me
      }, he(T, !1)
    }).catch(Me => {
      Zr.error(Me.message)
    })
  }
  hc(() => [b(C)], () => {
    const Ce = b(C),
      Me = o[Ce];
    if (Me) {
      he(z, Me), he(T, !1);
      return
    }
    he(T, !0), ci.allianceLeaderboard(l.allianceId, Ce).then(Le => {
      he(z, Le), o[Ce] = Le, he(T, !1)
    }).catch(Le => {
      Zr.error(Le.message)
    })
  });
  var G = WP(),
    ie = E(G);
  hm(ie, {
    get value() {
      return b(C)
    },
    set value(Ce) {
      he(C, Ce, !0)
    }
  });
  var de = $(ie, 2),
    fe = E(de);
  {
    var W = Ce => {
        var Me = qP();
        H(Ce, Me)
      },
      le = Ce => {
        var Me = sr(),
          Le = Et(Me);
        {
          var $e = Ve => {
              var ct = VP(),
                nt = E(ct),
                Ye = $(nt);
              {
                var dt = qe => {
                    var pt = sa();
                    lt(at => Te(pt, at), [() => Ud().toLowerCase()]), H(qe, pt)
                  },
                  rt = qe => {
                    var pt = sr(),
                      at = Et(pt);
                    {
                      var ht = xt => {
                          var Q = sa();
                          lt(re => Te(Q, re), [() => nm()]), H(xt, Q)
                        },
                        Re = xt => {
                          var Q = sr(),
                            re = Et(Q);
                          {
                            var xe = ce => {
                              var Ee = sa();
                              lt(Be => Te(Ee, Be), [() => am()]), H(ce, Ee)
                            };
                            et(re, ce => {
                              b(C) === "month" && ce(xe)
                            }, !0)
                          }
                          H(xt, Q)
                        };
                      et(at, xt => {
                        b(C) === "week" ? xt(ht) : xt(Re, !1)
                      }, !0)
                    }
                    H(qe, pt)
                  };
                et(Ye, qe => {
                  b(C) === "today" ? qe(dt) : qe(rt, !1)
                })
              }
              A(ct), lt(qe => Te(nt, `${qe??""} `), [() => im()]), H(Ve, ct)
            },
            Oe = Ve => {
              var ct = HP(),
                nt = E(ct),
                Ye = E(nt),
                dt = $(E(Ye)),
                rt = E(dt, !0);
              A(dt);
              var qe = $(dt),
                pt = E(qe, !0);
              A(qe), A(Ye), A(nt);
              var at = $(nt);
              xn(at, 31, () => b(z), ht => ht.userId, (ht, Re, xt) => {
                const Q = vt(() => {
                  var ur;
                  return ((ur = Ot.data) == null ? void 0 : ur.id) === b(Re).userId
                });
                var re = GP();
                let xe;
                var ce = E(re),
                  Ee = E(ce, !0);
                A(ce);
                var Be = $(ce),
                  Ke = E(Be),
                  tt = E(Ke);
                ss(tt, {
                  class: "size-10 border",
                  get userId() {
                    return b(Re).userId
                  },
                  get pictureUrl() {
                    return b(Re).picture
                  }
                });
                var ot = $(tt, 2),
                  ft = E(ot),
                  Bt = $(ft),
                  At = E(Bt);
                A(Bt), A(ot);
                var cr = $(ot, 2);
                {
                  var Mt = ur => {
                    const Qt = vt(() => as(b(Re).equippedFlag));
                    var er = ZP(),
                      Dt = E(er, !0);
                    A(er), lt(() => {
                      Br(er, "data-tip", b(Qt).name), Te(Dt, b(Qt).flag)
                    }), H(ur, er)
                  };
                  et(cr, ur => {
                    b(Re).equippedFlag && ur(Mt)
                  })
                }
                var yt = $(cr, 2);
                {
                  var St = ur => {
                    fh(ur, {
                      get username() {
                        return b(Re).discord
                      }
                    })
                  };
                  et(yt, ur => {
                    b(Re).discord && ur(St)
                  })
                }
                A(Ke), A(Be);
                var jt = $(Be),
                  Lt = E(jt),
                  Gt = $(Lt);
                {
                  var gr = ur => {
                    var Qt = UP();
                    let er;
                    Qt.__click = [$P, l, Re];
                    var Dt = E(Qt);
                    dm(Dt, {
                      class: "size-4"
                    }), A(Qt), lt((Ir, Tr) => {
                      er = Vr(Qt, 1, "btn btn-sm btn-ghost absolute -right-2 top-1/2 !-translate-y-1/2 sm:right-4", null, er, Ir), Br(Qt, "data-tip", Tr)
                    }, [() => ({
                      tooltip: b(F) > 640
                    }), () => wT()]), H(ur, Qt)
                  };
                  et(Gt, ur => {
                    b(Re).lastLatitude && b(Re).lastLongitude && ur(gr)
                  })
                }
                A(jt), A(re), lt((ur, Qt, er) => {
                  var Dt;
                  xe = Vr(re, 1, "", null, xe, ur), Te(Ee, b(xt) + 1), Vr(ot, 1, `font-semibold ${Qt??""} flex gap-1`), Te(ft, `${(b(Q)?((Dt=Ot.data)==null?void 0:Dt.name)??b(Re).name:b(Re).name)??""} `), Te(At, `#${b(Re).userId??""}`), Te(Lt, `${er??""} `)
                }, [() => ({
                  "bg-base-200": b(Q)
                }), () => Yn(b(Re).userId), () => b(Re).pixelsPainted.toLocaleString("en-US")]), Yo(re, () => Jo, () => ({
                  duration: 200
                })), H(ht, re)
              }), A(at), A(ct), lt((ht, Re) => {
                Te(rt, ht), Te(pt, Re)
              }, [() => sm(), () => rm()]), H(Ve, ct)
            };
          et(Le, Ve => {
            b(z).length === 0 ? Ve($e) : Ve(Oe, !1)
          }, !0)
        }
        H(Ce, Me)
      };
    et(fe, Ce => {
      b(T) ? Ce(W) : Ce(le, !1)
    })
  }
  A(de), A(G), Vd("innerWidth", Ce => he(F, Ce, !0)), H(y, G), Er()
}
en(["click"]);
var KP = wr('<svg><path d="M480-160q-33 0-56.5-23.5T400-240q0-33 23.5-56.5T480-320q33 0 56.5 23.5T560-240q0 33-23.5 56.5T480-160Zm0-240q-33 0-56.5-23.5T400-480q0-33 23.5-56.5T480-560q33 0 56.5 23.5T560-480q0 33-23.5 56.5T480-400Zm0-240q-33 0-56.5-23.5T400-720q0-33 23.5-56.5T480-800q33 0 56.5 23.5T560-720q0 33-23.5 56.5T480-640Z"></path></svg>');

function pm(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = KP();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var YP = (y, l) => l.onclickback(),
  JP = De('<div class="badge badge-primary badge-sm badge-soft">ADMIN</div>'),
  QP = async (y, l) => {
    try {
      b(l).loading = !0, await ci.giveAllianceAdmin(b(l).id), b(l).role = "admin"
    } catch {
      Zr.error(zC())
    } finally {
      b(l).loading = !1
    }
  }, eI = async (y, l, _) => {
    try {
      b(l).loading = !0, await ci.banAllianceUser(b(l).id), _.data = _.data.filter(T => T.id !== b(l).id)
    } catch {
      Zr.error(e3())
    } finally {
      b(l).loading = !1
    }
  }, tI = De('<li><button class="btn btn-ghost"> </button></li> <li><button class="btn btn-ghost btn-error not-hover:text-error"> </button></li>', 1), rI = De('<li><button class="btn btn-ghost text-base-content/80"> </button></li>'), iI = De('<tr><td class="w-full"><div class="flex items-center gap-2"><!> <span> </span> <!></div></td><td class="px-0"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-ghost"><!></div> <ul class="dropdown-content menu bg-base-100 rounded-box z-1 border-base-200 right-0 w-44 translate-y-1 gap-1 border p-2 shadow-sm"><!></ul></div></td></tr>'), nI = De('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'), aI = (y, l, _) => {
    ci.unbanAllianceUser(b(l).id).then(() => {
      _.data = _.data.filter(T => T.id !== b(l).id)
    }).catch(T => Zr.error(T.message)).finally(() => {
      b(l).loading = !1
    })
  }, sI = De('<tr><td class="w-full"><div class="flex items-center gap-2"><!> <span> </span></div></td><td class="px-0"><button class="btn btn-error"> </button></td></tr>'), oI = De('<div class="text-base-content/80 mt-4 flex justify-center"> </div>'), lI = De('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'), cI = De('<div><section class="mt-2 flex items-center gap-1"><button class="btn btn-ghost btn-circle"><!></button> <h2 class="text-xl font-semibold"> </h2></section> <div class="tabs tabs-border mt-2"><input type="radio" name="members_tabs" class="tab" checked/> <div class="tab-content py-4"><table class="table"><tbody></tbody></table> <!></div> <input type="radio" name="members_tabs" class="tab"/> <div class="tab-content py-4"><table class="table"><tbody></tbody></table> <!> <!></div></div></div>');

function uI(y, l) {
  kr(l, !0);
  let _ = En({
      data: [],
      page: 0,
      hasNextPage: !0,
      loading: !1
    }),
    T = En({
      data: [],
      page: 0,
      hasNextPage: !0,
      loading: !1
    });
  var z = cI(),
    F = E(z),
    C = E(F);
  C.__click = [YP, l];
  var o = E(C);
  bx(o, {
    class: "size-5"
  }), A(C);
  var K = $(C, 2),
    G = E(K, !0);
  A(K), A(F);
  var ie = $(F, 2),
    de = E(ie);
  $a(de);
  var fe = $(de, 2),
    W = E(fe),
    le = E(W);
  xn(le, 21, () => _.data, rt => rt.id, (rt, qe, pt) => {
    const at = vt(() => {
      var Mt;
      return ((Mt = Ot.data) == null ? void 0 : Mt.id) === b(qe).id
    });
    var ht = iI(),
      Re = E(ht),
      xt = E(Re),
      Q = E(xt);
    ss(Q, {
      class: "size-10 border",
      get userId() {
        return b(qe).id
      },
      get pictureUrl() {
        return b(qe).picture
      }
    });
    var re = $(Q, 2),
      xe = E(re);
    A(re);
    var ce = $(re, 2);
    {
      var Ee = Mt => {
        var yt = JP();
        H(Mt, yt)
      };
      et(ce, Mt => {
        b(qe).role === "admin" && Mt(Ee)
      })
    }
    A(xt), A(Re);
    var Be = $(Re),
      Ke = E(Be),
      tt = E(Ke),
      ot = E(tt);
    pm(ot, {
      class: "size-4"
    }), A(tt);
    var ft = $(tt, 2),
      Bt = E(ft);
    {
      var At = Mt => {
          var yt = tI(),
            St = Et(yt),
            jt = E(St);
          jt.__click = [QP, qe];
          var Lt = E(jt, !0);
          A(jt), A(St);
          var Gt = $(St, 2),
            gr = E(Gt);
          gr.__click = [eI, qe, _];
          var ur = E(gr, !0);
          A(gr), A(Gt), lt((Qt, er) => {
            jt.disabled = b(qe).loading, Te(Lt, Qt), gr.disabled = b(qe).loading, Te(ur, er)
          }, [() => DT(), () => cv()]), H(Mt, yt)
        },
        cr = Mt => {
          var yt = rI(),
            St = E(yt);
          St.disabled = !0;
          var jt = E(St, !0);
          A(St), A(yt), lt(Lt => Te(jt, Lt), [() => NT()]), H(Mt, yt)
        };
      et(Bt, Mt => {
        b(qe).role === "member" ? Mt(At) : Mt(cr, !1)
      })
    }
    A(ft), A(Ke), A(Be), A(ht), lt(Mt => {
      var yt;
      Vr(re, 1, `font-semibold ${Mt??""}`), Te(xe, `${(b(at)?((yt=Ot.data)==null?void 0:yt.name)??b(qe).name:b(qe).name)??""} #${b(qe).id??""}`)
    }, [() => Yn(b(qe).id)]), H(rt, ht)
  }), A(le), A(W);
  var Ce = $(W, 2);
  {
    var Me = rt => {
      var qe = sr(),
        pt = Et(qe);
      Iu(pt, () => _.page, at => {
        var ht = nI();
        qn(ht, () => Re => {
          const xt = new IntersectionObserver(Q => {
            Q[0].isIntersecting && !_.loading && (_.loading = !0, ci.getAllianceMembers(_.page).then(re => {
              _.data = [..._.data, ...re.data], _.hasNextPage = re.hasNext, _.page++
            }).catch(re => {
              Zr.error(re.message)
            }).finally(() => {
              _.loading = !1
            }))
          });
          return xt.observe(Re), () => {
            xt.disconnect()
          }
        }), H(at, ht)
      }), H(rt, qe)
    };
    et(Ce, rt => {
      _.hasNextPage && rt(Me)
    })
  }
  A(fe);
  var Le = $(fe, 2),
    $e = $(Le, 2),
    Oe = E($e),
    Ve = E(Oe);
  xn(Ve, 21, () => T.data, rt => rt.id, (rt, qe, pt) => {
    var at = sI(),
      ht = E(at),
      Re = E(ht),
      xt = E(Re);
    ss(xt, {
      class: "size-10 border",
      get userId() {
        return b(qe).id
      },
      get pictureUrl() {
        return b(qe).picture
      }
    });
    var Q = $(xt, 2),
      re = E(Q);
    A(Q), A(Re), A(ht);
    var xe = $(ht),
      ce = E(xe);
    ce.__click = [aI, qe, T];
    var Ee = E(ce, !0);
    A(ce), A(xe), A(at), lt((Be, Ke) => {
      Vr(Q, 1, `font-semibold ${Be??""}`), Te(re, `${b(qe).name??""} #${b(qe).id??""}`), ce.disabled = b(qe).loading, Te(Ee, Ke)
    }, [() => Yn(b(qe).id), () => VT()]), H(rt, at)
  }), A(Ve), A(Oe);
  var ct = $(Oe, 2);
  {
    var nt = rt => {
      var qe = oI(),
        pt = E(qe, !0);
      A(qe), lt(at => Te(pt, at), [() => UT()]), H(rt, qe)
    };
    et(ct, rt => {
      !T.hasNextPage && T.data.length === 0 && rt(nt)
    })
  }
  var Ye = $(ct, 2);
  {
    var dt = rt => {
      var qe = sr(),
        pt = Et(qe);
      Iu(pt, () => T.page, at => {
        var ht = lI();
        qn(ht, () => Re => {
          const xt = new IntersectionObserver(Q => {
            Q[0].isIntersecting && !T.loading && (T.loading = !0, ci.getAllianceBannedMembers(T.page).then(re => {
              T.data = [...T.data, ...re.data], T.hasNextPage = re.hasNext, T.page++
            }).catch(re => {
              Zr.error(re.message)
            }).finally(() => {
              T.loading = !1
            }))
          });
          return xt.observe(Re), () => {
            xt.disconnect()
          }
        }), H(at, ht)
      }), H(rt, qe)
    };
    et(Ye, rt => {
      T.hasNextPage && rt(dt)
    })
  }
  A($e), A(ie), A(z), lt((rt, qe, pt) => {
    Te(G, rt), Br(de, "aria-label", qe), Br(Le, "aria-label", pt)
  }, [() => sv(), () => i3(), () => s3()]), H(y, z), Er()
}
en(["click"]);
var hI = De('<span class="label"> </span>'),
  dI = De('<span class="hidden px-1 text-[10px] peer-focus:block"> </span>'),
  pI = De('<p class="text-error ml-3 text-sm"> </p>'),
  fI = De('<div><label><!> <input class="peer" type="text"/> <!></label> <!></div>');

function Sf(y, l) {
  kr(l, !0);
  let _ = It(l, "value", 15),
    T = It(l, "validate", 15),
    z = _t("");
  const F = vt(() => {
    var Le;
    return ((Le = _()) == null ? void 0 : Le.length) ?? 0
  });
  T(C);

  function C() {
    return l.min !== void 0 && b(F) < l.min ? (he(z, b(F) === 0 ? "Required" : `Min. characters: ${l.min}`, !0), !1) : l.max !== void 0 && b(F) > l.max ? (he(z, `Max. characters: ${l.max}`), !1) : !0
  }
  $r(() => {
    var Le;
    l.max !== void 0 && b(F) > l.max && _((Le = _()) == null ? void 0 : Le.substring(0, l.max))
  });
  var o = fI(),
    K = E(o);
  let G;
  var ie = E(K);
  {
    var de = Le => {
      var $e = hI(),
        Oe = E($e, !0);
      A($e), lt(() => Te(Oe, l.label)), H(Le, $e)
    };
    et(ie, Le => {
      l.label && Le(de)
    })
  }
  var fe = $(ie, 2);
  $a(fe);
  var W = $(fe, 2);
  {
    var le = Le => {
      var $e = dI(),
        Oe = E($e, !0);
      A($e), lt(() => Te(Oe, l.max - b(F))), H(Le, $e)
    };
    et(W, Le => {
      l.max !== void 0 && Le(le)
    })
  }
  A(K);
  var Ce = $(K, 2);
  {
    var Me = Le => {
      var $e = pI(),
        Oe = E($e, !0);
      A($e), lt(() => Te(Oe, b(z))), H(Le, $e)
    };
    et(Ce, Le => {
      b(z) && Le(Me)
    })
  }
  A(o), lt(Le => {
    G = Vr(K, 1, "input w-full", null, G, Le), Br(fe, "placeholder", l.placeholder), Br(fe, "maxlength", l.max)
  }, [() => ({
    "input-error": !!b(z)
  })]), jd(fe, _), H(y, o), Er()
}
var mI = (y, l) => {
    var _;
    (_ = l()) == null || _.close()
  },
  _I = De('<dialog class="modal"><div class="modal-box"><h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form><div class="my-4"><!></div> <div class="flex w-full justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-primary"> </button></div></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function gI(y, l) {
  kr(l, !0);
  let _ = It(l, "ref", 15),
    T = _t(!1),
    z = _t(""),
    F = _t(void 0);
  Ii(() => {
    const $e = Oe => {
      var Ve;
      Oe.key === "Escape" && ((Ve = _()) == null || Ve.close())
    };
    return document.addEventListener("keydown", $e), () => document.removeEventListener("keydown", $e)
  });
  var C = _I(),
    o = E(C),
    K = E(o),
    G = E(K, !0);
  A(K);
  var ie = $(K, 2),
    de = E(ie),
    fe = E(de);
  {
    let $e = vt(() => wf()),
      Oe = vt(() => MT());
    Sf(fe, {
      get label() {
        return b($e)
      },
      get placeholder() {
        return b(Oe)
      },
      min: 1,
      max: 16,
      get value() {
        return b(z)
      },
      set value(Ve) {
        he(z, Ve, !0)
      },
      get validate() {
        return b(F)
      },
      set validate(Ve) {
        he(F, Ve, !0)
      }
    })
  }
  A(de);
  var W = $(de, 2),
    le = E(W);
  le.__click = [mI, _];
  var Ce = E(le, !0);
  A(le);
  var Me = $(le, 2),
    Le = E(Me, !0);
  A(Me), A(W), A(ie), A(o), mi(2), A(C), Ss(C, $e => _($e), () => _()), lt(($e, Oe, Ve) => {
    Te(G, $e), le.disabled = b(T), Te(Ce, Oe), Me.disabled = b(T), Te(Le, Ve)
  }, [() => ST(), () => Jf(), () => ET()]), bn("submit", ie, async () => {
    var $e, Oe;
    try {
      if (!(($e = b(F)) != null && $e())) return;
      he(T, !0);
      const {
        id: Ve
      } = await ci.createAlliance(b(z));
      await l.onsuccess(Ve), (Oe = _()) == null || Oe.close()
    } catch (Ve) {
      Zr.error(Ve.message)
    } finally {
      he(T, !1)
    }
  }), H(y, C), Er()
}
en(["click"]);
var vI = wr('<svg><path d="M240-120q-45 0-89-22t-71-58q26 0 53-20.5t27-59.5q0-50 35-85t85-35q50 0 85 35t35 85q0 66-47 113t-113 47Zm230-240L360-470l358-358q11-11 27.5-11.5T774-828l54 54q12 12 12 28t-12 28L470-360Z"></path></svg>');

function mh(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = vI();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var yI = wr('<svg><path d="M160-160v-100.77l527.23-527.77q6.15-5.48 13.57-8.47 7.43-2.99 15.49-2.99t15.62 2.54q7.55 2.54 13.94 9.15l42.69 42.93q6.61 6.38 9.04 14 2.42 7.63 2.42 15.25 0 8.13-2.74 15.56-2.74 7.42-8.72 13.57L260.77-160H160Zm540.15-496.46L760-715.54 715.54-760l-59.08 59.85 43.69 43.69Z"></path></svg>'),
  xI = wr('<svg><path d="M200-200h57l391-391-57-57-391 391v57Zm-80 80v-170l528-527q12-11 26.5-17t30.5-6q16 0 31 6t26 18l55 56q12 11 17.5 26t5.5 30q0 16-5.5 30.5T817-647L290-120H120Zm640-584-56-56 56 56Zm-141 85-28-29 57 57-29-28Z"></path></svg>');

function Pf(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy", "filled"]);
  var T = sr(),
    z = Et(T);
  {
    var F = o => {
        var K = yI();
        Kt(K, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ..._
        })), H(o, K)
      },
      C = o => {
        var K = xI();
        Kt(K, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ..._
        })), H(o, K)
      };
    et(z, o => {
      l.filled ? o(F) : o(C, !1)
    })
  }
  H(y, T)
}
var bI = wr('<svg><path d="M360-440h80v-110h80v110h80v-190l-120-80-120 80v190ZM480-80Q319-217 239.5-334.5T160-552q0-150 96.5-239T480-880q127 0 223.5 89T800-552q0 100-79.5 217.5T480-80Z"></path></svg>');

function wI(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = bI();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var TI = wr('<svg><path d="M160-160q-33 0-56.5-23.5T80-240v-480q0-33 23.5-56.5T160-800h640q33 0 56.5 23.5T880-720v480q0 33-23.5 56.5T800-160H160Zm320-280L160-640v400h640v-400L480-440Zm0-80 320-200H160l320 200ZM160-640v-80 480-400Z"></path></svg>');

function CI(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = TI();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var SI = wr('<svg><path d="M720-400v-120H600v-80h120v-120h80v120h120v80H800v120h-80Zm-360-80q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM40-160v-112q0-34 17.5-62.5T104-378q62-31 126-46.5T360-440q66 0 130 15.5T616-378q29 15 46.5 43.5T680-272v112H40Z"></path></svg>');

function PI(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = SI();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var II = wr('<svg><path d="M480-480q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM160-160v-112q0-34 17.5-62.5T224-378q62-31 126-46.5T480-440q66 0 130 15.5T736-378q29 15 46.5 43.5T800-272v112H160Z"></path></svg>');

function Gd(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = II();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}

function MI(y, l = "_blank") {
  return y.replaceAll(/https?:\/\/[^\s]+/g, _ => `<a href="${_}"${l?` target="${l}"`:""}>${_}</a>`)
}
var AI = De('<div class="flex h-full items-center justify-center"><span class="loading loading-spinner loading-xl"></span></div>'),
  kI = async (y, l, _, T) => {
    try {
      he(l, !0), await ci.leaveAlliance(), he(_, !0), await T()
    } catch (z) {
      Zr.error(z.message)
    } finally {
      he(l, !1)
    }
  }, EI = (y, l) => {
    he(l, !0)
  }, zI = De('<div class="tooltip"><button class="btn"><!></button></div>'), LI = (y, l) => {
    var _;
    (_ = b(l)) == null || _.show()
  }, DI = De('<button class="text-base-content/50 translate-y-0.5 p-1"><!></button>'), RI = De('<section class="text-base-content/80 highlight-link"><!> <!></section>'), BI = De('<span class="font-semibold"> </span>'), FI = (y, l) => he(l, !0), OI = De('<button class="text-primary font-semibold underline"> </button>'), NI = (y, l, _) => {
    var T;
    (T = b(l)) != null && T.hq ? _.onhqclick({
      lat: b(l).hq.latitude,
      lng: b(l).hq.longitude
    }) : _.onhqchange()
  }, jI = De('<span class="text-primary underline"> </span>'), qI = De('<span class="text-primary underline"> </span>'), VI = De('<button class="text-base-content/80 p-1"><!></button>'), ZI = De('<div class="flex items-center gap-1"><!> <span> <button class="font-semibold"><!></button></span> <!></div>'), $I = De('<section class="flex items-center justify-between"><h2 class="text-xl font-semibold sm:text-3xl"> </h2> <div class="flex items-center gap-1"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-ghost"><!></div> <ul class="dropdown-content menu bg-base-100 rounded-box z-1 border-base-200 right-0 w-44 translate-y-1 border p-2 shadow-sm"><li><button class="btn btn-soft btn-error"> </button></li></ul></div> <!></div></section> <!> <section class="mt-3"><div class="flex items-center gap-1"><!> <span> <span class="font-semibold"> </span></span></div> <div class="flex items-center gap-1"><!> <span> <!></span></div> <!></section> <section class="mt-6"><h3 class="text-lg font-semibold"> </h3> <div class="mt-1 pb-2"><!></div></section> <!> <!>', 1), UI = (y, l) => {
    var _;
    (_ = b(l)) == null || _.show()
  }, GI = De('<div class="flex h-[90%] flex-col items-center justify-center gap-3"><span class="text-base-content/80"> </span> <span class="mt-8 flex items-center gap-2 text-xl font-semibold"><!> </span> <div class="flex w-full justify-center"><div class="divider w-full max-w-sm"> </div></div> <button class="btn btn-xl btn-soft mb-6"><!> </button></div> <!>', 1), HI = De('<div class="h-full"><!></div>');

function WI(y, l) {
  kr(l, !0);
  let _ = _t(void 0),
    T = _t(!0),
    z = _t(void 0),
    F = _t(!1),
    C = _t(void 0),
    o = _t(!1),
    K = _t(!1),
    G = _t(() => {});
  hc(() => l.open, () => {
    l.open && Pd.shouldReload && ie()
  }), Ii(() => {
    const Ce = setInterval(() => {
      Pd.shouldReload = !0
    }, 1e4);
    return () => {
      clearTimeout(Ce)
    }
  });
  async function ie() {
    try {
      he(_, await ci.getAlliance(), !0), b(_) && b(G)(), he(T, !1), Pd.shouldReload = !1
    } catch (Ce) {
      Zr.error(Ce.message)
    }
  }
  var de = HI(),
    fe = E(de);
  {
    var W = Ce => {
        var Me = AI();
        H(Ce, Me)
      },
      le = Ce => {
        var Me = sr(),
          Le = Et(Me);
        {
          var $e = Ve => {
              uI(Ve, {
                onclickback: () => he(K, !1)
              })
            },
            Oe = Ve => {
              var ct = sr(),
                nt = Et(ct);
              {
                var Ye = rt => {
                    var qe = $I(),
                      pt = Et(qe),
                      at = E(pt),
                      ht = E(at, !0);
                    A(at);
                    var Re = $(at, 2),
                      xt = E(Re),
                      Q = E(xt),
                      re = E(Q);
                    pm(re, {
                      class: "size-4"
                    }), A(Q);
                    var xe = $(Q, 2),
                      ce = E(xe),
                      Ee = E(ce);
                    Ee.__click = [kI, F, T, ie];
                    var Be = E(Ee, !0);
                    A(Ee), A(ce), A(xe), A(xt);
                    var Ke = $(xt, 2);
                    {
                      var tt = $t => {
                        var yr = zI(),
                          jr = E(yr);
                        jr.__click = [EI, o];
                        var ye = E(jr);
                        PI(ye, {
                          class: "size-4"
                        }), A(jr), A(yr), lt(j => Br(yr, "data-tip", j), [() => eT()]), H($t, yr)
                      };
                      et(Ke, $t => {
                        b(_).role == "admin" && $t(tt)
                      })
                    }
                    A(Re), A(pt);
                    var ot = $(pt, 2);
                    {
                      var ft = $t => {
                        var yr = RI(),
                          jr = E(yr);
                        xx(jr, () => MI(b(_).description || lv()));
                        var ye = $(jr, 2);
                        {
                          var j = V => {
                            var X = DI();
                            X.__click = [LI, C];
                            var se = E(X);
                            Pf(se, {
                              class: "size-4"
                            }), A(X), H(V, X)
                          };
                          et(ye, V => {
                            b(_).role === "admin" && V(j)
                          })
                        }
                        A(yr), H($t, yr)
                      };
                      et(ot, $t => {
                        (b(_).description || b(_).role === "admin") && $t(ft)
                      })
                    }
                    var Bt = $(ot, 2),
                      At = E(Bt),
                      cr = E(At);
                    mh(cr, {
                      class: "inline size-4"
                    });
                    var Mt = $(cr, 2),
                      yt = E(Mt),
                      St = $(yt),
                      jt = E(St, !0);
                    A(St), A(Mt), A(At);
                    var Lt = $(At, 2),
                      Gt = E(Lt);
                    Gd(Gt, {
                      class: "inline size-4"
                    });
                    var gr = $(Gt, 2),
                      ur = E(gr),
                      Qt = $(ur);
                    {
                      var er = $t => {
                          var yr = BI(),
                            jr = E(yr, !0);
                          A(yr), lt(ye => Te(jr, ye), [() => b(_).members.toLocaleString("en-US")]), H($t, yr)
                        },
                        Dt = $t => {
                          var yr = OI();
                          yr.__click = [FI, K];
                          var jr = E(yr, !0);
                          A(yr), lt(ye => Te(jr, ye), [() => b(_).members.toLocaleString("en-US")]), H($t, yr)
                        };
                      et(Qt, $t => {
                        b(_).role === "member" ? $t(er) : $t(Dt, !1)
                      })
                    }
                    A(gr), A(Lt);
                    var Ir = $(Lt, 2);
                    {
                      var Tr = $t => {
                        var yr = ZI(),
                          jr = E(yr);
                        wI(jr, {
                          class: "inline size-4"
                        });
                        var ye = $(jr, 2),
                          j = E(ye),
                          V = $(j);
                        V.__click = [NI, _, l];
                        var X = E(V);
                        {
                          var se = Se => {
                              var Ne = jI(),
                                ze = E(Ne);
                              A(Ne), lt((Ie, We) => Te(ze, `${Ie??""}, ${We??""}`), [() => b(_).hq.latitude.toFixed(3), () => b(_).hq.longitude.toFixed(3)]), H(Se, Ne)
                            },
                            we = Se => {
                              var Ne = qI(),
                                ze = E(Ne, !0);
                              A(Ne), lt(Ie => Te(ze, Ie), [() => I5()]), H(Se, Ne)
                            };
                          et(X, Se => {
                            b(_).hq ? Se(se) : Se(we, !1)
                          })
                        }
                        A(V), A(ye);
                        var Ae = $(ye, 2);
                        {
                          var Ze = Se => {
                            var Ne = VI();
                            Ne.__click = function(...Ie) {
                              var We;
                              (We = l.onhqchange) == null || We.apply(this, Ie)
                            };
                            var ze = E(Ne);
                            Pf(ze, {
                              class: "text-base-content/50 size-4"
                            }), A(Ne), H(Se, Ne)
                          };
                          et(Ae, Se => {
                            b(_).role === "admin" && Se(Ze)
                          })
                        }
                        A(yr), lt(Se => Te(j, `${Se??""}: `), [() => C5()]), H($t, yr)
                      };
                      et(Ir, $t => {
                        (b(_).hq || b(_).role === "admin") && $t(Tr)
                      })
                    }
                    A(Bt);
                    var Dr = $(Bt, 2),
                      Fr = E(Dr),
                      dr = E(Fr, !0);
                    A(Fr);
                    var Or = $(Fr, 2),
                      zr = E(Or);
                    XP(zr, {
                      get allianceId() {
                        return b(_).id
                      },
                      get onlastpixelclick() {
                        return l.onlastpixelclick
                      },
                      get reload() {
                        return b(G)
                      },
                      set reload($t) {
                        he(G, $t, !0)
                      }
                    }), A(Or), A(Dr);
                    var tr = $(Dr, 2);
                    TP(tr, {
                      get description() {
                        return b(_).description
                      },
                      onsuccess: async $t => {
                        b(_) && (b(_).description = $t)
                      },
                      get ref() {
                        return b(C)
                      },
                      set ref($t) {
                        he(C, $t, !0)
                      }
                    });
                    var br = $(tr, 2);
                    IP(br, {
                      get open() {
                        return b(o)
                      },
                      set open($t) {
                        he(o, $t, !0)
                      }
                    }), lt(($t, yr, jr, ye, j) => {
                      Te(ht, b(_).name), Ee.disabled = b(F), Te(Be, $t), Te(yt, `${yr??""}: `), Te(jt, jr), Te(ur, `${ye??""}: `), Te(dr, j)
                    }, [() => y5(), () => rm(), () => b(_).pixelsPainted.toLocaleString("en-US"), () => sv(), () => tm()]), H(rt, qe)
                  },
                  dt = rt => {
                    var qe = GI(),
                      pt = Et(qe),
                      at = E(pt),
                      ht = E(at);
                    A(at);
                    var Re = $(at, 2),
                      xt = E(Re);
                    CI(xt, {
                      class: "size-5"
                    });
                    var Q = $(xt, 1, !0);
                    A(Re);
                    var re = $(Re, 2),
                      xe = E(re),
                      ce = E(xe, !0);
                    A(xe), A(re);
                    var Ee = $(re, 2);
                    Ee.__click = [UI, z];
                    var Be = E(Ee);
                    Wg(Be, {
                      class: "size-6"
                    });
                    var Ke = $(Be);
                    A(Ee), A(pt);
                    var tt = $(pt, 2);
                    gI(tt, {
                      onsuccess: ie,
                      get ref() {
                        return b(z)
                      },
                      set ref(ot) {
                        he(z, ot, !0)
                      }
                    }), lt((ot, ft, Bt, At) => {
                      Te(ht, `${ot??""}:`), Te(Q, ft), Te(ce, Bt), Te(Ke, ` ${At??""}`)
                    }, [() => k5(), () => L5(), () => B5(), () => N5()]), H(rt, qe)
                  };
                et(nt, rt => {
                  b(_) ? rt(Ye) : rt(dt, !1)
                }, !0)
              }
              H(Ve, ct)
            };
          et(Le, Ve => {
            b(K) ? Ve($e) : Ve(Oe, !1)
          }, !0)
        }
        H(Ce, Me)
      };
    et(fe, Ce => {
      b(T) ? Ce(W) : Ce(le, !1)
    })
  }
  A(de), H(y, de), Er()
}
en(["click"]);
var XI = wr('<svg><path d="M40-160v-160q0-34 23.5-57t56.5-23h131q20 0 38 10t29 27q29 39 71.5 61t90.5 22q49 0 91.5-22t70.5-61q13-17 30.5-27t36.5-10h131q34 0 57 23t23 57v160H640v-91q-35 25-75.5 38T480-200q-43 0-84-13.5T320-252v92H40Zm440-160q-38 0-72-17.5T351-386q-17-25-42.5-39.5T253-440q22-37 93-58.5T480-520q63 0 134 21.5t93 58.5q-29 0-55 14.5T609-386q-22 32-56 49t-73 17ZM160-440q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T280-560q0 50-34.5 85T160-440Zm640 0q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T920-560q0 50-34.5 85T800-440ZM480-560q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T600-680q0 50-34.5 85T480-560Z"></path></svg>');

function Hd(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = XI();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
const KI = y => y;

function YI(y) {
  const l = y - 1;
  return l * l * l + 1
}

function Kn(y, {
  delay: l = 0,
  duration: _ = 400,
  easing: T = KI
} = {}) {
  const z = +getComputedStyle(y).opacity;
  return {
    delay: l,
    duration: _,
    easing: T,
    css: F => `opacity: ${F*z}`
  }
}

function df(y, {
  delay: l = 0,
  duration: _ = 400,
  easing: T = YI,
  axis: z = "y"
} = {}) {
  const F = getComputedStyle(y),
    C = +F.opacity,
    o = z === "y" ? "height" : "width",
    K = parseFloat(F[o]),
    G = z === "y" ? ["top", "bottom"] : ["left", "right"],
    ie = G.map(Le => `${Le[0].toUpperCase()}${Le.slice(1)}`),
    de = parseFloat(F[`padding${ie[0]}`]),
    fe = parseFloat(F[`padding${ie[1]}`]),
    W = parseFloat(F[`margin${ie[0]}`]),
    le = parseFloat(F[`margin${ie[1]}`]),
    Ce = parseFloat(F[`border${ie[0]}Width`]),
    Me = parseFloat(F[`border${ie[1]}Width`]);
  return {
    delay: l,
    duration: _,
    easing: T,
    css: Le => `overflow: hidden;opacity: ${Math.min(Le*20,1)*C};${o}: ${Le*K}px;padding-${G[0]}: ${Le*de}px;padding-${G[1]}: ${Le*fe}px;margin-${G[0]}: ${Le*W}px;margin-${G[1]}: ${Le*le}px;border-${G[0]}-width: ${Le*Ce}px;border-${G[1]}-width: ${Le*Me}px;min-${o}: 0`
  }
}
var JI = De('<dialog class="modal"><div class="modal-box sm:h-11/12 flex max-w-3xl flex-col max-sm:size-full max-sm:rounded-none max-sm:px-3 max-sm:py-5"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <div class="flex items-center gap-1.5"><!> <h3 class="text-lg font-bold max-sm:text-xl"> </h3></div> <div class="mt-1 grow"><!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function QI(y, l) {
  kr(l, !0);
  let _ = It(l, "open", 15);
  Ii(() => {
    const de = fe => {
      fe.key === "Escape" && _(!1)
    };
    return document.addEventListener("keydown", de), () => document.removeEventListener("keydown", de)
  });
  var T = JI(),
    z = E(T),
    F = $(E(z), 2),
    C = E(F);
  Hd(C, {
    class: "size-5 max-sm:size-6"
  });
  var o = $(C, 2),
    K = E(o, !0);
  A(o), A(F);
  var G = $(F, 2),
    ie = E(G);
  WI(ie, {
    get open() {
      return _()
    },
    get onhqchange() {
      return l.onhqchange
    },
    get onhqclick() {
      return l.onhqclick
    },
    get onlastpixelclick() {
      return l.onlastpixelclick
    }
  }), A(G), A(z), mi(2), A(T), qn(T, () => de => {
    $r(() => {
      _() ? (de.show(), Va.url.searchParams.get("alliance") && (Va.url.searchParams.delete("alliance"), Hg(Va.url.toString()))) : de.close()
    })
  }), lt(de => Te(K, de), [() => Zd()]), bn("close", T, () => _(!1)), An(2, G, () => Kn, () => ({
    duration: 300
  })), H(y, T), Er()
}
var eM = wr('<svg><path d="M360-240q-33 0-56.5-23.5T280-320v-480q0-33 23.5-56.5T360-880h360q33 0 56.5 23.5T800-800v480q0 33-23.5 56.5T720-240H360ZM200-80q-33 0-56.5-23.5T120-160v-560h80v560h440v80H200Z"></path></svg>'),
  tM = wr('<svg><path d="M360-240q-33 0-56.5-23.5T280-320v-480q0-33 23.5-56.5T360-880h360q33 0 56.5 23.5T800-800v480q0 33-23.5 56.5T720-240H360Zm0-80h360v-480H360v480ZM200-80q-33 0-56.5-23.5T120-160v-560h80v560h440v80H200Zm160-240v-480 480Z"></path></svg>');

function rM(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy", "filled"]);
  var T = sr(),
    z = Et(T);
  {
    var F = o => {
        var K = eM();
        Kt(K, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ..._
        })), H(o, K)
      },
      C = o => {
        var K = tM();
        Kt(K, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ..._
        })), H(o, K)
      };
    et(z, o => {
      l.filled ? o(F) : o(C, !1)
    })
  }
  H(y, T)
}
var iM = wr('<svg><path d="M480-320 280-520l56-58 104 104v-326h80v326l104-104 56 58-200 200ZM240-160q-33 0-56.5-23.5T160-240v-120h80v120h480v-120h80v120q0 33-23.5 56.5T720-160H240Z"></path></svg>');

function _v(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = iM();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var nM = wr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm40-80h480L570-480 450-320l-90-120-120 160Zm-40 80v-560 560Z"></path></svg>');

function aM(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = nM();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var sM = wr('<svg><path d="M680-80q-50 0-85-35t-35-85q0-6 3-28L282-392q-16 15-37 23.5t-45 8.5q-50 0-85-35t-35-85q0-50 35-85t85-35q24 0 45 8.5t37 23.5l281-164q-2-7-2.5-13.5T560-760q0-50 35-85t85-35q50 0 85 35t35 85q0 50-35 85t-85 35q-24 0-45-8.5T598-672L317-508q2 7 2.5 13.5t.5 14.5q0 8-.5 14.5T317-452l281 164q16-15 37-23.5t45-8.5q50 0 85 35t35 85q0 50-35 85t-85 35Z"></path></svg>');

function gv(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = sM();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
const Yl = {
  hour: 3600 * 1e3,
  min: 60 * 1e3,
  sec: 1e3
};

function zd(y) {
  const l = Math.floor(y / Yl.hour);
  y -= l * Yl.hour;
  const _ = Math.floor(y / Yl.min);
  y -= _ * Yl.min;
  const z = Math.floor(y / Yl.sec).toString().padStart(2, "0");
  return l > 0 ? `${l}:${_.toString().padStart(2,"0")}:${z}` : `${_}:${z}`
}

function oM(y) {
  const l = new Date,
    _ = l.getFullYear(),
    T = String(l.getMonth() + 1).padStart(2, "0"),
    z = String(l.getDate()).padStart(2, "0"),
    F = String(l.getHours()).padStart(2, "0"),
    C = String(l.getMinutes()).padStart(2, "0"),
    o = String(l.getSeconds()).padStart(2, "0");
  return `${_}-${T}-${z} ${F}:${C}:${o}`
}
var lM = (y, l, _) => {
    navigator.clipboard.writeText(l.url.toString()), he(_, !0), setTimeout(() => {
      he(_, !1)
    }, 1e3)
  },
  cM = De('<img class="border-base-content/20 border" alt="Screenshot"/>'),
  uM = De('<div class="flex w-full items-center justify-center"><span class="loading loading-spinner"></span></div>'),
  hM = async (y, l) => {
    b(l) && (await navigator.clipboard.write([new ClipboardItem({
      "image/png": b(l)
    })]), Zr.info(PS()))
  }, dM = De('<div><h3 class="mb-1 mt-5 flex items-center gap-1 text-xl font-semibold"><!> </h3> <!> <div class="mt-3 flex items-end justify-end gap-2"><button class="btn"><!> </button> <a class="btn btn-primary"><!> </a></div></div>'), pM = De('<dialog class="modal"><div class="modal-box max-h-11/12"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <h3 class="flex items-center gap-1.5 text-xl font-bold"><!> </h3> <div class="border-base-content/20 rounded-field mt-3 flex w-full items-center gap-1 border-2 py-1.5 pl-4 pr-2.5"><input class="text-base-content/80 min-w-10 grow text-sm font-medium" readonly=""/> <div class="h-10"><button> </button></div></div> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function fM(y, l) {
  kr(l, !0);
  let _ = It(l, "open", 15),
    T = _t(!1);
  Ii(() => {
    const Oe = Ve => {
      Ve.key === "Escape" && _(!1)
    };
    return document.addEventListener("keydown", Oe), () => document.removeEventListener("keydown", Oe)
  });
  let z = _t(null),
    F = _t("");
  $r(() => {
    _() ? (l.hideHover(), setTimeout(() => {
      l.map.once("render", () => {
        try {
          l.map.getCanvas().toBlob(Oe => {
            Oe && (he(z, Oe, !0), he(F, URL.createObjectURL(b(z)), !0))
          }, "image/png")
        } finally {
          l.showHover()
        }
      })
    }, 500)) : b(F) && (URL.revokeObjectURL(b(F)), he(z, null), he(F, ""))
  });
  var C = pM(),
    o = E(C),
    K = $(E(o), 2),
    G = E(K);
  gv(G, {
    class: "size-5"
  });
  var ie = $(G);
  A(K);
  var de = $(K, 2),
    fe = E(de);
  $a(fe);
  var W = $(fe, 2),
    le = E(W);
  let Ce;
  le.__click = [lM, l, T];
  var Me = E(le, !0);
  A(le), A(W), A(de);
  var Le = $(de, 2);
  {
    var $e = Oe => {
      const Ve = vt(() => {
        var ce;
        return (ce = l.map) == null ? void 0 : ce.getCanvas()
      });
      var ct = dM(),
        nt = E(ct),
        Ye = E(nt);
      aM(Ye, {
        class: "inline size-5"
      });
      var dt = $(Ye);
      A(nt);
      var rt = $(nt, 2);
      {
        var qe = ce => {
            var Ee = cM();
            lt(() => {
              Br(Ee, "src", b(F)), Br(Ee, "width", b(Ve).width), Br(Ee, "height", b(Ve).height)
            }), H(ce, Ee)
          },
          pt = ce => {
            var Ee = uM();
            lt(() => cc(Ee, `aspect-ratio: ${b(Ve).width/b(Ve).height}`)), H(ce, Ee)
          };
        et(rt, ce => {
          b(F) ? ce(qe) : ce(pt, !1)
        })
      }
      var at = $(rt, 2),
        ht = E(at);
      ht.__click = [hM, z];
      var Re = E(ht);
      rM(Re, {
        class: "size-5"
      });
      var xt = $(Re);
      A(ht);
      var Q = $(ht, 2),
        re = E(Q);
      _v(re, {
        class: "size-5"
      });
      var xe = $(re);
      A(Q), A(at), A(ct), lt((ce, Ee, Be, Ke) => {
        Te(dt, ` ${ce??""}`), Te(xt, ` ${Ee??""}`), Br(Q, "href", b(F)), Br(Q, "download", `wplace_${Be??""}.png`), Te(xe, ` ${Ke??""}`)
      }, [() => xS(), () => Tf(), () => oM().replaceAll(" ", "_").replaceAll(":", "-"), () => TS()]), An(2, ct, () => Kn, () => ({
        duration: 300
      })), H(Oe, ct)
    };
    et(Le, Oe => {
      _() && Oe($e)
    })
  }
  A(o), mi(2), A(C), qn(C, () => Oe => {
    $r(() => {
      _() ? Oe.show() : Oe.close()
    })
  }), lt((Oe, Ve, ct, nt) => {
    Te(ie, ` ${Oe??""}`), Ug(fe, Ve), Ce = Vr(le, 1, "btn btn-primary", null, Ce, ct), Te(Me, nt)
  }, [() => H3(), () => l.url.toString(), () => ({
    "btn-success": b(T)
  }), () => b(T) ? ov() : Tf()]), bn("close", C, () => _(!1)), H(y, C), Er()
}
en(["click"]);
var mM = wr('<svg><path d="m576-160-56-56 104-104-104-104 56-56 104 104 104-104 56 56-104 104 104 104-56 56-104-104-104 104Zm79-360L513-662l56-56 85 85 170-170 56 57-225 226ZM80-280v-80h360v80H80Zm0-320v-80h360v80H80Z"></path></svg>');

function _M(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = mM();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var gM = De('<li class="bg-base-200 border-base-content/10 rounded-xl border-2 p-3"> </li>'),
  vM = De('<div><div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold"> <span class="badge badge-sm badge-error badge-soft ml-1"> </span></h3></div> <div class="text-sm sm:text-base"><ul class="my-3 flex flex-col gap-2 font-medium"></ul> <p class="text-base-content/80 mt-2 text-sm"> </p></div></div>');

function fm(y, l) {
  kr(l, !1);
  const _ = [Q2(), K2(), rw(), aw(), lw(), hw(), fw()];
  Jg();
  var T = vM(),
    z = E(T),
    F = E(z);
  _M(F, {
    class: "size-5"
  });
  var C = $(F, 2),
    o = E(C),
    K = $(o),
    G = E(K, !0);
  A(K), A(C), A(z);
  var ie = $(z, 2),
    de = E(ie);
  xn(de, 5, () => _, Yf, (le, Ce) => {
    var Me = gM(),
      Le = E(Me, !0);
    A(Me), lt(() => Te(Le, b(Ce))), H(le, Me)
  }), A(de);
  var fe = $(de, 2),
    W = E(fe, !0);
  A(fe), A(ie), A(T), lt((le, Ce, Me) => {
    Te(o, `${le??""} `), Te(G, Ce), Te(W, Me)
  }, [() => $2(), () => H2(), () => gw()]), H(y, T), Er()
}
var yM = (y, l) => {
    l(!1)
  },
  xM = De('<dialog class="modal"><div class="modal-box sm:max-h-11/12"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <div class="flex h-full flex-col gap-6"><h2 class="text-xl font-semibold">📑 Updated rules</h2> <section><!></section> <button class="btn btn-primary">Close</button></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function bM(y, l) {
  kr(l, !0);
  let _ = It(l, "open", 15);
  Ii(() => {
    const G = ie => {
      ie.key === "Escape" && _(!1)
    };
    return document.addEventListener("keydown", G), () => document.removeEventListener("keydown", G)
  });
  var T = xM(),
    z = E(T),
    F = $(E(z), 2),
    C = $(E(F), 2),
    o = E(C);
  fm(o, {}), A(C);
  var K = $(C, 2);
  K.__click = [yM, _], A(F), A(z), mi(2), A(T), qn(T, () => G => {
    $r(() => {
      _() ? G.show() : G.close()
    })
  }), bn("close", T, () => _(!1)), H(y, T), Er()
}
en(["click"]);
var wM = () => {
    Va.url.searchParams.delete("new-user"), Hg(Va.url.toString())
  },
  TM = De('<dialog class="modal"><div class="modal-box max-h-11/12"><section class="mb-6 flex justify-center"><h2 class="font-pixel flex flex-col justify-center"><span class="text-center text-2xl"> </span> <!></h2></section> <section class="my-2"><!></section> <form class="mt-6 flex justify-center" method="dialog"><button class="btn btn-primary sm:btn-lg"> </button></form></div></dialog>');

function CM(y, l) {
  kr(l, !0);
  let _ = It(l, "open", 15);
  Ii(() => {
    const Ce = Me => {
      Me.key === "Escape" && _(!1)
    };
    return document.addEventListener("keydown", Ce), () => document.removeEventListener("keydown", Ce)
  });
  var T = TM(),
    z = E(T),
    F = E(z),
    C = E(F),
    o = E(C),
    K = E(o, !0);
  A(o);
  var G = $(o, 2);
  Qg(G, {
    hasText: !0,
    size: "medium"
  }), A(C), A(F);
  var ie = $(F, 2),
    de = E(ie);
  fm(de, {}), A(ie);
  var fe = $(ie, 2),
    W = E(fe);
  W.__click = [wM];
  var le = E(W, !0);
  A(W), A(fe), A(z), A(T), qn(T, () => Ce => {
    $r(() => {
      _() ? Ce.show() : Ce.close()
    })
  }), lt((Ce, Me) => {
    Te(K, Ce), Te(le, Me)
  }, [() => q2(), () => xw()]), bn("close", T, () => _(!1)), H(y, T), Er()
}
en(["click"]);

function SM() {
  const y = navigator.userAgent,
    l = navigator.vendor;
  return /Chrome/.test(y) && /Google Inc/.test(l) ? "Chrome" : /Safari/.test(y) && /Apple Computer/.test(l) ? "Safari" : /Firefox/.test(y) ? "Firefox" : /Edge/.test(y) ? "Edge" : /Opera|OPR/.test(y) ? "Opera" : "Unknown"
}
var PM = wr('<svg><path d="M358.939 44C384.805 44 405.773 64.9683 405.773 90.834C405.773 116.7 384.805 137.668 358.939 137.668C335.282 137.668 315.725 120.127 312.558 97.3418C311.882 97.5076 311.068 97.7132 310.139 97.9658C307.227 98.7577 303.219 99.9781 298.844 101.688C289.898 105.186 280.227 110.425 274.75 117.568C269.021 125.042 265.37 135.158 263.158 143.737C262.067 147.97 261.355 151.71 260.917 154.385C260.789 155.166 260.687 155.855 260.604 156.437C304.314 157.147 344.347 169.064 375.81 188.514C386.896 180.117 400.712 175.135 415.691 175.135C452.208 175.135 481.811 204.738 481.811 241.254C481.81 267.527 466.485 290.221 444.287 300.885C441.861 377.201 358.696 438.508 256.456 438.508C154.451 438.508 71.4321 377.482 68.6426 301.409C45.8419 290.978 30.0001 267.967 30 241.254C30 204.738 59.6021 175.135 96.1182 175.135C111.321 175.135 125.325 180.267 136.494 188.892C167.617 169.488 207.216 157.484 250.507 156.473C250.517 156.392 250.528 156.307 250.539 156.218C250.646 155.398 250.811 154.224 251.049 152.771C251.524 149.867 252.293 145.823 253.475 141.24C255.808 132.188 259.872 120.54 266.814 111.484C274.011 102.098 285.828 96.04 295.202 92.375C299.987 90.5044 304.348 89.1775 307.514 88.3164C309.099 87.8852 310.394 87.568 311.302 87.3574C311.69 87.2673 312.009 87.1968 312.249 87.1445C314.13 63.0035 334.316 44.0001 358.939 44ZM255.905 334.922C234.07 334.922 213.107 336.328 193.621 338.913C190.267 341.144 188.408 343.008 187.698 344.95C187.085 346.63 187.361 348.283 188.093 350.118C200.137 369.374 217.021 383.431 236.377 389.255C237.939 389.694 239.551 390.118 241.216 390.527C246.165 391.641 251.258 392.225 256.456 392.225C283.556 392.224 307.779 376.436 323.849 351.639C325.103 348.78 325.526 346.501 324.943 344.546C324.28 342.322 322.364 340.66 319.327 339.067C299.52 336.385 278.166 334.922 255.905 334.922ZM167.196 240.151C148.634 240.151 133.586 257.42 133.586 278.721C133.586 300.022 148.634 317.29 167.196 317.29C185.759 317.29 200.806 300.022 200.806 278.721C200.806 257.42 185.759 240.152 167.196 240.151ZM343.512 240.151C324.949 240.152 309.901 257.42 309.901 278.721C309.901 300.022 324.949 317.29 343.512 317.29C362.074 317.29 377.122 300.022 377.122 278.721C377.122 257.42 362.074 240.151 343.512 240.151Z"></path></svg>');

function IM(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = PM();
  Kt(T, () => ({
    viewBox: "0 0 512 512",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ..._
  })), H(y, T)
}
var MM = wr('<svg><path fill="#0A0A08" d="M128 23.064c34.177 0 38.225.13 51.722.745 12.48.57 19.258 2.655 23.769 4.408 5.974 2.322 10.238 5.096 14.717 9.575 4.48 4.479 7.253 8.743 9.575 14.717 1.753 4.511 3.838 11.289 4.408 23.768.615 13.498.745 17.546.745 51.723 0 34.178-.13 38.226-.745 51.723-.57 12.48-2.655 19.257-4.408 23.768-2.322 5.974-5.096 10.239-9.575 14.718-4.479 4.479-8.743 7.253-14.717 9.574-4.511 1.753-11.289 3.839-23.769 4.408-13.495.616-17.543.746-51.722.746-34.18 0-38.228-.13-51.723-.746-12.48-.57-19.257-2.655-23.768-4.408-5.974-2.321-10.239-5.095-14.718-9.574-4.479-4.48-7.253-8.744-9.574-14.718-1.753-4.51-3.839-11.288-4.408-23.768-.616-13.497-.746-17.545-.746-51.723 0-34.177.13-38.225.746-51.722.57-12.48 2.655-19.258 4.408-23.769 2.321-5.974 5.095-10.238 9.574-14.717 4.48-4.48 8.744-7.253 14.718-9.575 4.51-1.753 11.288-3.838 23.768-4.408 13.497-.615 17.545-.745 51.723-.745M128 0C93.237 0 88.878.147 75.226.77c-13.625.622-22.93 2.786-31.071 5.95-8.418 3.271-15.556 7.648-22.672 14.764C14.367 28.6 9.991 35.738 6.72 44.155 3.555 52.297 1.392 61.602.77 75.226.147 88.878 0 93.237 0 128c0 34.763.147 39.122.77 52.774.622 13.625 2.785 22.93 5.95 31.071 3.27 8.417 7.647 15.556 14.763 22.672 7.116 7.116 14.254 11.492 22.672 14.763 8.142 3.165 17.446 5.328 31.07 5.95 13.653.623 18.012.77 52.775.77s39.122-.147 52.774-.77c13.624-.622 22.929-2.785 31.07-5.95 8.418-3.27 15.556-7.647 22.672-14.763 7.116-7.116 11.493-14.254 14.764-22.672 3.164-8.142 5.328-17.446 5.95-31.07.623-13.653.77-18.012.77-52.775s-.147-39.122-.77-52.774c-.622-13.624-2.786-22.929-5.95-31.07-3.271-8.418-7.648-15.556-14.764-22.672C227.4 14.368 220.262 9.99 211.845 6.72c-8.142-3.164-17.447-5.328-31.071-5.95C167.122.147 162.763 0 128 0Zm0 62.27C91.698 62.27 62.27 91.7 62.27 128c0 36.302 29.428 65.73 65.73 65.73 36.301 0 65.73-29.428 65.73-65.73 0-36.301-29.429-65.73-65.73-65.73Zm0 108.397c-23.564 0-42.667-19.103-42.667-42.667S104.436 85.333 128 85.333s42.667 19.103 42.667 42.667-19.103 42.667-42.667 42.667Zm83.686-110.994c0 8.484-6.876 15.36-15.36 15.36-8.483 0-15.36-6.876-15.36-15.36 0-8.483 6.877-15.36 15.36-15.36 8.484 0 15.36 6.877 15.36 15.36Z"></path></svg>');

function AM(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = MM();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    preserveAspectRatio: "xMidYMid",
    viewBox: "0 0 256 256",
    ..._
  })), H(y, T)
}
var kM = wr('<svg><path d="M240-640h360v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85h-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640Zm0 480h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM240-160v-400 400Z"></path></svg>');

function Ld(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = kM();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var EM = De(' <a class="link" href="https://help.constructiononline.com/en/scheduling-webgl-and-hardware-acceleration">link</a>', 1),
  zM = De('<span class="link cursor-auto">chrome://settings/system</span>.', 1),
  LM = De('<span class="link cursor-auto">edge://settings/system/manageSystem</span>.', 1),
  DM = De(' <kbd class="kbd kbd-sm"> </kbd> <!>', 1),
  RM = De('<div class="flex h-full flex-col gap-5"><section class="mb-2 flex flex-col items-center justify-center gap-2"><!> <div class="text-center text-sm max-sm:mt-1"> <a class="link" href="https://maplibre.org/" target="_blank">MapLibre</a> | <a class="link" href="https://openfreemap.org/" target="_blank">OpenFreeMap</a> <a class="link" href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a></div> <div class="w-full text-center text-sm"><p><a class="link" href="https://www.reddit.com/r/WplaceLive/comments/1lhzmmq/bug_reports_and_feature_requests/" target="_blank"> </a> <span class="mx-0.5">|</span> <a href="https://discord.gg/wplacelive" target="_blank"><!> <span class="link">Discord</span></a> <span class="mx-0.5">|</span> <a href="https://www.reddit.com/r/WplaceLive/" target="_blank"><!> <span class="link">Reddit</span></a> <span class="mx-0.5">|</span> <a href="https://www.instagram.com/wplace.live/" target="_blank"><!> <span class="link">Instagram</span></a></p></div></section> <section><h3 class="text-lg font-semibold"> </h3> <iframe class="mt-1 aspect-video w-full bg-black" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe></section> <section><h3 class="text-lg font-semibold"> </h3> <p class="not-touchscreen:hidden text-sm"> <button class="btn btn-square shadow-md"><!></button> </p> <p class="touchscreen:hidden text-sm"> <span class="kbd kbd-xs text-base-content rounded-md"> </span> </p></section> <section><h3 class="text-lg font-semibold"> </h3> <p class="text-sm"><!></p></section> <section><!></section> <div class="grow"></div> <section class="text-base-content/80 w-full text-center text-sm"><span>Email: <a class="link" href="mailto:contact@wplace.live">contact@wplace.live</a></span> · <a class="link" href="https://wplace.live/terms/terms-of-service" target="_blank"> </a> · <a class="link" href="https://wplace.live/terms/privacy" target="_blank"> </a></section></div>'),
  BM = De('<dialog class="modal"><div class="modal-box sm:max-h-11/12 max-sm:size-full max-sm:rounded-none max-sm:px-4 sm:max-w-5xl"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>');

function FM(y, l) {
  kr(l, !0);
  let _ = It(l, "open", 15);
  Ii(() => {
    const de = fe => {
      fe.key === "Escape" && _(!1)
    };
    return document.addEventListener("keydown", de), () => document.removeEventListener("keydown", de)
  });
  const T = SM();
  var z = BM(),
    F = E(z),
    C = $(E(F), 2);
  {
    var o = de => {
      var fe = RM(),
        W = E(fe),
        le = E(W);
      Qg(le, {
        hasText: !0,
        size: "medium"
      });
      var Ce = $(le, 2),
        Me = E(Ce),
        Le = $(Me, 4);
      mi(), A(Ce);
      var $e = $(Ce, 2),
        Oe = E($e),
        Ve = E(Oe),
        ct = E(Ve, !0);
      A(Ve);
      var nt = $(Ve, 4),
        Ye = E(nt);
      um(Ye, {
        class: "mr-0.5 inline size-4"
      }), mi(2), A(nt);
      var dt = $(nt, 4),
        rt = E(dt);
      IM(rt, {
        class: "mr-0.5 inline size-4"
      }), mi(2), A(dt);
      var qe = $(dt, 4),
        pt = E(qe);
      AM(pt, {
        class: "mr-0.5 inline size-4"
      }), mi(2), A(qe), A(Oe), A($e), A(W);
      var at = $(W, 2),
        ht = E(at),
        Re = E(ht, !0);
      A(ht);
      var xt = $(ht, 2);
      A(at);
      var Q = $(at, 2),
        re = E(Q),
        xe = E(re, !0);
      A(re);
      var ce = $(re, 2),
        Ee = E(ce),
        Be = $(Ee),
        Ke = E(Be);
      Ld(Ke, {
        class: "size-5"
      }), A(Be);
      var tt = $(Be);
      A(ce);
      var ot = $(ce, 2),
        ft = E(ot),
        Bt = $(ft),
        At = E(Bt, !0);
      A(Bt);
      var cr = $(Bt);
      A(ot), A(Q);
      var Mt = $(Q, 2),
        yt = E(Mt),
        St = E(yt, !0);
      A(yt);
      var jt = $(yt, 2),
        Lt = E(jt);
      {
        var Gt = Fr => {
            var dr = EM(),
              Or = Et(dr);
            mi(), lt(zr => Te(Or, `${zr??""}: `), [() => qS()]), H(Fr, dr)
          },
          gr = Fr => {
            var dr = DM(),
              Or = Et(dr),
              zr = $(Or),
              tr = E(zr, !0);
            A(zr);
            var br = $(zr),
              $t = $(br);
            {
              var yr = ye => {
                  var j = zM();
                  mi(), H(ye, j)
                },
                jr = ye => {
                  var j = sr(),
                    V = Et(j);
                  {
                    var X = se => {
                      var we = LM();
                      mi(), H(se, we)
                    };
                    et(V, se => {
                      T === "Edge" && se(X)
                    }, !0)
                  }
                  H(ye, j)
                };
              et($t, ye => {
                T === "Chrome" ? ye(yr) : ye(jr, !1)
              })
            }
            lt((ye, j, V) => {
              Te(Or, `${ye??""} `), Te(tr, j), Te(br, ` ${V??""} `)
            }, [() => zS(), () => RS(), () => OS()]), H(Fr, dr)
          };
        et(Lt, Fr => {
          T !== "Chrome" && T !== "Edge" ? Fr(Gt) : Fr(gr, !1)
        })
      }
      A(jt), A(Mt);
      var ur = $(Mt, 2),
        Qt = E(ur);
      fm(Qt, {}), A(ur);
      var er = $(ur, 4),
        Dt = $(E(er), 2),
        Ir = E(Dt, !0);
      A(Dt);
      var Tr = $(Dt, 2),
        Dr = E(Tr, !0);
      A(Tr), A(er), A(fe), lt((Fr, dr, Or, zr, tr, br, $t, yr, jr, ye, j, V, X) => {
        Te(Me, `${Fr??""} `), Te(Le, ` ©
						${dr??""} `), Te(ct, Or), Te(Re, zr), Br(xt, "src", aa.language === "pt" ? "https://www.youtube.com/embed/AcE85QM4iPQ?si=wbeZD8vxOzvlB_Z9" : "https://www.youtube.com/embed/xOXtd-WzRxA?si=fHz8Z6ecXGYrDhkN"), Te(xe, tr), Te(Ee, `${br??""} `), Te(tt, ` ${$t??""}`), Te(ft, `${yr??""} `), Te(At, jr), Te(cr, ` ${ye??""}`), Te(St, j), Te(Ir, V), Te(Dr, X)
      }, [() => L1(), () => B1(), () => N1(), () => V1(), () => U1(), () => W1(), () => Y1(), () => eb(), () => ib(), () => sb(), () => AS(), () => $S(), () => HS()]), An(2, fe, () => Kn, () => ({
        duration: 300
      })), H(de, fe)
    };
    et(C, de => {
      _() && de(o)
    })
  }
  A(F);
  var K = $(F, 2),
    G = E(K),
    ie = E(G, !0);
  A(G), A(K), A(z), qn(z, () => de => {
    $r(() => {
      _() ? de.show() : de.close()
    })
  }), lt(de => Te(ie, de), [() => ec()]), bn("close", z, () => _(!1)), H(y, z), Er()
}

function OM(y) {
  return typeof y == "function"
}

function _h(y) {
  return y !== null && typeof y == "object"
}
const NM = ["string", "number", "bigint", "boolean"];

function If(y) {
  return y == null || NM.includes(typeof y) ? !0 : Array.isArray(y) ? y.every(l => If(l)) : typeof y == "object" ? Object.getPrototypeOf(y) === Object.prototype : !1
}
const Mu = Symbol("box"),
  mm = Symbol("is-writable");

function jM(y) {
  return _h(y) && Mu in y
}

function qM(y) {
  return mr.isBox(y) && mm in y
}

function mr(y) {
  let l = _t(En(y));
  return {
    [Mu]: !0,
    [mm]: !0,
    get current() {
      return b(l)
    },
    set current(_) {
      he(l, _, !0)
    }
  }
}

function VM(y, l) {
  const _ = vt(y);
  return l ? {
    [Mu]: !0,
    [mm]: !0,
    get current() {
      return b(_)
    },
    set current(T) {
      l(T)
    }
  } : {
    [Mu]: !0,
    get current() {
      return y()
    }
  }
}

function ZM(y) {
  return mr.isBox(y) ? y : OM(y) ? mr.with(y) : mr(y)
}

function $M(y) {
  return Object.entries(y).reduce((l, [_, T]) => mr.isBox(T) ? (mr.isWritableBox(T) ? Object.defineProperty(l, _, {
    get() {
      return T.current
    },
    set(z) {
      T.current = z
    }
  }) : Object.defineProperty(l, _, {
    get() {
      return T.current
    }
  }), l) : Object.assign(l, {
    [_]: T
  }), {})
}

function UM(y) {
  return mr.isWritableBox(y) ? {
    [Mu]: !0,
    get current() {
      return y.current
    }
  } : y
}
mr.from = ZM;
mr.with = VM;
mr.flatten = $M;
mr.readonly = UM;
mr.isBox = jM;
mr.isWritableBox = qM;

function GM(...y) {
  return function(l) {
    var _;
    for (const T of y)
      if (T) {
        if (l.defaultPrevented) return;
        typeof T == "function" ? T.call(this, l) : (_ = T.current) == null || _.call(this, l)
      }
  }
}
var Hl = {},
  pf, Ag;

function HM() {
  if (Ag) return pf;
  Ag = 1;
  var y = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g,
    l = /\n/g,
    _ = /^\s*/,
    T = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/,
    z = /^:\s*/,
    F = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/,
    C = /^[;\s]*/,
    o = /^\s+|\s+$/g,
    K = `
`,
    G = "/",
    ie = "*",
    de = "",
    fe = "comment",
    W = "declaration";
  pf = function(Ce, Me) {
    if (typeof Ce != "string") throw new TypeError("First argument must be a string");
    if (!Ce) return [];
    Me = Me || {};
    var Le = 1,
      $e = 1;

    function Oe(ht) {
      var Re = ht.match(l);
      Re && (Le += Re.length);
      var xt = ht.lastIndexOf(K);
      $e = ~xt ? ht.length - xt : $e + ht.length
    }

    function Ve() {
      var ht = {
        line: Le,
        column: $e
      };
      return function(Re) {
        return Re.position = new ct(ht), dt(), Re
      }
    }

    function ct(ht) {
      this.start = ht, this.end = {
        line: Le,
        column: $e
      }, this.source = Me.source
    }
    ct.prototype.content = Ce;

    function nt(ht) {
      var Re = new Error(Me.source + ":" + Le + ":" + $e + ": " + ht);
      if (Re.reason = ht, Re.filename = Me.source, Re.line = Le, Re.column = $e, Re.source = Ce, !Me.silent) throw Re
    }

    function Ye(ht) {
      var Re = ht.exec(Ce);
      if (Re) {
        var xt = Re[0];
        return Oe(xt), Ce = Ce.slice(xt.length), Re
      }
    }

    function dt() {
      Ye(_)
    }

    function rt(ht) {
      var Re;
      for (ht = ht || []; Re = qe();) Re !== !1 && ht.push(Re);
      return ht
    }

    function qe() {
      var ht = Ve();
      if (!(G != Ce.charAt(0) || ie != Ce.charAt(1))) {
        for (var Re = 2; de != Ce.charAt(Re) && (ie != Ce.charAt(Re) || G != Ce.charAt(Re + 1));) ++Re;
        if (Re += 2, de === Ce.charAt(Re - 1)) return nt("End of comment missing");
        var xt = Ce.slice(2, Re - 2);
        return $e += 2, Oe(xt), Ce = Ce.slice(Re), $e += 2, ht({
          type: fe,
          comment: xt
        })
      }
    }

    function pt() {
      var ht = Ve(),
        Re = Ye(T);
      if (Re) {
        if (qe(), !Ye(z)) return nt("property missing ':'");
        var xt = Ye(F),
          Q = ht({
            type: W,
            property: le(Re[0].replace(y, de)),
            value: xt ? le(xt[0].replace(y, de)) : de
          });
        return Ye(C), Q
      }
    }

    function at() {
      var ht = [];
      rt(ht);
      for (var Re; Re = pt();) Re !== !1 && (ht.push(Re), rt(ht));
      return ht
    }
    return dt(), at()
  };

  function le(Ce) {
    return Ce ? Ce.replace(o, de) : de
  }
  return pf
}
var kg;

function WM() {
  if (kg) return Hl;
  kg = 1;
  var y = Hl && Hl.__importDefault || function(T) {
    return T && T.__esModule ? T : {
      default: T
    }
  };
  Object.defineProperty(Hl, "__esModule", {
    value: !0
  }), Hl.default = _;
  var l = y(HM());

  function _(T, z) {
    var F = null;
    if (!T || typeof T != "string") return F;
    var C = (0, l.default)(T),
      o = typeof z == "function";
    return C.forEach(function(K) {
      if (K.type === "declaration") {
        var G = K.property,
          ie = K.value;
        o ? z(G, ie, K) : ie && (F = F || {}, F[G] = ie)
      }
    }), F
  }
  return Hl
}
var XM = WM();
const Eg = cm(XM),
  KM = Eg.default || Eg,
  YM = /\d/,
  JM = ["-", "_", "/", "."];

function QM(y = "") {
  if (!YM.test(y)) return y !== y.toLowerCase()
}

function e4(y) {
  const l = [];
  let _ = "",
    T, z;
  for (const F of y) {
    const C = JM.includes(F);
    if (C === !0) {
      l.push(_), _ = "", T = void 0;
      continue
    }
    const o = QM(F);
    if (z === !1) {
      if (T === !1 && o === !0) {
        l.push(_), _ = F, T = o;
        continue
      }
      if (T === !0 && o === !1 && _.length > 1) {
        const K = _.at(-1);
        l.push(_.slice(0, Math.max(0, _.length - 1))), _ = K + F, T = o;
        continue
      }
    }
    _ += F, T = o, z = C
  }
  return l.push(_), l
}

function vv(y) {
  return y ? e4(y).map(l => r4(l)).join("") : ""
}

function t4(y) {
  return i4(vv(y || ""))
}

function r4(y) {
  return y ? y[0].toUpperCase() + y.slice(1) : ""
}

function i4(y) {
  return y ? y[0].toLowerCase() + y.slice(1) : ""
}

function wd(y) {
  if (!y) return {};
  const l = {};

  function _(T, z) {
    if (T.startsWith("-moz-") || T.startsWith("-webkit-") || T.startsWith("-ms-") || T.startsWith("-o-")) {
      l[vv(T)] = z;
      return
    }
    if (T.startsWith("--")) {
      l[T] = z;
      return
    }
    l[t4(T)] = z
  }
  return KM(y, _), l
}

function n4(...y) {
  return (...l) => {
    for (const _ of y) typeof _ == "function" && _(...l)
  }
}

function a4(y, l) {
  const _ = RegExp(y, "g");
  return T => {
    if (typeof T != "string") throw new TypeError(`expected an argument of type string, but got ${typeof T}`);
    return T.match(_) ? T.replace(_, l) : T
  }
}
const s4 = a4(/[A-Z]/, y => `-${y.toLowerCase()}`);

function o4(y) {
  if (!y || typeof y != "object" || Array.isArray(y)) throw new TypeError(`expected an argument of type object, but got ${typeof y}`);
  return Object.keys(y).map(l => `${s4(l)}: ${y[l]};`).join(`
`)
}

function yv(y = {}) {
  return o4(y).replace(`
`, " ")
}
const xv = {
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  borderWidth: "0",
  transform: "translateX(-100%)"
};
yv(xv);
const l4 = ["onabort", "onanimationcancel", "onanimationend", "onanimationiteration", "onanimationstart", "onauxclick", "onbeforeinput", "onbeforetoggle", "onblur", "oncancel", "oncanplay", "oncanplaythrough", "onchange", "onclick", "onclose", "oncompositionend", "oncompositionstart", "oncompositionupdate", "oncontextlost", "oncontextmenu", "oncontextrestored", "oncopy", "oncuechange", "oncut", "ondblclick", "ondrag", "ondragend", "ondragenter", "ondragleave", "ondragover", "ondragstart", "ondrop", "ondurationchange", "onemptied", "onended", "onerror", "onfocus", "onfocusin", "onfocusout", "onformdata", "ongotpointercapture", "oninput", "oninvalid", "onkeydown", "onkeypress", "onkeyup", "onload", "onloadeddata", "onloadedmetadata", "onloadstart", "onlostpointercapture", "onmousedown", "onmouseenter", "onmouseleave", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onpaste", "onpause", "onplay", "onplaying", "onpointercancel", "onpointerdown", "onpointerenter", "onpointerleave", "onpointermove", "onpointerout", "onpointerover", "onpointerup", "onprogress", "onratechange", "onreset", "onresize", "onscroll", "onscrollend", "onsecuritypolicyviolation", "onseeked", "onseeking", "onselect", "onselectionchange", "onselectstart", "onslotchange", "onstalled", "onsubmit", "onsuspend", "ontimeupdate", "ontoggle", "ontouchcancel", "ontouchend", "ontouchmove", "ontouchstart", "ontransitioncancel", "ontransitionend", "ontransitionrun", "ontransitionstart", "onvolumechange", "onwaiting", "onwebkitanimationend", "onwebkitanimationiteration", "onwebkitanimationstart", "onwebkittransitionend", "onwheel"],
  c4 = new Set(l4);

function u4(y) {
  return c4.has(y)
}

function Ta(...y) {
  const l = {
    ...y[0]
  };
  for (let _ = 1; _ < y.length; _++) {
    const T = y[_];
    if (T) {
      for (const z of Object.keys(T)) {
        const F = l[z],
          C = T[z],
          o = typeof F == "function",
          K = typeof C == "function";
        if (o && u4(z)) {
          const G = F,
            ie = C;
          l[z] = GM(G, ie)
        } else if (o && K) l[z] = n4(F, C);
        else if (z === "class") {
          const G = If(F),
            ie = If(C);
          G && ie ? l[z] = Su(F, C) : G ? l[z] = Su(F) : ie && (l[z] = Su(C))
        } else if (z === "style") {
          const G = typeof F == "object",
            ie = typeof C == "object",
            de = typeof F == "string",
            fe = typeof C == "string";
          if (G && ie) l[z] = {
            ...F,
            ...C
          };
          else if (G && fe) {
            const W = wd(C);
            l[z] = {
              ...F,
              ...W
            }
          } else if (de && ie) {
            const W = wd(F);
            l[z] = {
              ...W,
              ...C
            }
          } else if (de && fe) {
            const W = wd(F),
              le = wd(C);
            l[z] = {
              ...W,
              ...le
            }
          } else G ? l[z] = F : ie ? l[z] = C : de ? l[z] = F : fe && (l[z] = C)
        } else l[z] = C !== void 0 ? C : F
      }
      for (const z of Object.getOwnPropertySymbols(T)) {
        const F = l[z],
          C = T[z];
        l[z] = C !== void 0 ? C : F
      }
    }
  }
  return typeof l.style == "object" && (l.style = yv(l.style).replaceAll(`
`, " ")), l.hidden !== !0 && (l.hidden = void 0, delete l.hidden), l.disabled !== !0 && (l.disabled = void 0, delete l.disabled), l
}
const h4 = typeof window < "u" ? window : void 0;

function d4(y) {
  let l = y.activeElement;
  for (; l != null && l.shadowRoot;) {
    const _ = l.shadowRoot.activeElement;
    if (_ === l) break;
    l = _
  }
  return l
}
var rc, Du;
class p4 {
  constructor(l = {}) {
    Pr(this, rc);
    Pr(this, Du);
    const {
      window: _ = h4,
      document: T = _ == null ? void 0 : _.document
    } = l;
    _ !== void 0 && (Xn(this, rc, T), Xn(this, Du, Gg(z => {
      const F = Pu(_, "focusin", z),
        C = Pu(_, "focusout", z);
      return () => {
        F(), C()
      }
    })))
  }
  get current() {
    var l;
    return (l = st(this, Du)) == null || l.call(this), st(this, rc) ? d4(st(this, rc)) : null
  }
}
rc = new WeakMap, Du = new WeakMap;
new p4;
var Ru, bs;
class _m {
  constructor(l) {
    Pr(this, Ru);
    Pr(this, bs);
    Xn(this, Ru, l), Xn(this, bs, Symbol(l))
  }
  get key() {
    return st(this, bs)
  }
  exists() {
    return ox(st(this, bs))
  }
  get() {
    const l = vg(st(this, bs));
    if (l === void 0) throw new Error(`Context "${st(this,Ru)}" not found`);
    return l
  }
  getOr(l) {
    const _ = vg(st(this, bs));
    return _ === void 0 ? l : _
  }
  set(l) {
    return lx(st(this, bs), l)
  }
}
Ru = new WeakMap, bs = new WeakMap;

function f4(y, l) {
  switch (y) {
    case "post":
      $r(l);
      break;
    case "pre":
      Kf(l);
      break
  }
}

function bv(y, l, _, T = {}) {
  const {
    lazy: z = !1
  } = T;
  let F = !z,
    C = Array.isArray(y) ? [] : void 0;
  f4(l, () => {
    const o = Array.isArray(y) ? y.map(G => G()) : y();
    if (!F) {
      F = !0, C = o;
      return
    }
    const K = so(() => _(o, C));
    return C = o, K
  })
}

function oo(y, l, _) {
  bv(y, "post", l, _)
}

function m4(y, l, _) {
  bv(y, "pre", l, _)
}
oo.pre = m4;
var ic;
class _4 {
  constructor(l, _) {
    Pr(this, ic, _t(void 0));
    _ !== void 0 && he(st(this, ic), _, !0), oo(() => l(), (T, z) => {
      he(st(this, ic), z, !0)
    })
  }
  get current() {
    return b(st(this, ic))
  }
}
ic = new WeakMap;

function g4(y, l) {
  return setTimeout(l, y)
}

function Wl(y) {
  Vg().then(y)
}
const v4 = 1,
  y4 = 9,
  x4 = 11;

function b4(y) {
  return _h(y) && y.nodeType === v4 && typeof y.nodeName == "string"
}

function wv(y) {
  return _h(y) && y.nodeType === y4
}

function w4(y) {
  var l;
  return _h(y) && ((l = y.constructor) == null ? void 0 : l.name) === "VisualViewport"
}

function T4(y) {
  return _h(y) && y.nodeType !== void 0
}

function C4(y) {
  return T4(y) && y.nodeType === x4 && "host" in y
}

function S4(y) {
  return wv(y) ? y : w4(y) ? y.document : (y == null ? void 0 : y.ownerDocument) ?? document
}

function Tv(y) {
  var l;
  return C4(y) ? Tv(y.host) : wv(y) ? y.defaultView ?? window : b4(y) ? ((l = y.ownerDocument) == null ? void 0 : l.defaultView) ?? window : window
}

function P4(y) {
  let l = y.activeElement;
  for (; l != null && l.shadowRoot;) {
    const _ = l.shadowRoot.activeElement;
    if (_ === l) break;
    l = _
  }
  return l
}
var Bu;
class I4 {
  constructor(l) {
    fr(this, "element");
    Pr(this, Bu, vt(() => this.element.current ? this.element.current.getRootNode() ?? document : document));
    fr(this, "getDocument", () => S4(this.root));
    fr(this, "getWindow", () => this.getDocument().defaultView ?? window);
    fr(this, "getActiveElement", () => P4(this.root));
    fr(this, "isActiveElement", l => l === this.getActiveElement());
    fr(this, "querySelector", l => this.root ? this.root.querySelector(l) : null);
    fr(this, "querySelectorAll", l => this.root ? this.root.querySelectorAll(l) : []);
    fr(this, "setTimeout", (l, _) => this.getWindow().setTimeout(l, _));
    fr(this, "clearTimeout", l => this.getWindow().clearTimeout(l));
    typeof l == "function" ? this.element = mr.with(l) : this.element = l
  }
  get root() {
    return b(st(this, Bu))
  }
  set root(l) {
    he(st(this, Bu), l)
  }
  getElementById(l) {
    return this.root.getElementById(l)
  }
}
Bu = new WeakMap;

function Ea(y, l) {
  return {
    [Nx()]: _ => mr.isBox(y) ? (y.current = _, so(() => l == null ? void 0 : l(_)), () => {
      "isConnected" in _ && _.isConnected || (y.current = null, l == null || l(null))
    }) : (y(_), so(() => l == null ? void 0 : l(_)), () => {
      "isConnected" in _ && _.isConnected || (y(null), l == null || l(null))
    })
  }
}

function M4(y) {
  return y ? "true" : "false"
}

function A4(y) {
  return y ? "true" : "false"
}

function k4(y) {
  return y ? "" : void 0
}

function E4(y) {
  return y ? "true" : "false"
}

function z4(y) {
  return y ? "" : void 0
}

function L4(y) {
  return y ? !0 : void 0
}
var nc, Fu;
class D4 {
  constructor(l) {
    Pr(this, nc);
    Pr(this, Fu);
    fr(this, "attrs");
    Xn(this, nc, l.getVariant ? l.getVariant() : null), Xn(this, Fu, st(this, nc) ? `data-${st(this,nc)}-` : `data-${l.component}-`), this.getAttr = this.getAttr.bind(this), this.selector = this.selector.bind(this), this.attrs = Object.fromEntries(l.parts.map(_ => [_, this.getAttr(_)]))
  }
  getAttr(l, _) {
    return _ ? `data-${_}-${l}` : `${st(this,Fu)}${l}`
  }
  selector(l, _) {
    return `[${this.getAttr(l,_)}]`
  }
}
nc = new WeakMap, Fu = new WeakMap;

function Cv(y) {
  const l = new D4(y);
  return {
    ...l.attrs,
    selector: l.selector,
    getAttr: l.getAttr
  }
}
const R4 = "ArrowDown",
  B4 = "ArrowLeft",
  F4 = "ArrowRight",
  O4 = "ArrowUp",
  N4 = "End",
  j4 = "Enter",
  q4 = "Home",
  V4 = "p",
  Z4 = "n",
  $4 = "j",
  U4 = "k",
  G4 = "h",
  H4 = "l";

function Au() {}

function za(y, l) {
  return `bits-${y}`
}

function W4(y) {
  if (!y) return null;
  for (const l of y.childNodes)
    if (l.nodeType !== Node.COMMENT_NODE) return l;
  return null
}
globalThis.bitsIdCounter ?? (globalThis.bitsIdCounter = {
  current: 0
});

function X4(y = "bits") {
  return globalThis.bitsIdCounter.current++, `${y}-${globalThis.bitsIdCounter.current}`
}

function K4(y, l) {
  let _ = y.nextElementSibling;
  for (; _;) {
    if (_.matches(l)) return _;
    _ = _.nextElementSibling
  }
}

function Y4(y, l) {
  let _ = y.previousElementSibling;
  for (; _;) {
    if (_.matches(l)) return _;
    _ = _.previousElementSibling
  }
}

function Sv(y) {
  if (typeof CSS < "u" && typeof CSS.escape == "function") return CSS.escape(y);
  const l = y.length;
  let _ = -1,
    T, z = "";
  const F = y.charCodeAt(0);
  if (l === 1 && F === 45) return "\\" + y;
  for (; ++_ < l;) {
    if (T = y.charCodeAt(_), T === 0) {
      z += "�";
      continue
    }
    if (T >= 1 && T <= 31 || T === 127 || _ === 0 && T >= 48 && T <= 57 || _ === 1 && T >= 48 && T <= 57 && F === 45) {
      z += "\\" + T.toString(16) + " ";
      continue
    }
    if (T >= 128 || T === 45 || T === 95 || T >= 48 && T <= 57 || T >= 65 && T <= 90 || T >= 97 && T <= 122) {
      z += y.charAt(_);
      continue
    }
    z += "\\" + y.charAt(_)
  }
  return z
}
const Ko = "data-value",
  da = Cv({
    component: "command",
    parts: ["root", "list", "input", "separator", "loading", "empty", "group", "group-items", "group-heading", "item", "viewport", "input-label"]
  }),
  Xl = da.selector("group"),
  ff = da.selector("group-items"),
  zg = da.selector("group-heading"),
  Pv = da.selector("item"),
  mf = `${da.selector("item")}:not([aria-disabled="true"])`,
  tl = new _m("Command.Root"),
  J4 = new _m("Command.List"),
  ku = new _m("Command.Group"),
  Lg = {
    search: "",
    value: "",
    filtered: {
      count: 0,
      items: new Map,
      groups: new Set
    }
  };
var ac, Ou, Nu, ju, qu, Vu, Zu, $u, lr, Iv, Id, Af, Md, Ad, kd, io, Mv, Av, kf, bu, Ef, zf, kv, wu, Lf, Df, Ev, Tu, Cu, Uu;
const ym = class ym {
  constructor(l) {
    Pr(this, lr);
    fr(this, "opts");
    fr(this, "attachment");
    Pr(this, ac, !1);
    Pr(this, Ou, !0);
    fr(this, "sortAfterTick", !1);
    fr(this, "sortAndFilterAfterTick", !1);
    fr(this, "allItems", new Set);
    fr(this, "allGroups", new Map);
    fr(this, "allIds", new Map);
    Pr(this, Nu, _t(0));
    Pr(this, ju, _t(null));
    Pr(this, qu, _t(null));
    Pr(this, Vu, _t(null));
    Pr(this, Zu, _t(Lg));
    Pr(this, $u, _t(En(Lg)));
    Pr(this, Uu, vt(() => ({
      id: this.opts.id.current,
      role: "application",
      [da.root]: "",
      tabindex: -1,
      onkeydown: this.onkeydown,
      ...this.attachment
    })));
    this.opts = l, this.attachment = Ea(this.opts.ref);
    const _ = {
      ...this._commandState,
      value: this.opts.value.current ?? ""
    };
    this._commandState = _, this.commandState = _, this.onkeydown = this.onkeydown.bind(this)
  }
  static create(l) {
    return tl.set(new ym(l))
  }
  get key() {
    return b(st(this, Nu))
  }
  set key(l) {
    he(st(this, Nu), l, !0)
  }
  get viewportNode() {
    return b(st(this, ju))
  }
  set viewportNode(l) {
    he(st(this, ju), l, !0)
  }
  get inputNode() {
    return b(st(this, qu))
  }
  set inputNode(l) {
    he(st(this, qu), l, !0)
  }
  get labelNode() {
    return b(st(this, Vu))
  }
  set labelNode(l) {
    he(st(this, Vu), l, !0)
  }
  get commandState() {
    return b(st(this, Zu))
  }
  set commandState(l) {
    he(st(this, Zu), l)
  }
  get _commandState() {
    return b(st(this, $u))
  }
  set _commandState(l) {
    he(st(this, $u), l, !0)
  }
  setState(l, _, T) {
    Object.is(this._commandState[l], _) || (this._commandState[l] = _, l === "search" ? (Rr(this, lr, kd).call(this), Rr(this, lr, Md).call(this)) : l === "value" && (T || Rr(this, lr, Mv).call(this)), Rr(this, lr, Id).call(this))
  }
  setValue(l, _) {
    l !== this.opts.value.current && l === "" && Wl(() => {
      this.key++
    }), this.setState("value", l, _), this.opts.value.current = l
  }
  getValidItems() {
    const l = this.opts.ref.current;
    return l ? Array.from(l.querySelectorAll(mf)).filter(T => !!T) : []
  }
  getVisibleItems() {
    const l = this.opts.ref.current;
    return l ? Array.from(l.querySelectorAll(Pv)).filter(T => !!T) : []
  }
  get itemsGrid() {
    var o, K, G, ie;
    if (!this.isGrid) return [];
    const l = this.opts.columns.current ?? 1,
      _ = this.getVisibleItems(),
      T = [
        []
      ];
    let z = (o = _[0]) == null ? void 0 : o.getAttribute("data-group"),
      F = 0,
      C = 0;
    for (let de = 0; de < _.length; de++) {
      const fe = _[de],
        W = fe == null ? void 0 : fe.getAttribute("data-group");
      z !== W ? (z = W, F = 1, C++, T.push([{
        index: de,
        firstRowOfGroup: !0,
        ref: fe
      }])) : (F++, F > l && (C++, F = 1, T.push([])), (ie = T[C]) == null || ie.push({
        index: de,
        firstRowOfGroup: ((G = (K = T[C]) == null ? void 0 : K[0]) == null ? void 0 : G.firstRowOfGroup) ?? de === 0,
        ref: fe
      }))
    }
    return T
  }
  updateSelectedToIndex(l) {
    const _ = this.getValidItems()[l];
    _ && this.setValue(_.getAttribute(Ko) ?? "")
  }
  updateSelectedByItem(l) {
    const _ = Rr(this, lr, io).call(this),
      T = this.getValidItems(),
      z = T.findIndex(C => C === _);
    let F = T[z + l];
    this.opts.loop.current && (F = z + l < 0 ? T[T.length - 1] : z + l === T.length ? T[0] : T[z + l]), F && this.setValue(F.getAttribute(Ko) ?? "")
  }
  updateSelectedByGroup(l) {
    const _ = Rr(this, lr, io).call(this);
    let T = _ == null ? void 0 : _.closest(Xl),
      z;
    for (; T && !z;) T = l > 0 ? K4(T, Xl) : Y4(T, Xl), z = T == null ? void 0 : T.querySelector(mf);
    z ? this.setValue(z.getAttribute(Ko) ?? "") : this.updateSelectedByItem(l)
  }
  registerValue(l, _) {
    var T;
    return l && l === ((T = this.allIds.get(l)) == null ? void 0 : T.value) || this.allIds.set(l, {
      value: l,
      keywords: _
    }), this._commandState.filtered.items.set(l, Rr(this, lr, Af).call(this, l, _)), this.sortAfterTick || (this.sortAfterTick = !0, Wl(() => {
      Rr(this, lr, Md).call(this), this.sortAfterTick = !1
    })), () => {
      this.allIds.delete(l)
    }
  }
  registerItem(l, _) {
    return this.allItems.add(l), _ && (this.allGroups.has(_) ? this.allGroups.get(_).add(l) : this.allGroups.set(_, new Set([l]))), this.sortAndFilterAfterTick || (this.sortAndFilterAfterTick = !0, Wl(() => {
      Rr(this, lr, kd).call(this), Rr(this, lr, Md).call(this), this.sortAndFilterAfterTick = !1
    })), Rr(this, lr, Id).call(this), () => {
      const T = Rr(this, lr, io).call(this);
      this.allIds.delete(l), this.allItems.delete(l), this.commandState.filtered.items.delete(l), Rr(this, lr, kd).call(this), (T == null ? void 0 : T.getAttribute("id")) === l && Rr(this, lr, Ad).call(this), Rr(this, lr, Id).call(this)
    }
  }
  registerGroup(l) {
    return this.allGroups.has(l) || this.allGroups.set(l, new Set), () => {
      this.allIds.delete(l), this.allGroups.delete(l)
    }
  }
  get isGrid() {
    return this.opts.columns.current !== null
  }
  onkeydown(l) {
    const _ = this.opts.vimBindings.current && l.ctrlKey;
    switch (l.key) {
      case Z4:
      case $4: {
        _ && (this.isGrid ? Rr(this, lr, Ef).call(this, l) : Rr(this, lr, bu).call(this, l));
        break
      }
      case H4: {
        _ && this.isGrid && Rr(this, lr, bu).call(this, l);
        break
      }
      case R4:
        this.isGrid ? Rr(this, lr, Ef).call(this, l) : Rr(this, lr, bu).call(this, l);
        break;
      case F4:
        if (!this.isGrid) break;
        Rr(this, lr, bu).call(this, l);
        break;
      case V4:
      case U4: {
        _ && (this.isGrid ? Rr(this, lr, Df).call(this, l) : Rr(this, lr, Cu).call(this, l));
        break
      }
      case G4: {
        _ && this.isGrid && Rr(this, lr, Cu).call(this, l);
        break
      }
      case O4:
        this.isGrid ? Rr(this, lr, Df).call(this, l) : Rr(this, lr, Cu).call(this, l);
        break;
      case B4:
        if (!this.isGrid) break;
        Rr(this, lr, Cu).call(this, l);
        break;
      case q4:
        l.preventDefault(), this.updateSelectedToIndex(0);
        break;
      case N4:
        l.preventDefault(), Rr(this, lr, kf).call(this);
        break;
      case j4:
        if (!l.isComposing && l.keyCode !== 229) {
          l.preventDefault();
          const T = Rr(this, lr, io).call(this);
          T && (T == null || T.click())
        }
    }
  }
  get props() {
    return b(st(this, Uu))
  }
  set props(l) {
    he(st(this, Uu), l)
  }
};
ac = new WeakMap, Ou = new WeakMap, Nu = new WeakMap, ju = new WeakMap, qu = new WeakMap, Vu = new WeakMap, Zu = new WeakMap, $u = new WeakMap, lr = new WeakSet, Iv = function() {
  return Ox(this._commandState)
}, Id = function() {
  st(this, ac) || (Xn(this, ac, !0), Wl(() => {
    var T, z;
    Xn(this, ac, !1);
    const l = Rr(this, lr, Iv).call(this);
    !Object.is(this.commandState, l) && (this.commandState = l, (z = (T = this.opts.onStateChange) == null ? void 0 : T.current) == null || z.call(T, l))
  }))
}, Af = function(l, _) {
  const T = this.opts.filter.current ?? Dv;
  return l ? T(l, this._commandState.search, _) : 0
}, Md = function() {
  var C;
  if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
    Rr(this, lr, Ad).call(this);
    return
  }
  const l = this._commandState.filtered.items,
    _ = [];
  for (const o of this._commandState.filtered.groups) {
    const K = this.allGroups.get(o);
    let G = 0;
    if (!K) {
      _.push([o, G]);
      continue
    }
    for (const ie of K) {
      const de = l.get(ie);
      G = Math.max(de ?? 0, G)
    }
    _.push([o, G])
  }
  const T = this.viewportNode,
    z = this.getValidItems().sort((o, K) => {
      const G = o.getAttribute("data-value"),
        ie = K.getAttribute("data-value"),
        de = l.get(G) ?? 0;
      return (l.get(ie) ?? 0) - de
    });
  for (const o of z) {
    const K = o.closest(ff);
    if (K) {
      const G = o.parentElement === K ? o : o.closest(`${ff} > *`);
      G && K.appendChild(G)
    } else {
      const G = o.parentElement === T ? o : o.closest(`${ff} > *`);
      G && (T == null || T.appendChild(G))
    }
  }
  const F = _.sort((o, K) => K[1] - o[1]);
  for (const o of F) {
    const K = T == null ? void 0 : T.querySelector(`${Xl}[${Ko}="${Sv(o[0])}"]`);
    (C = K == null ? void 0 : K.parentElement) == null || C.appendChild(K)
  }
  Rr(this, lr, Ad).call(this)
}, Ad = function() {
  Wl(() => {
    const l = this.getValidItems().find(z => z.getAttribute("aria-disabled") !== "true"),
      _ = l == null ? void 0 : l.getAttribute(Ko),
      T = st(this, Ou) && this.opts.disableInitialScroll.current;
    this.setValue(_ ?? "", T), Xn(this, Ou, !1)
  })
}, kd = function() {
  var _, T;
  if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
    this._commandState.filtered.count = this.allItems.size;
    return
  }
  this._commandState.filtered.groups = new Set;
  let l = 0;
  for (const z of this.allItems) {
    const F = ((_ = this.allIds.get(z)) == null ? void 0 : _.value) ?? "",
      C = ((T = this.allIds.get(z)) == null ? void 0 : T.keywords) ?? [],
      o = Rr(this, lr, Af).call(this, F, C);
    this._commandState.filtered.items.set(z, o), o > 0 && l++
  }
  for (const [z, F] of this.allGroups)
    for (const C of F) {
      const o = this._commandState.filtered.items.get(C);
      if (o && o > 0) {
        this._commandState.filtered.groups.add(z);
        break
      }
    }
  this._commandState.filtered.count = l
}, io = function() {
  const l = this.opts.ref.current;
  if (!l) return;
  const _ = l.querySelector(`${mf}[data-selected]`);
  if (_) return _
}, Mv = function() {
  Wl(() => {
    var T, z, F, C, o;
    const l = Rr(this, lr, io).call(this);
    if (!l) return;
    const _ = (T = l.parentElement) == null ? void 0 : T.parentElement;
    if (_) {
      if (this.isGrid) {
        const K = Rr(this, lr, Av).call(this, l);
        if (l.scrollIntoView({
            block: "nearest"
          }), K) {
          const G = (z = l == null ? void 0 : l.closest(Xl)) == null ? void 0 : z.querySelector(zg);
          G == null || G.scrollIntoView({
            block: "nearest"
          });
          return
        }
      } else {
        const K = W4(_);
        if (K && ((F = K.dataset) == null ? void 0 : F.value) === ((C = l.dataset) == null ? void 0 : C.value)) {
          const G = (o = l == null ? void 0 : l.closest(Xl)) == null ? void 0 : o.querySelector(zg);
          G == null || G.scrollIntoView({
            block: "nearest"
          });
          return
        }
      }
      l.scrollIntoView({
        block: "nearest"
      })
    }
  })
}, Av = function(l) {
  const _ = this.itemsGrid;
  if (_.length === 0) return !1;
  for (let T = 0; T < _.length; T++) {
    const z = _[T];
    if (z !== void 0)
      for (let F = 0; F < z.length; F++) {
        const C = z[F];
        if (!(C === void 0 || C.ref !== l)) return C.firstRowOfGroup
      }
  }
  return !1
}, kf = function() {
  return this.updateSelectedToIndex(this.getValidItems().length - 1)
}, bu = function(l) {
  l.preventDefault(), l.metaKey ? Rr(this, lr, kf).call(this) : l.altKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(1)
}, Ef = function(l) {
  this.opts.columns.current !== null && (l.preventDefault(), l.metaKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(Rr(this, lr, kv).call(this, l)))
}, zf = function(l, _) {
  if (_.length === 0) return null;
  for (let T = 0; T < _.length; T++) {
    const z = _[T];
    if (z !== void 0)
      for (let F = 0; F < z.length; F++) {
        const C = z[F];
        if (!(C === void 0 || C.ref !== l)) return {
          columnIndex: F,
          rowIndex: T
        }
      }
  }
  return null
}, kv = function(l) {
  const _ = this.itemsGrid,
    T = Rr(this, lr, io).call(this);
  if (!T) return 0;
  const z = Rr(this, lr, zf).call(this, T, _);
  if (!z) return 0;
  let F = null;
  const C = l.altKey ? 1 : 0;
  if (l.altKey && z.rowIndex === _.length - 2 && !this.opts.loop.current) F = Rr(this, lr, wu).call(this, {
    start: _.length - 1,
    end: _.length,
    expectedColumnIndex: z.columnIndex,
    grid: _
  });
  else if (z.rowIndex === _.length - 1) {
    if (!this.opts.loop.current) return 0;
    F = Rr(this, lr, wu).call(this, {
      start: 0 + C,
      end: z.rowIndex,
      expectedColumnIndex: z.columnIndex,
      grid: _
    })
  } else F = Rr(this, lr, wu).call(this, {
    start: z.rowIndex + 1 + C,
    end: _.length,
    expectedColumnIndex: z.columnIndex,
    grid: _
  }), F === null && this.opts.loop.current && (F = Rr(this, lr, wu).call(this, {
    start: 0,
    end: z.rowIndex,
    expectedColumnIndex: z.columnIndex,
    grid: _
  }));
  return Rr(this, lr, Lf).call(this, T, F)
}, wu = function({
  start: l,
  end: _,
  grid: T,
  expectedColumnIndex: z
}) {
  var C;
  let F = null;
  for (let o = l; o < _; o++) {
    const K = T[o];
    if (F = ((C = K[z]) == null ? void 0 : C.ref) ?? null, F !== null && Td(F)) {
      F = null;
      continue
    }
    if (F === null)
      for (let G = K.length - 1; G >= 0; G--) {
        const ie = K[K.length - 1];
        if (!(ie === void 0 || Td(ie.ref))) {
          F = ie.ref;
          break
        }
      }
    break
  }
  return F
}, Lf = function(l, _) {
  if (_ === null) return 0;
  const T = this.getValidItems(),
    z = T.findIndex(C => C === l);
  return T.findIndex(C => C === _) - z
}, Df = function(l) {
  this.opts.columns.current !== null && (l.preventDefault(), l.metaKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(Rr(this, lr, Ev).call(this, l)))
}, Ev = function(l) {
  const _ = this.itemsGrid,
    T = Rr(this, lr, io).call(this);
  if (T === void 0) return 0;
  const z = Rr(this, lr, zf).call(this, T, _);
  if (z === null) return 0;
  let F = null;
  const C = l.altKey ? 1 : 0;
  if (l.altKey && z.rowIndex === 1 && this.opts.loop.current === !1) F = Rr(this, lr, Tu).call(this, {
    start: 0,
    end: 0,
    expectedColumnIndex: z.columnIndex,
    grid: _
  });
  else if (z.rowIndex === 0) {
    if (this.opts.loop.current === !1) return 0;
    F = Rr(this, lr, Tu).call(this, {
      start: _.length - 1 - C,
      end: z.rowIndex + 1,
      expectedColumnIndex: z.columnIndex,
      grid: _
    })
  } else F = Rr(this, lr, Tu).call(this, {
    start: z.rowIndex - 1 - C,
    end: 0,
    expectedColumnIndex: z.columnIndex,
    grid: _
  }), F === null && this.opts.loop.current && (F = Rr(this, lr, Tu).call(this, {
    start: _.length - 1,
    end: z.rowIndex + 1,
    expectedColumnIndex: z.columnIndex,
    grid: _
  }));
  return Rr(this, lr, Lf).call(this, T, F)
}, Tu = function({
  start: l,
  end: _,
  grid: T,
  expectedColumnIndex: z
}) {
  var C;
  let F = null;
  for (let o = l; o >= _; o--) {
    const K = T[o];
    if (K !== void 0) {
      if (F = ((C = K[z]) == null ? void 0 : C.ref) ?? null, F !== null && Td(F)) {
        F = null;
        continue
      }
      if (F === null)
        for (let G = K.length - 1; G >= 0; G--) {
          const ie = K[K.length - 1];
          if (!(ie === void 0 || Td(ie.ref))) {
            F = ie.ref;
            break
          }
        }
      break
    }
  }
  return F
}, Cu = function(l) {
  l.preventDefault(), l.metaKey ? this.updateSelectedToIndex(0) : l.altKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(-1)
}, Uu = new WeakMap;
let Mf = ym;

function Td(y) {
  return y.getAttribute("aria-disabled") === "true"
}
var Gu, Hu, Wu;
const xm = class xm {
  constructor(l, _) {
    fr(this, "opts");
    fr(this, "root");
    fr(this, "attachment");
    Pr(this, Gu, vt(() => this.root._commandState.filtered.count === 0 && st(this, Hu) === !1 || this.opts.forceMount.current));
    Pr(this, Hu, !0);
    Pr(this, Wu, vt(() => ({
      id: this.opts.id.current,
      role: "presentation",
      [da.empty]: "",
      ...this.attachment
    })));
    this.opts = l, this.root = _, this.attachment = Ea(this.opts.ref), Kf(() => {
      Xn(this, Hu, !1)
    })
  }
  static create(l) {
    return new xm(l, tl.get())
  }
  get shouldRender() {
    return b(st(this, Gu))
  }
  set shouldRender(l) {
    he(st(this, Gu), l)
  }
  get props() {
    return b(st(this, Wu))
  }
  set props(l) {
    he(st(this, Wu), l)
  }
};
Gu = new WeakMap, Hu = new WeakMap, Wu = new WeakMap;
let Rf = xm;
var Xu, Ku, Yu, Ju;
const bm = class bm {
  constructor(l, _) {
    fr(this, "opts");
    fr(this, "root");
    fr(this, "attachment");
    Pr(this, Xu, vt(() => this.opts.forceMount.current || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search ? !0 : this.root._commandState.filtered.groups.has(this.trueValue)));
    Pr(this, Ku, _t(null));
    Pr(this, Yu, _t(""));
    Pr(this, Ju, vt(() => ({
      id: this.opts.id.current,
      role: "presentation",
      hidden: this.shouldRender ? void 0 : !0,
      "data-value": this.trueValue,
      [da.group]: "",
      ...this.attachment
    })));
    this.opts = l, this.root = _, this.attachment = Ea(this.opts.ref), this.trueValue = l.value.current ?? l.id.current, oo(() => this.trueValue, () => this.root.registerGroup(this.trueValue)), $r(() => this.opts.value.current ? (this.trueValue = this.opts.value.current, this.root.registerValue(this.opts.value.current)) : this.headingNode && this.headingNode.textContent ? (this.trueValue = this.headingNode.textContent.trim().toLowerCase(), this.root.registerValue(this.trueValue)) : (this.trueValue = `-----${this.opts.id.current}`, this.root.registerValue(this.trueValue)))
  }
  static create(l) {
    return ku.set(new bm(l, tl.get()))
  }
  get shouldRender() {
    return b(st(this, Xu))
  }
  set shouldRender(l) {
    he(st(this, Xu), l)
  }
  get headingNode() {
    return b(st(this, Ku))
  }
  set headingNode(l) {
    he(st(this, Ku), l, !0)
  }
  get trueValue() {
    return b(st(this, Yu))
  }
  set trueValue(l) {
    he(st(this, Yu), l, !0)
  }
  get props() {
    return b(st(this, Ju))
  }
  set props(l) {
    he(st(this, Ju), l)
  }
};
Xu = new WeakMap, Ku = new WeakMap, Yu = new WeakMap, Ju = new WeakMap;
let Bf = bm;
var Qu;
const wm = class wm {
  constructor(l, _) {
    fr(this, "opts");
    fr(this, "group");
    fr(this, "attachment");
    Pr(this, Qu, vt(() => ({
      id: this.opts.id.current,
      [da["group-heading"]]: "",
      ...this.attachment
    })));
    this.opts = l, this.group = _, this.attachment = Ea(this.opts.ref, T => this.group.headingNode = T)
  }
  static create(l) {
    return new wm(l, ku.get())
  }
  get props() {
    return b(st(this, Qu))
  }
  set props(l) {
    he(st(this, Qu), l)
  }
};
Qu = new WeakMap;
let Ff = wm;
var eh;
const Tm = class Tm {
  constructor(l, _) {
    fr(this, "opts");
    fr(this, "group");
    fr(this, "attachment");
    Pr(this, eh, vt(() => {
      var l;
      return {
        id: this.opts.id.current,
        role: "group",
        [da["group-items"]]: "",
        "aria-labelledby": ((l = this.group.headingNode) == null ? void 0 : l.id) ?? void 0,
        ...this.attachment
      }
    }));
    this.opts = l, this.group = _, this.attachment = Ea(this.opts.ref)
  }
  static create(l) {
    return new Tm(l, ku.get())
  }
  get props() {
    return b(st(this, eh))
  }
  set props(l) {
    he(st(this, eh), l)
  }
};
eh = new WeakMap;
let Of = Tm;
var Dd, th;
const Cm = class Cm {
  constructor(l, _) {
    fr(this, "opts");
    fr(this, "root");
    fr(this, "attachment");
    Pr(this, Dd, vt(() => {
      var _;
      const l = (_ = this.root.viewportNode) == null ? void 0 : _.querySelector(`${Pv}[${Ko}="${Sv(this.root.opts.value.current)}"]`);
      if (l != null) return l.getAttribute("id") ?? void 0
    }));
    Pr(this, th, vt(() => {
      var l, _;
      return {
        id: this.opts.id.current,
        type: "text",
        [da.input]: "",
        autocomplete: "off",
        autocorrect: "off",
        spellcheck: !1,
        "aria-autocomplete": "list",
        role: "combobox",
        "aria-expanded": A4(!0),
        "aria-controls": ((l = this.root.viewportNode) == null ? void 0 : l.id) ?? void 0,
        "aria-labelledby": ((_ = this.root.labelNode) == null ? void 0 : _.id) ?? void 0,
        "aria-activedescendant": b(st(this, Dd)),
        ...this.attachment
      }
    }));
    this.opts = l, this.root = _, this.attachment = Ea(this.opts.ref, T => this.root.inputNode = T), oo(() => this.opts.ref.current, () => {
      const T = this.opts.ref.current;
      T && this.opts.autofocus.current && g4(10, () => T.focus())
    }), oo(() => this.opts.value.current, () => {
      this.root.commandState.search !== this.opts.value.current && this.root.setState("search", this.opts.value.current)
    })
  }
  static create(l) {
    return new Cm(l, tl.get())
  }
  get props() {
    return b(st(this, th))
  }
  set props(l) {
    he(st(this, th), l)
  }
};
Dd = new WeakMap, th = new WeakMap;
let Nf = Cm;
var no, Rd, rh, ih, nh, el, zv, qf, ah;
const Sm = class Sm {
  constructor(l, _) {
    Pr(this, el);
    fr(this, "opts");
    fr(this, "root");
    fr(this, "attachment");
    Pr(this, no, null);
    Pr(this, Rd, vt(() => {
      var l;
      return this.opts.forceMount.current || ((l = st(this, no)) == null ? void 0 : l.opts.forceMount.current) === !0
    }));
    Pr(this, rh, vt(() => {
      if (this.opts.ref.current, b(st(this, Rd)) || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search) return !0;
      const l = this.root.commandState.filtered.items.get(this.trueValue);
      return l === void 0 ? !1 : l > 0
    }));
    Pr(this, ih, vt(() => this.root.opts.value.current === this.trueValue && this.trueValue !== ""));
    Pr(this, nh, _t(""));
    Pr(this, ah, vt(() => {
      var l;
      return {
        id: this.opts.id.current,
        "aria-disabled": M4(this.opts.disabled.current),
        "aria-selected": E4(this.isSelected),
        "data-disabled": k4(this.opts.disabled.current),
        "data-selected": z4(this.isSelected),
        "data-value": this.trueValue,
        "data-group": (l = st(this, no)) == null ? void 0 : l.trueValue,
        [da.item]: "",
        role: "option",
        onpointermove: this.onpointermove,
        onclick: this.onclick,
        ...this.attachment
      }
    }));
    this.opts = l, this.root = _, Xn(this, no, ku.getOr(null)), this.trueValue = l.value.current, this.attachment = Ea(this.opts.ref), oo([() => this.trueValue, () => {
      var T;
      return (T = st(this, no)) == null ? void 0 : T.trueValue
    }, () => this.opts.forceMount.current], () => {
      var T;
      if (!this.opts.forceMount.current) return this.root.registerItem(this.trueValue, (T = st(this, no)) == null ? void 0 : T.trueValue)
    }), oo([() => this.opts.value.current, () => this.opts.ref.current], () => {
      var T, z;
      !this.opts.value.current && ((T = this.opts.ref.current) != null && T.textContent) && (this.trueValue = this.opts.ref.current.textContent.trim()), this.root.registerValue(this.trueValue, l.keywords.current.map(F => F.trim())), (z = this.opts.ref.current) == null || z.setAttribute(Ko, this.trueValue)
    }), this.onclick = this.onclick.bind(this), this.onpointermove = this.onpointermove.bind(this)
  }
  static create(l) {
    const _ = ku.getOr(null);
    return new Sm({
      ...l,
      group: _
    }, tl.get())
  }
  get shouldRender() {
    return b(st(this, rh))
  }
  set shouldRender(l) {
    he(st(this, rh), l)
  }
  get isSelected() {
    return b(st(this, ih))
  }
  set isSelected(l) {
    he(st(this, ih), l)
  }
  get trueValue() {
    return b(st(this, nh))
  }
  set trueValue(l) {
    he(st(this, nh), l, !0)
  }
  onpointermove(l) {
    this.opts.disabled.current || this.root.opts.disablePointerSelection.current || Rr(this, el, qf).call(this)
  }
  onclick(l) {
    this.opts.disabled.current || Rr(this, el, zv).call(this)
  }
  get props() {
    return b(st(this, ah))
  }
  set props(l) {
    he(st(this, ah), l)
  }
};
no = new WeakMap, Rd = new WeakMap, rh = new WeakMap, ih = new WeakMap, nh = new WeakMap, el = new WeakSet, zv = function() {
  var l;
  this.opts.disabled.current || (Rr(this, el, qf).call(this), (l = this.opts.onSelect) == null || l.current())
}, qf = function() {
  this.opts.disabled.current || this.root.setValue(this.trueValue, !0)
}, ah = new WeakMap;
let jf = Sm;
var sh;
const Pm = class Pm {
  constructor(l, _) {
    fr(this, "opts");
    fr(this, "root");
    fr(this, "attachment");
    Pr(this, sh, vt(() => ({
      id: this.opts.id.current,
      role: "listbox",
      "aria-label": this.opts.ariaLabel.current,
      [da.list]: "",
      ...this.attachment
    })));
    this.opts = l, this.root = _, this.attachment = Ea(this.opts.ref)
  }
  static create(l) {
    return J4.set(new Pm(l, tl.get()))
  }
  get props() {
    return b(st(this, sh))
  }
  set props(l) {
    he(st(this, sh), l)
  }
};
sh = new WeakMap;
let Vf = Pm;
var oh;
const Im = class Im {
  constructor(l, _) {
    fr(this, "opts");
    fr(this, "root");
    fr(this, "attachment");
    Pr(this, oh, vt(() => {
      var l;
      return {
        id: this.opts.id.current,
        [da["input-label"]]: "",
        for: (l = this.opts.for) == null ? void 0 : l.current,
        style: xv,
        ...this.attachment
      }
    }));
    this.opts = l, this.root = _, this.attachment = Ea(this.opts.ref, T => this.root.labelNode = T)
  }
  static create(l) {
    return new Im(l, tl.get())
  }
  get props() {
    return b(st(this, oh))
  }
  set props(l) {
    he(st(this, oh), l)
  }
};
oh = new WeakMap;
let Zf = Im;
var Q4 = De("<label><!></label>");

function e6(y, l) {
  const _ = Za();
  kr(l, !0);
  let T = It(l, "id", 19, () => za(_)),
    z = It(l, "ref", 15, null),
    F = Yt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "children"]);
  const C = Zf.create({
      id: mr.with(() => T()),
      ref: mr.with(() => z(), ie => z(ie))
    }),
    o = vt(() => Ta(F, C.props));
  var K = Q4();
  Kt(K, () => ({
    ...b(o)
  }));
  var G = E(K);
  Qi(G, () => l.children ?? kn), A(K), H(y, K), Er()
}
var t6 = De("<!> <!>", 1),
  r6 = De("<div><!> <!></div>");

function i6(y, l) {
  const _ = Za();
  kr(l, !0);
  const T = at => {
    e6(at, {
      children: (ht, Re) => {
        mi();
        var xt = sa();
        lt(() => Te(xt, fe())), H(ht, xt)
      },
      $$slots: {
        default: !0
      }
    })
  };
  let z = It(l, "id", 19, () => za(_)),
    F = It(l, "ref", 15, null),
    C = It(l, "value", 15, ""),
    o = It(l, "onValueChange", 3, Au),
    K = It(l, "onStateChange", 3, Au),
    G = It(l, "loop", 3, !1),
    ie = It(l, "shouldFilter", 3, !0),
    de = It(l, "filter", 3, Dv),
    fe = It(l, "label", 3, ""),
    W = It(l, "vimBindings", 3, !0),
    le = It(l, "disablePointerSelection", 3, !1),
    Ce = It(l, "disableInitialScroll", 3, !1),
    Me = It(l, "columns", 3, null),
    Le = Yt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "onValueChange", "onStateChange", "loop", "shouldFilter", "filter", "label", "vimBindings", "disablePointerSelection", "disableInitialScroll", "columns", "children", "child"]);
  const $e = Mf.create({
      id: mr.with(() => z()),
      ref: mr.with(() => F(), at => F(at)),
      filter: mr.with(() => de()),
      shouldFilter: mr.with(() => ie()),
      loop: mr.with(() => G()),
      value: mr.with(() => C(), at => {
        C() !== at && (C(at), o()(at))
      }),
      vimBindings: mr.with(() => W()),
      disablePointerSelection: mr.with(() => le()),
      disableInitialScroll: mr.with(() => Ce()),
      onStateChange: mr.with(() => K()),
      columns: mr.with(() => Me())
    }),
    Oe = at => $e.updateSelectedToIndex(at),
    Ve = at => $e.updateSelectedByGroup(at),
    ct = at => $e.updateSelectedByItem(at),
    nt = () => $e.getValidItems(),
    Ye = vt(() => Ta(Le, $e.props));
  var dt = sr(),
    rt = Et(dt);
  {
    var qe = at => {
        var ht = t6(),
          Re = Et(ht);
        T(Re);
        var xt = $(Re, 2);
        Qi(xt, () => l.child, () => ({
          props: b(Ye)
        })), H(at, ht)
      },
      pt = at => {
        var ht = r6();
        Kt(ht, () => ({
          ...b(Ye)
        }));
        var Re = E(ht);
        T(Re);
        var xt = $(Re, 2);
        Qi(xt, () => l.children ?? kn), A(ht), H(at, ht)
      };
    et(rt, at => {
      l.child ? at(qe) : at(pt, !1)
    })
  }
  return H(y, dt), Er({
    updateSelectedToIndex: Oe,
    updateSelectedByGroup: Ve,
    updateSelectedByItem: ct,
    getValidItems: nt
  })
}
var n6 = De("<div><!></div>");

function a6(y, l) {
  const _ = Za();
  kr(l, !0);
  let T = It(l, "id", 19, () => za(_)),
    z = It(l, "ref", 15, null),
    F = It(l, "forceMount", 3, !1),
    C = Yt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child", "forceMount"]);
  const o = Rf.create({
      id: mr.with(() => T()),
      ref: mr.with(() => z(), fe => z(fe)),
      forceMount: mr.with(() => F())
    }),
    K = vt(() => Ta(o.props, C));
  var G = sr(),
    ie = Et(G);
  {
    var de = fe => {
      var W = sr(),
        le = Et(W);
      {
        var Ce = Le => {
            var $e = sr(),
              Oe = Et($e);
            Qi(Oe, () => l.child, () => ({
              props: b(K)
            })), H(Le, $e)
          },
          Me = Le => {
            var $e = n6();
            Kt($e, () => ({
              ...b(K)
            }));
            var Oe = E($e);
            Qi(Oe, () => l.children ?? kn), A($e), H(Le, $e)
          };
        et(le, Le => {
          l.child ? Le(Ce) : Le(Me, !1)
        })
      }
      H(fe, W)
    };
    et(ie, fe => {
      o.shouldRender && fe(de)
    })
  }
  H(y, G), Er()
}
var s6 = De("<div><!></div>");

function o6(y, l) {
  const _ = Za();
  kr(l, !0);
  let T = It(l, "id", 19, () => za(_)),
    z = It(l, "ref", 15, null),
    F = It(l, "value", 3, ""),
    C = It(l, "forceMount", 3, !1),
    o = Yt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "forceMount", "children", "child"]);
  const K = Bf.create({
      id: mr.with(() => T()),
      ref: mr.with(() => z(), le => z(le)),
      forceMount: mr.with(() => C()),
      value: mr.with(() => F())
    }),
    G = vt(() => Ta(o, K.props));
  var ie = sr(),
    de = Et(ie);
  {
    var fe = le => {
        var Ce = sr(),
          Me = Et(Ce);
        Qi(Me, () => l.child, () => ({
          props: b(G)
        })), H(le, Ce)
      },
      W = le => {
        var Ce = s6();
        Kt(Ce, () => ({
          ...b(G)
        }));
        var Me = E(Ce);
        Qi(Me, () => l.children ?? kn), A(Ce), H(le, Ce)
      };
    et(de, le => {
      l.child ? le(fe) : le(W, !1)
    })
  }
  H(y, ie), Er()
}
var l6 = De("<div><!></div>");

function c6(y, l) {
  const _ = Za();
  kr(l, !0);
  let T = It(l, "id", 19, () => za(_)),
    z = It(l, "ref", 15, null),
    F = Yt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child"]);
  const C = Ff.create({
      id: mr.with(() => T()),
      ref: mr.with(() => z(), fe => z(fe))
    }),
    o = vt(() => Ta(F, C.props));
  var K = sr(),
    G = Et(K);
  {
    var ie = fe => {
        var W = sr(),
          le = Et(W);
        Qi(le, () => l.child, () => ({
          props: b(o)
        })), H(fe, W)
      },
      de = fe => {
        var W = l6();
        Kt(W, () => ({
          ...b(o)
        }));
        var le = E(W);
        Qi(le, () => l.children ?? kn), A(W), H(fe, W)
      };
    et(G, fe => {
      l.child ? fe(ie) : fe(de, !1)
    })
  }
  H(y, K), Er()
}
var u6 = De("<div><!></div>"),
  h6 = De('<div style="display: contents;"><!></div>');

function d6(y, l) {
  const _ = Za();
  kr(l, !0);
  let T = It(l, "id", 19, () => za(_)),
    z = It(l, "ref", 15, null),
    F = Yt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child"]);
  const C = Of.create({
      id: mr.with(() => T()),
      ref: mr.with(() => z(), fe => z(fe))
    }),
    o = vt(() => Ta(F, C.props));
  var K = h6(),
    G = E(K);
  {
    var ie = fe => {
        var W = sr(),
          le = Et(W);
        Qi(le, () => l.child, () => ({
          props: b(o)
        })), H(fe, W)
      },
      de = fe => {
        var W = u6();
        Kt(W, () => ({
          ...b(o)
        }));
        var le = E(W);
        Qi(le, () => l.children ?? kn), A(W), H(fe, W)
      };
    et(G, fe => {
      l.child ? fe(ie) : fe(de, !1)
    })
  }
  A(K), H(y, K), Er()
}
var p6 = De("<input/>");

function f6(y, l) {
  const _ = Za();
  kr(l, !0);
  let T = It(l, "value", 15, ""),
    z = It(l, "autofocus", 3, !1),
    F = It(l, "id", 19, () => za(_)),
    C = It(l, "ref", 15, null),
    o = Yt(l, ["$$slots", "$$events", "$$legacy", "value", "autofocus", "id", "ref", "child"]);
  const K = Nf.create({
      id: mr.with(() => F()),
      ref: mr.with(() => C(), le => C(le)),
      value: mr.with(() => T(), le => {
        T(le)
      }),
      autofocus: mr.with(() => z() ?? !1)
    }),
    G = vt(() => Ta(o, K.props));
  var ie = sr(),
    de = Et(ie);
  {
    var fe = le => {
        var Ce = sr(),
          Me = Et(Ce);
        Qi(Me, () => l.child, () => ({
          props: b(G)
        })), H(le, Ce)
      },
      W = le => {
        var Ce = p6();
        $a(Ce), Kt(Ce, () => ({
          ...b(G)
        })), jd(Ce, T), H(le, Ce)
      };
    et(de, le => {
      l.child ? le(fe) : le(W, !1)
    })
  }
  H(y, ie), Er()
}
var m6 = De("<div><!></div>"),
  _6 = De('<div style="display: contents;" data-item-wrapper=""><!></div>');

function g6(y, l) {
  const _ = Za();
  kr(l, !0);
  let T = It(l, "id", 19, () => za(_)),
    z = It(l, "ref", 15, null),
    F = It(l, "value", 3, ""),
    C = It(l, "disabled", 3, !1),
    o = It(l, "onSelect", 3, Au),
    K = It(l, "forceMount", 3, !1),
    G = It(l, "keywords", 19, () => []),
    ie = Yt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "disabled", "children", "child", "onSelect", "forceMount", "keywords"]);
  const de = jf.create({
      id: mr.with(() => T()),
      ref: mr.with(() => z(), Ce => z(Ce)),
      value: mr.with(() => F()),
      disabled: mr.with(() => C()),
      onSelect: mr.with(() => o()),
      forceMount: mr.with(() => K()),
      keywords: mr.with(() => G())
    }),
    fe = vt(() => Ta(ie, de.props));
  var W = sr(),
    le = Et(W);
  Iu(le, () => de.root.key, Ce => {
    var Me = _6(),
      Le = E(Me);
    {
      var $e = Oe => {
        var Ve = sr(),
          ct = Et(Ve);
        {
          var nt = dt => {
              var rt = sr(),
                qe = Et(rt);
              Qi(qe, () => l.child, () => ({
                props: b(fe)
              })), H(dt, rt)
            },
            Ye = dt => {
              var rt = m6();
              Kt(rt, () => ({
                ...b(fe)
              }));
              var qe = E(rt);
              Qi(qe, () => l.children ?? kn), A(rt), H(dt, rt)
            };
          et(ct, dt => {
            l.child ? dt(nt) : dt(Ye, !1)
          })
        }
        H(Oe, Ve)
      };
      et(Le, Oe => {
        de.shouldRender && Oe($e)
      })
    }
    A(Me), lt(() => Br(Me, "data-value", de.trueValue)), H(Ce, Me)
  }), H(y, W), Er()
}
var v6 = De("<div><!></div>");

function y6(y, l) {
  const _ = Za();
  kr(l, !0);
  let T = It(l, "id", 19, () => za(_)),
    z = It(l, "ref", 15, null),
    F = Yt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "child", "children", "aria-label"]);
  const C = Vf.create({
      id: mr.with(() => T()),
      ref: mr.with(() => z(), ie => z(ie)),
      ariaLabel: mr.with(() => l["aria-label"] ?? "Suggestions...")
    }),
    o = vt(() => Ta(F, C.props));
  var K = sr(),
    G = Et(K);
  Iu(G, () => C.root._commandState.search === "", ie => {
    var de = sr(),
      fe = Et(de);
    {
      var W = Ce => {
          var Me = sr(),
            Le = Et(Me);
          Qi(Le, () => l.child, () => ({
            props: b(o)
          })), H(Ce, Me)
        },
        le = Ce => {
          var Me = v6();
          Kt(Me, () => ({
            ...b(o)
          }));
          var Le = E(Me);
          Qi(Le, () => l.children ?? kn), A(Me), H(Ce, Me)
        };
      et(fe, Ce => {
        l.child ? Ce(W) : Ce(le, !1)
      })
    }
    H(ie, de)
  }), H(y, K), Er()
}
const Dg = 1,
  x6 = .9,
  b6 = .8,
  w6 = .17,
  _f = .1,
  gf = .999,
  T6 = .9999,
  C6 = .99,
  S6 = /[\\/_+.#"@[({&]/,
  P6 = /[\\/_+.#"@[({&]/g,
  I6 = /[\s-]/,
  Lv = /[\s-]/g;

function $f(y, l, _, T, z, F, C) {
  if (F === l.length) return z === y.length ? Dg : C6;
  const o = `${z},${F}`;
  if (C[o] !== void 0) return C[o];
  const K = T.charAt(F);
  let G = _.indexOf(K, z),
    ie = 0,
    de, fe, W, le;
  for (; G >= 0;) de = $f(y, l, _, T, G + 1, F + 1, C), de > ie && (G === z ? de *= Dg : S6.test(y.charAt(G - 1)) ? (de *= b6, W = y.slice(z, G - 1).match(P6), W && z > 0 && (de *= gf ** W.length)) : I6.test(y.charAt(G - 1)) ? (de *= x6, le = y.slice(z, G - 1).match(Lv), le && z > 0 && (de *= gf ** le.length)) : (de *= w6, z > 0 && (de *= gf ** (G - z))), y.charAt(G) !== l.charAt(F) && (de *= T6)), (de < _f && _.charAt(G - 1) === T.charAt(F + 1) || T.charAt(F + 1) === T.charAt(F) && _.charAt(G - 1) !== T.charAt(F)) && (fe = $f(y, l, _, T, G + 1, F + 2, C), fe * _f > de && (de = fe * _f)), de > ie && (ie = de), G = _.indexOf(K, G + 1);
  return C[o] = ie, ie
}

function Rg(y) {
  return y.toLowerCase().replace(Lv, " ")
}

function Dv(y, l, _) {
  return y = _ && _.length > 0 ? `${`${y} ${_==null?void 0:_.join(" ")}`}` : y, $f(y, l, Rg(y), Rg(l), 0, 0, {})
}
const M6 = 18,
  Rv = 40,
  A6 = `${Rv}px`,
  k6 = ["[data-lastpass-icon-root]", "com-1password-button", "[data-dashlanecreated]", '[style$="2147483647 !important;"]'].join(",");

function E6({
  containerRef: y,
  inputRef: l,
  pushPasswordManagerStrategy: _,
  isFocused: T,
  domContext: z
}) {
  let F = _t(!1),
    C = _t(!1),
    o = _t(!1);

  function K() {
    const ie = _.current;
    return ie === "none" ? !1 : ie === "increase-width" && b(F) && b(C)
  }

  function G() {
    const ie = y.current,
      de = l.current;
    if (!ie || !de || b(o) || _.current === "none") return;
    const fe = ie,
      W = fe.getBoundingClientRect().left + fe.offsetWidth,
      le = fe.getBoundingClientRect().top + fe.offsetHeight / 2,
      Ce = W - M6,
      Me = le;
    z.querySelectorAll(k6).length === 0 && z.getDocument().elementFromPoint(Ce, Me) === ie || (he(F, !0), he(o, !0))
  }
  return $r(() => {
    const ie = y.current;
    if (!ie || _.current === "none") return;

    function de() {
      const le = Tv(ie).innerWidth - ie.getBoundingClientRect().right;
      he(C, le >= Rv)
    }
    de();
    const fe = setInterval(de, 1e3);
    return () => {
      clearInterval(fe)
    }
  }), $r(() => {
    const ie = T.current || z.getActiveElement() === l.current;
    if (_.current === "none" || !ie) return;
    const de = setTimeout(G, 0),
      fe = setTimeout(G, 2e3),
      W = setTimeout(G, 5e3),
      le = setTimeout(() => {
        he(o, !0)
      }, 6e3);
    return () => {
      clearTimeout(de), clearTimeout(fe), clearTimeout(W), clearTimeout(le)
    }
  }), {
    get hasPwmBadge() {
      return b(F)
    },
    get willPushPwmBadge() {
      return K()
    },
    PWM_BADGE_SPACE_WIDTH: A6
  }
}
const Bv = Cv({
    component: "pin-input",
    parts: ["root", "cell"]
  }),
  z6 = ["Backspace", "Delete", "ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End", "Escape", "Enter", "Tab", "Shift", "Control", "Meta"];
var Aa, sc, ws, wa, ka, oc, ns, Ts, ao, lc, Bd, lh, ch, Fd, Od, Fv, uh, hh, Nd, dh;
const Mm = class Mm {
  constructor(l) {
    Pr(this, Od);
    fr(this, "opts");
    fr(this, "attachment");
    Pr(this, Aa, mr(null));
    Pr(this, sc, _t(!1));
    fr(this, "inputAttachment", Ea(st(this, Aa)));
    Pr(this, ws, mr(!1));
    Pr(this, wa, _t(null));
    Pr(this, ka, _t(null));
    Pr(this, oc, new _4(() => this.opts.value.current ?? ""));
    Pr(this, ns, vt(() => typeof this.opts.pattern.current == "string" ? new RegExp(this.opts.pattern.current) : this.opts.pattern.current));
    Pr(this, Ts, _t(En({
      prev: [null, null, "none"],
      willSyntheticBlur: !1
    })));
    Pr(this, ao);
    Pr(this, lc);
    fr(this, "domContext");
    fr(this, "onkeydown", l => {
      const _ = l.key;
      z6.includes(_) || l.ctrlKey || l.metaKey || _ && b(st(this, ns)) && !b(st(this, ns)).test(_) && l.preventDefault()
    });
    Pr(this, Bd, vt(() => ({
      position: "relative",
      cursor: this.opts.disabled.current ? "default" : "text",
      userSelect: "none",
      WebkitUserSelect: "none",
      pointerEvents: "none"
    })));
    Pr(this, lh, vt(() => ({
      id: this.opts.id.current,
      [Bv.root]: "",
      style: b(st(this, Bd)),
      ...this.attachment
    })));
    Pr(this, ch, vt(() => ({
      style: {
        position: "absolute",
        inset: 0,
        pointerEvents: "none"
      }
    })));
    Pr(this, Fd, vt(() => ({
      position: "absolute",
      inset: 0,
      width: st(this, ao).willPushPwmBadge ? `calc(100% + ${st(this,ao).PWM_BADGE_SPACE_WIDTH})` : "100%",
      clipPath: st(this, ao).willPushPwmBadge ? `inset(0 ${st(this,ao).PWM_BADGE_SPACE_WIDTH} 0 0)` : void 0,
      height: "100%",
      display: "flex",
      textAlign: this.opts.textAlign.current,
      opacity: "1",
      color: "transparent",
      pointerEvents: "all",
      background: "transparent",
      caretColor: "transparent",
      border: "0 solid transparent",
      outline: "0 solid transparent",
      boxShadow: "none",
      lineHeight: "1",
      letterSpacing: "-.5em",
      fontSize: "var(--bits-pin-input-root-height)",
      fontFamily: "monospace",
      fontVariantNumeric: "tabular-nums"
    })));
    Pr(this, uh, () => {
      var Ce;
      const l = st(this, Aa).current,
        _ = this.opts.ref.current;
      if (!l || !_) return;
      if (this.domContext.getActiveElement() !== l) {
        he(st(this, wa), null), he(st(this, ka), null);
        return
      }
      const T = l.selectionStart,
        z = l.selectionEnd,
        F = l.selectionDirection ?? "none",
        C = l.maxLength,
        o = l.value,
        K = b(st(this, Ts)).prev;
      let G = -1,
        ie = -1,
        de;
      if (o.length !== 0 && T !== null && z !== null) {
        const Me = T === z,
          Le = T === o.length && o.length < C;
        if (Me && !Le) {
          const $e = T;
          if ($e === 0) G = 0, ie = 1, de = "forward";
          else if ($e === C) G = $e - 1, ie = $e, de = "backward";
          else if (C > 1 && o.length > 1) {
            let Oe = 0;
            if (K[0] !== null && K[1] !== null) {
              de = $e < K[0] ? "backward" : "forward";
              const Ve = K[0] === K[1] && K[0] < C;
              de === "backward" && !Ve && (Oe = -1)
            }
            G = Oe - $e, ie = Oe + $e + 1
          }
        }
        G !== -1 && ie !== -1 && G !== ie && ((Ce = st(this, Aa).current) == null || Ce.setSelectionRange(G, ie, de))
      }
      const fe = G !== -1 ? G : T,
        W = ie !== -1 ? ie : z,
        le = de ?? F;
      he(st(this, wa), fe, !0), he(st(this, ka), W, !0), b(st(this, Ts)).prev = [fe, W, le]
    });
    fr(this, "oninput", l => {
      const _ = l.currentTarget.value.slice(0, this.opts.maxLength.current);
      if (_.length > 0 && b(st(this, ns)) && !b(st(this, ns)).test(_)) {
        l.preventDefault();
        return
      }
      typeof st(this, oc).current == "string" && _.length < st(this, oc).current.length && this.domContext.getDocument().dispatchEvent(new Event("selectionchange")), this.opts.value.current = _
    });
    fr(this, "onfocus", l => {
      const _ = st(this, Aa).current;
      if (_) {
        const T = Math.min(_.value.length, this.opts.maxLength.current - 1),
          z = _.value.length;
        _.setSelectionRange(T, z), he(st(this, wa), T, !0), he(st(this, ka), z, !0)
      }
      st(this, ws).current = !0
    });
    fr(this, "onpaste", l => {
      var ie, de, fe, W;
      const _ = st(this, Aa).current;
      if (!_) return;
      const T = le => {
          const Ce = _.selectionStart === null ? void 0 : _.selectionStart,
            Me = _.selectionEnd === null ? void 0 : _.selectionEnd,
            Le = Ce !== Me,
            $e = this.opts.value.current;
          return (Le ? $e.slice(0, Ce) + le + $e.slice(Me) : $e.slice(0, Ce) + le + $e.slice(Ce)).slice(0, this.opts.maxLength.current)
        },
        z = le => le.length > 0 && b(st(this, ns)) && !b(st(this, ns)).test(le);
      if (!((ie = this.opts.pasteTransformer) != null && ie.current) && (!st(this, lc).isIOS || !l.clipboardData || !_)) {
        const le = T((de = l.clipboardData) == null ? void 0 : de.getData("text/plain"));
        z(le) && l.preventDefault();
        return
      }
      const F = ((fe = l.clipboardData) == null ? void 0 : fe.getData("text/plain")) ?? "",
        C = (W = this.opts.pasteTransformer) != null && W.current ? this.opts.pasteTransformer.current(F) : F;
      l.preventDefault();
      const o = T(C);
      if (z(o)) return;
      _.value = o, this.opts.value.current = o;
      const K = Math.min(o.length, this.opts.maxLength.current - 1),
        G = o.length;
      _.setSelectionRange(K, G), he(st(this, wa), K, !0), he(st(this, ka), G, !0)
    });
    fr(this, "onmouseover", l => {
      he(st(this, sc), !0)
    });
    fr(this, "onmouseleave", l => {
      he(st(this, sc), !1)
    });
    fr(this, "onblur", l => {
      if (b(st(this, Ts)).willSyntheticBlur) {
        b(st(this, Ts)).willSyntheticBlur = !1;
        return
      }
      st(this, ws).current = !1
    });
    Pr(this, hh, vt(() => {
      var l;
      return {
        id: this.opts.inputId.current,
        style: b(st(this, Fd)),
        autocomplete: this.opts.autocomplete.current || "one-time-code",
        "data-pin-input-input": "",
        "data-pin-input-input-mss": b(st(this, wa)),
        "data-pin-input-input-mse": b(st(this, ka)),
        inputmode: this.opts.inputmode.current,
        pattern: (l = b(st(this, ns))) == null ? void 0 : l.source,
        maxlength: this.opts.maxLength.current,
        value: this.opts.value.current,
        disabled: L4(this.opts.disabled.current),
        onpaste: this.onpaste,
        oninput: this.oninput,
        onkeydown: this.onkeydown,
        onmouseover: this.onmouseover,
        onmouseleave: this.onmouseleave,
        onfocus: this.onfocus,
        onblur: this.onblur,
        ...this.inputAttachment
      }
    }));
    Pr(this, Nd, vt(() => Array.from({
      length: this.opts.maxLength.current
    }).map((l, _) => {
      const T = st(this, ws).current && b(st(this, wa)) !== null && b(st(this, ka)) !== null && (b(st(this, wa)) === b(st(this, ka)) && _ === b(st(this, wa)) || _ >= b(st(this, wa)) && _ < b(st(this, ka))),
        z = this.opts.value.current[_] !== void 0 ? this.opts.value.current[_] : null;
      return {
        char: z,
        isActive: T,
        hasFakeCaret: T && z === null
      }
    })));
    Pr(this, dh, vt(() => ({
      cells: b(st(this, Nd)),
      isFocused: st(this, ws).current,
      isHovering: b(st(this, sc))
    })));
    var _;
    this.opts = l, this.attachment = Ea(this.opts.ref), this.domContext = new I4(l.ref), Xn(this, lc, {
      value: this.opts.value,
      isIOS: typeof window < "u" && ((_ = window == null ? void 0 : window.CSS) == null ? void 0 : _.supports("-webkit-touch-callout", "none"))
    }), Xn(this, ao, E6({
      containerRef: this.opts.ref,
      inputRef: st(this, Aa),
      isFocused: st(this, ws),
      pushPasswordManagerStrategy: this.opts.pushPasswordManagerStrategy,
      domContext: this.domContext
    })), Ii(() => {
      const T = st(this, Aa).current,
        z = this.opts.ref.current;
      if (!T || !z) return;
      st(this, lc).value.current !== T.value && (this.opts.value.current = T.value), b(st(this, Ts)).prev = [T.selectionStart, T.selectionEnd, T.selectionDirection ?? "none"];
      const F = Pu(this.domContext.getDocument(), "selectionchange", st(this, uh), {
        capture: !0
      });
      st(this, uh).call(this), this.domContext.getActiveElement() === T && (st(this, ws).current = !0), this.domContext.getElementById("pin-input-style") || Rr(this, Od, Fv).call(this);
      const C = () => {
        z && z.style.setProperty("--bits-pin-input-root-height", `${T.clientHeight}px`)
      };
      C();
      const o = new ResizeObserver(C);
      return o.observe(T), () => {
        F(), o.disconnect()
      }
    }), oo([() => this.opts.value.current, () => st(this, Aa).current], () => {
      L6(() => {
        const T = st(this, Aa).current;
        if (!T) return;
        T.dispatchEvent(new Event("input"));
        const z = T.selectionStart,
          F = T.selectionEnd,
          C = T.selectionDirection ?? "none";
        z !== null && F !== null && (he(st(this, wa), z, !0), he(st(this, ka), F, !0), b(st(this, Ts)).prev = [z, F, C])
      }, this.domContext)
    }), $r(() => {
      const T = this.opts.value.current,
        z = st(this, oc).current,
        F = this.opts.maxLength.current,
        C = this.opts.onComplete.current;
      z !== void 0 && T !== z && z.length < F && T.length === F && C(T)
    })
  }
  static create(l) {
    return new Mm(l)
  }
  get rootProps() {
    return b(st(this, lh))
  }
  set rootProps(l) {
    he(st(this, lh), l)
  }
  get inputWrapperProps() {
    return b(st(this, ch))
  }
  set inputWrapperProps(l) {
    he(st(this, ch), l)
  }
  get inputProps() {
    return b(st(this, hh))
  }
  set inputProps(l) {
    he(st(this, hh), l)
  }
  get snippetProps() {
    return b(st(this, dh))
  }
  set snippetProps(l) {
    he(st(this, dh), l)
  }
};
Aa = new WeakMap, sc = new WeakMap, ws = new WeakMap, wa = new WeakMap, ka = new WeakMap, oc = new WeakMap, ns = new WeakMap, Ts = new WeakMap, ao = new WeakMap, lc = new WeakMap, Bd = new WeakMap, lh = new WeakMap, ch = new WeakMap, Fd = new WeakMap, Od = new WeakSet, Fv = function() {
  const l = this.domContext.getDocument(),
    _ = l.createElement("style");
  if (_.id = "pin-input-style", l.head.appendChild(_), _.sheet) {
    const T = "background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;";
    xu(_.sheet, "[data-pin-input-input]::selection { background: transparent !important; color: transparent !important; }"), xu(_.sheet, `[data-pin-input-input]:autofill { ${T} }`), xu(_.sheet, `[data-pin-input-input]:-webkit-autofill { ${T} }`), xu(_.sheet, "@supports (-webkit-touch-callout: none) { [data-pin-input-input] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }"), xu(_.sheet, "[data-pin-input-input] + * { pointer-events: all !important; }")
  }
}, uh = new WeakMap, hh = new WeakMap, Nd = new WeakMap, dh = new WeakMap;
let Uf = Mm;
var ph;
const Am = class Am {
  constructor(l) {
    fr(this, "opts");
    fr(this, "attachment");
    Pr(this, ph, vt(() => ({
      id: this.opts.id.current,
      [Bv.cell]: "",
      "data-active": this.opts.cell.current.isActive ? "" : void 0,
      "data-inactive": this.opts.cell.current.isActive ? void 0 : "",
      ...this.attachment
    })));
    this.opts = l, this.attachment = Ea(this.opts.ref)
  }
  static create(l) {
    return new Am(l)
  }
  get props() {
    return b(st(this, ph))
  }
  set props(l) {
    he(st(this, ph), l)
  }
};
ph = new WeakMap;
let Gf = Am;

function L6(y, l) {
  const _ = l.setTimeout(y, 0),
    T = l.setTimeout(y, 10),
    z = l.setTimeout(y, 50);
  return [_, T, z]
}

function xu(y, l) {
  try {
    y.insertRule(l)
  } catch {
    console.error("pin input could not insert CSS rule:", l)
  }
}
var D6 = De("<div><!> <div><input/></div></div>");

function R6(y, l) {
  const _ = Za();
  kr(l, !0);
  let T = It(l, "id", 19, () => za(_)),
    z = It(l, "inputId", 19, () => `${za(_)}-input`),
    F = It(l, "ref", 15, null),
    C = It(l, "maxlength", 3, 6),
    o = It(l, "textalign", 3, "left"),
    K = It(l, "inputmode", 3, "numeric"),
    G = It(l, "onComplete", 3, Au),
    ie = It(l, "pushPasswordManagerStrategy", 3, "increase-width"),
    de = It(l, "class", 3, ""),
    fe = It(l, "autocomplete", 3, "one-time-code"),
    W = It(l, "disabled", 3, !1),
    le = It(l, "value", 15, ""),
    Ce = It(l, "onValueChange", 3, Au),
    Me = Yt(l, ["$$slots", "$$events", "$$legacy", "id", "inputId", "ref", "maxlength", "textalign", "pattern", "inputmode", "onComplete", "pushPasswordManagerStrategy", "class", "children", "autocomplete", "disabled", "value", "onValueChange", "pasteTransformer"]);
  const Le = Uf.create({
      id: mr.with(() => T()),
      ref: mr.with(() => F(), rt => F(rt)),
      inputId: mr.with(() => z()),
      autocomplete: mr.with(() => fe()),
      maxLength: mr.with(() => C()),
      textAlign: mr.with(() => o()),
      disabled: mr.with(() => W()),
      inputmode: mr.with(() => K()),
      pattern: mr.with(() => l.pattern),
      onComplete: mr.with(() => G()),
      value: mr.with(() => le(), rt => {
        le(rt), Ce()(rt)
      }),
      pushPasswordManagerStrategy: mr.with(() => ie()),
      pasteTransformer: mr.with(() => l.pasteTransformer)
    }),
    $e = vt(() => Ta(Me, Le.inputProps)),
    Oe = vt(() => Ta(Le.rootProps, {
      class: de()
    })),
    Ve = vt(() => Ta(Le.inputWrapperProps, {}));
  var ct = D6();
  Kt(ct, () => ({
    ...b(Oe)
  }));
  var nt = E(ct);
  Qi(nt, () => l.children ?? kn, () => Le.snippetProps);
  var Ye = $(nt, 2);
  Kt(Ye, () => ({
    ...b(Ve)
  }));
  var dt = E(Ye);
  $a(dt), Kt(dt, () => ({
    ...b($e)
  })), A(Ye), A(ct), H(y, ct), Er()
}
var B6 = De("<div><!></div>");

function F6(y, l) {
  const _ = Za();
  kr(l, !0);
  let T = It(l, "id", 19, () => za(_)),
    z = It(l, "ref", 15, null),
    F = Yt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "cell", "child", "children"]);
  const C = Gf.create({
      id: mr.with(() => T()),
      ref: mr.with(() => z(), fe => z(fe)),
      cell: mr.with(() => l.cell)
    }),
    o = vt(() => Ta(F, C.props));
  var K = sr(),
    G = Et(K);
  {
    var ie = fe => {
        var W = sr(),
          le = Et(W);
        Qi(le, () => l.child, () => ({
          props: b(o)
        })), H(fe, W)
      },
      de = fe => {
        var W = B6();
        Kt(W, () => ({
          ...b(o)
        }));
        var le = E(W);
        Qi(le, () => l.children ?? kn), A(W), H(fe, W)
      };
    et(G, fe => {
      l.child ? fe(ie) : fe(de, !1)
    })
  }
  H(y, K), Er()
}

function dc(...y) {
  return Xg(Su(y))
}

function O6(y, l) {
  kr(l, !0);
  let _ = It(l, "ref", 15, null),
    T = It(l, "value", 15, ""),
    z = Yt(l, ["$$slots", "$$events", "$$legacy", "ref", "value", "class"]);
  var F = sr(),
    C = Et(F);
  {
    let o = vt(() => dc("bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md", l.class));
    cn(C, () => i6, (K, G) => {
      G(K, lo({
        "data-slot": "command",
        get class() {
          return b(o)
        }
      }, () => z, {
        get value() {
          return T()
        },
        set value(ie) {
          T(ie)
        },
        get ref() {
          return _()
        },
        set ref(ie) {
          _(ie)
        }
      }))
    })
  }
  H(y, F), Er()
}
var N6 = wr('<svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"></path></svg>');

function pc(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = N6();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}

function j6(y, l) {
  kr(l, !0);
  let _ = It(l, "ref", 15, null),
    T = Yt(l, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var z = sr(),
    F = Et(z);
  {
    let C = vt(() => dc("py-6 text-center text-sm", l.class));
    cn(F, () => a6, (o, K) => {
      K(o, lo({
        "data-slot": "command-empty",
        get class() {
          return b(C)
        }
      }, () => T, {
        get ref() {
          return _()
        },
        set ref(G) {
          _(G)
        }
      }))
    })
  }
  H(y, z), Er()
}
var q6 = De("<!> <!>", 1);

function V6(y, l) {
  kr(l, !0);
  let _ = It(l, "ref", 15, null),
    T = Yt(l, ["$$slots", "$$events", "$$legacy", "ref", "class", "children", "heading", "value"]);
  var z = sr(),
    F = Et(z);
  {
    let C = vt(() => dc("text-foreground overflow-hidden p-1", l.class)),
      o = vt(() => l.value ?? l.heading ?? `----${X4()}`);
    cn(F, () => o6, (K, G) => {
      G(K, lo({
        "data-slot": "command-group",
        get class() {
          return b(C)
        },
        get value() {
          return b(o)
        }
      }, () => T, {
        get ref() {
          return _()
        },
        set ref(ie) {
          _(ie)
        },
        children: (ie, de) => {
          var fe = q6(),
            W = Et(fe);
          {
            var le = Me => {
              var Le = sr(),
                $e = Et(Le);
              cn($e, () => c6, (Oe, Ve) => {
                Ve(Oe, {
                  class: "text-muted-foreground px-2 py-1.5 text-xs font-medium",
                  children: (ct, nt) => {
                    mi();
                    var Ye = sa();
                    lt(() => Te(Ye, l.heading)), H(ct, Ye)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              }), H(Me, Le)
            };
            et(W, Me => {
              l.heading && Me(le)
            })
          }
          var Ce = $(W, 2);
          cn(Ce, () => d6, (Me, Le) => {
            Le(Me, {
              get children() {
                return l.children
              }
            })
          }), H(ie, fe)
        },
        $$slots: {
          default: !0
        }
      }))
    })
  }
  H(y, z), Er()
}

function Z6(y, l) {
  kr(l, !0);
  let _ = It(l, "ref", 15, null),
    T = Yt(l, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var z = sr(),
    F = Et(z);
  {
    let C = vt(() => dc("aria-selected:bg-base-300 aria-selected:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", l.class));
    cn(F, () => g6, (o, K) => {
      K(o, lo({
        "data-slot": "command-item",
        get class() {
          return b(C)
        }
      }, () => T, {
        get ref() {
          return _()
        },
        set ref(G) {
          _(G)
        }
      }))
    })
  }
  H(y, z), Er()
}
var $6 = wr('<svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"></path></svg>');

function U6(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = $6();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var G6 = De('<div class="border-base-content/10 flex h-9 items-center gap-2 border-b px-3" data-slot="command-input-wrapper"><!> <!></div>');

function H6(y, l) {
  kr(l, !0);
  let _ = It(l, "ref", 15, null),
    T = It(l, "value", 15, ""),
    z = Yt(l, ["$$slots", "$$events", "$$legacy", "ref", "class", "value"]);
  var F = G6(),
    C = E(F);
  U6(C, {
    class: "size-5 opacity-50"
  });
  var o = $(C, 2);
  {
    let K = vt(() => dc("placeholder:text-muted-foreground outline-hidden flex h-10 w-full rounded-md bg-transparent py-3 text-sm disabled:cursor-not-allowed disabled:opacity-50", l.class));
    cn(o, () => f6, (G, ie) => {
      ie(G, lo({
        "data-slot": "command-input",
        get class() {
          return b(K)
        }
      }, () => z, {
        get ref() {
          return _()
        },
        set ref(de) {
          _(de)
        },
        get value() {
          return T()
        },
        set value(de) {
          T(de)
        }
      }))
    })
  }
  A(F), H(y, F), Er()
}

function W6(y, l) {
  kr(l, !0);
  let _ = It(l, "ref", 15, null),
    T = Yt(l, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
  var z = sr(),
    F = Et(z);
  {
    let C = vt(() => dc("max-h-[300px] scroll-py-1 overflow-y-auto overflow-x-hidden", l.class));
    cn(F, () => y6, (o, K) => {
      K(o, lo({
        "data-slot": "command-list",
        get class() {
          return b(C)
        }
      }, () => T, {
        get ref() {
          return _()
        },
        set ref(G) {
          _(G)
        }
      }))
    })
  }
  H(y, z), Er()
}
var X6 = wr('<svg><path d="M480-80 240-320l57-57 183 183 183-183 57 57L480-80ZM298-584l-58-56 240-240 240 240-58 56-182-182-182 182Z"></path></svg>');

function K6(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = X6();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var Y6 = De("<span> </span> <!>", 1),
  J6 = De('<span class="font-flag ml-0.5"> </span> ', 1),
  Q6 = De('<span class="flex gap-1.5"><span class="font-flag"> </span> </span>'),
  eA = De("<!> <!>", 1),
  tA = De("<!> <!>", 1),
  rA = (y, l) => {
    l(0)
  },
  iA = De('<button class="btn btn-xs btn-circle btn-ghost"><!></button>'),
  nA = De('<div class="flex items-center"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-sm max-w-74 text-base-content/80 m-1"><!></div> <div><!></div></div> <!></div>');

function Bg(y, l) {
  kr(l, !0);
  let _ = It(l, "countryId", 15, 0),
    T = It(l, "dropdownDirection", 3, "right"),
    z = _t(null),
    F = _t(null),
    C = _t("");

  function o() {
    Vg().then(() => {
      var Oe;
      (Oe = document.activeElement) == null || Oe.blur(), he(C, "")
    })
  }
  var K = nA(),
    G = E(K),
    ie = E(G),
    de = E(ie);
  {
    var fe = Oe => {
        var Ve = Y6(),
          ct = Et(Ve),
          nt = E(ct, !0);
        A(ct);
        var Ye = $(ct, 2);
        K6(Ye, {
          class: "size-3.5"
        }), lt(dt => Te(nt, dt), [() => iv()]), H(Oe, Ve)
      },
      W = Oe => {
        const Ve = vt(() => as(_()));
        var ct = J6(),
          nt = Et(ct),
          Ye = E(nt, !0);
        A(nt);
        var dt = $(nt);
        lt(() => {
          Te(Ye, b(Ve).flag), Te(dt, ` ${b(Ve).name??""}`)
        }), H(Oe, ct)
      };
    et(de, Oe => {
      _() === 0 ? Oe(fe) : Oe(W, !1)
    })
  }
  A(ie);
  var le = $(ie, 2);
  let Ce;
  var Me = E(le);
  cn(Me, () => O6, (Oe, Ve) => {
    Ve(Oe, {
      children: (ct, nt) => {
        var Ye = tA(),
          dt = Et(Ye);
        cn(dt, () => H6, (qe, pt) => {
          pt(qe, {
            placeholder: "Country",
            get ref() {
              return b(z)
            },
            set ref(at) {
              he(z, at)
            },
            get value() {
              return b(C)
            },
            set value(at) {
              he(C, at, !0)
            }
          })
        });
        var rt = $(dt, 2);
        cn(rt, () => W6, (qe, pt) => {
          pt(qe, {
            children: (at, ht) => {
              var Re = eA(),
                xt = Et(Re);
              cn(xt, () => j6, (re, xe) => {
                xe(re, {
                  children: (ce, Ee) => {
                    mi();
                    var Be = sa();
                    lt(Ke => Te(Be, Ke), [() => O2()]), H(ce, Be)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              });
              var Q = $(xt, 2);
              cn(Q, () => V6, (re, xe) => {
                xe(re, {
                  children: (ce, Ee) => {
                    var Be = sr(),
                      Ke = Et(Be);
                    xn(Ke, 17, () => jn.countries, tt => tt.id, (tt, ot) => {
                      var ft = sr(),
                        Bt = Et(ft);
                      cn(Bt, () => Z6, (At, cr) => {
                        cr(At, {
                          get value() {
                            return b(ot).name
                          },
                          onSelect: () => {
                            _(b(ot).id), o()
                          },
                          children: (Mt, yt) => {
                            var St = Q6(),
                              jt = E(St),
                              Lt = E(jt, !0);
                            A(jt);
                            var Gt = $(jt);
                            A(St), lt(() => {
                              Te(Lt, b(ot).flag), Te(Gt, ` ${b(ot).name??""}`)
                            }), H(Mt, St)
                          },
                          $$slots: {
                            default: !0
                          }
                        })
                      }), H(tt, ft)
                    }), H(ce, Be)
                  },
                  $$slots: {
                    default: !0
                  }
                })
              }), H(at, Re)
            },
            $$slots: {
              default: !0
            }
          })
        }), H(ct, Ye)
      },
      $$slots: {
        default: !0
      }
    })
  }), A(le), A(G);
  var Le = $(G, 2);
  {
    var $e = Oe => {
      var Ve = iA();
      Ve.__click = [rA, _];
      var ct = E(Ve);
      pc(ct, {
        class: "size-3.5"
      }), A(Ve), H(Oe, Ve)
    };
    et(Le, Oe => {
      _() != 0 && Oe($e)
    })
  }
  A(K), Ss(K, Oe => he(F, Oe), () => b(F)), lt(Oe => Ce = Vr(le, 1, "dropdown-content menu bg-base-100 rounded-box z-1 border-base-content/10 w-52 rounded-lg border py-1 shadow-sm", null, Ce, Oe), [() => ({
    "right-1": T() === "left"
  })]), bn("focus", ie, () => {
    b(z).focus()
  }), H(y, K), Er()
}
en(["click"]);
var aA = wr('<svg><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-7-.5-14.5T799-507q-5 29-27 48t-52 19h-80q-33 0-56.5-23.5T560-520v-40H400v-80q0-33 23.5-56.5T480-720h40q0-23 12.5-40.5T563-789q-20-5-40.5-8t-42.5-3q-134 0-227 93t-93 227h200q66 0 113 47t47 113v40H400v110q20 5 39.5 7.5T480-160Z"></path></svg>');

function sA(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = aA();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var oA = wr('<svg><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Z"></path></svg>'),
  lA = wr('<svg><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"></path></svg>');

function Hf(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy", "filled"]);
  var T = sr(),
    z = Et(T);
  {
    var F = o => {
        var K = oA();
        Kt(K, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ..._
        })), H(o, K)
      },
      C = o => {
        var K = lA();
        Kt(K, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ..._
        })), H(o, K)
      };
    et(z, o => {
      l.filled ? o(F) : o(C, !1)
    })
  }
  H(y, T)
}
var cA = De('<label class="tab grow font-semibold max-sm:h-10"><input type="radio" class="tab grow"/> <!> </label>'),
  uA = De('<div class="mb-2"><!></div>'),
  hA = De('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  dA = (y, l, _) => {
    l.onvisitclick({
      lat: b(_).lastLatitude,
      lng: b(_).lastLongitude
    })
  },
  pA = De('<tr><td class="text-base-content/80 text-center font-medium max-sm:hidden"> </td><td><span class="font-flag tooltip mr-1 text-base sm:text-lg"> </span> <span> <span class="ml-0.5"> </span></span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td><td class="px-1 text-center"><button class="btn btn-sm"> </button></td></tr>'),
  fA = De('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th class="max-sm:hidden"></th><th> </th><th class="text-center"> <br class="sm:hidden"/> <span class="tooltip max-sm:hidden"><!></span></th><th class="px-1"></th></tr></thead><tbody></tbody></table>'),
  mA = De('<tr><td class="text-base-content/80 text-center font-medium"> </td><td><span class="font-flag tooltip mr-1 text-base sm:text-lg"> </span> <span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  _A = De('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th> </th><th class="text-center"> <br class="sm:hidden"/> <span class="tooltip before:-translate-x-1/4 max-sm:hidden"><!></span></th></tr></thead><tbody></tbody></table>'),
  gA = De('<span class="font-flag tooltip ml-0.5"> </span>'),
  vA = De("<span> </span>"),
  yA = De('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="max-sm:px-1"><div class="flex items-center gap-2"><!> <div class="items-center gap-2 sm:flex"><span> <span class="ml-0.5"> </span></span> <!> <!> <!></div></div></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  xA = De('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  bA = De('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="h-14 max-sm:px-1"><span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  wA = De('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  TA = De('<div class="h-screen pt-20"><div class="flex justify-center"><span class="loading loading-spinner"></span></div></div>'),
  CA = De('<div class="tabs tabs-box max-sm:tabs-xs"></div> <div class="my-4 flex items-center justify-between"><!> <!></div> <!> <!>', 1);

function SA(y, l) {
  kr(l, !0);
  const _ = [];
  let T = _t(1e3);
  const z = vt(() => b(T) <= 640);
  let F = _t("today"),
    C = {
      regions: {
        label: c3(),
        icon: dm
      },
      countries: {
        label: d3(),
        icon: sA
      },
      players: {
        label: uv(),
        icon: Gd
      },
      alliances: {
        label: hv(),
        icon: Hd
      }
    },
    o = _t("regions"),
    K = _t(0),
    G = En({
      players: {},
      alliances: {},
      regions: {},
      countries: {}
    }),
    ie = vt(() => {
      var Ye, dt, rt;
      return b(o) === "regions" ? (dt = (Ye = G[b(o)][b(K)]) == null ? void 0 : Ye[b(F)]) == null ? void 0 : dt.entries : (rt = G[b(o)][b(F)]) == null ? void 0 : rt.entries
    });
  const de = 5 * 1e3;
  $r(() => {
    var qe;
    if (!l.open) return;
    const Ye = b(F),
      dt = b(o),
      rt = b(K);
    dt === "players" && (!G[dt][Ye] || Date.now() - G[dt][Ye].time > de) ? ci.leaderboardPlayers(Ye).then(pt => {
      G[dt][Ye] = {
        time: Date.now(),
        entries: pt
      }
    }).catch(pt => Zr.error(pt.message)) : dt === "alliances" && (!G[dt][Ye] || Date.now() - G[dt][Ye].time > de) ? ci.leaderboardAlliances(Ye).then(pt => {
      G[dt][Ye] = {
        time: Date.now(),
        entries: pt
      }
    }).catch(pt => Zr.error(pt.message)) : dt === "countries" && (!G[dt][Ye] || Date.now() - G[dt][Ye].time > de) ? ci.leaderboardCountries(Ye).then(pt => {
      G[dt][Ye] = {
        time: Date.now(),
        entries: pt
      }
    }).catch(pt => Zr.error(pt.message)) : dt === "regions" && (!((qe = G[dt][rt]) != null && qe[Ye]) || Date.now() - G[dt][rt][Ye].time > de) && ci.leaderboardRegions(Ye, rt).then(pt => {
      G[dt][rt] || (G[dt][rt] = {}), G[dt][rt][Ye] = {
        time: Date.now(),
        entries: pt
      }
    }).catch(pt => Zr.error(pt.message))
  });
  var fe = CA(),
    W = Et(fe);
  xn(W, 21, () => Object.entries(C), ([Ye, {
    label: dt,
    icon: rt
  }]) => Ye, (Ye, dt) => {
    var rt = vt(() => Zg(b(dt), 2));
    let qe = () => b(rt)[0],
      pt = () => b(rt)[1].label,
      at = () => b(rt)[1].icon;
    const ht = vt(at);
    var Re = cA(),
      xt = E(Re);
    $a(xt);
    var Q, re = $(xt, 2);
    cn(re, () => b(ht), (ce, Ee) => {
      Ee(ce, {
        get this() {
          return at()
        },
        class: "mr-1 size-5 max-sm:hidden"
      })
    });
    var xe = $(re);
    A(Re), lt(() => {
      Br(xt, "aria-label", pt()), Q !== (Q = qe()) && (xt.value = (xt.__value = qe()) ?? ""), Te(xe, ` ${pt()??""}`)
    }), Qf(_, [], xt, () => (qe(), b(o)), ce => he(o, ce)), H(Ye, Re)
  }), A(W);
  var le = $(W, 2),
    Ce = E(le);
  hm(Ce, {
    get value() {
      return b(F)
    },
    set value(Ye) {
      he(F, Ye, !0)
    }
  });
  var Me = $(Ce, 2);
  {
    var Le = Ye => {
      Bg(Ye, {
        dropdownDirection: "left",
        get countryId() {
          return b(K)
        },
        set countryId(dt) {
          he(K, dt, !0)
        }
      })
    };
    et(Me, Ye => {
      b(o) === "regions" && !b(z) && Ye(Le)
    })
  }
  A(le);
  var $e = $(le, 2);
  {
    var Oe = Ye => {
      var dt = uA(),
        rt = E(dt);
      Bg(rt, {
        get countryId() {
          return b(K)
        },
        set countryId(qe) {
          he(K, qe, !0)
        }
      }), A(dt), H(Ye, dt)
    };
    et($e, Ye => {
      b(o) === "regions" && b(z) && Ye(Oe)
    })
  }
  var Ve = $($e, 2);
  {
    var ct = Ye => {
        var dt = hA(),
          rt = E(dt),
          qe = $(rt);
        {
          var pt = ht => {
              var Re = sa();
              lt(xt => Te(Re, xt), [() => Ud().toLowerCase()]), H(ht, Re)
            },
            at = ht => {
              var Re = sr(),
                xt = Et(Re);
              {
                var Q = xe => {
                    var ce = sa();
                    lt(Ee => Te(ce, Ee), [() => nm()]), H(xe, ce)
                  },
                  re = xe => {
                    var ce = sr(),
                      Ee = Et(ce);
                    {
                      var Be = Ke => {
                        var tt = sa();
                        lt(ot => Te(tt, ot), [() => am()]), H(Ke, tt)
                      };
                      et(Ee, Ke => {
                        b(F) === "month" && Ke(Be)
                      }, !0)
                    }
                    H(xe, ce)
                  };
                et(xt, xe => {
                  b(F) === "week" ? xe(Q) : xe(re, !1)
                }, !0)
              }
              H(ht, Re)
            };
          et(qe, ht => {
            b(F) === "today" ? ht(pt) : ht(at, !1)
          })
        }
        A(dt), lt(ht => Te(rt, `${ht??""} `), [() => im()]), H(Ye, dt)
      },
      nt = Ye => {
        var dt = sr(),
          rt = Et(dt);
        {
          var qe = at => {
              var ht = sr(),
                Re = Et(ht);
              {
                var xt = re => {
                    const xe = vt(() => b(ie));
                    var ce = fA(),
                      Ee = E(ce),
                      Be = E(Ee),
                      Ke = $(E(Be)),
                      tt = E(Ke, !0);
                    A(Ke);
                    var ot = $(Ke),
                      ft = E(ot),
                      Bt = $(ft, 2),
                      At = $(Bt),
                      cr = E(At);
                    Hf(cr, {
                      class: "text-base-content/50 mb-0.5 ml-1 inline size-4"
                    }), A(At), A(ot), mi(), A(Be), A(Ee);
                    var Mt = $(Ee);
                    xn(Mt, 31, () => b(xe), yt => yt.id, (yt, St, jt) => {
                      const Lt = vt(() => as(b(St).countryId));
                      var Gt = pA(),
                        gr = E(Gt),
                        ur = E(gr, !0);
                      A(gr);
                      var Qt = $(gr),
                        er = E(Qt),
                        Dt = E(er, !0);
                      A(er);
                      var Ir = $(er, 2),
                        Tr = E(Ir),
                        Dr = $(Tr),
                        Fr = E(Dr);
                      A(Dr), A(Ir), A(Qt);
                      var dr = $(Qt),
                        Or = E(dr, !0);
                      A(dr);
                      var zr = $(dr),
                        tr = E(zr);
                      tr.__click = [dA, l, St];
                      var br = E(tr, !0);
                      A(tr), A(zr), A(Gt), lt(($t, yr, jr) => {
                        Te(ur, b(jt) + 1), Br(er, "data-tip", b(Lt).name), Te(Dt, b(Lt).flag), Vr(Ir, 1, `font-semibold ${$t??""}`), Te(Tr, `${b(St).name??""} `), Te(Fr, `#${b(St).number??""}`), Te(Or, yr), Te(br, jr)
                      }, [() => Yn(b(St).cityId), () => b(St).pixelsPainted.toLocaleString("en-US"), () => A3()]), Yo(Gt, () => Jo, () => ({
                        duration: 200
                      })), H(yt, Gt)
                    }), A(Mt), A(ce), lt((yt, St, jt, Lt) => {
                      Te(tt, yt), Te(ft, `${St??""} `), Te(Bt, `${jt??""} `), Br(At, "data-tip", Lt)
                    }, [() => y3(), () => Jl(), () => Ql().toLowerCase(), () => P3()]), H(re, ce)
                  },
                  Q = re => {
                    var xe = sr(),
                      ce = Et(xe);
                    {
                      var Ee = Ke => {
                          var tt = _A(),
                            ot = E(tt),
                            ft = E(ot),
                            Bt = $(E(ft)),
                            At = E(Bt, !0);
                          A(Bt);
                          var cr = $(Bt),
                            Mt = E(cr),
                            yt = $(Mt, 2),
                            St = $(yt),
                            jt = E(St);
                          Hf(jt, {
                            class: "text-base-content/50 mb-0.5 ml-1 inline size-4"
                          }), A(St), A(cr), A(ft), A(ot);
                          var Lt = $(ot);
                          xn(Lt, 31, () => b(ie), Gt => Gt.id, (Gt, gr, ur) => {
                            const Qt = vt(() => as(b(gr).id));
                            var er = mA(),
                              Dt = E(er),
                              Ir = E(Dt, !0);
                            A(Dt);
                            var Tr = $(Dt),
                              Dr = E(Tr),
                              Fr = E(Dr, !0);
                            A(Dr);
                            var dr = $(Dr, 2),
                              Or = E(dr, !0);
                            A(dr), A(Tr);
                            var zr = $(Tr),
                              tr = E(zr, !0);
                            A(zr), A(er), lt((br, $t) => {
                              Te(Ir, b(ur) + 1), Br(Dr, "data-tip", b(Qt).name), Te(Fr, b(Qt).flag), Vr(dr, 1, `font-semibold ${br??""}`), Te(Or, b(Qt).name), Te(tr, $t)
                            }, [() => Yn(b(gr).id), () => b(gr).pixelsPainted.toLocaleString("en-US")]), Yo(er, () => Jo, () => ({
                              duration: 200
                            })), H(Gt, er)
                          }), A(Lt), A(tt), lt((Gt, gr, ur, Qt) => {
                            Te(At, Gt), Te(Mt, `${gr??""} `), Te(yt, `${ur??""} `), Br(St, "data-tip", Qt)
                          }, [() => iv(), () => Jl(), () => Ql().toLowerCase(), () => aC()]), H(Ke, tt)
                        },
                        Be = Ke => {
                          var tt = sr(),
                            ot = Et(tt);
                          {
                            var ft = At => {
                                const cr = vt(() => b(ie));
                                var Mt = xA(),
                                  yt = E(Mt),
                                  St = E(yt),
                                  jt = $(E(St)),
                                  Lt = E(jt, !0);
                                A(jt);
                                var Gt = $(jt),
                                  gr = E(Gt),
                                  ur = $(gr, 2, !0);
                                A(Gt), A(St), A(yt);
                                var Qt = $(yt);
                                xn(Qt, 31, () => b(cr), er => er.id, (er, Dt, Ir) => {
                                  const Tr = vt(() => {
                                    var ze;
                                    return ((ze = Ot.data) == null ? void 0 : ze.id) === b(Dt).id
                                  });
                                  var Dr = yA();
                                  let Fr;
                                  var dr = E(Dr),
                                    Or = E(dr, !0);
                                  A(dr);
                                  var zr = $(dr),
                                    tr = E(zr),
                                    br = E(tr);
                                  ss(br, {
                                    class: "size-8 border sm:size-10",
                                    get userId() {
                                      return b(Dt).id
                                    },
                                    get pictureUrl() {
                                      return b(Dt).picture
                                    }
                                  });
                                  var $t = $(br, 2),
                                    yr = E($t),
                                    jr = E(yr),
                                    ye = $(jr),
                                    j = E(ye);
                                  A(ye), A(yr);
                                  var V = $(yr, 2);
                                  {
                                    var X = ze => {
                                      const Ie = vt(() => as(b(Dt).equippedFlag));
                                      var We = gA(),
                                        ve = E(We, !0);
                                      A(We), lt(() => {
                                        Br(We, "data-tip", b(Ie).name), Te(ve, b(Ie).flag)
                                      }), H(ze, We)
                                    };
                                    et(V, ze => {
                                      b(Dt).equippedFlag && ze(X)
                                    })
                                  }
                                  var se = $(V, 2);
                                  {
                                    var we = ze => {
                                      fh(ze, {
                                        get username() {
                                          return b(Dt).discord
                                        }
                                      })
                                    };
                                    et(se, ze => {
                                      b(Dt).discord && ze(we)
                                    })
                                  }
                                  var Ae = $(se, 2);
                                  {
                                    var Ze = ze => {
                                      var Ie = vA(),
                                        We = E(Ie, !0);
                                      A(Ie), lt((ve, Pt) => {
                                        Vr(Ie, 1, `badge badge-sm ml-0.5 border-0 ${ve??""} ${Pt??""}`), Te(We, b(Dt).allianceName)
                                      }, [() => em(b(Dt).allianceId), () => Yn(b(Dt).allianceId)]), H(ze, Ie)
                                    };
                                    et(Ae, ze => {
                                      "allianceName" in b(Dt) && b(Dt).allianceName && ze(Ze)
                                    })
                                  }
                                  A($t), A(tr), A(zr);
                                  var Se = $(zr),
                                    Ne = E(Se, !0);
                                  A(Se), A(Dr), lt((ze, Ie, We) => {
                                    Fr = Vr(Dr, 1, "", null, Fr, ze), Te(Or, b(Ir) + 1), Vr(yr, 1, `font-semibold max-sm:ml-2 ${Ie??""} flex gap-1`), Te(jr, `${b(Dt).name??""} `), Te(j, `#${b(Dt).id??""}`), Te(Ne, We)
                                  }, [() => ({
                                    "bg-base-200": b(Tr)
                                  }), () => Yn(b(Dt).id), () => b(Dt).pixelsPainted.toLocaleString("en-US")]), Yo(Dr, () => Jo, () => ({
                                    duration: 200
                                  })), H(er, Dr)
                                }), A(Qt), A(Mt), lt((er, Dt, Ir) => {
                                  Te(Lt, er), Te(gr, `${Dt??""} `), Te(ur, Ir)
                                }, [() => sm(), () => Jl(), () => Ql().toLowerCase()]), H(At, Mt)
                              },
                              Bt = At => {
                                var cr = sr(),
                                  Mt = Et(cr);
                                {
                                  var yt = St => {
                                    var jt = wA(),
                                      Lt = E(jt),
                                      Gt = E(Lt),
                                      gr = $(E(Gt)),
                                      ur = E(gr, !0);
                                    A(gr);
                                    var Qt = $(gr),
                                      er = E(Qt),
                                      Dt = $(er, 2, !0);
                                    A(Qt), A(Gt), A(Lt);
                                    var Ir = $(Lt);
                                    xn(Ir, 31, () => b(ie), Tr => Tr.id, (Tr, Dr, Fr) => {
                                      const dr = vt(() => {
                                        var V;
                                        return ((V = Ot.data) == null ? void 0 : V.allianceId) === b(Dr).id
                                      });
                                      var Or = bA();
                                      let zr;
                                      var tr = E(Or),
                                        br = E(tr, !0);
                                      A(tr);
                                      var $t = $(tr),
                                        yr = E($t),
                                        jr = E(yr, !0);
                                      A(yr), A($t);
                                      var ye = $($t),
                                        j = E(ye, !0);
                                      A(ye), A(Or), lt((V, X, se) => {
                                        zr = Vr(Or, 1, "", null, zr, V), Te(br, b(Fr) + 1), Vr(yr, 1, `font-semibold ${X??""}`), Te(jr, b(Dr).name), Te(j, se)
                                      }, [() => ({
                                        "bg-base-200": b(dr)
                                      }), () => Yn(b(Dr).id), () => b(Dr).pixelsPainted.toLocaleString("en-US")]), Yo(Or, () => Jo, () => ({
                                        duration: 200
                                      })), H(Tr, Or)
                                    }), A(Ir), A(jt), lt((Tr, Dr, Fr) => {
                                      Te(ur, Tr), Te(er, `${Dr??""} `), Te(Dt, Fr)
                                    }, [() => Zd(), () => Jl(), () => Ql().toLowerCase()]), H(St, jt)
                                  };
                                  et(Mt, St => {
                                    b(o) === "alliances" && St(yt)
                                  }, !0)
                                }
                                H(At, cr)
                              };
                            et(ot, At => {
                              b(o) === "players" ? At(ft) : At(Bt, !1)
                            }, !0)
                          }
                          H(Ke, tt)
                        };
                      et(ce, Ke => {
                        b(o) === "countries" ? Ke(Ee) : Ke(Be, !1)
                      }, !0)
                    }
                    H(re, xe)
                  };
                et(Re, re => {
                  b(o) === "regions" ? re(xt) : re(Q, !1)
                })
              }
              H(at, ht)
            },
            pt = at => {
              var ht = TA();
              H(at, ht)
            };
          et(rt, at => {
            b(ie) ? at(qe) : at(pt, !1)
          }, !0)
        }
        H(Ye, dt)
      };
    et(Ve, Ye => {
      b(ie) && b(ie).length === 0 ? Ye(ct) : Ye(nt, !1)
    })
  }
  Vd("innerWidth", Ye => he(T, Ye, !0)), H(y, fe), Er()
}
en(["click"]);
var PA = wr('<svg><path d="M160-200h160v-320H160v320Zm240 0h160v-560H400v560Zm240 0h160v-240H640v240ZM80-120v-480h240v-240h320v320h240v400H80Z"></path></svg>');

function Ov(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = PA();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var IA = De('<dialog class="modal"><div class="modal-box h-11/12 max-w-3xl max-sm:size-full max-sm:rounded-none max-sm:px-3 max-sm:py-5 sm:overflow-x-hidden"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold"> </h3></div> <div class="mt-4"><!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function MA(y, l) {
  kr(l, !0);
  let _ = It(l, "open", 15);
  Ii(() => {
    const de = fe => {
      fe.key === "Escape" && _(!1)
    };
    return document.addEventListener("keydown", de), () => document.removeEventListener("keydown", de)
  });
  var T = IA(),
    z = E(T),
    F = $(E(z), 2),
    C = E(F);
  Ov(C, {
    class: "size-6"
  });
  var o = $(C, 2),
    K = E(o, !0);
  A(o), A(F);
  var G = $(F, 2),
    ie = E(G);
  SA(ie, {
    get onvisitclick() {
      return l.onvisitclick
    },
    get open() {
      return _()
    }
  }), A(G), A(z), mi(2), A(T), qn(T, () => de => {
    $r(() => {
      _() ? de.show() : de.close()
    })
  }), lt(de => Te(K, de), [() => tm()]), bn("close", T, () => _(!1)), H(y, T), Er()
}
var AA = De("<div><!></div>"),
  kA = De('<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function EA(y, l) {
  kr(l, !0);
  let _ = It(l, "open", 15);
  Ii(() => {
    const o = K => {
      K.key === "Escape" && _(!1)
    };
    return document.addEventListener("keydown", o), () => document.removeEventListener("keydown", o)
  });
  var T = kA(),
    z = E(T),
    F = $(E(z), 2);
  {
    var C = o => {
      var K = AA(),
        G = E(K);
      Ex(G, {}), A(K), An(2, K, () => Kn, () => ({
        duration: 300
      })), H(o, K)
    };
    et(F, o => {
      _() && o(C)
    })
  }
  A(z), mi(2), A(T), qn(T, () => o => {
    $r(() => {
      _() ? o.show() : o.close()
    })
  }), bn("close", T, () => _(!1)), H(y, T), Er()
}
var zA = (y, l, _) => {
    localStorage.setItem(b(l), "true"), he(_, !1)
  },
  LA = De('<span class="indicator-item indicator-bottom indicator-center badge badge-primary badge-xs">new</span>'),
  DA = De("<div><!> <!></div>");

function vf(y, l) {
  kr(l, !0);
  let _ = _t(!1);
  const T = vt(() => "showed:" + l.key);
  Ii(() => {
    he(_, !localStorage.getItem(b(T)))
  });
  var z = DA();
  z.__click = [zA, T, _];
  var F = E(z);
  {
    var C = K => {
      var G = LA();
      An(3, G, () => Kn, () => ({
        duration: 200
      })), H(K, G)
    };
    et(F, K => {
      b(_) && K(C)
    })
  }
  var o = $(F, 2);
  Qi(o, () => l.children), A(z), lt(() => Vr(z, 1, `indicator ${l.class??""}`)), H(y, z), Er()
}
en(["click"]);
var RA = De("<p>You don't have charges to paint. <br/> </p>");

function BA(y, l) {
  kr(l, !1), Jg();
  var _ = RA(),
    T = $(E(_), 2);
  A(_), lt(z => Te(T, ` Next charge in ${z??""}`), [() => zd(Ot.cooldown ?? 0)]), H(y, _), Er()
}
var FA = De("<canvas></canvas>");

function Nv(y, l) {
  kr(l, !0);
  let _ = It(l, "width", 15, 0),
    T = Yt(l, ["$$slots", "$$events", "$$legacy", "value", "fontSize", "color", "weight", "mono", "width"]),
    z = vt(() => Math.ceil(l.fontSize)),
    F = _t(null);
  const C = window.devicePixelRatio ?? 1,
    o = '"Geist", ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"',
    K = '"Geist Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  $r(() => {
    const ie = b(F).getContext("2d");
    ie.textBaseline = "top", ie.font = `${l.weight??"normal"} ${l.fontSize}px ${l.mono?K:o}`, ie.fillStyle = l.color ?? "#394e6a", ie.setTransform(C, 0, 0, C, 0, 0), ie.clearRect(0, 0, _(), b(z)), ie.fillText(l.value, 0, 0);
    const de = ie.measureText(l.value);
    _(Math.ceil(de.actualBoundingBoxRight)), he(z, de.actualBoundingBoxDescent)
  });
  var G = FA();
  Kt(G, () => ({
    width: _() * C,
    height: b(z) * C,
    style: `width: ${_()??""}px; height: ${b(z)??""}px`,
    ...T
  })), Ss(G, ie => he(F, ie), () => b(F)), H(y, G), Er()
}
var OA = De('<span class="w-7 text-xs"> </span>'),
  NA = De('<span class="flex items-center gap-1 sm:mt-[1px]"><span><!></span> <!></span>'),
  jA = De('<span class="loading loading-spinner center-absolute absolute"></span>'),
  qA = De('<button><!> <div class="flex items-center gap-2"> <!></div> <!></button>');

function jv(y, l) {
  kr(l, !0);
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy", "loading", "charges"]),
    T = _t(0);
  var z = qA();
  Kt(z, () => ({
    ..._,
    class: `btn btn-primary btn-lg sm:btn-xl relative ${l.class??""}`
  }));
  var F = E(z);
  mh(F, {
    class: "size-6"
  });
  var C = $(F, 2),
    o = E(C),
    K = $(o);
  {
    var G = fe => {
      const W = vt(() => `${Math.floor(l.charges)}/${Ot.data.charges.max}`);
      var le = NA(),
        Ce = E(le),
        Me = E(Ce);
      {
        let Oe = vt(() => l.disabled ? "#394e6a33" : "#ffffff");
        Nv(Me, {
          weight: 600,
          fontSize: 16,
          get value() {
            return b(W)
          },
          get color() {
            return b(Oe)
          },
          get width() {
            return b(T)
          },
          set width(Ve) {
            he(T, Ve, !0)
          }
        })
      }
      A(Ce);
      var Le = $(Ce, 2);
      {
        var $e = Oe => {
          var Ve = OA(),
            ct = E(Ve);
          A(Ve), lt(nt => Te(ct, `(${nt??""})`), [() => zd(Ot.cooldown)]), H(Oe, Ve)
        };
        et(Le, Oe => {
          l.charges < Ot.data.charges.max && Ot.cooldown !== void 0 && Oe($e)
        })
      }
      A(le), lt(Oe => cc(Ce, `width: ${Oe??""}px`), [() => (Math.floor(b(T) / 5) + 1) * 5]), H(fe, le)
    };
    et(K, fe => {
      l.charges !== void 0 && Ot.data && fe(G)
    })
  }
  A(C);
  var ie = $(C, 2);
  {
    var de = fe => {
      var W = jA();
      H(fe, W)
    };
    et(ie, fe => {
      l.loading && fe(de)
    })
  }
  A(z), lt(fe => Te(o, `${fe??""} `), [() => av()]), H(y, z), Er()
}
const VA = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAABVQTFRFAAAASkKEenHEta7xWmmLi5y0v8vc+SuCVQAAAAF0Uk5TAEDm2GYAAAA/SURBVHjaXcjBDcAwDMNAUW28/8hF0MCIzN9RV7aVfuxp+IGPe+AdPQRpFaRrgcNrn/Bb4LAE4W5aNb3TXUofoSgBYpzN5I4AAAAASUVORK5CYII=",
  ZA = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAFxJREFUeNq107EJACAMRFEHyxSu4jbuZ+0IyhUS4ZDogYEr3++Svp+ZDUzGrRTMIwKmiIApImCKiBgbOXOEcRxQsQcW7rVKeA9gj5gD2D3mgC/GcQSLMEdO+/qtE+/GV5duYCOPAAAAAElFTkSuQmCC",
  $A = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAAXNSR0IArs4c6QAAAAJ0Uk5TAAB2k804AAAAKklEQVR42mOAAhsbCA3n//9vQ74ApqE2QIAgwIqBykFaICwMAQwt9HEpAIf2Me1Ro5Q9AAAAAElFTkSuQmCC",
  UA = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAABVJREFUeNpjYGA48x8DYwoB1Q0RlQDDCVmniJ241gAAAABJRU5ErkJggg==";

function GA(y, l, _) {
  return new Promise((T, z) => {
    y.once("render", () => {
      const F = y.getCanvas().toDataURL(),
        C = document.createElement("img");
      C.src = F, C.onload = () => {
        const o = document.createElement("canvas");
        o.width = C.width, o.height = C.height;
        const K = o.getContext("2d");
        if (K) {
          K.drawImage(C, 0, 0);
          const [G, ie, de, fe] = K.getImageData(l, _, 1, 1).data;
          T([G, ie, de, fe])
        } else z(new Error("Could not get 2d context from canvas"));
        C.remove(), o.remove()
      }
    }), y.triggerRepaint()
  })
}
class HA {
  constructor(l) {
    fr(this, "gm");
    fr(this, "opacity", 1);
    fr(this, "id", `paint-preview-${Math.random()}`);
    fr(this, "tiles", new Map);
    this.input = l, this.gm = new uc(this.input.tileSize)
  }
  place([l, _], T) {
    const {
      tile: z,
      pixel: F
    } = this.gm.latLonToTileAndPixel(l, _, this.input.tileZoom), C = this.getTileKey(z[0], z[1]);
    let o = this.tiles.get(C);
    if (!o) {
      const K = this.gm.tileBoundsLatLon(z[0], z[1], this.input.tileZoom),
        G = om(K, !0),
        ie = new WA({
          coordinates: G,
          id: `${this.id}-${C}`,
          layerPaint: {
            "raster-opacity": this.opacity,
            "raster-resampling": "nearest"
          },
          tileSize: this.input.tileSize,
          beforeLayerId: this.input.beforeLayerId
        });
      ie.addTo(this.input.map), this.tiles.set(C, ie), o = ie
    }
    o.place(F[0], this.input.tileSize - F[1] - 1, T)
  }
  clear() {
    const l = this.input.map;
    for (const _ of this.tiles.values()) _.removeFrom(l), _.removeDOM();
    this.tiles.clear()
  }
  clearAndPlace(l, _) {
    this.clear(), this.place(l, _)
  }
  remove([l, _]) {
    const {
      tile: T,
      pixel: z
    } = this.gm.latLonToTileAndPixel(l, _, this.input.tileZoom), F = this.getTileKey(T[0], T[1]), C = this.tiles.get(F);
    C && C.remove(z[0], this.input.tileSize - z[1] - 1)
  }
  setCanvasOpacity(l) {
    this.opacity = l;
    for (const _ of this.tiles.values()) _.setOpacity(l)
  }
  getTileKey(l, _) {
    return `${l},${_}`
  }
}
class WA {
  constructor(l) {
    fr(this, "canvas");
    fr(this, "maps", new Set);
    this.input = l;
    const _ = this.input.tileSize;
    this.canvas = document.createElement("canvas"), this.canvas.width = _, this.canvas.height = _
  }
  place(l, _, T) {
    var C;
    const z = ((C = jn.colors) == null ? void 0 : C[T]) ?? jn.colors[0],
      F = this.canvas.getContext("2d");
    if (F) {
      const o = F.createImageData(1, 1),
        [K, G, ie] = z.rgb,
        de = T === 0 ? 0 : 255;
      o.data[0] = K, o.data[1] = G, o.data[2] = ie, o.data[3] = de, F.putImageData(o, l, _)
    }
  }
  remove(l, _) {
    const T = this.canvas.getContext("2d");
    T && T.clearRect(l, _, 1, 1)
  }
  addTo(l) {
    const _ = this.input.id;
    l.getSource(_) || l.addSource(_, {
      type: "canvas",
      canvas: this.canvas,
      coordinates: this.input.coordinates
    }), l.getLayer(_) || (l.addLayer({
      id: _,
      type: "raster",
      source: _,
      paint: this.input.layerPaint
    }), this.input.beforeLayerId && l.moveLayer(_, this.input.beforeLayerId)), this.maps.add(l)
  }
  removeFrom(l) {
    const {
      id: _
    } = this.input;
    l.getLayer(_) && l.removeLayer(_), l.getSource(_) && l.removeSource(_), this.maps.delete(l)
  }
  removeDOM() {
    this.canvas.remove()
  }
  setOpacity(l) {
    for (const _ of this.maps.values()) _.setPaintProperty(this.input.id, "raster-opacity", l)
  }
}
var XA = wr('<svg><path d="M5 21C4.45 21 3.97917 20.8042 3.5875 20.4125C3.19583 20.0208 3 19.55 3 19V15H5V19H9V21H5ZM15 21V19H19V15H21V19C21 19.55 20.8042 20.0208 20.4125 20.4125C20.0208 20.8042 19.55 21 19 21H15ZM3 9V5C3 4.45 3.19583 3.97917 3.5875 3.5875C3.97917 3.19583 4.45 3 5 3H9V5H5V9H3ZM19 9V5H15V3H19C19.55 3 20.0208 3.19583 20.4125 3.5875C20.8042 3.97917 21 4.45 21 5V9H19Z"></path></svg>');

function KA(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = XA();
  Kt(T, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ..._
  })), H(y, T)
}
var YA = wr('<svg><path d="M5 19H9V21H5C4.45 21 3.97956 20.8038 3.58789 20.4121C3.19622 20.0204 3 19.55 3 19V15H5V19ZM20.6768 20.0908C20.6015 20.2031 20.5138 20.3105 20.4121 20.4121C20.0204 20.8038 19.55 21 19 21H15V19H19V18.4141L20.6768 20.0908ZM21 17.5859L19 15.5859V15H21V17.5859ZM5.58594 5H5V9H3V5C3 4.45 3.19622 3.97956 3.58789 3.58789C3.68947 3.48631 3.79597 3.3975 3.9082 3.32227L5.58594 5ZM19 3C19.55 3 20.0204 3.19622 20.4121 3.58789C20.8038 3.97956 21 4.45 21 5V9H19V5H15V3H19ZM9 5H8.41406L6.41406 3H9V5Z"></path><rect x="1" y="2.41422" width="2" height="29" transform="rotate(-45 1 2.41422)"></rect></svg>');

function JA(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = YA();
  Kt(T, () => ({
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ..._
  })), H(y, T)
}
var QA = De("<div><!></div>");

function Kl(y, l) {
  kr(l, !0);
  var _ = QA(),
    T = E(_);
  Qi(T, () => l.children ?? kn), A(_), lt(() => Vr(_, 1, `bg-base-100/60 border-base-content/20 -top-15 pointer-events-none absolute left-1/2 line-clamp-1 flex w-max -translate-x-1/2 select-none items-center gap-1 rounded-full border-2 px-3 py-1.5 ${l.class??""}`)), H(y, _), Er()
}
var ek = De('<div class="confetti svelte-15ksp55"></div>'),
  tk = De("<div></div>");

function gm(y, l) {
  kr(l, !0);
  const _ = It(l, "size", 3, 10),
    T = It(l, "x", 19, () => [-.5, .5]),
    z = It(l, "y", 19, () => [.25, 1]),
    F = It(l, "duration", 3, 2e3),
    C = It(l, "infinite", 3, !1),
    o = It(l, "delay", 19, () => [0, 50]),
    K = It(l, "colorRange", 19, () => [0, 360]),
    G = It(l, "colorArray", 19, () => []),
    ie = It(l, "amount", 3, 50),
    de = It(l, "iterationCount", 3, 1),
    fe = It(l, "fallDistance", 3, "100px"),
    W = It(l, "rounded", 3, !1),
    le = It(l, "cone", 3, !1),
    Ce = It(l, "noGravity", 3, !1),
    Me = It(l, "xSpread", 3, .15),
    Le = It(l, "destroyOnComplete", 3, !0),
    $e = It(l, "disableForReducedMotion", 3, !1);
  let Oe = _t(!1);
  Ii(() => {
    !Le() || C() || typeof de() == "string" || setTimeout(() => he(Oe, !0), (F() + o()[1]) * de())
  });

  function Ve(rt, qe) {
    return Math.random() * (qe - rt) + rt
  }

  function ct() {
    return G().length ? G()[Math.round(Math.random() * (G().length - 1))] : `hsl(${Math.round(Ve(K()[0],K()[1]))}, 75%, 50%)`
  }
  var nt = sr(),
    Ye = Et(nt);
  {
    var dt = rt => {
      var qe = tk();
      let pt;
      xn(qe, 21, () => ({
        length: ie()
      }), Yf, (at, ht) => {
        var Re = ek();
        lt((xt, Q, re, xe, ce, Ee, Be, Ke, tt, ot, ft) => cc(Re, `
        --color: ${xt??""};
        --skew: ${Q??""}deg,${re??""}deg;
        --rotation-xyz: ${xe??""}, ${ce??""}, ${Ee??""};
        --rotation-deg: ${Be??""}deg;
        --translate-y-multiplier: ${Ke??""};
        --translate-x-multiplier: ${tt??""};
        --scale: ${ot??""};
        --transition-delay: ${ft??""}ms;
        --transition-duration: ${C()?`calc(${F()}ms * var(--scale))`:`${F()}ms`};`), [ct, () => Ve(-45, 45), () => Ve(-45, 45), () => Ve(-10, 10), () => Ve(-10, 10), () => Ve(-10, 10), () => Ve(0, 360), () => Ve(z()[0], z()[1]), () => Ve(T()[0], T()[1]), () => .1 * Ve(2, 10), () => Ve(o()[0], o()[1])]), H(at, Re)
      }), A(qe), lt(at => {
        pt = Vr(qe, 1, "confetti-holder svelte-15ksp55", null, pt, at), cc(qe, `
    --fall-distance: ${fe()??""};
    --size: ${_()??""}px;
    --x-spread: ${1-Me()};
    --transition-iteration-count: ${(C()?"infinite":de())??""};`)
      }, [() => ({
        rounded: W(),
        cone: le(),
        "no-gravity": Ce(),
        "reduced-motion": $e()
      })]), H(rt, qe)
    };
    et(Ye, rt => {
      b(Oe) || rt(dt)
    })
  }
  H(y, nt), Er()
}
var rk = async (y, l, _, T) => {
  try {
    he(l, !0), await ci.purchase({
      id: _,
      amount: 1,
      variant: T.colorIdx
    }), await Ot.refresh(), ha.notification1.play()
  } catch (z) {
    Zr.error(z.message)
  } finally {
    he(l, !1)
  }
}, ik = De('<span class="loading loading-spinner center-absolute absolute"></span>'), nk = De('<!> <span class="text-sm">Droplets</span>', 1), ak = De('<!> Unlocked <span class="center-absolute absolute"><!></span>', 1), sk = (y, l) => l(!1), ok = De('<div class="flex flex-col gap-4"><section><div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold">Unlock</h3> <div class="ml-auto mr-4"><!></div></div> <p class="text-base-content/80 mt-1 text-sm">Permanently unlock the color</p></section> <div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><div class="border-base-content/20 size-32 rounded-2xl border-4"></div></div> <p class="mt-4 text-center text-2xl font-bold"> </p> <div class="flex w-max flex-col"><div><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <!></button></div> <button class="btn relative mt-3 h-10">Close</button></div></div></div>'), lk = De('<dialog class="modal !bg-black/80"><div class="modal-box max-h-11/12 w-11/12 max-w-md"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function ck(y, l) {
  kr(l, !0);
  let _ = It(l, "open", 15);
  const T = vt(() => jn.colors[l.colorIdx]),
    z = vt(() => {
      var W;
      return ((W = Ot.data) == null ? void 0 : W.droplets) ?? 0
    });
  let F = _t(!1);
  const C = vt(() => (b(F), Ot.hasColor(l.colorIdx)));
  Ii(() => {
    const W = le => {
      le.key === "Escape" && _(!1)
    };
    return document.addEventListener("keydown", W), () => document.removeEventListener("keydown", W)
  });
  const o = 100,
    K = jn.products[o];
  var G = lk(),
    ie = E(G),
    de = $(E(ie), 2);
  {
    var fe = W => {
      var le = ok(),
        Ce = E(le),
        Me = E(Ce),
        Le = E(Me);
      Ld(Le, {
        class: "size-6"
      });
      var $e = $(Le, 4),
        Oe = E($e);
      Kg(Oe, {
        get value() {
          return b(z)
        }
      }), A($e), A(Me), mi(2), A(Ce);
      var Ve = $(Ce, 2),
        ct = E(Ve),
        nt = E(ct);
      A(ct);
      var Ye = $(ct, 2),
        dt = E(Ye, !0);
      A(Ye);
      var rt = $(Ye, 2),
        qe = E(rt);
      let pt;
      var at = E(qe);
      at.__click = [rk, F, o, l];
      var ht = E(at);
      {
        var Re = ce => {
          var Ee = ik();
          H(ce, Ee)
        };
        et(ht, ce => {
          b(F) && ce(Re)
        })
      }
      var xt = $(ht, 2);
      {
        var Q = ce => {
            var Ee = nk(),
              Be = Et(Ee);
            qd(Be, {
              class: "size-5"
            });
            var Ke = $(Be);
            mi(), lt(tt => Te(Ke, ` ${tt??""} `), [() => K.price.toLocaleString("en-US")]), H(ce, Ee)
          },
          re = ce => {
            var Ee = ak(),
              Be = Et(Ee);
            Ld(Be, {
              class: "size-5"
            });
            var Ke = $(Be, 2),
              tt = E(Ke);
            gm(tt, {}), A(Ke), H(ce, Ee)
          };
        et(xt, ce => {
          b(C) ? ce(re, !1) : ce(Q)
        })
      }
      A(at), A(qe);
      var xe = $(qe, 2);
      xe.__click = [sk, _], A(rt), A(Ve), A(le), lt((ce, Ee) => {
        cc(nt, `background: rgb(${b(T).rgb[0]} ${b(T).rgb[1]} ${b(T).rgb[2]})`), Br(nt, "aria-label", b(T).name), Te(dt, b(T).name), Br(qe, "data-tip", ce), pt = Vr(qe, 1, "", null, pt, Ee), at.disabled = b(z) < K.price || b(F) || b(C)
      }, [() => $d(), () => ({
        tooltip: !b(C) && b(z) < K.price
      })]), H(W, le)
    };
    et(de, W => {
      Ot.data && W(fe)
    })
  }
  A(ie), mi(2), A(G), qn(G, () => W => {
    $r(() => {
      _() ? W.show() : W.close()
    })
  }), bn("close", G, () => _(!1)), H(y, G), Er()
}
en(["click"]);
var uk = wr('<svg><path d="M200-80q-50 0-85-35t-35-85q0-39 22.5-69.5T160-313v-334q-35-13-57.5-43.5T80-760q0-50 35-85t85-35q39 0 69.5 22.5T313-800h334q12-35 42.5-57.5T760-880q50 0 85 35t35 85q0 40-22.5 70.5T800-647v334q35 13 57.5 43.5T880-200q0 50-35 85t-85 35q-39 0-69.5-22.5T647-160H313q-13 35-43.5 57.5T200-80Zm0-640q17 0 28.5-11.5T240-760q0-17-11.5-28.5T200-800q-17 0-28.5 11.5T160-760q0 17 11.5 28.5T200-720Zm560 0q17 0 28.5-11.5T800-760q0-17-11.5-28.5T760-800q-17 0-28.5 11.5T720-760q0 17 11.5 28.5T760-720ZM313-240h334q9-26 28-45t45-28v-334q-26-9-45-28t-28-45H313q-9 26-28 45t-45 28v334q26 9 45 28t28 45Zm447 80q17 0 28.5-11.5T800-200q0-17-11.5-28.5T760-240q-17 0-28.5 11.5T720-200q0 17 11.5 28.5T760-160Zm-560 0q17 0 28.5-11.5T240-200q0-17-11.5-28.5T200-240q-17 0-28.5 11.5T160-200q0 17 11.5 28.5T200-160Zm0-600Zm560 0Zm0 560Zm-560 0Z"></path></svg>');

function Fg(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = uk();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var hk = wr('<svg><path d="M120-120v-190l358-358-58-56 58-56 76 76 124-124q5-5 12.5-8t15.5-3q8 0 15 3t13 8l94 94q5 6 8 13t3 15q0 8-3 15.5t-8 12.5L705-555l76 78-57 57-56-58-358 358H120Zm80-80h78l332-334-76-76-334 332v78Zm447-410 96-96-37-37-96 96 37 37Zm0 0-37-37 37 37Z"></path></svg>');

function Og(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = hk();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var dk = wr('<svg><path d="m247-904 57-56 343 343q23 23 23 57t-23 57L457-313q-23 23-57 23t-57-23L153-503q-23-23-23-57t23-57l190-191-96-96Zm153 153L209-560h382L400-751Zm360 471q-33 0-56.5-23.5T680-360q0-21 12.5-45t27.5-45q9-12 19-25t21-25q11 12 21 25t19 25q15 21 27.5 45t12.5 45q0 33-23.5 56.5T760-280ZM80 0v-160h800V0H80Z"></path></svg>');

function qv(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = dk();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var pk = wr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm240-400v80h80v-80h-80Zm-160 0v80h80v-80h-80Zm80 80v80h80v-80h-80Zm160 0v80h80v-80h-80Zm-320 0v80h80v-80h-80Zm400-80v80h80v80h80v-80h-80v-80h-80ZM280-360v80h-80v80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h-80v80h-80v-80h-80v80h-80v-80h-80Zm480-160v80-80Zm0 160v80-80Z"></path></svg>'),
  fk = wr('<svg><path d="M440-440v-80h80v80h-80Zm-80 80v-80h80v80h-80Zm160 0v-80h80v80h-80Zm80-80v-80h80v80h-80Zm-320 0v-80h80v80h-80Zm-80 320q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm80-80h80v-80h-80v80Zm160 0h80v-80h-80v80Zm320 0v-80 80Zm-560-80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h80v-320H200v320h80v80h-80v80Zm0 80v-560 560Zm560-240v80-80ZM600-280v80h80v-80h-80Z"></path></svg>');

function Vv(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy", "filled"]);
  var T = sr(),
    z = Et(T);
  {
    var F = o => {
        var K = pk();
        Kt(K, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ..._
        })), H(o, K)
      },
      C = o => {
        var K = fk();
        Kt(K, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ..._
        })), H(o, K)
      };
    et(z, o => {
      l.filled ? o(F) : o(C, !1)
    })
  }
  H(y, T)
}
var mk = wr('<svg><path d="M240-80q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640h40v-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240Zm0-80h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM360-640h240v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85v80ZM240-160v-400 400Z"></path></svg>');

function Wf(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = mk();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var _k = wr('<svg><path d="M419-80q-28 0-52.5-12T325-126L107-403l19-20q20-21 48-25t52 11l74 45v-328q0-17 11.5-28.5T340-760q17 0 29 11.5t12 28.5v472l-97-60 104 133q6 7 14 11t17 4h221q33 0 56.5-23.5T720-240v-160q0-17-11.5-28.5T680-440H461v-80h219q50 0 85 35t35 85v160q0 66-47 113T640-80H419ZM167-620q-13-22-20-47.5t-7-52.5q0-83 58.5-141.5T340-920q83 0 141.5 58.5T540-720q0 27-7 52.5T513-620l-69-40q8-14 12-28.5t4-31.5q0-50-35-85t-85-35q-50 0-85 35t-35 85q0 17 4 31.5t12 28.5l-69 40Zm335 280Z"></path></svg>');

function Zv(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = _k();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var gk = wr('<svg><path d="m356-160-56-56 180-180 180 180-56 56-124-124-124 124Zm124-404L300-744l56-56 124 124 124-124 56 56-180 180Z"></path></svg>');

function vk(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = gk();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var yk = wr('<svg><path d="M480-120 300-300l58-58 122 122 122-122 58 58-180 180ZM358-598l-58-58 180-180 180 180-58 58-122-122-122 122Z"></path></svg>');

function xk(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = yk();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var bk = De("<!> ", 1),
  wk = De("<!> ", 1),
  Tk = De("<!> ", 1),
  Ck = De('<!><b> </b> <span class="touchscreen:hidden"> <span class="kbd kbd-xs text-base-content rounded-md"> </span></span> ', 1),
  Sk = De("<!> ", 1),
  Pk = De("<!> <!>", 1),
  Ik = (y, l) => he(l, !b(l)),
  Mk = (y, l) => {
    he(l, "colorpicker")
  },
  Ak = (y, l) => {
    l(!l())
  },
  kk = (y, l) => {
    he(l, "cleararea")
  },
  Ek = De('<div class="tooltip ml-1"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">C</kbd></div> <button><!></button></div>'),
  zk = (y, l) => {
    ha.smallPlop.play(), l()
  },
  Lk = (y, l, _) => {
    l(b(_).idx)
  },
  Dk = De('<!> <span class="bg-base-100 translate-1/2 absolute bottom-0 right-0 flex size-5 items-center justify-center rounded-full max-sm:hidden"><!></span>', 1),
  Rk = De("<div><button><!></button></div>"),
  Bk = (y, l) => {
    he(l, !b(l))
  },
  Fk = (y, l) => {
    he(l, b(l) === "eraser" ? "pencil" : "eraser", !0)
  },
  Ok = De('<div class="relative px-3"><!> <div class="flex items-center gap-1.5"><button class="btn btn-circle btn-sm btn-soft"><!></button> <div class="flex grow items-center gap-1"><h2 class="select-none text-xl"> <!></h2> <div class="tooltip ml-1"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">I</kbd></div> <button><!></button></div> <div class="tooltip"><button title="Toggle art opacity"><!></button></div> <!></div> <button class="btn btn-circle btn-sm"><!></button></div> <div class="mb-4 mt-3"><div></div></div> <div class="relative h-12 sm:h-14"><button class="btn btn-lg btn-square sm:btn-xl absolute bottom-0 left-0 shadow-md"><!></button> <div class="absolute bottom-0 left-1/2 -translate-x-1/2"><!></div> <div class="absolute bottom-0 right-0"><div class="tooltip ml-auto"><div class="tooltip-content not-touchscreen:-translate-x-[10%]"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">E</kbd></div> <button><!></button></div></div></div></div> <!>', 1);

function Nk(y, l) {
  kr(l, !0);
  let _ = It(l, "screenLocked", 15),
    T = It(l, "opaquePixelArt", 15);
  const z = vt(() => new uc(l.tileSize));
  let F = _t(1),
    C = _t("pencil");
  const o = new Map,
    K = new Map;
  let G = _t(0),
    ie = _t(!1),
    de = _t(!0),
    fe = vt(() => Ot.charges ?? 0),
    W = vt(() => b(fe) - b(G)),
    le = _t(!1),
    Ce = !1,
    Me = _t(!1),
    Le = _t(En([]));
  const $e = vt(() => b(C) === "pencil"),
    Oe = vt(() => b(C) === "eraser"),
    Ve = vt(() => b(C) === "colorpicker"),
    ct = vt(() => b(C) === "cleararea");
  let nt = _t(!1),
    Ye = _t(0),
    dt = _t(void 0),
    rt = _t(void 0);
  const qe = [1, 2, 3, 32, 4, 5, 6, 33, 7, 34, 35, 8, 9, 10, 11, 37, 38, 39, 40, 41, 42, 12, 13, 14, 15, 16, 17, 43, 20, 44, 18, 19, 45, 46, 21, 22, 47, 48, 49, 23, 24, 25, 26, 27, 28, 53, 54, 55, 29, 30, 50, 56, 57, 36, 51, 31, 52, 61, 62, 63, 58, 59, 60, 0].map(je => ({
      ...jn.colors[je],
      idx: je
    })),
    pt = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0].map(je => ({
      ...jn.colors[je],
      idx: je
    }));
  let at = _t(!1);
  const ht = vt(() => b(at) ? qe : pt),
    Re = "show-all-colors";
  Ii(() => {
    he(at, localStorage.getItem(Re) === "true")
  }), $r(() => {
    localStorage.setItem(Re, b(at) ? "true" : "false")
  });
  const xt = "selected-color";
  Ii(() => {
    const je = Number(localStorage.getItem(xt));
    !isNaN(je) && je < jn.colors.length && je > 0 && he(F, je, !0)
  }), $r(() => {
    localStorage.setItem(xt, b(F).toString())
  });
  const Q = new HA({
    map: l.map,
    tileSize: l.tileSize,
    tileZoom: l.tileZoom,
    beforeLayerId: l.hoverLayerId
  });
  $r(() => {
    const je = T() ? 1 : 0;
    Q.setCanvasOpacity(je)
  }), $r(() => {
    T() ? bf() : tt([...o.values()])
  });
  let re = !1;
  Ii(() => {
    qa(l.map.getCenter(), l.map.getZoom());
    const je = l.map.on("click", Ar => {
      var fi;
      l.zoom < l.tileZoom + 2 && !((fi = Ot.data) != null && fi.isModerator) && l.map.easeTo({
        center: Ar.lngLat,
        zoom: 17
      });
      const qr = [Ar.lngLat.lat, Ar.lngLat.lng];
      if (b($e)) ce([qr], b(F));
      else if (b(Oe)) Ee([qr]);
      else if (b(Ve)) Be(qr, Ar.point);
      else if (b(ct) && (b(Le).push(qr), ce([qr], 0), b(Le).length >= 2)) {
        const [nn, un] = b(Le), [bt, Rt] = b(z).latLonToPixelsFloor(nn[0], nn[1], l.tileZoom), [Zt, hi] = b(z).latLonToPixelsFloor(un[0], un[1], l.tileZoom), gi = Math.min(bt, Zt), Ei = Math.max(bt, Zt), si = Math.min(Rt, hi), vr = Math.max(Rt, hi), Xi = [];
        for (let Jt = si; Jt <= vr; Jt++) {
          const Vt = b(z).pixelsToLatLon(gi + .5, Jt + .5, l.tileZoom),
            Ur = b(z).pixelsToLatLon(Ei + .5, Jt + .5, l.tileZoom),
            Kr = Ut({
              lat: Vt[0],
              lng: Vt[1]
            }, {
              lat: Ur[0],
              lng: Ur[1]
            }).slice(0, b(W) - Xi.length);
          if (Xi.push(...Kr), Xi.length >= b(W)) break
        }
        ce(Xi, 0), he(Le, [], !0), he(C, "pencil")
      }
      he(le, !0)
    });

    function Ut(Ar, qr) {
      const fi = b(z).latLonToPixels(Ar.lat, Ar.lng, l.tileZoom),
        nn = qr ? b(z).latLonToPixels(qr.lat, qr.lng, l.tileZoom) : fi;
      return wx(fi, nn).map(bt => b(z).pixelsToLatLon(bt[0] + .5, bt[1] + .5, l.tileZoom))
    }

    function nr(Ar, qr) {
      const fi = Ut(Ar, qr);
      b($e) ? ce(fi, b(F)) : b(Oe) && Ee(fi), he(le, !0)
    }
    let Gr;

    function Xr(Ar) {
      const qr = l.map.unproject([Ar.clientX, Ar.clientY]);
      if (b(Me)) {
        const fi = Ut(qr, Gr);
        Ee(fi)
      }(re || Ce) && nr(qr, Gr), Gr = qr
    }
    window.addEventListener("mousemove", Xr);
    let gt = !1;
    const hr = l.map.on("touchstart", Ar => {
        if (Ar.points.length == 2) {
          _(!1), At(), gt = !0, setTimeout(() => gt = !1, 150);
          return
        }
        _() && setTimeout(() => {
          !gt && nr(Ar.lngLat)
        }, 150), Gr = Ar.lngLat
      }),
      xr = l.map.on("touchmove", Ar => {
        _() && nr(Ar.lngLat, Gr), Gr = Ar.lngLat
      }),
      ai = Ar => {
        Ar.code === "Space" && (re || Gr && nr(Gr), re = !0, Ar.preventDefault())
      };
    document.addEventListener("keydown", ai);
    const ki = Ar => {
      Ar.code === "Space" && (re = !1, xe = !1, b(G) === 0 && b(Oe) && he(C, "pencil"))
    };
    document.addEventListener("keyup", ki);

    function _i(Ar) {
      if (Ar.button === 2) {
        he(Me, !0);
        const fi = l.map.unproject([Ar.clientX, Ar.clientY]);
        Ee([
          [fi.lat, fi.lng]
        ])
      }
    }
    document.addEventListener("mousedown", _i);

    function _r(Ar) {
      Ar.button === 2 && he(Me, !1)
    }
    document.addEventListener("mouseup", _r);
    const Ti = Ar => {
      var qr, fi;
      switch (Ar.code) {
        case "KeyE":
          b(G) > 0 && (b(Oe) ? he(C, "pencil") : he(C, "eraser"));
          return;
        case "KeyI":
          he(C, "colorpicker");
          return;
        case "KeyC":
          (fi = (qr = Ot) == null ? void 0 : qr.data) != null && fi.isModerator && he(C, "cleararea");
          return
      }
    };
    return document.addEventListener("keypress", Ti), () => {
      xr.unsubscribe(), hr.unsubscribe(), je.unsubscribe(), document.removeEventListener("mousemove", Xr), document.removeEventListener("keydown", ai), document.removeEventListener("keyup", ki), document.removeEventListener("keypress", Ti), document.removeEventListener("mousedown", _i), document.removeEventListener("mouseup", _r), ot()
    }
  });
  let xe = !1;

  function ce(je, Ut) {
    let nr = !1;
    const Gr = Ut === 0;
    for (let Xr of je) {
      const [gt, hr] = Xr, xr = Tx(Ut), {
        tile: ai,
        pixel: ki
      } = b(z).latLonToTileAndPixel(gt, hr, l.tileZoom), _i = {
        color: xr,
        tile: ai,
        pixel: ki,
        season: l.season,
        colorIdx: Ut
      }, _r = hf(_i), Ti = o.get(_r), Ar = b(fe) - o.size;
      if (!Ti && Ar < 1) {
        if (xe && (re || _())) continue;
        xe = !0, Zr.info(hC());
        continue
      }
      Ti && Ti.colorIdx === Ut || (ha.plop.play(), nr || l.hidePixelHover(), o.set(_r, _i), Q.place(Xr, Ut), l.crosshair.place(Xr), nr = !0, Gr && K.set(_r, _i))
    }
    he(G, o.size, !0), nr && !T() ? tt([...o.values()]) : nr && T() && Gr && tt([...K.values()])
  }

  function Ee(je) {
    let Ut = !1,
      nr = !1;
    for (let Gr of je) {
      const [Xr, gt] = Gr, {
        tile: hr,
        pixel: xr
      } = b(z).latLonToTileAndPixel(Xr, gt, l.tileZoom), ai = hf({
        tile: hr,
        pixel: xr,
        season: l.season
      }), ki = o.get(ai);
      ki && (ha.plop.play(), l.hidePixelHover(), o.delete(ai), K.delete(ai), Q.remove([Xr, gt]), l.crosshair.remove(Gr), Ut = !0, ki.colorIdx === 0 && (nr = !0)), o.size === 0 && !(re || Ce || _()) && he(C, "pencil")
    }
    he(G, o.size, !0), Ut && !T() ? tt([...o.values()]) : Ut && T() && nr && tt([...K.values()])
  }

  function Be(je, Ut) {
    const {
      tile: nr,
      pixel: Gr
    } = b(z).latLonToTileAndPixel(je[0], je[1], l.tileZoom), Xr = hf({
      tile: nr,
      pixel: Gr,
      season: l.season
    }), gt = o.get(Xr);
    if (gt) {
      cr(gt.colorIdx), requestAnimationFrame(() => {
        var ki;
        (ki = document.getElementById(`color-${gt.colorIdx}`)) == null || ki.focus()
      });
      return
    }
    const hr = window.devicePixelRatio,
      xr = Math.floor(Ut.x * hr),
      ai = Math.floor(Ut.y * hr);
    l.hidePixelHover(), GA(l.map, xr, ai).then(([ki, _i, _r]) => {
      const Ti = Cx({
        r: ki,
        g: _i,
        b: _r
      });
      cr(Ti), requestAnimationFrame(() => {
        var Ar;
        (Ar = document.getElementById(`color-${Ti}`)) == null || Ar.focus()
      })
    })
  }
  hc(() => b(F), () => {
    l.clickedLatLon && !b(le) && (b(F) === void 0 && he(F, 1), ce([l.clickedLatLon], b(F)))
  }), $r(() => {
    const je = b(de) ? .8 : 0;
    l.crosshair.setCanvasOpacity(je)
  });
  let Ke = _t(16.5);
  $r(() => {
    if (b(dt) && b(rt) && l.clickedLatLon) {
      const je = l.map.getZoom();
      if (je < b(Ke)) {
        const [Ut, nr] = l.clickedLatLon, Gr = b(z).latLonToPixelBoundsLatLon(Ut, nr, l.tileZoom), Xr = lm(Gr), gt = b(dt) - b(rt).clientHeight, hr = b(dt) / 2 - gt / 2;
        l.map.flyTo({
          center: {
            lat: Xr[0],
            lng: Xr[1]
          },
          zoom: 17.5,
          offset: je > 11 ? [0, -hr] : [0, 0]
        })
      }
      he(Ke, l.tileZoom, !0)
    }
  }), Ii(() => {
    const je = () => {
      !document.hidden && (console.log("Tab visible again"), T() ? tt([...K.values()]) : tt([...o.values()]))
    };
    return document.addEventListener("visibilitychange", je), () => document.removeEventListener("visibilitychange", je)
  }), $r(() => {
    switch (b(C)) {
      case "pencil":
        l.map.getCanvas().style.cursor = `url('${$A}') 8 8, default`, l.map.setPaintProperty(l.hoverLayerId, "raster-opacity", .4);
        return;
      case "colorpicker":
        l.map.getCanvas().style.cursor = `url('${VA}') 0 16, default`, l.map.setPaintProperty(l.hoverLayerId, "raster-opacity", 0);
        return;
      case "eraser":
        l.map.getCanvas().style.cursor = `url('${ZA}') 2 14, default`, l.map.setPaintProperty(l.hoverLayerId, "raster-opacity", .4);
        return
    }
  }), $r(() => {
    _() ? Bt() : At()
  });
  async function tt(je) {
    await gx(je), l.refreshPixelArt()
  }
  async function ot() {
    await bf(), Q.clear(), l.refreshPixelArt(), l.crosshair.clear()
  }
  async function ft() {
    await ot(), At(), l.map.getCanvas().style.cursor = "default", l.map.setPaintProperty(l.hoverLayerId, "raster-opacity", .4), l.onclose()
  }

  function Bt() {
    l.map.dragPan.disable(), l.map.touchZoomRotate.disable(), document.body.style.overscrollBehavior = "none"
  }

  function At() {
    l.map.dragPan.enable(), l.map.touchZoomRotate.enable(), document.body.style.overscrollBehavior = ""
  }

  function cr(je) {
    return je >= 32 && he(at, !0), Ot.hasColor(je) ? (ha.smallDropplet.play(), he(F, je, !0), he(C, "pencil"), !0) : (ha.smallDropplet.play(), he(nt, !0), he(Ye, je, !0), !1)
  }
  yx(je => {
    je.type === "leave" && b(G) > 0 && je.cancel()
  });
  const Mt = "show-paint-more-than-one-pixel-msg";
  let yt = _t(!1);
  Ii(() => {
    var je;
    he(yt, !localStorage.getItem(Mt) && (((je = Ot.data) == null ? void 0 : je.pixelsPainted) ?? 0) < 100, !0)
  }), $r(() => {
    b(G) > 1 && (he(yt, !1), localStorage.setItem(Mt, "false"))
  });
  const St = "lp";
  Ii(() => {
    var Ut;
    const je = localStorage.getItem(St);
    if (je) try {
      const nr = JSON.parse(atob(je)),
        Gr = (nr == null ? void 0 : nr.time) ?? 0,
        Xr = 60 * 1e3;
      (nr == null ? void 0 : nr.userId) !== ((Ut = Ot.data) == null ? void 0 : Ut.id) && Date.now() - Gr < 30 * Xr && !Sx && (Zr.error(fC()), ft())
    } catch (nr) {
      console.error(nr)
    }
  });

  function jt() {
    var Ut;
    const je = btoa(JSON.stringify({
      userId: (Ut = Ot.data) == null ? void 0 : Ut.id,
      time: Date.now()
    }));
    localStorage.setItem(St, je)
  }
  var Lt = Ok(),
    Gt = Et(Lt),
    gr = E(Gt);
  {
    var ur = je => {
        Kl(je, {
          children: (Ut, nr) => {
            var Gr = bk(),
              Xr = Et(Gr);
            qv(Xr, {
              class: "inline size-5"
            });
            var gt = $(Xr);
            lt(hr => Te(gt, ` ${hr??""}`), [() => Iw()]), H(Ut, Gr)
          },
          $$slots: {
            default: !0
          }
        })
      },
      Qt = je => {
        var Ut = sr(),
          nr = Et(Ut);
        {
          var Gr = gt => {
              Kl(gt, {
                class: "not-touchscreen:hidden",
                children: (hr, xr) => {
                  var ai = wk(),
                    ki = Et(ai);
                  bg(ki, {
                    class: "inline size-5"
                  });
                  var _i = $(ki);
                  lt(_r => Te(_i, ` ${_r??""}`), [() => kw()]), H(hr, ai)
                },
                $$slots: {
                  default: !0
                }
              })
            },
            Xr = gt => {
              var hr = sr(),
                xr = Et(hr);
              {
                var ai = _i => {
                    Kl(_i, {
                      class: "not-touchscreen:hidden",
                      children: (_r, Ti) => {
                        var Ar = Tk(),
                          qr = Et(Ar);
                        Og(qr, {
                          class: "inline size-5"
                        });
                        var fi = $(qr, 1, !0);
                        lt(nn => Te(fi, nn), [() => Lw()]), H(_r, Ar)
                      },
                      $$slots: {
                        default: !0
                      }
                    })
                  },
                  ki = _i => {
                    var _r = sr(),
                      Ti = Et(_r);
                    {
                      var Ar = fi => {
                          Kl(fi, {
                            class: "touchscreen:hidden",
                            children: (nn, un) => {
                              var bt = Ck(),
                                Rt = Et(bt);
                              Zv(Rt, {
                                class: "inline size-5"
                              });
                              var Zt = $(Rt),
                                hi = E(Zt, !0);
                              A(Zt);
                              var gi = $(Zt, 2),
                                Ei = E(gi),
                                si = $(Ei),
                                vr = E(si, !0);
                              A(si), A(gi);
                              var Xi = $(gi);
                              lt((Jt, Vt, Ur, Kr) => {
                                Te(hi, Jt), Te(Ei, `${Vt??""} `), Te(vr, Ur), Te(Xi, ` ${Kr??""}`)
                              }, [() => Bw(), () => Vw(), () => Nw(), () => Uw()]), H(nn, bt)
                            },
                            $$slots: {
                              default: !0
                            }
                          })
                        },
                        qr = fi => {
                          var nn = sr(),
                            un = Et(nn);
                          {
                            var bt = Zt => {
                                Kl(Zt, {
                                  class: "bg-warning text-warning-content animate-bounce",
                                  children: (hi, gi) => {
                                    var Ei = Sk(),
                                      si = Et(Ei);
                                    mh(si, {
                                      class: "inline size-5"
                                    });
                                    var vr = $(si);
                                    lt(Xi => Te(vr, ` ${Xi??""}`), [() => Ww()]), H(hi, Ei)
                                  },
                                  $$slots: {
                                    default: !0
                                  }
                                })
                              },
                              Rt = Zt => {
                                var hi = sr(),
                                  gi = Et(hi);
                                {
                                  var Ei = si => {
                                    Kl(si, {
                                      class: "bg-warning text-warning-content animate-bounce",
                                      children: (vr, Xi) => {
                                        var Jt = Pk(),
                                          Vt = Et(Jt);
                                        Fg(Vt, {
                                          class: "inline size-5"
                                        });
                                        var Ur = $(Vt, 2);
                                        {
                                          var Kr = Yr => {
                                              var wi = sa();
                                              lt(Fi => Te(wi, Fi), [() => QS()]), H(Yr, wi)
                                            },
                                            bi = Yr => {
                                              var wi = sr(),
                                                Fi = Et(wi);
                                              {
                                                var Ci = zi => {
                                                  var Li = sa();
                                                  lt(vi => Te(Li, vi), [() => rP()]), H(zi, Li)
                                                };
                                                et(Fi, zi => {
                                                  b(Le).length === 1 && zi(Ci)
                                                }, !0)
                                              }
                                              H(Yr, wi)
                                            };
                                          et(Ur, Yr => {
                                            b(Le).length === 0 ? Yr(Kr) : Yr(bi, !1)
                                          })
                                        }
                                        H(vr, Jt)
                                      },
                                      $$slots: {
                                        default: !0
                                      }
                                    })
                                  };
                                  et(gi, si => {
                                    b(ct) && si(Ei)
                                  }, !0)
                                }
                                H(Zt, hi)
                              };
                            et(un, Zt => {
                              b(yt) ? Zt(bt) : Zt(Rt, !1)
                            }, !0)
                          }
                          H(fi, nn)
                        };
                      et(Ti, fi => {
                        b($e) && b(G) === 0 ? fi(Ar) : fi(qr, !1)
                      }, !0)
                    }
                    H(_i, _r)
                  };
                et(xr, _i => {
                  b(Ve) ? _i(ai) : _i(ki, !1)
                }, !0)
              }
              H(gt, hr)
            };
          et(nr, gt => {
            b(Oe) ? gt(Gr) : gt(Xr, !1)
          }, !0)
        }
        H(je, Ut)
      };
    et(gr, je => {
      b(Oe) && b(G) === 0 ? je(ur) : je(Qt, !1)
    })
  }
  var er = $(gr, 2),
    Dt = E(er);
  Dt.__click = [Ik, de];
  var Ir = E(Dt);
  {
    var Tr = je => {
        KA(je, {
          class: "size-4"
        })
      },
      Dr = je => {
        JA(je, {
          class: "size-4"
        })
      };
    et(Ir, je => {
      b(de) ? je(Tr) : je(Dr, !1)
    })
  }
  A(Dt);
  var Fr = $(Dt, 2),
    dr = E(Fr),
    Or = E(dr),
    zr = $(Or);
  Nv(zr, {
    class: "inline",
    fontSize: 14,
    get value() {
      return `(${b(G)??""})`
    },
    mono: !0
  }), A(dr);
  var tr = $(dr, 2),
    br = E(tr),
    $t = E(br);
  mi(), A(br);
  var yr = $(br, 2);
  yr.__click = [Mk, C];
  var jr = E(yr);
  Og(jr, {
    class: "size-4.5"
  }), A(yr), A(tr);
  var ye = $(tr, 2),
    j = E(ye);
  let V;
  j.__click = [Ak, T];
  var X = E(j);
  {
    let je = vt(() => !T());
    Vv(X, {
      class: "size-4.5",
      get filled() {
        return b(je)
      }
    })
  }
  A(j), A(ye);
  var se = $(ye, 2);
  {
    var we = je => {
      var Ut = Ek(),
        nr = E(Ut),
        Gr = E(nr);
      mi(), A(nr);
      var Xr = $(nr, 2);
      Xr.__click = [kk, C];
      var gt = E(Xr);
      Fg(gt, {
        class: "size-4.5"
      }), A(Xr), A(Ut), lt(hr => {
        Te(Gr, `${hr??""} `), Vr(Xr, 1, Xo({
          "btn btn-circle btn-sm": !0,
          "btn-ghost": !b(ct),
          "btn-primary": b(ct)
        }))
      }, [() => KS()]), H(je, Ut)
    };
    et(se, je => {
      var Ut, nr;
      (nr = (Ut = Ot) == null ? void 0 : Ut.data) != null && nr.isModerator && je(we)
    })
  }
  A(Fr);
  var Ae = $(Fr, 2);
  Ae.__click = [zk, ft];
  var Ze = E(Ae);
  pc(Ze, {
    class: "size-4"
  }), A(Ae), A(er);
  var Se = $(er, 2),
    Ne = E(Se);
  xn(Ne, 23, () => b(ht), je => je.idx, (je, Ut, nr) => {
    const Gr = vt(() => {
        const [_r, Ti, Ar] = b(Ut).rgb;
        return {
          r: _r,
          g: Ti,
          b: Ar
        }
      }),
      Xr = vt(() => b(F) === b(Ut).idx && b($e)),
      gt = vt(() => b(Ut).idx === 0),
      hr = vt(() => Ot.hasColor(b(Ut).idx));
    var xr = Rk(),
      ai = E(xr);
    ai.__click = [Lk, cr, Ut];
    var ki = E(ai);
    {
      var _i = _r => {
        var Ti = Dk(),
          Ar = Et(Ti);
        Wf(Ar, {
          class: "center-absolute absolute size-4 opacity-30 sm:hidden sm:size-6"
        });
        var qr = $(Ar, 2),
          fi = E(qr);
        Wf(fi, {
          class: "text-base-content/80 size-4"
        }), A(qr), H(_r, Ti)
      };
      et(ki, _r => {
        b(hr) || _r(_i)
      })
    }
    A(ai), A(xr), lt(() => {
      Vr(xr, 1, Xo({
        tooltip: !0,
        "max-sm:h-6": b(at),
        "max-sm:before:translate-x-1/4": b(nr) % 8 === 0 && b(Ut).name.length > 7,
        "max-sm:before:-translate-x-1/4": (b(nr) - 7) % 8 === 0 && b(Ut).name.length > 7,
        "max-xl:before:translate-x-1/4": b(nr) % 16 === 0 && b(Ut).name.length > 7,
        "max-xl:before:-translate-x-1/4": (b(nr) - 15) % 16 === 0 && b(Ut).name.length > 7,
        "xl:before:translate-x-1/4": b(at) && b(nr) % 32 === 0 && b(Ut).name.length > 7,
        "xl:before:-translate-x-1/4": b(at) && (b(nr) - 31) % 32 === 0 && b(Ut).name.length > 7
      })), Br(xr, "data-tip", b(Ut).name), Vr(ai, 1, Xo({
        "btn relative aspect-square w-full rounded-xl": !0,
        "border-primary ring-primary ring-2": b(Xr),
        "border-base-300": !b(Xr) && b(gt),
        "border-base-content/20": !b(Xr) && !b(gt),
        "max-sm:h-6 max-sm:rounded-md": b(at)
      })), cc(ai, b(gt) ? `background-image: url(${UA}); background-size: cover; image-rendering: pixelated;` : `background: rgb(${b(Gr).r} ${b(Gr).g} ${b(Gr).b})`), Br(ai, "aria-label", b(Ut).name), Br(ai, "id", `color-${b(Ut).idx??""}`)
    }), bn("focus", ai, () => {
      b(hr) && (he(F, b(Ut).idx, !0), he(C, "pencil"))
    }), H(je, xr)
  }), A(Ne), A(Se);
  var ze = $(Se, 2),
    Ie = E(ze);
  Ie.__click = [Bk, at];
  var We = E(Ie);
  {
    var ve = je => {
        vk(je, {
          class: "size-5"
        })
      },
      Pt = je => {
        xk(je, {
          class: "size-5"
        })
      };
    et(We, je => {
      b(at) ? je(ve) : je(Pt, !1)
    })
  }
  A(Ie);
  var Xt = $(Ie, 2),
    Nt = E(Xt);
  {
    let je = vt(() => b(G) > 100 ? "animate-pulse" : ""),
      Ut = vt(() => b(G) === 0 || b(ie) || b(W) < 0 || !aa.captcha),
      nr = vt(() => b(ie) || !aa.captcha);
    jv(Nt, {
      get class() {
        return b(je)
      },
      get charges() {
        return b(W)
      },
      get disabled() {
        return b(Ut)
      },
      get loading() {
        return b(nr)
      },
      onclick: async () => {
        var gt;
        const Gr = (gt = aa.captcha) == null ? void 0 : gt.token;
        if (!Gr) return;
        ha.droppletAndPlop.play();
        const Xr = [...o.values()];
        he(ie, !0);
        try {
          await ci.paint(Xr, Gr), await vx(Xr), jt(), Ot.refresh(), Pd.shouldReload = !0, await ft()
        } catch (hr) {
          Zr.error(`${hr.message}`)
        } finally {
          he(ie, !1), aa.captcha = void 0
        }
      }
    })
  }
  A(Xt);
  var Ht = $(Xt, 2),
    or = E(Ht),
    ri = E(or),
    ti = E(ri);
  mi(), A(ri);
  var Wr = $(ri, 2);
  let Cr;
  Wr.__click = [Fk, C];
  var ii = E(Wr);
  bg(ii, {
    class: "size-5",
    get filled() {
      return b(Oe)
    }
  }), A(Wr), A(or), A(Ht), A(ze), A(Gt), Ss(Gt, je => he(rt, je), () => b(rt));
  var Hi = $(Gt, 2);
  ck(Hi, {
    get colorIdx() {
      return b(Ye)
    },
    get open() {
      return b(nt)
    },
    set open(je) {
      he(nt, je, !0)
    }
  }), lt((je, Ut, nr, Gr, Xr, gt) => {
    Te(Or, `${je??""} `), Te($t, `${Ut??""} `), Vr(yr, 1, Xo({
      "btn btn-circle btn-sm": !0,
      "btn-ghost": !b(Ve),
      "btn-primary": b(Ve)
    })), Br(ye, "data-tip", nr), V = Vr(j, 1, "btn btn-sm btn-circle btn-ghost text-base-content/80", null, V, Gr), Vr(Ne, 1, Xo({
      "md:grid-cols-16 min-[100rem]:grid-cols-32 grid grid-cols-8": !0,
      "xl:grid-cols-32 sm:grid-cols-16 gap-0.5 sm:gap-1": b(at),
      "gap-1": !b(at)
    })), Te(ti, `${Xr??""} `), Cr = Vr(Wr, 1, "btn btn-lg btn-square sm:btn-xl shadow-md", null, Cr, gt), Wr.disabled = b(G) === 0
  }, [() => Yw(), () => e5(), () => nv(), () => ({
    "text-primary": !T()
  }), () => Px(), () => ({
    "btn-primary": b(Oe)
  })]), Vd("innerHeight", je => he(dt, je, !0)), H(y, Lt), Er()
}
en(["click"]);

function vm(...y) {
  return Xg(Su(y))
}
var jk = De("<div><!></div>");

function qk(y, l) {
  kr(l, !0);
  let _ = It(l, "ref", 15, null),
    T = Yt(l, ["$$slots", "$$events", "$$legacy", "ref", "class", "children"]);
  var z = jk();
  Kt(z, C => ({
    class: C,
    ...T
  }), [() => vm("flex items-center", l.class)]);
  var F = E(z);
  Qi(F, () => l.children ?? kn), A(z), Ss(z, C => _(C), () => _()), H(y, z), Er()
}
var Vk = De('<div class="pointer-events-none absolute inset-0 flex items-center justify-center"><div class="animate-caret-blink bg-base-content/80 h-4 w-px duration-1000"></div></div>'),
  Zk = De(" <!>", 1);

function $k(y, l) {
  kr(l, !0);
  let _ = It(l, "ref", 15, null),
    T = Yt(l, ["$$slots", "$$events", "$$legacy", "ref", "cell", "class"]);
  var z = sr(),
    F = Et(z);
  {
    let C = vt(() => vm("border-input relative flex size-12 items-center justify-center border-y border-r text-xl transition-all first:rounded-l-md first:border-l last:rounded-r-md", l.cell.isActive && "ring-base-content/40 z-10 ring-2", l.class));
    cn(F, () => F6, (o, K) => {
      K(o, lo({
        get cell() {
          return l.cell
        },
        get class() {
          return b(C)
        }
      }, () => T, {
        get ref() {
          return _()
        },
        set ref(G) {
          _(G)
        },
        children: (G, ie) => {
          mi();
          var de = Zk(),
            fe = Et(de),
            W = $(fe);
          {
            var le = Ce => {
              var Me = Vk();
              H(Ce, Me)
            };
            et(W, Ce => {
              l.cell.hasFakeCaret && Ce(le)
            })
          }
          lt(() => Te(fe, `${l.cell.char??""} `)), H(G, de)
        },
        $$slots: {
          default: !0
        }
      }))
    })
  }
  H(y, z), Er()
}

function Uk(y, l) {
  kr(l, !0);
  let _ = It(l, "ref", 15, null),
    T = It(l, "value", 15, ""),
    z = Yt(l, ["$$slots", "$$events", "$$legacy", "ref", "class", "value"]);
  var F = sr(),
    C = Et(F);
  {
    let o = vt(() => vm("flex items-center gap-2 has-[:disabled]:opacity-50 [&_input]:disabled:cursor-not-allowed", l.class));
    cn(C, () => R6, (K, G) => {
      G(K, lo({
        get class() {
          return b(o)
        }
      }, () => z, {
        get ref() {
          return _()
        },
        set ref(ie) {
          _(ie)
        },
        get value() {
          return T()
        },
        set value(ie) {
          T(ie)
        }
      }))
    })
  }
  H(y, F), Er()
}
var yf = {
    exports: {}
  },
  Ng;

function Gk() {
  return Ng || (Ng = 1, (function(y) {
    (function(l) {
      y.exports ? y.exports = l() : window.intlTelInput = l()
    })(() => {
      var l = (() => {
        var _ = Object.defineProperty,
          T = Object.getOwnPropertyDescriptor,
          z = Object.getOwnPropertyNames,
          F = Object.prototype.hasOwnProperty,
          C = (Q, re) => {
            for (var xe in re) _(Q, xe, {
              get: re[xe],
              enumerable: !0
            })
          },
          o = (Q, re, xe, ce) => {
            if (re && typeof re == "object" || typeof re == "function")
              for (let Ee of z(re)) !F.call(Q, Ee) && Ee !== xe && _(Q, Ee, {
                get: () => re[Ee],
                enumerable: !(ce = T(re, Ee)) || ce.enumerable
              });
            return Q
          },
          K = Q => o(_({}, "__esModule", {
            value: !0
          }), Q),
          G = {};
        C(G, {
          Iti: () => at,
          default: () => xt
        });
        var ie = [
            ["af", "93"],
            ["ax", "358", 1],
            ["al", "355"],
            ["dz", "213"],
            ["as", "1", 5, ["684"]],
            ["ad", "376"],
            ["ao", "244"],
            ["ai", "1", 6, ["264"]],
            ["ag", "1", 7, ["268"]],
            ["ar", "54"],
            ["am", "374"],
            ["aw", "297"],
            ["ac", "247"],
            ["au", "61", 0, null, "0"],
            ["at", "43"],
            ["az", "994"],
            ["bs", "1", 8, ["242"]],
            ["bh", "973"],
            ["bd", "880"],
            ["bb", "1", 9, ["246"]],
            ["by", "375"],
            ["be", "32"],
            ["bz", "501"],
            ["bj", "229"],
            ["bm", "1", 10, ["441"]],
            ["bt", "975"],
            ["bo", "591"],
            ["ba", "387"],
            ["bw", "267"],
            ["br", "55"],
            ["io", "246"],
            ["vg", "1", 11, ["284"]],
            ["bn", "673"],
            ["bg", "359"],
            ["bf", "226"],
            ["bi", "257"],
            ["kh", "855"],
            ["cm", "237"],
            ["ca", "1", 1, ["204", "226", "236", "249", "250", "263", "289", "306", "343", "354", "365", "367", "368", "382", "387", "403", "416", "418", "428", "431", "437", "438", "450", "584", "468", "474", "506", "514", "519", "548", "579", "581", "584", "587", "604", "613", "639", "647", "672", "683", "705", "709", "742", "753", "778", "780", "782", "807", "819", "825", "867", "873", "879", "902", "905"]],
            ["cv", "238"],
            ["bq", "599", 1, ["3", "4", "7"]],
            ["ky", "1", 12, ["345"]],
            ["cf", "236"],
            ["td", "235"],
            ["cl", "56"],
            ["cn", "86"],
            ["cx", "61", 2, ["89164"], "0"],
            ["cc", "61", 1, ["89162"], "0"],
            ["co", "57"],
            ["km", "269"],
            ["cg", "242"],
            ["cd", "243"],
            ["ck", "682"],
            ["cr", "506"],
            ["ci", "225"],
            ["hr", "385"],
            ["cu", "53"],
            ["cw", "599", 0],
            ["cy", "357"],
            ["cz", "420"],
            ["dk", "45"],
            ["dj", "253"],
            ["dm", "1", 13, ["767"]],
            ["do", "1", 2, ["809", "829", "849"]],
            ["ec", "593"],
            ["eg", "20"],
            ["sv", "503"],
            ["gq", "240"],
            ["er", "291"],
            ["ee", "372"],
            ["sz", "268"],
            ["et", "251"],
            ["fk", "500"],
            ["fo", "298"],
            ["fj", "679"],
            ["fi", "358", 0],
            ["fr", "33"],
            ["gf", "594"],
            ["pf", "689"],
            ["ga", "241"],
            ["gm", "220"],
            ["ge", "995"],
            ["de", "49"],
            ["gh", "233"],
            ["gi", "350"],
            ["gr", "30"],
            ["gl", "299"],
            ["gd", "1", 14, ["473"]],
            ["gp", "590", 0],
            ["gu", "1", 15, ["671"]],
            ["gt", "502"],
            ["gg", "44", 1, ["1481", "7781", "7839", "7911"], "0"],
            ["gn", "224"],
            ["gw", "245"],
            ["gy", "592"],
            ["ht", "509"],
            ["hn", "504"],
            ["hk", "852"],
            ["hu", "36"],
            ["is", "354"],
            ["in", "91"],
            ["id", "62"],
            ["ir", "98"],
            ["iq", "964"],
            ["ie", "353"],
            ["im", "44", 2, ["1624", "74576", "7524", "7924", "7624"], "0"],
            ["il", "972"],
            ["it", "39", 0],
            ["jm", "1", 4, ["876", "658"]],
            ["jp", "81"],
            ["je", "44", 3, ["1534", "7509", "7700", "7797", "7829", "7937"], "0"],
            ["jo", "962"],
            ["kz", "7", 1, ["33", "7"], "8"],
            ["ke", "254"],
            ["ki", "686"],
            ["xk", "383"],
            ["kw", "965"],
            ["kg", "996"],
            ["la", "856"],
            ["lv", "371"],
            ["lb", "961"],
            ["ls", "266"],
            ["lr", "231"],
            ["ly", "218"],
            ["li", "423"],
            ["lt", "370"],
            ["lu", "352"],
            ["mo", "853"],
            ["mg", "261"],
            ["mw", "265"],
            ["my", "60"],
            ["mv", "960"],
            ["ml", "223"],
            ["mt", "356"],
            ["mh", "692"],
            ["mq", "596"],
            ["mr", "222"],
            ["mu", "230"],
            ["yt", "262", 1, ["269", "639"], "0"],
            ["mx", "52"],
            ["fm", "691"],
            ["md", "373"],
            ["mc", "377"],
            ["mn", "976"],
            ["me", "382"],
            ["ms", "1", 16, ["664"]],
            ["ma", "212", 0, null, "0"],
            ["mz", "258"],
            ["mm", "95"],
            ["na", "264"],
            ["nr", "674"],
            ["np", "977"],
            ["nl", "31"],
            ["nc", "687"],
            ["nz", "64"],
            ["ni", "505"],
            ["ne", "227"],
            ["ng", "234"],
            ["nu", "683"],
            ["nf", "672"],
            ["kp", "850"],
            ["mk", "389"],
            ["mp", "1", 17, ["670"]],
            ["no", "47", 0],
            ["om", "968"],
            ["pk", "92"],
            ["pw", "680"],
            ["ps", "970"],
            ["pa", "507"],
            ["pg", "675"],
            ["py", "595"],
            ["pe", "51"],
            ["ph", "63"],
            ["pl", "48"],
            ["pt", "351"],
            ["pr", "1", 3, ["787", "939"]],
            ["qa", "974"],
            ["re", "262", 0, null, "0"],
            ["ro", "40"],
            ["ru", "7", 0, null, "8"],
            ["rw", "250"],
            ["ws", "685"],
            ["sm", "378"],
            ["st", "239"],
            ["sa", "966"],
            ["sn", "221"],
            ["rs", "381"],
            ["sc", "248"],
            ["sl", "232"],
            ["sg", "65"],
            ["sx", "1", 21, ["721"]],
            ["sk", "421"],
            ["si", "386"],
            ["sb", "677"],
            ["so", "252"],
            ["za", "27"],
            ["kr", "82"],
            ["ss", "211"],
            ["es", "34"],
            ["lk", "94"],
            ["bl", "590", 1],
            ["sh", "290"],
            ["kn", "1", 18, ["869"]],
            ["lc", "1", 19, ["758"]],
            ["mf", "590", 2],
            ["pm", "508"],
            ["vc", "1", 20, ["784"]],
            ["sd", "249"],
            ["sr", "597"],
            ["sj", "47", 1, ["79"]],
            ["se", "46"],
            ["ch", "41"],
            ["sy", "963"],
            ["tw", "886"],
            ["tj", "992"],
            ["tz", "255"],
            ["th", "66"],
            ["tl", "670"],
            ["tg", "228"],
            ["tk", "690"],
            ["to", "676"],
            ["tt", "1", 22, ["868"]],
            ["tn", "216"],
            ["tr", "90"],
            ["tm", "993"],
            ["tc", "1", 23, ["649"]],
            ["tv", "688"],
            ["ug", "256"],
            ["ua", "380"],
            ["ae", "971"],
            ["gb", "44", 0, null, "0"],
            ["us", "1", 0],
            ["uy", "598"],
            ["vi", "1", 24, ["340"]],
            ["uz", "998"],
            ["vu", "678"],
            ["va", "39", 1, ["06698"]],
            ["ve", "58"],
            ["vn", "84"],
            ["wf", "681"],
            ["eh", "212", 1, ["5288", "5289"], "0"],
            ["ye", "967"],
            ["zm", "260"],
            ["zw", "263"]
          ],
          de = [];
        for (let Q = 0; Q < ie.length; Q++) {
          const re = ie[Q];
          de[Q] = {
            name: "",
            iso2: re[0],
            dialCode: re[1],
            priority: re[2] || 0,
            areaCodes: re[3] || null,
            nodeById: {},
            nationalPrefix: re[4] || null
          }
        }
        var fe = de,
          W = {
            ad: "Andorra",
            ae: "United Arab Emirates",
            af: "Afghanistan",
            ag: "Antigua & Barbuda",
            ai: "Anguilla",
            al: "Albania",
            am: "Armenia",
            ao: "Angola",
            ar: "Argentina",
            as: "American Samoa",
            at: "Austria",
            au: "Australia",
            aw: "Aruba",
            ax: "Åland Islands",
            az: "Azerbaijan",
            ba: "Bosnia & Herzegovina",
            bb: "Barbados",
            bd: "Bangladesh",
            be: "Belgium",
            bf: "Burkina Faso",
            bg: "Bulgaria",
            bh: "Bahrain",
            bi: "Burundi",
            bj: "Benin",
            bl: "St. Barthélemy",
            bm: "Bermuda",
            bn: "Brunei",
            bo: "Bolivia",
            bq: "Caribbean Netherlands",
            br: "Brazil",
            bs: "Bahamas",
            bt: "Bhutan",
            bw: "Botswana",
            by: "Belarus",
            bz: "Belize",
            ca: "Canada",
            cc: "Cocos (Keeling) Islands",
            cd: "Congo - Kinshasa",
            cf: "Central African Republic",
            cg: "Congo - Brazzaville",
            ch: "Switzerland",
            ci: "Côte d’Ivoire",
            ck: "Cook Islands",
            cl: "Chile",
            cm: "Cameroon",
            cn: "China",
            co: "Colombia",
            cr: "Costa Rica",
            cu: "Cuba",
            cv: "Cape Verde",
            cw: "Curaçao",
            cx: "Christmas Island",
            cy: "Cyprus",
            cz: "Czechia",
            de: "Germany",
            dj: "Djibouti",
            dk: "Denmark",
            dm: "Dominica",
            do: "Dominican Republic",
            dz: "Algeria",
            ec: "Ecuador",
            ee: "Estonia",
            eg: "Egypt",
            eh: "Western Sahara",
            er: "Eritrea",
            es: "Spain",
            et: "Ethiopia",
            fi: "Finland",
            fj: "Fiji",
            fk: "Falkland Islands",
            fm: "Micronesia",
            fo: "Faroe Islands",
            fr: "France",
            ga: "Gabon",
            gb: "United Kingdom",
            gd: "Grenada",
            ge: "Georgia",
            gf: "French Guiana",
            gg: "Guernsey",
            gh: "Ghana",
            gi: "Gibraltar",
            gl: "Greenland",
            gm: "Gambia",
            gn: "Guinea",
            gp: "Guadeloupe",
            gq: "Equatorial Guinea",
            gr: "Greece",
            gt: "Guatemala",
            gu: "Guam",
            gw: "Guinea-Bissau",
            gy: "Guyana",
            hk: "Hong Kong SAR China",
            hn: "Honduras",
            hr: "Croatia",
            ht: "Haiti",
            hu: "Hungary",
            id: "Indonesia",
            ie: "Ireland",
            il: "Israel",
            im: "Isle of Man",
            in: "India",
            io: "British Indian Ocean Territory",
            iq: "Iraq",
            ir: "Iran",
            is: "Iceland",
            it: "Italy",
            je: "Jersey",
            jm: "Jamaica",
            jo: "Jordan",
            jp: "Japan",
            ke: "Kenya",
            kg: "Kyrgyzstan",
            kh: "Cambodia",
            ki: "Kiribati",
            km: "Comoros",
            kn: "St. Kitts & Nevis",
            kp: "North Korea",
            kr: "South Korea",
            kw: "Kuwait",
            ky: "Cayman Islands",
            kz: "Kazakhstan",
            la: "Laos",
            lb: "Lebanon",
            lc: "St. Lucia",
            li: "Liechtenstein",
            lk: "Sri Lanka",
            lr: "Liberia",
            ls: "Lesotho",
            lt: "Lithuania",
            lu: "Luxembourg",
            lv: "Latvia",
            ly: "Libya",
            ma: "Morocco",
            mc: "Monaco",
            md: "Moldova",
            me: "Montenegro",
            mf: "St. Martin",
            mg: "Madagascar",
            mh: "Marshall Islands",
            mk: "North Macedonia",
            ml: "Mali",
            mm: "Myanmar (Burma)",
            mn: "Mongolia",
            mo: "Macao SAR China",
            mp: "Northern Mariana Islands",
            mq: "Martinique",
            mr: "Mauritania",
            ms: "Montserrat",
            mt: "Malta",
            mu: "Mauritius",
            mv: "Maldives",
            mw: "Malawi",
            mx: "Mexico",
            my: "Malaysia",
            mz: "Mozambique",
            na: "Namibia",
            nc: "New Caledonia",
            ne: "Niger",
            nf: "Norfolk Island",
            ng: "Nigeria",
            ni: "Nicaragua",
            nl: "Netherlands",
            no: "Norway",
            np: "Nepal",
            nr: "Nauru",
            nu: "Niue",
            nz: "New Zealand",
            om: "Oman",
            pa: "Panama",
            pe: "Peru",
            pf: "French Polynesia",
            pg: "Papua New Guinea",
            ph: "Philippines",
            pk: "Pakistan",
            pl: "Poland",
            pm: "St. Pierre & Miquelon",
            pr: "Puerto Rico",
            ps: "Palestinian Territories",
            pt: "Portugal",
            pw: "Palau",
            py: "Paraguay",
            qa: "Qatar",
            re: "Réunion",
            ro: "Romania",
            rs: "Serbia",
            ru: "Russia",
            rw: "Rwanda",
            sa: "Saudi Arabia",
            sb: "Solomon Islands",
            sc: "Seychelles",
            sd: "Sudan",
            se: "Sweden",
            sg: "Singapore",
            sh: "St. Helena",
            si: "Slovenia",
            sj: "Svalbard & Jan Mayen",
            sk: "Slovakia",
            sl: "Sierra Leone",
            sm: "San Marino",
            sn: "Senegal",
            so: "Somalia",
            sr: "Suriname",
            ss: "South Sudan",
            st: "São Tomé & Príncipe",
            sv: "El Salvador",
            sx: "Sint Maarten",
            sy: "Syria",
            sz: "Eswatini",
            tc: "Turks & Caicos Islands",
            td: "Chad",
            tg: "Togo",
            th: "Thailand",
            tj: "Tajikistan",
            tk: "Tokelau",
            tl: "Timor-Leste",
            tm: "Turkmenistan",
            tn: "Tunisia",
            to: "Tonga",
            tr: "Turkey",
            tt: "Trinidad & Tobago",
            tv: "Tuvalu",
            tw: "Taiwan",
            tz: "Tanzania",
            ua: "Ukraine",
            ug: "Uganda",
            us: "United States",
            uy: "Uruguay",
            uz: "Uzbekistan",
            va: "Vatican City",
            vc: "St. Vincent & Grenadines",
            ve: "Venezuela",
            vg: "British Virgin Islands",
            vi: "U.S. Virgin Islands",
            vn: "Vietnam",
            vu: "Vanuatu",
            wf: "Wallis & Futuna",
            ws: "Samoa",
            ye: "Yemen",
            yt: "Mayotte",
            za: "South Africa",
            zm: "Zambia",
            zw: "Zimbabwe"
          },
          le = W,
          Ce = {
            selectedCountryAriaLabel: "Selected country",
            noCountrySelected: "No country selected",
            countryListAriaLabel: "List of countries",
            searchPlaceholder: "Search",
            zeroSearchResults: "No results found",
            oneSearchResult: "1 result found",
            multipleSearchResults: "${count} results found",
            ac: "Ascension Island",
            xk: "Kosovo"
          },
          Me = Ce,
          Le = {
            ...le,
            ...Me
          },
          $e = Le;
        for (let Q = 0; Q < fe.length; Q++) fe[Q].name = $e[fe[Q].iso2];
        var Oe = 0,
          Ve = {
            allowDropdown: !0,
            autoPlaceholder: "polite",
            containerClass: "",
            countryOrder: null,
            countrySearch: !0,
            customPlaceholder: null,
            dropdownContainer: null,
            excludeCountries: [],
            fixDropdownWidth: !0,
            formatAsYouType: !0,
            formatOnDisplay: !0,
            geoIpLookup: null,
            hiddenInput: null,
            i18n: {},
            initialCountry: "",
            loadUtils: null,
            nationalMode: !0,
            onlyCountries: [],
            placeholderNumberType: "MOBILE",
            showFlags: !0,
            separateDialCode: !1,
            strictMode: !1,
            useFullscreenPopup: typeof navigator < "u" && typeof window < "u" ? /Android.+Mobile|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 500 : !1,
            validationNumberTypes: ["MOBILE"]
          },
          ct = ["800", "822", "833", "844", "855", "866", "877", "880", "881", "882", "883", "884", "885", "886", "887", "888", "889"],
          nt = Q => Q.replace(/\D/g, ""),
          Ye = (Q = "") => Q.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase(),
          dt = Q => {
            const re = nt(Q);
            if (re.charAt(0) === "1") {
              const xe = re.substr(1, 3);
              return ct.includes(xe)
            }
            return !1
          },
          rt = (Q, re, xe, ce) => {
            if (xe === 0 && !ce) return 0;
            let Ee = 0;
            for (let Be = 0; Be < re.length; Be++) {
              if (/[+0-9]/.test(re[Be]) && Ee++, Ee === Q && !ce) return Be + 1;
              if (ce && Ee === Q + 1) return Be
            }
            return re.length
          },
          qe = (Q, re, xe) => {
            const ce = document.createElement(Q);
            return re && Object.entries(re).forEach(([Ee, Be]) => ce.setAttribute(Ee, Be)), xe && xe.appendChild(ce), ce
          },
          pt = (Q, ...re) => {
            const {
              instances: xe
            } = Re;
            Object.values(xe).forEach(ce => ce[Q](...re))
          },
          at = class {
            constructor(Q, re = {}) {
              this.id = Oe++, this.telInput = Q, this.highlightedItem = null, this.options = Object.assign({}, Ve, re), this.hadInitialPlaceholder = !!Q.getAttribute("placeholder")
            }
            _init() {
              this.options.useFullscreenPopup && (this.options.fixDropdownWidth = !1), this.options.onlyCountries.length === 1 && (this.options.initialCountry = this.options.onlyCountries[0]), this.options.separateDialCode && (this.options.nationalMode = !1), this.options.allowDropdown && !this.options.showFlags && !this.options.separateDialCode && (this.options.nationalMode = !1), this.options.useFullscreenPopup && !this.options.dropdownContainer && (this.options.dropdownContainer = document.body), this.isAndroid = typeof navigator < "u" ? /Android/i.test(navigator.userAgent) : !1, this.isRTL = !!this.telInput.closest("[dir=rtl]");
              const Q = this.options.allowDropdown || this.options.separateDialCode;
              this.showSelectedCountryOnLeft = this.isRTL ? !Q : Q, this.options.separateDialCode && (this.isRTL ? this.originalPaddingRight = this.telInput.style.paddingRight : this.originalPaddingLeft = this.telInput.style.paddingLeft), this.options.i18n = {
                ...$e,
                ...this.options.i18n
              };
              const re = new Promise((ce, Ee) => {
                  this.resolveAutoCountryPromise = ce, this.rejectAutoCountryPromise = Ee
                }),
                xe = new Promise((ce, Ee) => {
                  this.resolveUtilsScriptPromise = ce, this.rejectUtilsScriptPromise = Ee
                });
              this.promise = Promise.all([re, xe]), this.selectedCountryData = {}, this._processCountryData(), this._generateMarkup(), this._setInitialState(), this._initListeners(), this._initRequests()
            }
            _processCountryData() {
              this._processAllCountries(), this._processDialCodes(), this._translateCountryNames(), this._sortCountries()
            }
            _sortCountries() {
              this.options.countryOrder && (this.options.countryOrder = this.options.countryOrder.map(Q => Q.toLowerCase())), this.countries.sort((Q, re) => {
                const {
                  countryOrder: xe
                } = this.options;
                if (xe) {
                  const ce = xe.indexOf(Q.iso2),
                    Ee = xe.indexOf(re.iso2),
                    Be = ce > -1,
                    Ke = Ee > -1;
                  if (Be || Ke) return Be && Ke ? ce - Ee : Be ? -1 : 1
                }
                return Q.name.localeCompare(re.name)
              })
            }
            _addToDialCodeMap(Q, re, xe) {
              re.length > this.dialCodeMaxLen && (this.dialCodeMaxLen = re.length), this.dialCodeToIso2Map.hasOwnProperty(re) || (this.dialCodeToIso2Map[re] = []);
              for (let Ee = 0; Ee < this.dialCodeToIso2Map[re].length; Ee++)
                if (this.dialCodeToIso2Map[re][Ee] === Q) return;
              const ce = xe !== void 0 ? xe : this.dialCodeToIso2Map[re].length;
              this.dialCodeToIso2Map[re][ce] = Q
            }
            _processAllCountries() {
              const {
                onlyCountries: Q,
                excludeCountries: re
              } = this.options;
              if (Q.length) {
                const xe = Q.map(ce => ce.toLowerCase());
                this.countries = fe.filter(ce => xe.includes(ce.iso2))
              } else if (re.length) {
                const xe = re.map(ce => ce.toLowerCase());
                this.countries = fe.filter(ce => !xe.includes(ce.iso2))
              } else this.countries = fe
            }
            _translateCountryNames() {
              for (let Q = 0; Q < this.countries.length; Q++) {
                const re = this.countries[Q].iso2.toLowerCase();
                this.options.i18n.hasOwnProperty(re) && (this.countries[Q].name = this.options.i18n[re])
              }
            }
            _processDialCodes() {
              this.dialCodes = {}, this.dialCodeMaxLen = 0, this.dialCodeToIso2Map = {};
              for (let Q = 0; Q < this.countries.length; Q++) {
                const re = this.countries[Q];
                this.dialCodes[re.dialCode] || (this.dialCodes[re.dialCode] = !0), this._addToDialCodeMap(re.iso2, re.dialCode, re.priority)
              }
              for (let Q = 0; Q < this.countries.length; Q++) {
                const re = this.countries[Q];
                if (re.areaCodes) {
                  const xe = this.dialCodeToIso2Map[re.dialCode][0];
                  for (let ce = 0; ce < re.areaCodes.length; ce++) {
                    const Ee = re.areaCodes[ce];
                    for (let Be = 1; Be < Ee.length; Be++) {
                      const Ke = Ee.substr(0, Be),
                        tt = re.dialCode + Ke;
                      this._addToDialCodeMap(xe, tt), this._addToDialCodeMap(re.iso2, tt)
                    }
                    this._addToDialCodeMap(re.iso2, re.dialCode + Ee)
                  }
                }
              }
            }
            _generateMarkup() {
              var cr, Mt, yt;
              this.telInput.classList.add("iti__tel-input"), !this.telInput.hasAttribute("autocomplete") && !(this.telInput.form && this.telInput.form.hasAttribute("autocomplete")) && this.telInput.setAttribute("autocomplete", "off");
              const {
                allowDropdown: Q,
                separateDialCode: re,
                showFlags: xe,
                containerClass: ce,
                hiddenInput: Ee,
                dropdownContainer: Be,
                fixDropdownWidth: Ke,
                useFullscreenPopup: tt,
                countrySearch: ot,
                i18n: ft
              } = this.options;
              let Bt = "iti";
              Q && (Bt += " iti--allow-dropdown"), xe && (Bt += " iti--show-flags"), ce && (Bt += ` ${ce}`), tt || (Bt += " iti--inline-dropdown");
              const At = qe("div", {
                class: Bt
              });
              if ((cr = this.telInput.parentNode) == null || cr.insertBefore(At, this.telInput), Q || xe || re) {
                this.countryContainer = qe("div", {
                  class: "iti__country-container"
                }, At), this.showSelectedCountryOnLeft ? this.countryContainer.style.left = "0px" : this.countryContainer.style.right = "0px", Q ? (this.selectedCountry = qe("button", {
                  type: "button",
                  class: "iti__selected-country",
                  "aria-expanded": "false",
                  "aria-label": this.options.i18n.selectedCountryAriaLabel,
                  "aria-haspopup": "true",
                  "aria-controls": `iti-${this.id}__dropdown-content`,
                  role: "combobox"
                }, this.countryContainer), this.telInput.disabled && this.selectedCountry.setAttribute("disabled", "true")) : this.selectedCountry = qe("div", {
                  class: "iti__selected-country"
                }, this.countryContainer);
                const St = qe("div", {
                  class: "iti__selected-country-primary"
                }, this.selectedCountry);
                if (this.selectedCountryInner = qe("div", {
                    class: "iti__flag"
                  }, St), this.selectedCountryA11yText = qe("span", {
                    class: "iti__a11y-text"
                  }, this.selectedCountryInner), Q && (this.dropdownArrow = qe("div", {
                    class: "iti__arrow",
                    "aria-hidden": "true"
                  }, St)), re && (this.selectedDialCode = qe("div", {
                    class: "iti__selected-dial-code"
                  }, this.selectedCountry)), Q) {
                  const jt = Ke ? "" : "iti--flexible-dropdown-width";
                  if (this.dropdownContent = qe("div", {
                      id: `iti-${this.id}__dropdown-content`,
                      class: `iti__dropdown-content iti__hide ${jt}`
                    }), ot && (this.searchInput = qe("input", {
                      type: "text",
                      class: "iti__search-input",
                      placeholder: ft.searchPlaceholder,
                      role: "combobox",
                      "aria-expanded": "true",
                      "aria-label": ft.searchPlaceholder,
                      "aria-controls": `iti-${this.id}__country-listbox`,
                      "aria-autocomplete": "list",
                      autocomplete: "off"
                    }, this.dropdownContent), this.searchResultsA11yText = qe("span", {
                      class: "iti__a11y-text"
                    }, this.dropdownContent)), this.countryList = qe("ul", {
                      class: "iti__country-list",
                      id: `iti-${this.id}__country-listbox`,
                      role: "listbox",
                      "aria-label": ft.countryListAriaLabel
                    }, this.dropdownContent), this._appendListItems(), ot && this._updateSearchResultsText(), Be) {
                    let Lt = "iti iti--container";
                    tt ? Lt += " iti--fullscreen-popup" : Lt += " iti--inline-dropdown", this.dropdown = qe("div", {
                      class: Lt
                    }), this.dropdown.appendChild(this.dropdownContent)
                  } else this.countryContainer.appendChild(this.dropdownContent)
                }
              }
              if (At.appendChild(this.telInput), this._updateInputPadding(), Ee) {
                const St = this.telInput.getAttribute("name") || "",
                  jt = Ee(St);
                if (jt.phone) {
                  const Lt = (Mt = this.telInput.form) == null ? void 0 : Mt.querySelector(`input[name="${jt.phone}"]`);
                  Lt ? this.hiddenInput = Lt : (this.hiddenInput = qe("input", {
                    type: "hidden",
                    name: jt.phone
                  }), At.appendChild(this.hiddenInput))
                }
                if (jt.country) {
                  const Lt = (yt = this.telInput.form) == null ? void 0 : yt.querySelector(`input[name="${jt.country}"]`);
                  Lt ? this.hiddenInputCountry = Lt : (this.hiddenInputCountry = qe("input", {
                    type: "hidden",
                    name: jt.country
                  }), At.appendChild(this.hiddenInputCountry))
                }
              }
            }
            _appendListItems() {
              for (let Q = 0; Q < this.countries.length; Q++) {
                const re = this.countries[Q],
                  xe = Q === 0 ? "iti__highlight" : "",
                  ce = qe("li", {
                    id: `iti-${this.id}__item-${re.iso2}`,
                    class: `iti__country ${xe}`,
                    tabindex: "-1",
                    role: "option",
                    "data-dial-code": re.dialCode,
                    "data-country-code": re.iso2,
                    "aria-selected": "false"
                  }, this.countryList);
                re.nodeById[this.id] = ce;
                let Ee = "";
                this.options.showFlags && (Ee += `<div class='iti__flag iti__${re.iso2}'></div>`), Ee += `<span class='iti__country-name'>${re.name}</span>`, Ee += `<span class='iti__dial-code'>+${re.dialCode}</span>`, ce.insertAdjacentHTML("beforeend", Ee)
              }
            }
            _setInitialState(Q = !1) {
              const re = this.telInput.getAttribute("value"),
                xe = this.telInput.value,
                Ee = re && re.charAt(0) === "+" && (!xe || xe.charAt(0) !== "+") ? re : xe,
                Be = this._getDialCode(Ee),
                Ke = dt(Ee),
                {
                  initialCountry: tt,
                  geoIpLookup: ot
                } = this.options,
                ft = tt === "auto" && ot;
              if (Be && !Ke) this._updateCountryFromNumber(Ee);
              else if (!ft || Q) {
                const Bt = tt ? tt.toLowerCase() : "";
                Bt && this._getCountryData(Bt, !0) ? this._setCountry(Bt) : Be && Ke ? this._setCountry("us") : this._setCountry()
              }
              Ee && this._updateValFromNumber(Ee)
            }
            _initListeners() {
              this._initTelInputListeners(), this.options.allowDropdown && this._initDropdownListeners(), (this.hiddenInput || this.hiddenInputCountry) && this.telInput.form && this._initHiddenInputListener()
            }
            _initHiddenInputListener() {
              var Q;
              this._handleHiddenInputSubmit = () => {
                this.hiddenInput && (this.hiddenInput.value = this.getNumber()), this.hiddenInputCountry && (this.hiddenInputCountry.value = this.getSelectedCountryData().iso2 || "")
              }, (Q = this.telInput.form) == null || Q.addEventListener("submit", this._handleHiddenInputSubmit)
            }
            _initDropdownListeners() {
              this._handleLabelClick = re => {
                this.dropdownContent.classList.contains("iti__hide") ? this.telInput.focus() : re.preventDefault()
              };
              const Q = this.telInput.closest("label");
              Q && Q.addEventListener("click", this._handleLabelClick), this._handleClickSelectedCountry = () => {
                this.dropdownContent.classList.contains("iti__hide") && !this.telInput.disabled && !this.telInput.readOnly && this._openDropdown()
              }, this.selectedCountry.addEventListener("click", this._handleClickSelectedCountry), this._handleCountryContainerKeydown = re => {
                this.dropdownContent.classList.contains("iti__hide") && ["ArrowUp", "ArrowDown", " ", "Enter"].includes(re.key) && (re.preventDefault(), re.stopPropagation(), this._openDropdown()), re.key === "Tab" && this._closeDropdown()
              }, this.countryContainer.addEventListener("keydown", this._handleCountryContainerKeydown)
            }
            _initRequests() {
              let {
                loadUtils: Q,
                initialCountry: re,
                geoIpLookup: xe
              } = this.options;
              Q && !Re.utils ? (this._handlePageLoad = () => {
                var Ee;
                window.removeEventListener("load", this._handlePageLoad), (Ee = Re.attachUtils(Q)) == null || Ee.catch(() => {})
              }, Re.documentReady() ? this._handlePageLoad() : window.addEventListener("load", this._handlePageLoad)) : this.resolveUtilsScriptPromise(), re === "auto" && xe && !this.selectedCountryData.iso2 ? this._loadAutoCountry() : this.resolveAutoCountryPromise()
            }
            _loadAutoCountry() {
              Re.autoCountry ? this.handleAutoCountry() : Re.startedLoadingAutoCountry || (Re.startedLoadingAutoCountry = !0, typeof this.options.geoIpLookup == "function" && this.options.geoIpLookup((Q = "") => {
                const re = Q.toLowerCase();
                re && this._getCountryData(re, !0) ? (Re.autoCountry = re, setTimeout(() => pt("handleAutoCountry"))) : (this._setInitialState(!0), pt("rejectAutoCountryPromise"))
              }, () => {
                this._setInitialState(!0), pt("rejectAutoCountryPromise")
              }))
            }
            _openDropdownWithPlus() {
              this._openDropdown(), this.searchInput.value = "+", this._filterCountries("", !0)
            }
            _initTelInputListeners() {
              const {
                strictMode: Q,
                formatAsYouType: re,
                separateDialCode: xe,
                formatOnDisplay: ce,
                allowDropdown: Ee,
                countrySearch: Be
              } = this.options;
              let Ke = !1;
              new RegExp("\\p{L}", "u").test(this.telInput.value) && (Ke = !0), this._handleInputEvent = tt => {
                if (this.isAndroid && (tt == null ? void 0 : tt.data) === "+" && xe && Ee && Be) {
                  const At = this.telInput.selectionStart || 0,
                    cr = this.telInput.value.substring(0, At - 1),
                    Mt = this.telInput.value.substring(At);
                  this.telInput.value = cr + Mt, this._openDropdownWithPlus();
                  return
                }
                this._updateCountryFromNumber(this.telInput.value) && this._triggerCountryChange();
                const ot = (tt == null ? void 0 : tt.data) && /[^+0-9]/.test(tt.data),
                  ft = (tt == null ? void 0 : tt.inputType) === "insertFromPaste" && this.telInput.value;
                ot || ft && !Q ? Ke = !0 : /[^+0-9]/.test(this.telInput.value) || (Ke = !1);
                const Bt = (tt == null ? void 0 : tt.detail) && tt.detail.isSetNumber && !ce;
                if (re && !Ke && !Bt) {
                  const At = this.telInput.selectionStart || 0,
                    Mt = this.telInput.value.substring(0, At).replace(/[^+0-9]/g, "").length,
                    yt = (tt == null ? void 0 : tt.inputType) === "deleteContentForward",
                    St = this._formatNumberAsYouType(),
                    jt = rt(Mt, St, At, yt);
                  this.telInput.value = St, this.telInput.setSelectionRange(jt, jt)
                }
              }, this.telInput.addEventListener("input", this._handleInputEvent), (Q || xe) && (this._handleKeydownEvent = tt => {
                if (tt.key && tt.key.length === 1 && !tt.altKey && !tt.ctrlKey && !tt.metaKey) {
                  if (xe && Ee && Be && tt.key === "+") {
                    tt.preventDefault(), this._openDropdownWithPlus();
                    return
                  }
                  if (Q) {
                    const ot = this.telInput.value,
                      ft = ot.charAt(0) === "+",
                      Bt = !ft && this.telInput.selectionStart === 0 && tt.key === "+",
                      At = /^[0-9]$/.test(tt.key),
                      cr = xe ? At : Bt || At,
                      Mt = ot.slice(0, this.telInput.selectionStart) + tt.key + ot.slice(this.telInput.selectionEnd),
                      yt = this._getFullNumber(Mt),
                      St = Re.utils.getCoreNumber(yt, this.selectedCountryData.iso2),
                      jt = this.maxCoreNumberLength && St.length > this.maxCoreNumberLength;
                    let Lt = !1;
                    if (ft) {
                      const Gt = this.selectedCountryData.iso2;
                      Lt = this._getCountryFromNumber(yt) !== Gt
                    }(!cr || jt && !Lt && !Bt) && tt.preventDefault()
                  }
                }
              }, this.telInput.addEventListener("keydown", this._handleKeydownEvent))
            }
            _cap(Q) {
              const re = parseInt(this.telInput.getAttribute("maxlength") || "", 10);
              return re && Q.length > re ? Q.substr(0, re) : Q
            }
            _trigger(Q, re = {}) {
              const xe = new CustomEvent(Q, {
                bubbles: !0,
                cancelable: !0,
                detail: re
              });
              this.telInput.dispatchEvent(xe)
            }
            _openDropdown() {
              const {
                fixDropdownWidth: Q,
                countrySearch: re
              } = this.options;
              if (Q && (this.dropdownContent.style.width = `${this.telInput.offsetWidth}px`), this.dropdownContent.classList.remove("iti__hide"), this.selectedCountry.setAttribute("aria-expanded", "true"), this._setDropdownPosition(), re) {
                const xe = this.countryList.firstElementChild;
                xe && (this._highlightListItem(xe, !1), this.countryList.scrollTop = 0), this.searchInput.focus()
              }
              this._bindDropdownListeners(), this.dropdownArrow.classList.add("iti__arrow--up"), this._trigger("open:countrydropdown")
            }
            _setDropdownPosition() {
              if (this.options.dropdownContainer && this.options.dropdownContainer.appendChild(this.dropdown), !this.options.useFullscreenPopup) {
                const Q = this.telInput.getBoundingClientRect(),
                  re = this.telInput.offsetHeight;
                this.options.dropdownContainer && (this.dropdown.style.top = `${Q.top+re}px`, this.dropdown.style.left = `${Q.left}px`, this._handleWindowScroll = () => this._closeDropdown(), window.addEventListener("scroll", this._handleWindowScroll))
              }
            }
            _bindDropdownListeners() {
              this._handleMouseoverCountryList = ce => {
                var Be;
                const Ee = (Be = ce.target) == null ? void 0 : Be.closest(".iti__country");
                Ee && this._highlightListItem(Ee, !1)
              }, this.countryList.addEventListener("mouseover", this._handleMouseoverCountryList), this._handleClickCountryList = ce => {
                var Be;
                const Ee = (Be = ce.target) == null ? void 0 : Be.closest(".iti__country");
                Ee && this._selectListItem(Ee)
              }, this.countryList.addEventListener("click", this._handleClickCountryList);
              let Q = !0;
              this._handleClickOffToClose = () => {
                Q || this._closeDropdown(), Q = !1
              }, document.documentElement.addEventListener("click", this._handleClickOffToClose);
              let re = "",
                xe = null;
              if (this._handleKeydownOnDropdown = ce => {
                  ["ArrowUp", "ArrowDown", "Enter", "Escape"].includes(ce.key) && (ce.preventDefault(), ce.stopPropagation(), ce.key === "ArrowUp" || ce.key === "ArrowDown" ? this._handleUpDownKey(ce.key) : ce.key === "Enter" ? this._handleEnterKey() : ce.key === "Escape" && this._closeDropdown()), !this.options.countrySearch && /^[a-zA-ZÀ-ÿа-яА-Я ]$/.test(ce.key) && (ce.stopPropagation(), xe && clearTimeout(xe), re += ce.key.toLowerCase(), this._searchForCountry(re), xe = setTimeout(() => {
                    re = ""
                  }, 1e3))
                }, document.addEventListener("keydown", this._handleKeydownOnDropdown), this.options.countrySearch) {
                const ce = () => {
                  const Be = this.searchInput.value.trim();
                  Be ? this._filterCountries(Be) : this._filterCountries("", !0)
                };
                let Ee = null;
                this._handleSearchChange = () => {
                  Ee && clearTimeout(Ee), Ee = setTimeout(() => {
                    ce(), Ee = null
                  }, 100)
                }, this.searchInput.addEventListener("input", this._handleSearchChange), this.searchInput.addEventListener("click", Be => Be.stopPropagation())
              }
            }
            _searchForCountry(Q) {
              for (let re = 0; re < this.countries.length; re++) {
                const xe = this.countries[re];
                if (xe.name.substr(0, Q.length).toLowerCase() === Q) {
                  const Ee = xe.nodeById[this.id];
                  this._highlightListItem(Ee, !1), this._scrollTo(Ee);
                  break
                }
              }
            }
            _filterCountries(Q, re = !1) {
              let xe = !0;
              this.countryList.innerHTML = "";
              const ce = Ye(Q);
              for (let Ee = 0; Ee < this.countries.length; Ee++) {
                const Be = this.countries[Ee],
                  Ke = Ye(Be.name),
                  tt = Be.name.split(/[^a-zA-ZÀ-ÿа-яА-Я]/).map(ft => ft[0]).join("").toLowerCase(),
                  ot = `+${Be.dialCode}`;
                if (re || Ke.includes(ce) || ot.includes(ce) || Be.iso2.includes(ce) || tt.includes(ce)) {
                  const ft = Be.nodeById[this.id];
                  ft && this.countryList.appendChild(ft), xe && (this._highlightListItem(ft, !1), xe = !1)
                }
              }
              xe && this._highlightListItem(null, !1), this.countryList.scrollTop = 0, this._updateSearchResultsText()
            }
            _updateSearchResultsText() {
              const {
                i18n: Q
              } = this.options, re = this.countryList.childElementCount;
              let xe;
              re === 0 ? xe = Q.zeroSearchResults : re === 1 ? xe = Q.oneSearchResult : xe = Q.multipleSearchResults.replace("${count}", re.toString()), this.searchResultsA11yText.textContent = xe
            }
            _handleUpDownKey(Q) {
              var xe, ce;
              let re = Q === "ArrowUp" ? (xe = this.highlightedItem) == null ? void 0 : xe.previousElementSibling : (ce = this.highlightedItem) == null ? void 0 : ce.nextElementSibling;
              !re && this.countryList.childElementCount > 1 && (re = Q === "ArrowUp" ? this.countryList.lastElementChild : this.countryList.firstElementChild), re && (this._scrollTo(re), this._highlightListItem(re, !1))
            }
            _handleEnterKey() {
              this.highlightedItem && this._selectListItem(this.highlightedItem)
            }
            _updateValFromNumber(Q) {
              let re = Q;
              if (this.options.formatOnDisplay && Re.utils && this.selectedCountryData) {
                const xe = this.options.nationalMode || re.charAt(0) !== "+" && !this.options.separateDialCode,
                  {
                    NATIONAL: ce,
                    INTERNATIONAL: Ee
                  } = Re.utils.numberFormat,
                  Be = xe ? ce : Ee;
                re = Re.utils.formatNumber(re, this.selectedCountryData.iso2, Be)
              }
              re = this._beforeSetNumber(re), this.telInput.value = re
            }
            _updateCountryFromNumber(Q) {
              const re = this._getCountryFromNumber(Q);
              return re !== null ? this._setCountry(re) : !1
            }
            _ensureHasDialCode(Q) {
              const {
                dialCode: re,
                nationalPrefix: xe
              } = this.selectedCountryData;
              if (Q.charAt(0) === "+" || !re) return Q;
              const Be = xe && Q.charAt(0) === xe && !this.options.separateDialCode ? Q.substring(1) : Q;
              return `+${re}${Be}`
            }
            _getCountryFromNumber(Q) {
              const re = Q.indexOf("+");
              let xe = re ? Q.substring(re) : Q;
              const ce = this.selectedCountryData.iso2,
                Ee = this.selectedCountryData.dialCode;
              xe = this._ensureHasDialCode(xe);
              const Be = this._getDialCode(xe, !0),
                Ke = nt(xe);
              if (Be) {
                const tt = nt(Be),
                  ot = this.dialCodeToIso2Map[tt];
                if (!ce && this.defaultCountry && ot.includes(this.defaultCountry)) return this.defaultCountry;
                const ft = ce && ot.includes(ce) && (Ke.length === tt.length || !this.selectedCountryData.areaCodes);
                if (!(Ee === "1" && dt(Ke)) && !ft) {
                  for (let At = 0; At < ot.length; At++)
                    if (ot[At]) return ot[At]
                }
              } else {
                if (xe.charAt(0) === "+" && Ke.length) return "";
                if ((!xe || xe === "+") && !this.selectedCountryData.iso2) return this.defaultCountry
              }
              return null
            }
            _highlightListItem(Q, re) {
              const xe = this.highlightedItem;
              if (xe && (xe.classList.remove("iti__highlight"), xe.setAttribute("aria-selected", "false")), this.highlightedItem = Q, this.highlightedItem) {
                this.highlightedItem.classList.add("iti__highlight"), this.highlightedItem.setAttribute("aria-selected", "true");
                const ce = this.highlightedItem.getAttribute("id") || "";
                this.selectedCountry.setAttribute("aria-activedescendant", ce), this.options.countrySearch && this.searchInput.setAttribute("aria-activedescendant", ce)
              }
              re && this.highlightedItem.focus()
            }
            _getCountryData(Q, re) {
              for (let xe = 0; xe < this.countries.length; xe++)
                if (this.countries[xe].iso2 === Q) return this.countries[xe];
              if (re) return null;
              throw new Error(`No country data for '${Q}'`)
            }
            _setCountry(Q) {
              const {
                separateDialCode: re,
                showFlags: xe,
                i18n: ce
              } = this.options, Ee = this.selectedCountryData.iso2 ? this.selectedCountryData : {};
              if (this.selectedCountryData = Q ? this._getCountryData(Q, !1) || {} : {}, this.selectedCountryData.iso2 && (this.defaultCountry = this.selectedCountryData.iso2), this.selectedCountryInner) {
                let Be = "",
                  Ke = "";
                Q && xe ? (Be = `iti__flag iti__${Q}`, Ke = `${this.selectedCountryData.name} +${this.selectedCountryData.dialCode}`) : (Be = "iti__flag iti__globe", Ke = ce.noCountrySelected), this.selectedCountryInner.className = Be, this.selectedCountryA11yText.textContent = Ke
              }
              if (this._setSelectedCountryTitleAttribute(Q, re), re) {
                const Be = this.selectedCountryData.dialCode ? `+${this.selectedCountryData.dialCode}` : "";
                this.selectedDialCode.innerHTML = Be, this._updateInputPadding()
              }
              return this._updatePlaceholder(), this._updateMaxLength(), Ee.iso2 !== Q
            }
            _updateInputPadding() {
              if (this.selectedCountry) {
                const re = (this.selectedCountry.offsetWidth || this._getHiddenSelectedCountryWidth()) + 6;
                this.showSelectedCountryOnLeft ? this.telInput.style.paddingLeft = `${re}px` : this.telInput.style.paddingRight = `${re}px`
              }
            }
            _updateMaxLength() {
              const {
                strictMode: Q,
                placeholderNumberType: re,
                validationNumberTypes: xe
              } = this.options, {
                iso2: ce
              } = this.selectedCountryData;
              if (Q && Re.utils)
                if (ce) {
                  const Ee = Re.utils.numberType[re];
                  let Be = Re.utils.getExampleNumber(ce, !1, Ee, !0),
                    Ke = Be;
                  for (; Re.utils.isPossibleNumber(Be, ce, xe);) Ke = Be, Be += "0";
                  const tt = Re.utils.getCoreNumber(Ke, ce);
                  this.maxCoreNumberLength = tt.length, ce === "by" && (this.maxCoreNumberLength = tt.length + 1)
                } else this.maxCoreNumberLength = null
            }
            _setSelectedCountryTitleAttribute(Q = null, re) {
              if (!this.selectedCountry) return;
              let xe;
              Q && !re ? xe = `${this.selectedCountryData.name}: +${this.selectedCountryData.dialCode}` : Q ? xe = this.selectedCountryData.name : xe = "Unknown", this.selectedCountry.setAttribute("title", xe)
            }
            _getHiddenSelectedCountryWidth() {
              if (this.telInput.parentNode) {
                const Q = this.telInput.parentNode.cloneNode(!1);
                Q.style.visibility = "hidden", document.body.appendChild(Q);
                const re = this.countryContainer.cloneNode();
                Q.appendChild(re);
                const xe = this.selectedCountry.cloneNode(!0);
                re.appendChild(xe);
                const ce = xe.offsetWidth;
                return document.body.removeChild(Q), ce
              }
              return 0
            }
            _updatePlaceholder() {
              const {
                autoPlaceholder: Q,
                placeholderNumberType: re,
                nationalMode: xe,
                customPlaceholder: ce
              } = this.options, Ee = Q === "aggressive" || !this.hadInitialPlaceholder && Q === "polite";
              if (Re.utils && Ee) {
                const Be = Re.utils.numberType[re];
                let Ke = this.selectedCountryData.iso2 ? Re.utils.getExampleNumber(this.selectedCountryData.iso2, xe, Be) : "";
                Ke = this._beforeSetNumber(Ke), typeof ce == "function" && (Ke = ce(Ke, this.selectedCountryData)), this.telInput.setAttribute("placeholder", Ke)
              }
            }
            _selectListItem(Q) {
              const re = this._setCountry(Q.getAttribute("data-country-code"));
              this._closeDropdown(), this._updateDialCode(Q.getAttribute("data-dial-code")), this.telInput.focus(), re && this._triggerCountryChange()
            }
            _closeDropdown() {
              this.dropdownContent.classList.add("iti__hide"), this.selectedCountry.setAttribute("aria-expanded", "false"), this.selectedCountry.removeAttribute("aria-activedescendant"), this.highlightedItem && this.highlightedItem.setAttribute("aria-selected", "false"), this.options.countrySearch && this.searchInput.removeAttribute("aria-activedescendant"), this.dropdownArrow.classList.remove("iti__arrow--up"), document.removeEventListener("keydown", this._handleKeydownOnDropdown), this.options.countrySearch && this.searchInput.removeEventListener("input", this._handleSearchChange), document.documentElement.removeEventListener("click", this._handleClickOffToClose), this.countryList.removeEventListener("mouseover", this._handleMouseoverCountryList), this.countryList.removeEventListener("click", this._handleClickCountryList), this.options.dropdownContainer && (this.options.useFullscreenPopup || window.removeEventListener("scroll", this._handleWindowScroll), this.dropdown.parentNode && this.dropdown.parentNode.removeChild(this.dropdown)), this._handlePageLoad && window.removeEventListener("load", this._handlePageLoad), this._trigger("close:countrydropdown")
            }
            _scrollTo(Q) {
              const re = this.countryList,
                xe = document.documentElement.scrollTop,
                ce = re.offsetHeight,
                Ee = re.getBoundingClientRect().top + xe,
                Be = Ee + ce,
                Ke = Q.offsetHeight,
                tt = Q.getBoundingClientRect().top + xe,
                ot = tt + Ke,
                ft = tt - Ee + re.scrollTop;
              if (tt < Ee) re.scrollTop = ft;
              else if (ot > Be) {
                const Bt = ce - Ke;
                re.scrollTop = ft - Bt
              }
            }
            _updateDialCode(Q) {
              const re = this.telInput.value,
                xe = `+${Q}`;
              let ce;
              if (re.charAt(0) === "+") {
                const Ee = this._getDialCode(re);
                Ee ? ce = re.replace(Ee, xe) : ce = xe, this.telInput.value = ce
              }
            }
            _getDialCode(Q, re) {
              let xe = "";
              if (Q.charAt(0) === "+") {
                let ce = "";
                for (let Ee = 0; Ee < Q.length; Ee++) {
                  const Be = Q.charAt(Ee);
                  if (!isNaN(parseInt(Be, 10))) {
                    if (ce += Be, re) this.dialCodeToIso2Map[ce] && (xe = Q.substr(0, Ee + 1));
                    else if (this.dialCodes[ce]) {
                      xe = Q.substr(0, Ee + 1);
                      break
                    }
                    if (ce.length === this.dialCodeMaxLen) break
                  }
                }
              }
              return xe
            }
            _getFullNumber(Q) {
              const re = Q || this.telInput.value.trim(),
                {
                  dialCode: xe
                } = this.selectedCountryData;
              let ce;
              const Ee = nt(re);
              return this.options.separateDialCode && re.charAt(0) !== "+" && xe && Ee ? ce = `+${xe}` : ce = "", ce + re
            }
            _beforeSetNumber(Q) {
              let re = Q;
              if (this.options.separateDialCode) {
                let xe = this._getDialCode(re);
                if (xe) {
                  xe = `+${this.selectedCountryData.dialCode}`;
                  const ce = re[xe.length] === " " || re[xe.length] === "-" ? xe.length + 1 : xe.length;
                  re = re.substr(ce)
                }
              }
              return this._cap(re)
            }
            _triggerCountryChange() {
              this._trigger("countrychange")
            }
            _formatNumberAsYouType() {
              const Q = this._getFullNumber(),
                re = Re.utils ? Re.utils.formatNumberAsYouType(Q, this.selectedCountryData.iso2) : Q,
                {
                  dialCode: xe
                } = this.selectedCountryData;
              return this.options.separateDialCode && this.telInput.value.charAt(0) !== "+" && re.includes(`+${xe}`) ? (re.split(`+${xe}`)[1] || "").trim() : re
            }
            handleAutoCountry() {
              this.options.initialCountry === "auto" && Re.autoCountry && (this.defaultCountry = Re.autoCountry, this.selectedCountryData.iso2 || this.selectedCountryInner.classList.contains("iti__globe") || this.setCountry(this.defaultCountry), this.resolveAutoCountryPromise())
            }
            handleUtils() {
              Re.utils && (this.telInput.value && this._updateValFromNumber(this.telInput.value), this.selectedCountryData.iso2 && (this._updatePlaceholder(), this._updateMaxLength())), this.resolveUtilsScriptPromise()
            }
            destroy() {
              var Ee, Be;
              const {
                allowDropdown: Q,
                separateDialCode: re
              } = this.options;
              if (Q) {
                this._closeDropdown(), this.selectedCountry.removeEventListener("click", this._handleClickSelectedCountry), this.countryContainer.removeEventListener("keydown", this._handleCountryContainerKeydown);
                const Ke = this.telInput.closest("label");
                Ke && Ke.removeEventListener("click", this._handleLabelClick)
              }
              const {
                form: xe
              } = this.telInput;
              this._handleHiddenInputSubmit && xe && xe.removeEventListener("submit", this._handleHiddenInputSubmit), this.telInput.removeEventListener("input", this._handleInputEvent), this._handleKeydownEvent && this.telInput.removeEventListener("keydown", this._handleKeydownEvent), this.telInput.removeAttribute("data-intl-tel-input-id"), re && (this.isRTL ? this.telInput.style.paddingRight = this.originalPaddingRight : this.telInput.style.paddingLeft = this.originalPaddingLeft);
              const ce = this.telInput.parentNode;
              (Ee = ce == null ? void 0 : ce.parentNode) == null || Ee.insertBefore(this.telInput, ce), (Be = ce == null ? void 0 : ce.parentNode) == null || Be.removeChild(ce), delete Re.instances[this.id]
            }
            getExtension() {
              return Re.utils ? Re.utils.getExtension(this._getFullNumber(), this.selectedCountryData.iso2) : ""
            }
            getNumber(Q) {
              if (Re.utils) {
                const {
                  iso2: re
                } = this.selectedCountryData;
                return Re.utils.formatNumber(this._getFullNumber(), re, Q)
              }
              return ""
            }
            getNumberType() {
              return Re.utils ? Re.utils.getNumberType(this._getFullNumber(), this.selectedCountryData.iso2) : -99
            }
            getSelectedCountryData() {
              return this.selectedCountryData
            }
            getValidationError() {
              if (Re.utils) {
                const {
                  iso2: Q
                } = this.selectedCountryData;
                return Re.utils.getValidationError(this._getFullNumber(), Q)
              }
              return -99
            }
            isValidNumber() {
              if (!this.selectedCountryData.iso2) return !1;
              const Q = this._getFullNumber(),
                re = Q.search(new RegExp("\\p{L}", "u"));
              if (re > -1) {
                const xe = Q.substring(0, re),
                  ce = this._utilsIsPossibleNumber(xe),
                  Ee = this._utilsIsPossibleNumber(Q);
                return ce && Ee
              }
              return this._utilsIsPossibleNumber(Q)
            }
            _utilsIsPossibleNumber(Q) {
              return Re.utils ? Re.utils.isPossibleNumber(Q, this.selectedCountryData.iso2, this.options.validationNumberTypes) : null
            }
            isValidNumberPrecise() {
              if (!this.selectedCountryData.iso2) return !1;
              const Q = this._getFullNumber(),
                re = Q.search(new RegExp("\\p{L}", "u"));
              if (re > -1) {
                const xe = Q.substring(0, re),
                  ce = this._utilsIsValidNumber(xe),
                  Ee = this._utilsIsValidNumber(Q);
                return ce && Ee
              }
              return this._utilsIsValidNumber(Q)
            }
            _utilsIsValidNumber(Q) {
              return Re.utils ? Re.utils.isValidNumber(Q, this.selectedCountryData.iso2, this.options.validationNumberTypes) : null
            }
            setCountry(Q) {
              const re = Q == null ? void 0 : Q.toLowerCase(),
                xe = this.selectedCountryData.iso2;
              (Q && re !== xe || !Q && xe) && (this._setCountry(re), this._updateDialCode(this.selectedCountryData.dialCode), this._triggerCountryChange())
            }
            setNumber(Q) {
              const re = this._updateCountryFromNumber(Q);
              this._updateValFromNumber(Q), re && this._triggerCountryChange(), this._trigger("input", {
                isSetNumber: !0
              })
            }
            setPlaceholderNumberType(Q) {
              this.options.placeholderNumberType = Q, this._updatePlaceholder()
            }
            setDisabled(Q) {
              this.telInput.disabled = Q, Q ? this.selectedCountry.setAttribute("disabled", "true") : this.selectedCountry.removeAttribute("disabled")
            }
          },
          ht = Q => {
            if (!Re.utils && !Re.startedLoadingUtilsScript) {
              let re;
              if (typeof Q == "function") try {
                re = Promise.resolve(Q())
              } catch (xe) {
                return Promise.reject(xe)
              } else return Promise.reject(new TypeError(`The argument passed to attachUtils must be a function that returns a promise for the utilities module, not ${typeof Q}`));
              return Re.startedLoadingUtilsScript = !0, re.then(xe => {
                const ce = xe == null ? void 0 : xe.default;
                if (!ce || typeof ce != "object") throw new TypeError("The loader function passed to attachUtils did not resolve to a module object with utils as its default export.");
                return Re.utils = ce, pt("handleUtils"), !0
              }).catch(xe => {
                throw pt("rejectUtilsScriptPromise", xe), xe
              })
            }
            return null
          },
          Re = Object.assign((Q, re) => {
            const xe = new at(Q, re);
            return xe._init(), Q.setAttribute("data-intl-tel-input-id", xe.id.toString()), Re.instances[xe.id] = xe, xe
          }, {
            defaults: Ve,
            documentReady: () => document.readyState === "complete",
            getCountryData: () => fe,
            getInstance: Q => {
              const re = Q.getAttribute("data-intl-tel-input-id");
              return re ? Re.instances[re] : null
            },
            instances: {},
            attachUtils: ht,
            startedLoadingUtilsScript: !1,
            startedLoadingAutoCountry: !1,
            version: "25.3.2"
          }),
          xt = Re;
        return K(G)
      })();
      return l.default
    })
  })(yf)), yf.exports
}
var Hk = Gk();
const Wk = cm(Hk);
var Xk = De('<div><span class="loading loading-spinner loading-xl"></span></div>'),
  Kk = De('<span class="w-8"> </span>'),
  Yk = De('<div class="text-center"><h2 class="text-2xl font-bold"> </h2> <p class="text-base-content/80 mt-0.5 text-sm"> </p></div> <form class="mt-8 flex w-full flex-col gap-3"><input class="input pl-12! w-full" type="tel" id="phone"/> <button class="btn btn-primary w-full"> <!></button></form>', 1),
  Jk = async (y, l, _) => {
    await l(b(_))
  }, Qk = De('<span class="w-8"> </span>'), eE = (y, l) => {
    he(l, "")
  }, tE = De('<div class="text-center"><h2 class="text-2xl font-bold"> </h2> <p class="mt-0.5 text-sm"> </p></div> <div class="mt-4"><!></div> <div class="mt-3 flex flex-col items-center gap-1"><button class="btn btn-ghost w-max"> <!></button> <button class="text-primary cursor-pointer text-xs"> </button></div>', 1), rE = De('<div class="flex h-full w-full flex-col items-center justify-center"><!></div>');

function iE(y, l) {
  kr(l, !0);
  let _ = _t(!0),
    T = _t(""),
    z = _t(0),
    F = _t(!1);
  const C = vt(() => b(z) > 0 || b(F));
  let o = _t(!1),
    K = _t(""),
    G = _t(void 0);
  const ie = vt(() => {
    var Me;
    return `phone:${(Me=Ot.data)==null?void 0:Me.id}`
  });
  $r(() => {
    const Me = localStorage.getItem(b(ie));
    Me && he(T, Me, !0)
  }), Ii(() => {
    ci.getOtpCooldown().then($e => {
      he(z, $e.cooldownMs, !0)
    }).catch($e => {
      Zr.error($e.message)
    }).finally(() => {
      he(_, !1)
    });
    const Me = 1e3,
      Le = setInterval(() => {
        he(z, Math.max(0, b(z) - Me), !0)
      }, Me);
    return () => {
      clearInterval(Le)
    }
  });
  async function de(Me) {
    try {
      he(F, !0);
      const Le = await ci.sendOtp(Me);
      Zr.info(`${gC()} ${Le.phone}`), he(T, Le.phone, !0), he(z, Le.cooldownMs, !0), localStorage.setItem(b(ie), b(T))
    } catch (Le) {
      Zr.error(Le.message)
    } finally {
      he(F, !1)
    }
  }
  $r(() => {
    b(K).length === 6 && (he(o, !0), (async () => {
      try {
        await ci.verifyOtp(b(K)), await Ot.refresh(), Zr.success(xC()), localStorage.removeItem(b(ie)), l.onsuccess(b(T))
      } catch (Me) {
        Zr.error(Me.message)
      } finally {
        he(K, ""), he(o, !1)
      }
    })())
  });
  var fe = rE(),
    W = E(fe);
  {
    var le = Me => {
        var Le = Xk();
        H(Me, Le)
      },
      Ce = Me => {
        var Le = sr(),
          $e = Et(Le);
        {
          var Oe = ct => {
              var nt = Yk(),
                Ye = Et(nt),
                dt = E(Ye),
                rt = E(dt, !0);
              A(dt);
              var qe = $(dt, 2),
                pt = E(qe, !0);
              A(qe), A(Ye);
              var at = $(Ye, 2),
                ht = E(at);
              qn(ht, () => xe => (he(G, Wk(xe, {
                strictMode: !0,
                initialCountry: "br",
                loadUtils: () => Lx(() => import("../chunks/1FgtjJRR.js"), [], import.meta.url),
                containerClass: "w-full",
                dropdownContainer: document.body
              })), () => {
                var ce;
                (ce = b(G)) == null || ce.destroy()
              }));
              var Re = $(ht, 2),
                xt = E(Re),
                Q = $(xt);
              {
                var re = xe => {
                  var ce = Kk(),
                    Ee = E(ce);
                  A(ce), lt(Be => Te(Ee, `(${Be??""})`), [() => zd(b(z))]), H(xe, ce)
                };
                et(Q, xe => {
                  b(z) > 0 && xe(re)
                })
              }
              A(Re), A(at), lt((xe, ce, Ee) => {
                Te(rt, xe), Te(pt, ce), Re.disabled = b(C), Te(xt, `${Ee??""} `)
              }, [() => KC(), () => QC(), () => rS()]), bn("submit", at, async () => {
                var ce;
                if (b(C)) return;
                if (!((ce = b(G)) != null && ce.isValidNumber())) {
                  Zr.error(TC());
                  return
                }
                const xe = b(G).getNumber();
                await de(xe)
              }), H(ct, nt)
            },
            Ve = ct => {
              var nt = tE(),
                Ye = Et(nt),
                dt = E(Ye),
                rt = E(dt, !0);
              A(dt);
              var qe = $(dt, 2),
                pt = E(qe);
              A(qe), A(Ye);
              var at = $(Ye, 2),
                ht = E(at);
              {
                const Be = (Ke, tt) => {
                  let ot = () => tt == null ? void 0 : tt().cells;
                  var ft = sr(),
                    Bt = Et(ft);
                  cn(Bt, () => qk, (At, cr) => {
                    cr(At, {
                      class: "border-primary",
                      children: (Mt, yt) => {
                        var St = sr(),
                          jt = Et(St);
                        xn(jt, 16, ot, Lt => Lt, (Lt, Gt) => {
                          var gr = sr(),
                            ur = Et(gr);
                          cn(ur, () => $k, (Qt, er) => {
                            er(Qt, {
                              get cell() {
                                return Gt
                              },
                              class: "border-base-content/20 size-11 sm:size-12"
                            })
                          }), H(Lt, gr)
                        }), H(Mt, St)
                      },
                      $$slots: {
                        default: !0
                      }
                    })
                  }), H(Ke, ft)
                };
                cn(ht, () => Uk, (Ke, tt) => {
                  tt(Ke, {
                    maxlength: 6,
                    class: "mx-auto w-max",
                    get disabled() {
                      return b(o)
                    },
                    get value() {
                      return b(K)
                    },
                    set value(ot) {
                      he(K, ot, !0)
                    },
                    children: Be,
                    $$slots: {
                      default: !0
                    }
                  })
                })
              }
              A(at);
              var Re = $(at, 2),
                xt = E(Re);
              xt.__click = [Jk, de, T];
              var Q = E(xt),
                re = $(Q);
              {
                var xe = Be => {
                  var Ke = Qk(),
                    tt = E(Ke);
                  A(Ke), lt(ot => Te(tt, `(${ot??""})`), [() => zd(b(z))]), H(Be, Ke)
                };
                et(re, Be => {
                  b(z) > 0 && Be(xe)
                })
              }
              A(xt);
              var ce = $(xt, 2);
              ce.__click = [eE, T];
              var Ee = E(ce, !0);
              A(ce), A(Re), lt((Be, Ke, tt, ot) => {
                Te(rt, Be), Te(pt, `${Ke??""} ${b(T)??""}`), xt.disabled = b(C), Te(Q, `${tt??""} `), Te(Ee, ot)
              }, [() => aS(), () => lS(), () => hS(), () => fS()]), H(ct, nt)
            };
          et($e, ct => {
            b(T) ? ct(Ve, !1) : ct(Oe)
          }, !0)
        }
        H(Me, Le)
      };
    et(W, Me => {
      b(_) ? Me(le) : Me(Ce, !1)
    })
  }
  A(fe), H(y, fe), Er()
}
en(["click"]);
var nE = De('<dialog class="modal"><div class="modal-box h-72 max-w-sm"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <!></div></dialog>');

function aE(y, l) {
  kr(l, !0);
  let _ = It(l, "open", 15);
  var T = nE(),
    z = E(T),
    F = $(E(z), 2);
  {
    var C = o => {
      iE(o, {
        onsuccess: () => _(!1)
      })
    };
    et(F, o => {
      _() && o(C)
    })
  }
  A(z), A(T), qn(T, () => o => {
    $r(() => {
      _() ? o.show() : o.close()
    })
  }), bn("close", T, () => _(!1)), H(y, T), Er()
}
var sE = (y, l) => {
    l()
  },
  oE = De('<span class="center-absolute loading loading-spinner absolute"></span>'),
  lE = De('<button type="button" class="relative hover:brightness-95 disabled:opacity-50"><!> <!></button>'),
  cE = (y, l, _) => {
    l(b(_).id)
  },
  uE = De('<span class="center-absolute loading loading-spinner absolute"></span>'),
  hE = De('<button type="button" class="relative hover:brightness-95 disabled:opacity-50"><!> <!></button>'),
  dE = De('<div><div class="text-base-content/80 text-sm"> </div> <div class="mt-2 grid grid-cols-3 gap-2"><!> <!></div></div>'),
  pE = (y, l) => {
    var _;
    (_ = b(l)) == null || _.show()
  },
  fE = (y, l) => {
    l(!1)
  },
  mE = (y, l) => {
    var _;
    (_ = b(l)) == null || _.close()
  },
  _E = async (y, l) => {
    try {
      he(l, !0), await ci.deleteMe(), Zr.warning(OC()), await Ot.logout()
    } catch (_) {
      Zr.error(_.message)
    } finally {
      he(l, !1)
    }
  }, gE = De('<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form class="mt-3 w-full"><div class="flex flex-col gap-6 sm:flex-row"><div class="sm:min-w-34 flex items-center justify-center gap-6 sm:flex-col sm:gap-3"><div class="relative w-max"><!> <a class="tooltip btn btn-circle tooltip-right absolute -bottom-1 -right-1 max-sm:overflow-x-hidden" href="/profile-picture"><!></a></div> <!></div> <div class="flex w-full flex-col gap-3"><!> <!> <label class="label text-sm"><input class="checkbox checkbox-xs" type="checkbox"/> </label></div></div> <div class="mt-4 flex w-full items-center justify-between"><button type="button" class="btn btn-error btn-soft btn-sm w-max"> </button> <div class="flex gap-2"><button class="btn btn-soft" type="button"> </button> <button class="btn btn-primary" type="submit"> </button></div></div></form></div></dialog> <dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <p class="mt-4"> </p> <div class="mt-4 flex justify-end gap-2"><button class="btn btn-soft"> </button> <button class="btn btn-error"> </button></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>', 1);

function vE(y, l) {
  kr(l, !0);
  let _ = It(l, "open", 15),
    T = _t(En(l.userData.name)),
    z = _t(En(l.userData.discord)),
    F = _t(En(l.userData.showLastPixel)),
    C = _t(!1),
    o = _t(void 0),
    K = _t(void 0);
  Ii(() => {
    const Dt = Ir => {
      Ir.key === "Escape" && _(!1)
    };
    return document.addEventListener("keydown", Dt), () => document.removeEventListener("keydown", Dt)
  });
  let G = _t(void 0),
    ie = _t(void 0);
  $r(() => {
    he(T, l.userData.name, !0), he(F, l.userData.showLastPixel, !0)
  }), $r(() => {
    _() && !b(K) && ci.getMyProfilePictures().then(Dt => {
      he(K, Dt, !0)
    }).catch(Dt => {
      Zr.error(Dt.message)
    })
  });
  let de = _t(!1);
  async function fe(Dt) {
    try {
      he(de, !0), await ci.changeProfilePicture(Dt), await Ot.refresh()
    } finally {
      he(de, !1)
    }
  }
  var W = gE(),
    le = Et(W),
    Ce = E(le),
    Me = $(E(Ce), 2),
    Le = E(Me, !0);
  A(Me);
  var $e = $(Me, 2),
    Oe = E($e),
    Ve = E(Oe),
    ct = E(Ve),
    nt = E(ct);
  ss(nt, {
    class: "size-30",
    get userId() {
      return l.userData.id
    },
    get pictureUrl() {
      return l.userData.picture
    }
  });
  var Ye = $(nt, 2),
    dt = E(Ye);
  Wg(dt, {
    class: "size-5"
  }), A(Ye), A(ct);
  var rt = $(ct, 2);
  {
    var qe = Dt => {
      var Ir = dE(),
        Tr = E(Ir),
        Dr = E(Tr, !0);
      A(Tr);
      var Fr = $(Tr, 2),
        dr = E(Fr);
      {
        var Or = tr => {
          var br = lE();
          br.__click = [sE, fe];
          var $t = E(br);
          ss($t, {
            class: "size-10 border",
            get userId() {
              return l.userData.id
            }
          });
          var yr = $($t, 2);
          {
            var jr = ye => {
              var j = oE();
              H(ye, j)
            };
            et(yr, ye => {
              b(de) && ye(jr)
            })
          }
          A(br), lt(() => br.disabled = b(de)), H(tr, br)
        };
        et(dr, tr => {
          l.userData.picture && tr(Or)
        })
      }
      var zr = $(dr, 2);
      xn(zr, 17, () => b(K), tr => tr.id, (tr, br) => {
        var $t = sr(),
          yr = Et($t);
        {
          var jr = ye => {
            var j = hE();
            j.__click = [cE, fe, br];
            var V = E(j);
            ss(V, {
              class: "size-10 border",
              get userId() {
                return l.userData.id
              },
              get pictureUrl() {
                return b(br).url
              }
            });
            var X = $(V, 2);
            {
              var se = we => {
                var Ae = uE();
                H(we, Ae)
              };
              et(X, we => {
                b(de) && we(se)
              })
            }
            A(j), lt(() => j.disabled = b(de)), H(ye, j)
          };
          et(yr, ye => {
            l.userData.picture !== b(br).url && ye(jr)
          })
        }
        H(tr, $t)
      }), A(Fr), A(Ir), lt(tr => Te(Dr, tr), [() => n2()]), H(Dt, Ir)
    };
    et(rt, Dt => {
      var Ir;
      (Ir = b(K)) != null && Ir.length && Dt(qe)
    })
  }
  A(Ve);
  var pt = $(Ve, 2),
    at = E(pt);
  {
    let Dt = vt(() => wf()),
      Ir = vt(() => wf());
    Sf(at, {
      get label() {
        return b(Dt)
      },
      get placeholder() {
        return b(Ir)
      },
      min: 1,
      max: 16,
      get value() {
        return b(T)
      },
      set value(Tr) {
        he(T, Tr, !0)
      },
      get validate() {
        return b(G)
      },
      set validate(Tr) {
        he(G, Tr, !0)
      }
    })
  }
  var ht = $(at, 2);
  {
    let Dt = vt(() => l5());
    Sf(ht, {
      label: "Discord",
      get placeholder() {
        return b(Dt)
      },
      max: 32,
      get value() {
        return b(z)
      },
      set value(Ir) {
        he(z, Ir, !0)
      },
      get validate() {
        return b(ie)
      },
      set validate(Ir) {
        he(ie, Ir, !0)
      }
    })
  }
  var Re = $(ht, 2),
    xt = E(Re);
  $a(xt);
  var Q = $(xt);
  A(Re), A(pt), A(Oe);
  var re = $(Oe, 2),
    xe = E(re);
  xe.__click = [pE, o];
  var ce = E(xe, !0);
  A(xe);
  var Ee = $(xe, 2),
    Be = E(Ee);
  Be.__click = [fE, _];
  var Ke = E(Be, !0);
  A(Be);
  var tt = $(Be, 2),
    ot = E(tt, !0);
  A(tt), A(Ee), A(re), A($e), A(Ce), A(le), qn(le, () => Dt => {
    $r(() => {
      _() ? Dt.show() : Dt.close()
    })
  });
  var ft = $(le, 2),
    Bt = E(ft),
    At = $(E(Bt), 2),
    cr = E(At, !0);
  A(At);
  var Mt = $(At, 2),
    yt = E(Mt, !0);
  A(Mt);
  var St = $(Mt, 2),
    jt = E(St);
  jt.__click = [mE, o];
  var Lt = E(jt, !0);
  A(jt);
  var Gt = $(jt, 2);
  Gt.__click = [_E, C];
  var gr = E(Gt, !0);
  A(Gt), A(St), A(Bt);
  var ur = $(Bt, 2),
    Qt = E(ur),
    er = E(Qt, !0);
  A(Qt), A(ur), A(ft), Ss(ft, Dt => he(o, Dt), () => b(o)), lt((Dt, Ir, Tr, Dr, Fr, dr, Or, zr, tr, br, $t) => {
    Te(Le, Dt), Br(Ye, "data-tip", Ir), Te(Q, ` ${Tr??""}`), Te(ce, Dr), Be.disabled = b(C), Te(Ke, Fr), tt.disabled = b(C), Te(ot, dr), Te(cr, Or), Te(yt, zr), Te(Lt, tr), Gt.disabled = b(C), Te(gr, br), Te(er, $t)
  }, [() => gS(), () => Ix(), () => o2(), () => Cg(), () => ec(), () => d2(), () => m2(), () => v2(), () => Jf(), () => Cg(), () => ec()]), bn("close", le, () => _(!1)), bn("submit", $e, async () => {
    var Dt, Ir;
    try {
      if (!((Dt = b(G)) != null && Dt()) || !((Ir = b(ie)) != null && Ir())) return;
      he(C, !0), await ci.updateMe({
        name: b(T),
        showLastPixel: b(F),
        discord: b(z)
      }), Ot.refresh(), Zr.success(RC()), _(!1)
    } catch (Tr) {
      Zr.error(Tr.message)
    } finally {
      he(C, !1)
    }
  }), Mx(xt, () => b(F), Dt => he(F, Dt)), H(y, W), Er()
}
en(["click"]);
var yE = wr('<svg><path d="M440-160v-487L216-423l-56-57 320-320 320 320-56 57-224-224v487h-80Z"></path></svg>');

function xE(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = yE();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var bE = wr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h280v80H200v560h280v80H200Zm440-160-55-58 102-102H360v-80h327L585-622l55-58 200 200-200 200Z"></path></svg>');

function $v(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = bE();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var wE = wr('<svg><path d="M240-80q-50 0-85-35t-35-85v-120h120v-560l60 60 60-60 60 60 60-60 60 60 60-60 60 60 60-60 60 60 60-60v680q0 50-35 85t-85 35H240Zm480-80q17 0 28.5-11.5T760-200v-560H320v440h360v120q0 17 11.5 28.5T720-160ZM360-600v-80h240v80H360Zm0 120v-80h240v80H360Zm320-120q-17 0-28.5-11.5T640-640q0-17 11.5-28.5T680-680q17 0 28.5 11.5T720-640q0 17-11.5 28.5T680-600Zm0 120q-17 0-28.5-11.5T640-520q0-17 11.5-28.5T680-560q17 0 28.5 11.5T720-520q0 17-11.5 28.5T680-480ZM240-160h360v-80H200v40q0 17 11.5 28.5T240-160Zm-40 0v-80 80Z"></path></svg>');

function TE(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = wE();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var CE = wr('<svg><defs><radialGradient id="snoo-radial-gragient" cx="169.75" cy="92.19" r="50.98" fx="169.75" fy="92.19" gradientTransform="matrix(1 0 0 .87 0 11.64)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#feffff"></stop><stop offset=".4" stop-color="#feffff"></stop><stop offset=".51" stop-color="#f9fcfc"></stop><stop offset=".62" stop-color="#edf3f5"></stop><stop offset=".7" stop-color="#dee9ec"></stop><stop offset=".72" stop-color="#d8e4e8"></stop><stop offset=".76" stop-color="#ccd8df"></stop><stop offset=".8" stop-color="#c8d5dd"></stop><stop offset=".83" stop-color="#ccd6de"></stop><stop offset=".85" stop-color="#d8dbe2"></stop><stop offset=".88" stop-color="#ede3e9"></stop><stop offset=".9" stop-color="#ffebef"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-2" cx="47.31" r="50.98" fx="47.31"></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-3" cx="109.61" cy="85.59" r="153.78" fx="109.61" fy="85.59" gradientTransform="matrix(1 0 0 .7 0 25.56)"></radialGradient><radialGradient id="snoo-radial-gragient-4" cx="-6.01" cy="64.68" r="12.85" fx="-6.01" fy="64.68" gradientTransform="matrix(1.07 0 0 1.55 81.08 27.26)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#f60"></stop><stop offset=".5" stop-color="#ff4500"></stop><stop offset=".7" stop-color="#fc4301"></stop><stop offset=".82" stop-color="#f43f07"></stop><stop offset=".92" stop-color="#e53812"></stop><stop offset="1" stop-color="#d4301f"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient-4" id="snoo-radial-gragient-5" cx="-73.55" cy="64.68" r="12.85" fx="-73.55" fy="64.68" gradientTransform="matrix(-1.07 0 0 1.55 62.87 27.26)"></radialGradient><radialGradient id="snoo-radial-gragient-6" cx="107.93" cy="166.96" r="45.3" fx="107.93" fy="166.96" gradientTransform="matrix(1 0 0 .66 0 57.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#172e35"></stop><stop offset=".29" stop-color="#0e1c21"></stop><stop offset=".73" stop-color="#030708"></stop><stop offset="1"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-7" cx="147.88" cy="32.94" r="39.77" fx="147.88" fy="32.94" gradientTransform="matrix(1 0 0 .98 0 .54)"></radialGradient><radialGradient id="snoo-radial-gragient-8" cx="131.31" cy="73.08" r="32.6" fx="131.31" fy="73.08" gradientUnits="userSpaceOnUse"><stop offset=".48" stop-color="#7a9299"></stop><stop offset=".67" stop-color="#172e35"></stop><stop offset=".75"></stop><stop offset=".82" stop-color="#172e35"></stop></radialGradient></defs><path fill="#ff4500" stroke-width="0" d="M108 0C48.35 0 0 48.35 0 108c0 29.82 12.09 56.82 31.63 76.37l-20.57 20.57C6.98 209.02 9.87 216 15.64 216H108c59.65 0 108-48.35 108-108S167.65 0 108 0Z"></path><circle cx="169.22" cy="106.98" r="25.22" fill="url(#snoo-radial-gragient)" stroke-width="0"></circle><circle cx="46.78" cy="106.98" r="25.22" fill="url(#snoo-radial-gragient-2)" stroke-width="0"></circle><ellipse cx="108.06" cy="128.64" fill="url(#snoo-radial-gragient-3)" stroke-width="0" rx="72" ry="54"></ellipse><path fill="url(#snoo-radial-gragient-4)" stroke-width="0" d="M86.78 123.48c-.42 9.08-6.49 12.38-13.56 12.38s-12.46-4.93-12.04-14.01c.42-9.08 6.49-15.02 13.56-15.02s12.46 7.58 12.04 16.66Z"></path><path fill="url(#snoo-radial-gragient-5)" stroke-width="0" d="M129.35 123.48c.42 9.08 6.49 12.38 13.56 12.38s12.46-4.93 12.04-14.01c-.42-9.08-6.49-15.02-13.56-15.02s-12.46 7.58-12.04 16.66Z"></path><ellipse cx="79.63" cy="116.37" class="snoo-cls-11 svelte-1977t4s" rx="2.8" ry="3.05"></ellipse><ellipse cx="146.21" cy="116.37" class="snoo-cls-11 svelte-1977t4s" rx="2.8" ry="3.05"></ellipse><path fill="url(#snoo-radial-gragient-6)" stroke-width="0" d="M108.06 142.92c-8.76 0-17.16.43-24.92 1.22-1.33.13-2.17 1.51-1.65 2.74 4.35 10.39 14.61 17.69 26.57 17.69s22.23-7.3 26.57-17.69c.52-1.23-.33-2.61-1.65-2.74-7.77-.79-16.16-1.22-24.92-1.22Z"></path><circle cx="147.49" cy="49.43" r="17.87" fill="url(#snoo-radial-gragient-7)" stroke-width="0"></circle><path fill="url(#snoo-radial-gragient-8)" stroke-width="0" d="M107.8 76.92c-2.14 0-3.87-.89-3.87-2.27 0-16.01 13.03-29.04 29.04-29.04 2.14 0 3.87 1.73 3.87 3.87s-1.73 3.87-3.87 3.87c-11.74 0-21.29 9.55-21.29 21.29 0 1.38-1.73 2.27-3.87 2.27Z"></path><path fill="#842123" stroke-width="0" d="M62.82 122.65c.39-8.56 6.08-14.16 12.69-14.16 6.26 0 11.1 6.39 11.28 14.33.17-8.88-5.13-15.99-12.05-15.99s-13.14 6.05-13.56 15.2c-.42 9.15 4.97 13.83 12.04 13.83h.52c-6.44-.16-11.3-4.79-10.91-13.2Zm90.48 0c-.39-8.56-6.08-14.16-12.69-14.16-6.26 0-11.1 6.39-11.28 14.33-.17-8.88 5.13-15.99 12.05-15.99 7.07 0 13.14 6.05 13.56 15.2.42 9.15-4.97 13.83-12.04 13.83h-.52c6.44-.16 11.3-4.79 10.91-13.2Z"></path></svg>');

function SE(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = CE();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink",
    viewBox: "0 0 216 216",
    ..._
  }), void 0, void 0, "svelte-1977t4s"), H(y, T)
}
var PE = wr('<svg><path d="m476-80 182-480h84L924-80h-84l-43-122H603L560-80h-84ZM160-200l-56-56 202-202q-35-35-63.5-80T190-640h84q20 39 40 68t48 58q33-33 68.5-92.5T484-720H40v-80h280v-80h80v80h280v80H564q-21 72-63 148t-83 116l96 98-30 82-122-125-202 201Zm468-72h144l-72-204-72 204Z"></path></svg>');

function IE(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = PE();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var ME = wr('<svg><path d="M792-56 671-177q-25 16-53 27.5T560-131v-82q14-5 27.5-10t25.5-12L480-368v208L280-360H120v-240h128L56-792l56-56 736 736-56 56Zm-8-232-58-58q17-31 25.5-65t8.5-70q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 53-14.5 102T784-288ZM650-422l-90-90v-130q47 22 73.5 66t26.5 96q0 15-2.5 29.5T650-422ZM480-592 376-696l104-104v208Zm-80 238v-94l-72-72H200v80h114l86 86Zm-36-130Z"></path></svg>');

function AE(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = ME();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var kE = wr('<svg><path d="M560-131v-82q90-26 145-100t55-168q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 127-78 224.5T560-131ZM120-360v-240h160l200-200v640L280-360H120Zm440 40v-322q47 22 73.5 66t26.5 96q0 51-26.5 94.5T560-320ZM400-606l-86 86H200v80h114l86 86v-252ZM300-480Z"></path></svg>');

function EE(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = kE();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var zE = (y, l) => {
    he(l, !0)
  },
  LE = De('<span class="tooltip font-flag ml-0.5"> </span>'),
  DE = De('<div class="mt-1"><!></div>'),
  RE = (y, l, _) => {
    localStorage.setItem(kx, b(l).key), he(_, b(l).key, !0), location.reload()
  },
  BE = De('<span class="center-absolute loading loading-spinner loading-xs absolute"></span>'),
  FE = De("<li><button><!> </button></li>"),
  OE = async (y, l) => {
    var _;
    try {
      const T = await ((_ = b(l)) == null ? void 0 : _.prompt());
      (T == null ? void 0 : T.outcome) === "accepted" && he(l, void 0)
    } catch (T) {
      Zr.error(Zb({
        error: T.message
      }))
    }
  }, NE = De('<button class="btn pwa:hidden w-full sm:hidden"><!> </button>'), jE = De('<form class="w-full" method="POST"><button class="btn w-full"><!> Purchases</button></form>'), qE = async (y, l, _, T) => {
    var z;
    try {
      he(l, !0), await _.user.logout(), T(), Zr.warning(qC(), {
        icon: $v
      }), (z = _.onlogout) == null || z.call(_)
    } catch {
      Zr.error($C())
    } finally {
      he(l, !1)
    }
  }, VE = De('<div class="dropdown"><div tabindex="0" role="button" class="btn size-12 p-0 shadow-md"><!></div> <div class="dropdown-content menu bg-base-100 rounded-box border-base-300 z-1 relative right-1 w-[min(100vw-24px,400px)] translate-y-2 border p-4 shadow-md" tabindex="0"><button class="btn btn-ghost btn-circle absolute right-2 top-2"><!></button> <section class="flex gap-2"><div class="relative"><!> <button class="btn btn-circle btn-sm absolute -bottom-1 -right-1"><!></button></div> <div><div class="flex items-center gap-1.5 pr-8 text-lg font-medium"><h3 class="line-clamp-1 text-ellipsis text-lg"> </h3> <span> </span> <!> <!></div> <div class="flex items-center gap-1"><!> <span> <span class="text-primary font-semibold"> </span></span></div> <div class="flex items-center gap-1"><!> <span class="text-secondary"><span class="font-semibold"> </span> <button class="tooltip"><!></button></span></div></div></section> <section class="mt-3 flex flex-col gap-2"><div class="mb-1 flex items-center justify-between"><h3 class="text-lg font-semibold"> </h3> <div class="flex items-center gap-2"><div class="dropdown dropdown-end"><div tabindex="0" role="button" class="btn btn-sm btn-circle"><!></div> <ul tabindex="0" class="dropdown-content menu bg-base-100 z-1 w-max rounded-xl p-2 shadow-sm"></ul></div> <div class="tooltip"><button class="btn btn-sm btn-circle"><!></button></div></div></div>  <!> <a class="btn w-full" href="https://www.twitch.tv/directory/category/wplace" target="_blank"><!> </a> <a class="btn w-full" href="http://discord.gg/wplacelive" target="_blank"><!> Discord</a> <a class="btn w-full" href="https://www.reddit.com/r/WplaceLive/" target="_blank"><!> Reddit</a> <!> <button class="btn"><!> </button></section></div></div> <!>', 1);

function ZE(y, l) {
  kr(l, !0);
  let _ = _t(!1),
    T = _t(!1);

  function z() {
    var de;
    (de = document.activeElement) == null || de.blur()
  }
  const F = [{
    label: "🇺🇸 English",
    key: "en"
  }, {
    label: "🇧🇷 Português",
    key: "pt"
  }];
  let C = _t(""),
    o = _t(void 0);
  var K = sr(),
    G = Et(K);
  {
    var ie = de => {
      var fe = VE(),
        W = Et(fe),
        le = E(W),
        Ce = E(le);
      Yg(Ce, {
        get userId() {
          return l.user.data.id
        },
        get level() {
          return l.user.data.level
        },
        get pictureUrl() {
          return l.user.data.picture
        }
      }), A(le);
      var Me = $(le, 2),
        Le = E(Me);
      Le.__click = z;
      var $e = E(Le);
      pc($e, {
        class: "size-5"
      }), A(Le);
      var Oe = $(Le, 2),
        Ve = E(Oe),
        ct = E(Ve);
      ss(ct, {
        get userId() {
          return l.user.data.id
        },
        get pictureUrl() {
          return l.user.data.picture
        }
      });
      var nt = $(ct, 2);
      nt.__click = [zE, _];
      var Ye = E(nt);
      Pf(Ye, {
        class: "size-4"
      }), A(nt), A(Ve);
      var dt = $(Ve, 2),
        rt = E(dt),
        qe = E(rt),
        pt = E(qe, !0);
      A(qe);
      var at = $(qe, 2),
        ht = E(at);
      A(at);
      var Re = $(at, 2);
      {
        var xt = Ne => {
          const ze = vt(() => as(l.user.data.equippedFlag));
          var Ie = LE(),
            We = E(Ie, !0);
          A(Ie), lt(() => {
            Br(Ie, "data-tip", b(ze).name), Te(We, b(ze).flag)
          }), H(Ne, Ie)
        };
        et(Re, Ne => {
          l.user.data.equippedFlag && Ne(xt)
        })
      }
      var Q = $(Re, 2);
      {
        var re = Ne => {
          var ze = DE(),
            Ie = E(ze);
          fh(Ie, {
            get username() {
              return l.user.data.discord
            }
          }), A(ze), H(Ne, ze)
        };
        et(Q, Ne => {
          l.user.data.discord && Ne(re)
        })
      }
      A(rt);
      var xe = $(rt, 2),
        ce = E(xe);
      mh(ce, {
        class: "inline size-4"
      });
      var Ee = $(ce, 2),
        Be = E(Ee),
        Ke = $(Be),
        tt = E(Ke, !0);
      A(Ke), A(Ee), A(xe);
      var ot = $(xe, 2),
        ft = E(ot);
      xE(ft, {
        class: "inline size-4"
      });
      var Bt = $(ft, 2),
        At = E(Bt),
        cr = E(At);
      A(At);
      var Mt = $(At),
        yt = $(Mt),
        St = E(yt);
      Hf(St, {
        class: "mb-0.5 inline size-4 opacity-50"
      }), A(yt), A(Bt), A(ot), A(dt), A(Oe);
      var jt = $(Oe, 2),
        Lt = E(jt),
        Gt = E(Lt),
        gr = E(Gt, !0);
      A(Gt);
      var ur = $(Gt, 2),
        Qt = E(ur),
        er = E(Qt),
        Dt = E(er);
      IE(Dt, {
        class: "size-4"
      }), A(er);
      var Ir = $(er, 2);
      xn(Ir, 21, () => F, Yf, (Ne, ze) => {
        const Ie = vt(() => b(C) === b(ze).key);
        var We = FE(),
          ve = E(We);
        let Pt;
        ve.__click = [RE, ze, C];
        var Xt = E(ve);
        {
          var Nt = or => {
            var ri = BE();
            H(or, ri)
          };
          et(Xt, or => {
            b(Ie) && or(Nt)
          })
        }
        var Ht = $(Xt);
        A(ve), A(We), lt(or => {
          Pt = Vr(ve, 1, "font-flag relative font-medium", null, Pt, or), Te(Ht, ` ${b(ze).label??""}`)
        }, [() => ({
          "bg-base-200": b(Ie)
        })]), H(Ne, We)
      }), A(Ir), A(Qt);
      var Tr = $(Qt, 2),
        Dr = E(Tr);
      Dr.__click = () => {
        aa.muted = !aa.muted
      };
      var Fr = E(Dr);
      {
        var dr = Ne => {
            AE(Ne, {
              class: "size-4"
            })
          },
          Or = Ne => {
            EE(Ne, {
              class: "size-4"
            })
          };
        et(Fr, Ne => {
          aa.muted ? Ne(dr) : Ne(Or, !1)
        })
      }
      A(Dr), A(Tr), A(ur), A(Lt);
      var zr = $(Lt, 2);
      {
        var tr = Ne => {
          var ze = NE();
          ze.__click = [OE, o];
          var Ie = E(ze);
          _v(Ie, {
            class: "size-5"
          });
          var We = $(Ie);
          A(ze), lt(ve => Te(We, ` ${ve??""}`), [() => Gb()]), H(Ne, ze)
        };
        et(zr, Ne => {
          b(o) && Ne(tr)
        })
      }
      var br = $(zr, 2),
        $t = E(br);
      ev($t, {
        class: "size-5"
      });
      var yr = $($t);
      A(br);
      var jr = $(br, 2),
        ye = E(jr);
      um(ye, {
        class: "size-5"
      }), mi(), A(jr);
      var j = $(jr, 2),
        V = E(j);
      SE(V, {
        class: "size-5"
      }), mi(), A(j);
      var X = $(j, 2);
      {
        var se = Ne => {
          var ze = jE(),
            Ie = E(ze),
            We = E(Ie);
          TE(We, {
            class: "size-5"
          }), mi(), A(Ie), A(ze), lt(() => Br(ze, "action", `${px}/payment/create-portal-session`)), H(Ne, ze)
        };
        et(X, Ne => {
          var ze;
          (ze = l.user.data) != null && ze.isCustomer && Ne(se)
        })
      }
      var we = $(X, 2);
      we.__click = [qE, T, l, z];
      var Ae = E(we);
      $v(Ae, {
        class: "size-5"
      });
      var Ze = $(Ae);
      A(we), A(jt), A(Me), A(W);
      var Se = $(W, 2);
      vE(Se, {
        get userData() {
          return l.user.data
        },
        get open() {
          return b(_)
        },
        set open(Ne) {
          he(_, Ne, !0)
        }
      }), lt((Ne, ze, Ie, We, ve, Pt, Xt, Nt, Ht, or, ri) => {
        Br(le, "title", Ne), Br(qe, "title", l.user.data.name), Te(pt, l.user.data.name), Vr(at, 1, ze), Te(ht, `#${l.user.data.id??""}`), Te(Be, `${Ie??""}: `), Te(tt, We), Te(cr, `Level ${ve??""}`), Te(Mt, ` (${Pt??""}%) `), Br(yt, "data-tip", Xt), Te(gr, Nt), Br(Tr, "data-tip", Ht), Te(yr, ` ${or??""}`), we.disabled = b(T), Te(Ze, ` ${ri??""}`)
      }, [() => Rb(), () => Xo(Yn(l.user.data.id)), () => rm(), () => l.user.data.pixelsPainted.toLocaleString("en-US"), () => Math.floor(l.user.data.level), () => Math.floor(l.user.data.level % 1 * 100), () => i5(), () => jb(), () => aa.muted ? Q3() : K3(), () => Xb(), () => Jb()]), bn("focus", le, () => {
        he(o, window.pwaInstallPrompt, !0)
      }), H(de, fe)
    };
    et(G, de => {
      l.user.data && l.user.charges !== void 0 && de(ie)
    })
  }
  H(y, K), Er()
}
en(["click"]);
var $E = wr('<svg><path d="M100-240v-480l360 240-360 240Zm400 0v-480l360 240-360 240ZM180-480Zm400 0Zm-400 90 136-90-136-90v180Zm400 0 136-90-136-90v180Z"></path></svg>');

function UE(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = $E();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var GE = wr('<svg><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q146 0 255.5 91.5T872-559h-82q-19-73-68.5-130.5T600-776v16q0 33-23.5 56.5T520-680h-80v80q0 17-11.5 28.5T400-560h-80v80h80v120h-40L168-552q-3 18-5.5 36t-2.5 36q0 131 92 225t228 95v80Zm364-20L716-228q-21 12-45 20t-51 8q-75 0-127.5-52.5T440-380q0-75 52.5-127.5T620-560q75 0 127.5 52.5T800-380q0 27-8 51t-20 45l128 128-56 56ZM620-280q42 0 71-29t29-71q0-42-29-71t-71-29q-42 0-71 29t-29 71q0 42 29 71t71 29Z"></path></svg>');

function HE(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = GE();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var WE = async (y, l, _, T, z, F) => {
  if (b(l)) {
    _.map.easeTo(b(l)), he(l, void 0);
    return
  }
  he(T, !0);
  try {
    qa(_.map.getCenter(), _.map.getZoom());
    const C = new uc(b(z)),
      {
        tile: o,
        pixel: K
      } = await ci.getRandomTile(_.season),
      G = o.x * b(z) + K.x,
      ie = o.y * b(z) + K.y,
      [de, fe] = C.pixelsToLatLon(G, ie, b(F)),
      W = {
        lat: de,
        lng: fe
      },
      le = b(F) + 2;
    he(l, {
      zoom: le,
      center: W
    }, !0), _.map.flyTo(b(l)), Qo.isEmpty() && Qo.push({
      pos: _.map.getCenter(),
      zoom: _.map.getZoom()
    }), setTimeout(() => {
      he(l, void 0)
    }, 2500), Qo.push({
      pos: W,
      zoom: le
    })
  } catch (C) {
    Zr.error(C.message)
  } finally {
    he(T, !1)
  }
}, XE = De('<button class="btn btn-square shadow-md"><!></button>');

function KE(y, l) {
  kr(l, !0);
  const _ = vt(() => jn.seasons[l.season].tileSize),
    T = vt(() => jn.seasons[l.season].zoom);
  let z = _t(!1),
    F = _t(void 0);
  var C = XE();
  C.__click = [WE, F, l, z, _, T];
  var o = E(C);
  {
    var K = ie => {
        HE(ie, {
          class: "size-5"
        })
      },
      G = ie => {
        UE(ie, {
          class: "size-5"
        })
      };
    et(o, ie => {
      b(F) ? ie(G, !1) : ie(K)
    })
  }
  A(C), lt(ie => {
    Br(C, "title", ie), C.disabled = b(z)
  }, [() => cb()]), H(y, C), Er()
}
en(["click"]);
var YE = De('<label class="tab grow font-semibold max-sm:h-10"><input type="radio" class="tab grow"/> <!> </label>'),
  JE = De('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'),
  QE = De('<span class="font-flag tooltip ml-0.5"> </span>'),
  e8 = De("<span> </span>"),
  t8 = De('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="max-sm:px-1"><div class="flex items-center gap-2"><!> <div class="items-center gap-2 sm:flex"><span> <span class="ml-0.5"> </span></span> <!> <!> <!></div></div></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  r8 = De('<table class="table"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  i8 = De('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="h-14 max-sm:px-1"><span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'),
  n8 = De('<table class="table"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'),
  a8 = De('<div class="h-screen pt-20"><div class="flex justify-center"><span class="loading loading-spinner"></span></div></div>'),
  s8 = De('<div class="tabs tabs-box"></div> <div class="my-4 flex items-center justify-between"><!></div> <!>', 1);

function o8(y, l) {
  kr(l, !0);
  const _ = [];
  let T = _t("today"),
    z = {
      players: {
        label: uv(),
        icon: Gd
      },
      alliances: {
        label: hv(),
        icon: Hd
      }
    },
    F = _t("players"),
    C = En({
      players: {},
      alliances: {}
    });
  const o = vt(() => C[b(F)][b(T)]);
  $r(() => {
    if (b(o)) return;
    const Ce = b(T),
      Me = b(F);
    Me === "players" ? ci.leaderboardRegionPlayers(l.regionId, Ce).then(Le => {
      C[Me][Ce] = Le
    }).catch(Le => {
      Zr.error(Le.message)
    }) : Me === "alliances" && ci.leaderboardRegionAlliances(l.regionId, Ce).then(Le => {
      C[Me][Ce] = Le
    }).catch(Le => {
      Zr.error(Le.message)
    })
  });
  var K = s8(),
    G = Et(K);
  xn(G, 21, () => Object.entries(z), ([Ce, {
    label: Me,
    icon: Le
  }]) => Ce, (Ce, Me) => {
    var Le = vt(() => Zg(b(Me), 2));
    let $e = () => b(Le)[0],
      Oe = () => b(Le)[1].label,
      Ve = () => b(Le)[1].icon;
    const ct = vt(Ve);
    var nt = YE(),
      Ye = E(nt);
    $a(Ye);
    var dt, rt = $(Ye, 2);
    cn(rt, () => b(ct), (pt, at) => {
      at(pt, {
        get this() {
          return Ve()
        },
        class: "mr-1 size-5 max-sm:hidden"
      })
    });
    var qe = $(rt);
    A(nt), lt(() => {
      Br(Ye, "aria-label", Oe()), dt !== (dt = $e()) && (Ye.value = (Ye.__value = $e()) ?? ""), Te(qe, ` ${Oe()??""}`)
    }), Qf(_, [], Ye, () => ($e(), b(F)), pt => he(F, pt)), H(Ce, nt)
  }), A(G);
  var ie = $(G, 2),
    de = E(ie);
  hm(de, {
    get value() {
      return b(T)
    },
    set value(Ce) {
      he(T, Ce, !0)
    }
  }), A(ie);
  var fe = $(ie, 2);
  {
    var W = Ce => {
        var Me = JE(),
          Le = E(Me),
          $e = $(Le);
        {
          var Oe = ct => {
              var nt = sa();
              lt(Ye => Te(nt, Ye), [() => Ud().toLowerCase()]), H(ct, nt)
            },
            Ve = ct => {
              var nt = sr(),
                Ye = Et(nt);
              {
                var dt = qe => {
                    var pt = sa();
                    lt(at => Te(pt, at), [() => nm()]), H(qe, pt)
                  },
                  rt = qe => {
                    var pt = sr(),
                      at = Et(pt);
                    {
                      var ht = Re => {
                        var xt = sa();
                        lt(Q => Te(xt, Q), [() => am()]), H(Re, xt)
                      };
                      et(at, Re => {
                        b(T) === "month" && Re(ht)
                      }, !0)
                    }
                    H(qe, pt)
                  };
                et(Ye, qe => {
                  b(T) === "week" ? qe(dt) : qe(rt, !1)
                }, !0)
              }
              H(ct, nt)
            };
          et($e, ct => {
            b(T) === "today" ? ct(Oe) : ct(Ve, !1)
          })
        }
        A(Me), lt(ct => Te(Le, `${ct??""} `), [() => im()]), H(Ce, Me)
      },
      le = Ce => {
        var Me = sr(),
          Le = Et(Me);
        {
          var $e = Ve => {
              var ct = sr(),
                nt = Et(ct);
              {
                var Ye = rt => {
                    const qe = vt(() => b(o));
                    var pt = r8(),
                      at = E(pt),
                      ht = E(at),
                      Re = $(E(ht)),
                      xt = E(Re, !0);
                    A(Re);
                    var Q = $(Re),
                      re = E(Q),
                      xe = $(re, 2, !0);
                    A(Q), A(ht), A(at);
                    var ce = $(at);
                    xn(ce, 31, () => b(qe), Ee => Ee.id, (Ee, Be, Ke) => {
                      const tt = vt(() => {
                        var dr;
                        return ((dr = Ot.data) == null ? void 0 : dr.id) === b(Be).id
                      });
                      var ot = t8();
                      let ft;
                      var Bt = E(ot),
                        At = E(Bt, !0);
                      A(Bt);
                      var cr = $(Bt),
                        Mt = E(cr),
                        yt = E(Mt);
                      ss(yt, {
                        class: "size-10 border",
                        get userId() {
                          return b(Be).id
                        },
                        get pictureUrl() {
                          return b(Be).picture
                        }
                      });
                      var St = $(yt, 2),
                        jt = E(St),
                        Lt = E(jt),
                        Gt = $(Lt),
                        gr = E(Gt);
                      A(Gt), A(jt);
                      var ur = $(jt, 2);
                      {
                        var Qt = dr => {
                          const Or = vt(() => as(b(Be).equippedFlag));
                          var zr = QE(),
                            tr = E(zr, !0);
                          A(zr), lt(() => {
                            Br(zr, "data-tip", b(Or).name), Te(tr, b(Or).flag)
                          }), H(dr, zr)
                        };
                        et(ur, dr => {
                          "equippedFlag" in b(Be) && b(Be).equippedFlag && dr(Qt)
                        })
                      }
                      var er = $(ur, 2);
                      {
                        var Dt = dr => {
                          fh(dr, {
                            get username() {
                              return b(Be).discord
                            }
                          })
                        };
                        et(er, dr => {
                          b(Be).discord && dr(Dt)
                        })
                      }
                      var Ir = $(er, 2);
                      {
                        var Tr = dr => {
                          var Or = e8(),
                            zr = E(Or, !0);
                          A(Or), lt((tr, br) => {
                            Vr(Or, 1, `badge badge-sm ml-0.5 border-0 ${tr??""} ${br??""}`), Te(zr, b(Be).allianceName)
                          }, [() => em(b(Be).allianceId), () => Yn(b(Be).allianceId)]), H(dr, Or)
                        };
                        et(Ir, dr => {
                          "allianceName" in b(Be) && b(Be).allianceName && dr(Tr)
                        })
                      }
                      A(St), A(Mt), A(cr);
                      var Dr = $(cr),
                        Fr = E(Dr, !0);
                      A(Dr), A(ot), lt((dr, Or, zr) => {
                        ft = Vr(ot, 1, "", null, ft, dr), Te(At, b(Ke) + 1), Vr(jt, 1, `font-semibold max-sm:ml-2 ${Or??""} flex gap-1`), Te(Lt, `${b(Be).name??""} `), Te(gr, `#${b(Be).id??""}`), Te(Fr, zr)
                      }, [() => ({
                        "bg-base-200": b(tt)
                      }), () => Yn(b(Be).id), () => b(Be).pixelsPainted.toLocaleString("en-US")]), Yo(ot, () => Jo, () => ({
                        duration: 200
                      })), H(Ee, ot)
                    }), A(ce), A(pt), lt((Ee, Be, Ke) => {
                      Te(xt, Ee), Te(re, `${Be??""} `), Te(xe, Ke)
                    }, [() => sm(), () => Jl(), () => Ql().toLowerCase()]), H(rt, pt)
                  },
                  dt = rt => {
                    var qe = sr(),
                      pt = Et(qe);
                    {
                      var at = ht => {
                        var Re = n8(),
                          xt = E(Re),
                          Q = E(xt),
                          re = $(E(Q)),
                          xe = E(re, !0);
                        A(re);
                        var ce = $(re),
                          Ee = E(ce),
                          Be = $(Ee, 2, !0);
                        A(ce), A(Q), A(xt);
                        var Ke = $(xt);
                        xn(Ke, 31, () => b(o), tt => tt.id, (tt, ot, ft) => {
                          const Bt = vt(() => {
                            var ur;
                            return ((ur = Ot.data) == null ? void 0 : ur.allianceId) === b(ot).id
                          });
                          var At = i8();
                          let cr;
                          var Mt = E(At),
                            yt = E(Mt, !0);
                          A(Mt);
                          var St = $(Mt),
                            jt = E(St),
                            Lt = E(jt, !0);
                          A(jt), A(St);
                          var Gt = $(St),
                            gr = E(Gt, !0);
                          A(Gt), A(At), lt((ur, Qt, er) => {
                            cr = Vr(At, 1, "", null, cr, ur), Te(yt, b(ft) + 1), Vr(jt, 1, `font-semibold ${Qt??""}`), Te(Lt, b(ot).name), Te(gr, er)
                          }, [() => ({
                            "bg-base-200": b(Bt)
                          }), () => Yn(b(ot).id), () => b(ot).pixelsPainted.toLocaleString("en-US")]), Yo(At, () => Jo, () => ({
                            duration: 200
                          })), H(tt, At)
                        }), A(Ke), A(Re), lt((tt, ot, ft) => {
                          Te(xe, tt), Te(Ee, `${ot??""} `), Te(Be, ft)
                        }, [() => Zd(), () => Jl(), () => Ql().toLowerCase()]), H(ht, Re)
                      };
                      et(pt, ht => {
                        b(F) === "alliances" && ht(at)
                      }, !0)
                    }
                    H(rt, qe)
                  };
                et(nt, rt => {
                  b(F) === "players" ? rt(Ye) : rt(dt, !1)
                })
              }
              H(Ve, ct)
            },
            Oe = Ve => {
              var ct = a8();
              H(Ve, ct)
            };
          et(Le, Ve => {
            b(o) ? Ve($e) : Ve(Oe, !1)
          }, !0)
        }
        H(Ce, Me)
      };
    et(fe, Ce => {
      b(o) && b(o).length === 0 ? Ce(W) : Ce(le, !1)
    })
  }
  H(y, K), Er()
}
var l8 = De('<div class="mt-5"><!></div>'),
  c8 = De('<dialog class="modal"><div class="modal-box h-11/12 max-w-3xl"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <h2><span class="font-flag tooltip"> </span> <span> </span> <span> </span></h2> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');

function u8(y, l) {
  kr(l, !0);
  let _ = It(l, "open", 15);
  const T = vt(() => as(l.region.countryId));
  Ii(() => {
    const Ce = Me => {
      Me.key === "Escape" && _(!1)
    };
    return document.addEventListener("keydown", Ce), () => document.removeEventListener("keydown", Ce)
  });
  var z = c8(),
    F = E(z),
    C = $(E(F), 2),
    o = E(C),
    K = E(o, !0);
  A(o);
  var G = $(o, 2),
    ie = E(G, !0);
  A(G);
  var de = $(G, 2),
    fe = E(de);
  A(de), A(C);
  var W = $(C, 2);
  {
    var le = Ce => {
      var Me = l8(),
        Le = E(Me);
      o8(Le, {
        get regionId() {
          return l.region.id
        }
      }), A(Me), An(2, Me, () => Kn, () => ({
        duration: 300
      })), H(Ce, Me)
    };
    et(W, Ce => {
      _() && Ce(le)
    })
  }
  A(F), mi(2), A(z), qn(z, () => Ce => {
    $r(() => {
      _() ? Ce.show() : Ce.close()
    })
  }), lt(Ce => {
    Vr(C, 1, `flex gap-2 text-xl font-bold sm:text-2xl ${Ce??""}`), Br(o, "data-tip", b(T).name), Te(K, b(T).flag), Te(ie, l.region.name), Te(fe, `#${l.region.number??""}`)
  }, [() => Yn(l.region.cityId)]), bn("close", z, () => _(!1)), H(y, z), Er()
}
var h8 = wr('<svg><path d="M791-55 686-160H160v-112q0-34 17.5-62.5T224-378q45-23 91.5-37t94.5-21L55-791l57-57 736 736-57 57ZM240-240h366L486-360h-6q-56 0-111 13.5T260-306q-9 5-14.5 14t-5.5 20v32Zm496-138q29 14 46 42.5t18 61.5L666-408q18 7 35.5 14t34.5 16ZM568-506l-59-59q23-9 37-29.5t14-45.5q0-33-23.5-56.5T480-720q-25 0-45.5 14T405-669l-59-59q23-34 58-53t76-19q66 0 113 47t47 113q0 41-19 76t-53 58Zm38 266H240h366ZM457-617Z"></path></svg>');

function d8(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = h8();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    height: "24px",
    viewBox: "0 -960 960 960",
    width: "24px",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var p8 = wr('<svg><path d="m233-120 65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Z"></path></svg>'),
  f8 = wr('<svg><path d="m354-287 126-76 126 77-33-144 111-96-146-13-58-136-58 135-146 13 111 97-33 143ZM233-120l65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Zm247-350Z"></path></svg>');

function m8(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy", "filled"]);
  var T = sr(),
    z = Et(T);
  {
    var F = o => {
        var K = p8();
        Kt(K, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ..._
        })), H(o, K)
      },
      C = o => {
        var K = f8();
        Kt(K, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ..._
        })), H(o, K)
      };
    et(z, o => {
      l.filled ? o(F) : o(C, !1)
    })
  }
  H(y, T)
}
var _8 = (y, l, _, T, z) => {
    if (b(l) && b(_)) {
      const F = b(l) - b(_).clientHeight,
        C = b(l) / 2 - F / 2;
      T.map.flyTo({
        center: {
          lat: b(z).center[0],
          lng: b(z).center[1]
        },
        zoom: 17.5,
        offset: [0, -C]
      })
    }
  },
  g8 = (y, l, _) => l.onclickregion(b(_)),
  v8 = De('<button><span class="font-flag tooltip"> </span> <span class="line-clamp-1 text-ellipsis"> </span> <span> </span></button>'),
  y8 = De('<div class="skeleton h-5 w-16"></div>'),
  x8 = De('<div class="skeleton mt-1 h-5 w-32"></div>'),
  b8 = De('<span class="font-flag tooltip ml-0.5"> </span>'),
  w8 = async (y, l, _, T, z, F) => {
    he(l, !0);
    try {
      await ci.banAllianceUser(b(_).id), await T({
        ...b(z),
        season: F.season
      })
    } catch (C) {
      Zr.error(C.message)
    } finally {
      he(l, !1)
    }
  }, T8 = De('<div class="dropdown dropdown-top max-sm:dropdown-top max-sm:dropdown-left"><button tabindex="0" class="btn btn-xs btn-circle"><!></button> <ul tabindex="0" class="dropdown-content menu bg-base-100 z-1 mb-1 w-max rounded-xl p-2 shadow-sm"><li><button class="text-error"><!> </button></li></ul></div>'), C8 = De("<span> </span> <!>", 1), S8 = De('<div class="flex items-center gap-1"><span> </span> <div class="ml-0.5"><!></div> <span><span> </span> <span> </span></span> <!> <!> <!></div>'), P8 = (y, l) => l.onclickpaint(l.latLon), I8 = async (y, l, _, T) => {
    try {
      he(l, !0), b(_) ? (await ci.deleteFavoriteLocation(b(_).id), Zr.warning(PC())) : (await ci.favoriteLocation(b(T).center), Zr.success(AC())), ha.smallPlop.play(), Ot.refresh()
    } catch (z) {
      Zr.error(z.message)
    } finally {
      he(l, !1)
    }
  }, M8 = De("<button><!> </button>"), A8 = (y, l, _) => l.onclickshare(_P(Va.url, {
    pos: {
      lat: b(_).center[0],
      lng: b(_).center[1]
    },
    zoom: l.zoom
  })), k8 = De('<div><div class="flex gap-2 px-3"><div class="flex grow gap-1"><button class="btn btn-sm btn-circle btn-soft"><!></button> <h2 class="mt-0.5 flex items-center gap-2 text-lg"><span class="whitespace-nowrap"> </span> <!></h2></div> <button class="btn btn-circle btn-sm"><!></button></div> <div class="text-base-content/80 mt-1 px-3 text-sm"><!></div> <div class="hide-scrollbar flex max-w-full gap-1.5 overflow-x-auto px-3 pb-2 pt-3 sm:pb-3"><button class="btn btn-primary"><!> </button> <!> <button class="btn btn-primary btn-soft"><!> </button></div></div>');

function E8(y, l) {
  kr(l, !0);
  let _ = _t(void 0);
  const T = vt(() => new uc(l.tileSize));
  let z = _t(void 0),
    F = _t(void 0),
    C = _t(!1),
    o = _t(!1);
  const K = vt(() => {
    const [ot, ft] = l.latLon ?? [0, 0], Bt = b(T).latLonToPixelBoundsLatLon(ot, ft, l.pixelArtZoom), At = lm(Bt), {
      tile: cr,
      pixel: Mt
    } = b(T).latLonToTileAndPixel(ot, ft, l.pixelArtZoom), yt = b(T).latLonToRegionAndPixel(ot, ft, l.pixelArtZoom);
    return {
      bounds: Bt,
      center: At,
      tile: cr,
      pixel: Mt,
      regionPixel: yt.pixel
    }
  });
  $r(() => {
    ha.plop.play(), l.crosshair.clearAndPlace(l.latLon)
  });
  let G = 0;
  const ie = ({
    pixel: ot,
    tile: ft,
    season: Bt
  }) => `s${Bt}:p(${ot[0]},${ot[1]}):t(${ft[0]},${ft[1]})`;
  let de;
  hc(() => [b(K), l.season], () => {
    const ot = {
        ...b(K),
        season: l.season
      },
      ft = ie(ot);
    if (he(_, l.pixelInfoCache.get(ft), !0), b(_) !== void 0) return;
    l.pixelInfoCache.size === 0 && (G = 0), G++, G > 6 ? (clearTimeout(de), de = setTimeout(async () => fe(ot), 500)) : fe(ot)
  });
  async function fe(ot) {
    const ft = await ci.getPixelInfo(ot);
    if (ft.paintedBy !== void 0) {
      const At = ie(ot);
      l.pixelInfoCache.set(At, ft)
    }
    const Bt = ie({
      ...b(K),
      season: l.season
    });
    return he(_, l.pixelInfoCache.get(Bt), !0), ft
  }

  function W() {
    l.crosshair.clear(), ha.smallPlop.play(), l.onclose()
  }
  Ii(() => {
    const ot = ft => {
      ft.key === "Escape" && W()
    };
    return document.addEventListener("keydown", ot), () => document.removeEventListener("keydown", ot)
  });
  var le = k8(),
    Ce = E(le),
    Me = E(Ce),
    Le = E(Me);
  Le.__click = [_8, z, F, l, K];
  var $e = E(Le);
  dm($e, {
    class: "fill-primary size-5"
  }), A(Le);
  var Oe = $(Le, 2),
    Ve = E(Oe),
    ct = E(Ve);
  A(Ve);
  var nt = $(Ve, 2);
  {
    var Ye = ot => {
        const ft = vt(() => b(_).region),
          Bt = vt(() => as(b(ft).countryId));
        var At = v8();
        At.__click = [g8, l, ft];
        var cr = E(At),
          Mt = E(cr, !0);
        A(cr);
        var yt = $(cr, 2),
          St = E(yt, !0);
        A(yt);
        var jt = $(yt, 2),
          Lt = E(jt);
        A(jt), A(At), lt(Gt => {
          Vr(At, 1, `btn btn-xs flex gap-1 py-3 text-sm max-sm:max-w-32 ${Gt??""}`), Br(cr, "data-tip", b(Bt).name), Te(Mt, b(Bt).flag), Te(St, b(ft).name), Te(Lt, `#${b(ft).number??""}`)
        }, [() => Yn(b(ft).cityId)]), H(ot, At)
      },
      dt = ot => {
        var ft = y8();
        H(ot, ft)
      };
    et(nt, ot => {
      var ft;
      (ft = b(_)) != null && ft.region ? ot(Ye) : ot(dt, !1)
    })
  }
  A(Oe), A(Me);
  var rt = $(Me, 2);
  rt.__click = W;
  var qe = E(rt);
  pc(qe, {
    class: "size-4"
  }), A(rt), A(Ce);
  var pt = $(Ce, 2),
    at = E(pt);
  {
    var ht = ot => {
        var ft = x8();
        H(ot, ft)
      },
      Re = ot => {
        var ft = sr(),
          Bt = Et(ft);
        {
          var At = Mt => {
              var yt = sa();
              lt(St => Te(yt, St), [() => z3()]), H(Mt, yt)
            },
            cr = Mt => {
              const yt = vt(() => b(_).paintedBy);
              var St = S8(),
                jt = E(St),
                Lt = E(jt);
              A(jt);
              var Gt = $(jt, 2),
                gr = E(Gt);
              ss(gr, {
                class: "size-5 border-0",
                get userId() {
                  return b(yt).id
                },
                get pictureUrl() {
                  return b(yt).picture
                }
              }), A(Gt);
              var ur = $(Gt, 2),
                Qt = E(ur),
                er = E(Qt, !0);
              A(Qt);
              var Dt = $(Qt, 2),
                Ir = E(Dt);
              A(Dt), A(ur);
              var Tr = $(ur, 2);
              {
                var Dr = tr => {
                  const br = vt(() => as(b(yt).equippedFlag));
                  var $t = b8(),
                    yr = E($t, !0);
                  A($t), lt(() => {
                    Br($t, "data-tip", b(br).name), Te(yr, b(br).flag)
                  }), H(tr, $t)
                };
                et(Tr, tr => {
                  b(yt).equippedFlag && tr(Dr)
                })
              }
              var Fr = $(Tr, 2);
              {
                var dr = tr => {
                  fh(tr, {
                    get username() {
                      return b(yt).discord
                    }
                  })
                };
                et(Fr, tr => {
                  b(yt).discord && tr(dr)
                })
              }
              var Or = $(Fr, 2);
              {
                var zr = tr => {
                  var br = C8(),
                    $t = Et(br),
                    yr = E($t, !0);
                  A($t);
                  var jr = $($t, 2);
                  {
                    var ye = j => {
                      var V = T8(),
                        X = E(V),
                        se = E(X);
                      pm(se, {
                        class: "size-4"
                      }), A(X);
                      var we = $(X, 2),
                        Ae = E(we),
                        Ze = E(Ae);
                      Ze.__click = [w8, o, yt, fe, K, l];
                      var Se = E(Ze);
                      d8(Se, {
                        class: "size-5"
                      });
                      var Ne = $(Se);
                      A(Ze), A(Ae), A(we), A(V), lt(ze => Te(Ne, ` ${ze??""}`), [() => cv()]), H(j, V)
                    };
                    et(jr, j => {
                      var V;
                      b(yt).allianceId === ((V = Ot.data) == null ? void 0 : V.allianceId) && Ot.data.allianceRole === "admin" && Ot.data.id !== b(yt).id && j(ye)
                    })
                  }
                  lt((j, V) => {
                    Vr($t, 1, `badge badge-sm ml-0.5 border-0 ${j??""} ${V??""}`), Te(yr, b(yt).allianceName)
                  }, [() => em(b(yt).allianceId), () => Yn(b(yt).allianceId)]), H(tr, br)
                };
                et(Or, tr => {
                  b(yt).allianceName && tr(zr)
                })
              }
              A(St), lt((tr, br) => {
                var $t;
                Te(Lt, `${tr??""}:`), Vr(ur, 1, `font-medium ${br??""} flex gap-1.5`), Te(er, (($t = Ot.data) == null ? void 0 : $t.id) === b(yt).id ? Ot.data.name : b(yt).name), Te(Ir, `#${b(yt).id??""}`)
              }, [() => R3(), () => Yn(b(yt).id)]), H(Mt, St)
            };
          et(Bt, Mt => {
            b(_).paintedBy.id === 0 ? Mt(At) : Mt(cr, !1)
          }, !0)
        }
        H(ot, ft)
      };
    et(at, ot => {
      b(_) === void 0 ? ot(ht) : ot(Re, !1)
    })
  }
  A(pt);
  var xt = $(pt, 2),
    Q = E(xt);
  Q.__click = [P8, l];
  var re = E(Q);
  mh(re, {
    class: "size-4.5"
  });
  var xe = $(re);
  A(Q);
  var ce = $(Q, 2);
  {
    var Ee = ot => {
      const ft = vt(() => Ot.data.favoriteLocations.find(St => Math.abs(St.latitude - b(K).center[0]) < 5e-5 && Math.abs(St.longitude - b(K).center[1]) < 5e-5)),
        Bt = vt(() => !b(ft) && Ot.data.favoriteLocations.length >= Ot.data.maxFavoriteLocations);
      var At = M8();
      let cr;
      At.__click = [I8, C, ft, K];
      var Mt = E(At);
      {
        let St = vt(() => !!b(ft));
        m8(Mt, {
          class: "size-4.5",
          get filled() {
            return b(St)
          }
        })
      }
      var yt = $(Mt);
      A(At), lt((St, jt) => {
        cr = Vr(At, 1, "btn btn-primary btn-soft", null, cr, St), At.disabled = b(C) || b(Bt), Te(yt, ` ${jt??""}`)
      }, [() => ({
        "text-yellow-400": !!b(ft)
      }), () => b(Bt) ? O3() : q3()]), H(ot, At)
    };
    et(ce, ot => {
      Ot.data && ot(Ee)
    })
  }
  var Be = $(ce, 2);
  Be.__click = [A8, l, K];
  var Ke = E(Be);
  gv(Ke, {
    class: "size-4.5"
  });
  var tt = $(Ke);
  A(Be), A(xt), A(le), Ss(le, ot => he(F, ot), () => b(F)), lt((ot, ft) => {
    Te(ct, `Pixel: ${b(K).regionPixel[0]??""}, ${b(K).regionPixel[1]??""}`), Q.disabled = Ot.loading, Te(xe, ` ${ot??""}`), Te(tt, ` ${ft??""}`)
  }, [() => av(), () => $3()]), Vd("innerHeight", ot => he(z, ot, !0)), H(y, le), Er()
}
en(["click"]);

function z8(y) {
  var T;
  const l = document.createElement("div");
  (T = y.parentElement) == null || T.insertBefore(l, y.nextSibling);
  const _ = new IntersectionObserver(z => {
    z[0].isIntersecting ? y.classList.remove("stuck") : y.classList.add("stuck")
  }, {
    threshold: 0,
    rootMargin: "0px"
  });
  return _.observe(l), () => {
    l.remove(), _.disconnect()
  }
}
var L8 = wr('<svg><path d="M200-120v-680h360l16 80h224v400H520l-16-80H280v280h-80Z"></path></svg>'),
  D8 = wr('<svg><path d="M200-120v-680h360l16 80h224v400H520l-16-80H280v280h-80Zm300-440Zm86 160h134v-240H510l-16-80H280v240h290l16 80Z"></path></svg>');

function R8(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy", "filled"]);
  var T = sr(),
    z = Et(T);
  {
    var F = o => {
        var K = L8();
        Kt(K, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ..._
        })), H(o, K)
      },
      C = o => {
        var K = D8();
        Kt(K, () => ({
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -960 960 960",
          fill: "currentColor",
          ..._
        })), H(o, K)
      };
    et(z, o => {
      l.filled ? o(F) : o(C, !1)
    })
  }
  H(y, T)
}
var B8 = De('<span class="loading loading-spinner center-absolute absolute"></span>'),
  F8 = De('<button class="btn btn-lg sm:btn-md btn-primary relative h-10"><!> <!> <span class="text-sm">Droplets</span></button>'),
  O8 = De('<span class="loading loading-spinner center-absolute absolute"></span>'),
  N8 = De('<!> <span class="text-sm"> </span>', 1),
  j8 = De('<span class="text-sm"> </span>'),
  q8 = De('<button><div class="tooltip-content max-w-54 p-2"> </div> <!> <!></button>'),
  V8 = De('<div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="font-flag flex grow items-center justify-center p-1 text-7xl"> </div> <p class="mt-2 text-center text-xl font-bold"> </p> <!> <div><!></div></div>'),
  Z8 = (y, l) => {
    he(l, !b(l))
  },
  $8 = De('<div><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium">Flags</h3></div> <p class="text-base-content/80 text-sm"> </p> <div class="grid-cols mt-3 grid gap-3 sm:grid-cols-2 lg:grid-cols-4"></div> <div class="mt-4 flex justify-center"><button class="btn btn-lg"> </button></div></div>');

function U8(y, l) {
  kr(l, !0);
  const _ = (Oe, Ve = kn) => {
      const ct = vt(() => {
          var ce;
          return (((ce = Ot.data) == null ? void 0 : ce.droplets) ?? 0) >= C.price
        }),
        nt = vt(() => b(K) === Ve().id);
      var Ye = V8(),
        dt = E(Ye),
        rt = E(dt, !0);
      A(dt);
      var qe = $(dt, 2),
        pt = E(qe, !0);
      A(qe);
      var at = $(qe, 2);
      {
        var ht = ce => {
          gm(ce, {})
        };
        et(at, ce => {
          Ve().id === b(G) && ce(ht)
        })
      }
      var Re = $(at, 2);
      let xt;
      var Q = E(Re);
      {
        var re = ce => {
            var Ee = F8();
            Ee.__click = async () => {
              try {
                const ft = Ve().id;
                he(K, ft, !0), await ci.purchase({
                  id: F,
                  amount: 1,
                  variant: ft
                }), Ot.refresh(), ha.notification1.play();
                const Bt = z.find(At => At.id === ft);
                Bt && (Bt.owned = !0), he(G, ft, !0)
              } catch (ft) {
                Zr.error(ft.message)
              } finally {
                he(K, void 0)
              }
            };
            var Be = E(Ee);
            {
              var Ke = ft => {
                var Bt = B8();
                H(ft, Bt)
              };
              et(Be, ft => {
                b(nt) && ft(Ke)
              })
            }
            var tt = $(Be, 2);
            qd(tt, {
              class: "size-4"
            });
            var ot = $(tt);
            mi(), A(Ee), lt(ft => {
              Ee.disabled = !b(ct) || b(nt), Te(ot, ` ${ft??""} `)
            }, [() => C.price.toLocaleString("en-US")]), H(ce, Ee)
          },
          xe = ce => {
            const Ee = vt(() => {
              var yt;
              return ((yt = Ot.data) == null ? void 0 : yt.equippedFlag) === Ve().id
            });
            var Be = q8();
            let Ke;
            Be.__click = async () => {
              try {
                he(K, Ve().id, !0);
                const yt = b(Ee) ? 0 : Ve().id;
                await ci.equipFlag(yt), Ot.data && (Ot.data.equippedFlag = yt), Ot.refresh()
              } catch (yt) {
                Zr.error(yt.message)
              } finally {
                he(K, void 0)
              }
            };
            var tt = E(Be),
              ot = E(tt, !0);
            A(tt);
            var ft = $(tt, 2);
            {
              var Bt = yt => {
                var St = O8();
                H(yt, St)
              };
              et(ft, yt => {
                b(nt) && yt(Bt)
              })
            }
            var At = $(ft, 2);
            {
              var cr = yt => {
                  var St = N8(),
                    jt = Et(St);
                  pc(jt, {
                    class: "size-4"
                  });
                  var Lt = $(jt, 2),
                    Gt = E(Lt, !0);
                  A(Lt), lt(gr => Te(Gt, gr), [() => k2()]), H(yt, St)
                },
                Mt = yt => {
                  var St = j8(),
                    jt = E(St, !0);
                  A(St), lt(Lt => Te(jt, Lt), [() => L2()]), H(yt, St)
                };
              et(At, yt => {
                b(Ee) ? yt(cr) : yt(Mt, !1)
              })
            }
            A(Be), lt((yt, St) => {
              Ke = Vr(Be, 1, "btn btn-lg sm:btn-md tooltip tooltip-bottom relative h-10", null, Ke, yt), Be.disabled = b(nt), Te(ot, St)
            }, [() => ({
              "btn-warning": b(Ee)
            }), () => I2()]), H(ce, Be)
          };
        et(Q, ce => {
          Ve().owned ? ce(xe, !1) : ce(re)
        })
      }
      A(Re), A(Ye), lt((ce, Ee) => {
        Te(rt, Ve().flag), Te(pt, Ve().name), xt = Vr(Re, 1, "mt-3", null, xt, ce), Br(Re, "data-tip", Ee)
      }, [() => ({
        tooltip: !b(ct)
      }), () => $d()]), H(Oe, Ye)
    },
    T = jn.countries.map(Oe => ({
      ...Oe,
      owned: Ot.flagsBitmap.get(Oe.id)
    }));
  T.sort((Oe, Ve) => Number(Ve.owned) - Number(Oe.owned));
  const z = En(T),
    F = 110,
    C = jn.products[F];
  let o = _t(!1),
    K = _t(void 0),
    G = _t(void 0);
  var ie = $8(),
    de = E(ie),
    fe = E(de);
  R8(fe, {
    class: "size-5.5",
    filled: !0
  }), mi(2), A(de);
  var W = $(de, 2),
    le = E(W, !0);
  A(W);
  var Ce = $(W, 2);
  xn(Ce, 23, () => z, Oe => Oe.id, (Oe, Ve, ct) => {
    var nt = sr(),
      Ye = Et(nt);
    {
      var dt = rt => {
        _(rt, () => b(Ve))
      };
      et(Ye, rt => {
        (b(ct) < 8 || b(o)) && rt(dt)
      })
    }
    H(Oe, nt)
  }), A(Ce);
  var Me = $(Ce, 2),
    Le = E(Me);
  Le.__click = [Z8, o];
  var $e = E(Le, !0);
  A(Le), A(Me), A(ie), lt(Oe => {
    Te(le, Oe), Te($e, b(o) ? "Show less" : "Show more")
  }, [() => C2()]), H(y, ie), Er()
}
en(["click"]);
var G8 = De('<p class="mt-1 text-center text-sm"> </p>'),
  H8 = (y, l) => {
    $g(l, -1)
  },
  W8 = (y, l) => {
    $g(l)
  },
  X8 = (y, l, _) => {
    l(b(_))
  },
  K8 = De('<button class="text-base-content/80 absolute left-full top-1/2 ml-2 size-10 -translate-y-1/2 rounded-full text-[10px] font-bold">MAX</button>'),
  Y8 = async (y, l, _, T) => {
    try {
      he(l, !0), await ci.purchase({
        id: _.productId,
        amount: T()
      }), ha.notification1.play(), _.onpurchasecompleted(T())
    } catch (z) {
      Zr.error(z.message)
    } finally {
      he(l, !1)
    }
  }, J8 = De('<span class="loading loading-spinner center-absolute absolute"></span>'), Q8 = De('<div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><!></div> <p class="mt-2 text-center text-2xl font-bold sm:text-3xl"> </p> <!> <div class="relative mt-4 flex justify-center gap-3"><button class="btn btn-circle">-</button> <input class="input number-input max-w-16 text-center font-bold opacity-80" type="number" min="1"/> <button class="btn btn-circle">+</button> <!></div> <div><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <!> <span class="text-sm">Droplets</span></button></div></div>');

function jg(y, l) {
  kr(l, !0);
  let _ = It(l, "amount", 15, 1);
  const T = vt(() => _() * l.unitPrice),
    z = vt(() => Math.floor(l.userDroplets / l.unitPrice));
  let F = _t(!1);
  $r(() => {
    _() < 0 && _(0)
  });
  var C = Q8(),
    o = E(C),
    K = E(o);
  Qi(K, () => l.icon ?? kn), A(o);
  var G = $(o, 2),
    ie = E(G, !0);
  A(G);
  var de = $(G, 2);
  {
    var fe = qe => {
      var pt = G8(),
        at = E(pt, !0);
      A(pt), lt(() => Te(at, l.subtitle)), H(qe, pt)
    };
    et(de, qe => {
      l.subtitle && qe(fe)
    })
  }
  var W = $(de, 2),
    le = E(W);
  le.__click = [H8, _];
  var Ce = $(le, 2);
  $a(Ce);
  var Me = $(Ce, 2);
  Me.__click = [W8, _];
  var Le = $(Me, 2);
  {
    var $e = qe => {
      var pt = K8();
      pt.__click = [X8, _, z], H(qe, pt)
    };
    et(Le, qe => {
      _() < b(z) && qe($e)
    })
  }
  A(W);
  var Oe = $(W, 2);
  let Ve;
  var ct = E(Oe);
  ct.__click = [Y8, F, l, _];
  var nt = E(ct);
  {
    var Ye = qe => {
      var pt = J8();
      H(qe, pt)
    };
    et(nt, qe => {
      b(F) && qe(Ye)
    })
  }
  var dt = $(nt, 2);
  qd(dt, {
    class: "size-4"
  });
  var rt = $(dt);
  mi(), A(ct), A(Oe), A(C), lt((qe, pt, at, ht) => {
    Te(ie, qe), Me.disabled = _() >= b(z), Br(Oe, "data-tip", pt), Ve = Vr(Oe, 1, "", null, Ve, at), ct.disabled = l.userDroplets < b(T) || b(F) || !_(), Te(rt, ` ${ht??""} `)
  }, [() => l.title(_()), () => $d(), () => ({
    tooltip: l.userDroplets < b(T)
  }), () => b(T).toLocaleString("en-US")]), jd(Ce, _), H(y, C), Er()
}
en(["click"]);
var ez = wr('<svg><path d="M346-140 100-386q-10-10-15-22t-5-25q0-13 5-25t15-22l230-229-106-106 62-65 400 400q10 10 14.5 22t4.5 25q0 13-4.5 25T686-386L440-140q-10 10-22 15t-25 5q-13 0-25-5t-22-15Zm47-506L179-432h428L393-646Zm399 526q-36 0-61-25.5T706-208q0-27 13.5-51t30.5-47l42-54 44 54q16 23 30 47t14 51q0 37-26 62.5T792-120Z"></path></svg>');

function tz(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = ez();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var rz = wr('<svg><path d="M280-80q-33 0-56.5-23.5T200-160q0-33 23.5-56.5T280-240q33 0 56.5 23.5T360-160q0 33-23.5 56.5T280-80Zm400 0q-33 0-56.5-23.5T600-160q0-33 23.5-56.5T680-240q33 0 56.5 23.5T760-160q0 33-23.5 56.5T680-80ZM246-720l96 200h280l110-200H246Zm-38-80h590q23 0 35 20.5t1 41.5L692-482q-11 20-29.5 31T622-440H324l-44 80h480v80H280q-45 0-68-39.5t-2-78.5l54-98-144-304H40v-80h130l38 80Zm134 280h280-280Z"></path></svg>');

function Uv(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = rz();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var iz = wr('<svg><path d="m700-300-57-56 84-84H120v-80h607l-83-84 57-56 179 180-180 180Z"></path></svg>');

function nz(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = iz();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var az = wr('<svg><path d="M280-160v-80h400v80H280Zm160-160v-327L336-544l-56-56 200-200 200 200-56 56-104-103v327h-80Z"></path></svg>');

function sz(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = az();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var oz = De('<div><section class="not-stuck:border-transparent stuck:border-base-content/10 bg-base-100/70 sticky top-0 z-10 border-b px-6 pb-4 pt-6 backdrop-blur-sm"><div class="relative flex items-center gap-1"><!> <h3 class="text-3xl font-bold"> </h3> <div class="ml-auto mr-4"><!></div> <form method="dialog" class="absolute -right-4 -top-4"><button class="btn btn-sm btn-circle btn-ghost">✕</button></form></div></section> <div class="flex flex-col gap-6 px-6 pb-6"><section><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <p class="text-base-content/80 text-sm"> </p> <div class="mt-3 grid gap-3 sm:grid-cols-2"><!> <!></div></section> <section><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <div class="mt-3"><div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><div class="relative flex size-52 items-center justify-center"><div class="scale-[3]"><!></div></div></div> <p class="mt-2 text-center text-2xl font-bold sm:text-3xl"> </p> <p class="mt-1 text-center text-sm"> </p> <div><a href="/profile-picture"><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <span class="text-sm">Droplets</span></button></a></div></div></div></section> <section><!></section></div></div>'),
  lz = De('<span class="center-absolute absolute"><!></span>'),
  cz = De('<dialog class="modal"><div class="modal-box max-h-11/12 w-11/12 max-w-4xl p-0"><!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog> <dialog class="modal"><div class="modal-box w-max overflow-hidden"><div class="flex flex-col items-center gap-6 px-4"><h2 class="text-lg font-semibold"> </h2> <div class="flex items-center gap-2 text-3xl sm:text-5xl"><span class="text-base-content/80 flex items-center gap-2"> <span class="text-primary text-3xl font-semibold max-sm:hidden"> </span></span> <span><!></span> <span class="text-primary flex font-bold"> </span></div> <form method="dialog"><button class="btn btn-primary btn-lg relative"> <!></button></form></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>', 1);

function uz(y, l) {
  kr(l, !0);
  let _ = It(l, "open", 15),
    T = _t(void 0),
    z = _t(En({
      name: Sg(),
      prev: 1e3,
      new: 1e5
    }));
  Ii(() => {
    const Be = Ke => {
      Ke.key === "Escape" && _(!1)
    };
    return document.addEventListener("keydown", Be), () => document.removeEventListener("keydown", Be)
  });
  const F = {
      id: 70,
      product: jn.products[70]
    },
    C = {
      id: 80,
      product: jn.products[80]
    },
    o = {
      product: jn.products[120]
    };
  var K = cz(),
    G = Et(K),
    ie = E(G),
    de = E(ie);
  {
    var fe = Be => {
      var Ke = oz(),
        tt = E(Ke),
        ot = E(tt),
        ft = E(ot);
      Uv(ft, {
        class: "size-8"
      });
      var Bt = $(ft, 2),
        At = E(Bt, !0);
      A(Bt);
      var cr = $(Bt, 2),
        Mt = E(cr);
      {
        let We = vt(() => {
          var ve;
          return ((ve = Ot.data) == null ? void 0 : ve.droplets) ?? 0
        });
        Kg(Mt, {
          get value() {
            return b(We)
          }
        })
      }
      A(cr), mi(2), A(ot), A(tt), qn(tt, () => z8);
      var yt = $(tt, 2),
        St = E(yt),
        jt = E(St),
        Lt = E(jt);
      tz(Lt, {
        class: "size-5.5",
        filled: !0
      });
      var Gt = $(Lt, 2),
        gr = E(Gt, !0);
      A(Gt), A(jt);
      var ur = $(jt, 2),
        Qt = E(ur, !0);
      A(ur);
      var er = $(ur, 2),
        Dt = E(er);
      {
        const We = Pt => {
          sz(Pt, {
            class: "text-primary size-26"
          })
        };
        let ve = vt(() => Cb());
        jg(Dt, {
          get productId() {
            return F.id
          },
          title: Pt => bb({
            amount: F.product.items[0].amount * Pt
          }),
          get subtitle() {
            return b(ve)
          },
          get unitPrice() {
            return F.product.price
          },
          get userDroplets() {
            return Ot.data.droplets
          },
          onpurchasecompleted: async Pt => {
            var Ht, or, ri, ti, Wr;
            const Xt = (or = (Ht = Ot.data) == null ? void 0 : Ht.charges) == null ? void 0 : or.max;
            await Ot.refresh();
            const Nt = (ti = (ri = Ot.data) == null ? void 0 : ri.charges) == null ? void 0 : ti.max;
            Xt !== void 0 && Nt !== void 0 && (he(z, {
              name: Sg(),
              prev: Xt,
              new: Nt
            }, !0), (Wr = b(T)) == null || Wr.show())
          },
          icon: We,
          $$slots: {
            icon: !0
          }
        })
      }
      var Ir = $(Dt, 2);
      {
        const We = Pt => {
          qv(Pt, {
            class: "text-primary my-3 size-20"
          })
        };
        let ve = vt(() => db());
        jg(Ir, {
          get productId() {
            return C.id
          },
          title: Pt => _5({
            amount: C.product.items[0].amount * Pt
          }),
          get subtitle() {
            return b(ve)
          },
          get unitPrice() {
            return C.product.price
          },
          get userDroplets() {
            return Ot.data.droplets
          },
          onpurchasecompleted: async Pt => {
            var Nt, Ht, or;
            const Xt = (Ht = (Nt = Ot.data) == null ? void 0 : Nt.charges) == null ? void 0 : Ht.count;
            await Ot.refresh(), Xt !== void 0 && (he(z, {
              name: p5(),
              prev: Math.floor(Xt),
              new: Math.floor(Xt + C.product.items[0].amount * Pt)
            }, !0), (or = b(T)) == null || or.show())
          },
          icon: We,
          $$slots: {
            icon: !0
          }
        })
      }
      A(er), A(St);
      var Tr = $(St, 2),
        Dr = E(Tr),
        Fr = E(Dr);
      Gd(Fr, {
        class: "size-5.5",
        filled: !0
      });
      var dr = $(Fr, 2),
        Or = E(dr, !0);
      A(dr), A(Dr);
      var zr = $(Dr, 2),
        tr = E(zr),
        br = E(tr),
        $t = E(br),
        yr = E($t),
        jr = E(yr);
      Yg(jr, {
        get userId() {
          return Ot.data.id
        },
        get level() {
          return Ot.data.level
        },
        get pictureUrl() {
          return Ot.data.picture
        }
      }), A(yr), A($t), A(br);
      var ye = $(br, 2),
        j = E(ye, !0);
      A(ye);
      var V = $(ye, 2),
        X = E(V, !0);
      A(V);
      var se = $(V, 2);
      let we;
      var Ae = E(se),
        Ze = E(Ae),
        Se = E(Ze);
      qd(Se, {
        class: "size-4"
      });
      var Ne = $(Se);
      mi(), A(Ze), A(Ae), A(se), A(tr), A(zr), A(Tr);
      var ze = $(Tr, 2),
        Ie = E(ze);
      U8(Ie, {}), A(ze), A(yt), A(Ke), lt((We, ve, Pt, Xt, Nt, Ht, or, ri, ti) => {
        Te(At, We), Te(gr, ve), Te(Qt, Pt), Te(Or, Xt), Te(j, Nt), Te(X, Ht), Br(se, "data-tip", or), we = Vr(se, 1, "", null, we, ri), Ze.disabled = Ot.data.droplets < o.product.price, Te(Ne, ` ${ti??""} `)
      }, [() => rv(), () => mb(), () => vb(), () => b2(), () => Ib(), () => kb(), () => $d(), () => ({
        tooltip: Ot.data.droplets < o.product.price
      }), () => o.product.price.toLocaleString("en-US")]), An(2, Ke, () => Kn), H(Be, Ke)
    };
    et(de, Be => {
      Ot.data && _() && Be(fe)
    })
  }
  A(ie);
  var W = $(ie, 2),
    le = E(W),
    Ce = E(le, !0);
  A(le), A(W), A(G), qn(G, () => Be => {
    $r(() => {
      _() ? Be.show() : Be.close()
    })
  });
  var Me = $(G, 2),
    Le = E(Me),
    $e = E(Le),
    Oe = E($e),
    Ve = E(Oe, !0);
  A(Oe);
  var ct = $(Oe, 2),
    nt = E(ct),
    Ye = E(nt),
    dt = $(Ye),
    rt = E(dt);
  A(dt), A(nt);
  var qe = $(nt, 2),
    pt = E(qe);
  nz(pt, {
    class: "size-5"
  }), A(qe);
  var at = $(qe, 2),
    ht = E(at, !0);
  A(at), A(ct);
  var Re = $(ct, 2),
    xt = E(Re),
    Q = E(xt),
    re = $(Q);
  Iu(re, () => b(z).new, Be => {
    var Ke = lz(),
      tt = E(Ke);
    gm(tt, {}), A(Ke), H(Be, Ke)
  }), A(xt), A(Re), A($e), A(Le);
  var xe = $(Le, 2),
    ce = E(xe),
    Ee = E(ce, !0);
  A(ce), A(xe), A(Me), Ss(Me, Be => he(T, Be), () => b(T)), lt((Be, Ke, tt) => {
    Te(Ce, Be), Te(Ve, b(z).name), Te(Ye, `${b(z).prev??""} `), Te(rt, `(+${b(z).new-b(z).prev})`), Te(ht, b(z).new), Te(Q, `${Ke??""} `), Te(Ee, tt)
  }, [() => ec(), () => ec(), () => ec()]), bn("close", G, () => _(!1)), H(y, K), Er()
}
var hz = wr('<svg><path d="M382-240 154-468l57-57 171 171 367-367 57 57-424 424Z"></path></svg>');

function dz(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = hz();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var pz = wr('<svg><path d="M480-680q-33 0-56.5-23.5T400-760q0-33 23.5-56.5T480-840q33 0 56.5 23.5T560-760q0 33-23.5 56.5T480-680Zm-60 560v-480h120v480H420Z"></path></svg>');

function fz(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = pz();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var mz = wr('<svg><path d="M440-40v-80q-125-14-214.5-103.5T122-438H42v-80h80q14-125 103.5-214.5T440-836v-80h80v80q125 14 214.5 103.5T838-518h80v80h-80q-14 125-103.5 214.5T520-120v80h-80Zm40-158q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Z"></path></svg>');

function _z(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = mz();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var gz = wr('<svg><path d="M440-42v-80q-125-14-214.5-103.5T122-440H42v-80h80q14-125 103.5-214.5T440-838v-80h80v80q125 14 214.5 103.5T838-520h80v80h-80q-14 125-103.5 214.5T520-122v80h-80Zm40-158q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Zm0-120q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47Z"></path></svg>');

function vz(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = gz();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var yz = wr('<svg><path d="M380-720v-98L142-580h98v60H40v-200h60v98l238-238h-98v-60h200v200h-60ZM593-40q-24 0-46-9t-39-26L304-280l30-31q16-16 37.5-21.5t42.5.5l66 19v-327q0-17 11.5-28.5T520-680q17 0 28.5 11.5T560-640v433l-97-27 102 102q5 5 12.5 8.5T593-120h167q33 0 56.5-23.5T840-200v-160q0-17 11.5-28.5T880-400q17 0 28.5 11.5T920-360v160q0 66-47 113T760-40H593Zm7-280v-160q0-17 11.5-28.5T640-520q17 0 28.5 11.5T680-480v160h-80Zm120 0v-120q0-17 11.5-28.5T760-480q17 0 28.5 11.5T800-440v120h-80Zm-20 80Z"></path></svg>');

function xz(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = yz();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var bz = wr('<svg><path d="M360-840v-80h240v80H360Zm80 440h80v-240h-80v240Zm40 320q-74 0-139.5-28.5T226-186q-49-49-77.5-114.5T120-440q0-74 28.5-139.5T226-694q49-49 114.5-77.5T480-800q62 0 119 20t107 58l56-56 56 56-56 56q38 50 58 107t20 119q0 74-28.5 139.5T734-186q-49 49-114.5 77.5T480-80Zm0-80q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Zm0-280Z"></path></svg>');

function wz(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = bz();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var Tz = wr('<svg><path d="M280-200v-80h284q63 0 109.5-40T720-420q0-60-46.5-100T564-560H312l104 104-56 56-200-200 200-200 56 56-104 104h252q97 0 166.5 63T800-420q0 94-69.5 157T564-200H280Z"></path></svg>');

function Cz(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = Tz();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}
var Sz = wr('<svg><path d="m644-428-58-58q9-47-27-88t-93-32l-58-58q17-8 34.5-12t37.5-4q75 0 127.5 52.5T660-500q0 20-4 37.5T644-428Zm128 126-58-56q38-29 67.5-63.5T832-500q-50-101-143.5-160.5T480-720q-29 0-57 4t-55 12l-62-62q41-17 84-25.5t90-8.5q151 0 269 83.5T920-500q-23 59-60.5 109.5T772-302Zm20 246L624-222q-35 11-70.5 16.5T480-200q-151 0-269-83.5T40-500q21-53 53-98.5t73-81.5L56-792l56-56 736 736-56 56ZM222-624q-29 26-53 57t-41 67q50 101 143.5 160.5T480-280q20 0 39-2.5t39-5.5l-36-38q-11 3-21 4.5t-21 1.5q-75 0-127.5-52.5T300-500q0-11 1.5-21t4.5-21l-84-82Zm319 93Zm-151 75Z"></path></svg>');

function Pz(y, l) {
  let _ = Yt(l, ["$$slots", "$$events", "$$legacy"]);
  var T = Sz();
  Kt(T, () => ({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -960 960 960",
    fill: "currentColor",
    ..._
  })), H(y, T)
}

function xf(y) {
  const l = document.createElement("img");
  return l.src = y, new Promise((_, T) => {
    l.addEventListener("load", () => {
      _(l)
    }), l.addEventListener("error", z => {
      T(z)
    })
  })
}

function Iz(y) {
  const l = document.createElement("canvas");
  l.width = y.naturalWidth, l.height = y.naturalHeight;
  const _ = l.getContext("2d");
  return _ == null || _.drawImage(y, 0, 0), l
}

function Mz(y, l, _) {
  return y < l ? l : y > _ ? _ : y
}

function Az(y, l) {
  const _ = 10 ** l;
  return Math.round(y * _) / _
}
var kz = De('<meta property="og:title" content="Wplace - A massive real-time pixel art canvas on the world map!"/> <meta name="twitter:title" content="Wplace - A massive real-time pixel art canvas on the world map!"/> <meta name="robots" content="index, follow, max-image-preview:large"/> <meta name="color-scheme" content="light only"/>', 1),
  Ez = (y, l) => {
    he(l, !b(l))
  },
  zz = De("<button><!></button>"),
  Lz = async (y, l, _, T) => {
    var z;
    b(l) || he(l, await new Promise((F, C) => {
      navigator.geolocation.getCurrentPosition(o => {
        F(o)
      }, o => {
        C(o)
      })
    })), b(l) && (qa({
      lat: b(l).coords.latitude,
      lng: b(l).coords.longitude
    }, b(_)), (z = b(T)) == null || z.flyTo({
      center: {
        lat: b(l).coords.latitude,
        lng: b(l).coords.longitude
      },
      zoom: 16.5
    }))
  }, Dz = De('<div class="relative"><!> <span class="center-absolute absolute text-[10px] text-red-400">?</span></div>'), Rz = De('<button class="btn btn-lg btn-square sm:btn-xl z-30 shadow-md"><!></button>'), Bz = (y, l, _, T) => {
    var z;
    he(l, !0), b(_) && qa((z = b(_)) == null ? void 0 : z.getCenter(), b(T))
  }, Fz = De('<button class="btn btn-primary shadow-xl"> </button>'), Oz = De("<div><!></div>"), Nz = (y, l, _, T) => {
    var F;
    he(l, !0);
    const z = (F = b(_)) == null ? void 0 : F.getCenter();
    z && qa(z, b(T))
  }, jz = De('<button class="btn btn-square shadow-md"><!></button>'), qz = (y, l) => {
    he(l, !0)
  }, Vz = De('<button class="btn btn-square relative shadow-md"><!></button>'), Zz = (y, l) => {
    he(l, !0)
  }, $z = De('<button class="btn btn-square relative shadow-md"><!></button>'), Uz = De('<div class="flex flex-col items-center gap-3"><!> <!> <!> <!></div>'), Gz = (y, l) => {
    he(l, !b(l))
  }, Hz = De('<div class="flex flex-col gap-3"><button><!></button></div>'), Wz = De('<div class="z-100 absolute bottom-1 left-1/2 -translate-x-1/2"><!></div>'), Xz = (y, l) => {
    he(l, !0)
  }, Kz = De('<button class="btn btn-sm btn-circle"><!></button>'), Yz = (y, l) => {
    var _;
    (_ = b(l)) == null || _.zoomIn()
  }, Jz = (y, l) => {
    var _;
    (_ = b(l)) == null || _.zoomOut()
  }, Qz = De('<button class="btn btn-sm btn-circle"><!></button>'), eL = () => {
    window.location.replace(Va.url.origin)
  }, tL = De('<button class="btn btn-sm btn-circle not-pwa:hidden"><!></button>'), rL = (y, l) => {
    b(l) && Qo.goToPrev(b(l))
  }, iL = De('<button class="btn btn-sm btn-circle"><!></button>'), nL = De('<div class="btn btn-sm btn-error w-max cursor-auto text-nowrap text-xs sm:text-base"><!> </div>'), aL = (y, l, _) => {
    var T;
    (T = b(l)) == null || T.flyTo({
      center: b(l).getCenter(),
      zoom: _
    })
  }, sL = De('<button class="btn sm:btn-lg duration text-nowrap text-xs transition-opacity sm:text-base"><!> </button>'), oL = De("<span></span>"), lL = De('<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2 md:max-w-lg"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t pt-2 sm:mb-3 sm:shadow-xl"><!></div></div>'), cL = De('<div class="absolute bottom-0 left-0 z-50 w-full"><div class="rounded-t-box bg-base-100 border-base-300 w-full border-t py-3"><!></div></div>'), uL = (y, l) => {
    he(l, {
      name: "mainMenu"
    }, !0)
  }, hL = De('<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t pt-2 sm:mb-3 sm:shadow-xl"><div class="px-3 pb-2 pt-1"><div class="flex items-center justify-between"><span><!> </span> <button class="btn btn-circle btn-sm"><!></button></div> <div class="mt-1 flex items-center justify-center gap-4"><button class="btn btn-primary w-46"><!></button></div></div></div></div>'), dL = De('<div class="disable-pinch-zoom relative h-full overflow-hidden svelte-6wmtgk"><div id="map" class="h-screen w-screen cursor-default"></div> <div><div><!> <!></div></div> <!> <div><!> <div class="flex flex-col gap-1 max-sm:hidden"><button class="btn btn-sm btn-circle">+</button> <button class="btn btn-sm btn-circle">-</button></div> <div class="max-sm:hidden"><a href="https://www.twitch.tv/directory/category/wplace" class="btn btn-sm btn-circle" target="_blank" title="Livestreams"><!></a></div> <!> <!> <!></div> <div><!> <!></div> <div><!></div> <div><!></div> <div><!></div>  <!></div> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>', 1);

function FL(y, l) {
  kr(l, !0);
  const _ = xg,
    T = fx,
    z = new uc(T),
    F = _ - .4,
    C = mP(Va.url),
    o = C.season ?? yg,
    K = new Map;
  let G = _t(void 0),
    ie = _t(14.5),
    de = _t(!1);
  const fe = vt(() => {
    var bt;
    return ((bt = Ot.data) == null ? void 0 : bt.id) === 401
  });
  let W = _t(!1),
    le = _t(En(C.select && C.pos ? {
      name: "pixelSelected",
      latLon: [C.pos.lat, C.pos.lng]
    } : {
      name: "mainMenu"
    }));
  Ii(() => {
    Me().then(Zt => he(G, Zt));
    let bt = [0, 0];

    function Rt(Zt) {
      var hi;
      if (b(G) && b(ie) > _ + 1) {
        const {
          lat: gi,
          lng: Ei
        } = b(G).unproject([Zt.clientX, Zt.clientY]), si = z.latLonToPixels(gi, Ei, _), vr = Math.floor(si[0]), Xi = Math.floor(si[1]);
        if (bt[0] !== vr || bt[1] !== Xi) {
          const Jt = z.latLonToPixelBoundsLatLon(gi, Ei, _),
            Vt = om(Jt, !0);
          (hi = b(G).getSource(Oe)) == null || hi.setCoordinates(Vt), bt = [vr, Xi]
        }
      }
    }
    return window.addEventListener("mousemove", Rt), () => {
      var Zt;
      (Zt = b(G)) == null || Zt.remove(), window.removeEventListener("mousemove", Rt), Ce && clearInterval(Ce), bf()
    }
  });
  let Ce;
  async function Me() {
    const bt = C.pos ? {
      ...C.pos,
      zoom: b(ie)
    } : await aP();
    C.zoom !== void 0 && (bt.zoom = C.zoom);
    const Rt = await new Promise(si => {
      const vr = new bd.Map({
        style: "https://maps.wplace.live/styles/liberty",
        center: bt,
        zoom: bt.zoom,
        container: "map",
        dragRotate: !1,
        doubleClickZoom: !1,
        pitch: 0,
        maxPitch: 0,
        attributionControl: !1
      });
      vr.touchZoomRotate.disableRotation(), vr.on("style.load", () => {
        vr == null || vr.setLayoutProperty("poi_transit", "visibility", "none"), vr == null || vr.setLayoutProperty("poi_r20", "visibility", "none"), vr == null || vr.setLayoutProperty("poi_r7", "visibility", "none"), vr == null || vr.setLayoutProperty("poi_r1", "visibility", "none"), vr == null || vr.setLayoutProperty("building", "visibility", "none"), vr == null || vr.setLayoutProperty("building-3d", "visibility", "none"), vr == null || vr.setLayoutProperty("landuse_pitch", "visibility", "none"), vr == null || vr.setLayoutProperty("landuse_hospital", "visibility", "none"), vr == null || vr.setLayoutProperty("landuse_school", "visibility", "none"), vr == null || vr.setLayoutProperty("landuse_residential", "visibility", "none"), vr == null || vr.setLayoutProperty("waterway_tunnel", "visibility", "none"), vr == null || vr.setFilter("water", ["all", ["!=", "brunnel", "tunnel"],
          ["!=", "class", "swimming_pool"]
        ]), si(vr)
      })
    });
    $e(Rt), Ye();
    const Zt = jn.refreshIntervalMs;

    function hi() {
      let si = b(ie) > _ + 1.5 ? Zt : 2.5 * Zt;
      try {
        document.visibilityState === "visible" && $e(Rt)
      } finally {
        setTimeout(hi, si)
      }
    }
    Ce = setTimeout(hi, Zt);
    let gi = b(ie);
    Rt.on("zoom", () => {
      he(ie, Rt.getZoom(), !0);
      const si = Az(b(ie), 1);
      si != gi && (b(Re) && b(Re).setOpacity(xt(gi)), gi = si)
    });
    let Ei = "default";
    return Rt.on("dragstart", () => {
      const si = Rt.getCanvas();
      Ei = si.style.cursor, si.style.cursor = "move"
    }), Rt.on("dragend", () => {
      Rt.getCanvas().style.cursor = Ei
    }), Rt.on("mouseout", () => {
      dt()
    }), Rt.on("click", async si => {
      var Ur;
      const vr = si.lngLat.lat,
        Xi = si.lngLat.lng,
        Jt = [vr, Xi];
      if (b(le).name === "paintingPixel") return;
      if (b(le).name === "selectHq") {
        b(le).hq = Jt, (Ur = b(Q)) == null || Ur.clearAndPlace(Jt);
        return
      }
      const Vt = Rt.getZoom();
      if (Vt < F) {
        Zr.info(HC());
        return
      }
      qa({
        lat: vr,
        lng: Xi
      }, Vt), he(le, {
        name: "pixelSelected",
        latLon: Jt
      }, !0)
    }), Rt
  }
  const Le = "pixel-art-layer";

  function $e(bt) {
    const Rt = window.innerWidth,
      Zt = `${mx}/s${yg}/tiles/{x}/{y}.png`;
    if (K.clear(), !bt.style) return;
    bt.getSource(Le) ? bt.refreshTiles(Le) : bt.addSource(Le, {
      type: "raster",
      tiles: [Zt],
      minzoom: _,
      maxzoom: _,
      tileSize: Rt > 640 ? 550 : 400
    }), bt.getLayer(Le) || bt.addLayer({
      id: Le,
      type: "raster",
      source: Le,
      paint: {
        "raster-resampling": "nearest",
        "raster-opacity": b(qe)
      }
    })
  }
  const Oe = "pixel-hover",
    Ve = 1e-5,
    ct = [
      [0, 0],
      [Ve, 0],
      [Ve, -Ve],
      [0, -Ve]
    ],
    nt = .4;
  async function Ye() {
    var bt, Rt, Zt, hi;
    if (!((bt = b(G)) != null && bt.getSource(Oe))) {
      const gi = Iz(await xf(iP));
      (Rt = b(G)) == null || Rt.addSource(Oe, {
        type: "canvas",
        canvas: gi,
        coordinates: ct
      })
    }(Zt = b(G)) != null && Zt.getLayer(Oe) || (hi = b(G)) == null || hi.addLayer({
      id: Oe,
      type: "raster",
      source: Oe,
      paint: {
        "raster-resampling": "nearest",
        "raster-opacity": nt
      }
    })
  }

  function dt() {
    var bt, Rt;
    (Rt = (bt = b(G)) == null ? void 0 : bt.getSource(Oe)) == null || Rt.setCoordinates(ct)
  }
  let rt = _t(En(C.opaque ?? !0)),
    qe = vt(() => b(rt) ? 1 : .3);
  $r(() => {
    var bt;
    (bt = b(G)) != null && bt.getLayer(Le) && b(G).setPaintProperty(Le, "raster-opacity", b(qe))
  });
  let pt = _t(void 0),
    at = _t(void 0),
    ht = _t(void 0);
  Ii(() => (navigator.permissions.query({
    name: "geolocation"
  }).then(bt => {
    bt.state === "granted" && he(ht, navigator.geolocation.watchPosition(Rt => {
      he(pt, Rt)
    }, Rt => {
      he(at, Rt)
    }, {
      enableHighAccuracy: !1,
      maximumAge: 1e3,
      timeout: 6e3
    }), !0)
  }), () => {
    b(ht) && navigator.geolocation.clearWatch(b(ht))
  }));
  let Re = _t(void 0);
  hc(() => [b(pt), b(G)], () => {
    var bt, Rt;
    if (b(pt) && b(G)) {
      const Zt = {
          lat: b(pt).coords.latitude,
          lng: b(pt).coords.longitude
        },
        hi = xt(b(ie));
      if (!b(Re)) {
        const gi = document.createElement("div");
        gi.classList.add("maplibregl-user-location-dot"), gi.classList.add("cursor-auto"), he(Re, new bd.Marker({
          element: gi,
          opacity: hi
        }).setLngLat(Zt).addTo(b(G)))
      }(Rt = (bt = b(Re)) == null ? void 0 : bt.setLngLat(Zt)) == null || Rt.setOpacity(hi)
    }
  });

  function xt(bt) {
    return bt < _ ? "1.0" : Mz((bt - _) * .2, .5, 1).toFixed(2)
  }
  let Q = _t(void 0);
  $r(() => {
    var bt;
    b(G) && ((bt = so(() => b(Q))) == null || bt.clear(), xf(Pg).then(Rt => {
      he(Q, new Mg({
        id: "select-crosshair",
        map: b(G),
        tileSize: T,
        zoom: _,
        img: Rt,
        markerFn: () => {
          const Zt = new bd.Marker({
            color: "#0069ff"
          });
          return Zt.addClassName("z-20"), Zt
        }
      }))
    }))
  });
  let re = _t(void 0);
  $r(() => {
    var bt;
    b(G) && ((bt = so(() => b(Q))) == null || bt.clear(), xf(Pg).then(Rt => {
      he(re, new Mg({
        id: "paint-crosshair",
        map: b(G),
        tileSize: T,
        zoom: _,
        img: Rt
      }))
    }))
  });
  let xe = _t(!1),
    ce = _t(!1),
    Ee = _t(!1),
    Be = _t(!!C.newUser),
    Ke = _t(!1),
    tt = _t(!!C.alliance),
    ot = _t(!1);
  const ft = "void-message-2";
  let Bt = _t(!1);
  $r(() => {
    const bt = localStorage.getItem(ft);
    Ot.data && !bt && (he(Bt, !0), localStorage.setItem(ft, "true"))
  });
  let At = _t(!1),
    cr = _t(En(Va.url)),
    Mt = _t(En({
      cityId: 0,
      countryId: 1,
      id: 0,
      name: "None",
      number: 1
    })),
    yt = _t(!1);
  const St = "view-rules";
  let jt = !1;
  $r(() => {
    Ot.data && (!jt && Ot.data.pixelsPainted > 1 && (localStorage.getItem(St) || (he(yt, !0), localStorage.setItem(St, "true"))), jt = !0)
  });
  let Lt = _t(!1);
  $r(() => {
    var bt;
    he(Lt, !!((bt = Ot.data) != null && bt.needsPhoneVerification))
  });
  let Gt = _t([]),
    gr = vt(() => b(ie) < F ? "1.0" : b(ie) < F + 2 ? "0.5" : "0.3");
  $r(() => {
    var Rt;
    const bt = (Rt = Ot.data) == null ? void 0 : Rt.favoriteLocations;
    if (bt && b(G)) {
      for (const Zt of so(() => b(Gt))) Zt.remove();
      he(Gt, bt.map(Zt => {
        const hi = document.createElement("div");
        hi.classList.add("text-yellow-400"), hi.classList.add("cursor-pointer"), hi.classList.add("z-10"), hi.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor">
					<path fill="#000a" d="m183-51 79-338L-1-617l346-29 135-319 135 319 346 29-263 228 79 338-297-180L183-51Z"/>
					<path d="m293-203.08 49.62-212.54-164.93-142.84 217.23-18.85L480-777.69l85.08 200.38 217.23 18.85-164.93 142.84L667-203.08 480-315.92 293-203.08Z"/>
				</svg>`;
        const gi = {
          lat: Zt.latitude,
          lng: Zt.longitude
        };
        return hi.addEventListener("click", si => {
          si.stopPropagation(), ur([Zt.latitude, Zt.longitude])
        }), new bd.Marker({
          element: hi,
          opacity: b(gr)
        }).setLngLat(gi).addTo(b(G))
      }))
    }
  });

  function ur(bt) {
    var Zt;
    const Rt = {
      lat: bt[0],
      lng: bt[1]
    };
    (Zt = b(G)) == null || Zt.flyTo({
      center: Rt,
      zoom: Math.max(b(ie), 15)
    }), qa(Rt, b(ie)), he(le, {
      name: "pixelSelected",
      latLon: [Rt.lat, Rt.lng]
    }, !0)
  }
  $r(() => {
    if (b(le).name === "paintingPixel")
      for (const bt of b(Gt)) bt.addClassName("hidden");
    else
      for (const bt of b(Gt)) bt.removeClassName("hidden"), bt.setOpacity(b(gr))
  });
  let Qt = Number.MAX_VALUE;
  $r(() => {
    if (Ot.charges !== void 0 && Ot.data) {
      const bt = Ot.data.charges.max,
        Rt = Ot.charges;
      Qt < bt && Rt >= bt && ha.notification1.play(), Qt = Ot.charges
    }
  });
  let er = _t(!1),
    Dt = Date.now();
  Ii(() => {
    const bt = fP(),
      Rt = () => {
        var hi;
        if (!document.hidden && Date.now() - Dt > 30 * Yl.min) {
          if (bt) {
            const Ei = (hi = b(G)) == null ? void 0 : hi.getCenter();
            Ei && qa(Ei, b(ie)), window.location.replace(Va.url.origin)
          } else Ot.refresh();
          Dt = Date.now()
        }
      };
    return document.addEventListener("visibilitychange", Rt), () => document.removeEventListener("visibilitychange", Rt)
  }), Ii(() => {
    function bt() {
      ci.online = !0
    }
    window.addEventListener("online", bt);

    function Rt() {
      ci.online = !1
    }
    return window.addEventListener("offline", Rt), () => {
      window.removeEventListener("online", bt), window.removeEventListener("offline", Rt)
    }
  }), $r(() => {
    if (!ci.online) {
      const bt = setInterval(() => {
        ci.health().then(() => {
          ci.online = !0, !Ot.data && !Ot.loading && Ot.refresh()
        })
      }, 5e3);
      return () => {
        clearInterval(bt)
      }
    }
  }), Ii(() => {
    function bt(Rt) {
      Rt.data.type && b(G) && $e(b(G))
    }
    return navigator.serviceWorker.addEventListener("message", bt), () => {
      navigator.serviceWorker.removeEventListener("message", bt)
    }
  });
  var Ir = dL();
  cx(bt => {
    var Rt = kz();
    ux.title = "Wplace - Paint the world", mi(6), H(bt, Rt)
  });
  var Tr = Et(Ir);
  {
    const bt = Jt => {
        var Vt = zz();
        Vt.__click = [Ez, rt];
        var Ur = E(Vt);
        {
          let Kr = vt(() => !b(rt));
          Vv(Ur, {
            class: "size-5",
            get filled() {
              return b(Kr)
            }
          })
        }
        A(Vt), lt(Kr => {
          Br(Vt, "title", Kr), Vr(Vt, 1, Xo({
            "btn btn-lg btn-square sm:btn-xl z-30 shadow-md": !0,
            "text-base-content/80": b(rt),
            "btn-primary btn-soft": !b(rt)
          }))
        }, [() => nv()]), H(Jt, Vt)
      },
      Rt = Jt => {
        var Vt = Rz();
        Vt.__click = [Lz, pt, ie, G];
        var Ur = E(Vt);
        {
          var Kr = Yr => {
              vz(Yr, {
                class: "size-5.5 fill-blue-800"
              })
            },
            bi = Yr => {
              var wi = Dz(),
                Fi = E(wi);
              _z(Fi, {
                class: "size-5.5 fill-red-400"
              }), mi(2), A(wi), H(Yr, wi)
            };
          et(Ur, Yr => {
            b(pt) ? Yr(Kr) : Yr(bi, !1)
          })
        }
        A(Vt), lt(Yr => Br(Vt, "title", Yr), [() => I1()]), H(Jt, Vt)
      };
    var Dr = $(E(Tr), 2);
    let Zt;
    var Fr = E(Dr);
    let hi;
    var dr = E(Fr);
    {
      var Or = Jt => {
          var Vt = Fz();
          Vt.__click = [Bz, xe, G, ie];
          var Ur = E(Vt, !0);
          A(Vt), lt(Kr => Te(Ur, Kr), [() => Gx()]), H(Jt, Vt)
        },
        zr = Jt => {
          var Vt = sr(),
            Ur = Et(Vt);
          {
            var Kr = bi => {
              var Yr = Oz(),
                wi = E(Yr);
              ZE(wi, {
                get user() {
                  return Ot
                },
                onlogout: () => {
                  he(le, {
                    name: "mainMenu"
                  }, !0)
                },
                onclickleaderboard: () => {
                  he(Ee, !0)
                },
                onclickshop: () => {
                  var Ci;
                  he(ce, !0);
                  const Fi = (Ci = b(G)) == null ? void 0 : Ci.getCenter();
                  Fi && qa(Fi, b(ie))
                }
              }), A(Yr), An(3, Yr, () => Kn, () => ({
                duration: 150
              })), H(bi, Yr)
            };
            et(Ur, bi => {
              Ot.data && b(G) && b(le).name !== "paintingPixel" && bi(Kr)
            }, !0)
          }
          H(Jt, Vt)
        };
      et(dr, Jt => {
        !Ot.loading && !Ot.data ? Jt(Or) : Jt(zr, !1)
      })
    }
    var tr = $(dr, 2);
    {
      var br = Jt => {
          var Vt = Uz(),
            Ur = E(Vt);
          {
            var Kr = Ci => {
              vf(Ci, {
                key: "shop-profile-picture",
                children: (zi, Li) => {
                  var vi = jz();
                  vi.__click = [Nz, ce, G, ie];
                  var an = E(vi);
                  Uv(an, {
                    class: "size-5"
                  }), A(vi), lt(Jn => Br(vi, "title", Jn), [() => rv()]), H(zi, vi)
                },
                $$slots: {
                  default: !0
                }
              })
            };
            et(Ur, Ci => {
              Ot.data && Ci(Kr)
            })
          }
          var bi = $(Ur, 2);
          {
            var Yr = Ci => {
              var zi = Vz();
              zi.__click = [qz, tt];
              var Li = E(zi);
              Hd(Li, {
                class: "size-5"
              }), A(zi), lt(vi => Br(zi, "title", vi), [() => Zd()]), H(Ci, zi)
            };
            et(bi, Ci => {
              Ot.data && Ci(Yr)
            })
          }
          var wi = $(bi, 2);
          KE(wi, {
            get map() {
              return b(G)
            },
            get season() {
              return o
            }
          });
          var Fi = $(wi, 2);
          vf(Fi, {
            key: "region-leaderboard",
            children: (Ci, zi) => {
              var Li = $z();
              Li.__click = [Zz, Ee];
              var vi = E(Li);
              Ov(vi, {
                class: "size-5"
              }), A(Li), lt(an => Br(Li, "title", an), [() => tm()]), H(Ci, Li)
            },
            $$slots: {
              default: !0
            }
          }), A(Vt), An(3, Vt, () => Kn, () => ({
            duration: 150
          })), H(Jt, Vt)
        },
        $t = Jt => {
          var Vt = sr(),
            Ur = Et(Vt);
          {
            var Kr = bi => {
              var Yr = Hz(),
                wi = E(Yr);
              let Fi;
              wi.__click = [Gz, de];
              var Ci = E(wi);
              {
                var zi = vi => {
                    Wf(vi, {
                      class: "size-5"
                    })
                  },
                  Li = vi => {
                    Ld(vi, {
                      class: "size-5"
                    })
                  };
                et(Ci, vi => {
                  b(de) ? vi(zi) : vi(Li, !1)
                })
              }
              A(wi), A(Yr), lt((vi, an) => {
                Br(wi, "title", vi), Fi = Vr(wi, 1, "btn btn-square not-touchscreen:hidden shadow-md", null, Fi, an)
              }, [() => b(de) ? t1() : n1(), () => ({
                "btn-primary": b(de)
              })]), An(1, Yr, () => Kn, () => ({
                delay: 150,
                duration: 150
              })), H(bi, Yr)
            };
            et(Ur, bi => {
              b(G) && b(le).name === "paintingPixel" && bi(Kr)
            }, !0)
          }
          H(Jt, Vt)
        };
      et(tr, Jt => {
        b(G) && b(le).name !== "paintingPixel" ? Jt(br) : Jt($t, !1)
      })
    }
    A(Fr), A(Dr);
    var yr = $(Dr, 2);
    {
      var jr = Jt => {
        var Vt = Wz(),
          Ur = E(Vt);
        {
          let Kr = vt(() => _x.trim());
          zx(Ur, {
            get siteKey() {
              return b(Kr)
            },
            refreshExpired: "auto",
            appearance: "interaction-only",
            callback: bi => {
              aa.captcha = {
                token: bi,
                time: Date.now()
              }
            }
          })
        }
        A(Vt), An(2, Vt, () => Kn, () => ({
          duration: 300
        })), H(Jt, Vt)
      };
      et(yr, Jt => {
        (!aa.captcha || aa.now - aa.captcha.time > 180 * 1e3) && Jt(jr)
      })
    }
    var ye = $(yr, 2);
    let gi;
    var j = E(ye);
    {
      var V = Jt => {
        vf(Jt, {
          key: "info",
          children: (Vt, Ur) => {
            var Kr = Kz();
            Kr.__click = [Xz, Ke];
            var bi = E(Kr);
            fz(bi, {
              class: "size-3.5"
            }), A(Kr), lt(Yr => Br(Kr, "title", Yr), [() => o1()]), H(Vt, Kr)
          },
          $$slots: {
            default: !0
          }
        })
      };
      et(j, Jt => {
        b(le).name !== "paintingPixel" && Jt(V)
      })
    }
    var X = $(j, 2),
      se = E(X);
    se.__click = [Yz, G];
    var we = $(se, 2);
    we.__click = [Jz, G], A(X);
    var Ae = $(X, 2),
      Ze = E(Ae),
      Se = E(Ze);
    ev(Se, {
      class: "size-4"
    }), A(Ze), A(Ae);
    var Ne = $(Ae, 2);
    {
      var ze = Jt => {
        var Vt = Qz(),
          Ur = E(Vt);
        Pz(Ur, {
          class: "size-4",
          onclick: () => {
            he(W, !b(W))
          }
        }), A(Vt), lt(Kr => Br(Vt, "title", Kr), [() => t2()]), H(Jt, Vt)
      };
      et(Ne, Jt => {
        b(fe) && Jt(ze)
      })
    }
    var Ie = $(Ne, 2);
    {
      var We = Jt => {
        var Vt = tL();
        Vt.__click = [eL];
        var Ur = E(Vt);
        Dx(Ur, {
          class: "size-3"
        }), A(Vt), lt(Kr => Br(Vt, "title", Kr), [() => Rx()]), H(Jt, Vt)
      };
      et(Ie, Jt => {
        b(le).name !== "paintingPixel" && Jt(We)
      })
    }
    var ve = $(Ie, 2);
    {
      var Pt = Jt => {
        var Vt = iL();
        Vt.__click = [rL, G];
        var Ur = E(Vt);
        Cz(Ur, {
          class: "size-3"
        }), A(Vt), lt((Kr, bi) => {
          Br(Vt, "title", Kr), Vt.disabled = bi
        }, [() => _1(), () => !Qo.hasPrev()]), An(1, Vt, () => Kn, () => ({
          delay: 1e3,
          duration: 300
        })), An(2, Vt, () => Kn, () => ({
          duration: 300
        })), H(Jt, Vt)
      };
      et(ve, Jt => {
        Qo.hasPrev() && b(le).name !== "paintingPixel" && Jt(Pt)
      })
    }
    A(ye);
    var Xt = $(ye, 2);
    let Ei;
    var Nt = E(Xt);
    {
      var Ht = Jt => {
        var Vt = nL(),
          Ur = E(Vt);
        Bx(Ur, {
          class: "size-5"
        });
        var Kr = $(Ur);
        A(Vt), lt(bi => Te(Kr, ` ${bi??""}`), [() => y1()]), An(1, Vt, () => Kn, () => ({
          duration: 1e3
        })), An(2, Vt, () => Kn), H(Jt, Vt)
      };
      et(Nt, Jt => {
        ci.online || Jt(Ht)
      })
    }
    var or = $(Nt, 2);
    {
      var ri = Jt => {
        var Vt = sL();
        Vt.__click = [aL, G, _];
        var Ur = E(Vt);
        xz(Ur, {
          class: "size-5"
        });
        var Kr = $(Ur);
        A(Vt), lt(bi => Te(Kr, ` ${bi??""}`), [() => w1()]), An(3, Vt, () => Kn, () => ({
          duration: 300
        })), H(Jt, Vt)
      };
      et(or, Jt => {
        b(ie) < F && Jt(ri)
      })
    }
    A(Xt);
    var ti = $(Xt, 2);
    let si;
    var Wr = E(ti);
    bt(Wr), A(ti);
    var Cr = $(ti, 2);
    let vr;
    var ii = E(Cr);
    {
      var Hi = Jt => {
          jv(Jt, {
            class: "z-30",
            onclick: () => {
              var Vt;
              (Vt = Ot.data) != null && Vt.needsPhoneVerification ? (he(Lt, !0), Zr.warning(Tg())) : Ot.charges !== void 0 && Ot.charges < 1 ? Zr.warning(BA, {
                icon: wz
              }) : b(G) && Ot.data ? (ha.smallDropplet.play(), he(le, {
                name: "paintingPixel"
              }, !0)) : (he(xe, !0), b(G) && qa(b(G).getCenter(), b(ie)))
            },
            get disabled() {
              return Ot.loading
            },
            get loading() {
              return Ot.loading
            },
            get charges() {
              return Ot.charges
            }
          })
        },
        je = Jt => {
          var Vt = oL();
          H(Jt, Vt)
        };
      et(ii, Jt => {
        b(le).name === "mainMenu" ? Jt(Hi) : Jt(je, !1)
      })
    }
    A(Cr);
    var Ut = $(Cr, 2);
    let Xi;
    var nr = E(Ut);
    Rt(nr), A(Ut);
    var Gr = $(Ut, 2);
    {
      var Xr = Jt => {
        var Vt = sr(),
          Ur = Et(Vt);
        {
          var Kr = Yr => {
              var wi = lL(),
                Fi = E(wi),
                Ci = E(Fi);
              E8(Ci, {
                get latLon() {
                  return b(le).latLon
                },
                get map() {
                  return b(G)
                },
                get crosshair() {
                  return b(Q)
                },
                get pixelInfoCache() {
                  return K
                },
                get season() {
                  return o
                },
                get tileSize() {
                  return T
                },
                get pixelArtZoom() {
                  return _
                },
                get zoom() {
                  return b(ie)
                },
                get opaquePixelArt() {
                  return b(rt)
                },
                onclose: () => he(le, {
                  name: "mainMenu"
                }, !0),
                onclickshare: zi => {
                  he(cr, zi, !0), he(At, !0)
                },
                onclickpaint: ([zi, Li]) => {
                  var an, Jn, Ki;
                  if (!Ot.data) {
                    he(xe, !0);
                    return
                  }
                  if ((an = Ot.data) != null && an.needsPhoneVerification) {
                    he(Lt, !0), Zr.warning(Tg());
                    return
                  }
                  if (Ot.charges !== void 0 && Ot.charges < 1) {
                    Zr.warning(k1());
                    return
                  }
                  const vi = lm(z.latLonToPixelBoundsLatLon(zi, Li, _));
                  (Jn = b(G)) == null || Jn.flyTo({
                    center: {
                      lat: vi[0],
                      lon: vi[1]
                    }
                  }), he(le, {
                    name: "paintingPixel",
                    clickedLatLon: [zi, Li]
                  }, !0), (Ki = b(Q)) == null || Ki.clear()
                },
                onclickregion: zi => {
                  he(Mt, zi, !0), he(ot, !0)
                }
              }), A(Fi), A(wi), An(3, Fi, () => df, () => ({
                duration: 100
              })), H(Yr, wi)
            },
            bi = Yr => {
              var wi = sr(),
                Fi = Et(wi);
              {
                var Ci = Li => {
                    var vi = cL(),
                      an = E(vi),
                      Jn = E(an);
                    Nk(Jn, {
                      get map() {
                        return b(G)
                      },
                      get clickedLatLon() {
                        return b(le).clickedLatLon
                      },
                      get tileSize() {
                        return T
                      },
                      get tileZoom() {
                        return _
                      },
                      get season() {
                        return o
                      },
                      get zoom() {
                        return b(ie)
                      },
                      get crosshair() {
                        return b(re)
                      },
                      refreshPixelArt: () => b(G) && $e(b(G)),
                      hidePixelHover: dt,
                      hoverLayerId: Oe,
                      onclose: () => {
                        he(le, {
                          name: "mainMenu"
                        }, !0), dt()
                      },
                      get screenLocked() {
                        return b(de)
                      },
                      set screenLocked(Ki) {
                        he(de, Ki, !0)
                      },
                      get opaquePixelArt() {
                        return b(rt)
                      },
                      set opaquePixelArt(Ki) {
                        he(rt, Ki, !0)
                      }
                    }), A(an), A(vi), An(3, an, () => df, () => ({
                      duration: 100
                    })), H(Li, vi)
                  },
                  zi = Li => {
                    var vi = sr(),
                      an = Et(vi);
                    {
                      var Jn = Ki => {
                        var Jr = hL(),
                          Qn = E(Jr),
                          oa = E(Qn),
                          pa = E(oa),
                          os = E(pa),
                          Ps = E(os);
                        Zv(Ps, {
                          class: "inline size-4"
                        });
                        var Vn = $(Ps);
                        A(os);
                        var ea = $(os, 2);
                        ea.__click = [uL, le];
                        var ni = E(ea);
                        pc(ni, {
                          class: "size-4"
                        }), A(ea), A(pa);
                        var Ua = $(pa, 2),
                          La = E(Ua);
                        La.__click = async () => {
                          var Yi;
                          if (b(le).name === "selectHq") {
                            const Oi = b(le).hq;
                            if (Oi) try {
                              he(er, !0), await ci.updateAllianceHeadquarters(Oi[0], Oi[1]), (Yi = b(Q)) == null || Yi.clear(), he(tt, !0), he(le, {
                                name: "mainMenu"
                              }, !0)
                            } catch (hn) {
                              Zr.error(hn.message)
                            } finally {
                              he(er, !1)
                            }
                          }
                        };
                        var co = E(La);
                        dz(co, {
                          class: "size-6"
                        }), A(La), A(Ua), A(oa), A(Qn), A(Jr), lt(Yi => {
                          Te(Vn, ` ${Yi??""}`), La.disabled = b(le).hq === void 0 || b(er)
                        }, [() => rC()]), An(3, Qn, () => df, () => ({
                          duration: 100
                        })), H(Ki, Jr)
                      };
                      et(an, Ki => {
                        b(le).name === "selectHq" && Ki(Jn)
                      }, !0)
                    }
                    H(Li, vi)
                  };
                et(Fi, Li => {
                  b(le).name === "paintingPixel" && b(re) ? Li(Ci) : Li(zi, !1)
                }, !0)
              }
              H(Yr, wi)
            };
          et(Ur, Yr => {
            b(le).name === "pixelSelected" && b(Q) ? Yr(Kr) : Yr(bi, !1)
          })
        }
        H(Jt, Vt)
      };
      et(Gr, Jt => {
        b(G) && Jt(Xr)
      })
    }
    A(Tr), lt((Jt, Vt, Ur, Kr, bi, Yr, wi, Fi, Ci) => {
      Zt = Vr(Dr, 1, "absolute right-2 top-2 z-30", null, Zt, Jt), hi = Vr(Fr, 1, "flex flex-col gap-4", null, hi, Vt), gi = Vr(ye, 1, "absolute left-2 top-2 z-30 flex flex-col gap-3", null, gi, Ur), Br(se, "title", Kr), Br(we, "title", bi), Ei = Vr(Xt, 1, "absolute left-1/2 top-2 z-30 flex -translate-x-1/2 flex-col items-center justify-center gap-2", null, Ei, Yr), si = Vr(ti, 1, "absolute bottom-3 left-3 z-30", null, si, wi), vr = Vr(Cr, 1, "absolute bottom-3 left-1/2 z-30 -translate-x-1/2", null, vr, Fi), Xi = Vr(Ut, 1, "absolute bottom-3 right-3 z-30", null, Xi, Ci)
    }, [() => ({
      hidden: b(W)
    }), () => ({
      "items-end": !Ot.data,
      "items-center": Ot.data
    }), () => ({
      hidden: b(W)
    }), () => u1(), () => p1(), () => ({
      hidden: b(W)
    }), () => ({
      hidden: b(W)
    }), () => ({
      hidden: b(W)
    }), () => ({
      hidden: b(W)
    })])
  }
  var gt = $(Tr, 2);
  EA(gt, {
    get open() {
      return b(xe)
    },
    set open(bt) {
      he(xe, bt, !0)
    }
  });
  var hr = $(gt, 2);
  uz(hr, {
    get open() {
      return b(ce)
    },
    set open(bt) {
      he(ce, bt, !0)
    }
  });
  var xr = $(hr, 2);
  CM(xr, {
    get open() {
      return b(Be)
    },
    set open(bt) {
      he(Be, bt, !0)
    }
  });
  var ai = $(xr, 2);
  FM(ai, {
    get open() {
      return b(Ke)
    },
    set open(bt) {
      he(Ke, bt, !0)
    }
  });
  var ki = $(ai, 2);
  bM(ki, {
    get open() {
      return b(yt)
    },
    set open(bt) {
      he(yt, bt, !0)
    }
  });
  var _i = $(ki, 2);
  MA(_i, {
    onvisitclick: bt => {
      var Rt;
      (Rt = b(G)) == null || Rt.flyTo({
        center: bt,
        zoom: xg + 1
      }), qa(bt, b(ie)), Qo.push({
        pos: bt,
        zoom: b(ie)
      }), he(Ee, !1)
    },
    get open() {
      return b(Ee)
    },
    set open(bt) {
      he(Ee, bt, !0)
    }
  });
  var _r = $(_i, 2);
  u8(_r, {
    get region() {
      return b(Mt)
    },
    get open() {
      return b(ot)
    },
    set open(bt) {
      he(ot, bt, !0)
    }
  });
  var Ti = $(_r, 2);
  Ax(Ti, {
    get open() {
      return aa.dropletsDialogOpen
    },
    set open(bt) {
      aa.dropletsDialogOpen = bt
    }
  });
  var Ar = $(Ti, 2);
  {
    var qr = bt => {
      QI(bt, {
        onhqchange: () => {
          he(le, {
            name: "selectHq"
          }, !0), he(tt, !1)
        },
        onhqclick: Rt => {
          var Zt;
          (Zt = b(G)) == null || Zt.flyTo({
            center: Rt,
            zoom: Math.max(b(ie), 15)
          }), he(le, {
            name: "pixelSelected",
            latLon: [Rt.lat, Rt.lng]
          }, !0), he(tt, !1)
        },
        onlastpixelclick: Rt => {
          var Zt;
          (Zt = b(G)) == null || Zt.flyTo({
            center: Rt,
            zoom: Math.max(b(ie), 15)
          }), he(le, {
            name: "pixelSelected",
            latLon: [Rt.lat, Rt.lng]
          }, !0), he(tt, !1)
        },
        get open() {
          return b(tt)
        },
        set open(Rt) {
          he(tt, Rt, !0)
        }
      })
    };
    et(Ar, bt => {
      b(G) && bt(qr)
    })
  }
  var fi = $(Ar, 2);
  aE(fi, {
    get open() {
      return b(Lt)
    },
    set open(bt) {
      he(Lt, bt, !0)
    }
  });
  var nn = $(fi, 2);
  {
    var un = bt => {
      fM(bt, {
        get url() {
          return b(cr)
        },
        get map() {
          return b(G)
        },
        hideHover: () => {
          var Rt, Zt;
          (Rt = b(G)) == null || Rt.setPaintProperty(Oe, "raster-opacity", 0), (Zt = b(Q)) == null || Zt.setCanvasOpacity(0)
        },
        showHover: () => {
          var Rt, Zt;
          (Rt = b(G)) == null || Rt.setPaintProperty(Oe, "raster-opacity", nt), (Zt = b(Q)) == null || Zt.setCanvasOpacity(1)
        },
        get open() {
          return b(At)
        },
        set open(Rt) {
          he(At, Rt, !0)
        }
      })
    };
    et(nn, bt => {
      b(G) && bt(un)
    })
  }
  H(y, Ir), Er()
}
en(["click"]);
export {
  FL as component
};